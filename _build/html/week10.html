

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>11. Week 10 - Uniswap &mdash; Plutus Pioneer Program Lecture Notes  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="10. Week 09 - Marlowe" href="week9.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Plutus Pioneer Program Lecture Notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="week1.html">2. Week 01 - Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="week2.html">3. Week 02 - Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="week3.html">4. Week 03 - Script Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="week4.html">5. Week 04 - Monads</a></li>
<li class="toctree-l1"><a class="reference internal" href="week5.html">6. Week 05 - Native Tokens</a></li>
<li class="toctree-l1"><a class="reference internal" href="week6.html">7. Week 06 - Oracles</a></li>
<li class="toctree-l1"><a class="reference internal" href="week7.html">8. Week 07 - State Machines</a></li>
<li class="toctree-l1"><a class="reference internal" href="week8.html">9. Week 08 - Property Based Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="week9.html">10. Week 09 - Marlowe</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">11. Week 10 - Uniswap</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-is-uniswap">11.1. What is Uniswap</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Plutus Pioneer Program Lecture Notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">11. </span>Week 10 - Uniswap</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/week10.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="week-10-uniswap">
<h1><span class="section-number">11. </span>Week 10 - Uniswap<a class="headerlink" href="#week-10-uniswap" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These is a written version of <a class="reference external" href="https://youtu.be/Dg36h9YPMz4">Lecture
#10</a>.</p>
<p>In this lecture we look at an implementation of Uniswap in Plutus.</p>
<p>This is the last lecture in the Plutus Pioneer Program. However, there will be a special lecture once it is possible to deploy contracts to the testnet.</p>
</div>
<p>In this lecture we won’t be introducing any new topics or concepts. Instead we will do an end-to-end walk through of a demo that Lars wrote some months ago that
clones the very popular Uniswap contract from Ethereum.</p>
<p>The one new thing we will look at following several requests is how you can query the endpoints created by the PAB with Curl commands just from the console.</p>
<div class="section" id="what-is-uniswap">
<h2><span class="section-number">11.1. </span>What is Uniswap<a class="headerlink" href="#what-is-uniswap" title="Permalink to this headline">¶</a></h2>
<p>So for those of you who haven’t heard of Uniswap, what is Uniswap?</p>
<p>Uniswap is a so-called DeFi, or decentralized finance application, that allows swapping of tokens without any central authority. In
the case of Ethereum it’s ERC20 tokens.</p>
<p>So you don’t need a centralized exchange, the traditional way to exchange tokens or other crypto assets. Instead everything is governed by
smart contracts and works fully automatically on the blockchain.</p>
<p>Another interesting feature of Uniswap is that it doesn’t discover prices the usual way with the so-called order book, but uses a different
automatic price discovery system. The idea is that people can create so-called liquidity pools.</p>
<p>If they want other users to be able to swap two different tokens, then somebody can create a liquidity pool and put a certain amount of those two tokens
in this liquidity pool, and in return the creator of the pool will receive so-called liquidity tokens that are specific to this one pool.</p>
<p>Other users can use that pool to swap. They take some amount of one of the tokens out in exchange for putting an amount of the other token back in.</p>
<p>Additionally, people can also add liquidity to the pool and receive liquidity tokens, or they can also burn liquidity tokens in exchange for tokens from the pool.</p>
<p>And all these features are also implemented in the version of Uniswap that works on Cardano that we’re going to look at now.</p>
<div class="figure align-default">
<img alt="_images/pic__00149.png" src="_images/pic__00149.png" />
</div>
<p>So let’s look at the various operations that are available in turn.</p>
<p>It all starts by somebody setting up the whole system. So some organization or entity that wants to offer this Uniswap service.</p>
<p>It starts with a transaction that creates a UTxO at this script address, here we call that <em>factory</em> for Uniswap factory. It contains an NFT that identifies the factory,
the same trick that we have used a couple of times before, and as datum, it will contain the list of all liquidity pools.</p>
<p>So in the beginning, when the factory is just being created, that list will be empty.</p>
<p>Now let’s assume that one user, Alice wants to create a liquidity pool for tokens A and B. A pool that allows others to swap A against B or B against A.</p>
<div class="figure align-default">
<img alt="_images/pic__00150.png" src="_images/pic__00150.png" />
</div>
<p>She has to provide some initial liquidity for the pool. So she needs some amount of token A and some amount of token B, let’s say she has 1,000A and 2000B.</p>
<p>It’s important to note here that the ratio between A and B reflects Alice’s belief in the relative value of the tokens. So if she wants to set up a pool with
1000A and 2000B, then she believes that one A has the same value as two Bs.</p>
<p>In order to create the liquidity pool, she will create a transaction with two inputs and three outputs.</p>
<div class="figure align-default">
<img alt="_images/pic__00151.png" src="_images/pic__00151.png" />
</div>
<p>The two inputs will be the liquidity she wants to provide; the 1000A and 2000B and the Uniswap factory invoked with the create redeemer. The three outputs
will be the newly-created pool.</p>
<p>We call it <em>Pool AB</em> here to indicate that it contains tokens AB, which will contain the liquidity that Alice provided; the 1000A and the 2000B and a freshly-minted
token that identifies this pool, an NFT, called <em>AB NFT</em> here.</p>
<p>The datum of the pool, the 1415, will be the amount of liquidity tokens that Alice receives in return for setting up this pool and providing the liquidity. #</p>
<p>If you wonder about the number, that is the square root of the product of 1000 and 2000, so that’s how the initial amount of liquidity tokens is calculated. It
doesn’t really matter, you could scale it arbitrarily, but that’s the way Uniswap does it.</p>
<p>The second output is the Uniswap factory again, with the same NFT as before that identifies it. And now the datum has been updated. So in this list that was
empty before, the list of all liquidity pools, there is now an entry for the newly-created AB pool.</p>
<p>Finally, there’s a third output for Alice, where she receives the freshly-minted liquidity tokens, called <em>AB</em> here to indicate that they belong to the pool AB.</p>
<p>Now that the liquidity pool has been set up, other users can use it to swap.</p>
<div class="figure align-default">
<img alt="_images/pic__00152.png" src="_images/pic__00152.png" />
</div>
<p>So let’s assume that Bob wants to swap 100A against B. What will Bob do?</p>
<p>He will create a transaction that has two inputs and two outputs. The two inputs are the 100A he wants to swap, and the pool with the swap redeemer. The outputs
are the Bs he gets in return.</p>
<p>In this example, that would be 181B and the updated pool. So the pool now has the additional 100A that Bob provided. So now it’s 1,100A, and it has 181B fewer than before.</p>
<p>It still, of course, has the NFT that identifies the pool and the datum hasn’t changed because the amount of liquidity tokens that have been minted hasn’t changed.</p>
<p>Now, of course, the question is, where does this 181 come from? This is this ingenious idea, how price discovery works in Uniswap.</p>
<p>So the rule is roughly that the product of the amounts of the two tokens must never decrease. Initially we have 1000 As and 2000 Bs and the product is 2 million.</p>
<p>If you do the calculation, then you will see that after the swap 1100*1819 will be slightly larger than 2 million.</p>
<p>If you think about it or try a couple of examples by yourself, then you will see that in principle, you will always pay this ratio of the As and Bs in the pool, at least if you swap small amounts.</p>
<p>So originally the ratio from A to B was 1:2, 1000:2000. 100 is relatively small in comparison to the 1000 liquidity, so Bob should roughly get 200B, but he does get less
and there are two reasons for that.</p>
<p>One is that the amount of tokens in the liquidity pool is never allowed to go to zero. And the more of one sort you take out, the more expensive it gets -
the less you get in return. So 100 depletes the pool a bit of As, so Bob doesn’t get the full factor 2 out, he gets a little bit less out. That’s exactly how this product formula works.</p>
<p>This also makes it ingenious, because it automatically accounts for supply and demand. If the next person also wants to swap 100A, they would get even less out.</p>
<p>The idea is if a lot of people want to put A in and want to get B in return, that means the demand for B is high. And that means the price of B in relation to A
should rise. And that is exactly what’s happening.</p>
<p>So the more people do a swap in this direction, put A in and get B out, the less of the gap because the price of B rises. If there were swaps in the other direction,
you would have the opposite effect.</p>
<p>If there’s an equal amount of swaps from A to B and B to A, then this ratio between the two amounts would stay roughly the same.</p>
<p>There’s an additional reason why Bob doesn’t get the full 200 that he might expect, and that is fees.</p>
<p>We want to incentivize Alice to set up the pool in the first place. She won’t just do that for fun, she wants to profit from it, so she wants to earn on swaps that people make.</p>
<p>The original product formula is modified a bit to insist that the product doesn’t only not decrease, but that it increases by a certain amount, a certain percentage,
depending on how much people swap. That’s 3% in this example of the 100A that Bob swaps, and it would be the same if you swap B instead.</p>
<p>This is basically added on top of this product, so anytime somebody swaps, not only does the product not decrease, it actually increases. And the more people swap, the more it increases.</p>
<p>The idea is that if Alice now would close the pool by burning her liquidity tokens, she gets all the remaining tokens in the pool and the product
would be higher than what she originally put in.</p>
<p>So that’s her incentive to set up the pool in the first place.</p>
<p>The next operation we look at is the add operation where somebody supplies the pool with additional liquidity.</p>
<div class="figure align-default">
<img alt="_images/pic__00153.png" src="_images/pic__00153.png" />
</div>
<p>So let’s say that Charlie also believes that the ratio from A to B should be 1:2 and he wants to contribute 400A and 800B.
He could also have tokens in a different ratio.
Basically the ratio reflects his belief in the true relative value of the tokens.
So Charlie wants to add 400 As and 800 Bs, and he creates a transaction
with two inputs and two outputs.
The inputs are the pool and his contribution, his additional liquidity
and the outputs are the updated pool where now his As and Bs have
been added to the pool tokens and note that now the datum has changed.
So we had 1,415 liquidity tokens before, and now we have 1,982, and
the difference the 567 go to Charlie.
So that’s the second output of this transaction.
And that’s the reward to Charlie for providing this liquidity,
this additional liquidity.
And there the formula is a bit complicated, but in principle,
it also works with the product.
So you check how much the product was before and after
the tokens have been added.
And you take into account, how many have already been minted?
And that also ensures that now basically Alice profits from the fees that Bob
paid with the swap and Charlie doesn’t.
So this is taking into account, but the specific formula doesn’t matter.
The idea is just that it’s fair.
So people should receive liquidity tokens proportional to their contribution,
but, if they only add liquidity after a couple of swaps have already happened,
then they shouldn’t profit from the fees that have accumulated in the meantime.
The next operation we look at is called removed and it allows owners of liquidity
tokens for a pool to burn some of them.</p>
<div class="figure align-default">
<img alt="_images/pic__00154.png" src="_images/pic__00154.png" />
</div>
<p>So in this example, let’s assume that Alice wants to
burn all her liquidity tokens.
She could also keep some, she doesn’t have to burn on, but in this example, she wants
to burn all her 1,415 liquidity tokens.
So for that, she creates another transaction with two inputs and
two outputs, the inputs are the liquidity token she wants to burn.
And of course the pool again with the remove redeemer.
And The outputs are the tokens from the pool that she receives
in return, so in this case, she would get 1078 A and 1,869 B.
And the updated pool is the second output.
So the 1078 A and 1,869 Bs have been removed from the pool and the datum has
been updated, so the 1,415 liquidity tokens that Alice burnt are now
subtracted from the 1,982 we had before.
And we see that 567 are remaining which are exactly those that Charlie owns.
And the formula for how many tokens Alice gets for burning liquidity
tokens, is again, somewhat complicated, but it’s basically just proportional.
So we know how many liquidity tokens there are in total 1,982 from the datum.
And she basically just gets 1,415 over 1,982 of the pool.
And she gets the tokens in the ratio that they are in now.
So the 1072, 1,869 should be the same ratio as the 1,500 to 2,619.
So by burning, you don’t change the ratio of the pool.
The last operation is close and it is for completely closing a pool and removing it.</p>
<div class="figure align-default">
<img alt="_images/pic__00155.png" src="_images/pic__00155.png" />
</div>
<p>And this can only happen when the last remaining liquidity tokens are burnt.
So in our example, Charlie holds all the remaining 567 liquidity tokens, and
therefore he can close down the pool.
And in order to do that, he creates a transaction with three inputs.
One is the factory and note that we only involve the factory when we created the
pool and now when we close it again, which also means that the contention
on the factory is not very high.
So the factory only gets involved when new pools are created, when pools are
closed down, but once they exist and as long as they are not closed, the
operations are independent of the factory.
But if you just need the factory, when we want to update the list
of existing pools, and by the way, this list is used to ensure that
there won’t be duplicate pools.
So the create operation that we looked at in the beginning will fail if somebody
tries to create a pool that already exists for a pair of tokens that already exist.
So there will always for any given pair of tokens, be at most one pool
that country against those two tokens.
Okay, so let’s go back to the close operation.
So the first input is the factory with the close redeemer, second the input
is the pool that we want to close.
And third input are all the remaining liquidity tokens, and we get two
outputs, one is the updated factory.
So in this case we only had one pool.
So the list only contains this one pool, and this is now removed from the
list, and the second output contains of all the remaining tokens, all the
tokens that were still in the pool by the time it gets closed down.
So the remaining liquidity tokens are burnt and Charlie gets all the
remaining tokens from the pool.</p>
<div class="figure align-default">
<img alt="_images/pic__00157.png" src="_images/pic__00157.png" />
</div>
<p>Code for Uniswap is actually part of the Plutus repository and it is in the Plutus
use cases library, and it split into four modules that are imported by the
Plutus dot contracts dot Uniswap module.
On-chain, off-chain, types and pool.
So as the names suggest:
on-chain contains the on-chain validation.
Off-chain contains the off-chain contracts.
Types contains common types that the other shares.
And pool contains the business logic, the calculations, how many liquidity tokens
the creator of a pool gets, how many tokens you get when you add liquidity
to a pool, how many tokens you get back when you burn liquidity tokens and
under which conditions a swap is valid.
So I don’t want to go through all of that in too much detail.
It contains nothing we haven’t talked about before, but let’s
at least have a brief look.
So let’s look at the types module first.
You represents the Uniswap coin, the one that identifies the factory</p>
<div class="figure align-default">
<img alt="_images/pic__00159.png" src="_images/pic__00159.png" />
</div>
<p>A and
B are used for pool operations where we have these two sorts of tokens inside
the pool,</p>
<div class="figure align-default">
<img alt="_images/pic__00160.png" src="_images/pic__00160.png" />
</div>
<p>pool state is the token that identifies a pool, actually in the
diagram earlier I said it’s an NFT.
And by definition, NFT is something that only exists once actually here in the
implementation for each pool, an identical coin is created that identifies that pool.
So it’s not strictly speaking NFT.
So all the liquidity pools have one coin of that sort</p>
<div class="figure align-default">
<img alt="_images/pic__00161.png" src="_images/pic__00161.png" />
</div>
<p>and liquidity
is used for the liquidity tokens that the liquidity providers gets.</p>
<div class="figure align-default">
<img alt="_images/pic__00162.png" src="_images/pic__00162.png" />
</div>
<p>And all these types are then used in the coin A type.
So A is a type parameter, that’s a so-called Phantom type.
So that means it has no representation at run time.
It’s just used to not mix up the various coins to make it easier to see what goes
where, so in the datum, a coin is simply an asset class that we have seen before.
So asset class recall is a combination of currency symbol and token name.</p>
<div class="figure align-default">
<img alt="_images/pic__00163.png" src="_images/pic__00163.png" />
</div>
<p>then amount is just a wrapper around integer that also contains
such a Phantom type parameter, so that we don’t confuse amounts for
token A and token B for example.</p>
<div class="figure align-default">
<img alt="_images/pic__00164.png" src="_images/pic__00164.png" />
</div>
<p>Then we have some helper functions, constructing a
value from coin and the amount.
And here, for example, we see the use of this Phantom type, that’s actually a
common trick in Haskell because now if you have, for example, pool operations
that has two different coins and two different amounts for the different coins.
And if the one is tag with this type capital A and the other with capital
B, then normally one could easily confuse them and somehow do operations
with the one coin, with the amount for the other, and then make a mistake.
And here the type system enforces that we don’t do that.
So we can only use this value of function, for example, if we a coin and
the amount with the same tag type tag.
So as I said, that’s a common trick in Haskell that some lightweight type
level programming that is doesn’t need any fancy GHC extensions.
Unit Value creates one amount of the given coin.
Is unity checks whether this coin is contained in the value exactly once,
then amount checks how often the coin is contained in the value, and
finally make coin turns a currency symbol into a token name, into a coin.</p>
<div class="figure align-default">
<img alt="_images/pic__00165.png" src="_images/pic__00165.png" />
</div>
<p>And we have the Uniswap type which identifies the instance of the
Uniswap system we are running.
So of course, nobody can stop anybody from setting up a competing Uniswap system with
the competing factory, but the value of this type identifies a specific system.
And all the operations that are specific to pool will be parameterized
by a value of this type, but it’s just a wrapper around the coin U.
And that is just the NFT that identifies the factory.</p>
<div class="figure align-default">
<img alt="_images/pic__00166.png" src="_images/pic__00166.png" />
</div>
<p>Then we have a type for liquidity pools, and that is basically just
two coins, the two coins in there.</p>
<p>However, there is one slight complication, only the two types
of tokens inside the pool matter.</p>
<div class="figure align-default">
<img alt="_images/pic__00167.png" src="_images/pic__00167.png" />
</div>
<p>Not the order, there is no first or second token, a pool that has coin
A, A and coin B, B should be the same as one where A and B are swapped.
And in order to achieve that, the eq instance has a special implementation.
So it’s not the standard, we don’t just compare if we want to compare two
liquidity pools, we don’t just compare the first field with the first field of
other, and the second with the second, but we also try the other way round.
So liquidity pool tokens AB would be the same as liquidity pool with tokens BA.
So that’s the only slight complication here.</p>
<div class="figure align-default">
<img alt="_images/pic__00168.png" src="_images/pic__00168.png" />
</div>
<p>Then we define the actions, that’s basically the redeemers.
So create with argument liquidity pool is for creating a new liquidity
pool closes for closing one, swap is for swapping, remove is for removing
liquidity and add is for adding liquidity.
Note that in the diagrams I showed earlier for simplicity, I
called the redeemer simply create.
So I didn’t mention this argument of type liquidity pool.</p>
<div class="figure align-default">
<img alt="_images/pic__00170.png" src="_images/pic__00170.png" />
</div>
<p>The datum is a bit more complex than we have seen before.
So it’s not just a simple integer or similarly simple
type, it’s a type Uniswap datum.
And there are two constructors, one for the factory and one for each pool.
So the factory will use the factory constructor and the pool
will use the pool constructor.
And as I explained before, the datum contains…
for the factory contains a list of all liquidity pools that currently exist.
And the datum for pool contains the liquidity pool that I
didn’t mention in the diagram.
And what I did mention in the diagram, it contains the amount of liquidity
that has been minted for this pool.
Remember that gets updated when somebody adds liquidity or removes liquidity.</p>
<div class="figure align-default">
<img alt="_images/pic__00172.png" src="_images/pic__00172.png" />
</div>
<p>Next let’s look at the pool module, which as I explained before, contains
the business logic, the calculations.
So we have calculate initial liquidity.
It gets the initial amount of token A and B that I put into the pool and
returns the liquidity tokens that are returned in exchange for those.
Then calculate additional liquidity for the case that the pool already exists and
somebody provides additional liquidity.
So the first two arguments are the amount of token already in there.
Then the third one is the liquidity that has already been
minted for the pool, the…
not the liquidity, the liquidity tokens that have already been minted.
And the next two arguments are how many As and Bs are added to the pool.
And the result is how many liquidity tokens will be minted in exchange
for this additional amount.
That’s additional liquidity.</p>
<div class="figure align-default">
<img alt="_images/pic__00173.png" src="_images/pic__00173.png" />
</div>
<p>Calculate removal is for the opposite case.
So given how many tokens are in the pool how much liquidity
tokens have been minted.
How many liquidity tokens to be removed?
It gives how many token’s A and B remain in the pool.
Check swap is arguably the central function of the whole
Uniswap system, calculates a swap.
So this, and this is how many As and Bs are originally in the pool and
this and this says how many As and Bs are after the swap in the pool.
And it just returns whether that’s okay or not.
So in principle, it just checks that the product of the last two arguments is
larger than the product of the first two.
And as I explained before, it’s a bit more complicated because
the fee is taken into account.
So in this case, it’s Oh, 0.3%.
So you can see this is taking into account here.</p>
<div class="figure align-default">
<img alt="_images/pic__00175.png" src="_images/pic__00175.png" />
</div>
<p>It also makes sure that none of the amounts ever drops to zero.
So it’s not allowed to remove all coins, have one sort or both from a pool.
And that also makes sense because of this product, if one of the
factors was zero, then of course it couldn’t be larger than it was before.
Finally, there’s this LP ticker function.
It’s just a helper function that given a liquidity pool, computes a
token name for the liquidity token.
And the idea here is that this token name should only depend on the
liquidity pool and should be unique.
So each pair of tokens should result in a unique token name.
And in principle it just takes the currency symbols and the token names of
the two tokens or coins, concatenates all of them and hashes that, and then uses
the hash of the concatenation just to get something unique and a slight complication
is here that again must make sure that the order of coins in the pool doesn’t matter.
So this way there’s a condition here.
So it’s checked that they are sorted and if they are not
sorted, then you swap them around.
So the, this function should return the same token name for liquidity pool
with token A and B and for liquidity pool, with token B and A which also
corresponds to what I said earlier about equality for liquidity pools.</p>
<div class="figure align-default">
<img alt="_images/pic__00176.png" src="_images/pic__00176.png" />
</div>
<p>Now let’s look at the on-chain part.
Only two functions are exported to make the validator for the Uniswap
both factory and pools, because they share the same script address.
They address distinguished by the datum and by the coins that identify
them and validate liquidity forging.
So that’s the monetary policy script for the liquidity tokens, but there…
it’s a lot of code in this module.
And as I said, I don’t want to go through it in detail, let’s
rather look at the structure.</p>
<div class="figure align-default">
<img alt="_images/pic__00178.png" src="_images/pic__00178.png" />
</div>
<p>So this is the make Uniswap validator function.
And this function contains all the cases for factories and
pools and the various redeemers.
And we have the function validated liquidity forging, which is the
monetary policy for liquidity tokens.
And the idea here is that it doesn’t contain any logic and simply delegates
the logic to the Uniswap validator.
And the way it does that is it checks the inputs of the forging transaction
and checks that it’s either contains a factory or contains a pool, because if
it does, then this validator will run.
We know that this validator will run and then the validator can
check that the forging is okay.
And the way it does check with the…
Either the factory bool is an input is why are the coins that
identify a factory or pool?
So it checks whether this Uniswap factory coin is in the input or whether
one of the pool coins is in the input.
And then we just have helper functions for all the various
cases and they haven’t looked quite long but it’s all straightforward.
And it’s basically what I explained in the diagram, just spelled out in
detail that all these conditions are satisfied for all the different cases.</p>
<div class="figure align-default">
<img alt="_images/pic__00179.png" src="_images/pic__00179.png" />
</div>
<p>One thing I should mention is I didn’t use state machines
and I’m not sure it’s possible.
I was thinking about that and it wasn’t obvious to me, the problem
is, I mean, one should think that both the factory and the individual
pools behave like state machines.
I mean, they are identified by their tokens and they are these
legal transitions and then the data gets updated and so on.
But the problem are, is that sometimes we have both of them invoice the
factory and one of the pools.
And it’s not obvious to me whether that’s possible with the
current state machine machinery.
So I basically did it by hand and I’ve wrote this.</p>
<div class="figure align-default">
<img alt="_images/pic__00181.png" src="_images/pic__00181.png" />
</div>
<p>Finally, let’s look at the off-chain code.
Also no surprises here, it’s the usual boiler plate</p>
<div class="figure align-default">
<img alt="_images/pic__00182.png" src="_images/pic__00182.png" />
</div>
<p>, be
defined two different schemas.
The idea is that one is for the entity that creates the Uniswap factory.
And that only has one endpoint start and no parameters.
And then once that is created a second schema for people that make use of this
Uniswap system, and all the contracts in here will be parameterized by the uniswap
instance that this first action creates.</p>
<div class="figure align-default">
<img alt="_images/pic__00183.png" src="_images/pic__00183.png" />
</div>
<p>we make use of the state mechanism.
So of this monad writer mechanism that is accessible via tell, and basically for
all the user operations, we have our own state, we call it user contract state.
So there will be a helper contract that queries for all existing pools.
So then the state would be using this pools constructor and return a
list of pools in a simplified form, it’s just a nested pair of pairs
of coin and amount in each pool.
Now the helper function to query the existing funds of a wallet that will
just return a value and then construct us for all the other operations.
So if they have happened, then one of those will be the state.
So for example, if we did a swap, then afterwards the status
will be updated to swapped.
If we removed liquidity, it will be updated to removed and so on.</p>
<div class="figure align-default">
<img alt="_images/pic__00184.png" src="_images/pic__00184.png" />
</div>
<p>Then some names for the various tokens, so you need swap for, with the token
name of the NFT in the Uniswap factory, pool state will be the token name for the
coins that identify the liquidity pools.
Then our usual boiler plate to actually get a script instance</p>
<div class="figure align-default">
<img alt="_images/pic__00185.png" src="_images/pic__00185.png" />
</div>
<p>and
the policy for the liquidity tokens.
Some various helper functions,</p>
<div class="figure align-default">
<img alt="_images/pic__00186.png" src="_images/pic__00186.png" />
</div>
<p>then all the parameters for the endpoints.
So for example, if we want to create a pool we need to know
the tokens and the amounts.
If you want to swap, it must know the tokens and how much to swap and
the idea is here that one of these two last fields should be zero.
So if you want to put in A and get our B we’ve would specify the SP amount, how
many As we want to put in, but we would leave the B at zero and the other way
round if we want to swap B against As.
Close if you want to close a pool, we just have to specify which pool.
So we give to two tokens that are in there.
Remove you have to specify the pool and how much liquidity we want to burn and
add again, identify the pool and how many As and how many Bs we want to add.</p>
<div class="figure align-default">
<img alt="_images/pic__00188.png" src="_images/pic__00188.png" />
</div>
<p>Now here we have the implementation.
So start, as I said, sets up the whole system and did again, makes use of this
other use case we have used before, the currency forge contract to mint
this NFT, the factory NFT that’s then used to identify the Uniswap factory.</p>
<div class="figure align-default">
<img alt="_images/pic__00189.png" src="_images/pic__00189.png" />
</div>
<p>Create it’s the contract that creates a liquidity pool.
And we see all of these will be, as I mentioned before, identified
by the Uniswap value, which is the result of this start contract here.
So if we have create,</p>
<div class="figure align-default">
<img alt="_images/pic__00190.png" src="_images/pic__00190.png" />
</div>
<p>we have close, again parameterized by Uniswap</p>
<div class="figure align-default">
<img alt="_images/pic__00191.png" src="_images/pic__00191.png" />
</div>
<p>remove,</p>
<div class="figure align-default">
<img alt="_images/pic__00192.png" src="_images/pic__00192.png" />
</div>
<p>add</p>
<div class="figure align-default">
<img alt="_images/pic__00193.png" src="_images/pic__00193.png" />
</div>
<p>and swap</p>
<p>And all these functions also make use of the functions from the pools
module, that contain the business logic.
So that will be used both in the validator, on the on-chain
side, as well as on the off chain side in these contracts here.</p>
<div class="figure align-default">
<img alt="_images/pic__00194.png" src="_images/pic__00194.png" />
</div>
<p>Pools as I said just curious the existing pools.
So it looks for the factory UTXO and checks the datum of that.
And as we know, the datum of the factory contains the list of all pools.</p>
<div class="figure align-default">
<img alt="_images/pic__00195.png" src="_images/pic__00195.png" />
</div>
<p>And finally funds just checks our own funds, the funds in
the wallet and returns them.</p>
<p>So these all return values or I mean, funds for example returns
value, pools returns a list of this.
But I mentioned earlier, we want to write that in the state, and this is now
done in, in these endpoint definitions.</p>
<div class="figure align-default">
<img alt="_images/pic__00197.png" src="_images/pic__00197.png" />
</div>
<p>So first we have the owner endpoint for setting up the whole system,
which just uses the stop contract.
And then we have the user endpoints, which combined all these
operations that a user can do.
And now there is no return value anymore, and instead we make use of the state.
So we use the last monoid again.
So only the last toll state will be kept.
And we also allow for error.
So if there’s an error in one of these contracts, then we will catch that error,
but use a left to write it in the state.
And if there was no error we write the appropriate user contract
state value in the state with the right constructor for either.
So this is done here.</p>
<div class="figure align-default">
<img alt="_images/pic__00198.png" src="_images/pic__00198.png" />
</div>
<p>Finally, we also have a stop endpoint that simply stops, it doesn’t do anything.
Just, if you look at the definition here at any time you can invoke stop
or one of the others, and if it was one of the others then recursively user
endpoints is called again, but in the case of stop not, so if stop endpoint
is ever called then the contract stops.</p>
<p>There are also tests for Uniswap contained in this Plutus use cases library,
but I don’t want to look at them now.
Let’s rather look at the Plutus PAB path and how you can
write a front-end for Uniswap.
There is actually one also contained in the Plutus repo.
It’s in the Plutus PAB library and there in the examples folder,
so there’s a Uniswap folder that contains the simulation monad path
of, of an example, how to do that.</p>
<div class="figure align-default">
<img alt="_images/pic__00200.png" src="_images/pic__00200.png" />
</div>
<p>And I took this and copied it into our Plutus pioneer program repo and
slightly modified it to make it more suitable for what I wanted to show you.
When we look at the cabal file for this week’s code, there are two executables.
One Uniswap minus PAB, which will run the PAB Memphis solver, and then
one Uniswap minus client, which is a simple console based front-end
for the Uniswap application.</p>
<div class="figure align-default">
<img alt="_images/pic__00201.png" src="_images/pic__00201.png" />
</div>
<p>And you see, in the other modules field there is a module Uniswap
and that’s listed in both.
So that will contain some common definitions that are used by both paths.
So let’s first look at that.
First of all, as I explained when I presented the Oracle demo, we need some
data type that captures the various instances we can run for the wallets.
And in this case, I have three in it.
Hasn’t been mentioned before.
That has nothing specifically to do with Uniswap.
This is just used to create some example tokens and
distribute them in the beginning.
Then Uniswap start correponds to the Uniswap start or Uniswap owner schema that
I showed you just now for setting up the whole system and Uniswap user corresponds
to the other path, to the various endpoints to interact with the system.
And this task construct is parameterized by a value of type Uniswap,
which is the result of starting.
So after having started the system, the result would be of type Uniswap and this
is then needed to parameterize the client.
This is just boiler plate, this is this init contract that
distributes the initial funds.
So it again makes use of the forge contract that we have seen before.
And it now producers tokens with token names A, B, C, D and 1 million of each.
And actually it also multiplies that by the number of wallets.
So in this case, I want to use four wallets, wallets one to four,
it’s actually 4 million of each of the tokens will be forged.
And once they have been forged, I sent from the forging wallet to all the
other wallets, 1 billion of the tokens.
So one wallet forges 4 million of each, and then loops over the other
wallets and sends them 1 million each.
So this is just needed to set up example tokens and distribute
them amongst the wallets.
This is just a helper function because in order to communicate the various
contract instance IDs and other things I need, I just use helper files and this
is the file name for a given wallet.
So now let’s look at the PAB part we will look at the main program in a second,
just this here is the boiler plate I showed you earlier to actually hook up
the PAB mechanism with actual contracts.
So this is all boiler plate, and it uses this Uniswap contracts that are justified
with the three constructors in it Uniswap start and Uniswap user, and in this
part, this is linked with the schema.
So Uniswap user will use the Uniswap user schema that we defined before.
Uniswap start will use the Uniswap owner schema that we defined before and in it
we’ll use a schema without endpoints.
And this part here connects these constructors with actual contracts.
So Uniswap user with argument US will use the user endpoints that we looked
at earlier Uniswap start will use the owner endpoint that we looked at earlier.
And init will use the init contract that we just defined in the Uniswap
that’s just for demonstration to create these initial coins.
This here is again boiler plate.
Now we can look at the main program.
So in the simulator monad, we execute certain things.
So first we set up the whole system, we start the server and get
the handle to shut it down again.
And then in the end we just wait until the user types a key
and then we shut it down again.
Okay.
So first thing we do is wallet one activates this init contract.
So we know from looking at the code what that will do, it will mint all
these example tokens, ABCD, 4 million of each, and then distribute them.
So that wallets one to four end up with 1 million of each of the
four different tokens and we wait.
So, I mean, this will concurrently start this contract, but then immediately
continue at one block, so we use this wait for state that I explained when
we talked about Oracles to wait until init returns and what init will do is
it will write the currency symbol of the forged example tokens into the state.
So we wait until we see that and then we remember it and we wait until
this init contract has finished.
And then we write the currency symbol into a file that I called symbol dot json.
And we just use encode that comes from data dot aeson, the json
standard json library for Haskell.
So we take this currency symbol and encode it to json and write it in
this file and we write a log message.
Then again for wallet one, we start the Uniswap system.
So we use the Uniswap start constructor and we again use wait for state to
wait until we get the result and the result of the Uniswap start, I explained
it earlier will be a value of type Uniswap, and we need that value in order
to parameterize the user contracts.
So we wait until we get this, I called it US and will log and now Uniswap, the
system is running and now we can start the user instances for all the wallets.
So I loop all our wallets and activate the Uniswap user contract which is
now parameterized by the US value I got in the previous step here.
Okay.
Now I have these handles and in order to interact, to communicate
from the front-end with the server, I need these handles.
So I write them into a file and this is where you says helper function
CID file that I showed you earlier.
So I will end up with four files W one dot CID until W four dot CID, which
contains these contract instance IDs for the four contracts, log message, and
then I just wait until the user types a key and I can shut down the server.
Let’s try this out with cabal run Uniswap minus PAB, and now a lot of stuff is
happening, remember, first we forge these example tokens ABCD, and then we need
to distribute them to the other wallets.
Then we have to start the Uniswap system.
And for that, we again have to first forge the Uniswap NFT that identifies
the factory and then create the initial UTXO for the factory that
contains an empty list of pools.
And now we see that all the Uniswap user contracts have started for
wallets one, two, three, four.
If we look, we see the various files that I wrote, so we can look at those.
So symbol dot json is the currency symbol of the example tokens I created.
So I need that to refer to them.
And then we have these W one to W four.
So if you look at one of those, that’s the contract instance IDs for the
contract instances for the four wallets.
And in order to find the correct HTTP endpoints to communicate
with them, I need these.
Let’s look at the client next.
So as for the Oracle, I also wrote that in Haskell using the same library for
doing HTTP requests and in the main program, first of all, I expect one
command line parameter, just a number from one to four, so that the main program
knows for which wallet it’s running.
Then I read the corresponding CID file to get the contract
instance ID for that wallet.
And I read this symbol dot json file to get the currency
symbol of the example tokens.
I read that with something, read file coming from the byte string library, and
decode comes from the aeson library to decode the json back to Haskell data type,
I just check whether there was an error.
And if not, I invoke this go function where give as parameters
the CID, the contracts instance ID and the currency symbol.
And here it’s just a loop, I read a command from the console, we get to the
commands a second, and then depending on the command, I involve various helper
functions and the commands exactly correspond to the endpoints we have,
except for stop, I didn’t implement stop.
So we can carry our funds, we can look for existing pools, we can create
a pool, we can add liquidity to a pool, we can remove liquidity from
a pool, we can close a pool, and we can swap, which is the whole point.
And commands, it’s just this.
So for each of those, we have a command and in order to enter amounts and currency
tokens, currency symbols and token names.
Because the currency symbol will always be the CS, we are only using
our example tokens, I don’t need that and for the token name, because the
token names for ABCD I just use a character for that, it’s easier to type.
So for example, create Integer Character Integer Character.
So that means create a liquidity pool with that amount of the token with
that token name and that amount of the token with this token name and so on.
This read command, it’s just straightforward reads from the
keyboard and then tries to pass that as a command and if it fails it will
just recursively read command again.
And if it succeeds, it returns this command.
Then there are just various helper functions to convert something of
type command into the corresponding parameter types, like create params
or add params from the Uniswap module that I showed you earlier.
This here show coin header and show coin are just to make it look a bit prettier
when we query the funds or the pools, and then we have the various endpoints
and that all makes use a helper function.
Last time, I think for the Oracle I spelled it out, now extracted it.
So I have these helper functions get status, which we need in
order to get something back from the contracts and call endpoint.
So I’m just using this library, this IQ library as last time.
And here, this is the interesting part, this is the request.
So it will be the post request, this is the URL, and I must give
the instance ID, this is here.
So this is of type UUID, so I just convert it into a string and then pick
it to a text because this HTTP library expects text here and the name of the
endpoint and the request body that depends, of course, what parameters.
So this is just a parameter here, that’s the third argument in the function.
The response will always be unit and I just check whether
I get a 200 status code or not.
And the get status is a get request that invokes this HTTP endpoint
called status, again with the CID.
And it doesn’t take a request body and I have to tell it what I’m dealing with.
So that’s why I need this Uniswap contracts type here.
And that’s also why this Uniswap client executable also needs
access to this Uniswap module.
And then I just check if the state is empty, which happens right in the
beginning because before in anything else told anything to the state, then I wait a
second and recurse and if there’s a state, so it’s just E, then I know that this is
of type either text a user contract state.
Recall this user contract state that was one constructor for each
of the endpoints, but if there’s an error during contract execution,
I get the error message as a text.
And if something went wrong, then I end in this third case.
And with these two it’s easy to write all the cases for the endpoints.
So let’s maybe look at one, it get funds.
So I use this call endpoint helper function that I stress short.
So for the endpoint named funds, and in this case, the argument, the request body.
The argument, the request body is just unit.
And I wait for two seconds and then I use this get status helper function.
And if I get a right, then I show the funds that I got and otherwise I recurse.
So I wait until I get the right, because in this case,
there’s funds should never fail.
There’s no way that can fail.
Therefore I can safely wait forever.
Get pools is similar.
So it’s more or less the same, except that instead of funds, I have pools now.
And let’s look at one more example, for example, for creating a pool.
So again, I call the endpoint.
I wait for two seconds.
Now that could actually go something wrong.
For example, if I try to create a pool where both coins are the same, or if I
specify a larger liquidity than I have in my wallet, then I would get an error.
So in this case, I, if I get an error, I just log it for the console
and the others are very similar.
Now let’s try it out.
Let’s start three instances for wallets one, two, three, and try
to recreate the scenario from the diagrams in the beginning.
So I can start it simply by a cabal run Uniswap minus client.
And then as command line parameter, I give one for wallet one, and I do the
same for wallet two and for wallet three.
And I see here that these log messages, that the contract instance
ID and the symbol for token that I can use, the ABCD read correctly.
So now what can I do?
I can, for example, clearing my funds and I see I have A, B, C, D, 1 million
each and a lot of lovelace, let’s see three, six, nine, 100,000 ADA.
And I can also look for pools, but right now, there shouldn’t be
any, and indeed none are listed.
So let’s switch to wallet one, let’s say this is Alice, Bob
is two and Charlie is three.
And in the diagrams, we started with Alice setting up a liquidity pool
for tokens A and B, 1,000 and 2,000.
So to do this here, we can type, create thousand A.
Remember that was of type character, so I have to use single quotes and 2000 B.
And I get the created status spec.
So it seems to have worked.
I can query for pools again, and indeed there is one now.
So I see it has A and B and with the correct amounts, 1,000 and 2,000.
The next step was that Bob swaps 100 A for Bs.
So let’s do swap 100 A for Bs.
Okay.
Let’s check how many funds Bob now has and indeed he has 100 less As and 181 more Bs.
Next Charlie added liquidity.
I think it was 400 and 800, so we can use add 400 A, 800 B.
Now check the pools.
Let me see, it’s 1500 and 2619.
Is that correct, so we have 1000 at the beginning, then 100 for
add it by Bob and now 400 by Charlie, so I think that’s correct.
Now, if we go back to Alice, she wants to remove her liquidity.
So let’s first create her funds.
So she has less A and Bs now because she provided them as liquidity for the pool,
but she has this liquidity token 1,415.
So for example, she can burn them and get tokens in exchange.
She doesn’t have to burn all, but in the diagram she did.
So let’s do this, so remove 1415 A B, and let’s clear her funds again.
So now she doesn’t have liquidity token anymore, but she got As and Bs back.
So if we compare, so was 8,000 here so now it’s 9,869.
So she got 1,869 Bs and 1,070 As.
And I think the last step was that Charlie closes the pool.
So let’s switch to Charlie and let’s say, close A B.
And if now we look for pools, then again, we don’t get any.
So it all seems to work.
Finally, I want to show how to do this without Haskell, the front-end, and
just use something like curl because somebody in the Q &amp; A asked for that.
So let’s see, I have For example, status dot SH you will also find
it in the code folder and I expect one argument, that’s the wallet.
And then I just curl to this URL and I interpolate the content of that
file, the correct wallet file given by the first parameter here and status.
And because that’s very unwieldy, I pass it on at Piper through tool JQ.
And then I only interested in the current state and dot observable state of the
corresponding json after resulting json.
So if I try this right now for wallet one, for example, and see
that wallet one at the moment has these amounts of the tokens ABCD.
Okay, and…
At least that was the last status.
Maybe it’s not up to date.
So for example, I can do funds let’s first look at the funds script.
So that again, only takes one parameter, one argument, the wallet, and that that’s
a call to this so, same here to put the correct constance, contract instance
ID there, and then endpoint funds.
And this is a post request, so I need a request body.
So this is unit because the funds endpoint doesn’t require any
arguments except the unit argument.
So now that I’ve invoked that if I query status again, it should have been updated.
Probably it hasn’t changed yet.
Bit more interesting is what to do with the post requested.
We have interesting arguments, for example, if now, wallet
one wants to create a pool again with 1,000 A and 2000 B.
So we need a request body for the correct parameters for the create params.
So let’s look at this.
So I say if it’s shared script for that.
So in principle, the call is simple, so now again, contract instance ID
and now it’s endpoint create, but the question is what to write in this body.
So I have it here.
So I use similar arguments to in the Haskell implementation.
So first the wallet and then the A amount, A token, B amount, B token.
So maybe we should first check whether it works, so I can do create wallet.
What was it one?
It doesn’t matter.
Let’s say wallet one, 1,000 A 2,000 B.
Okay.
And now if I query the status, now it hasn’t updated yet.
So it’s the, it’s still the funds status.
So let’s try again.
Now I get the created.
So also I have pools.
Sorry.
Pools, wallet one.
Okay, and now the status.
Okay.
Now I see, I have this new liquidity pool with A and B.
So remains the question, how I got this, this body, because that’s complicated.
It’s hard to do this by hand, but if we look back at the Haskell output, What I
did was here, for example, for create, I always write the URL, where do the
request to, and also the request body.
And we can actually check the code for this.
So if we look at Uniswap client.
This is in the, in this helper function called endpoint.
I brushed over that earlier when I show you the code.
So this is this line here, there write the request body.
So I get the A, that’s just a Haskell value that can be encoded to json and I
here in this, in this line where I log, I just use encode from the json library
from sorry, from the aeson library.
So this is now a byte string.
And in order to write that to the console, I need two strings, so I use something
from the byte string library it’s called a byte string dot lazy dot character
eight, for character eight encoding.
And so I unpack this byte string to a string and then I log it.
And that’s the way I would recommend in order to figure
out what requests bodies to use.
I mean, you don’t of course have to write a whole program, you can
also do that in the repl so you just need a value of the correct type.
And then use aeson to encode it and look at the result and then you see
the shape of the json that is expected, and then you can use that and then it’s
straightforward to do the call request.
So we don’t need a Haskell backend.
You, I mean, once you have curl you can use anything like JavaScript,
for example, to write the front-end.
Okay, that concludes the lecture.
And I think because it’s the last lecture, I also don’t want to give you homework,
of course you can, if you like play around with this demo and set up your
own liquidity pools and do some swaps, and of course, whatever you want, I
mean, you for example, can try to write a JavaScript front-end, a nice graphical
UI, or you could also as a challenge, think about whether it is possible
to, use the state machine mechanism instead of doing it by hand, as I did.
So this, as I said was the last regular lecture of this course.
I thank you very much again, for all your hard work and your
attention and your enthusiasm.
And I hope you learned a lot and are eager to try it out once
plutus is available on the Testnet.
And then later on the main net.
And I hope to see you again soon in, in a future course about some other
technologies like Atala PRISM or Marlowe.
Thank you very much again, it was a great pleasure teaching this course.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="week9.html" class="btn btn-neutral float-left" title="10. Week 09 - Marlowe" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
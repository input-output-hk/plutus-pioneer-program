<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Algebra.Graph.AdjacencyMap.Algorithm</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">algebraic-graphs-0.7: A library for algebraic graph construction and transformation</span><ul class="links" id="page-menu"><li><a href="src/Algebra.Graph.AdjacencyMap.Algorithm.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Andrey Mokhov 2016-2022</td></tr><tr><th>License</th><td>MIT (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>andrey.mokhov@gmail.com</td></tr><tr><th>Stability</th><td>unstable</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Algebra.Graph.AdjacencyMap.Algorithm</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Algorithms</a></li><li><a href="#g:2">Correctness properties</a></li><li><a href="#g:3">Type synonyms</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p><strong>Alga</strong> is a library for algebraic construction and manipulation of graphs
 in Haskell. See <a href="https://github.com/snowleopard/alga-paper">this paper</a> for the
 motivation behind the library, the underlying theory, and implementation details.</p><p>This module provides basic graph algorithms, such as <em>depth-first search</em>,
 implemented for the <a href="Algebra-Graph-AdjacencyMap.html">Algebra.Graph.AdjacencyMap</a> data type.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:bfsForest">bfsForest</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; [a] -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> a</li><li class="src short"><a href="#v:bfs">bfs</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:dfsForest">dfsForest</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> a</li><li class="src short"><a href="#v:dfsForestFrom">dfsForestFrom</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; [a] -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> a</li><li class="src short"><a href="#v:dfs">dfs</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:reachable">reachable</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; a -&gt; [a]</li><li class="src short"><a href="#v:topSort">topSort</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Either.html#t:Either" title="Data.Either">Either</a> (<a href="Algebra-Graph-AdjacencyMap-Algorithm.html#t:Cycle" title="Algebra.Graph.AdjacencyMap.Algorithm">Cycle</a> a) [a]</li><li class="src short"><a href="#v:isAcyclic">isAcyclic</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:scc">scc</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> (<a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.NonEmpty.AdjacencyMap">AdjacencyMap</a> a)</li><li class="src short"><a href="#v:isDfsForestOf">isDfsForestOf</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> a -&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:isTopSortOf">isTopSortOf</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Cycle">Cycle</a> = <a href="../../ghc/html/libraries/base-4.16.3.0/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Algorithms</h1></a><div class="top"><p class="src"><a id="v:bfsForest" class="def">bfsForest</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; [a] -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> a <a href="src/Algebra.Graph.AdjacencyMap.Algorithm.html#bfsForest" class="link">Source</a> <a href="#v:bfsForest" class="selflink">#</a></p><div class="doc"><p>Compute the <em>breadth-first search</em> forest of a graph, such that adjacent
 vertices are explored in increasing order according to their <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code> instance.
 The search is seeded by a list of vertices that will become the roots of the
 resulting forest. Duplicates in the list will have their first occurrence
 explored and subsequent ones ignored. The seed vertices that do not belong to
 the graph are also ignored.</p><p>Complexity: <em>O((L + m) * log n)</em> time and <em>O(n)</em> space, where <em>L</em> is the
 number of seed vertices.</p><pre><code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [0]        == <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code>
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [1]        == <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [2]        == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> 2
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [0,1,2]    == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [2,1,0]    == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 1) [1]        == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> 1
<code><a href="Algebra-Graph-AdjacencyMap.html#v:isSubgraphOf" title="Algebra.Graph.AdjacencyMap">isSubgraphOf</a></code> (<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ bfsForest x vs) x == True
bfsForest x (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertexList" title="Algebra.Graph.AdjacencyMap">vertexList</a></code> x)               == <code><a href="../../ghc/html/libraries/base-4.16.3.0/GHC-List.html#v:map" title="GHC.List">map</a></code> (\v -&gt; Node v []) (<code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:nub" title="Data.List">nub</a></code> $ <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertexList" title="Algebra.Graph.AdjacencyMap">vertexList</a></code> x)
bfsForest x []                           == []
bfsForest <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code> vs                       == []
bfsForest (3 * (1 + 4) * (1 + 5)) [1,4]  == [ Node { rootLabel = 1
                                                   , subForest = [ Node { rootLabel = 5
                                                                        , subForest = [] }]}
                                            , Node { rootLabel = 4
                                                   , subForest = [] }]
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [5,4..1]) [3] == <code><a href="Algebra-Graph-AdjacencyMap.html#v:path" title="Algebra.Graph.AdjacencyMap">path</a></code> [3,2,1] + <code><a href="Algebra-Graph-AdjacencyMap.html#v:path" title="Algebra.Graph.AdjacencyMap">path</a></code> [3,4,5]

</pre></div></div><div class="top"><p class="src"><a id="v:bfs" class="def">bfs</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; [a] -&gt; [[a]] <a href="src/Algebra.Graph.AdjacencyMap.Algorithm.html#bfs" class="link">Source</a> <a href="#v:bfs" class="selflink">#</a></p><div class="doc"><p>A version of <code><a href="Algebra-Graph-AdjacencyMap-Algorithm.html#v:bfsForest" title="Algebra.Graph.AdjacencyMap.Algorithm">bfsForest</a></code> where the resulting forest is converted to a level
 structure. Adjacent vertices are explored in the increasing order according
 to their <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code> instance. Flattening the result via <code><code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:concat" title="Data.List">concat</a></code></code> <code>.</code> <code><code><a href="Algebra-Graph-AdjacencyMap-Algorithm.html#v:bfs" title="Algebra.Graph.AdjacencyMap.Algorithm">bfs</a></code></code> <code>x</code>
 gives an enumeration of reachable vertices in the breadth-first search order.</p><p>Complexity: <em>O((L + m) * min(n,W))</em> time and <em>O(n)</em> space, where <em>L</em> is the
 number of seed vertices.</p><pre>bfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [0]                == []
bfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [1]                == [[1], [2]]
bfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [2]                == [[2]]
bfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [1,2]              == [[1,2]]
bfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [2,1]              == [[2,1]]
bfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 1) [1]                == [[1]]
bfs <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code> vs                      == []
bfs x []                          == []
bfs (1 * 2 + 3 * 4 + 5 * 6) [1,2] == [[1,2]]
bfs (1 * 2 + 3 * 4 + 5 * 6) [1,3] == [[1,3], [2,4]]
bfs (3 * (1 + 4) * (1 + 5)) [3]   == [[3], [1,4,5]]

bfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [5,4..1]) [3]          == [[2], [1,3], [5,4]]
<code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:concat" title="Data.List">concat</a></code> $ bfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [5,4..1]) [3] == [3,2,4,1,5]
<code><a href="../../ghc/html/libraries/base-4.16.3.0/GHC-List.html#v:map" title="GHC.List">map</a></code> <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:concat" title="Data.List">concat</a></code> . <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:transpose" title="Data.List">transpose</a></code> . <code><a href="../../ghc/html/libraries/base-4.16.3.0/GHC-List.html#v:map" title="GHC.List">map</a></code> <code><a href="../../containers/html/Data-Tree.html#v:levels" title="Data.Tree">levels</a></code> . <code><a href="Algebra-Graph-AdjacencyMap-Algorithm.html#v:bfsForest" title="Algebra.Graph.AdjacencyMap.Algorithm">bfsForest</a></code> x    == bfs x
</pre></div></div><div class="top"><p class="src"><a id="v:dfsForest" class="def">dfsForest</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> a <a href="src/Algebra.Graph.AdjacencyMap.Algorithm.html#dfsForest" class="link">Source</a> <a href="#v:dfsForest" class="selflink">#</a></p><div class="doc"><p>Compute the <em>depth-first search</em> forest of a graph, where adjacent vertices
 are explored in the increasing order according to their <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code> instance.</p><p>Complexity: <em>O((n + m) * min(n,W))</em> time and <em>O(n)</em> space.</p><pre><code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForest <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code>              == <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code>
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForest (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 1)         == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> 1
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForest (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2)         == <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForest (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 2 1)         == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyMap.html#v:isSubgraphOf" title="Algebra.Graph.AdjacencyMap">isSubgraphOf</a></code> (<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForest x) x == True
<code><a href="Algebra-Graph-AdjacencyMap-Algorithm.html#v:isDfsForestOf" title="Algebra.Graph.AdjacencyMap.Algorithm">isDfsForestOf</a></code> (dfsForest x) x         == True
dfsForest . <code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> . dfsForest        == dfsForest
dfsForest (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> vs)               == <code><a href="../../ghc/html/libraries/base-4.16.3.0/GHC-List.html#v:map" title="GHC.List">map</a></code> (\v -&gt; Node v []) (<code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:nub" title="Data.List">nub</a></code> $ <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:sort" title="Data.List">sort</a></code> vs)
dfsForest $ 3 * (1 + 4) * (1 + 5)     == [ Node { rootLabel = 1
                                                , subForest = [ Node { rootLabel = 5
                                                                     , subForest = [] }]}
                                         , Node { rootLabel = 3
                                                , subForest = [ Node { rootLabel = 4
                                                                     , subForest = [] }]}]
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> (dfsForest $ <code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [5,4..1]) == <code><a href="Algebra-Graph-AdjacencyMap.html#v:path" title="Algebra.Graph.AdjacencyMap">path</a></code> [1,2,3,4,5]
</pre></div></div><div class="top"><p class="src"><a id="v:dfsForestFrom" class="def">dfsForestFrom</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; [a] -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> a <a href="src/Algebra.Graph.AdjacencyMap.Algorithm.html#dfsForestFrom" class="link">Source</a> <a href="#v:dfsForestFrom" class="selflink">#</a></p><div class="doc"><p>Compute the <em>depth-first search</em> forest of a graph starting from the given
 seed vertices, where adjacent vertices are explored in the increasing order
 according to their <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code> instance. Note that the resulting forest does not
 necessarily span the whole graph, as some vertices may be unreachable. The
 seed vertices which do not belong to the graph are ignored.</p><p>Complexity: <em>O((L + m) * log n)</em> time and <em>O(n)</em> space, where <em>L</em> is the
 number of seed vertices.</p><pre><code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForestFrom <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code>      vs             == <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code>
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 1) [1]            == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> 1
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [0]            == <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code>
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [1]            == <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [2]            == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> 2
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [1,2]          == <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [2,1]          == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyMap.html#v:isSubgraphOf" title="Algebra.Graph.AdjacencyMap">isSubgraphOf</a></code> (<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForestFrom x vs) x     == True
<code><a href="Algebra-Graph-AdjacencyMap-Algorithm.html#v:isDfsForestOf" title="Algebra.Graph.AdjacencyMap.Algorithm">isDfsForestOf</a></code> (dfsForestFrom x (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertexList" title="Algebra.Graph.AdjacencyMap">vertexList</a></code> x)) x == True
dfsForestFrom x (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertexList" title="Algebra.Graph.AdjacencyMap">vertexList</a></code> x)                   == <code><a href="Algebra-Graph-AdjacencyMap-Algorithm.html#v:dfsForest" title="Algebra.Graph.AdjacencyMap.Algorithm">dfsForest</a></code> x
dfsForestFrom x []                               == []
dfsForestFrom (3 * (1 + 4) * (1 + 5)) [1,4]      == [ Node { rootLabel = 1
                                                           , subForest = [ Node { rootLabel = 5
                                                                                , subForest = [] }
                                                    , Node { rootLabel = 4
                                                           , subForest = [] }]
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [5,4..1]) [3] == <code><a href="Algebra-Graph-AdjacencyMap.html#v:path" title="Algebra.Graph.AdjacencyMap">path</a></code> [3,2,1,5,4]
</pre></div></div><div class="top"><p class="src"><a id="v:dfs" class="def">dfs</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; [a] -&gt; [a] <a href="src/Algebra.Graph.AdjacencyMap.Algorithm.html#dfs" class="link">Source</a> <a href="#v:dfs" class="selflink">#</a></p><div class="doc"><p>Return the list vertices visited by the <em>depth-first search</em> in a graph,
 starting from the given seed vertices. Adjacent vertices are explored in the
 increasing order according to their <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code> instance.</p><p>Complexity: <em>O((L + m) * log n)</em> time and <em>O(n)</em> space, where <em>L</em> is the
 number of seed vertices.</p><pre>dfs <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code>      vs    == []
dfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 1) [1]   == [1]
dfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [0]   == []
dfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [1]   == [1,2]
dfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [2]   == [2]
dfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [1,2] == [1,2]
dfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [2,1] == [2,1]
dfs x          []    == []

<code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:and" title="Data.List">and</a></code> [ <code><a href="Algebra-Graph-AdjacencyMap.html#v:hasVertex" title="Algebra.Graph.AdjacencyMap">hasVertex</a></code> v x | v &lt;- dfs x vs ]       == True
dfs (3 * (1 + 4) * (1 + 5)) [1,4]           == [1,5,4]
dfs (<code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [5,4..1]) [3] == [3,2,1,5,4]
</pre></div></div><div class="top"><p class="src"><a id="v:reachable" class="def">reachable</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; a -&gt; [a] <a href="src/Algebra.Graph.AdjacencyMap.Algorithm.html#reachable" class="link">Source</a> <a href="#v:reachable" class="selflink">#</a></p><div class="doc"><p>Return the list of vertices <em>reachable</em> from a source vertex in a graph.
 The vertices in the resulting list appear in the <em>depth-first search order</em>.</p><p>Complexity: <em>O(m * log n)</em> time and <em>O(n)</em> space.</p><pre>reachable <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code>              x == []
reachable (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> 1)         1 == [1]
reachable (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 1)         1 == [1]
reachable (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2)         0 == []
reachable (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2)         1 == [1,2]
reachable (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2)         2 == [2]
reachable (<code><a href="Algebra-Graph-AdjacencyMap.html#v:path" title="Algebra.Graph.AdjacencyMap">path</a></code>    [1..8]  ) 4 == [4..8]
reachable (<code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [1..8]  ) 4 == [4..8] ++ [1..3]
reachable (<code><a href="Algebra-Graph-AdjacencyMap.html#v:clique" title="Algebra.Graph.AdjacencyMap">clique</a></code>  [8,7..1]) 8 == [8] ++ [1..7]

<code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:and" title="Data.List">and</a></code> [ <code><a href="Algebra-Graph-AdjacencyMap.html#v:hasVertex" title="Algebra.Graph.AdjacencyMap">hasVertex</a></code> v x | v &lt;- reachable x y ] == True
</pre></div></div><div class="top"><p class="src"><a id="v:topSort" class="def">topSort</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Either.html#t:Either" title="Data.Either">Either</a> (<a href="Algebra-Graph-AdjacencyMap-Algorithm.html#t:Cycle" title="Algebra.Graph.AdjacencyMap.Algorithm">Cycle</a> a) [a] <a href="src/Algebra.Graph.AdjacencyMap.Algorithm.html#topSort" class="link">Source</a> <a href="#v:topSort" class="selflink">#</a></p><div class="doc"><p>Compute a topological sort of a graph or discover a cycle.</p><p>Vertices are explored in the decreasing order according to their <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code>
 instance. This gives the lexicographically smallest topological ordering in
 the case of success. In the case of failure, the cycle is characterized by
 being the lexicographically smallest up to rotation with respect to
 <code>Ord</code> <code>(Dual</code> <code>Int)</code> in the first connected component of the graph containing
 a cycle, where the connected components are ordered by their largest vertex
 with respect to <code>Ord a</code>.</p><p>Complexity: <em>O((n + m) * min(n,W))</em> time and <em>O(n)</em> space.</p><pre>topSort (1 * 2 + 3 * 1)                    == Right [3,1,2]
topSort (<code><a href="Algebra-Graph-AdjacencyMap.html#v:path" title="Algebra.Graph.AdjacencyMap">path</a></code> [1..5])                      == Right [1..5]
topSort (3 * (1 * 4 + 2 * 5))              == Right [3,1,2,4,5]
topSort (1 * 2 + 2 * 1)                    == Left (2 <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [1])
topSort (<code><a href="Algebra-Graph-AdjacencyMap.html#v:path" title="Algebra.Graph.AdjacencyMap">path</a></code> [5,4..1] + <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 2 4)         == Left (4 <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [3,2])
topSort (<code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [1..3])                   == Left (3 <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [1,2])
topSort (<code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [1..3] + <code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> [3,2,1]) == Left (3 <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [2])
topSort (1 * 2 + (5 + 2) * 1 + 3 * 4 * 3)  == Left (1 <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [2])
fmap (<code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-Function.html#v:flip" title="Data.Function">flip</a></code> <code><a href="Algebra-Graph-AdjacencyMap-Algorithm.html#v:isTopSortOf" title="Algebra.Graph.AdjacencyMap.Algorithm">isTopSortOf</a></code> x) (topSort x)      /= Right False
<code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-Either.html#v:isRight" title="Data.Either">isRight</a></code> . topSort                          == <code><a href="Algebra-Graph-AdjacencyMap-Algorithm.html#v:isAcyclic" title="Algebra.Graph.AdjacencyMap.Algorithm">isAcyclic</a></code>
topSort . <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code>                         == Right . <code>nub</code> . <code>sort</code>
</pre></div></div><div class="top"><p class="src"><a id="v:isAcyclic" class="def">isAcyclic</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Algebra.Graph.AdjacencyMap.Algorithm.html#isAcyclic" class="link">Source</a> <a href="#v:isAcyclic" class="selflink">#</a></p><div class="doc"><p>Check if a given graph is <em>acyclic</em>.</p><p>Complexity: <em>O((n+m)*log n)</em> time and <em>O(n)</em> space.</p><pre>isAcyclic (1 * 2 + 3 * 1) == True
isAcyclic (1 * 2 + 2 * 1) == False
isAcyclic . <code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code>       == <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:null" title="Data.List">null</a></code>
isAcyclic                 == <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-Either.html#v:isRight" title="Data.Either">isRight</a></code> . <code><a href="Algebra-Graph-AdjacencyMap-Algorithm.html#v:topSort" title="Algebra.Graph.AdjacencyMap.Algorithm">topSort</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:scc" class="def">scc</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> (<a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.NonEmpty.AdjacencyMap">AdjacencyMap</a> a) <a href="src/Algebra.Graph.AdjacencyMap.Algorithm.html#scc" class="link">Source</a> <a href="#v:scc" class="selflink">#</a></p><div class="doc"><p>Compute the <em>condensation</em> of a graph, where each vertex corresponds to a
 <em>strongly-connected component</em> of the original graph. Note that component
 graphs are non-empty, and are therefore of type
 <a href="Algebra-Graph-NonEmpty-AdjacencyMap.html">Algebra.Graph.NonEmpty.AdjacencyMap</a>.</p><p>Details about the implementation can be found at
 <a href="https://github.com/jitwit/alga-notes/blob/master/gabow.org">gabow-notes</a>.</p><p>Complexity: <em>O((n+m)*log n)</em> time and <em>O(n+m)</em> space.</p><pre>scc <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code>               == <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code>
scc (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> x)          == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> (NonEmpty.<code><a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#v:vertex" title="Algebra.Graph.NonEmpty.AdjacencyMap">vertex</a></code> x)
scc (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> xs)       == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> (<code><a href="../../ghc/html/libraries/base-4.16.3.0/GHC-List.html#v:map" title="GHC.List">map</a></code> <code><a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#v:vertex" title="Algebra.Graph.NonEmpty.AdjacencyMap">vertex</a></code> xs)
scc (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 1)          == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> (NonEmpty.<code><a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#v:edge" title="Algebra.Graph.NonEmpty.AdjacencyMap">edge</a></code> 1 1)
scc (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2)          == <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code>   (NonEmpty.<code><a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#v:vertex" title="Algebra.Graph.NonEmpty.AdjacencyMap">vertex</a></code> 1) (NonEmpty.<code><a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#v:vertex" title="Algebra.Graph.NonEmpty.AdjacencyMap">vertex</a></code> 2)
scc (<code><a href="Algebra-Graph-AdjacencyMap.html#v:circuit" title="Algebra.Graph.AdjacencyMap">circuit</a></code> (1:xs))    == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> (NonEmpty.<code><a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#v:circuit1" title="Algebra.Graph.NonEmpty.AdjacencyMap">circuit1</a></code> (1 <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> xs))
scc (3 * 1 * 4 * 1 * 5) == <code><a href="Algebra-Graph-AdjacencyMap.html#v:edges" title="Algebra.Graph.AdjacencyMap">edges</a></code>  [ (NonEmpty.<code><a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#v:vertex" title="Algebra.Graph.NonEmpty.AdjacencyMap">vertex</a></code>  3      , NonEmpty.<code><a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#v:vertex" title="Algebra.Graph.NonEmpty.AdjacencyMap">vertex</a></code>  5      )
                                  , (NonEmpty.<code><a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#v:vertex" title="Algebra.Graph.NonEmpty.AdjacencyMap">vertex</a></code>  3      , NonEmpty.<code><a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#v:clique1" title="Algebra.Graph.NonEmpty.AdjacencyMap">clique1</a></code> [1,4,1])
                                  , (NonEmpty.<code><a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#v:clique1" title="Algebra.Graph.NonEmpty.AdjacencyMap">clique1</a></code> [1,4,1], NonEmpty.<code><a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#v:vertex" title="Algebra.Graph.NonEmpty.AdjacencyMap">vertex</a></code>  5      ) ]
<code><a href="Algebra-Graph-AdjacencyMap-Algorithm.html#v:isAcyclic" title="Algebra.Graph.AdjacencyMap.Algorithm">isAcyclic</a></code> . scc == <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-Function.html#v:const" title="Data.Function">const</a></code> True
<code><a href="Algebra-Graph-AdjacencyMap-Algorithm.html#v:isAcyclic" title="Algebra.Graph.AdjacencyMap.Algorithm">isAcyclic</a></code> x     == (scc x == <code><a href="Algebra-Graph-AdjacencyMap.html#v:gmap" title="Algebra.Graph.AdjacencyMap">gmap</a></code> NonEmpty.<code><a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#v:vertex" title="Algebra.Graph.NonEmpty.AdjacencyMap">vertex</a></code> x)
</pre></div></div><a href="#g:2" id="g:2"><h1>Correctness properties</h1></a><div class="top"><p class="src"><a id="v:isDfsForestOf" class="def">isDfsForestOf</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> a -&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Algebra.Graph.AdjacencyMap.Algorithm.html#isDfsForestOf" class="link">Source</a> <a href="#v:isDfsForestOf" class="selflink">#</a></p><div class="doc"><p>Check if a given forest is a correct <em>depth-first search</em> forest of a graph.
 The implementation is based on the paper &quot;Depth-First Search and Strong
 Connectivity in Coq&quot; by Fran&#231;ois Pottier.</p><pre>isDfsForestOf []                              <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code>            == True
isDfsForestOf []                              (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> 1)       == False
isDfsForestOf [Node 1 []]                     (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> 1)       == True
isDfsForestOf [Node 1 []]                     (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> 2)       == False
isDfsForestOf [Node 1 [], Node 1 []]          (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> 1)       == False
isDfsForestOf [Node 1 []]                     (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 1)       == True
isDfsForestOf [Node 1 []]                     (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2)       == False
isDfsForestOf [Node 1 [], Node 2 []]          (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2)       == False
isDfsForestOf [Node 2 [], Node 1 []]          (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2)       == True
isDfsForestOf [Node 1 [Node 2 []]]            (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2)       == True
isDfsForestOf [Node 1 [], Node 2 []]          (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> [1,2]) == True
isDfsForestOf [Node 2 [], Node 1 []]          (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> [1,2]) == True
isDfsForestOf [Node 1 [Node 2 []]]            (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> [1,2]) == False
isDfsForestOf [Node 1 [Node 2 [Node 3 []]]]   (<code><a href="Algebra-Graph-AdjacencyMap.html#v:path" title="Algebra.Graph.AdjacencyMap">path</a></code> [1,2,3])   == True
isDfsForestOf [Node 1 [Node 3 [Node 2 []]]]   (<code><a href="Algebra-Graph-AdjacencyMap.html#v:path" title="Algebra.Graph.AdjacencyMap">path</a></code> [1,2,3])   == False
isDfsForestOf [Node 3 [], Node 1 [Node 2 []]] (<code><a href="Algebra-Graph-AdjacencyMap.html#v:path" title="Algebra.Graph.AdjacencyMap">path</a></code> [1,2,3])   == True
isDfsForestOf [Node 2 [Node 3 []], Node 1 []] (<code><a href="Algebra-Graph-AdjacencyMap.html#v:path" title="Algebra.Graph.AdjacencyMap">path</a></code> [1,2,3])   == True
isDfsForestOf [Node 1 [], Node 2 [Node 3 []]] (<code><a href="Algebra-Graph-AdjacencyMap.html#v:path" title="Algebra.Graph.AdjacencyMap">path</a></code> [1,2,3])   == False
</pre></div></div><div class="top"><p class="src"><a id="v:isTopSortOf" class="def">isTopSortOf</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Algebra.Graph.AdjacencyMap.Algorithm.html#isTopSortOf" class="link">Source</a> <a href="#v:isTopSortOf" class="selflink">#</a></p><div class="doc"><p>Check if a given list of vertices is a correct <em>topological sort</em> of a graph.</p><pre>isTopSortOf [3,1,2] (1 * 2 + 3 * 1) == True
isTopSortOf [1,2,3] (1 * 2 + 3 * 1) == False
isTopSortOf []      (1 * 2 + 3 * 1) == False
isTopSortOf []      <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code>           == True
isTopSortOf [x]     (<code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> x)      == True
isTopSortOf [x]     (<code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> x x)      == False
</pre></div></div><a href="#g:3" id="g:3"><h1>Type synonyms</h1></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Cycle" class="def">Cycle</a> = <a href="../../ghc/html/libraries/base-4.16.3.0/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="src/Algebra.Graph.AdjacencyMap.Algorithm.html#Cycle" class="link">Source</a> <a href="#t:Cycle" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>
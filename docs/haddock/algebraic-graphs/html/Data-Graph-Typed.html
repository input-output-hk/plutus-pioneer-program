<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.Graph.Typed</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">algebraic-graphs-0.7: A library for algebraic graph construction and transformation</span><ul class="links" id="page-menu"><li><a href="src/Data.Graph.Typed.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Anton Lorenzen Andrey Mokhov 2016-2022</td></tr><tr><th>License</th><td>MIT (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>anfelor@posteo.de, andrey.mokhov@gmail.com</td></tr><tr><th>Stability</th><td>unstable</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.Graph.Typed</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Data type and construction</a></li><li><a href="#g:2">Basic algorithms</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p><strong>Alga</strong> is a library for algebraic construction and manipulation of graphs
 in Haskell. See <a href="https://github.com/snowleopard/alga-paper">this paper</a> for the
 motivation behind the library, the underlying theory, and implementation details.</p><p>This module provides primitives for interoperability between this library and
 the <a href="../../containers/html/Data-Graph.html">Data.Graph</a> module of the containers library. It is for internal use only
 and may be removed without notice at any point.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:GraphKL">GraphKL</a> a = <a href="#v:GraphKL">GraphKL</a> {<ul class="subs"><li><a href="#v:toGraphKL">toGraphKL</a> :: <a href="../../containers/html/Data-Graph.html#t:Graph" title="Data.Graph">Graph</a></li><li><a href="#v:fromVertexKL">fromVertexKL</a> :: <a href="../../containers/html/Data-Graph.html#t:Vertex" title="Data.Graph">Vertex</a> -&gt; a</li><li><a href="#v:toVertexKL">toVertexKL</a> :: a -&gt; <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../../containers/html/Data-Graph.html#t:Vertex" title="Data.Graph">Vertex</a></li></ul>}</li><li class="src short"><a href="#v:fromAdjacencyMap">fromAdjacencyMap</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a> a</li><li class="src short"><a href="#v:fromAdjacencyIntMap">fromAdjacencyIntMap</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a> <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:dfsForest">dfsForest</a> :: <a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a> a -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> a</li><li class="src short"><a href="#v:dfsForestFrom">dfsForestFrom</a> :: <a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a> a -&gt; [a] -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> a</li><li class="src short"><a href="#v:dfs">dfs</a> :: <a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a> a -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:topSort">topSort</a> :: <a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a> a -&gt; [a]</li><li class="src short"><a href="#v:scc">scc</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> (<a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.NonEmpty.AdjacencyMap">AdjacencyMap</a> a)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Data type and construction</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:GraphKL" class="def">GraphKL</a> a <a href="src/Data.Graph.Typed.html#GraphKL" class="link">Source</a> <a href="#t:GraphKL" class="selflink">#</a></p><div class="doc"><p><code><a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a></code> encapsulates King-Launchbury graphs, which are implemented in
 the <a href="../../containers/html/Data-Graph.html">Data.Graph</a> module of the <code>containers</code> library.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:GraphKL" class="def">GraphKL</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:toGraphKL" class="def">toGraphKL</a> :: <a href="../../containers/html/Data-Graph.html#t:Graph" title="Data.Graph">Graph</a></dfn><div class="doc"><p>Array-based graph representation (King and Launchbury, 1995).</p></div></li><li><dfn class="src"><a id="v:fromVertexKL" class="def">fromVertexKL</a> :: <a href="../../containers/html/Data-Graph.html#t:Vertex" title="Data.Graph">Vertex</a> -&gt; a</dfn><div class="doc"><p>A mapping of <a href="Data-Graph-Vertex.html">Data.Graph.Vertex</a> to vertices of type <code>a</code>.
 This is partial and may fail if the vertex is out of bounds.</p></div></li><li><dfn class="src"><a id="v:toVertexKL" class="def">toVertexKL</a> :: a -&gt; <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../../containers/html/Data-Graph.html#t:Vertex" title="Data.Graph">Vertex</a></dfn><div class="doc"><p>A mapping from vertices of type <code>a</code> to <a href="Data-Graph-Vertex.html">Data.Graph.Vertex</a>.
 Returns <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if the argument is not in the graph.</p></div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><a id="v:fromAdjacencyMap" class="def">fromAdjacencyMap</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a> a <a href="src/Data.Graph.Typed.html#fromAdjacencyMap" class="link">Source</a> <a href="#v:fromAdjacencyMap" class="selflink">#</a></p><div class="doc"><p>Build <code><a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a></code> from an <code><a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a></code>. If <code>fromAdjacencyMap g == h</code>
 then the following holds:</p><pre>map (<code><a href="Data-Graph-Typed.html#v:fromVertexKL" title="Data.Graph.Typed">fromVertexKL</a></code> h) (<code><a href="../../containers/html/Data-Graph.html#v:vertices" title="Data.Graph">vertices</a></code> $ <code><a href="Data-Graph-Typed.html#v:toGraphKL" title="Data.Graph.Typed">toGraphKL</a></code> h)                               == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertexList" title="Algebra.Graph.AdjacencyMap">vertexList</a></code> g
map (\(x, y) -&gt; (<code><a href="Data-Graph-Typed.html#v:fromVertexKL" title="Data.Graph.Typed">fromVertexKL</a></code> h x, <code><a href="Data-Graph-Typed.html#v:fromVertexKL" title="Data.Graph.Typed">fromVertexKL</a></code> h y)) (<code><a href="../../containers/html/Data-Graph.html#v:edges" title="Data.Graph">edges</a></code> $ <code><a href="Data-Graph-Typed.html#v:toGraphKL" title="Data.Graph.Typed">toGraphKL</a></code> h) == <code><a href="Algebra-Graph-AdjacencyMap.html#v:edgeList" title="Algebra.Graph.AdjacencyMap">edgeList</a></code> g
<code><a href="Data-Graph-Typed.html#v:toGraphKL" title="Data.Graph.Typed">toGraphKL</a></code> (fromAdjacencyMap (1 * 2 + 3 * 1))                                == <code>array</code> (0,2) [(0,[1]), (1,[]), (2,[0])]
<code><a href="Data-Graph-Typed.html#v:toGraphKL" title="Data.Graph.Typed">toGraphKL</a></code> (fromAdjacencyMap (1 * 2 + 2 * 1))                                == <code>array</code> (0,1) [(0,[1]), (1,[0])]
</pre></div></div><div class="top"><p class="src"><a id="v:fromAdjacencyIntMap" class="def">fromAdjacencyIntMap</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a> <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Data.Graph.Typed.html#fromAdjacencyIntMap" class="link">Source</a> <a href="#v:fromAdjacencyIntMap" class="selflink">#</a></p><div class="doc"><p>Build <code><a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a></code> from an <code><a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a></code>. If
 <code>fromAdjacencyIntMap g == h</code> then the following holds:</p><pre>map (<code><a href="Data-Graph-Typed.html#v:fromVertexKL" title="Data.Graph.Typed">fromVertexKL</a></code> h) (<code><a href="../../containers/html/Data-Graph.html#v:vertices" title="Data.Graph">vertices</a></code> $ <code><a href="Data-Graph-Typed.html#v:toGraphKL" title="Data.Graph.Typed">toGraphKL</a></code> h)                               == <code><a href="../../containers/html/Data-IntSet.html#v:toAscList" title="Data.IntSet">toAscList</a></code> (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertexIntSet" title="Algebra.Graph.AdjacencyIntMap">vertexIntSet</a></code> g)
map (\(x, y) -&gt; (<code><a href="Data-Graph-Typed.html#v:fromVertexKL" title="Data.Graph.Typed">fromVertexKL</a></code> h x, <code><a href="Data-Graph-Typed.html#v:fromVertexKL" title="Data.Graph.Typed">fromVertexKL</a></code> h y)) (<code><a href="../../containers/html/Data-Graph.html#v:edges" title="Data.Graph">edges</a></code> $ <code><a href="Data-Graph-Typed.html#v:toGraphKL" title="Data.Graph.Typed">toGraphKL</a></code> h) == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edgeList" title="Algebra.Graph.AdjacencyIntMap">edgeList</a></code> g
<code><a href="Data-Graph-Typed.html#v:toGraphKL" title="Data.Graph.Typed">toGraphKL</a></code> (fromAdjacencyIntMap (1 * 2 + 3 * 1))                             == <code>array</code> (0,2) [(0,[1]), (1,[]), (2,[0])]
<code><a href="Data-Graph-Typed.html#v:toGraphKL" title="Data.Graph.Typed">toGraphKL</a></code> (fromAdjacencyIntMap (1 * 2 + 2 * 1))                             == <code>array</code> (0,1) [(0,[1]), (1,[0])]
</pre></div></div><a href="#g:2" id="g:2"><h1>Basic algorithms</h1></a><div class="top"><p class="src"><a id="v:dfsForest" class="def">dfsForest</a> :: <a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a> a -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> a <a href="src/Data.Graph.Typed.html#dfsForest" class="link">Source</a> <a href="#v:dfsForest" class="selflink">#</a></p><div class="doc"><p>Compute the <em>depth-first search</em> forest of a graph.</p><p>In the following examples we will use the helper function:</p><pre>(%) :: Ord a =&gt; (<code><a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a></code> a -&gt; b) -&gt; <code><a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a></code> a -&gt; b
f % x = f (<code><a href="Data-Graph-Typed.html#v:fromAdjacencyMap" title="Data.Graph.Typed">fromAdjacencyMap</a></code> x)
</pre><p>for greater clarity.</p><pre><code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> (dfsForest % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 1)           == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> 1
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> (dfsForest % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2)           == <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> (dfsForest % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 2 1)           == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyMap.html#v:isSubgraphOf" title="Algebra.Graph.AdjacencyMap">isSubgraphOf</a></code> (<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForest % x) x == True
dfsForest % <code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> (dfsForest % x)      == dfsForest % x
dfsForest % <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> vs                 == <code><a href="../../ghc/html/libraries/base-4.16.3.0/GHC-List.html#v:map" title="GHC.List">map</a></code> (\v -&gt; Node v []) (<code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:nub" title="Data.List">nub</a></code> $ <code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:sort" title="Data.List">sort</a></code> vs)
dfsForest % (3 * (1 + 4) * (1 + 5))     == [ Node { rootLabel = 1
                                                  , subForest = [ Node { rootLabel = 5
                                                                       , subForest = [] }]}
                                           , Node { rootLabel = 3
                                                  , subForest = [ Node { rootLabel = 4
                                                                       , subForest = [] }]}]
</pre></div></div><div class="top"><p class="src"><a id="v:dfsForestFrom" class="def">dfsForestFrom</a> :: <a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a> a -&gt; [a] -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> a <a href="src/Data.Graph.Typed.html#dfsForestFrom" class="link">Source</a> <a href="#v:dfsForestFrom" class="selflink">#</a></p><div class="doc"><p>Compute the <em>depth-first search</em> forest of a graph, searching from each of
 the given vertices in order. Note that the resulting forest does not
 necessarily span the whole graph, as some vertices may be unreachable.</p><p>In the following examples we will use the helper function:</p><pre>(%) :: Ord a =&gt; (<code><a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a></code> a -&gt; b) -&gt; <code><a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a></code> a -&gt; b
f % x = f (<code><a href="Data-Graph-Typed.html#v:fromAdjacencyMap" title="Data.Graph.Typed">fromAdjacencyMap</a></code> x)
</pre><p>for greater clarity.</p><pre><code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ (dfsForestFrom % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 1) [1]          == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> 1
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ (dfsForestFrom % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [0]          == <code><a href="Algebra-Graph-AdjacencyMap.html#v:empty" title="Algebra.Graph.AdjacencyMap">empty</a></code>
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ (dfsForestFrom % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [1]          == <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ (dfsForestFrom % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [2]          == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertex" title="Algebra.Graph.AdjacencyMap">vertex</a></code> 2
<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ (dfsForestFrom % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2) [2,1]        == <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyMap.html#v:isSubgraphOf" title="Algebra.Graph.AdjacencyMap">isSubgraphOf</a></code> (<code><a href="Algebra-Graph-AdjacencyMap.html#v:forest" title="Algebra.Graph.AdjacencyMap">forest</a></code> $ dfsForestFrom % x $ vs) x == True
dfsForestFrom % x $ <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertexList" title="Algebra.Graph.AdjacencyMap">vertexList</a></code> x                 == <code><a href="Data-Graph-Typed.html#v:dfsForest" title="Data.Graph.Typed">dfsForest</a></code> % x
dfsForestFrom % <code><a href="Algebra-Graph-AdjacencyMap.html#v:vertices" title="Algebra.Graph.AdjacencyMap">vertices</a></code> vs $ vs                 == <code><a href="../../ghc/html/libraries/base-4.16.3.0/GHC-List.html#v:map" title="GHC.List">map</a></code> (\v -&gt; Node v []) (<code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:nub" title="Data.List">nub</a></code> vs)
dfsForestFrom % x $ []                           == []
dfsForestFrom % (3 * (1 + 4) * (1 + 5)) $ [1,4]  == [ Node { rootLabel = 1
                                                           , subForest = [ Node { rootLabel = 5
                                                                                , subForest = [] }
                                                    , Node { rootLabel = 4
                                                           , subForest = [] }]
</pre></div></div><div class="top"><p class="src"><a id="v:dfs" class="def">dfs</a> :: <a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a> a -&gt; [a] -&gt; [a] <a href="src/Data.Graph.Typed.html#dfs" class="link">Source</a> <a href="#v:dfs" class="selflink">#</a></p><div class="doc"><p>Compute the list of vertices visited by the <em>depth-first search</em> in a
 graph, when searching from each of the given vertices in order.</p><p>In the following examples we will use the helper function:</p><pre>(%) :: Ord a =&gt; (<code><a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a></code> a -&gt; b) -&gt; <code><a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a></code> a -&gt; b
f % x = f (<code><a href="Data-Graph-Typed.html#v:fromAdjacencyMap" title="Data.Graph.Typed">fromAdjacencyMap</a></code> x)
</pre><p>for greater clarity.</p><pre>dfs % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 1 $ [1]   == [1]
dfs % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2 $ [0]   == []
dfs % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2 $ [1]   == [1,2]
dfs % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2 $ [2]   == [2]
dfs % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2 $ [1,2] == [1,2]
dfs % <code><a href="Algebra-Graph-AdjacencyMap.html#v:edge" title="Algebra.Graph.AdjacencyMap">edge</a></code> 1 2 $ [2,1] == [2,1]
dfs % x        $ []    == []

dfs % (3 * (1 + 4) * (1 + 5)) $ [1,4]     == [1,5,4]
<code><a href="../../ghc/html/libraries/base-4.16.3.0/Data-List.html#v:and" title="Data.List">and</a></code> [ <code><a href="Algebra-Graph-AdjacencyMap.html#v:hasVertex" title="Algebra.Graph.AdjacencyMap">hasVertex</a></code> v x | v &lt;- dfs % x $ vs ] == True
</pre></div></div><div class="top"><p class="src"><a id="v:topSort" class="def">topSort</a> :: <a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a> a -&gt; [a] <a href="src/Data.Graph.Typed.html#topSort" class="link">Source</a> <a href="#v:topSort" class="selflink">#</a></p><div class="doc"><p>Compute the <em>topological sort</em> of a graph. Note that this function returns
 a result even if the graph is cyclic.</p><p>In the following examples we will use the helper function:</p><pre>(%) :: Ord a =&gt; (<code><a href="Data-Graph-Typed.html#t:GraphKL" title="Data.Graph.Typed">GraphKL</a></code> a -&gt; b) -&gt; <code><a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a></code> a -&gt; b
f % x = f (<code><a href="Data-Graph-Typed.html#v:fromAdjacencyMap" title="Data.Graph.Typed">fromAdjacencyMap</a></code> x)
</pre><p>for greater clarity.</p><pre>topSort % (1 * 2 + 3 * 1) == [3,1,2]
topSort % (1 * 2 + 2 * 1) == [1,2]
</pre></div></div><div class="top"><p class="src"><a id="v:scc" class="def">scc</a> :: <a href="../../ghc/html/libraries/base-4.16.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> a -&gt; <a href="Algebra-Graph-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.AdjacencyMap">AdjacencyMap</a> (<a href="Algebra-Graph-NonEmpty-AdjacencyMap.html#t:AdjacencyMap" title="Algebra.Graph.NonEmpty.AdjacencyMap">AdjacencyMap</a> a) <a href="src/Data.Graph.Typed.html#scc" class="link">Source</a> <a href="#v:scc" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>
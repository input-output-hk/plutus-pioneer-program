-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Wadler/Leijen Pretty Printer for colored ANSI terminal output
--   
--   This is a pretty printing library based on Wadler's paper <a>"A
--   Prettier Printer"</a>. It has been enhanced with support for ANSI
--   terminal colored output using the <a>ansi-terminal</a> package.
@package ansi-wl-pprint
@version 0.6.9


-- | <b>WARNING:</b> Internal module. The contents of this file may vary
--   arbitrarily between any two versions. Use the public API if you care
--   about stability.
module Text.PrettyPrint.ANSI.Leijen.Internal

-- | The document <tt>(list xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in square brackets. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
list :: [Doc] -> Doc

-- | The document <tt>(tupled xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in parenthesis. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
tupled :: [Doc] -> Doc

-- | The document <tt>(semiBraces xs)</tt> separates the documents
--   <tt>xs</tt> with semicolons and encloses them in braces. The documents
--   are rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All semicolons are put in front of the elements.
semiBraces :: [Doc] -> Doc

-- | The document <tt>(encloseSep l r sep xs)</tt> concatenates the
--   documents <tt>xs</tt> separated by <tt>sep</tt> and encloses the
--   resulting document by <tt>l</tt> and <tt>r</tt>. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All separators are put in front of the elements.
--   For example, the combinator <a>list</a> can be defined with
--   <tt>encloseSep</tt>:
--   
--   <pre>
--   list xs = encloseSep lbracket rbracket comma xs
--   test    = text "list" &lt;+&gt; (list (map int [10,200,3000]))
--   </pre>
--   
--   Which is layed out with a page width of 20 as:
--   
--   <pre>
--   list [10,200,3000]
--   </pre>
--   
--   But when the page width is 15, it is layed out as:
--   
--   <pre>
--   list [10
--        ,200
--        ,3000]
--   </pre>
encloseSep :: Doc -> Doc -> Doc -> [Doc] -> Doc

-- | <tt>(punctuate p xs)</tt> concatenates all documents in <tt>xs</tt>
--   with document <tt>p</tt> except for the last document.
--   
--   <pre>
--   someText = map text ["words","in","a","tuple"]
--   test     = parens (align (cat (punctuate comma someText)))
--   </pre>
--   
--   This is layed out on a page width of 20 as:
--   
--   <pre>
--   (words,in,a,tuple)
--   </pre>
--   
--   But when the page width is 15, it is layed out as:
--   
--   <pre>
--   (words,
--    in,
--    a,
--    tuple)
--   </pre>
--   
--   (If you want put the commas in front of their elements instead of at
--   the end, you should use <a>tupled</a> or, in general,
--   <a>encloseSep</a>.)
punctuate :: Doc -> [Doc] -> [Doc]

-- | The document <tt>(sep xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;+&gt;)</tt>, if it fits the page, or
--   vertically with <tt>(&lt;$&gt;)</tt>.
--   
--   <pre>
--   sep xs  = group (vsep xs)
--   </pre>
sep :: [Doc] -> Doc

-- | The document <tt>(fillSep xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt> as long as its fits the page,
--   than inserts a <tt>line</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillSep xs  = foldr (&lt;/&gt;) empty xs
--   </pre>
fillSep :: [Doc] -> Doc

-- | The document <tt>(hsep xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt>.
hsep :: [Doc] -> Doc

-- | The document <tt>(vsep xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>(&lt;$&gt;)</tt>. If a <a>group</a> undoes the
--   line breaks inserted by <tt>vsep</tt>, all documents are separated
--   with a space.
--   
--   <pre>
--   someText = map text (words ("text to lay out"))
--   
--   test     = text "some" &lt;+&gt; vsep someText
--   </pre>
--   
--   This is layed out as:
--   
--   <pre>
--   some text
--   to
--   lay
--   out
--   </pre>
--   
--   The <a>align</a> combinator can be used to align the documents under
--   their first element
--   
--   <pre>
--   test     = text "some" &lt;+&gt; align (vsep someText)
--   </pre>
--   
--   Which is printed as:
--   
--   <pre>
--   some text
--        to
--        lay
--        out
--   </pre>
vsep :: [Doc] -> Doc

-- | The document <tt>(cat xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;&gt;)</tt>, if it fits the page, or
--   vertically with <tt>(&lt;$$&gt;)</tt>.
--   
--   <pre>
--   cat xs  = group (vcat xs)
--   </pre>
cat :: [Doc] -> Doc

-- | The document <tt>(fillCat xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt> as long as its fits the page,
--   than inserts a <tt>linebreak</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillCat xs  = foldr (&lt;//&gt;) empty xs
--   </pre>
fillCat :: [Doc] -> Doc

-- | The document <tt>(hcat xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt>.
hcat :: [Doc] -> Doc

-- | The document <tt>(vcat xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>(&lt;$$&gt;)</tt>. If a <a>group</a> undoes the
--   line breaks inserted by <tt>vcat</tt>, all documents are directly
--   concatenated.
vcat :: [Doc] -> Doc
fold :: (Doc -> Doc -> Doc) -> [Doc] -> Doc

-- | The document <tt>(x &lt;+&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <tt>space</tt> in between. (infixr 6)
(<+>) :: Doc -> Doc -> Doc
infixr 6 <+>

-- | The document <tt>(x &lt;/&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>softline</a> in between. This effectively
--   puts <tt>x</tt> and <tt>y</tt> either next to each other (with a
--   <tt>space</tt> in between) or underneath each other. (infixr 5)
(</>) :: Doc -> Doc -> Doc
infixr 5 </>

-- | The document <tt>(x &lt;//&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <a>softbreak</a> in between. This
--   effectively puts <tt>x</tt> and <tt>y</tt> either right next to each
--   other or underneath each other. (infixr 5)
(<//>) :: Doc -> Doc -> Doc
infixr 5 <//>

-- | The document <tt>(x &lt;$&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>line</a> in between. (infixr 5)
(<$>) :: Doc -> Doc -> Doc
infixr 5 <$>

-- | The document <tt>(x &lt;$$&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <tt>linebreak</tt> in between.
--   (infixr 5)
(<$$>) :: Doc -> Doc -> Doc
infixr 5 <$$>

-- | The document <tt>softline</tt> behaves like <a>space</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softline = group line
--   </pre>
softline :: Doc

-- | The document <tt>softbreak</tt> behaves like <a>empty</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softbreak  = group linebreak
--   </pre>
softbreak :: Doc

-- | Document <tt>(squotes x)</tt> encloses document <tt>x</tt> with single
--   quotes "'".
squotes :: Doc -> Doc

-- | Document <tt>(dquotes x)</tt> encloses document <tt>x</tt> with double
--   quotes '"'.
dquotes :: Doc -> Doc

-- | Document <tt>(braces x)</tt> encloses document <tt>x</tt> in braces,
--   "{" and "}".
braces :: Doc -> Doc

-- | Document <tt>(parens x)</tt> encloses document <tt>x</tt> in
--   parenthesis, "(" and ")".
parens :: Doc -> Doc

-- | Document <tt>(angles x)</tt> encloses document <tt>x</tt> in angles,
--   "&lt;" and "&gt;".
angles :: Doc -> Doc

-- | Document <tt>(brackets x)</tt> encloses document <tt>x</tt> in square
--   brackets, "[" and "]".
brackets :: Doc -> Doc

-- | The document <tt>(enclose l r x)</tt> encloses document <tt>x</tt>
--   between documents <tt>l</tt> and <tt>r</tt> using <tt>(&lt;&gt;)</tt>.
--   
--   <pre>
--   enclose l r x   = l &lt;&gt; x &lt;&gt; r
--   </pre>
enclose :: Doc -> Doc -> Doc -> Doc

-- | The document <tt>lparen</tt> contains a left parenthesis, "(".
lparen :: Doc

-- | The document <tt>rparen</tt> contains a right parenthesis, ")".
rparen :: Doc

-- | The document <tt>langle</tt> contains a left angle, "&lt;".
langle :: Doc

-- | The document <tt>rangle</tt> contains a right angle, "&gt;".
rangle :: Doc

-- | The document <tt>lbrace</tt> contains a left brace, "{".
lbrace :: Doc

-- | The document <tt>rbrace</tt> contains a right brace, "}".
rbrace :: Doc

-- | The document <tt>lbracket</tt> contains a left square bracket, "[".
lbracket :: Doc

-- | The document <tt>rbracket</tt> contains a right square bracket, "]".
rbracket :: Doc

-- | The document <tt>squote</tt> contains a single quote, "'".
squote :: Doc

-- | The document <tt>dquote</tt> contains a double quote, '"'.
dquote :: Doc

-- | The document <tt>semi</tt> contains a semicolon, ";".
semi :: Doc

-- | The document <tt>colon</tt> contains a colon, ":".
colon :: Doc

-- | The document <tt>comma</tt> contains a comma, ",".
comma :: Doc

-- | The document <tt>space</tt> contains a single space, " ".
--   
--   <pre>
--   x &lt;+&gt; y   = x &lt;&gt; space &lt;&gt; y
--   </pre>
space :: Doc

-- | The document <tt>dot</tt> contains a single dot, ".".
dot :: Doc

-- | The document <tt>backslash</tt> contains a back slash, "\".
backslash :: Doc

-- | The document <tt>equals</tt> contains an equal sign, "=".
equals :: Doc

-- | The document <tt>(string s)</tt> concatenates all characters in
--   <tt>s</tt> using <tt>line</tt> for newline characters and
--   <tt>char</tt> for all other characters. It is used instead of
--   <a>text</a> whenever the text contains newline characters.
string :: String -> Doc

-- | The document <tt>(bool b)</tt> shows the literal bool <tt>b</tt> using
--   <a>text</a>.
bool :: Bool -> Doc

-- | The document <tt>(int i)</tt> shows the literal integer <tt>i</tt>
--   using <a>text</a>.
int :: Int -> Doc

-- | The document <tt>(integer i)</tt> shows the literal integer <tt>i</tt>
--   using <a>text</a>.
integer :: Integer -> Doc

-- | The document <tt>(float f)</tt> shows the literal float <tt>f</tt>
--   using <a>text</a>.
float :: Float -> Doc

-- | The document <tt>(double d)</tt> shows the literal double <tt>d</tt>
--   using <a>text</a>.
double :: Double -> Doc

-- | The document <tt>(rational r)</tt> shows the literal rational
--   <tt>r</tt> using <a>text</a>.
rational :: Rational -> Doc

-- | The member <tt>prettyList</tt> is only used to define the <tt>instance
--   Pretty a =&gt; Pretty [a]</tt>. In normal circumstances only the
--   <tt>pretty</tt> function is used.
class Pretty a
pretty :: Pretty a => a -> Doc
prettyList :: Pretty a => [a] -> Doc

-- | The document <tt>(fillBreak i x)</tt> first renders document
--   <tt>x</tt>. It than appends <tt>space</tt>s until the width is equal
--   to <tt>i</tt>. If the width of <tt>x</tt> is already larger than
--   <tt>i</tt>, the nesting level is increased by <tt>i</tt> and a
--   <tt>line</tt> is appended. When we redefine <tt>ptype</tt> in the
--   previous example to use <tt>fillBreak</tt>, we get a useful variation
--   of the previous output:
--   
--   <pre>
--   ptype (name,tp)
--          = fillBreak 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   </pre>
--   
--   The output will now be:
--   
--   <pre>
--   let empty  :: Doc
--       nest   :: Int -&gt; Doc -&gt; Doc
--       linebreak
--              :: Doc
--   </pre>
fillBreak :: Int -> Doc -> Doc

-- | The document <tt>(fill i x)</tt> renders document <tt>x</tt>. It than
--   appends <tt>space</tt>s until the width is equal to <tt>i</tt>. If the
--   width of <tt>x</tt> is already larger, nothing is appended. This
--   combinator is quite useful in practice to output a list of bindings.
--   The following example demonstrates this.
--   
--   <pre>
--   types  = [("empty","Doc")
--            ,("nest","Int -&gt; Doc -&gt; Doc")
--            ,("linebreak","Doc")]
--   
--   ptype (name,tp)
--          = fill 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   
--   test   = text "let" &lt;+&gt; align (vcat (map ptype types))
--   </pre>
--   
--   Which is layed out as:
--   
--   <pre>
--   let empty  :: Doc
--       nest   :: Int -&gt; Doc -&gt; Doc
--       linebreak :: Doc
--   </pre>
fill :: Int -> Doc -> Doc
width :: Doc -> (Int -> Doc) -> Doc

-- | The document <tt>(indent i x)</tt> indents document <tt>x</tt> with
--   <tt>i</tt> spaces.
--   
--   <pre>
--   test  = indent 4 (fillSep (map text
--           (words "the indent combinator indents these words !")))
--   </pre>
--   
--   Which lays out with a page width of 20 as:
--   
--   <pre>
--   the indent
--   combinator
--   indents these
--   words !
--   </pre>
indent :: Int -> Doc -> Doc

-- | The hang combinator implements hanging indentation. The document
--   <tt>(hang i x)</tt> renders document <tt>x</tt> with a nesting level
--   set to the current column plus <tt>i</tt>. The following example uses
--   hanging indentation for some text:
--   
--   <pre>
--   test  = hang 4 (fillSep (map text
--           (words "the hang combinator indents these words !")))
--   </pre>
--   
--   Which lays out on a page with a width of 20 characters as:
--   
--   <pre>
--   the hang combinator
--       indents these
--       words !
--   </pre>
--   
--   The <tt>hang</tt> combinator is implemented as:
--   
--   <pre>
--   hang i x  = align (nest i x)
--   </pre>
hang :: Int -> Doc -> Doc

-- | The document <tt>(align x)</tt> renders document <tt>x</tt> with the
--   nesting level set to the current column. It is used for example to
--   implement <a>hang</a>.
--   
--   As an example, we will put a document right above another one,
--   regardless of the current nesting level:
--   
--   <pre>
--   x $$ y  = align (x &lt;$&gt; y)
--   </pre>
--   
--   <pre>
--   test    = text "hi" &lt;+&gt; (text "nice" $$ text "world")
--   </pre>
--   
--   which will be layed out as:
--   
--   <pre>
--   hi nice
--      world
--   </pre>
align :: Doc -> Doc

-- | The abstract data type <tt>Doc</tt> represents pretty documents.
--   
--   More specifically, a value of type <tt>Doc</tt> represents a non-empty
--   set of possible renderings of a document. The rendering functions
--   select one of these possibilities.
--   
--   <tt>Doc</tt> is an instance of the <a>Show</a> class. <tt>(show
--   doc)</tt> pretty prints document <tt>doc</tt> with a page width of 80
--   characters and a ribbon width of 32 characters.
--   
--   <pre>
--   show (text "hello" &lt;$&gt; text "world")
--   </pre>
--   
--   Which would return the string "hello\nworld", i.e.
--   
--   <pre>
--   hello
--   world
--   </pre>
data Doc
Fail :: Doc
Empty :: Doc
Char :: Char -> Doc
Text :: !Int -> String -> Doc
Line :: Doc
FlatAlt :: Doc -> Doc -> Doc
Cat :: Doc -> Doc -> Doc
Nest :: !Int -> Doc -> Doc
Union :: Doc -> Doc -> Doc
Column :: (Int -> Doc) -> Doc
Columns :: (Maybe Int -> Doc) -> Doc
Nesting :: (Int -> Doc) -> Doc
Color :: ConsoleLayer -> ColorIntensity -> Color -> Doc -> Doc
Intensify :: ConsoleIntensity -> Doc -> Doc
Italicize :: Bool -> Doc -> Doc
Underline :: Underlining -> Doc -> Doc
RestoreFormat :: Maybe (ColorIntensity, Color) -> Maybe (ColorIntensity, Color) -> Maybe ConsoleIntensity -> Maybe Bool -> Maybe Underlining -> Doc

-- | The data type <tt>SimpleDoc</tt> represents rendered documents and is
--   used by the display functions.
--   
--   Whereas values of the data type <a>Doc</a> represent non-empty sets of
--   possible renderings of a document, values of the data type
--   <tt>SimpleDoc</tt> represent single renderings of a document.
--   
--   The <tt>Int</tt> in <tt>SText</tt> contains the length of the string.
--   The <tt>Int</tt> in <tt>SLine</tt> contains the indentation for that
--   line. The library provides two default display functions
--   <a>displayS</a> and <a>displayIO</a>. You can provide your own display
--   function by writing a function from a <tt>SimpleDoc</tt> to your own
--   output format.
data SimpleDoc
SFail :: SimpleDoc
SEmpty :: SimpleDoc
SChar :: Char -> SimpleDoc -> SimpleDoc
SText :: !Int -> String -> SimpleDoc -> SimpleDoc
SLine :: !Int -> SimpleDoc -> SimpleDoc
SSGR :: [SGR] -> SimpleDoc -> SimpleDoc

-- | The empty document is, indeed, empty. Although <tt>empty</tt> has no
--   content, it does have a 'height' of 1 and behaves exactly like
--   <tt>(text "")</tt> (and is therefore not a unit of
--   <tt>&lt;$&gt;</tt>).
empty :: Doc

-- | The document <tt>(char c)</tt> contains the literal character
--   <tt>c</tt>. The character shouldn't be a newline (<tt>'n'</tt>), the
--   function <a>line</a> should be used for line breaks.
char :: Char -> Doc

-- | The document <tt>(text s)</tt> contains the literal string <tt>s</tt>.
--   The string shouldn't contain any newline (<tt>'n'</tt>) characters. If
--   the string contains newline characters, the function <a>string</a>
--   should be used.
text :: String -> Doc

-- | The <tt>line</tt> document advances to the next line and indents to
--   the current nesting level. Document <tt>line</tt> behaves like
--   <tt>(text " ")</tt> if the line break is undone by <a>group</a>.
line :: Doc

-- | The <tt>linebreak</tt> document advances to the next line and indents
--   to the current nesting level. Document <tt>linebreak</tt> behaves like
--   <a>empty</a> if the line break is undone by <a>group</a>.
linebreak :: Doc

-- | A linebreak that will never be flattened; it is guaranteed to render
--   as a newline.
hardline :: Doc
beside :: Doc -> Doc -> Doc

-- | The document <tt>(nest i x)</tt> renders document <tt>x</tt> with the
--   current indentation level increased by i (See also <a>hang</a>,
--   <a>align</a> and <a>indent</a>).
--   
--   <pre>
--   nest 2 (text "hello" &lt;$&gt; text "world") &lt;$&gt; text "!"
--   </pre>
--   
--   outputs as:
--   
--   <pre>
--   hello
--     world
--   !
--   </pre>
nest :: Int -> Doc -> Doc
column :: (Int -> Doc) -> Doc
nesting :: (Int -> Doc) -> Doc
columns :: (Maybe Int -> Doc) -> Doc

-- | The <tt>group</tt> combinator is used to specify alternative layouts.
--   The document <tt>(group x)</tt> undoes all line breaks in document
--   <tt>x</tt>. The resulting line is added to the current line if that
--   fits the page. Otherwise, the document <tt>x</tt> is rendered without
--   any changes.
group :: Doc -> Doc

-- | A document that is normally rendered as the first argument, but when
--   flattened, is rendered as the second document.
flatAlt :: Doc -> Doc -> Doc
flatten :: Doc -> Doc

-- | Displays a document with the black forecolor
black :: Doc -> Doc

-- | Displays a document with the red forecolor
red :: Doc -> Doc

-- | Displays a document with the green forecolor
green :: Doc -> Doc

-- | Displays a document with the yellow forecolor
yellow :: Doc -> Doc

-- | Displays a document with the blue forecolor
blue :: Doc -> Doc

-- | Displays a document with the magenta forecolor
magenta :: Doc -> Doc

-- | Displays a document with the cyan forecolor
cyan :: Doc -> Doc

-- | Displays a document with the white forecolor
white :: Doc -> Doc

-- | Displays a document with the dull black forecolor
dullblack :: Doc -> Doc

-- | Displays a document with the dull red forecolor
dullred :: Doc -> Doc

-- | Displays a document with the dull green forecolor
dullgreen :: Doc -> Doc

-- | Displays a document with the dull yellow forecolor
dullyellow :: Doc -> Doc

-- | Displays a document with the dull blue forecolor
dullblue :: Doc -> Doc

-- | Displays a document with the dull magenta forecolor
dullmagenta :: Doc -> Doc

-- | Displays a document with the dull cyan forecolor
dullcyan :: Doc -> Doc

-- | Displays a document with the dull white forecolor
dullwhite :: Doc -> Doc

-- | Displays a document with a forecolor given in the first parameter
color :: Color -> Doc -> Doc

-- | Displays a document with a dull forecolor given in the first parameter
dullcolor :: Color -> Doc -> Doc
colorFunctions :: Color -> (Doc -> Doc, Doc -> Doc)

-- | Displays a document with the black backcolor
onblack :: Doc -> Doc

-- | Displays a document with the red backcolor
onred :: Doc -> Doc

-- | Displays a document with the green backcolor
ongreen :: Doc -> Doc

-- | Displays a document with the yellow backcolor
onyellow :: Doc -> Doc

-- | Displays a document with the blue backcolor
onblue :: Doc -> Doc

-- | Displays a document with the magenta backcolor
onmagenta :: Doc -> Doc

-- | Displays a document with the cyan backcolor
oncyan :: Doc -> Doc

-- | Displays a document with the white backcolor
onwhite :: Doc -> Doc

-- | Displays a document with the dull black backcolor
ondullblack :: Doc -> Doc

-- | Displays a document with the dull red backcolor
ondullred :: Doc -> Doc

-- | Displays a document with the dull green backcolor
ondullgreen :: Doc -> Doc

-- | Displays a document with the dull yellow backcolor
ondullyellow :: Doc -> Doc

-- | Displays a document with the dull blue backcolor
ondullblue :: Doc -> Doc

-- | Displays a document with the dull magenta backcolor
ondullmagenta :: Doc -> Doc

-- | Displays a document with the dull cyan backcolor
ondullcyan :: Doc -> Doc

-- | Displays a document with the dull white backcolor
ondullwhite :: Doc -> Doc

-- | Displays a document with a backcolor given in the first parameter
oncolor :: Color -> Doc -> Doc

-- | Displays a document with a dull backcolor given in the first parameter
ondullcolor :: Color -> Doc -> Doc
oncolorFunctions :: Color -> (Doc -> Doc, Doc -> Doc)

-- | Displays a document in a heavier font weight
bold :: Doc -> Doc

-- | Displays a document in the normal font weight
debold :: Doc -> Doc

-- | Displays a document with underlining
underline :: Doc -> Doc

-- | Displays a document with no underlining
deunderline :: Doc -> Doc

-- | Removes all colorisation, emboldening and underlining from a document
plain :: Doc -> Doc
data Docs
Nil :: Docs
Cons :: !Int -> Doc -> Docs -> Docs

-- | This is the default pretty printer which is used by <a>show</a>,
--   <a>putDoc</a> and <a>hPutDoc</a>. <tt>(renderPretty ribbonfrac width
--   x)</tt> renders document <tt>x</tt> with a page width of
--   <tt>width</tt> and a ribbon width of <tt>(ribbonfrac * width)</tt>
--   characters. The ribbon width is the maximal amount of non-indentation
--   characters on a line. The parameter <tt>ribbonfrac</tt> should be
--   between <tt>0.0</tt> and <tt>1.0</tt>. If it is lower or higher, the
--   ribbon width will be 0 or <tt>width</tt> respectively.
renderPretty :: Float -> Int -> Doc -> SimpleDoc

-- | A slightly smarter rendering algorithm with more lookahead. It
--   provides provide earlier breaking on deeply nested structures For
--   example, consider this python-ish pseudocode:
--   <tt>fun(fun(fun(fun(fun([abcdefg, abcdefg])))))</tt> If we put a
--   softbreak (+ nesting 2) after each open parenthesis, and align the
--   elements of the list to match the opening brackets, this will render
--   with <tt>renderPretty</tt> and a page width of 20 as: <tt>
--   fun(fun(fun(fun(fun([ | abcdef, | abcdef, ] ))))) | </tt> Where the
--   20c. boundary has been marked with |. Because <tt>renderPretty</tt>
--   only uses one-line lookahead, it sees that the first line fits, and is
--   stuck putting the second and third lines after the 20-c mark. In
--   contrast, <tt>renderSmart</tt> will continue to check that the
--   potential document up to the end of the indentation level. Thus, it
--   will format the document as:
--   
--   <pre>
--   fun(                |
--     fun(              |
--       fun(            |
--         fun(          |
--           fun([       |
--                 abcdef,
--                 abcdef,
--               ]       |
--     )))))             |
--   </pre>
--   
--   Which fits within the 20c. boundary.
renderSmart :: Float -> Int -> Doc -> SimpleDoc
renderFits :: (Int -> Int -> Int -> SimpleDoc -> Bool) -> Float -> Int -> Doc -> SimpleDoc
fits1 :: Int -> Int -> Int -> SimpleDoc -> Bool
fitsR :: Int -> Int -> Int -> SimpleDoc -> Bool

-- | <tt>(renderCompact x)</tt> renders document <tt>x</tt> without adding
--   any indentation. Since no 'pretty' printing is involved, this renderer
--   is very fast. The resulting output contains fewer characters than a
--   pretty printed version and can be used for output that is read by
--   other programs.
--   
--   This rendering function does not add any colorisation information.
renderCompact :: Doc -> SimpleDoc

-- | <tt>(displayS simpleDoc)</tt> takes the output <tt>simpleDoc</tt> from
--   a rendering function and transforms it to a <a>ShowS</a> type (for use
--   in the <a>Show</a> class).
--   
--   <pre>
--   showWidth :: Int -&gt; Doc -&gt; String
--   showWidth w x   = displayS (renderPretty 0.4 w x) ""
--   </pre>
--   
--   ANSI color information will be discarded by this function unless you
--   are running on a Unix-like operating system. This is due to a
--   technical limitation in Windows ANSI support.
displayS :: SimpleDoc -> ShowS

-- | <tt>(displayIO handle simpleDoc)</tt> writes <tt>simpleDoc</tt> to the
--   file handle <tt>handle</tt>. This function is used for example by
--   <a>hPutDoc</a>:
--   
--   <pre>
--   hPutDoc handle doc  = displayIO handle (renderPretty 0.4 80 doc)
--   </pre>
--   
--   Any ANSI colorisation in <tt>simpleDoc</tt> will be output.
displayIO :: Handle -> SimpleDoc -> IO ()

-- | The action <tt>(putDoc doc)</tt> pretty prints document <tt>doc</tt>
--   to the standard output, with a page width of 80 characters and a
--   ribbon width of 32 characters.
--   
--   <pre>
--   main :: IO ()
--   main = do{ putDoc (text "hello" &lt;+&gt; text "world") }
--   </pre>
--   
--   Which would output
--   
--   <pre>
--   hello world
--   </pre>
--   
--   Any ANSI colorisation in <tt>doc</tt> will be output.
putDoc :: Doc -> IO ()

-- | <tt>(hPutDoc handle doc)</tt> pretty prints document <tt>doc</tt> to
--   the file handle <tt>handle</tt> with a page width of 80 characters and
--   a ribbon width of 32 characters.
--   
--   <pre>
--   main = do{ handle &lt;- openFile "MyFile" WriteMode
--            ; hPutDoc handle (vcat (map text
--                              ["vertical","text"]))
--            ; hClose handle
--            }
--   </pre>
--   
--   Any ANSI colorisation in <tt>doc</tt> will be output.
hPutDoc :: Handle -> Doc -> IO ()
spaces :: Int -> String
indentation :: Int -> String
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty a => Text.PrettyPrint.ANSI.Leijen.Internal.Pretty [a]
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Text.PrettyPrint.ANSI.Leijen.Internal.Doc
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty ()
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty GHC.Types.Bool
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty GHC.Types.Char
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty GHC.Types.Int
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty GHC.Num.Integer.Integer
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty GHC.Types.Float
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty GHC.Types.Double
instance (Text.PrettyPrint.ANSI.Leijen.Internal.Pretty a, Text.PrettyPrint.ANSI.Leijen.Internal.Pretty b) => Text.PrettyPrint.ANSI.Leijen.Internal.Pretty (a, b)
instance (Text.PrettyPrint.ANSI.Leijen.Internal.Pretty a, Text.PrettyPrint.ANSI.Leijen.Internal.Pretty b, Text.PrettyPrint.ANSI.Leijen.Internal.Pretty c) => Text.PrettyPrint.ANSI.Leijen.Internal.Pretty (a, b, c)
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty a => Text.PrettyPrint.ANSI.Leijen.Internal.Pretty (GHC.Maybe.Maybe a)
instance GHC.Base.Monoid Text.PrettyPrint.ANSI.Leijen.Internal.Doc
instance GHC.Base.Semigroup Text.PrettyPrint.ANSI.Leijen.Internal.Doc
instance Data.String.IsString Text.PrettyPrint.ANSI.Leijen.Internal.Doc
instance GHC.Show.Show Text.PrettyPrint.ANSI.Leijen.Internal.Doc


-- | This module is an extended implementation of the functional pretty
--   printer given by Philip Wadler (1997):
--   
--   <pre>
--   "A prettier printer"
--   Draft paper, April 1997, revised March 1998.
--   <a>https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf</a>
--   </pre>
--   
--   In their bare essence, the combinators given by Wadler are not
--   expressive enough to describe some commonly occurring layouts. This
--   library adds new primitives to describe these layouts and works well
--   in practice.
--   
--   The library is based on a single way to concatenate documents, which
--   is associative and has both a left and right unit. This simple design
--   leads to an efficient and short implementation. The simplicity is
--   reflected in the predictable behaviour of the combinators which make
--   them easy to use in practice.
--   
--   A thorough description of the primitive combinators and their
--   implementation can be found in Philip Wadler's paper. The main
--   differences with his original paper are:
--   
--   <ul>
--   <li>The nil document is called <a>empty</a>.</li>
--   <li>The above combinator is called <a>&lt;$&gt;</a>. The operator
--   <a>&lt;/&gt;</a> is used for soft line breaks.</li>
--   <li>There are three new primitives: <a>align</a>, <a>fill</a> and
--   <a>fillBreak</a>. These are very useful in practice.</li>
--   <li>There are many additional useful combinators, like <a>fillSep</a>
--   and <a>list</a>.</li>
--   <li>There are two renderers: <a>renderPretty</a> for pretty printing,
--   and <a>renderCompact</a> for quickly rendered, compact output more
--   suitable for generating input to other programs.</li>
--   <li>The pretty printing algorithm used by <a>renderPretty</a> extends
--   the algorithm given by Wadler to take into account a "ribbon width",
--   i.e., a desired maximum number of non-indentation characters to output
--   on any one line.</li>
--   <li>There are two displayers, <a>displayS</a> for strings and
--   <a>displayIO</a> for file-based output.</li>
--   <li>There is a <a>Pretty</a> class.</li>
--   <li>The implementation uses optimised representations and strictness
--   annotations.</li>
--   <li>The library has been extended to allow formatting text for output
--   to ANSI style consoles. New combinators allow control of foreground
--   and background color and the ability to make parts of the text bold or
--   underlined.</li>
--   </ul>
module Text.PrettyPrint.ANSI.Leijen

-- | The abstract data type <tt>Doc</tt> represents pretty documents.
--   
--   More specifically, a value of type <tt>Doc</tt> represents a non-empty
--   set of possible renderings of a document. The rendering functions
--   select one of these possibilities.
--   
--   <tt>Doc</tt> is an instance of the <a>Show</a> class. <tt>(show
--   doc)</tt> pretty prints document <tt>doc</tt> with a page width of 80
--   characters and a ribbon width of 32 characters.
--   
--   <pre>
--   show (text "hello" &lt;$&gt; text "world")
--   </pre>
--   
--   Which would return the string "hello\nworld", i.e.
--   
--   <pre>
--   hello
--   world
--   </pre>
data Doc

-- | The empty document is, indeed, empty. Although <tt>empty</tt> has no
--   content, it does have a 'height' of 1 and behaves exactly like
--   <tt>(text "")</tt> (and is therefore not a unit of
--   <tt>&lt;$&gt;</tt>).
empty :: Doc

-- | The document <tt>(char c)</tt> contains the literal character
--   <tt>c</tt>. The character shouldn't be a newline (<tt>'n'</tt>), the
--   function <a>line</a> should be used for line breaks.
char :: Char -> Doc

-- | The document <tt>(text s)</tt> contains the literal string <tt>s</tt>.
--   The string shouldn't contain any newline (<tt>'n'</tt>) characters. If
--   the string contains newline characters, the function <a>string</a>
--   should be used.
text :: String -> Doc

-- | The document <tt>(string s)</tt> concatenates all characters in
--   <tt>s</tt> using <tt>line</tt> for newline characters and
--   <tt>char</tt> for all other characters. It is used instead of
--   <a>text</a> whenever the text contains newline characters.
string :: String -> Doc

-- | The document <tt>(int i)</tt> shows the literal integer <tt>i</tt>
--   using <a>text</a>.
int :: Int -> Doc

-- | The document <tt>(integer i)</tt> shows the literal integer <tt>i</tt>
--   using <a>text</a>.
integer :: Integer -> Doc

-- | The document <tt>(float f)</tt> shows the literal float <tt>f</tt>
--   using <a>text</a>.
float :: Float -> Doc

-- | The document <tt>(double d)</tt> shows the literal double <tt>d</tt>
--   using <a>text</a>.
double :: Double -> Doc

-- | The document <tt>(rational r)</tt> shows the literal rational
--   <tt>r</tt> using <a>text</a>.
rational :: Rational -> Doc

-- | The document <tt>(bool b)</tt> shows the literal bool <tt>b</tt> using
--   <a>text</a>.
bool :: Bool -> Doc

-- | An associative operation.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The document <tt>(nest i x)</tt> renders document <tt>x</tt> with the
--   current indentation level increased by i (See also <a>hang</a>,
--   <a>align</a> and <a>indent</a>).
--   
--   <pre>
--   nest 2 (text "hello" &lt;$&gt; text "world") &lt;$&gt; text "!"
--   </pre>
--   
--   outputs as:
--   
--   <pre>
--   hello
--     world
--   !
--   </pre>
nest :: Int -> Doc -> Doc

-- | The <tt>line</tt> document advances to the next line and indents to
--   the current nesting level. Document <tt>line</tt> behaves like
--   <tt>(text " ")</tt> if the line break is undone by <a>group</a>.
line :: Doc

-- | The <tt>linebreak</tt> document advances to the next line and indents
--   to the current nesting level. Document <tt>linebreak</tt> behaves like
--   <a>empty</a> if the line break is undone by <a>group</a>.
linebreak :: Doc

-- | The <tt>group</tt> combinator is used to specify alternative layouts.
--   The document <tt>(group x)</tt> undoes all line breaks in document
--   <tt>x</tt>. The resulting line is added to the current line if that
--   fits the page. Otherwise, the document <tt>x</tt> is rendered without
--   any changes.
group :: Doc -> Doc

-- | The document <tt>softline</tt> behaves like <a>space</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softline = group line
--   </pre>
softline :: Doc

-- | The document <tt>softbreak</tt> behaves like <a>empty</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softbreak  = group linebreak
--   </pre>
softbreak :: Doc

-- | A linebreak that will never be flattened; it is guaranteed to render
--   as a newline.
hardline :: Doc

-- | A document that is normally rendered as the first argument, but when
--   flattened, is rendered as the second document.
flatAlt :: Doc -> Doc -> Doc

-- | The document <tt>(align x)</tt> renders document <tt>x</tt> with the
--   nesting level set to the current column. It is used for example to
--   implement <a>hang</a>.
--   
--   As an example, we will put a document right above another one,
--   regardless of the current nesting level:
--   
--   <pre>
--   x $$ y  = align (x &lt;$&gt; y)
--   </pre>
--   
--   <pre>
--   test    = text "hi" &lt;+&gt; (text "nice" $$ text "world")
--   </pre>
--   
--   which will be layed out as:
--   
--   <pre>
--   hi nice
--      world
--   </pre>
align :: Doc -> Doc

-- | The hang combinator implements hanging indentation. The document
--   <tt>(hang i x)</tt> renders document <tt>x</tt> with a nesting level
--   set to the current column plus <tt>i</tt>. The following example uses
--   hanging indentation for some text:
--   
--   <pre>
--   test  = hang 4 (fillSep (map text
--           (words "the hang combinator indents these words !")))
--   </pre>
--   
--   Which lays out on a page with a width of 20 characters as:
--   
--   <pre>
--   the hang combinator
--       indents these
--       words !
--   </pre>
--   
--   The <tt>hang</tt> combinator is implemented as:
--   
--   <pre>
--   hang i x  = align (nest i x)
--   </pre>
hang :: Int -> Doc -> Doc

-- | The document <tt>(indent i x)</tt> indents document <tt>x</tt> with
--   <tt>i</tt> spaces.
--   
--   <pre>
--   test  = indent 4 (fillSep (map text
--           (words "the indent combinator indents these words !")))
--   </pre>
--   
--   Which lays out with a page width of 20 as:
--   
--   <pre>
--   the indent
--   combinator
--   indents these
--   words !
--   </pre>
indent :: Int -> Doc -> Doc

-- | The document <tt>(encloseSep l r sep xs)</tt> concatenates the
--   documents <tt>xs</tt> separated by <tt>sep</tt> and encloses the
--   resulting document by <tt>l</tt> and <tt>r</tt>. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All separators are put in front of the elements.
--   For example, the combinator <a>list</a> can be defined with
--   <tt>encloseSep</tt>:
--   
--   <pre>
--   list xs = encloseSep lbracket rbracket comma xs
--   test    = text "list" &lt;+&gt; (list (map int [10,200,3000]))
--   </pre>
--   
--   Which is layed out with a page width of 20 as:
--   
--   <pre>
--   list [10,200,3000]
--   </pre>
--   
--   But when the page width is 15, it is layed out as:
--   
--   <pre>
--   list [10
--        ,200
--        ,3000]
--   </pre>
encloseSep :: Doc -> Doc -> Doc -> [Doc] -> Doc

-- | The document <tt>(list xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in square brackets. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
list :: [Doc] -> Doc

-- | The document <tt>(tupled xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in parenthesis. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
tupled :: [Doc] -> Doc

-- | The document <tt>(semiBraces xs)</tt> separates the documents
--   <tt>xs</tt> with semicolons and encloses them in braces. The documents
--   are rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All semicolons are put in front of the elements.
semiBraces :: [Doc] -> Doc

-- | The document <tt>(x &lt;+&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <tt>space</tt> in between. (infixr 6)
(<+>) :: Doc -> Doc -> Doc
infixr 6 <+>

-- | The document <tt>(x &lt;$&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>line</a> in between. (infixr 5)
(<$>) :: Doc -> Doc -> Doc
infixr 5 <$>

-- | The document <tt>(x &lt;/&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>softline</a> in between. This effectively
--   puts <tt>x</tt> and <tt>y</tt> either next to each other (with a
--   <tt>space</tt> in between) or underneath each other. (infixr 5)
(</>) :: Doc -> Doc -> Doc
infixr 5 </>

-- | The document <tt>(x &lt;$$&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <tt>linebreak</tt> in between.
--   (infixr 5)
(<$$>) :: Doc -> Doc -> Doc
infixr 5 <$$>

-- | The document <tt>(x &lt;//&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <a>softbreak</a> in between. This
--   effectively puts <tt>x</tt> and <tt>y</tt> either right next to each
--   other or underneath each other. (infixr 5)
(<//>) :: Doc -> Doc -> Doc
infixr 5 <//>

-- | The document <tt>(hsep xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt>.
hsep :: [Doc] -> Doc

-- | The document <tt>(vsep xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>(&lt;$&gt;)</tt>. If a <a>group</a> undoes the
--   line breaks inserted by <tt>vsep</tt>, all documents are separated
--   with a space.
--   
--   <pre>
--   someText = map text (words ("text to lay out"))
--   
--   test     = text "some" &lt;+&gt; vsep someText
--   </pre>
--   
--   This is layed out as:
--   
--   <pre>
--   some text
--   to
--   lay
--   out
--   </pre>
--   
--   The <a>align</a> combinator can be used to align the documents under
--   their first element
--   
--   <pre>
--   test     = text "some" &lt;+&gt; align (vsep someText)
--   </pre>
--   
--   Which is printed as:
--   
--   <pre>
--   some text
--        to
--        lay
--        out
--   </pre>
vsep :: [Doc] -> Doc

-- | The document <tt>(fillSep xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt> as long as its fits the page,
--   than inserts a <tt>line</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillSep xs  = foldr (&lt;/&gt;) empty xs
--   </pre>
fillSep :: [Doc] -> Doc

-- | The document <tt>(sep xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;+&gt;)</tt>, if it fits the page, or
--   vertically with <tt>(&lt;$&gt;)</tt>.
--   
--   <pre>
--   sep xs  = group (vsep xs)
--   </pre>
sep :: [Doc] -> Doc

-- | The document <tt>(hcat xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt>.
hcat :: [Doc] -> Doc

-- | The document <tt>(vcat xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>(&lt;$$&gt;)</tt>. If a <a>group</a> undoes the
--   line breaks inserted by <tt>vcat</tt>, all documents are directly
--   concatenated.
vcat :: [Doc] -> Doc

-- | The document <tt>(fillCat xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt> as long as its fits the page,
--   than inserts a <tt>linebreak</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillCat xs  = foldr (&lt;//&gt;) empty xs
--   </pre>
fillCat :: [Doc] -> Doc

-- | The document <tt>(cat xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;&gt;)</tt>, if it fits the page, or
--   vertically with <tt>(&lt;$$&gt;)</tt>.
--   
--   <pre>
--   cat xs  = group (vcat xs)
--   </pre>
cat :: [Doc] -> Doc

-- | <tt>(punctuate p xs)</tt> concatenates all documents in <tt>xs</tt>
--   with document <tt>p</tt> except for the last document.
--   
--   <pre>
--   someText = map text ["words","in","a","tuple"]
--   test     = parens (align (cat (punctuate comma someText)))
--   </pre>
--   
--   This is layed out on a page width of 20 as:
--   
--   <pre>
--   (words,in,a,tuple)
--   </pre>
--   
--   But when the page width is 15, it is layed out as:
--   
--   <pre>
--   (words,
--    in,
--    a,
--    tuple)
--   </pre>
--   
--   (If you want put the commas in front of their elements instead of at
--   the end, you should use <a>tupled</a> or, in general,
--   <a>encloseSep</a>.)
punctuate :: Doc -> [Doc] -> [Doc]

-- | The document <tt>(fill i x)</tt> renders document <tt>x</tt>. It than
--   appends <tt>space</tt>s until the width is equal to <tt>i</tt>. If the
--   width of <tt>x</tt> is already larger, nothing is appended. This
--   combinator is quite useful in practice to output a list of bindings.
--   The following example demonstrates this.
--   
--   <pre>
--   types  = [("empty","Doc")
--            ,("nest","Int -&gt; Doc -&gt; Doc")
--            ,("linebreak","Doc")]
--   
--   ptype (name,tp)
--          = fill 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   
--   test   = text "let" &lt;+&gt; align (vcat (map ptype types))
--   </pre>
--   
--   Which is layed out as:
--   
--   <pre>
--   let empty  :: Doc
--       nest   :: Int -&gt; Doc -&gt; Doc
--       linebreak :: Doc
--   </pre>
fill :: Int -> Doc -> Doc

-- | The document <tt>(fillBreak i x)</tt> first renders document
--   <tt>x</tt>. It than appends <tt>space</tt>s until the width is equal
--   to <tt>i</tt>. If the width of <tt>x</tt> is already larger than
--   <tt>i</tt>, the nesting level is increased by <tt>i</tt> and a
--   <tt>line</tt> is appended. When we redefine <tt>ptype</tt> in the
--   previous example to use <tt>fillBreak</tt>, we get a useful variation
--   of the previous output:
--   
--   <pre>
--   ptype (name,tp)
--          = fillBreak 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   </pre>
--   
--   The output will now be:
--   
--   <pre>
--   let empty  :: Doc
--       nest   :: Int -&gt; Doc -&gt; Doc
--       linebreak
--              :: Doc
--   </pre>
fillBreak :: Int -> Doc -> Doc

-- | The document <tt>(enclose l r x)</tt> encloses document <tt>x</tt>
--   between documents <tt>l</tt> and <tt>r</tt> using <tt>(&lt;&gt;)</tt>.
--   
--   <pre>
--   enclose l r x   = l &lt;&gt; x &lt;&gt; r
--   </pre>
enclose :: Doc -> Doc -> Doc -> Doc

-- | Document <tt>(squotes x)</tt> encloses document <tt>x</tt> with single
--   quotes "'".
squotes :: Doc -> Doc

-- | Document <tt>(dquotes x)</tt> encloses document <tt>x</tt> with double
--   quotes '"'.
dquotes :: Doc -> Doc

-- | Document <tt>(parens x)</tt> encloses document <tt>x</tt> in
--   parenthesis, "(" and ")".
parens :: Doc -> Doc

-- | Document <tt>(angles x)</tt> encloses document <tt>x</tt> in angles,
--   "&lt;" and "&gt;".
angles :: Doc -> Doc

-- | Document <tt>(braces x)</tt> encloses document <tt>x</tt> in braces,
--   "{" and "}".
braces :: Doc -> Doc

-- | Document <tt>(brackets x)</tt> encloses document <tt>x</tt> in square
--   brackets, "[" and "]".
brackets :: Doc -> Doc

-- | The document <tt>lparen</tt> contains a left parenthesis, "(".
lparen :: Doc

-- | The document <tt>rparen</tt> contains a right parenthesis, ")".
rparen :: Doc

-- | The document <tt>langle</tt> contains a left angle, "&lt;".
langle :: Doc

-- | The document <tt>rangle</tt> contains a right angle, "&gt;".
rangle :: Doc

-- | The document <tt>lbrace</tt> contains a left brace, "{".
lbrace :: Doc

-- | The document <tt>rbrace</tt> contains a right brace, "}".
rbrace :: Doc

-- | The document <tt>lbracket</tt> contains a left square bracket, "[".
lbracket :: Doc

-- | The document <tt>rbracket</tt> contains a right square bracket, "]".
rbracket :: Doc

-- | The document <tt>squote</tt> contains a single quote, "'".
squote :: Doc

-- | The document <tt>dquote</tt> contains a double quote, '"'.
dquote :: Doc

-- | The document <tt>semi</tt> contains a semicolon, ";".
semi :: Doc

-- | The document <tt>colon</tt> contains a colon, ":".
colon :: Doc

-- | The document <tt>comma</tt> contains a comma, ",".
comma :: Doc

-- | The document <tt>space</tt> contains a single space, " ".
--   
--   <pre>
--   x &lt;+&gt; y   = x &lt;&gt; space &lt;&gt; y
--   </pre>
space :: Doc

-- | The document <tt>dot</tt> contains a single dot, ".".
dot :: Doc

-- | The document <tt>backslash</tt> contains a back slash, "\".
backslash :: Doc

-- | The document <tt>equals</tt> contains an equal sign, "=".
equals :: Doc

-- | Displays a document with the black forecolor
black :: Doc -> Doc

-- | Displays a document with the red forecolor
red :: Doc -> Doc

-- | Displays a document with the green forecolor
green :: Doc -> Doc

-- | Displays a document with the yellow forecolor
yellow :: Doc -> Doc

-- | Displays a document with the blue forecolor
blue :: Doc -> Doc

-- | Displays a document with the magenta forecolor
magenta :: Doc -> Doc

-- | Displays a document with the cyan forecolor
cyan :: Doc -> Doc

-- | Displays a document with the white forecolor
white :: Doc -> Doc

-- | Displays a document with the dull black forecolor
dullblack :: Doc -> Doc

-- | Displays a document with the dull red forecolor
dullred :: Doc -> Doc

-- | Displays a document with the dull green forecolor
dullgreen :: Doc -> Doc

-- | Displays a document with the dull yellow forecolor
dullyellow :: Doc -> Doc

-- | Displays a document with the dull blue forecolor
dullblue :: Doc -> Doc

-- | Displays a document with the dull magenta forecolor
dullmagenta :: Doc -> Doc

-- | Displays a document with the dull cyan forecolor
dullcyan :: Doc -> Doc

-- | Displays a document with the dull white forecolor
dullwhite :: Doc -> Doc

-- | Displays a document with the black backcolor
onblack :: Doc -> Doc

-- | Displays a document with the red backcolor
onred :: Doc -> Doc

-- | Displays a document with the green backcolor
ongreen :: Doc -> Doc

-- | Displays a document with the yellow backcolor
onyellow :: Doc -> Doc

-- | Displays a document with the blue backcolor
onblue :: Doc -> Doc

-- | Displays a document with the magenta backcolor
onmagenta :: Doc -> Doc

-- | Displays a document with the cyan backcolor
oncyan :: Doc -> Doc

-- | Displays a document with the white backcolor
onwhite :: Doc -> Doc

-- | Displays a document with the dull black backcolor
ondullblack :: Doc -> Doc

-- | Displays a document with the dull red backcolor
ondullred :: Doc -> Doc

-- | Displays a document with the dull green backcolor
ondullgreen :: Doc -> Doc

-- | Displays a document with the dull yellow backcolor
ondullyellow :: Doc -> Doc

-- | Displays a document with the dull blue backcolor
ondullblue :: Doc -> Doc

-- | Displays a document with the dull magenta backcolor
ondullmagenta :: Doc -> Doc

-- | Displays a document with the dull cyan backcolor
ondullcyan :: Doc -> Doc

-- | Displays a document with the dull white backcolor
ondullwhite :: Doc -> Doc

-- | Displays a document in a heavier font weight
bold :: Doc -> Doc

-- | Displays a document in the normal font weight
debold :: Doc -> Doc

-- | Displays a document with underlining
underline :: Doc -> Doc

-- | Displays a document with no underlining
deunderline :: Doc -> Doc

-- | Removes all colorisation, emboldening and underlining from a document
plain :: Doc -> Doc

-- | The member <tt>prettyList</tt> is only used to define the <tt>instance
--   Pretty a =&gt; Pretty [a]</tt>. In normal circumstances only the
--   <tt>pretty</tt> function is used.
class Pretty a
pretty :: Pretty a => a -> Doc
prettyList :: Pretty a => [a] -> Doc

-- | The data type <tt>SimpleDoc</tt> represents rendered documents and is
--   used by the display functions.
--   
--   Whereas values of the data type <a>Doc</a> represent non-empty sets of
--   possible renderings of a document, values of the data type
--   <tt>SimpleDoc</tt> represent single renderings of a document.
--   
--   The <tt>Int</tt> in <tt>SText</tt> contains the length of the string.
--   The <tt>Int</tt> in <tt>SLine</tt> contains the indentation for that
--   line. The library provides two default display functions
--   <a>displayS</a> and <a>displayIO</a>. You can provide your own display
--   function by writing a function from a <tt>SimpleDoc</tt> to your own
--   output format.
data SimpleDoc
SFail :: SimpleDoc
SEmpty :: SimpleDoc
SChar :: Char -> SimpleDoc -> SimpleDoc
SText :: !Int -> String -> SimpleDoc -> SimpleDoc
SLine :: !Int -> SimpleDoc -> SimpleDoc
SSGR :: [SGR] -> SimpleDoc -> SimpleDoc

-- | This is the default pretty printer which is used by <a>show</a>,
--   <a>putDoc</a> and <a>hPutDoc</a>. <tt>(renderPretty ribbonfrac width
--   x)</tt> renders document <tt>x</tt> with a page width of
--   <tt>width</tt> and a ribbon width of <tt>(ribbonfrac * width)</tt>
--   characters. The ribbon width is the maximal amount of non-indentation
--   characters on a line. The parameter <tt>ribbonfrac</tt> should be
--   between <tt>0.0</tt> and <tt>1.0</tt>. If it is lower or higher, the
--   ribbon width will be 0 or <tt>width</tt> respectively.
renderPretty :: Float -> Int -> Doc -> SimpleDoc

-- | <tt>(renderCompact x)</tt> renders document <tt>x</tt> without adding
--   any indentation. Since no 'pretty' printing is involved, this renderer
--   is very fast. The resulting output contains fewer characters than a
--   pretty printed version and can be used for output that is read by
--   other programs.
--   
--   This rendering function does not add any colorisation information.
renderCompact :: Doc -> SimpleDoc

-- | A slightly smarter rendering algorithm with more lookahead. It
--   provides provide earlier breaking on deeply nested structures For
--   example, consider this python-ish pseudocode:
--   <tt>fun(fun(fun(fun(fun([abcdefg, abcdefg])))))</tt> If we put a
--   softbreak (+ nesting 2) after each open parenthesis, and align the
--   elements of the list to match the opening brackets, this will render
--   with <tt>renderPretty</tt> and a page width of 20 as: <tt>
--   fun(fun(fun(fun(fun([ | abcdef, | abcdef, ] ))))) | </tt> Where the
--   20c. boundary has been marked with |. Because <tt>renderPretty</tt>
--   only uses one-line lookahead, it sees that the first line fits, and is
--   stuck putting the second and third lines after the 20-c mark. In
--   contrast, <tt>renderSmart</tt> will continue to check that the
--   potential document up to the end of the indentation level. Thus, it
--   will format the document as:
--   
--   <pre>
--   fun(                |
--     fun(              |
--       fun(            |
--         fun(          |
--           fun([       |
--                 abcdef,
--                 abcdef,
--               ]       |
--     )))))             |
--   </pre>
--   
--   Which fits within the 20c. boundary.
renderSmart :: Float -> Int -> Doc -> SimpleDoc

-- | <tt>(displayS simpleDoc)</tt> takes the output <tt>simpleDoc</tt> from
--   a rendering function and transforms it to a <a>ShowS</a> type (for use
--   in the <a>Show</a> class).
--   
--   <pre>
--   showWidth :: Int -&gt; Doc -&gt; String
--   showWidth w x   = displayS (renderPretty 0.4 w x) ""
--   </pre>
--   
--   ANSI color information will be discarded by this function unless you
--   are running on a Unix-like operating system. This is due to a
--   technical limitation in Windows ANSI support.
displayS :: SimpleDoc -> ShowS

-- | <tt>(displayIO handle simpleDoc)</tt> writes <tt>simpleDoc</tt> to the
--   file handle <tt>handle</tt>. This function is used for example by
--   <a>hPutDoc</a>:
--   
--   <pre>
--   hPutDoc handle doc  = displayIO handle (renderPretty 0.4 80 doc)
--   </pre>
--   
--   Any ANSI colorisation in <tt>simpleDoc</tt> will be output.
displayIO :: Handle -> SimpleDoc -> IO ()

-- | The action <tt>(putDoc doc)</tt> pretty prints document <tt>doc</tt>
--   to the standard output, with a page width of 80 characters and a
--   ribbon width of 32 characters.
--   
--   <pre>
--   main :: IO ()
--   main = do{ putDoc (text "hello" &lt;+&gt; text "world") }
--   </pre>
--   
--   Which would output
--   
--   <pre>
--   hello world
--   </pre>
--   
--   Any ANSI colorisation in <tt>doc</tt> will be output.
putDoc :: Doc -> IO ()

-- | <tt>(hPutDoc handle doc)</tt> pretty prints document <tt>doc</tt> to
--   the file handle <tt>handle</tt> with a page width of 80 characters and
--   a ribbon width of 32 characters.
--   
--   <pre>
--   main = do{ handle &lt;- openFile "MyFile" WriteMode
--            ; hPutDoc handle (vcat (map text
--                              ["vertical","text"]))
--            ; hClose handle
--            }
--   </pre>
--   
--   Any ANSI colorisation in <tt>doc</tt> will be output.
hPutDoc :: Handle -> Doc -> IO ()
column :: (Int -> Doc) -> Doc
columns :: (Maybe Int -> Doc) -> Doc
nesting :: (Int -> Doc) -> Doc
width :: Doc -> (Int -> Doc) -> Doc

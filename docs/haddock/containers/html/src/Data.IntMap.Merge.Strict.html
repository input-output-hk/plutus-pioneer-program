<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE BangPatterns #-}</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__
</span><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable, StandaloneDeriving #-}</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if !defined(TESTING) &amp;&amp; defined(__GLASGOW_HASKELL__)
</span><span class="hs-pragma">{-# LANGUAGE Trustworthy #-}</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if __GLASGOW_HASKELL__ &gt;= 708
</span><span class="hs-pragma">{-# LANGUAGE RoleAnnotations #-}</span><span>
</span><span id="line-11"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span class="hs-cpp">
#define USE_MAGIC_PROXY 1
</span><span class="hs-cpp">#endif
</span><span class="hs-cpp">
#if USE_MAGIC_PROXY
</span><span class="hs-pragma">{-# LANGUAGE MagicHash #-}</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#include &quot;containers.h&quot;
</span><span>
</span><span id="line-21"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-22"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- Module      :  Data.IntMap.Merge.Strict</span><span>
</span><span id="line-24"></span><span class="hs-comment">-- Copyright   :  (c) wren romano 2016</span><span>
</span><span id="line-25"></span><span class="hs-comment">-- License     :  BSD-style</span><span>
</span><span id="line-26"></span><span class="hs-comment">-- Maintainer  :  libraries@haskell.org</span><span>
</span><span id="line-27"></span><span class="hs-comment">-- Portability :  portable</span><span>
</span><span id="line-28"></span><span class="hs-comment">--</span><span>
</span><span id="line-29"></span><span class="hs-comment">-- This module defines an API for writing functions that merge two</span><span>
</span><span id="line-30"></span><span class="hs-comment">-- maps. The key functions are 'merge' and 'mergeA'.</span><span>
</span><span id="line-31"></span><span class="hs-comment">-- Each of these can be used with several different \&quot;merge tactics\&quot;.</span><span>
</span><span id="line-32"></span><span class="hs-comment">--</span><span>
</span><span id="line-33"></span><span class="hs-comment">-- The 'merge' and 'mergeA' functions are shared by</span><span>
</span><span id="line-34"></span><span class="hs-comment">-- the lazy and strict modules. Only the choice of merge tactics</span><span>
</span><span id="line-35"></span><span class="hs-comment">-- determines strictness. If you use 'Data.Map.Merge.Strict.mapMissing'</span><span>
</span><span id="line-36"></span><span class="hs-comment">-- from this module then the results will be forced before they are</span><span>
</span><span id="line-37"></span><span class="hs-comment">-- inserted. If you use 'Data.Map.Merge.Lazy.mapMissing' from</span><span>
</span><span id="line-38"></span><span class="hs-comment">-- &quot;Data.Map.Merge.Lazy&quot; then they will not.</span><span>
</span><span id="line-39"></span><span class="hs-comment">--</span><span>
</span><span id="line-40"></span><span class="hs-comment">-- == Efficiency note</span><span>
</span><span id="line-41"></span><span class="hs-comment">--</span><span>
</span><span id="line-42"></span><span class="hs-comment">-- The 'Control.Category.Category', 'Applicative', and 'Monad' instances for</span><span>
</span><span id="line-43"></span><span class="hs-comment">-- 'WhenMissing' tactics are included because they are valid. However, they are</span><span>
</span><span id="line-44"></span><span class="hs-comment">-- inefficient in many cases and should usually be avoided. The instances</span><span>
</span><span id="line-45"></span><span class="hs-comment">-- for 'WhenMatched' tactics should not pose any major efficiency problems.</span><span>
</span><span id="line-46"></span><span class="hs-comment">--</span><span>
</span><span id="line-47"></span><span class="hs-comment">-- @since 0.5.9</span><span>
</span><span id="line-48"></span><span>
</span><span id="line-49"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Data.IntMap.Merge.Strict</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-50"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Simple merge tactic types</span></span><span>
</span><span id="line-51"></span><span>      </span><span class="annot"><a href="Data.IntMap.Internal.html#SimpleWhenMissing"><span class="hs-identifier">SimpleWhenMissing</span></a></span><span>
</span><span id="line-52"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#SimpleWhenMatched"><span class="hs-identifier">SimpleWhenMatched</span></a></span><span>
</span><span id="line-53"></span><span>
</span><span id="line-54"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** General combining function</span></span><span>
</span><span id="line-55"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#merge"><span class="hs-identifier">merge</span></a></span><span>
</span><span id="line-56"></span><span>
</span><span id="line-57"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** @WhenMatched@ tactics</span></span><span>
</span><span id="line-58"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeMatched"><span class="hs-identifier">zipWithMaybeMatched</span></a></span><span>
</span><span id="line-59"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMatched"><span class="hs-identifier">zipWithMatched</span></a></span><span>
</span><span id="line-60"></span><span>
</span><span id="line-61"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** @WhenMissing@ tactics</span></span><span>
</span><span id="line-62"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapMaybeMissing"><span class="hs-identifier">mapMaybeMissing</span></a></span><span>
</span><span id="line-63"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#dropMissing"><span class="hs-identifier">dropMissing</span></a></span><span>
</span><span id="line-64"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#preserveMissing"><span class="hs-identifier">preserveMissing</span></a></span><span>
</span><span id="line-65"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapMissing"><span class="hs-identifier">mapMissing</span></a></span><span>
</span><span id="line-66"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#filterMissing"><span class="hs-identifier">filterMissing</span></a></span><span>
</span><span id="line-67"></span><span>
</span><span id="line-68"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Applicative merge tactic types</span></span><span>
</span><span id="line-69"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier">WhenMissing</span></a></span><span>
</span><span id="line-70"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier">WhenMatched</span></a></span><span>
</span><span id="line-71"></span><span>
</span><span id="line-72"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Applicative general combining function</span></span><span>
</span><span id="line-73"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#mergeA"><span class="hs-identifier">mergeA</span></a></span><span>
</span><span id="line-74"></span><span>
</span><span id="line-75"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** @WhenMatched@ tactics</span></span><span>
</span><span id="line-76"></span><span>    </span><span class="hs-comment">-- | The tactics described for 'merge' work for</span><span>
</span><span id="line-77"></span><span>    </span><span class="hs-comment">-- 'mergeA' as well. Furthermore, the following</span><span>
</span><span id="line-78"></span><span>    </span><span class="hs-comment">-- are available.</span><span>
</span><span id="line-79"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeAMatched"><span class="hs-identifier">zipWithMaybeAMatched</span></a></span><span>
</span><span id="line-80"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithAMatched"><span class="hs-identifier">zipWithAMatched</span></a></span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** @WhenMissing@ tactics</span></span><span>
</span><span id="line-83"></span><span>    </span><span class="hs-comment">-- | The tactics described for 'merge' work for</span><span>
</span><span id="line-84"></span><span>    </span><span class="hs-comment">-- 'mergeA' as well. Furthermore, the following</span><span>
</span><span id="line-85"></span><span>    </span><span class="hs-comment">-- are available.</span><span>
</span><span id="line-86"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#traverseMaybeMissing"><span class="hs-identifier">traverseMaybeMissing</span></a></span><span>
</span><span id="line-87"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#traverseMissing"><span class="hs-identifier">traverseMissing</span></a></span><span>
</span><span id="line-88"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#filterAMissing"><span class="hs-identifier">filterAMissing</span></a></span><span>
</span><span id="line-89"></span><span>
</span><span id="line-90"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Covariant maps for tactics</span></span><span>
</span><span id="line-91"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapWhenMissing"><span class="hs-identifier">mapWhenMissing</span></a></span><span>
</span><span id="line-92"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapWhenMatched"><span class="hs-identifier">mapWhenMatched</span></a></span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Miscellaneous functions on tactics</span></span><span>
</span><span id="line-95"></span><span>
</span><span id="line-96"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#runWhenMatched"><span class="hs-identifier">runWhenMatched</span></a></span><span>
</span><span id="line-97"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#runWhenMissing"><span class="hs-identifier">runWhenMissing</span></a></span><span>
</span><span id="line-98"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html"><span class="hs-identifier">Data.IntMap.Internal</span></a></span><span>
</span><span id="line-101"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#SimpleWhenMissing"><span class="hs-identifier">SimpleWhenMissing</span></a></span><span>
</span><span id="line-102"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#SimpleWhenMatched"><span class="hs-identifier">SimpleWhenMatched</span></a></span><span>
</span><span id="line-103"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#merge"><span class="hs-identifier">merge</span></a></span><span>
</span><span id="line-104"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#dropMissing"><span class="hs-identifier">dropMissing</span></a></span><span>
</span><span id="line-105"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#preserveMissing"><span class="hs-identifier">preserveMissing</span></a></span><span>
</span><span id="line-106"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#filterMissing"><span class="hs-identifier">filterMissing</span></a></span><span>
</span><span id="line-107"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier">WhenMissing</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-108"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier">WhenMatched</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-109"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#mergeA"><span class="hs-identifier">mergeA</span></a></span><span>
</span><span id="line-110"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#filterAMissing"><span class="hs-identifier">filterAMissing</span></a></span><span>
</span><span id="line-111"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#runWhenMatched"><span class="hs-identifier">runWhenMatched</span></a></span><span>
</span><span id="line-112"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#runWhenMissing"><span class="hs-identifier">runWhenMissing</span></a></span><span>
</span><span id="line-113"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-114"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.IntMap.Strict.Internal.html"><span class="hs-identifier">Data.IntMap.Strict.Internal</span></a></span><span class="hs-cpp">
#if !MIN_VERSION_base(4,8,0)
</span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control.Applicative</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Applicative</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator">&lt;$&gt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier">Prelude</span></a></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier">filter</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier">map</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier">foldl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier">foldr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-119"></span><span>
</span><span id="line-120"></span><span class="hs-comment">-- | Map covariantly over a @'WhenMissing' f k x@.</span><span>
</span><span id="line-121"></span><span id="local-6989586621679181288"><span id="local-6989586621679181289"><span id="local-6989586621679181290"><span id="local-6989586621679181291"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapWhenMissing"><span class="hs-identifier hs-type">mapWhenMissing</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Functor</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181291"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679181290"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181289"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181291"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181288"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181290"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181291"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181288"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181289"><span class="hs-identifier hs-type">b</span></a></span></span></span></span></span><span>
</span><span id="line-122"></span><span id="mapWhenMissing"><span class="annot"><span class="annottext">mapWhenMissing :: forall (f :: * -&gt; *) a b x.
Functor f =&gt;
(a -&gt; b) -&gt; WhenMissing f x a -&gt; WhenMissing f x b
</span><a href="Data.IntMap.Merge.Strict.html#mapWhenMissing"><span class="hs-identifier hs-var hs-var">mapWhenMissing</span></a></span></span><span> </span><span id="local-6989586621679181146"><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679181146"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679181145"><span class="annot"><span class="annottext">WhenMissing f x a
</span><a href="#local-6989586621679181145"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span>
</span><span id="line-123"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">missingSubtree :: IntMap x -&gt; f (IntMap b)
</span><a href="Data.IntMap.Internal.html#missingSubtree"><span class="hs-identifier hs-var">missingSubtree</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; IntMap a -&gt; IntMap b
</span><a href="Data.IntMap.Strict.Internal.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679181146"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) x y.
WhenMissing f x y -&gt; IntMap x -&gt; f (IntMap y)
</span><a href="Data.IntMap.Internal.html#missingSubtree"><span class="hs-identifier hs-var">missingSubtree</span></a></span><span> </span><span class="annot"><span class="annottext">WhenMissing f x a
</span><a href="#local-6989586621679181145"><span class="hs-identifier hs-var">q</span></a></span><span>
</span><span id="line-124"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">missingKey :: Key -&gt; x -&gt; f (Maybe b)
</span><a href="Data.IntMap.Internal.html#missingKey"><span class="hs-identifier hs-var">missingKey</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679181139"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181139"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679181138"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181138"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679181146"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) x y.
WhenMissing f x y -&gt; Key -&gt; x -&gt; f (Maybe y)
</span><a href="Data.IntMap.Internal.html#missingKey"><span class="hs-identifier hs-var">missingKey</span></a></span><span> </span><span class="annot"><span class="annottext">WhenMissing f x a
</span><a href="#local-6989586621679181145"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181139"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181138"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span class="hs-comment">-- | Map covariantly over a @'WhenMatched' f k x y@.</span><span>
</span><span id="line-127"></span><span id="local-6989586621679181261"><span id="local-6989586621679181262"><span id="local-6989586621679181263"><span id="local-6989586621679181264"><span id="local-6989586621679181265"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapWhenMatched"><span class="hs-identifier hs-type">mapWhenMatched</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Functor</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181265"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679181264"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181263"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181265"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181262"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181261"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181264"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181265"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181262"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181261"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181263"><span class="hs-identifier hs-type">b</span></a></span></span></span></span></span></span><span>
</span><span id="line-128"></span><span id="mapWhenMatched"><span class="annot"><span class="annottext">mapWhenMatched :: forall (f :: * -&gt; *) a b x y.
Functor f =&gt;
(a -&gt; b) -&gt; WhenMatched f x y a -&gt; WhenMatched f x y b
</span><a href="Data.IntMap.Merge.Strict.html#mapWhenMatched"><span class="hs-identifier hs-var hs-var">mapWhenMatched</span></a></span></span><span> </span><span id="local-6989586621679181133"><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679181133"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679181132"><span class="annot"><span class="annottext">WhenMatched f x y a
</span><a href="#local-6989586621679181132"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span>
</span><span id="line-129"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">matchedKey :: Key -&gt; x -&gt; y -&gt; f (Maybe b)
</span><a href="Data.IntMap.Internal.html#matchedKey"><span class="hs-identifier hs-var">matchedKey</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679181129"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181129"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679181128"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181128"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679181127"><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679181127"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679181133"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) x y z.
WhenMatched f x y z -&gt; Key -&gt; x -&gt; y -&gt; f (Maybe z)
</span><a href="Data.IntMap.Internal.html#runWhenMatched"><span class="hs-identifier hs-var">runWhenMatched</span></a></span><span> </span><span class="annot"><span class="annottext">WhenMatched f x y a
</span><a href="#local-6989586621679181132"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181129"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181128"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679181127"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-130"></span><span>
</span><span id="line-131"></span><span class="hs-comment">-- | When a key is found in both maps, apply a function to the</span><span>
</span><span id="line-132"></span><span class="hs-comment">-- key and values and maybe use the result in the merged map.</span><span>
</span><span id="line-133"></span><span class="hs-comment">--</span><span>
</span><span id="line-134"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-135"></span><span class="hs-comment">-- zipWithMaybeMatched :: (k -&gt; x -&gt; y -&gt; Maybe z)</span><span>
</span><span id="line-136"></span><span class="hs-comment">--                     -&gt; SimpleWhenMatched k x y z</span><span>
</span><span id="line-137"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-138"></span><span id="local-6989586621679181247"><span id="local-6989586621679181248"><span id="local-6989586621679181249"><span id="local-6989586621679181250"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeMatched"><span class="hs-identifier hs-type">zipWithMaybeMatched</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181250"><span class="hs-identifier hs-type">f</span></a></span><span>
</span><span id="line-139"></span><span>                    </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181249"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181248"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181247"><span class="hs-identifier hs-type">z</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-140"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181250"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181249"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181248"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181247"><span class="hs-identifier hs-type">z</span></a></span></span></span></span></span><span>
</span><span id="line-141"></span><span id="zipWithMaybeMatched"><span class="annot"><span class="annottext">zipWithMaybeMatched :: forall (f :: * -&gt; *) x y z.
Applicative f =&gt;
(Key -&gt; x -&gt; y -&gt; Maybe z) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeMatched"><span class="hs-identifier hs-var hs-var">zipWithMaybeMatched</span></a></span></span><span> </span><span id="local-6989586621679181124"><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; Maybe z
</span><a href="#local-6989586621679181124"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) x y z.
(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-var">WhenMatched</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-142"></span><span>  </span><span class="hs-glyph">\</span><span id="local-6989586621679181123"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181123"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679181122"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181122"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679181121"><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679181121"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; Maybe z
</span><a href="#local-6989586621679181124"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181123"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181122"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679181121"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-143"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeMatched"><span class="hs-pragma hs-type">zipWithMaybeMatched</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-144"></span><span>
</span><span id="line-145"></span><span class="hs-comment">-- | When a key is found in both maps, apply a function to the</span><span>
</span><span id="line-146"></span><span class="hs-comment">-- key and values, perform the resulting action, and maybe use</span><span>
</span><span id="line-147"></span><span class="hs-comment">-- the result in the merged map.</span><span>
</span><span id="line-148"></span><span class="hs-comment">--</span><span>
</span><span id="line-149"></span><span class="hs-comment">-- This is the fundamental 'WhenMatched' tactic.</span><span>
</span><span id="line-150"></span><span id="local-6989586621679181233"><span id="local-6989586621679181234"><span id="local-6989586621679181235"><span id="local-6989586621679181236"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeAMatched"><span class="hs-identifier hs-type">zipWithMaybeAMatched</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181236"><span class="hs-identifier hs-type">f</span></a></span><span>
</span><span id="line-151"></span><span>                     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181235"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181234"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181236"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181233"><span class="hs-identifier hs-type">z</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-152"></span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181236"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181235"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181234"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181233"><span class="hs-identifier hs-type">z</span></a></span></span></span></span></span><span>
</span><span id="line-153"></span><span id="zipWithMaybeAMatched"><span class="annot"><span class="annottext">zipWithMaybeAMatched :: forall (f :: * -&gt; *) x y z.
Applicative f =&gt;
(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeAMatched"><span class="hs-identifier hs-var hs-var">zipWithMaybeAMatched</span></a></span></span><span> </span><span id="local-6989586621679181115"><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; f (Maybe z)
</span><a href="#local-6989586621679181115"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) x y z.
(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-var">WhenMatched</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-154"></span><span>  </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679181114"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181114"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679181113"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181113"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679181112"><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679181112"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; f (Maybe z)
</span><a href="#local-6989586621679181115"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181114"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181113"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679181112"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-155"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeAMatched"><span class="hs-pragma hs-type">zipWithMaybeAMatched</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-156"></span><span>
</span><span id="line-157"></span><span class="hs-comment">-- | When a key is found in both maps, apply a function to the</span><span>
</span><span id="line-158"></span><span class="hs-comment">-- key and values to produce an action and use its result in the merged map.</span><span>
</span><span id="line-159"></span><span id="local-6989586621679181222"><span id="local-6989586621679181223"><span id="local-6989586621679181224"><span id="local-6989586621679181225"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithAMatched"><span class="hs-identifier hs-type">zipWithAMatched</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181225"><span class="hs-identifier hs-type">f</span></a></span><span>
</span><span id="line-160"></span><span>                </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181224"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181223"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181225"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181222"><span class="hs-identifier hs-type">z</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-161"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181225"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181224"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181223"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181222"><span class="hs-identifier hs-type">z</span></a></span></span></span></span></span><span>
</span><span id="line-162"></span><span id="zipWithAMatched"><span class="annot"><span class="annottext">zipWithAMatched :: forall (f :: * -&gt; *) x y z.
Applicative f =&gt;
(Key -&gt; x -&gt; y -&gt; f z) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Merge.Strict.html#zipWithAMatched"><span class="hs-identifier hs-var hs-var">zipWithAMatched</span></a></span></span><span> </span><span id="local-6989586621679181107"><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; f z
</span><a href="#local-6989586621679181107"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) x y z.
(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-var">WhenMatched</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-163"></span><span>  </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679181106"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181106"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679181105"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181105"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679181104"><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679181104"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$!</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; f z
</span><a href="#local-6989586621679181107"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181106"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181105"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679181104"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-164"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithAMatched"><span class="hs-pragma hs-type">zipWithAMatched</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-165"></span><span>
</span><span id="line-166"></span><span class="hs-comment">-- | When a key is found in both maps, apply a function to the</span><span>
</span><span id="line-167"></span><span class="hs-comment">-- key and values and use the result in the merged map.</span><span>
</span><span id="line-168"></span><span class="hs-comment">--</span><span>
</span><span id="line-169"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-170"></span><span class="hs-comment">-- zipWithMatched :: (k -&gt; x -&gt; y -&gt; z)</span><span>
</span><span id="line-171"></span><span class="hs-comment">--                -&gt; SimpleWhenMatched k x y z</span><span>
</span><span id="line-172"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-173"></span><span id="local-6989586621679181213"><span id="local-6989586621679181214"><span id="local-6989586621679181215"><span id="local-6989586621679181216"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMatched"><span class="hs-identifier hs-type">zipWithMatched</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181216"><span class="hs-identifier hs-type">f</span></a></span><span>
</span><span id="line-174"></span><span>               </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181215"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181214"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181213"><span class="hs-identifier hs-type">z</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181216"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181215"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181214"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181213"><span class="hs-identifier hs-type">z</span></a></span></span></span></span></span><span>
</span><span id="line-175"></span><span id="zipWithMatched"><span class="annot"><span class="annottext">zipWithMatched :: forall (f :: * -&gt; *) x y z.
Applicative f =&gt;
(Key -&gt; x -&gt; y -&gt; z) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Merge.Strict.html#zipWithMatched"><span class="hs-identifier hs-var hs-var">zipWithMatched</span></a></span></span><span> </span><span id="local-6989586621679181101"><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; z
</span><a href="#local-6989586621679181101"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) x y z.
(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-var">WhenMatched</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-176"></span><span>  </span><span class="hs-glyph">\</span><span id="local-6989586621679181100"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181100"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679181099"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181099"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679181098"><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679181098"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; z
</span><a href="#local-6989586621679181101"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181100"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181099"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679181098"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-177"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMatched"><span class="hs-pragma hs-type">zipWithMatched</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-178"></span><span>
</span><span id="line-179"></span><span class="hs-comment">-- | Map over the entries whose keys are missing from the other map,</span><span>
</span><span id="line-180"></span><span class="hs-comment">-- optionally removing some. This is the most powerful 'SimpleWhenMissing'</span><span>
</span><span id="line-181"></span><span class="hs-comment">-- tactic, but others are usually more efficient.</span><span>
</span><span id="line-182"></span><span class="hs-comment">--</span><span>
</span><span id="line-183"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-184"></span><span class="hs-comment">-- mapMaybeMissing :: (k -&gt; x -&gt; Maybe y) -&gt; SimpleWhenMissing k x y</span><span>
</span><span id="line-185"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-186"></span><span class="hs-comment">--</span><span>
</span><span id="line-187"></span><span class="hs-comment">-- prop&gt; mapMaybeMissing f = traverseMaybeMissing (\k x -&gt; pure (f k x))</span><span>
</span><span id="line-188"></span><span class="hs-comment">--</span><span>
</span><span id="line-189"></span><span class="hs-comment">-- but @mapMaybeMissing@ uses fewer unnecessary 'Applicative' operations.</span><span>
</span><span id="line-190"></span><span id="local-6989586621679181206"><span id="local-6989586621679181207"><span id="local-6989586621679181208"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapMaybeMissing"><span class="hs-identifier hs-type">mapMaybeMissing</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181208"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181207"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181206"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181208"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181207"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181206"><span class="hs-identifier hs-type">y</span></a></span></span></span></span><span>
</span><span id="line-191"></span><span id="mapMaybeMissing"><span class="annot"><span class="annottext">mapMaybeMissing :: forall (f :: * -&gt; *) x y.
Applicative f =&gt;
(Key -&gt; x -&gt; Maybe y) -&gt; WhenMissing f x y
</span><a href="Data.IntMap.Merge.Strict.html#mapMaybeMissing"><span class="hs-identifier hs-var hs-var">mapMaybeMissing</span></a></span></span><span> </span><span id="local-6989586621679181094"><span class="annot"><span class="annottext">Key -&gt; x -&gt; Maybe y
</span><a href="#local-6989586621679181094"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span>
</span><span id="line-192"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">missingSubtree :: IntMap x -&gt; f (IntMap y)
</span><a href="Data.IntMap.Internal.html#missingSubtree"><span class="hs-identifier hs-var">missingSubtree</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679181093"><span class="annot"><span class="annottext">IntMap x
</span><a href="#local-6989586621679181093"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (Key -&gt; a -&gt; Maybe b) -&gt; IntMap a -&gt; IntMap b
</span><a href="Data.IntMap.Strict.Internal.html#mapMaybeWithKey"><span class="hs-identifier hs-var">mapMaybeWithKey</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; Maybe y
</span><a href="#local-6989586621679181094"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap x
</span><a href="#local-6989586621679181093"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-193"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">missingKey :: Key -&gt; x -&gt; f (Maybe y)
</span><a href="Data.IntMap.Internal.html#missingKey"><span class="hs-identifier hs-var">missingKey</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679181091"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181091"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679181090"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181090"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; Maybe y
</span><a href="#local-6989586621679181094"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181091"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181090"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-194"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapMaybeMissing"><span class="hs-pragma hs-type">mapMaybeMissing</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-195"></span><span>
</span><span id="line-196"></span><span class="hs-comment">-- | Map over the entries whose keys are missing from the other map.</span><span>
</span><span id="line-197"></span><span class="hs-comment">--</span><span>
</span><span id="line-198"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-199"></span><span class="hs-comment">-- mapMissing :: (k -&gt; x -&gt; y) -&gt; SimpleWhenMissing k x y</span><span>
</span><span id="line-200"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-201"></span><span class="hs-comment">--</span><span>
</span><span id="line-202"></span><span class="hs-comment">-- prop&gt; mapMissing f = mapMaybeMissing (\k x -&gt; Just $ f k x)</span><span>
</span><span id="line-203"></span><span class="hs-comment">--</span><span>
</span><span id="line-204"></span><span class="hs-comment">-- but @mapMissing@ is somewhat faster.</span><span>
</span><span id="line-205"></span><span id="local-6989586621679181198"><span id="local-6989586621679181199"><span id="local-6989586621679181200"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapMissing"><span class="hs-identifier hs-type">mapMissing</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181200"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181199"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181198"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181200"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181199"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181198"><span class="hs-identifier hs-type">y</span></a></span></span></span></span><span>
</span><span id="line-206"></span><span id="mapMissing"><span class="annot"><span class="annottext">mapMissing :: forall (f :: * -&gt; *) x y.
Applicative f =&gt;
(Key -&gt; x -&gt; y) -&gt; WhenMissing f x y
</span><a href="Data.IntMap.Merge.Strict.html#mapMissing"><span class="hs-identifier hs-var hs-var">mapMissing</span></a></span></span><span> </span><span id="local-6989586621679181086"><span class="annot"><span class="annottext">Key -&gt; x -&gt; y
</span><a href="#local-6989586621679181086"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span>
</span><span id="line-207"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">missingSubtree :: IntMap x -&gt; f (IntMap y)
</span><a href="Data.IntMap.Internal.html#missingSubtree"><span class="hs-identifier hs-var">missingSubtree</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679181085"><span class="annot"><span class="annottext">IntMap x
</span><a href="#local-6989586621679181085"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (Key -&gt; a -&gt; b) -&gt; IntMap a -&gt; IntMap b
</span><a href="Data.IntMap.Strict.Internal.html#mapWithKey"><span class="hs-identifier hs-var">mapWithKey</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; y
</span><a href="#local-6989586621679181086"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap x
</span><a href="#local-6989586621679181085"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-208"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">missingKey :: Key -&gt; x -&gt; f (Maybe y)
</span><a href="Data.IntMap.Internal.html#missingKey"><span class="hs-identifier hs-var">missingKey</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679181083"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181083"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679181082"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181082"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; y
</span><a href="#local-6989586621679181086"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181083"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181082"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-209"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapMissing"><span class="hs-pragma hs-type">mapMissing</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-210"></span><span>
</span><span id="line-211"></span><span class="hs-comment">-- | Traverse over the entries whose keys are missing from the other map,</span><span>
</span><span id="line-212"></span><span class="hs-comment">-- optionally producing values to put in the result.</span><span>
</span><span id="line-213"></span><span class="hs-comment">-- This is the most powerful 'WhenMissing' tactic, but others are usually</span><span>
</span><span id="line-214"></span><span class="hs-comment">-- more efficient.</span><span>
</span><span id="line-215"></span><span id="local-6989586621679181190"><span id="local-6989586621679181191"><span id="local-6989586621679181192"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#traverseMaybeMissing"><span class="hs-identifier hs-type">traverseMaybeMissing</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181192"><span class="hs-identifier hs-type">f</span></a></span><span>
</span><span id="line-216"></span><span>                     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181191"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181192"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181190"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181192"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181191"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181190"><span class="hs-identifier hs-type">y</span></a></span></span></span></span><span>
</span><span id="line-217"></span><span id="traverseMaybeMissing"><span class="annot"><span class="annottext">traverseMaybeMissing :: forall (f :: * -&gt; *) x y.
Applicative f =&gt;
(Key -&gt; x -&gt; f (Maybe y)) -&gt; WhenMissing f x y
</span><a href="Data.IntMap.Merge.Strict.html#traverseMaybeMissing"><span class="hs-identifier hs-var hs-var">traverseMaybeMissing</span></a></span></span><span> </span><span id="local-6989586621679181077"><span class="annot"><span class="annottext">Key -&gt; x -&gt; f (Maybe y)
</span><a href="#local-6989586621679181077"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span>
</span><span id="line-218"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">missingSubtree :: IntMap x -&gt; f (IntMap y)
</span><a href="Data.IntMap.Internal.html#missingSubtree"><span class="hs-identifier hs-var">missingSubtree</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(Key -&gt; a -&gt; f (Maybe b)) -&gt; IntMap a -&gt; f (IntMap b)
</span><a href="Data.IntMap.Strict.Internal.html#traverseMaybeWithKey"><span class="hs-identifier hs-var">traverseMaybeWithKey</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; f (Maybe y)
</span><a href="#local-6989586621679181077"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-219"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">missingKey :: Key -&gt; x -&gt; f (Maybe y)
</span><a href="Data.IntMap.Internal.html#missingKey"><span class="hs-identifier hs-var">missingKey</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679181075"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181075"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679181074"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181074"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; f (Maybe y)
</span><a href="#local-6989586621679181077"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181075"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181074"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-220"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#traverseMaybeMissing"><span class="hs-pragma hs-type">traverseMaybeMissing</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-221"></span><span>
</span><span id="line-222"></span><span class="hs-comment">-- | Traverse over the entries whose keys are missing from the other map.</span><span>
</span><span id="line-223"></span><span id="local-6989586621679181181"><span id="local-6989586621679181182"><span id="local-6989586621679181183"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#traverseMissing"><span class="hs-identifier hs-type">traverseMissing</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181183"><span class="hs-identifier hs-type">f</span></a></span><span>
</span><span id="line-224"></span><span>                     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181182"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679181183"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181181"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181183"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181182"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181181"><span class="hs-identifier hs-type">y</span></a></span></span></span></span><span>
</span><span id="line-225"></span><span id="traverseMissing"><span class="annot"><span class="annottext">traverseMissing :: forall (f :: * -&gt; *) x y.
Applicative f =&gt;
(Key -&gt; x -&gt; f y) -&gt; WhenMissing f x y
</span><a href="Data.IntMap.Merge.Strict.html#traverseMissing"><span class="hs-identifier hs-var hs-var">traverseMissing</span></a></span></span><span> </span><span id="local-6989586621679181069"><span class="annot"><span class="annottext">Key -&gt; x -&gt; f y
</span><a href="#local-6989586621679181069"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span>
</span><span id="line-226"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">missingSubtree :: IntMap x -&gt; f (IntMap y)
</span><a href="Data.IntMap.Internal.html#missingSubtree"><span class="hs-identifier hs-var">missingSubtree</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Applicative t =&gt;
(Key -&gt; a -&gt; t b) -&gt; IntMap a -&gt; t (IntMap b)
</span><a href="Data.IntMap.Strict.Internal.html#traverseWithKey"><span class="hs-identifier hs-var">traverseWithKey</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; f y
</span><a href="#local-6989586621679181069"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-227"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">missingKey :: Key -&gt; x -&gt; f (Maybe y)
</span><a href="Data.IntMap.Internal.html#missingKey"><span class="hs-identifier hs-var">missingKey</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679181067"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181067"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679181066"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181066"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">$!</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; f y
</span><a href="#local-6989586621679181069"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679181067"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679181066"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-228"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#traverseMissing"><span class="hs-pragma hs-type">traverseMissing</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-229"></span><span>
</span><span id="line-230"></span><span id="local-6989586621679181269"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-type">forceMaybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181269"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679181269"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-231"></span><span id="forceMaybe"><span class="annot"><span class="annottext">forceMaybe :: forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var hs-var">forceMaybe</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-232"></span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span id="local-6989586621679181065"><span class="annot"><span class="annottext">m :: Maybe a
</span><a href="#local-6989586621679181065"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.3.0/src"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679181065"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-233"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-pragma hs-type">forceMaybe</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-234"></span></pre></body></html>
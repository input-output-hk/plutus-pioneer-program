
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Documentation and Markup &#8212; Haddock 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Common Errors" href="common-errors.html" />
    <link rel="prev" title="Invoking Haddock" href="invoking.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="documentation-and-markup">
<h1>Documentation and Markup<a class="headerlink" href="#documentation-and-markup" title="Permalink to this heading">¶</a></h1>
<p>Haddock understands special documentation annotations in the Haskell
source file and propagates these into the generated documentation. The
annotations are purely optional: if there are no annotations, Haddock
will just generate documentation that contains the type signatures, data
type declarations, and class declarations exported by each of the
modules being processed.</p>
<section id="documenting-a-top-level-declaration">
<span id="top-level-declaration"></span><h2>Documenting a Top-Level Declaration<a class="headerlink" href="#documenting-a-top-level-declaration" title="Permalink to this heading">¶</a></h2>
<p>The simplest example of a documentation annotation is for documenting
any top-level declaration (function type signature, type declaration, or
class declaration). For example, if the source file contains the
following type signature:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">square</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">square</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>Then we can document it like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- |The &#39;square&#39; function squares an integer.</span><span class="w"></span>
<span class="nf">square</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">square</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">--</span> <span class="pre">|</span></code> syntax begins a documentation annotation, which applies
to the <em>following</em> declaration in the source file. Note that the
annotation is just a comment in Haskell — it will be ignored by the
Haskell compiler.</p>
<p>The declaration following a documentation annotation should be one of
the following:</p>
<ul class="simple">
<li><p>A type signature for a top-level function,</p></li>
<li><p>A definition for a top-level function with no type signature,</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">data</span></code> declaration,</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">pattern</span></code> declaration,</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">newtype</span></code> declaration,</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">type</span></code> declaration</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">class</span></code> declaration,</p></li>
<li><p>An <code class="docutils literal notranslate"><span class="pre">instance</span></code> declaration,</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">family</span></code> or <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">family</span></code> declaration, or</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">instance</span></code> or <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">instance</span></code> declaration.</p></li>
</ul>
<p>If the annotation is followed by a different kind of declaration, it
will probably be ignored by Haddock.</p>
<p>Some people like to write their documentation <em>after</em> the declaration;
this is possible in Haddock too:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">square</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="c1">-- ^The &#39;square&#39; function squares an integer.</span><span class="w"></span>
<span class="nf">square</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>Since Haddock uses the GHC API internally, it can infer types for
top-level functions without type signatures. However, you’re
encouraged to add explicit type signatures for all top-level
functions, to make your source code more readable for your users, and
at times to avoid GHC inferring overly general type signatures that
are less helpful to your users.</p>
<p>Documentation annotations may span several lines; the annotation
continues until the first non-comment line in the source file. For
example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- |The &#39;square&#39; function squares an integer.</span><span class="w"></span>
<span class="c1">-- It takes one argument, of type &#39;Int&#39;.</span><span class="w"></span>
<span class="nf">square</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">square</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>You can also use Haskell’s nested-comment style for documentation
annotations, which is sometimes more convenient when using multi-line
comments:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-|</span>
<span class="cm">  The &#39;square&#39; function squares an integer.</span>
<span class="cm">  It takes one argument, of type &#39;Int&#39;.</span>
<span class="cm">-}</span><span class="w"></span>
<span class="nf">square</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">square</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="documenting-parts-of-a-declaration">
<h2>Documenting Parts of a Declaration<a class="headerlink" href="#documenting-parts-of-a-declaration" title="Permalink to this heading">¶</a></h2>
<p>In addition to documenting the whole declaration, in some cases we can
also document individual parts of the declaration.</p>
<section id="class-methods">
<h3>Class Methods<a class="headerlink" href="#class-methods" title="Permalink to this heading">¶</a></h3>
<p>Class methods are documented in the same way as top level type
signatures, by using either the <code class="docutils literal notranslate"><span class="pre">--</span> <span class="pre">|</span></code> or <code class="docutils literal notranslate"><span class="pre">--</span> <span class="pre">^</span></code> annotations:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="c1">-- | This is the documentation for the &#39;f&#39; method</span><span class="w"></span>
<span class="w">   </span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">   </span><span class="c1">-- | This is the documentation for the &#39;g&#39; method</span><span class="w"></span>
<span class="w">   </span><span class="n">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>Associated type and data families can also be annotated in this way.</p>
</section>
<section id="constructors-and-record-fields">
<h3>Constructors and Record Fields<a class="headerlink" href="#constructors-and-record-fields" title="Permalink to this heading">¶</a></h3>
<p>Constructors are documented like so:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- | This is the documentation for the &#39;C1&#39; constructor</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">C1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- | This is the documentation for the &#39;C2&#39; constructor</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">C2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>or like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">C1</span><span class="w">   </span><span class="c1">-- ^ This is the documentation for the &#39;C1&#39; constructor</span><span class="w"></span>
<span class="w">      </span><span class="n">a</span><span class="w">  </span><span class="c1">-- ^ This is the documentation for the argument of type &#39;a&#39;</span><span class="w"></span>
<span class="w">      </span><span class="n">b</span><span class="w">  </span><span class="c1">-- ^ This is the documentation for the argument of type &#39;b&#39;</span><span class="w"></span>
</pre></div>
</div>
<p>There is one edge case that is handled differently: only one <code class="docutils literal notranslate"><span class="pre">--</span> <span class="pre">^</span></code>
annotation occurring after the constructor and all its arguments is
applied to the constructor, not its last argument:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">C1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w">  </span><span class="c1">-- ^ This is the documentation for the &#39;C1&#39; constructor</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">C2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w">  </span><span class="c1">-- ^ This is the documentation for the &#39;C2&#39; constructor</span><span class="w"></span>
</pre></div>
</div>
<p>Record fields are documented using one of these styles:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kt">C</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">-- | This is the documentation for the &#39;a&#39; field</span><span class="w"></span>
<span class="w">      </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="c1">-- | This is the documentation for the &#39;b&#39; field</span><span class="w"></span>
<span class="w">      </span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kt">C</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w">  </span><span class="c1">-- ^ This is the documentation for the &#39;a&#39; field</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">b</span><span class="w">  </span><span class="c1">-- ^ This is the documentation for the &#39;b&#39; field</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Alternative layout styles are generally accepted by Haddock - for
example doc comments can appear before or after the comma in separated
lists such as the list of record fields above.</p>
<p>In cases where more than one constructor exports a field with the same
name, the documentation attached to the first occurrence of the field
will be used, even if a comment is not present.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">someField</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="c1">-- ^ Doc for someField of A</span><span class="w"></span>
<span class="w">             </span><span class="p">}</span><span class="w"></span>
<span class="w">         </span><span class="o">|</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">someField</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="c1">-- ^ Doc for someField of B</span><span class="w"></span>
<span class="w">             </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In the above example, all occurrences of <code class="docutils literal notranslate"><span class="pre">someField</span></code> in the
documentation are going to be documented with
<code class="docutils literal notranslate"><span class="pre">Doc</span> <span class="pre">for</span> <span class="pre">someField</span> <span class="pre">of</span> <span class="pre">A</span></code>. Note that Haddock versions 2.14.0 and before
would join up documentation of each field and render the result. The
reason for this seemingly weird behaviour is the fact that <code class="docutils literal notranslate"><span class="pre">someField</span></code>
is actually the same (partial) function.</p>
</section>
<section id="deriving-clauses">
<h3>Deriving clauses<a class="headerlink" href="#deriving-clauses" title="Permalink to this heading">¶</a></h3>
<p>Most instances are top-level, so can be documented as in
<a class="reference internal" href="#top-level-declaration"><span class="std std-ref">Documenting a Top-Level Declaration</span></a>. The exception to this is instance that are
come from a <code class="docutils literal notranslate"><span class="pre">deriving</span></code> clause on a datatype declaration. These can
the documented like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">L</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">M</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">Eq</span><span class="w">   </span><span class="c1">-- ^ @since 4.5</span><span class="w"></span>
<span class="w">           </span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="w">  </span><span class="c1">-- ^ default &#39;Ord&#39; instance</span><span class="w"></span>
<span class="w">           </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This also scales to the various GHC extensions for deriving:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w">          </span><span class="kt">Show</span><span class="w">     </span><span class="c1">-- ^ derivation of &#39;Show&#39;</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="n">stock</span><span class="w">  </span><span class="p">(</span><span class="w"> </span><span class="kt">Eq</span><span class="w">       </span><span class="c1">-- ^ stock derivation of &#39;Eq&#39;</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="kt">Foldable</span><span class="w"> </span><span class="c1">-- ^ stock derivation of &#39;Foldable&#39;</span><span class="w"></span>
<span class="w">                  </span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="kr">newtype</span><span class="w">  </span><span class="kt">Ord</span><span class="w">      </span><span class="c1">-- ^ newtype derivation of &#39;Ord&#39;</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="n">anyclass</span><span class="w"> </span><span class="kt">Read</span><span class="w">     </span><span class="c1">-- ^ unsafe derivation of &#39;Read&#39;</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="kt">Eq1</span><span class="w">      </span><span class="c1">-- ^ deriving &#39;Eq1&#39; via &#39;Identity&#39;</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="kt">Ord1</span><span class="w">     </span><span class="c1">-- ^ deriving &#39;Ord1&#39; via &#39;Identity&#39;</span><span class="w"></span>
<span class="w">                  </span><span class="p">)</span><span class="w"> </span><span class="n">via</span><span class="w"> </span><span class="kt">Identity</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="function-arguments">
<h3>Function Arguments<a class="headerlink" href="#function-arguments" title="Permalink to this heading">¶</a></h3>
<p>Individual arguments to a function may be documented like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w">      </span><span class="c1">-- ^ The &#39;Int&#39; argument</span><span class="w"></span>
<span class="w">   </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Float</span><span class="w">    </span><span class="c1">-- ^ The &#39;Float&#39; argument</span><span class="w"></span>
<span class="w">   </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w">    </span><span class="c1">-- ^ The return value</span><span class="w"></span>
</pre></div>
</div>
<p>Pattern synonyms, GADT-style data constructors, and class methods also
support this style of documentation.</p>
</section>
</section>
<section id="the-module-description">
<span id="module-description"></span><h2>The Module Description<a class="headerlink" href="#the-module-description" title="Permalink to this heading">¶</a></h2>
<p>A module itself may be documented with multiple fields that can then be
displayed by the backend. In particular, the HTML backend displays all
the fields it currently knows about. We first show the most complete
module documentation example and then talk about the fields.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-|</span>
<span class="cm">Module      : W</span>
<span class="cm">Description : Short description</span>
<span class="cm">Copyright   : (c) Some Person, 2013</span>
<span class="cm">                  Someone Else, 2014</span>
<span class="cm">License     : GPL-3</span>
<span class="cm">Maintainer  : sample@email.com</span>
<span class="cm">Stability   : experimental</span>
<span class="cm">Portability : POSIX</span>

<span class="cm">Here is a longer description of this module, containing some</span>
<span class="cm">commentary with @some markup@.</span>
<span class="cm">-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">W</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>All fields are optional but they must be in order if they do appear.
Multi-line fields are accepted but the consecutive lines have to start
indented more than their label. If your label is indented one space, as
is often the case with the <code class="docutils literal notranslate"><span class="pre">--</span></code> syntax, the consecutive lines have
to start at two spaces at the very least. For example, above we saw a
multiline <code class="docutils literal notranslate"><span class="pre">Copyright</span></code> field:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-|</span>
<span class="cm">...</span>
<span class="cm">Copyright   : (c) Some Person, 2013</span>
<span class="cm">                  Someone Else, 2014</span>
<span class="cm">...</span>
<span class="cm">-}</span><span class="w"></span>
</pre></div>
</div>
<p>That could equivalently be written as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | ...</span><span class="w"></span>
<span class="c1">-- Copyright:</span><span class="w"></span>
<span class="c1">--  (c) Some Person, 2013</span><span class="w"></span>
<span class="c1">--  Someone Else, 2014</span><span class="w"></span>
<span class="c1">-- ...</span><span class="w"></span>
</pre></div>
</div>
<p>or as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | ...</span><span class="w"></span>
<span class="c1">-- Copyright: (c) Some Person, 2013</span><span class="w"></span>
<span class="c1">--     Someone Else, 2014</span><span class="w"></span>
<span class="c1">-- ...</span><span class="w"></span>
</pre></div>
</div>
<p>but not as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | ...</span><span class="w"></span>
<span class="c1">-- Copyright: (c) Some Person, 2013</span><span class="w"></span>
<span class="c1">-- Someone Else, 2014</span><span class="w"></span>
<span class="c1">-- ...</span><span class="w"></span>
</pre></div>
</div>
<p>since the <code class="docutils literal notranslate"><span class="pre">Someone</span></code> needs to be indented more than the
<code class="docutils literal notranslate"><span class="pre">Copyright</span></code>.</p>
<p>Whether new lines and other formatting in multiline fields is
preserved depends on the field type. For example, new lines in the
<code class="docutils literal notranslate"><span class="pre">Copyright</span></code> field are preserved, but new lines in the
<code class="docutils literal notranslate"><span class="pre">Description</span></code> field are not; leading whitespace is not preserved in
either <a class="footnote-reference brackets" href="#backend" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. Please note that we do not enforce the format for
any of the fields and the established formats are just a convention.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="backend" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Technically, whitespace and newlines in the
<code class="docutils literal notranslate"><span class="pre">Description</span></code> field are preserved verbatim by the HTML backend,
but because most browsers collapse whitespace in HTML, they don’t
render as such. But other backends may render this whitespace.</p>
</aside>
</aside>
<section id="fields-of-the-module-description">
<h3>Fields of the Module Description<a class="headerlink" href="#fields-of-the-module-description" title="Permalink to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Module</span></code> field specifies the current module name. Since the module
name can be inferred automatically from the source file, it doesn’t
affect the output of any of the backends. But you might want to
include it for any other tools that might be parsing these comments
without the help of GHC.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Description</span></code> field accepts some short text which outlines the
general purpose of the module. If you’re generating HTML, it will show
up next to the module link in the module index.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Copyright</span></code>, <code class="docutils literal notranslate"><span class="pre">License</span></code>, <code class="docutils literal notranslate"><span class="pre">Maintainer</span></code> and <code class="docutils literal notranslate"><span class="pre">Stability</span></code> fields should
be obvious. An alternative spelling for the <code class="docutils literal notranslate"><span class="pre">License</span></code> field is accepted
as <code class="docutils literal notranslate"><span class="pre">Licence</span></code> but the output will always prefer <code class="docutils literal notranslate"><span class="pre">License</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Portability</span></code> field has seen varied use by different library
authors. Some people put down things like operating system constraints
there while others put down which GHC extensions are used in the module.
Note that you might want to consider using the <code class="docutils literal notranslate"><span class="pre">show-extensions</span></code> module
flag for the latter (see <a class="reference internal" href="#module-attrs"><span class="std std-ref">Module Attributes</span></a>).</p>
<p>Finally, a module may contain a documentation comment before the
module header, in which case this comment is interpreted by Haddock as
an overall description of the module itself, and placed in a section
entitled <code class="docutils literal notranslate"><span class="pre">Description</span></code> in the documentation for the module. All the
usual Haddock <a class="reference internal" href="#markup"><span class="std std-ref">Markup</span></a> is valid in this comment.</p>
</section>
</section>
<section id="controlling-the-documentation-structure">
<h2>Controlling the Documentation Structure<a class="headerlink" href="#controlling-the-documentation-structure" title="Permalink to this heading">¶</a></h2>
<p>Haddock produces interface documentation that lists only the entities
actually exported by the module. If there is no export list then all
entities defined by the module are exported.</p>
<p>The documentation for a module will
include <em>all</em> entities exported by that module, even if they were
re-exported from another module. The only exception is when Haddock can’t
see the declaration for the re-exported entity, perhaps because it isn’t
part of the batch of modules currently being processed.</p>
<p>To Haddock the export list has even more significance than just
specifying the entities to be included in the documentation. It also
specifies the <em>order</em> that entities will be listed in the generated
documentation. This leaves the programmer free to implement functions in
any order he/she pleases, and indeed in any <em>module</em> he/she pleases, but
still specify the order that the functions should be documented in the
export list. Indeed, many programmers already do this: the export list
is often used as a kind of ad-hoc interface documentation, with
headings, groups of functions, type signatures and declarations in
comments.</p>
<p>In the next section we give examples illustrating most of the
structural markup features. After the examples we go into more detail
explaining the related markup, namely <a class="reference internal" href="#section-headings"><span class="std std-ref">Section Headings</span></a>,
<a class="reference internal" href="#named-chunks"><span class="std std-ref">(Named) Chunks of Documentation</span></a>, and <a class="reference internal" href="#re-exporting-entire-module"><span class="std std-ref">Re-Exporting an Entire Module</span></a>.</p>
<section id="documentation-structure-examples">
<span id="structure-examples"></span><h3>Documentation Structure Examples<a class="headerlink" href="#documentation-structure-examples" title="Permalink to this heading">¶</a></h3>
<p>We now give several examples that produce similar results and
illustrate most of the structural markup features. The first two
examples use an export list, but the third example does not.</p>
<p>The first example, using an export list with <a class="reference internal" href="#section-headings"><span class="std std-ref">Section Headings</span></a>
and inline section descriptions:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Image</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="w"> </span><span class="c1">-- * Image importers</span><span class="w"></span>
<span class="w">    </span><span class="c1">--</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- | There is a &quot;smart&quot; importer, &#39;readImage&#39;, that determines</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- the image format from the file extension, and several</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- &quot;dumb&quot; format-specific importers that decode the file as</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- the specified type.</span><span class="w"></span>
<span class="w">    </span><span class="nf">readImage</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="nf">readPngImage</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="nf">readGifImage</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- * Image exporters</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- ...</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Image.Types</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">Image</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="c1">-- | Read an image, guessing the format from the file name.</span><span class="w"></span>
<span class="nf">readImage</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Image</span><span class="w"></span>
<span class="nf">readImage</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="c1">-- | Read a GIF.</span><span class="w"></span>
<span class="nf">readGifImage</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Image</span><span class="w"></span>
<span class="nf">readGifImage</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="c1">-- | Read a PNG.</span><span class="w"></span>
<span class="nf">readPngImage</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Image</span><span class="w"></span>
<span class="nf">readPngImage</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Note that the order of the entities <code class="docutils literal notranslate"><span class="pre">readPngImage</span></code> and
<code class="docutils literal notranslate"><span class="pre">readGifImage</span></code> in the export list is different from the order of the
actual declarations farther down; the order in the export list is the
order used in the generated docs. Also, the imported <code class="docutils literal notranslate"><span class="pre">Image</span></code> type
itself is not re-exported, so it will not be included in the rendered
docs (see <a class="reference internal" href="#hyperlinking-re-exported"><span class="std std-ref">Hyperlinking and Re-Exported Entities</span></a>).</p>
<p>The second example, using an export list with a section description
defined elsewhere (the <code class="docutils literal notranslate"><span class="pre">$imageImporters</span></code>; see <a class="reference internal" href="#named-chunks"><span class="std std-ref">(Named) Chunks of Documentation</span></a>):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Image</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="w"> </span><span class="c1">-- * Image importers</span><span class="w"></span>
<span class="w">    </span><span class="c1">--</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- $imageImporters</span><span class="w"></span>
<span class="w">    </span><span class="nf">readImage</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="nf">readPngImage</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="nf">readGifImage</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- * Image exporters</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- ...</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Image.Types</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">Image</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="c1">-- $imageImporters</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- There is a &quot;smart&quot; importer, &#39;readImage&#39;, that determines the</span><span class="w"></span>
<span class="c1">-- image format from the file extension, and several &quot;dumb&quot;</span><span class="w"></span>
<span class="c1">-- format-specific importers that decode the file as the specified</span><span class="w"></span>
<span class="c1">-- type.</span><span class="w"></span>

<span class="c1">-- | Read an image, guessing the format from the file name.</span><span class="w"></span>
<span class="nf">readImage</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Image</span><span class="w"></span>
<span class="nf">readImage</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="c1">-- | Read a GIF.</span><span class="w"></span>
<span class="nf">readGifImage</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Image</span><span class="w"></span>
<span class="nf">readGifImage</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="c1">-- | Read a PNG.</span><span class="w"></span>
<span class="nf">readPngImage</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Image</span><span class="w"></span>
<span class="nf">readPngImage</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>This produces the same rendered docs as the first example, but the
source code itself is arguably more readable, since the documentation
for the group of importer functions is closer to their definitions.</p>
<p>The third example, without an export list:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Image</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Image.Types</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">Image</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="c1">-- * Image importers</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- $imageImporters</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- There is a &quot;smart&quot; importer, &#39;readImage&#39;, that determines the</span><span class="w"></span>
<span class="c1">-- image format from the file extension, and several &quot;dumb&quot;</span><span class="w"></span>
<span class="c1">-- format-specific importers that decode the file as the specified</span><span class="w"></span>
<span class="c1">-- type.</span><span class="w"></span>

<span class="c1">-- | Read an image, guessing the format from the file name.</span><span class="w"></span>
<span class="nf">readImage</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Image</span><span class="w"></span>
<span class="nf">readImage</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="c1">-- | Read a GIF.</span><span class="w"></span>
<span class="nf">readGifImage</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Image</span><span class="w"></span>
<span class="nf">readGifImage</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="c1">-- | Read a PNG.</span><span class="w"></span>
<span class="nf">readPngImage</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Image</span><span class="w"></span>
<span class="nf">readPngImage</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="o">...</span><span class="w"></span>

<span class="c1">-- * Image exporters</span><span class="w"></span>
<span class="c1">-- ...</span><span class="w"></span>
</pre></div>
</div>
<p>Note that the section headers (e.g. <code class="docutils literal notranslate"><span class="pre">--</span> <span class="pre">*</span> <span class="pre">Image</span> <span class="pre">importers</span></code>) now
appear in the module body itself, and that the section documentation
is still given using <a class="reference internal" href="#named-chunks"><span class="std std-ref">(Named) Chunks of Documentation</span></a>. Unlike in the first example
when using an export list, the named chunk syntax <code class="docutils literal notranslate"><span class="pre">$imageImporters</span></code>
<em>must</em> be used for the section documentation; attempting to use the
<code class="docutils literal notranslate"><span class="pre">--</span> <span class="pre">|</span> <span class="pre">...</span></code> syntax to document the image importers here will wrongly
associate the documentation chunk with the next definition!</p>
</section>
<section id="section-headings">
<span id="id2"></span><h3>Section Headings<a class="headerlink" href="#section-headings" title="Permalink to this heading">¶</a></h3>
<p>You can insert headings and sub-headings in the documentation by
including annotations at the appropriate point in the export list, or
in the module body directly when not using an export list.</p>
<p>For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Foo</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- * Classes</span><span class="w"></span>
<span class="w">  </span><span class="kt">C</span><span class="p">(</span><span class="o">..</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- * Types</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- ** A data type</span><span class="w"></span>
<span class="w">  </span><span class="kt">T</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- ** A record</span><span class="w"></span>
<span class="w">  </span><span class="kt">R</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- * Some functions</span><span class="w"></span>
<span class="w">  </span><span class="nf">f</span><span class="p">,</span><span class="w"> </span><span class="nf">g</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
</pre></div>
</div>
<p>Headings are introduced with the syntax <code class="docutils literal notranslate"><span class="pre">--</span> <span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">--</span> <span class="pre">**</span></code> and so
on, where the number of <code class="docutils literal notranslate"><span class="pre">*</span></code>s indicates the level of the heading
(section, sub-section, sub-sub-section, etc.).</p>
<p>If you use section headings, then Haddock will generate a table of
contents at the top of the module documentation for you.</p>
<p>By default, when generating HTML documentation Haddock will create an
anchor to each section of the form <code class="docutils literal notranslate"><span class="pre">#g:n</span></code>, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is an integer
that might change as you add new section headings. If you want to
create stable links, you can add an explicit anchor (see
<a class="reference internal" href="#anchors"><span class="std std-ref">Anchors</span></a>) after the section heading:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Foo</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- * Classes #classes#</span><span class="w"></span>
<span class="w">  </span><span class="kt">C</span><span class="p">(</span><span class="o">..</span><span class="p">)</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
</pre></div>
</div>
<p>This will create an HTML anchor <code class="docutils literal notranslate"><span class="pre">#g:classes</span></code> to the section.</p>
<p>The alternative style of placing the commas at the beginning of each
line is also supported, e.g.:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Foo</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- * Classes</span><span class="w"></span>
<span class="w">    </span><span class="kt">C</span><span class="p">(</span><span class="o">..</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- * Types</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- ** A data type</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="kt">T</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- ** A record</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="kt">R</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- * Some functions</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="nf">f</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="nf">g</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
</pre></div>
</div>
<p>When not using an export list, you may insert section headers in the
module body. Such section headers associate with all entities
declared up until the next section header. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Foo</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="c1">-- * Classes</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="c1">-- * Types</span><span class="w"></span>
<span class="c1">-- ** A data type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="c1">-- ** A record</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="c1">-- * Some functions</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="re-exporting-an-entire-module">
<span id="re-exporting-entire-module"></span><h3>Re-Exporting an Entire Module<a class="headerlink" href="#re-exporting-an-entire-module" title="Permalink to this heading">¶</a></h3>
<p>Haskell allows you to re-export the entire contents of a module (or at
least, everything currently in scope that was imported from a given
module) by listing it in the export list:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">A</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="nf">module</span><span class="w"> </span><span class="kt">B</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nf">module</span><span class="w"> </span><span class="kt">C</span><span class="w"></span>
<span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
</pre></div>
</div>
<p>What will the Haddock-generated documentation for this module look like?
Well, it depends on how the modules <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code> are imported. If
they are imported wholly and without any <code class="docutils literal notranslate"><span class="pre">hiding</span></code> qualifiers, then the
documentation will just contain a cross-reference to the documentation
for <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p>
<p>However, if the modules are not <em>completely</em> re-exported, for example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">A</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="nf">module</span><span class="w"> </span><span class="kt">B</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nf">module</span><span class="w"> </span><span class="kt">C</span><span class="w"></span>
<span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">B</span><span class="w"> </span><span class="k">hiding</span><span class="w"> </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">C</span><span class="w"> </span><span class="p">(</span><span class="nf">a</span><span class="p">,</span><span class="w"> </span><span class="nf">b</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>then Haddock behaves as if the set of entities re-exported from <code class="docutils literal notranslate"><span class="pre">B</span></code>
and <code class="docutils literal notranslate"><span class="pre">C</span></code> had been listed explicitly in the export list <a class="footnote-reference brackets" href="#notimplemented" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="notimplemented" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>This is not implemented at the time of writing
(Haddock version 2.17.3 with GHC 8.0.2). At the moment, Haddock
always inserts a module cross-reference.</p>
</aside>
</aside>
<p>The exception to this rule is when the re-exported module is declared
with the <code class="docutils literal notranslate"><span class="pre">hide</span></code> attribute (see <a class="reference internal" href="#module-attrs"><span class="std std-ref">Module Attributes</span></a>), in which
case the module is
never cross-referenced; the contents are always expanded in place in the
re-exporting module.</p>
</section>
<section id="named-chunks-of-documentation">
<span id="named-chunks"></span><h3>(Named) Chunks of Documentation<a class="headerlink" href="#named-chunks-of-documentation" title="Permalink to this heading">¶</a></h3>
<p>It is often desirable to include a chunk of documentation which is not
attached to any particular Haskell declaration, for example, when
giving summary documentation for a group of related definitions (see
<a class="reference internal" href="#structure-examples"><span class="std std-ref">Documentation Structure Examples</span></a>). In addition to including such documentation
chunks at the top of the file, as part of the
<a class="reference internal" href="#module-description"><span class="std std-ref">The Module Description</span></a>, you can also associate them with
<a class="reference internal" href="#section-headings"><span class="std std-ref">Section Headings</span></a>.</p>
<p>There are several ways to associate documentation chunks with section
headings, depending on whether you are using an export list or not:</p>
<ul>
<li><p>The documentation can be included in the export list directly, by
preceding it with a <code class="docutils literal notranslate"><span class="pre">--</span> <span class="pre">|</span></code>. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Foo</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">   </span><span class="c1">-- * A section heading</span><span class="w"></span>

<span class="w">   </span><span class="c1">-- | Some documentation not attached to a particular Haskell entity</span><span class="w"></span>
<span class="w">   </span><span class="o">...</span><span class="w"></span>
<span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
</pre></div>
</div>
<p>In this case the chunk is not “named”.</p>
</li>
<li><p>If the documentation is large and placing it inline in the export
list might bloat the export list and obscure the structure, then it
can be given a name and placed out of line in the body of the module.
This is achieved with a special form of documentation annotation
<code class="docutils literal notranslate"><span class="pre">-- $</span></code>, which we call a <em>named chunk</em>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Foo</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">   </span><span class="c1">-- * A section heading</span><span class="w"></span>

<span class="w">   </span><span class="c1">-- $doc</span><span class="w"></span>
<span class="w">   </span><span class="o">...</span><span class="w"></span>
<span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="c1">-- $doc</span><span class="w"></span>
<span class="c1">-- Here is a large chunk of documentation which may be referred to by</span><span class="w"></span>
<span class="c1">-- the name $doc.</span><span class="w"></span>
</pre></div>
</div>
<p>The documentation chunk is given a name of your choice (here
<code class="docutils literal notranslate"><span class="pre">doc</span></code>), which is the sequence of alphanumeric characters directly
after the <code class="docutils literal notranslate"><span class="pre">-- $</span></code>, and it may be referred to by the same name in
the export list. Note that named chunks must come <em>after</em> any
imports in the module body.</p>
</li>
<li><p>If you aren’t using an export list, then your only choice is to use
a named chunk with the <code class="docutils literal notranslate"><span class="pre">--</span> <span class="pre">$</span></code> syntax. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Foo</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="c1">-- * A section heading</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- $doc</span><span class="w"></span>
<span class="c1">-- Here is a large chunk of documentation which may be referred to by</span><span class="w"></span>
<span class="c1">-- the name $doc.</span><span class="w"></span>
</pre></div>
</div>
<p>Just like with entity declarations when not using an export list,
named chunks of documentation are associated with the preceding
section header here, or with the implicit top-level documentation
section if there is no preceding section header.</p>
<p><strong>Warning</strong>: the form used in the first bullet above, where the
chunk is not named, <em>does not work</em> when you aren’t using an
export list. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Foo</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="c1">-- * A section heading</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- | Some documentation not attached to a particular Haskell entity</span><span class="w"></span>

<span class="c1">-- | The fooifier.</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>will result in <code class="docutils literal notranslate"><span class="pre">Some</span> <span class="pre">documentation</span> <span class="pre">not</span> <span class="pre">...</span></code> being attached to the
<em>next</em> entity declaration, here <code class="docutils literal notranslate"><span class="pre">foo</span></code>, in addition to any other
documentation that next entity already has!</p>
</li>
</ul>
</section>
</section>
<section id="hyperlinking-and-re-exported-entities">
<span id="hyperlinking-re-exported"></span><h2>Hyperlinking and Re-Exported Entities<a class="headerlink" href="#hyperlinking-and-re-exported-entities" title="Permalink to this heading">¶</a></h2>
<p>When Haddock renders a type in the generated documentation, it
hyperlinks all the type constructors and class names in that type to
their respective definitions. But for a given type constructor or class
there may be several modules re-exporting it, and therefore several
modules whose documentation contains the definition of that type or
class (possibly including the current module!) so which one do we link
to?</p>
<p>Let’s look at an example. Suppose we have three modules <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code> and
<code class="docutils literal notranslate"><span class="pre">C</span></code> defined as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">A</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="kr">module</span><span class="w"> </span><span class="nn">B</span><span class="w"> </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">A</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">C</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">i</span><span class="w"></span>

<span class="kr">module</span><span class="w"> </span><span class="nn">C</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="p">,</span><span class="w"> </span><span class="nf">f</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">A</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">B</span><span class="w"></span>
</pre></div>
</div>
<p>Module <code class="docutils literal notranslate"><span class="pre">A</span></code> exports a datatype <code class="docutils literal notranslate"><span class="pre">T</span></code>. Module <code class="docutils literal notranslate"><span class="pre">B</span></code> imports <code class="docutils literal notranslate"><span class="pre">A</span></code> and
exports a function <code class="docutils literal notranslate"><span class="pre">f</span></code> whose type refers to <code class="docutils literal notranslate"><span class="pre">T</span></code>. Also, both <code class="docutils literal notranslate"><span class="pre">T</span></code>
and <code class="docutils literal notranslate"><span class="pre">f</span></code> are re-exported from module C.</p>
<p>Haddock takes the view that each entity has a <em>home</em> module; that is,
the module that the library designer would most like to direct the user
to, to find the documentation for that entity. So, Haddock makes all
links to an entity point to the home module. The one exception is when
the entity is also exported by the current module: Haddock makes a local
link if it can.</p>
<p>How is the home module for an entity determined? Haddock uses the
following rules:</p>
<ul class="simple">
<li><p>If modules A and B both export the entity, and module A imports
(directly or indirectly) module B, then B is preferred.</p></li>
<li><p>A module with the <code class="docutils literal notranslate"><span class="pre">hide</span></code> attribute is never chosen as the home.</p></li>
<li><p>A module with the <code class="docutils literal notranslate"><span class="pre">not-home</span></code> attribute is only chosen if there are
no other modules to choose.</p></li>
</ul>
<p>If multiple modules fit the criteria, then one is chosen at random. If
no modules fit the criteria (because the candidates are all hidden),
then Haddock will issue a warning for each reference to an entity
without a home.</p>
<p>In the example above, module <code class="docutils literal notranslate"><span class="pre">A</span></code> is chosen as the home for <code class="docutils literal notranslate"><span class="pre">T</span></code>
because it does not import any other module that exports <code class="docutils literal notranslate"><span class="pre">T</span></code>. The link
from <code class="docutils literal notranslate"><span class="pre">f</span></code>’s type in module <code class="docutils literal notranslate"><span class="pre">B</span></code> will therefore point to <code class="docutils literal notranslate"><span class="pre">A.T</span></code>.
However, <code class="docutils literal notranslate"><span class="pre">C</span></code> also exports <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span></code>, and the link from <code class="docutils literal notranslate"><span class="pre">f</span></code>’s
type in <code class="docutils literal notranslate"><span class="pre">C</span></code> will therefore point locally to <code class="docutils literal notranslate"><span class="pre">C.T</span></code>.</p>
</section>
<section id="module-attributes">
<span id="module-attrs"></span><h2>Module Attributes<a class="headerlink" href="#module-attributes" title="Permalink to this heading">¶</a></h2>
<p>Certain attributes may be specified for each module which affect the
way that Haddock generates documentation for that module. Attributes are
specified in a comma-separated list in an
<code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">OPTIONS_HADDOCK</span> <span class="pre">...</span> <span class="pre">#-}</span></code> pragma at the top of the module, either
before or after the module description. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# OPTIONS_HADDOCK hide, prune, ignore-exports #-}</span><span class="w"></span>

<span class="c1">-- |Module description</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>The options and module description can be in either order.</p>
<p>The following attributes are currently understood by Haddock:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">hide</span></code></dt><dd><p>Omit this module from the generated documentation, but nevertheless
propagate definitions and documentation from within this module to
modules that re-export those definitions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prune</span></code></dt><dd><p>Omit definitions that have no documentation annotations from the
generated documentation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ignore-exports</span></code></dt><dd><p>Ignore the export list. Generate documentation as if the module had
no export list - i.e. all the top-level declarations are exported,
and section headings may be given in the body of the module.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">not-home</span></code></dt><dd><p>Indicates that the current module should not be considered to be the
home module for each entity it exports, unless that entity is not
exported from any other module. See <a class="reference internal" href="#hyperlinking-re-exported"><span class="std std-ref">Hyperlinking and Re-Exported Entities</span></a>
for more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">show-extensions</span></code></dt><dd><p>Indicates that we should render the extensions used in this module
in the resulting documentation. This will only render if the output
format supports it. If Language is set, it will be shown as well and
all the extensions implied by it won’t. All enabled extensions will
be rendered, including those implied by their more powerful
versions.</p>
</dd>
</dl>
</section>
<section id="markup">
<span id="id4"></span><h2>Markup<a class="headerlink" href="#markup" title="Permalink to this heading">¶</a></h2>
<p>Haddock understands certain textual cues inside documentation
annotations that tell it how to render the documentation. The cues (or
“markup”) have been designed to be simple and mnemonic in ASCII so
the programmer doesn’t have to deal with heavyweight annotations when
editing documentation comments.</p>
<section id="paragraphs">
<h3>Paragraphs<a class="headerlink" href="#paragraphs" title="Permalink to this heading">¶</a></h3>
<p>One or more blank lines separates two paragraphs in a documentation
comment.</p>
</section>
<section id="special-characters">
<h3>Special Characters<a class="headerlink" href="#special-characters" title="Permalink to this heading">¶</a></h3>
<p>The following characters have special meanings in documentation comments:
<code class="docutils literal notranslate"><span class="pre">\</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">'</span></code>, <code class="docutils literal notranslate"><span class="pre">`</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">$</span></code>, <code class="docutils literal notranslate"><span class="pre">#</span></code>. To insert a
literal occurrence of one of these special characters, precede it with a
backslash (<code class="docutils literal notranslate"><span class="pre">\</span></code>).</p>
<p>Additionally, the character <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> has a special meaning at the beginning
of a line, and the following characters have special meanings at the
beginning of a paragraph: <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>. These characters can also be
escaped using <code class="docutils literal notranslate"><span class="pre">\</span></code>.</p>
<p>Furthermore, the character sequence <code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code> has a special meaning at the
beginning of a line. To escape it, just prefix the characters in the
sequence with a backslash.</p>
</section>
<section id="character-references">
<h3>Character References<a class="headerlink" href="#character-references" title="Permalink to this heading">¶</a></h3>
<p>Although Haskell source files may contain any character from the Unicode
character set, the encoding of these characters as bytes varies between
systems. Consequently, only source files restricted to the ASCII character set
are portable. Other characters may be specified in character and string
literals using Haskell character escapes. To represent such characters
in documentation comments, Haddock supports SGML-style numeric character
references of the forms <code class="docutils literal notranslate"><span class="pre">&amp;#</span></code>D<code class="docutils literal notranslate"><span class="pre">;</span></code> and <code class="docutils literal notranslate"><span class="pre">&amp;#x</span></code>H<code class="docutils literal notranslate"><span class="pre">;</span></code> where D
and H are decimal and hexadecimal numbers denoting a code position in
Unicode (or ISO 10646). For example, the references <code class="docutils literal notranslate"><span class="pre">&amp;#x3BB;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&amp;#x3bb;</span></code> and <code class="docutils literal notranslate"><span class="pre">&amp;#955;</span></code> all represent the lower-case letter lambda.</p>
</section>
<section id="code-blocks">
<h3>Code Blocks<a class="headerlink" href="#code-blocks" title="Permalink to this heading">¶</a></h3>
<p>Displayed blocks of code are indicated by surrounding a paragraph with
<code class="docutils literal notranslate"><span class="pre">&#64;...&#64;</span></code> or by preceding each line of a paragraph with <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> (we often
call these “bird tracks”). For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | This documentation includes two blocks of code:</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- @</span><span class="w"></span>
<span class="c1">--     f x = x + x</span><span class="w"></span>
<span class="c1">-- @</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- &gt;  g x = x * 42</span><span class="w"></span>
</pre></div>
</div>
<p>There is an important difference between the two forms of code block: in
the bird-track form, the text to the right of the ‘<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>’ is
interpreted literally, whereas the <code class="docutils literal notranslate"><span class="pre">&#64;...&#64;</span></code> form interprets markup as
normal inside the code block. In particular, <code class="docutils literal notranslate"><span class="pre">/</span></code> is markup for italics,
and so e.g. <code class="docutils literal notranslate"><span class="pre">&#64;x</span> <span class="pre">/</span> <span class="pre">y</span> <span class="pre">/</span> <span class="pre">z&#64;</span></code> renders as <code class="docutils literal notranslate"><span class="pre">x</span></code> followed by italic
<code class="docutils literal notranslate"><span class="pre">y</span></code> with no slashes, followed by <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
</section>
<section id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h3>
<p>Haddock has markup support for examples of interaction with a
<em>read-eval-print loop (REPL)</em>. An example is introduced with <code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code>
followed by an expression followed by zero or more result lines:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | Two examples are given below:</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- &gt;&gt;&gt; fib 10</span><span class="w"></span>
<span class="c1">-- 55</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- &gt;&gt;&gt; putStrLn &quot;foo\nbar&quot;</span><span class="w"></span>
<span class="c1">-- foo</span><span class="w"></span>
<span class="c1">-- bar</span><span class="w"></span>
</pre></div>
</div>
<p>Result lines that only contain the string <code class="docutils literal notranslate"><span class="pre">&lt;BLANKLINE&gt;</span></code> are rendered
as blank lines in the generated documentation.</p>
</section>
<section id="properties">
<h3>Properties<a class="headerlink" href="#properties" title="Permalink to this heading">¶</a></h3>
<p>Haddock provides markup for properties:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | Addition is commutative:</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- prop&gt; a + b = b + a</span><span class="w"></span>
</pre></div>
</div>
<p>This allows third-party applications to extract and verify them.</p>
</section>
<section id="hyperlinked-identifiers">
<h3>Hyperlinked Identifiers<a class="headerlink" href="#hyperlinked-identifiers" title="Permalink to this heading">¶</a></h3>
<p>Referring to a Haskell identifier, whether it be a type, class,
constructor, or function, is done by surrounding it with a combination
of single quotes and backticks. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | This module defines the type &#39;T&#39;.</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">`T`</span></code> is also ok. <code class="docutils literal notranslate"><span class="pre">'T`</span></code> and <code class="docutils literal notranslate"><span class="pre">`T'</span></code> are accepted but less common.</p>
<p>If there is an entity <code class="docutils literal notranslate"><span class="pre">T</span></code> in scope in the current module, then the
documentation will hyperlink the reference in the text to the definition
of <code class="docutils literal notranslate"><span class="pre">T</span></code> (if the output format supports hyperlinking, of course; in a
printed format it might instead insert a page reference to the
definition).</p>
<p>It is also possible to refer to entities that are not in scope in the
current module, by giving the full qualified name of the entity:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | The identifier &#39;M.T&#39; is not in scope</span><span class="w"></span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">M.T</span></code> is not otherwise in scope, then Haddock will simply emit a
link pointing to the entity <code class="docutils literal notranslate"><span class="pre">T</span></code> exported from module <code class="docutils literal notranslate"><span class="pre">M</span></code> (without
checking to see whether either <code class="docutils literal notranslate"><span class="pre">M</span></code> or <code class="docutils literal notranslate"><span class="pre">M.T</span></code> exist).</p>
<p>Since values and types live in different namespaces in Haskell, it is possible
for a reference such as <code class="docutils literal notranslate"><span class="pre">'X'</span></code> to be ambiguous. In such a case, Haddock
defaults to pointing to the type. The ambiguity can be overcome by explicitly
specifying a namespace, by way of a <code class="docutils literal notranslate"><span class="pre">v</span></code> (for value) or <code class="docutils literal notranslate"><span class="pre">t</span></code> (for type)
immediately before the link:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | An implicit reference to  &#39;X&#39;, the type constructor</span><span class="w"></span>
<span class="c1">--   An explicit reference to v&#39;X&#39;, the data constructor</span><span class="w"></span>
<span class="c1">--   An explicit reference to t&#39;X&#39;, the type constructor</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">X</span><span class="w"></span>
</pre></div>
</div>
<p>To make life easier for documentation writers, a quoted identifier is
only interpreted as such if the quotes surround a lexically valid
Haskell identifier. This means, for example, that it normally isn’t
necessary to escape the single quote when used as an apostrophe:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | I don&#39;t have to escape my apostrophes; great, isn&#39;t it?</span><span class="w"></span>
</pre></div>
</div>
<p>Nothing special is needed to hyperlink identifiers which contain
apostrophes themselves: to hyperlink <code class="docutils literal notranslate"><span class="pre">foo'</span></code> one would simply type
<code class="docutils literal notranslate"><span class="pre">'foo''</span></code>. Hyperlinking operators works in exactly the same way.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | A prefix operator @&#39;(++)&#39;@ and an infix identifier @&#39;`elem`&#39;@.</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="emphasis-bold-and-monospaced-text">
<h3>Emphasis, Bold and Monospaced Text<a class="headerlink" href="#emphasis-bold-and-monospaced-text" title="Permalink to this heading">¶</a></h3>
<p>Emphasis may be added by surrounding text with <code class="docutils literal notranslate"><span class="pre">/.../</span></code>. Other markup
is valid inside emphasis. To have a forward slash inside of emphasis,
just escape it: <code class="docutils literal notranslate"><span class="pre">/fo\/o/</span></code></p>
<p>Bold (strong) text is indicated by surrounding it with <code class="docutils literal notranslate"><span class="pre">__...__</span></code>.
Other markup is valid inside bold. For example, <code class="docutils literal notranslate"><span class="pre">__/foo/__</span></code> will make
the emphasised text <code class="docutils literal notranslate"><span class="pre">foo</span></code> bold. You don’t have to escape a single
underscore if you need it bold:
<code class="docutils literal notranslate"><span class="pre">__This_text_with_underscores_is_bold__</span></code>.</p>
<p>Monospaced (or typewriter) text is indicated by surrounding it with
<code class="docutils literal notranslate"><span class="pre">&#64;...&#64;</span></code>. Other markup is valid inside a monospaced span: for example
<code class="docutils literal notranslate"><span class="pre">&#64;'f' a b&#64;</span></code> will hyperlink the identifier <code class="docutils literal notranslate"><span class="pre">f</span></code> inside the code
fragment, but <code class="docutils literal notranslate"><span class="pre">&#64;__FILE__&#64;</span></code> will render <code class="docutils literal notranslate"><span class="pre">FILE</span></code> in bold with no
underscores, which may not be what you had in mind.</p>
</section>
<section id="linking-to-modules">
<h3>Linking to Modules<a class="headerlink" href="#linking-to-modules" title="Permalink to this heading">¶</a></h3>
<p>Linking to a module is done by surrounding the module name with double
quotes:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | This is a reference to the &quot;Foo&quot; module.</span><span class="w"></span>
</pre></div>
</div>
<p>A basic check is done on the syntax of the header name to ensure that it
is valid before turning it into a link but unlike with identifiers,
whether the module is in scope isn’t checked and will always be turned
into a link.</p>
<p>It is also possible to specify alternate text for the generated link
using syntax analogous to that used for URLs:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | This is a reference to [the main module](&quot;Module.Main&quot;).</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="itemized-and-enumerated-lists">
<h3>Itemized and Enumerated Lists<a class="headerlink" href="#itemized-and-enumerated-lists" title="Permalink to this heading">¶</a></h3>
<p>A bulleted item is represented by preceding a paragraph with either
“<code class="docutils literal notranslate"><span class="pre">*</span></code>” or “<code class="docutils literal notranslate"><span class="pre">-</span></code>”. A sequence of bulleted paragraphs is rendered as an
itemized list in the generated documentation, e.g.:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | This is a bulleted list:</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">--     * first item</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">--     * second item</span><span class="w"></span>
</pre></div>
</div>
<p>An enumerated list is similar, except each paragraph must be preceded by
either “<code class="docutils literal notranslate"><span class="pre">(n)</span></code>” or “<code class="docutils literal notranslate"><span class="pre">n.</span></code>” where n is any integer. e.g.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | This is an enumerated list:</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">--     (1) first item</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">--     2. second item</span><span class="w"></span>
</pre></div>
</div>
<p>Lists of the same type don’t have to be separated by a newline:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | This is an enumerated list:</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">--     (1) first item</span><span class="w"></span>
<span class="c1">--     2. second item</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- This is a bulleted list:</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">--     * first item</span><span class="w"></span>
<span class="c1">--     * second item</span><span class="w"></span>
</pre></div>
</div>
<p>You can have more than one line of content in a list element:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- |</span><span class="w"></span>
<span class="c1">-- * first item</span><span class="w"></span>
<span class="c1">-- and more content for the first item</span><span class="w"></span>
<span class="c1">-- * second item</span><span class="w"></span>
<span class="c1">-- and more content for the second item</span><span class="w"></span>
</pre></div>
</div>
<p>You can even nest whole paragraphs inside of list elements. The rules
are 4 spaces for each indentation level. You’re required to use a
newline before such nested paragraphs:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-|</span>
<span class="cm">* Beginning of list</span>
<span class="cm">This belongs to the list above!</span>

<span class="cm">    &gt; nested</span>
<span class="cm">    &gt; bird</span>
<span class="cm">    &gt; tracks</span>

<span class="cm">    * Next list</span>
<span class="cm">    More of the indented list.</span>

<span class="cm">        * Deeper</span>

<span class="cm">            @</span>
<span class="cm">            even code blocks work</span>
<span class="cm">            @</span>

<span class="cm">            * Deeper</span>

<span class="cm">                    1. Even deeper!</span>
<span class="cm">                    2. No newline separation even in indented lists.</span>
<span class="cm">-}</span><span class="w"></span>
</pre></div>
</div>
<p>The indentation of the first list item is honoured. That is, in the
following example the items are on the same level. Before Haddock
2.16.1, the second item would have been nested under the first item
which was unexpected.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-|</span>
<span class="cm">    * foo</span>

<span class="cm">    * bar</span>
<span class="cm">-}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="definition-lists">
<h3>Definition Lists<a class="headerlink" href="#definition-lists" title="Permalink to this heading">¶</a></h3>
<p>Definition lists are written as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | This is a definition list:</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">--   [@foo@]: The description of @foo@.</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">--   [@bar@]: The description of @bar@.</span><span class="w"></span>
</pre></div>
</div>
<p>To produce output something like this:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">foo</span></code></dt><dd><p>The description of <code class="docutils literal notranslate"><span class="pre">foo</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bar</span></code></dt><dd><p>The description of <code class="docutils literal notranslate"><span class="pre">bar</span></code>.</p>
</dd>
</dl>
<p>Each paragraph should be preceded by the “definition term” enclosed in
square brackets and followed by a colon. Other markup operators may be
used freely within the definition term. You can escape <code class="docutils literal notranslate"><span class="pre">]</span></code> with a
backslash as usual.</p>
<p>Same rules about nesting and no newline separation as for bulleted and
numbered lists apply.</p>
</section>
<section id="urls">
<h3>URLs<a class="headerlink" href="#urls" title="Permalink to this heading">¶</a></h3>
<p>A URL can be included in a documentation comment by surrounding it in
angle brackets, for example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">http</span><span class="kt">://</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">&gt;</span><span class="w"></span>
</pre></div>
</div>
<p>If the output format supports it, the URL will be turned into a
hyperlink when rendered.</p>
<p>If Haddock sees something that looks like a URL (such as something
starting with <code class="docutils literal notranslate"><span class="pre">http://</span></code> or <code class="docutils literal notranslate"><span class="pre">ssh://</span></code>) where the URL markup is valid,
it will automatically make it a hyperlink.</p>
</section>
<section id="links">
<h3>Links<a class="headerlink" href="#links" title="Permalink to this heading">¶</a></h3>
<p>Haddock supports Markdown syntax for inline links. A link consists of a
link text and a URL. The link text is enclosed in square brackets and
followed by the URL enclosed in regular parentheses, for example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">some</span><span class="w"> </span><span class="n">link</span><span class="p">](</span><span class="n">http</span><span class="kt">://</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The link text is used as a description for the URL if the output
format supports it.</p>
<p>Hint: There’s a <a class="reference external" href="https://github.com/haskell/haddock/issues/774">known issue</a>
that any inline link at the beginning of a line within a multi-line comment
isn’t rendered correctly:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-| Some multi-line comment that has a</span>
<span class="cm">[link](https://example.com) and a</span>
<span class="cm">[reference link]: https://example.com</span>
<span class="cm">-}</span><span class="w"></span>
</pre></div>
</div>
<p>Adding a space or a word in front of such a link can be used as a workaround.</p>
</section>
<section id="images">
<h3>Images<a class="headerlink" href="#images" title="Permalink to this heading">¶</a></h3>
<p>Haddock supports Markdown syntax for inline images. This resembles the
syntax for links, but starts with an exclamation mark. An example looks
like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">!</span><span class="p">[</span><span class="n">image</span><span class="w"> </span><span class="n">description</span><span class="p">](</span><span class="n">pathtoimage</span><span class="o">.</span><span class="n">png</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>If the output format supports it, the image will be rendered inside the
documentation. The image description is used as replacement text and/or
an image title.</p>
</section>
<section id="mathematics-latex">
<h3>Mathematics / LaTeX<a class="headerlink" href="#mathematics-latex" title="Permalink to this heading">¶</a></h3>
<p>Haddock supports LaTeX syntax for rendering mathematical notation. The
delimiters are <code class="docutils literal notranslate"><span class="pre">\[...\]</span></code> for displayed mathematics and <code class="docutils literal notranslate"><span class="pre">\(...\)</span></code>
for in-line mathematics. An example looks like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">\</span><span class="p">[</span><span class="w"></span>
<span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">frac</span><span class="p">{</span><span class="mi">1</span><span class="p">}{</span><span class="mi">2</span><span class="nf">\</span><span class="n">pi</span><span class="w"> </span><span class="n">i</span><span class="p">}</span><span class="nf">\</span><span class="n">oint_</span><span class="nf">\</span><span class="n">gamma</span><span class="w"> </span><span class="nf">\</span><span class="n">frac</span><span class="p">{</span><span class="n">f</span><span class="p">(</span><span class="n">z</span><span class="p">)}{</span><span class="n">z</span><span class="o">-</span><span class="n">a</span><span class="p">}</span><span class="nf">\</span><span class="p">,</span><span class="nf">\</span><span class="n">mathrm</span><span class="p">{</span><span class="n">d</span><span class="p">}</span><span class="n">z</span><span class="w"></span>
<span class="nf">\</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>If the output format supports it, the mathematics will be rendered
inside the documentation. For example, the HTML backend will display
the mathematics via <a class="reference external" href="https://www.mathjax.org">MathJax</a>.</p>
</section>
<section id="grid-tables">
<h3>Grid Tables<a class="headerlink" href="#grid-tables" title="Permalink to this heading">¶</a></h3>
<p>Inspired by reSTs grid tables, Haddock supports a complete table representation
via grid-like “ASCII art”. Grid tables are described with a visual grid made
up of the characters “-”, “=”, “|”, and “+”. The hyphen (“-”) is used for
horizontal lines (row separators). The equals sign (“=”) may be used to
separate optional header rows from the table body. The vertical bar (“|”) is
used for vertical lines (column separators). The plus sign (“+”) is used for
intersections of horizontal and vertical lines.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | This is a grid table:</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- +------------------------+------------+----------+----------+</span><span class="w"></span>
<span class="c1">-- | Header row, column 1   | Header 2   | Header 3 | Header 4 |</span><span class="w"></span>
<span class="c1">-- | (header rows optional) |            |          |          |</span><span class="w"></span>
<span class="c1">-- +========================+============+==========+==========+</span><span class="w"></span>
<span class="c1">-- | body row 1, column 1   | column 2   | column 3 | column 4 |</span><span class="w"></span>
<span class="c1">-- +------------------------+------------+----------+----------+</span><span class="w"></span>
<span class="c1">-- | body row 2             | Cells may span columns.          |</span><span class="w"></span>
<span class="c1">-- +------------------------+------------+---------------------+</span><span class="w"></span>
<span class="c1">-- | body row 3             | Cells may  | \[                  |</span><span class="w"></span>
<span class="c1">-- +------------------------+ span rows. | f(n) = \sum_{i=1}   |</span><span class="w"></span>
<span class="c1">-- | body row 4             |            | \]                  |</span><span class="w"></span>
<span class="c1">-- +------------------------+------------+---------------------+</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="anchors">
<span id="id5"></span><h3>Anchors<a class="headerlink" href="#anchors" title="Permalink to this heading">¶</a></h3>
<p>Sometimes it is useful to be able to link to a point in the
documentation which doesn’t correspond to a particular entity. For that
purpose, we allow <em>anchors</em> to be included in a documentation comment.
The syntax is <code class="docutils literal notranslate"><span class="pre">#label#</span></code>, where label is the name of the anchor. An
anchor is invisible in the generated documentation.</p>
<p>To link to an anchor from elsewhere, use the syntax <code class="docutils literal notranslate"><span class="pre">&quot;module#label&quot;</span></code>
where module is the module name containing the anchor, and label is the
anchor label. The module does not have to be local, it can be imported
via an interface. Please note that in Haddock versions 2.13.x and
earlier, the syntax was <code class="docutils literal notranslate"><span class="pre">&quot;module\#label&quot;</span></code>. It is considered deprecated
and will be removed in the future.</p>
</section>
<section id="headings">
<h3>Headings<a class="headerlink" href="#headings" title="Permalink to this heading">¶</a></h3>
<p>Headings inside of comment documentation are possible by preceding them
with a number of <code class="docutils literal notranslate"><span class="pre">=</span></code>s. From 1 to 6 are accepted. Extra <code class="docutils literal notranslate"><span class="pre">=</span></code>s will
be treated as belonging to the text of the heading. Note that it’s up to
the output format to decide how to render the different levels.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- |</span><span class="w"></span>
<span class="c1">-- = Heading level 1 with some /emphasis/</span><span class="w"></span>
<span class="c1">-- Something underneath the heading.</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- == /Subheading/</span><span class="w"></span>
<span class="c1">-- More content.</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- === Subsubheading</span><span class="w"></span>
<span class="c1">-- Even more content.</span><span class="w"></span>
</pre></div>
</div>
<p>Note that while headings have to start on a new paragraph, we allow
paragraph-level content to follow these immediately.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- |</span><span class="w"></span>
<span class="c1">-- = Heading level 1 with some __bold__</span><span class="w"></span>
<span class="c1">-- Something underneath the heading.</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- == /Subheading/</span><span class="w"></span>
<span class="c1">-- More content.</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- === Subsubheading</span><span class="w"></span>
<span class="c1">-- &gt;&gt;&gt; examples are only allowed at the start of paragraphs</span><span class="w"></span>
</pre></div>
</div>
<p>As of 2.15.1, there’s experimental (read: subject to change or get
removed) support for collapsible headers: simply wrap your existing
header title in underscores, as per bold syntax. The collapsible section
will stretch until the end of the comment or until a header of equal or
smaller number of <code class="docutils literal notranslate"><span class="pre">=</span></code>s.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- |</span><span class="w"></span>
<span class="c1">-- === __Examples:__</span><span class="w"></span>
<span class="c1">-- &gt;&gt;&gt; Some very long list of examples</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- ==== This still falls under the collapse</span><span class="w"></span>
<span class="c1">-- Some specialised examples</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- === This is does not go into the collapsable section.</span><span class="w"></span>
<span class="c1">-- More content.</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="metadata">
<h3>Metadata<a class="headerlink" href="#metadata" title="Permalink to this heading">¶</a></h3>
<p>Since Haddock 2.16.0, some support for embedding metadata in the
comments has started to appear. The use of such data aims to standardise
various community conventions in how such information is conveyed and to
provide uniform rendering.</p>
<section id="since">
<h4>Since<a class="headerlink" href="#since" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">&#64;since</span></code> annotation can be used to convey information about when the
function was introduced or when it has changed in a way significant to
the user. <code class="docutils literal notranslate"><span class="pre">&#64;since</span></code> is a paragraph-level element. While multiple such
annotations are not an error, only the one to appear in the comment last
will be used. <code class="docutils literal notranslate"><span class="pre">&#64;since</span></code> has to be followed with a version number, no
further description is currently allowed. The meaning of this feature is
subject to change in the future per user feedback.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- |</span><span class="w"></span>
<span class="c1">-- Some comment</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="c1">-- @since 1.2.3</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Haddock</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="invoking.html">Invoking Haddock</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Documentation and Markup</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#documenting-a-top-level-declaration">Documenting a Top-Level Declaration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#documenting-parts-of-a-declaration">Documenting Parts of a Declaration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-module-description">The Module Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-the-documentation-structure">Controlling the Documentation Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hyperlinking-and-re-exported-entities">Hyperlinking and Re-Exported Entities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-attributes">Module Attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#markup">Markup</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="common-errors.html">Common Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi-components.html">Haddocks of multiple components</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="invoking.html" title="previous chapter">Invoking Haddock</a></li>
      <li>Next: <a href="common-errors.html" title="next chapter">Common Errors</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Simon Marlow.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/markup.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>
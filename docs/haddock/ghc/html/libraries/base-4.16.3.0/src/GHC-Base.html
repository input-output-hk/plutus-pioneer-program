<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Base.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>
<a name="line-3"></a>The overall structure of the GHC Prelude is a bit tricky.
<a name="line-4"></a>
<a name="line-5"></a>  a) We want to avoid "orphan modules", i.e. ones with instance
<a name="line-6"></a>        decls that don't belong either to a tycon or a class
<a name="line-7"></a>        defined in the same module
<a name="line-8"></a>
<a name="line-9"></a>  b) We want to avoid giant modules
<a name="line-10"></a>
<a name="line-11"></a>So the rough structure is as follows, in (linearised) dependency order
<a name="line-12"></a>
<a name="line-13"></a>
<a name="line-14"></a>GHC.Prim        Has no implementation.  It defines built-in things, and
<a name="line-15"></a>                by importing it you bring them into scope.
<a name="line-16"></a>                The source file is GHC.Prim.hi-boot, which is just
<a name="line-17"></a>                copied to make GHC.Prim.hi
<a name="line-18"></a>
<a name="line-19"></a>GHC.Base        Classes: Eq, Ord, Functor, Monad
<a name="line-20"></a>                Types:   list, (), Int, Bool, Ordering, Char, String
<a name="line-21"></a>
<a name="line-22"></a>Data.Tuple      Types: tuples, plus instances for GHC.Base classes
<a name="line-23"></a>
<a name="line-24"></a>GHC.Show        Class: Show, plus instances for GHC.Base/GHC.Tup types
<a name="line-25"></a>
<a name="line-26"></a>GHC.Enum        Class: Enum,  plus instances for GHC.Base/GHC.Tup types
<a name="line-27"></a>
<a name="line-28"></a>Data.Maybe      Type: Maybe, plus instances for GHC.Base classes
<a name="line-29"></a>
<a name="line-30"></a>GHC.List        List functions
<a name="line-31"></a>
<a name="line-32"></a>GHC.Num         Class: Num, plus instances for Int
<a name="line-33"></a>                Type:  Integer, plus instances for all classes so far (Eq, Ord, Num, Show)
<a name="line-34"></a>
<a name="line-35"></a>                Integer is needed here because it is mentioned in the signature
<a name="line-36"></a>                of 'fromInteger' in class Num
<a name="line-37"></a>
<a name="line-38"></a>GHC.Real        Classes: Real, Integral, Fractional, RealFrac
<a name="line-39"></a>                         plus instances for Int, Integer
<a name="line-40"></a>                Types:  Ratio, Rational
<a name="line-41"></a>                        plus instances for classes so far
<a name="line-42"></a>
<a name="line-43"></a>                Rational is needed here because it is mentioned in the signature
<a name="line-44"></a>                of 'toRational' in class Real
<a name="line-45"></a>
<a name="line-46"></a>GHC.ST  The ST monad, instances and a few helper functions
<a name="line-47"></a>
<a name="line-48"></a>Ix              Classes: Ix, plus instances for Int, Bool, Char, Integer, Ordering, tuples
<a name="line-49"></a>
<a name="line-50"></a>GHC.Arr         Types: Array, MutableArray, MutableVar
<a name="line-51"></a>
<a name="line-52"></a>                Arrays are used by a function in GHC.Float
<a name="line-53"></a>
<a name="line-54"></a>GHC.Float       Classes: Floating, RealFloat
<a name="line-55"></a>                Types:   Float, Double, plus instances of all classes so far
<a name="line-56"></a>
<a name="line-57"></a>                This module contains everything to do with floating point.
<a name="line-58"></a>                It is a big module (900 lines)
<a name="line-59"></a>                With a bit of luck, many modules can be compiled without ever reading GHC.Float.hi
<a name="line-60"></a>
<a name="line-61"></a>
<a name="line-62"></a>Other Prelude modules are much easier with fewer complex dependencies.
<a name="line-63"></a>-}</span>
<a name="line-64"></a>
<a name="line-65"></a><span class='hs-comment'>{-# LANGUAGE BangPatterns #-}</span>
<a name="line-66"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-67"></a><span class='hs-comment'>{-# LANGUAGE DataKinds #-}</span>
<a name="line-68"></a><span class='hs-comment'>{-# LANGUAGE ExistentialQuantification #-}</span>
<a name="line-69"></a><span class='hs-comment'>{-# LANGUAGE MagicHash #-}</span>
<a name="line-70"></a><span class='hs-comment'>{-# LANGUAGE NoImplicitPrelude #-}</span>
<a name="line-71"></a><span class='hs-comment'>{-# LANGUAGE PolyKinds #-}</span>
<a name="line-72"></a><span class='hs-comment'>{-# LANGUAGE RankNTypes #-}</span>
<a name="line-73"></a><span class='hs-comment'>{-# LANGUAGE UnboxedTuples #-}</span>
<a name="line-74"></a><span class='hs-comment'>{-# LANGUAGE Unsafe #-}</span>
<a name="line-75"></a>
<a name="line-76"></a><span class='hs-comment'>-- -Wno-orphans is needed for things like:</span>
<a name="line-77"></a><span class='hs-comment'>-- Orphan rule: "x# -# x#" ALWAYS forall x# :: Int# -# x# x# = 0</span>
<a name="line-78"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-orphans #-}</span>
<a name="line-79"></a><span class='hs-comment'>{-# OPTIONS_HADDOCK not-home #-}</span>
<a name="line-80"></a>
<a name="line-81"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-82"></a><span class='hs-comment'>-- |</span>
<a name="line-83"></a><span class='hs-comment'>-- Module      :  GHC.Base</span>
<a name="line-84"></a><span class='hs-comment'>-- Copyright   :  (c) The University of Glasgow, 1992-2002</span>
<a name="line-85"></a><span class='hs-comment'>-- License     :  see libraries/base/LICENSE</span>
<a name="line-86"></a><span class='hs-comment'>--</span>
<a name="line-87"></a><span class='hs-comment'>-- Maintainer  :  cvs-ghc@haskell.org</span>
<a name="line-88"></a><span class='hs-comment'>-- Stability   :  internal</span>
<a name="line-89"></a><span class='hs-comment'>-- Portability :  non-portable (GHC extensions)</span>
<a name="line-90"></a><span class='hs-comment'>--</span>
<a name="line-91"></a><span class='hs-comment'>-- Basic data types and classes.</span>
<a name="line-92"></a><span class='hs-comment'>--</span>
<a name="line-93"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-94"></a>
<a name="line-95"></a><span class='hs-cpp'>#include "MachDeps.h"</span>
<a name="line-96"></a>
<a name="line-97"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Base</span>
<a name="line-98"></a>        <span class='hs-layout'>(</span>
<a name="line-99"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Base</span><span class='hs-layout'>,</span>
<a name="line-100"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Classes</span><span class='hs-layout'>,</span>
<a name="line-101"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.CString</span><span class='hs-layout'>,</span>
<a name="line-102"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Magic</span><span class='hs-layout'>,</span>
<a name="line-103"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Types</span><span class='hs-layout'>,</span>
<a name="line-104"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Prim</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Re-export GHC.Prim and [boot] GHC.Err,</span>
<a name="line-105"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Prim.Ext</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- to avoid lots of people having to</span>
<a name="line-106"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Err</span><span class='hs-layout'>,</span>         <span class='hs-comment'>-- import it explicitly</span>
<a name="line-107"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Maybe</span>
<a name="line-108"></a>  <span class='hs-layout'>)</span>
<a name="line-109"></a>        <span class='hs-keyword'>where</span>
<a name="line-110"></a>
<a name="line-111"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types</span>
<a name="line-112"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Classes</span>
<a name="line-113"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.CString</span>
<a name="line-114"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Magic</span>
<a name="line-115"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prim</span>
<a name="line-116"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prim.Ext</span>
<a name="line-117"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Err</span>
<a name="line-118"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Maybe</span>
<a name="line-119"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>GHC.IO</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkUserError</span><span class='hs-layout'>,</span> <span class='hs-varid'>mplusIO</span><span class='hs-layout'>)</span>
<a name="line-120"></a>
<a name="line-121"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tuple</span> <span class='hs-layout'>(</span><span class='hs-conid'>Solo</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- Note [Depend on GHC.Tuple]</span>
<a name="line-122"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Num.Integer</span> <span class='hs-conid'>()</span>        <span class='hs-comment'>-- Note [Depend on GHC.Num.Integer]</span>
<a name="line-123"></a>
<a name="line-124"></a><span class='hs-comment'>-- for 'class Semigroup'</span>
<a name="line-125"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>GHC.Real</span> <span class='hs-layout'>(</span><span class='hs-conid'>Integral</span><span class='hs-layout'>)</span>
<a name="line-126"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>Data.Semigroup.Internal</span> <span class='hs-layout'>(</span> <span class='hs-varid'>stimesDefault</span>
<a name="line-127"></a>                                              <span class='hs-layout'>,</span> <span class='hs-varid'>stimesMaybe</span>
<a name="line-128"></a>                                              <span class='hs-layout'>,</span> <span class='hs-varid'>stimesList</span>
<a name="line-129"></a>                                              <span class='hs-layout'>,</span> <span class='hs-varid'>stimesIdempotentMonoid</span>
<a name="line-130"></a>                                              <span class='hs-layout'>)</span>
<a name="line-131"></a>
<a name="line-132"></a><span class='hs-comment'>-- $setup</span>
<a name="line-133"></a><span class='hs-comment'>-- &gt;&gt;&gt; import GHC.Num</span>
<a name="line-134"></a>
<a name="line-135"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>9</span>  <span class='hs-varop'>.</span>
<a name="line-136"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>5</span>  <span class='hs-varop'>++</span>
<a name="line-137"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>4</span>  <span class='hs-varop'>&lt;$</span>
<a name="line-138"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>1</span>  <span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>,</span> <span class='hs-varop'>&gt;&gt;=</span>
<a name="line-139"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>1</span>  <span class='hs-varop'>=&lt;&lt;</span>
<a name="line-140"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>0</span>  <span class='hs-varop'>$</span><span class='hs-layout'>,</span> <span class='hs-varop'>$!</span>
<a name="line-141"></a>
<a name="line-142"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>4</span> <span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>,</span> <span class='hs-varop'>&lt;*</span><span class='hs-layout'>,</span> <span class='hs-varop'>*&gt;</span><span class='hs-layout'>,</span> <span class='hs-varop'>&lt;**&gt;</span>
<a name="line-143"></a>
<a name="line-144"></a><span class='hs-keyword'>default</span> <span class='hs-conid'>()</span>              <span class='hs-comment'>-- Double isn't available yet</span>
<a name="line-145"></a>
<a name="line-146"></a><span class='hs-comment'>{-
<a name="line-147"></a>Note [Depend on GHC.Num.Integer]
<a name="line-148"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-149"></a>
<a name="line-150"></a>The Integer type is special because GHC.CoreToStg.Prep.mkConvertNumLiteral
<a name="line-151"></a>lookups names in ghc-bignum interfaces to construct Integer literal values.
<a name="line-152"></a>Currently it reads the interface file whether or not the current module *has*
<a name="line-153"></a>any Integer literals, so it's important that GHC.Num.Integer is compiled before
<a name="line-154"></a>any other module.
<a name="line-155"></a>
<a name="line-156"></a>The danger is that if the build system doesn't know about the implicit
<a name="line-157"></a>dependency on Integer, it'll compile some base module before GHC.Num.Integer,
<a name="line-158"></a>resulting in:
<a name="line-159"></a>  Failed to load interface for ‘GHC.Num.Integer’
<a name="line-160"></a>    There are files missing in the ‘ghc-bignum’ package,
<a name="line-161"></a>
<a name="line-162"></a>Note that this is only a problem with the make-based build system. Hadrian
<a name="line-163"></a>doesn't interleave compilation of modules from separate packages and respects
<a name="line-164"></a>the dependency between `base` and `ghc-bignum`.
<a name="line-165"></a>
<a name="line-166"></a>To ensure that GHC.Num.Integer is there, we must ensure that there is a visible
<a name="line-167"></a>dependency on GHC.Num.Integer from every module in base.  We make GHC.Base
<a name="line-168"></a>depend on GHC.Num.Integer; and everything else either depends on GHC.Base,
<a name="line-169"></a>directly on GHC.Num.Integer, or does not have NoImplicitPrelude (and hence
<a name="line-170"></a>depends on Prelude).
<a name="line-171"></a>
<a name="line-172"></a>The lookup is only disabled for packages ghc-prim and ghc-bignum, which aren't
<a name="line-173"></a>allowed to contain any Integer literal.
<a name="line-174"></a>
<a name="line-175"></a>
<a name="line-176"></a>Note [Depend on GHC.Tuple]
<a name="line-177"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-178"></a>Similarly, tuple syntax (or ()) creates an implicit dependency on
<a name="line-179"></a>GHC.Tuple, so we use the same rule as for Integer --- see Note [Depend on
<a name="line-180"></a>GHC.Num.Integer] --- to explain this to the build system.  We make GHC.Base
<a name="line-181"></a>depend on GHC.Tuple, and everything else depends on GHC.Base or Prelude.
<a name="line-182"></a>
<a name="line-183"></a>-}</span>
<a name="line-184"></a>
<a name="line-185"></a><span class='hs-cpp'>#if 0</span>
<a name="line-186"></a><a name="Bool"></a><span class='hs-comment'>-- for use when compiling GHC.Base itself doesn't work</span>
<a name="line-187"></a><a name="Bool"></a><span class='hs-keyword'>data</span>  <span class='hs-conid'>Bool</span>  <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>False</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>True</span>
<a name="line-188"></a><a name="Ordering"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Ordering</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EQ</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>GT</span>
<a name="line-189"></a><a name="Char"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Char</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-conid'>Char</span><span class='hs-cpp'>#</span>
<a name="line-190"></a><a name="String"></a><span class='hs-keyword'>type</span>  <span class='hs-conid'>String</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<a name="line-191"></a><a name="Int"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-192"></a><a name="()"></a><span class='hs-keyword'>data</span>  <span class='hs-conid'>()</span>  <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>()</span>
<a name="line-193"></a><a name="%5b%5d"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MkNil</span>
<a name="line-194"></a>
<a name="line-195"></a><a name="not"></a><span class='hs-definition'>not</span> <span class='hs-conid'>True</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-196"></a><a name="&&"></a><span class='hs-layout'>(</span><span class='hs-varop'>&amp;&amp;</span><span class='hs-layout'>)</span> <span class='hs-conid'>True</span> <span class='hs-conid'>True</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-197"></a><a name="otherwise"></a><span class='hs-definition'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-198"></a>
<a name="line-199"></a><a name="build"></a><span class='hs-definition'>build</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"urk"</span>
<a name="line-200"></a><a name="foldr"></a><span class='hs-definition'>foldr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"urk"</span>
<a name="line-201"></a><span class='hs-cpp'>#endif</span>
<a name="line-202"></a>
<a name="line-203"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>6</span> <span class='hs-varop'>&lt;&gt;</span>
<a name="line-204"></a>
<a name="line-205"></a><a name="Semigroup"></a><span class='hs-comment'>-- | The class of semigroups (types with an associative binary operation).</span>
<a name="line-206"></a><a name="Semigroup"></a><span class='hs-comment'>--</span>
<a name="line-207"></a><a name="Semigroup"></a><span class='hs-comment'>-- Instances should satisfy the following:</span>
<a name="line-208"></a><a name="Semigroup"></a><span class='hs-comment'>--</span>
<a name="line-209"></a><a name="Semigroup"></a><span class='hs-comment'>-- [Associativity] @x '&lt;&gt;' (y '&lt;&gt;' z) = (x '&lt;&gt;' y) '&lt;&gt;' z@</span>
<a name="line-210"></a><a name="Semigroup"></a><span class='hs-comment'>--</span>
<a name="line-211"></a><a name="Semigroup"></a><span class='hs-comment'>-- @since 4.9.0.0</span>
<a name="line-212"></a><a name="Semigroup"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<a name="line-213"></a>        <span class='hs-comment'>-- | An associative operation.</span>
<a name="line-214"></a>        <span class='hs-comment'>--</span>
<a name="line-215"></a>        <span class='hs-comment'>-- &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]</span>
<a name="line-216"></a>        <span class='hs-comment'>-- [1,2,3,4,5,6]</span>
<a name="line-217"></a>        <span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-218"></a>
<a name="line-219"></a>        <span class='hs-comment'>-- | Reduce a non-empty list with '&lt;&gt;'</span>
<a name="line-220"></a>        <span class='hs-comment'>--</span>
<a name="line-221"></a>        <span class='hs-comment'>-- The default definition should be sufficient, but this can be</span>
<a name="line-222"></a>        <span class='hs-comment'>-- overridden for efficiency.</span>
<a name="line-223"></a>        <span class='hs-comment'>--</span>
<a name="line-224"></a>        <span class='hs-comment'>-- &gt;&gt;&gt; import Data.List.NonEmpty (NonEmpty (..))</span>
<a name="line-225"></a>        <span class='hs-comment'>-- &gt;&gt;&gt; sconcat $ "Hello" :| [" ", "Haskell", "!"]</span>
<a name="line-226"></a>        <span class='hs-comment'>-- "Hello Haskell!"</span>
<a name="line-227"></a>        <span class='hs-varid'>sconcat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-228"></a>        <span class='hs-varid'>sconcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>as</span> <span class='hs-keyword'>where</span>
<a name="line-229"></a>          <span class='hs-varid'>go</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>go</span> <span class='hs-varid'>c</span> <span class='hs-varid'>cs</span>
<a name="line-230"></a>          <span class='hs-varid'>go</span> <span class='hs-varid'>b</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span>
<a name="line-231"></a>
<a name="line-232"></a>        <span class='hs-comment'>-- | Repeat a value @n@ times.</span>
<a name="line-233"></a>        <span class='hs-comment'>--</span>
<a name="line-234"></a>        <span class='hs-comment'>-- Given that this works on a 'Semigroup' it is allowed to fail if</span>
<a name="line-235"></a>        <span class='hs-comment'>-- you request 0 or fewer repetitions, and the default definition</span>
<a name="line-236"></a>        <span class='hs-comment'>-- will do so.</span>
<a name="line-237"></a>        <span class='hs-comment'>--</span>
<a name="line-238"></a>        <span class='hs-comment'>-- By making this a member of the class, idempotent semigroups</span>
<a name="line-239"></a>        <span class='hs-comment'>-- and monoids can upgrade this to execute in \(\mathcal{O}(1)\) by</span>
<a name="line-240"></a>        <span class='hs-comment'>-- picking @stimes = 'Data.Semigroup.stimesIdempotent'@ or @stimes =</span>
<a name="line-241"></a>        <span class='hs-comment'>-- 'stimesIdempotentMonoid'@ respectively.</span>
<a name="line-242"></a>        <span class='hs-comment'>--</span>
<a name="line-243"></a>        <span class='hs-comment'>-- &gt;&gt;&gt; stimes 4 [1]</span>
<a name="line-244"></a>        <span class='hs-comment'>-- [1,1,1,1]</span>
<a name="line-245"></a>        <span class='hs-varid'>stimes</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integral</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-246"></a>        <span class='hs-varid'>stimes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stimesDefault</span>
<a name="line-247"></a>
<a name="line-248"></a>
<a name="line-249"></a><a name="Monoid"></a><span class='hs-comment'>-- | The class of monoids (types with an associative binary operation that</span>
<a name="line-250"></a><a name="Monoid"></a><span class='hs-comment'>-- has an identity).  Instances should satisfy the following:</span>
<a name="line-251"></a><a name="Monoid"></a><span class='hs-comment'>--</span>
<a name="line-252"></a><a name="Monoid"></a><span class='hs-comment'>-- [Right identity] @x '&lt;&gt;' 'mempty' = x@</span>
<a name="line-253"></a><a name="Monoid"></a><span class='hs-comment'>-- [Left identity]  @'mempty' '&lt;&gt;' x = x@</span>
<a name="line-254"></a><a name="Monoid"></a><span class='hs-comment'>-- [Associativity]  @x '&lt;&gt;' (y '&lt;&gt;' z) = (x '&lt;&gt;' y) '&lt;&gt;' z@ ('Semigroup' law)</span>
<a name="line-255"></a><a name="Monoid"></a><span class='hs-comment'>-- [Concatenation]  @'mconcat' = 'foldr' ('&lt;&gt;') 'mempty'@</span>
<a name="line-256"></a><a name="Monoid"></a><span class='hs-comment'>--</span>
<a name="line-257"></a><a name="Monoid"></a><span class='hs-comment'>-- The method names refer to the monoid of lists under concatenation,</span>
<a name="line-258"></a><a name="Monoid"></a><span class='hs-comment'>-- but there are many other instances.</span>
<a name="line-259"></a><a name="Monoid"></a><span class='hs-comment'>--</span>
<a name="line-260"></a><a name="Monoid"></a><span class='hs-comment'>-- Some types can be viewed as a monoid in more than one way,</span>
<a name="line-261"></a><a name="Monoid"></a><span class='hs-comment'>-- e.g. both addition and multiplication on numbers.</span>
<a name="line-262"></a><a name="Monoid"></a><span class='hs-comment'>-- In such cases we often define @newtype@s and make those instances</span>
<a name="line-263"></a><a name="Monoid"></a><span class='hs-comment'>-- of 'Monoid', e.g. 'Data.Semigroup.Sum' and 'Data.Semigroup.Product'.</span>
<a name="line-264"></a><a name="Monoid"></a><span class='hs-comment'>--</span>
<a name="line-265"></a><a name="Monoid"></a><span class='hs-comment'>-- __NOTE__: 'Semigroup' is a superclass of 'Monoid' since /base-4.11.0.0/.</span>
<a name="line-266"></a><a name="Monoid"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<a name="line-267"></a>        <span class='hs-comment'>-- | Identity of 'mappend'</span>
<a name="line-268"></a>        <span class='hs-comment'>--</span>
<a name="line-269"></a>        <span class='hs-comment'>-- &gt;&gt;&gt; "Hello world" &lt;&gt; mempty</span>
<a name="line-270"></a>        <span class='hs-comment'>-- "Hello world"</span>
<a name="line-271"></a>        <span class='hs-varid'>mempty</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span>
<a name="line-272"></a>
<a name="line-273"></a>        <span class='hs-comment'>-- | An associative operation</span>
<a name="line-274"></a>        <span class='hs-comment'>--</span>
<a name="line-275"></a>        <span class='hs-comment'>-- __NOTE__: This method is redundant and has the default</span>
<a name="line-276"></a>        <span class='hs-comment'>-- implementation @'mappend' = ('&lt;&gt;')@ since /base-4.11.0.0/.</span>
<a name="line-277"></a>        <span class='hs-comment'>-- Should it be implemented manually, since 'mappend' is a synonym for</span>
<a name="line-278"></a>        <span class='hs-comment'>-- ('&lt;&gt;'), it is expected that the two functions are defined the same</span>
<a name="line-279"></a>        <span class='hs-comment'>-- way. In a future GHC release 'mappend' will be removed from 'Monoid'.</span>
<a name="line-280"></a>        <span class='hs-varid'>mappend</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-281"></a>        <span class='hs-varid'>mappend</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span>
<a name="line-282"></a>        <span class='hs-comment'>{-# INLINE mappend #-}</span>
<a name="line-283"></a>
<a name="line-284"></a>        <span class='hs-comment'>-- | Fold a list using the monoid.</span>
<a name="line-285"></a>        <span class='hs-comment'>--</span>
<a name="line-286"></a>        <span class='hs-comment'>-- For most types, the default definition for 'mconcat' will be</span>
<a name="line-287"></a>        <span class='hs-comment'>-- used, but the function is included in the class definition so</span>
<a name="line-288"></a>        <span class='hs-comment'>-- that an optimized version can be provided for specific types.</span>
<a name="line-289"></a>        <span class='hs-comment'>--</span>
<a name="line-290"></a>        <span class='hs-comment'>-- &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]</span>
<a name="line-291"></a>        <span class='hs-comment'>-- "Hello Haskell!"</span>
<a name="line-292"></a>        <span class='hs-varid'>mconcat</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-293"></a>        <span class='hs-varid'>mconcat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>mappend</span> <span class='hs-varid'>mempty</span>
<a name="line-294"></a>        <span class='hs-comment'>{-# INLINE mconcat #-}</span>
<a name="line-295"></a>        <span class='hs-comment'>-- INLINE in the hope of fusion with mconcat's argument (see !4890)</span>
<a name="line-296"></a>
<a name="line-297"></a><a name="instance%20Semigroup%20%5ba%5d"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-298"></a><a name="instance%20Semigroup%20%5ba%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>where</span>
<a name="line-299"></a>        <span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span>
<a name="line-300"></a>        <span class='hs-comment'>{-# INLINE (&lt;&gt;) #-}</span>
<a name="line-301"></a>
<a name="line-302"></a>        <span class='hs-varid'>stimes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stimesList</span>
<a name="line-303"></a>
<a name="line-304"></a><a name="instance%20Monoid%20%5ba%5d"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-305"></a><a name="instance%20Monoid%20%5ba%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>where</span>
<a name="line-306"></a>        <span class='hs-comment'>{-# INLINE mempty #-}</span>
<a name="line-307"></a>        <span class='hs-varid'>mempty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-308"></a>        <span class='hs-comment'>{-# INLINE mconcat #-}</span>
<a name="line-309"></a>        <span class='hs-varid'>mconcat</span> <span class='hs-varid'>xss</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xss</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-keyglyph'>]</span>
<a name="line-310"></a><span class='hs-comment'>-- See Note: [List comprehensions and inlining]</span>
<a name="line-311"></a>
<a name="line-312"></a><span class='hs-comment'>{-
<a name="line-313"></a>Note: [List comprehensions and inlining]
<a name="line-314"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-315"></a>The list monad operations are traditionally described in terms of concatMap:
<a name="line-316"></a>
<a name="line-317"></a>xs &gt;&gt;= f = concatMap f xs
<a name="line-318"></a>
<a name="line-319"></a>Similarly, mconcat for lists is just concat. Here in Base, however, we don't
<a name="line-320"></a>have concatMap, and we'll refrain from adding it here so it won't have to be
<a name="line-321"></a>hidden in imports. Instead, we use GHC's list comprehension desugaring
<a name="line-322"></a>mechanism to define mconcat and the Applicative and Monad instances for lists.
<a name="line-323"></a>We mark them INLINE because the inliner is not generally too keen to inline
<a name="line-324"></a>build forms such as the ones these desugar to without our insistence.  Defining
<a name="line-325"></a>these using list comprehensions instead of foldr has an additional potential
<a name="line-326"></a>benefit, as described in compiler/GHC/HsToCore/ListComp.hs: if optimizations
<a name="line-327"></a>needed to make foldr/build forms efficient are turned off, we'll get reasonably
<a name="line-328"></a>efficient translations anyway.
<a name="line-329"></a>-}</span>
<a name="line-330"></a>
<a name="line-331"></a><a name="instance%20Semigroup%20(NonEmpty%20a)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-332"></a><a name="instance%20Semigroup%20(NonEmpty%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonEmpty</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-333"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-conop'>:|</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-layout'>(</span><span class='hs-keyword'>as</span> <span class='hs-varop'>++</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span>
<a name="line-334"></a>
<a name="line-335"></a><a name="instance%20Semigroup%20(a%20-%3e%20b)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-336"></a><a name="instance%20Semigroup%20(a%20-%3e%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-337"></a>        <span class='hs-varid'>f</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>g</span> <span class='hs-varid'>x</span>
<a name="line-338"></a>        <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>f</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-339"></a>
<a name="line-340"></a><a name="instance%20Monoid%20(a%20-%3e%20b)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-341"></a><a name="instance%20Monoid%20(a%20-%3e%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-342"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-343"></a>
<a name="line-344"></a><a name="instance%20Semigroup%20()"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-345"></a><a name="instance%20Semigroup%20()"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-conid'>()</span> <span class='hs-keyword'>where</span>
<a name="line-346"></a>        <span class='hs-keyword'>_</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<a name="line-347"></a>        <span class='hs-varid'>sconcat</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<a name="line-348"></a>        <span class='hs-varid'>stimes</span>  <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<a name="line-349"></a>
<a name="line-350"></a><a name="instance%20Monoid%20()"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-351"></a><a name="instance%20Monoid%20()"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-conid'>()</span> <span class='hs-keyword'>where</span>
<a name="line-352"></a>        <span class='hs-comment'>-- Should it be strict?</span>
<a name="line-353"></a>        <span class='hs-varid'>mempty</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<a name="line-354"></a>        <span class='hs-varid'>mconcat</span> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<a name="line-355"></a>
<a name="line-356"></a><a name="instance%20Semigroup%20(Solo%20a)"></a><span class='hs-comment'>-- | @since 4.15</span>
<a name="line-357"></a><a name="instance%20Semigroup%20(Solo%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-conid'>Solo</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-358"></a>  <span class='hs-conid'>Solo</span> <span class='hs-varid'>a</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-conid'>Solo</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Solo</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-359"></a>  <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Solo</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Solo</span> <span class='hs-layout'>(</span><span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-360"></a>
<a name="line-361"></a><a name="instance%20Monoid%20(Solo%20a)"></a><span class='hs-comment'>-- | @since 4.15</span>
<a name="line-362"></a><a name="instance%20Monoid%20(Solo%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-conid'>Solo</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-363"></a>  <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Solo</span> <span class='hs-varid'>mempty</span>
<a name="line-364"></a>
<a name="line-365"></a><a name="instance%20Semigroup%20(a,%20b)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-366"></a><a name="instance%20Semigroup%20(a,%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-367"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>b'</span><span class='hs-layout'>)</span>
<a name="line-368"></a>        <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-369"></a>
<a name="line-370"></a><a name="instance%20Monoid%20(a,b)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-371"></a><a name="instance%20Monoid%20(a,b)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-372"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>)</span>
<a name="line-373"></a>
<a name="line-374"></a><a name="instance%20Semigroup%20(a,%20b,%20c)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-375"></a><a name="instance%20Semigroup%20(a,%20b,%20c)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-376"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b'</span><span class='hs-layout'>,</span><span class='hs-varid'>c'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>b'</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>c'</span><span class='hs-layout'>)</span>
<a name="line-377"></a>        <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-378"></a>
<a name="line-379"></a><a name="instance%20Monoid%20(a,b,c)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-380"></a><a name="instance%20Monoid%20(a,b,c)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-381"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>)</span>
<a name="line-382"></a>
<a name="line-383"></a><a name="instance%20Semigroup%20(a,%20b,%20c,%20d)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-384"></a><a name="instance%20Semigroup%20(a,%20b,%20c,%20d)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span>
<a name="line-385"></a>         <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-386"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b'</span><span class='hs-layout'>,</span><span class='hs-varid'>c'</span><span class='hs-layout'>,</span><span class='hs-varid'>d'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>b'</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>c'</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>d'</span><span class='hs-layout'>)</span>
<a name="line-387"></a>        <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span>
<a name="line-388"></a>
<a name="line-389"></a><a name="instance%20Monoid%20(a,b,c,d)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-390"></a><a name="instance%20Monoid%20(a,b,c,d)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-391"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>)</span>
<a name="line-392"></a>
<a name="line-393"></a><a name="instance%20Semigroup%20(a,%20b,%20c,%20d,%20e)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-394"></a><a name="instance%20Semigroup%20(a,%20b,%20c,%20d,%20e)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-395"></a>         <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-396"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b'</span><span class='hs-layout'>,</span><span class='hs-varid'>c'</span><span class='hs-layout'>,</span><span class='hs-varid'>d'</span><span class='hs-layout'>,</span><span class='hs-varid'>e'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>b'</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>c'</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>d'</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>e'</span><span class='hs-layout'>)</span>
<a name="line-397"></a>        <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-398"></a>            <span class='hs-layout'>(</span><span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-399"></a>
<a name="line-400"></a><a name="instance%20Monoid%20(a,b,c,d,e)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-401"></a><a name="instance%20Monoid%20(a,b,c,d,e)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<a name="line-402"></a>                <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-403"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>)</span>
<a name="line-404"></a>
<a name="line-405"></a>
<a name="line-406"></a><a name="instance%20Semigroup%20Ordering"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-407"></a><a name="instance%20Semigroup%20Ordering"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-conid'>Ordering</span> <span class='hs-keyword'>where</span>
<a name="line-408"></a>    <span class='hs-conid'>LT</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span>
<a name="line-409"></a>    <span class='hs-conid'>EQ</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>y</span>
<a name="line-410"></a>    <span class='hs-conid'>GT</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-411"></a>
<a name="line-412"></a>    <span class='hs-varid'>stimes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stimesIdempotentMonoid</span>
<a name="line-413"></a>
<a name="line-414"></a><a name="instance%20Monoid%20Ordering"></a><span class='hs-comment'>-- lexicographical ordering</span>
<a name="line-415"></a><a name="instance%20Monoid%20Ordering"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-416"></a><a name="instance%20Monoid%20Ordering"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-conid'>Ordering</span> <span class='hs-keyword'>where</span>
<a name="line-417"></a>    <span class='hs-varid'>mempty</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EQ</span>
<a name="line-418"></a>
<a name="line-419"></a><a name="instance%20Semigroup%20(Maybe%20a)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-420"></a><a name="instance%20Semigroup%20(Maybe%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-421"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>b</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span>
<a name="line-422"></a>    <span class='hs-varid'>a</span>       <span class='hs-varop'>&lt;&gt;</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span>
<a name="line-423"></a>    <span class='hs-conid'>Just</span> <span class='hs-varid'>a</span>  <span class='hs-varop'>&lt;&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>b</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-424"></a>
<a name="line-425"></a>    <span class='hs-varid'>stimes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stimesMaybe</span>
<a name="line-426"></a>
<a name="line-427"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- | Lift a semigroup into 'Maybe' forming a 'Monoid' according to</span>
<a name="line-428"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- &lt;<a href="http://en.wikipedia.org/wiki/Monoid">http://en.wikipedia.org/wiki/Monoid</a>&gt;: \"Any semigroup @S@ may be</span>
<a name="line-429"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- turned into a monoid simply by adjoining an element @e@ not in @S@</span>
<a name="line-430"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- and defining @e*e = e@ and @e*s = s = s*e@ for all @s ∈ S@.\"</span>
<a name="line-431"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>--</span>
<a name="line-432"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- /Since 4.11.0/: constraint on inner @a@ value generalised from</span>
<a name="line-433"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- 'Monoid' to 'Semigroup'.</span>
<a name="line-434"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>--</span>
<a name="line-435"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- @since 2.01</span>
<a name="line-436"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-437"></a>    <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-438"></a>
<a name="line-439"></a><a name="instance%20Applicative%20Solo"></a><span class='hs-comment'>-- | @since 4.15</span>
<a name="line-440"></a><a name="instance%20Applicative%20Solo"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>Solo</span> <span class='hs-keyword'>where</span>
<a name="line-441"></a>  <span class='hs-varid'>pure</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Solo</span>
<a name="line-442"></a>
<a name="line-443"></a>  <span class='hs-comment'>-- Note: we really want to match strictly here. This lets us write,</span>
<a name="line-444"></a>  <span class='hs-comment'>-- for example,</span>
<a name="line-445"></a>  <span class='hs-comment'>--</span>
<a name="line-446"></a>  <span class='hs-comment'>-- forceSpine :: Foldable f =&gt; f a -&gt; ()</span>
<a name="line-447"></a>  <span class='hs-comment'>-- forceSpine xs</span>
<a name="line-448"></a>  <span class='hs-comment'>--   | Solo r &lt;- traverse_ Solo xs</span>
<a name="line-449"></a>  <span class='hs-comment'>--   = r</span>
<a name="line-450"></a>  <span class='hs-conid'>Solo</span> <span class='hs-varid'>f</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-conid'>Solo</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Solo</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-451"></a>  <span class='hs-varid'>liftA2</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Solo</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Solo</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Solo</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-452"></a>
<a name="line-453"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>-- | For tuples, the 'Monoid' constraint on @a@ determines</span>
<a name="line-454"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>-- how the first values merge.</span>
<a name="line-455"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>-- For example, 'String's concatenate:</span>
<a name="line-456"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>--</span>
<a name="line-457"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>-- &gt; ("hello ", (+15)) &lt;*&gt; ("world!", 2002)</span>
<a name="line-458"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>-- &gt; ("hello world!",2017)</span>
<a name="line-459"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>--</span>
<a name="line-460"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>-- @since 2.01</span>
<a name="line-461"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,)</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-462"></a>    <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-463"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>u</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-464"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-465"></a>
<a name="line-466"></a><a name="instance%20Monad%20Solo"></a><span class='hs-comment'>-- | @since 4.15</span>
<a name="line-467"></a><a name="instance%20Monad%20Solo"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monad</span> <span class='hs-conid'>Solo</span> <span class='hs-keyword'>where</span>
<a name="line-468"></a>  <span class='hs-conid'>Solo</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span>
<a name="line-469"></a>
<a name="line-470"></a><a name="instance%20Monad%20((,)%20a)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-471"></a><a name="instance%20Monad%20((,)%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,)</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-472"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>u</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>k</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-473"></a>
<a name="line-474"></a><a name="instance%20Functor%20((,,)%20a%20b)"></a><span class='hs-comment'>-- | @since 4.14.0.0</span>
<a name="line-475"></a><a name="instance%20Functor%20((,,)%20a%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,,)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-476"></a>    <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-477"></a>
<a name="line-478"></a><a name="instance%20Applicative%20((,,)%20a%20b)"></a><span class='hs-comment'>-- | @since 4.14.0.0</span>
<a name="line-479"></a><a name="instance%20Applicative%20((,,)%20a%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,,)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-480"></a>    <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-481"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b'</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>b'</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-482"></a>
<a name="line-483"></a><a name="instance%20Monad%20((,,)%20a%20b)"></a><span class='hs-comment'>-- | @since 4.14.0.0</span>
<a name="line-484"></a><a name="instance%20Monad%20((,,)%20a%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,,)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-485"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>u</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>k</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-varid'>u'</span><span class='hs-layout'>,</span> <span class='hs-varid'>v'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>u'</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>v'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-486"></a>
<a name="line-487"></a><a name="instance%20Functor%20((,,,)%20a%20b%20c)"></a><span class='hs-comment'>-- | @since 4.14.0.0</span>
<a name="line-488"></a><a name="instance%20Functor%20((,,,)%20a%20b%20c)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,,,)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-489"></a>    <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span>
<a name="line-490"></a>
<a name="line-491"></a><a name="instance%20Applicative%20((,,,)%20a%20b%20c)"></a><span class='hs-comment'>-- | @since 4.14.0.0</span>
<a name="line-492"></a><a name="instance%20Applicative%20((,,,)%20a%20b%20c)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,,,)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-493"></a>    <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-494"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b'</span><span class='hs-layout'>,</span> <span class='hs-varid'>c'</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>b'</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>c'</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-495"></a>
<a name="line-496"></a><a name="instance%20Monad%20((,,,)%20a%20b%20c)"></a><span class='hs-comment'>-- | @since 4.14.0.0</span>
<a name="line-497"></a><a name="instance%20Monad%20((,,,)%20a%20b%20c)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,,,)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-498"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>u</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>w</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>k</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-varid'>u'</span><span class='hs-layout'>,</span> <span class='hs-varid'>v'</span><span class='hs-layout'>,</span> <span class='hs-varid'>w'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>u'</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>v'</span><span class='hs-layout'>,</span> <span class='hs-varid'>w</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>w'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-499"></a>
<a name="line-500"></a><a name="instance%20Semigroup%20(IO%20a)"></a><span class='hs-comment'>-- | @since 4.10.0.0</span>
<a name="line-501"></a><a name="instance%20Semigroup%20(IO%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-502"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span>
<a name="line-503"></a>
<a name="line-504"></a><a name="instance%20Monoid%20(IO%20a)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-505"></a><a name="instance%20Monoid%20(IO%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-506"></a>    <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>mempty</span>
<a name="line-507"></a>
<a name="line-508"></a><span class='hs-comment'>{- | A type @f@ is a Functor if it provides a function @fmap@ which, given any types @a@ and @b@
<a name="line-509"></a>lets you apply any function from @(a -&gt; b)@ to turn an @f a@ into an @f b@, preserving the
<a name="line-510"></a>structure of @f@. Furthermore @f@ needs to adhere to the following:
<a name="line-511"></a>
<a name="line-512"></a>[Identity]    @'fmap' 'id' == 'id'@
<a name="line-513"></a>[Composition] @'fmap' (f . g) == 'fmap' f . 'fmap' g@
<a name="line-514"></a>
<a name="line-515"></a>Note, that the second law follows from the free theorem of the type 'fmap' and
<a name="line-516"></a>the first law, so you need only check that the former condition holds.
<a name="line-517"></a>-}</span>
<a name="line-518"></a>
<a name="line-519"></a><a name="Functor"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Functor</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<a name="line-520"></a>    <span class='hs-comment'>-- | 'fmap' is used to apply a function of type @(a -&gt; b)@ to a value of type @f a@,</span>
<a name="line-521"></a>    <span class='hs-comment'>-- where f is a functor, to produce a value of type @f b@.</span>
<a name="line-522"></a>    <span class='hs-comment'>-- Note that for any type constructor with more than one parameter (e.g., `Either`),</span>
<a name="line-523"></a>    <span class='hs-comment'>-- only the last type parameter can be modified with `fmap` (e.g., `b` in `Either a b`).</span>
<a name="line-524"></a>    <span class='hs-comment'>--</span>
<a name="line-525"></a>    <span class='hs-comment'>-- Some type constructors with two parameters or more have a @'Data.Bifunctor'@ instance that allows</span>
<a name="line-526"></a>    <span class='hs-comment'>-- both the last and the penultimate parameters to be mapped over.</span>
<a name="line-527"></a>    <span class='hs-comment'>--</span>
<a name="line-528"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-529"></a>    <span class='hs-comment'>--</span>
<a name="line-530"></a>    <span class='hs-comment'>-- Convert from a @'Data.Maybe.Maybe' Int@ to a @Maybe String@</span>
<a name="line-531"></a>    <span class='hs-comment'>-- using 'Prelude.show':</span>
<a name="line-532"></a>    <span class='hs-comment'>--</span>
<a name="line-533"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; fmap show Nothing</span>
<a name="line-534"></a>    <span class='hs-comment'>-- Nothing</span>
<a name="line-535"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; fmap show (Just 3)</span>
<a name="line-536"></a>    <span class='hs-comment'>-- Just "3"</span>
<a name="line-537"></a>    <span class='hs-comment'>--</span>
<a name="line-538"></a>    <span class='hs-comment'>-- Convert from an @'Data.Either.Either' Int Int@ to an</span>
<a name="line-539"></a>    <span class='hs-comment'>-- @Either Int String@ using 'Prelude.show':</span>
<a name="line-540"></a>    <span class='hs-comment'>--</span>
<a name="line-541"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; fmap show (Left 17)</span>
<a name="line-542"></a>    <span class='hs-comment'>-- Left 17</span>
<a name="line-543"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; fmap show (Right 17)</span>
<a name="line-544"></a>    <span class='hs-comment'>-- Right "17"</span>
<a name="line-545"></a>    <span class='hs-comment'>--</span>
<a name="line-546"></a>    <span class='hs-comment'>-- Double each element of a list:</span>
<a name="line-547"></a>    <span class='hs-comment'>--</span>
<a name="line-548"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; fmap (*2) [1,2,3]</span>
<a name="line-549"></a>    <span class='hs-comment'>-- [2,4,6]</span>
<a name="line-550"></a>    <span class='hs-comment'>--</span>
<a name="line-551"></a>    <span class='hs-comment'>-- Apply 'Prelude.even' to the second element of a pair:</span>
<a name="line-552"></a>    <span class='hs-comment'>--</span>
<a name="line-553"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; fmap even (2,2)</span>
<a name="line-554"></a>    <span class='hs-comment'>-- (2,True)</span>
<a name="line-555"></a>    <span class='hs-comment'>--</span>
<a name="line-556"></a>    <span class='hs-comment'>-- It may seem surprising that the function is only applied to the last element of the tuple</span>
<a name="line-557"></a>    <span class='hs-comment'>-- compared to the list example above which applies it to every element in the list.</span>
<a name="line-558"></a>    <span class='hs-comment'>-- To understand, remember that tuples are type constructors with multiple type parameters:</span>
<a name="line-559"></a>    <span class='hs-comment'>-- a tuple of 3 elements @(a,b,c)@ can also be written @(,,) a b c@ and its @Functor@ instance</span>
<a name="line-560"></a>    <span class='hs-comment'>-- is defined for @Functor ((,,) a b)@ (i.e., only the third parameter is free to be mapped over</span>
<a name="line-561"></a>    <span class='hs-comment'>-- with @fmap@).</span>
<a name="line-562"></a>    <span class='hs-comment'>--</span>
<a name="line-563"></a>    <span class='hs-comment'>-- It explains why @fmap@ can be used with tuples containing values of different types as in the</span>
<a name="line-564"></a>    <span class='hs-comment'>-- following example:</span>
<a name="line-565"></a>    <span class='hs-comment'>--</span>
<a name="line-566"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; fmap even ("hello", 1.0, 4)</span>
<a name="line-567"></a>    <span class='hs-comment'>-- ("hello",1.0,True)</span>
<a name="line-568"></a>
<a name="line-569"></a>    <span class='hs-varid'>fmap</span>        <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-570"></a>
<a name="line-571"></a>    <span class='hs-comment'>-- | Replace all locations in the input with the same value.</span>
<a name="line-572"></a>    <span class='hs-comment'>-- The default definition is @'fmap' . 'const'@, but this may be</span>
<a name="line-573"></a>    <span class='hs-comment'>-- overridden with a more efficient version.</span>
<a name="line-574"></a>    <span class='hs-comment'>--</span>
<a name="line-575"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;$</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-576"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;$</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>fmap</span> <span class='hs-varop'>.</span> <span class='hs-varid'>const</span>
<a name="line-577"></a>
<a name="line-578"></a><span class='hs-comment'>-- | A functor with application, providing operations to</span>
<a name="line-579"></a><span class='hs-comment'>--</span>
<a name="line-580"></a><span class='hs-comment'>-- * embed pure expressions ('pure'), and</span>
<a name="line-581"></a><span class='hs-comment'>--</span>
<a name="line-582"></a><span class='hs-comment'>-- * sequence computations and combine their results ('&lt;*&gt;' and 'liftA2').</span>
<a name="line-583"></a><span class='hs-comment'>--</span>
<a name="line-584"></a><span class='hs-comment'>-- A minimal complete definition must include implementations of 'pure'</span>
<a name="line-585"></a><span class='hs-comment'>-- and of either '&lt;*&gt;' or 'liftA2'. If it defines both, then they must behave</span>
<a name="line-586"></a><span class='hs-comment'>-- the same as their default definitions:</span>
<a name="line-587"></a><span class='hs-comment'>--</span>
<a name="line-588"></a><span class='hs-comment'>--      @('&lt;*&gt;') = 'liftA2' 'id'@</span>
<a name="line-589"></a><span class='hs-comment'>--</span>
<a name="line-590"></a><span class='hs-comment'>--      @'liftA2' f x y = f 'Prelude.&lt;$&gt;' x '&lt;*&gt;' y@</span>
<a name="line-591"></a><span class='hs-comment'>--</span>
<a name="line-592"></a><span class='hs-comment'>-- Further, any definition must satisfy the following:</span>
<a name="line-593"></a><span class='hs-comment'>--</span>
<a name="line-594"></a><span class='hs-comment'>-- [Identity]</span>
<a name="line-595"></a><span class='hs-comment'>--</span>
<a name="line-596"></a><span class='hs-comment'>--      @'pure' 'id' '&lt;*&gt;' v = v@</span>
<a name="line-597"></a><span class='hs-comment'>--</span>
<a name="line-598"></a><span class='hs-comment'>-- [Composition]</span>
<a name="line-599"></a><span class='hs-comment'>--</span>
<a name="line-600"></a><span class='hs-comment'>--      @'pure' (.) '&lt;*&gt;' u '&lt;*&gt;' v '&lt;*&gt;' w = u '&lt;*&gt;' (v '&lt;*&gt;' w)@</span>
<a name="line-601"></a><span class='hs-comment'>--</span>
<a name="line-602"></a><span class='hs-comment'>-- [Homomorphism]</span>
<a name="line-603"></a><span class='hs-comment'>--</span>
<a name="line-604"></a><span class='hs-comment'>--      @'pure' f '&lt;*&gt;' 'pure' x = 'pure' (f x)@</span>
<a name="line-605"></a><span class='hs-comment'>--</span>
<a name="line-606"></a><span class='hs-comment'>-- [Interchange]</span>
<a name="line-607"></a><span class='hs-comment'>--</span>
<a name="line-608"></a><span class='hs-comment'>--      @u '&lt;*&gt;' 'pure' y = 'pure' ('$' y) '&lt;*&gt;' u@</span>
<a name="line-609"></a><span class='hs-comment'>--</span>
<a name="line-610"></a><span class='hs-comment'>--</span>
<a name="line-611"></a><span class='hs-comment'>-- The other methods have the following default definitions, which may</span>
<a name="line-612"></a><span class='hs-comment'>-- be overridden with equivalent specialized implementations:</span>
<a name="line-613"></a><span class='hs-comment'>--</span>
<a name="line-614"></a><span class='hs-comment'>--   * @u '*&gt;' v = ('id' '&lt;$' u) '&lt;*&gt;' v@</span>
<a name="line-615"></a><span class='hs-comment'>--</span>
<a name="line-616"></a><span class='hs-comment'>--   * @u '&lt;*' v = 'liftA2' 'const' u v@</span>
<a name="line-617"></a><span class='hs-comment'>--</span>
<a name="line-618"></a><span class='hs-comment'>-- As a consequence of these laws, the 'Functor' instance for @f@ will satisfy</span>
<a name="line-619"></a><span class='hs-comment'>--</span>
<a name="line-620"></a><span class='hs-comment'>--   * @'fmap' f x = 'pure' f '&lt;*&gt;' x@</span>
<a name="line-621"></a><span class='hs-comment'>--</span>
<a name="line-622"></a><span class='hs-comment'>--</span>
<a name="line-623"></a><span class='hs-comment'>-- It may be useful to note that supposing</span>
<a name="line-624"></a><span class='hs-comment'>--</span>
<a name="line-625"></a><span class='hs-comment'>--      @forall x y. p (q x y) = f x . g y@</span>
<a name="line-626"></a><span class='hs-comment'>--</span>
<a name="line-627"></a><span class='hs-comment'>-- it follows from the above that</span>
<a name="line-628"></a><span class='hs-comment'>--</span>
<a name="line-629"></a><span class='hs-comment'>--      @'liftA2' p ('liftA2' q u v) = 'liftA2' f u . 'liftA2' g v@</span>
<a name="line-630"></a><span class='hs-comment'>--</span>
<a name="line-631"></a><span class='hs-comment'>--</span>
<a name="line-632"></a><span class='hs-comment'>-- If @f@ is also a 'Monad', it should satisfy</span>
<a name="line-633"></a><span class='hs-comment'>--</span>
<a name="line-634"></a><span class='hs-comment'>--   * @'pure' = 'return'@</span>
<a name="line-635"></a><span class='hs-comment'>--</span>
<a name="line-636"></a><span class='hs-comment'>--   * @m1 '&lt;*&gt;' m2 = m1 '&gt;&gt;=' (\x1 -&gt; m2 '&gt;&gt;=' (\x2 -&gt; 'return' (x1 x2)))@</span>
<a name="line-637"></a><span class='hs-comment'>--</span>
<a name="line-638"></a><span class='hs-comment'>--   * @('*&gt;') = ('&gt;&gt;')@</span>
<a name="line-639"></a><span class='hs-comment'>--</span>
<a name="line-640"></a><span class='hs-comment'>-- (which implies that 'pure' and '&lt;*&gt;' satisfy the applicative functor laws).</span>
<a name="line-641"></a>
<a name="line-642"></a><a name="Applicative"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Functor</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<a name="line-643"></a>    <span class='hs-comment'>{-# MINIMAL pure, ((&lt;*&gt;) | liftA2) #-}</span>
<a name="line-644"></a>    <span class='hs-comment'>-- | Lift a value.</span>
<a name="line-645"></a>    <span class='hs-varid'>pure</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-646"></a>
<a name="line-647"></a>    <span class='hs-comment'>-- | Sequential application.</span>
<a name="line-648"></a>    <span class='hs-comment'>--</span>
<a name="line-649"></a>    <span class='hs-comment'>-- A few functors support an implementation of '&lt;*&gt;' that is more</span>
<a name="line-650"></a>    <span class='hs-comment'>-- efficient than the default one.</span>
<a name="line-651"></a>    <span class='hs-comment'>--</span>
<a name="line-652"></a>    <span class='hs-comment'>-- ==== __Example__</span>
<a name="line-653"></a>    <span class='hs-comment'>-- Used in combination with @('&lt;$&gt;')@, @('&lt;*&gt;')@ can be used to build a record.</span>
<a name="line-654"></a>    <span class='hs-comment'>--</span>
<a name="line-655"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}</span>
<a name="line-656"></a>    <span class='hs-comment'>--</span>
<a name="line-657"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo</span>
<a name="line-658"></a>    <span class='hs-comment'>--</span>
<a name="line-659"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar</span>
<a name="line-660"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz</span>
<a name="line-661"></a>    <span class='hs-comment'>--</span>
<a name="line-662"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState</span>
<a name="line-663"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz</span>
<a name="line-664"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-665"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-varid'>id</span>
<a name="line-666"></a>
<a name="line-667"></a>    <span class='hs-comment'>-- | Lift a binary function to actions.</span>
<a name="line-668"></a>    <span class='hs-comment'>--</span>
<a name="line-669"></a>    <span class='hs-comment'>-- Some functors support an implementation of 'liftA2' that is more</span>
<a name="line-670"></a>    <span class='hs-comment'>-- efficient than the default one. In particular, if 'fmap' is an</span>
<a name="line-671"></a>    <span class='hs-comment'>-- expensive operation, it is likely better to use 'liftA2' than to</span>
<a name="line-672"></a>    <span class='hs-comment'>-- 'fmap' over the structure and then use '&lt;*&gt;'.</span>
<a name="line-673"></a>    <span class='hs-comment'>--</span>
<a name="line-674"></a>    <span class='hs-comment'>-- This became a typeclass method in 4.10.0.0. Prior to that, it was</span>
<a name="line-675"></a>    <span class='hs-comment'>-- a function defined in terms of '&lt;*&gt;' and 'fmap'.</span>
<a name="line-676"></a>    <span class='hs-comment'>--</span>
<a name="line-677"></a>    <span class='hs-comment'>-- ==== __Example__</span>
<a name="line-678"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)</span>
<a name="line-679"></a>    <span class='hs-comment'>-- Just (3,5)</span>
<a name="line-680"></a>
<a name="line-681"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>c</span>
<a name="line-682"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-683"></a>
<a name="line-684"></a>    <span class='hs-comment'>-- | Sequence actions, discarding the value of the first argument.</span>
<a name="line-685"></a>    <span class='hs-comment'>--</span>
<a name="line-686"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-687"></a>    <span class='hs-comment'>-- If used in conjunction with the Applicative instance for 'Maybe',</span>
<a name="line-688"></a>    <span class='hs-comment'>-- you can chain Maybe computations, with a possible "early return"</span>
<a name="line-689"></a>    <span class='hs-comment'>-- in case of 'Nothing'.</span>
<a name="line-690"></a>    <span class='hs-comment'>--</span>
<a name="line-691"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; Just 2 *&gt; Just 3</span>
<a name="line-692"></a>    <span class='hs-comment'>-- Just 3</span>
<a name="line-693"></a>    <span class='hs-comment'>--</span>
<a name="line-694"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; Nothing *&gt; Just 3</span>
<a name="line-695"></a>    <span class='hs-comment'>-- Nothing</span>
<a name="line-696"></a>    <span class='hs-comment'>--</span>
<a name="line-697"></a>    <span class='hs-comment'>-- Of course a more interesting use case would be to have effectful</span>
<a name="line-698"></a>    <span class='hs-comment'>-- computations instead of just returning pure values.</span>
<a name="line-699"></a>    <span class='hs-comment'>--</span>
<a name="line-700"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; import Data.Char</span>
<a name="line-701"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; import Text.ParserCombinators.ReadP</span>
<a name="line-702"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof</span>
<a name="line-703"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; readP_to_S p "my name is Simon"</span>
<a name="line-704"></a>    <span class='hs-comment'>-- [("Simon","")]</span>
<a name="line-705"></a>
<a name="line-706"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-707"></a>    <span class='hs-varid'>a1</span> <span class='hs-varop'>*&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span> <span class='hs-varop'>&lt;$</span> <span class='hs-varid'>a1</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>a2</span>
<a name="line-708"></a>
<a name="line-709"></a>    <span class='hs-comment'>-- This is essentially the same as liftA2 (flip const), but if the</span>
<a name="line-710"></a>    <span class='hs-comment'>-- Functor instance has an optimized (&lt;$), it may be better to use</span>
<a name="line-711"></a>    <span class='hs-comment'>-- that instead. Before liftA2 became a method, this definition</span>
<a name="line-712"></a>    <span class='hs-comment'>-- was strictly better, but now it depends on the functor. For a</span>
<a name="line-713"></a>    <span class='hs-comment'>-- functor supporting a sharing-enhancing (&lt;$), this definition</span>
<a name="line-714"></a>    <span class='hs-comment'>-- may reduce allocation by preventing a1 from ever being fully</span>
<a name="line-715"></a>    <span class='hs-comment'>-- realized. In an implementation with a boring (&lt;$) but an optimizing</span>
<a name="line-716"></a>    <span class='hs-comment'>-- liftA2, it would likely be better to define (*&gt;) using liftA2.</span>
<a name="line-717"></a>
<a name="line-718"></a>    <span class='hs-comment'>-- | Sequence actions, discarding the value of the second argument.</span>
<a name="line-719"></a>    <span class='hs-comment'>--</span>
<a name="line-720"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-721"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-varid'>const</span>
<a name="line-722"></a>
<a name="line-723"></a><a name="%3c**%3e"></a><span class='hs-comment'>-- | A variant of '&lt;*&gt;' with the arguments reversed.</span>
<a name="line-724"></a><span class='hs-comment'>--</span>
<a name="line-725"></a><span class='hs-layout'>(</span><span class='hs-varop'>&lt;**&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-726"></a><span class='hs-layout'>(</span><span class='hs-varop'>&lt;**&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-727"></a><span class='hs-comment'>-- Don't use $ here, see the note at the top of the page</span>
<a name="line-728"></a>
<a name="line-729"></a><span class='hs-comment'>-- | Lift a function to actions.</span>
<a name="line-730"></a><span class='hs-comment'>-- Equivalent to Functor's `fmap` but implemented using only `Applicative`'s methods:</span>
<a name="line-731"></a><span class='hs-comment'>-- `liftA f a = pure f &lt;*&gt; a`</span>
<a name="line-732"></a><span class='hs-comment'>--</span>
<a name="line-733"></a><span class='hs-comment'>-- As such this function may be used to implement a `Functor` instance from an `Applicative` one.</span>
<a name="line-734"></a>
<a name="line-735"></a><span class='hs-comment'>--</span>
<a name="line-736"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-737"></a><span class='hs-comment'>-- Using the Applicative instance for Lists:</span>
<a name="line-738"></a><span class='hs-comment'>--</span>
<a name="line-739"></a><span class='hs-comment'>-- &gt;&gt;&gt; liftA (+1) [1, 2]</span>
<a name="line-740"></a><span class='hs-comment'>-- [2,3]</span>
<a name="line-741"></a><span class='hs-comment'>--</span>
<a name="line-742"></a><span class='hs-comment'>-- Or the Applicative instance for 'Maybe'</span>
<a name="line-743"></a><span class='hs-comment'>--</span>
<a name="line-744"></a><span class='hs-comment'>-- &gt;&gt;&gt; liftA (+1) (Just 3)</span>
<a name="line-745"></a><span class='hs-comment'>-- Just 4</span>
<a name="line-746"></a>
<a name="line-747"></a><a name="liftA"></a><span class='hs-definition'>liftA</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-748"></a><span class='hs-definition'>liftA</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>f</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>a</span>
<a name="line-749"></a><span class='hs-comment'>-- Caution: since this may be used for `fmap`, we can't use the obvious</span>
<a name="line-750"></a><span class='hs-comment'>-- definition of liftA = fmap.</span>
<a name="line-751"></a>
<a name="line-752"></a><span class='hs-comment'>-- | Lift a ternary function to actions.</span>
<a name="line-753"></a>
<a name="line-754"></a><a name="liftA3"></a><span class='hs-definition'>liftA3</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>d</span>
<a name="line-755"></a><span class='hs-definition'>liftA3</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>c</span>
<a name="line-756"></a>
<a name="line-757"></a>
<a name="line-758"></a><span class='hs-comment'>{-# INLINABLE liftA #-}</span>
<a name="line-759"></a><span class='hs-comment'>{-# SPECIALISE liftA :: (a1-&gt;r) -&gt; IO a1 -&gt; IO r #-}</span>
<a name="line-760"></a><span class='hs-comment'>{-# SPECIALISE liftA :: (a1-&gt;r) -&gt; Maybe a1 -&gt; Maybe r #-}</span>
<a name="line-761"></a><span class='hs-comment'>{-# INLINABLE liftA3 #-}</span>
<a name="line-762"></a><span class='hs-comment'>{-# SPECIALISE liftA3 :: (a1-&gt;a2-&gt;a3-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO a3 -&gt; IO r #-}</span>
<a name="line-763"></a><span class='hs-comment'>{-# SPECIALISE liftA3 :: (a1-&gt;a2-&gt;a3-&gt;r) -&gt;
<a name="line-764"></a>                                Maybe a1 -&gt; Maybe a2 -&gt; Maybe a3 -&gt; Maybe r #-}</span>
<a name="line-765"></a>
<a name="line-766"></a><a name="join"></a><span class='hs-comment'>-- | The 'join' function is the conventional monad join operator. It</span>
<a name="line-767"></a><span class='hs-comment'>-- is used to remove one level of monadic structure, projecting its</span>
<a name="line-768"></a><span class='hs-comment'>-- bound argument into the outer level.</span>
<a name="line-769"></a><span class='hs-comment'>--</span>
<a name="line-770"></a><span class='hs-comment'>--</span>
<a name="line-771"></a><span class='hs-comment'>-- \'@'join' bss@\' can be understood as the @do@ expression</span>
<a name="line-772"></a><span class='hs-comment'>--</span>
<a name="line-773"></a><span class='hs-comment'>-- @</span>
<a name="line-774"></a><span class='hs-comment'>-- do bs &lt;- bss</span>
<a name="line-775"></a><span class='hs-comment'>--    bs</span>
<a name="line-776"></a><span class='hs-comment'>-- @</span>
<a name="line-777"></a><span class='hs-comment'>--</span>
<a name="line-778"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-779"></a><span class='hs-comment'>--</span>
<a name="line-780"></a><span class='hs-comment'>-- A common use of 'join' is to run an 'IO' computation returned from</span>
<a name="line-781"></a><span class='hs-comment'>-- an 'GHC.Conc.STM' transaction, since 'GHC.Conc.STM' transactions</span>
<a name="line-782"></a><span class='hs-comment'>-- can't perform 'IO' directly. Recall that</span>
<a name="line-783"></a><span class='hs-comment'>--</span>
<a name="line-784"></a><span class='hs-comment'>-- @</span>
<a name="line-785"></a><span class='hs-comment'>-- 'GHC.Conc.atomically' :: STM a -&gt; IO a</span>
<a name="line-786"></a><span class='hs-comment'>-- @</span>
<a name="line-787"></a><span class='hs-comment'>--</span>
<a name="line-788"></a><span class='hs-comment'>-- is used to run 'GHC.Conc.STM' transactions atomically. So, by</span>
<a name="line-789"></a><span class='hs-comment'>-- specializing the types of 'GHC.Conc.atomically' and 'join' to</span>
<a name="line-790"></a><span class='hs-comment'>--</span>
<a name="line-791"></a><span class='hs-comment'>-- @</span>
<a name="line-792"></a><span class='hs-comment'>-- 'GHC.Conc.atomically' :: STM (IO b) -&gt; IO (IO b)</span>
<a name="line-793"></a><span class='hs-comment'>-- 'join'       :: IO (IO b)  -&gt; IO b</span>
<a name="line-794"></a><span class='hs-comment'>-- @</span>
<a name="line-795"></a><span class='hs-comment'>--</span>
<a name="line-796"></a><span class='hs-comment'>-- we can compose them as</span>
<a name="line-797"></a><span class='hs-comment'>--</span>
<a name="line-798"></a><span class='hs-comment'>-- @</span>
<a name="line-799"></a><span class='hs-comment'>-- 'join' . 'GHC.Conc.atomically' :: STM (IO b) -&gt; IO b</span>
<a name="line-800"></a><span class='hs-comment'>-- @</span>
<a name="line-801"></a><span class='hs-comment'>--</span>
<a name="line-802"></a><span class='hs-comment'>-- to run an 'GHC.Conc.STM' transaction and the 'IO' action it</span>
<a name="line-803"></a><span class='hs-comment'>-- returns.</span>
<a name="line-804"></a><span class='hs-definition'>join</span>              <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-805"></a><span class='hs-definition'>join</span> <span class='hs-varid'>x</span>            <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>id</span>
<a name="line-806"></a>
<a name="line-807"></a><a name="Monad"></a><span class='hs-comment'>{- | The 'Monad' class defines the basic operations over a /monad/,
<a name="line-808"></a>a concept from a branch of mathematics known as /category theory/.
<a name="line-809"></a>From the perspective of a Haskell programmer, however, it is best to
<a name="line-810"></a>think of a monad as an /abstract datatype/ of actions.
<a name="line-811"></a>Haskell's @do@ expressions provide a convenient syntax for writing
<a name="line-812"></a>monadic expressions.
<a name="line-813"></a>
<a name="line-814"></a>Instances of 'Monad' should satisfy the following:
<a name="line-815"></a>
<a name="line-816"></a>[Left identity]  @'return' a '&gt;&gt;=' k  =  k a@
<a name="line-817"></a>[Right identity] @m '&gt;&gt;=' 'return'  =  m@
<a name="line-818"></a>[Associativity]  @m '&gt;&gt;=' (\\x -&gt; k x '&gt;&gt;=' h)  =  (m '&gt;&gt;=' k) '&gt;&gt;=' h@
<a name="line-819"></a>
<a name="line-820"></a>Furthermore, the 'Monad' and 'Applicative' operations should relate as follows:
<a name="line-821"></a>
<a name="line-822"></a>* @'pure' = 'return'@
<a name="line-823"></a>* @m1 '&lt;*&gt;' m2 = m1 '&gt;&gt;=' (\x1 -&gt; m2 '&gt;&gt;=' (\x2 -&gt; 'return' (x1 x2)))@
<a name="line-824"></a>
<a name="line-825"></a>The above laws imply:
<a name="line-826"></a>
<a name="line-827"></a>* @'fmap' f xs  =  xs '&gt;&gt;=' 'return' . f@
<a name="line-828"></a>* @('&gt;&gt;') = ('*&gt;')@
<a name="line-829"></a>
<a name="line-830"></a>and that 'pure' and ('&lt;*&gt;') satisfy the applicative functor laws.
<a name="line-831"></a>
<a name="line-832"></a>The instances of 'Monad' for lists, 'Data.Maybe.Maybe' and 'System.IO.IO'
<a name="line-833"></a>defined in the "Prelude" satisfy these laws.
<a name="line-834"></a>-}</span>
<a name="line-835"></a><a name="Monad"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyword'>where</span>
<a name="line-836"></a>    <span class='hs-comment'>-- | Sequentially compose two actions, passing any value produced</span>
<a name="line-837"></a>    <span class='hs-comment'>-- by the first as an argument to the second.</span>
<a name="line-838"></a>    <span class='hs-comment'>--</span>
<a name="line-839"></a>    <span class='hs-comment'>-- \'@as '&gt;&gt;=' bs@\' can be understood as the @do@ expression</span>
<a name="line-840"></a>    <span class='hs-comment'>--</span>
<a name="line-841"></a>    <span class='hs-comment'>-- @</span>
<a name="line-842"></a>    <span class='hs-comment'>-- do a &lt;- as</span>
<a name="line-843"></a>    <span class='hs-comment'>--    bs a</span>
<a name="line-844"></a>    <span class='hs-comment'>-- @</span>
<a name="line-845"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;=</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-varop'>.</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-846"></a>
<a name="line-847"></a>    <span class='hs-comment'>-- | Sequentially compose two actions, discarding any value produced</span>
<a name="line-848"></a>    <span class='hs-comment'>-- by the first, like sequencing operators (such as the semicolon)</span>
<a name="line-849"></a>    <span class='hs-comment'>-- in imperative languages.</span>
<a name="line-850"></a>    <span class='hs-comment'>--</span>
<a name="line-851"></a>    <span class='hs-comment'>-- \'@as '&gt;&gt;' bs@\' can be understood as the @do@ expression</span>
<a name="line-852"></a>    <span class='hs-comment'>--</span>
<a name="line-853"></a>    <span class='hs-comment'>-- @</span>
<a name="line-854"></a>    <span class='hs-comment'>-- do as</span>
<a name="line-855"></a>    <span class='hs-comment'>--    bs</span>
<a name="line-856"></a>    <span class='hs-comment'>-- @</span>
<a name="line-857"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-varop'>.</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-858"></a>    <span class='hs-varid'>m</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>k</span> <span class='hs-comment'>-- See Note [Recursive bindings for Applicative/Monad]</span>
<a name="line-859"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;) #-}</span>
<a name="line-860"></a>
<a name="line-861"></a>    <span class='hs-comment'>-- | Inject a value into the monadic type.</span>
<a name="line-862"></a>    <span class='hs-varid'>return</span>      <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-863"></a>    <span class='hs-varid'>return</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span>
<a name="line-864"></a>
<a name="line-865"></a><span class='hs-comment'>{- Note [Recursive bindings for Applicative/Monad]
<a name="line-866"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-867"></a>
<a name="line-868"></a>The original Applicative/Monad proposal stated that after
<a name="line-869"></a>implementation, the designated implementation of (&gt;&gt;) would become
<a name="line-870"></a>
<a name="line-871"></a>  (&gt;&gt;) :: forall a b. m a -&gt; m b -&gt; m b
<a name="line-872"></a>  (&gt;&gt;) = (*&gt;)
<a name="line-873"></a>
<a name="line-874"></a>by default. You might be inclined to change this to reflect the stated
<a name="line-875"></a>proposal, but you really shouldn't! Why? Because people tend to define
<a name="line-876"></a>such instances the /other/ way around: in particular, it is perfectly
<a name="line-877"></a>legitimate to define an instance of Applicative (*&gt;) in terms of (&gt;&gt;),
<a name="line-878"></a>which would lead to an infinite loop for the default implementation of
<a name="line-879"></a>Monad! And people do this in the wild.
<a name="line-880"></a>
<a name="line-881"></a>This turned into a nasty bug that was tricky to track down, and rather
<a name="line-882"></a>than eliminate it everywhere upstream, it's easier to just retain the
<a name="line-883"></a>original default.
<a name="line-884"></a>
<a name="line-885"></a>-}</span>
<a name="line-886"></a>
<a name="line-887"></a><a name="=%3c%3c"></a><span class='hs-comment'>-- | Same as '&gt;&gt;=', but with the arguments interchanged.</span>
<a name="line-888"></a><span class='hs-comment'>{-# SPECIALISE (=&lt;&lt;) :: (a -&gt; [b]) -&gt; [a] -&gt; [b] #-}</span>
<a name="line-889"></a><span class='hs-layout'>(</span><span class='hs-varop'>=&lt;&lt;</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-890"></a><a name="f"></a><span class='hs-definition'>f</span> <span class='hs-varop'>=&lt;&lt;</span> <span class='hs-varid'>x</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>f</span>
<a name="line-891"></a>
<a name="line-892"></a><a name="when"></a><span class='hs-comment'>-- | Conditional execution of 'Applicative' expressions. For example,</span>
<a name="line-893"></a><span class='hs-comment'>--</span>
<a name="line-894"></a><span class='hs-comment'>-- &gt; when debug (putStrLn "Debugging")</span>
<a name="line-895"></a><span class='hs-comment'>--</span>
<a name="line-896"></a><span class='hs-comment'>-- will output the string @Debugging@ if the Boolean value @debug@</span>
<a name="line-897"></a><span class='hs-comment'>-- is 'True', and otherwise do nothing.</span>
<a name="line-898"></a><span class='hs-definition'>when</span>      <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-conid'>()</span>
<a name="line-899"></a><span class='hs-comment'>{-# INLINABLE when #-}</span>
<a name="line-900"></a><span class='hs-comment'>{-# SPECIALISE when :: Bool -&gt; IO () -&gt; IO () #-}</span>
<a name="line-901"></a><span class='hs-comment'>{-# SPECIALISE when :: Bool -&gt; Maybe () -&gt; Maybe () #-}</span>
<a name="line-902"></a><span class='hs-definition'>when</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>p</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>()</span>
<a name="line-903"></a>
<a name="line-904"></a><a name="sequence"></a><span class='hs-comment'>-- | Evaluate each action in the sequence from left to right,</span>
<a name="line-905"></a><span class='hs-comment'>-- and collect the results.</span>
<a name="line-906"></a><span class='hs-definition'>sequence</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>m</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-907"></a><span class='hs-comment'>{-# INLINE sequence #-}</span>
<a name="line-908"></a><span class='hs-definition'>sequence</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>id</span>
<a name="line-909"></a><span class='hs-comment'>-- Note: [sequence and mapM]</span>
<a name="line-910"></a>
<a name="line-911"></a><a name="mapM"></a><span class='hs-comment'>-- | @'mapM' f@ is equivalent to @'sequence' . 'map' f@.</span>
<a name="line-912"></a><span class='hs-definition'>mapM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-913"></a><span class='hs-comment'>{-# INLINE mapM #-}</span>
<a name="line-914"></a><span class='hs-definition'>mapM</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>k</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span>
<a name="line-915"></a>            <span class='hs-keyword'>where</span>
<a name="line-916"></a>              <span class='hs-varid'>k</span> <span class='hs-varid'>a</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>;</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>r</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-917"></a>
<a name="line-918"></a><span class='hs-comment'>{-
<a name="line-919"></a>Note: [sequence and mapM]
<a name="line-920"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-921"></a>Originally, we defined
<a name="line-922"></a>
<a name="line-923"></a>mapM f = sequence . map f
<a name="line-924"></a>
<a name="line-925"></a>This relied on list fusion to produce efficient code for mapM, and led to
<a name="line-926"></a>excessive allocation in cryptarithm2. Defining
<a name="line-927"></a>
<a name="line-928"></a>sequence = mapM id
<a name="line-929"></a>
<a name="line-930"></a>relies only on inlining a tiny function (id) and beta reduction, which tends to
<a name="line-931"></a>be a more reliable aspect of simplification. Indeed, this does not lead to
<a name="line-932"></a>similar problems in nofib.
<a name="line-933"></a>-}</span>
<a name="line-934"></a>
<a name="line-935"></a><a name="liftM"></a><span class='hs-comment'>-- | Promote a function to a monad.</span>
<a name="line-936"></a><span class='hs-definition'>liftM</span>   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-937"></a><span class='hs-definition'>liftM</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span>              <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-938"></a>
<a name="line-939"></a><a name="liftM2"></a><span class='hs-comment'>-- | Promote a function to a monad, scanning the monadic arguments from</span>
<a name="line-940"></a><span class='hs-comment'>-- left to right.  For example,</span>
<a name="line-941"></a><span class='hs-comment'>--</span>
<a name="line-942"></a><span class='hs-comment'>-- &gt; liftM2 (+) [0,1] [0,2] = [0,2,1,3]</span>
<a name="line-943"></a><span class='hs-comment'>-- &gt; liftM2 (+) (Just 1) Nothing = Nothing</span>
<a name="line-944"></a><span class='hs-comment'>--</span>
<a name="line-945"></a><span class='hs-definition'>liftM2</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-946"></a><span class='hs-definition'>liftM2</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-947"></a><span class='hs-comment'>-- Caution: since this may be used for `liftA2`, we can't use the obvious</span>
<a name="line-948"></a><span class='hs-comment'>-- definition of liftM2 = liftA2.</span>
<a name="line-949"></a>
<a name="line-950"></a><a name="liftM3"></a><span class='hs-comment'>-- | Promote a function to a monad, scanning the monadic arguments from</span>
<a name="line-951"></a><span class='hs-comment'>-- left to right (cf. 'liftM2').</span>
<a name="line-952"></a><span class='hs-definition'>liftM3</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-953"></a><span class='hs-definition'>liftM3</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span> <span class='hs-varid'>m3</span>       <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>x3</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m3</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span> <span class='hs-varid'>x3</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-954"></a>
<a name="line-955"></a><a name="liftM4"></a><span class='hs-comment'>-- | Promote a function to a monad, scanning the monadic arguments from</span>
<a name="line-956"></a><span class='hs-comment'>-- left to right (cf. 'liftM2').</span>
<a name="line-957"></a><span class='hs-definition'>liftM4</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a4</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a4</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-958"></a><span class='hs-definition'>liftM4</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span> <span class='hs-varid'>m3</span> <span class='hs-varid'>m4</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>x3</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m3</span><span class='hs-layout'>;</span> <span class='hs-varid'>x4</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m4</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span> <span class='hs-varid'>x3</span> <span class='hs-varid'>x4</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-959"></a>
<a name="line-960"></a><a name="liftM5"></a><span class='hs-comment'>-- | Promote a function to a monad, scanning the monadic arguments from</span>
<a name="line-961"></a><span class='hs-comment'>-- left to right (cf. 'liftM2').</span>
<a name="line-962"></a><span class='hs-definition'>liftM5</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a4</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a5</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a4</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a5</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-963"></a><span class='hs-definition'>liftM5</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span> <span class='hs-varid'>m3</span> <span class='hs-varid'>m4</span> <span class='hs-varid'>m5</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>x3</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m3</span><span class='hs-layout'>;</span> <span class='hs-varid'>x4</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m4</span><span class='hs-layout'>;</span> <span class='hs-varid'>x5</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m5</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span> <span class='hs-varid'>x3</span> <span class='hs-varid'>x4</span> <span class='hs-varid'>x5</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-964"></a>
<a name="line-965"></a><span class='hs-comment'>{-# INLINABLE liftM #-}</span>
<a name="line-966"></a><span class='hs-comment'>{-# SPECIALISE liftM :: (a1-&gt;r) -&gt; IO a1 -&gt; IO r #-}</span>
<a name="line-967"></a><span class='hs-comment'>{-# SPECIALISE liftM :: (a1-&gt;r) -&gt; Maybe a1 -&gt; Maybe r #-}</span>
<a name="line-968"></a><span class='hs-comment'>{-# INLINABLE liftM2 #-}</span>
<a name="line-969"></a><span class='hs-comment'>{-# SPECIALISE liftM2 :: (a1-&gt;a2-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO r #-}</span>
<a name="line-970"></a><span class='hs-comment'>{-# SPECIALISE liftM2 :: (a1-&gt;a2-&gt;r) -&gt; Maybe a1 -&gt; Maybe a2 -&gt; Maybe r #-}</span>
<a name="line-971"></a><span class='hs-comment'>{-# INLINABLE liftM3 #-}</span>
<a name="line-972"></a><span class='hs-comment'>{-# SPECIALISE liftM3 :: (a1-&gt;a2-&gt;a3-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO a3 -&gt; IO r #-}</span>
<a name="line-973"></a><span class='hs-comment'>{-# SPECIALISE liftM3 :: (a1-&gt;a2-&gt;a3-&gt;r) -&gt; Maybe a1 -&gt; Maybe a2 -&gt; Maybe a3 -&gt; Maybe r #-}</span>
<a name="line-974"></a><span class='hs-comment'>{-# INLINABLE liftM4 #-}</span>
<a name="line-975"></a><span class='hs-comment'>{-# SPECIALISE liftM4 :: (a1-&gt;a2-&gt;a3-&gt;a4-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO a3 -&gt; IO a4 -&gt; IO r #-}</span>
<a name="line-976"></a><span class='hs-comment'>{-# SPECIALISE liftM4 :: (a1-&gt;a2-&gt;a3-&gt;a4-&gt;r) -&gt; Maybe a1 -&gt; Maybe a2 -&gt; Maybe a3 -&gt; Maybe a4 -&gt; Maybe r #-}</span>
<a name="line-977"></a><span class='hs-comment'>{-# INLINABLE liftM5 #-}</span>
<a name="line-978"></a><span class='hs-comment'>{-# SPECIALISE liftM5 :: (a1-&gt;a2-&gt;a3-&gt;a4-&gt;a5-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO a3 -&gt; IO a4 -&gt; IO a5 -&gt; IO r #-}</span>
<a name="line-979"></a><span class='hs-comment'>{-# SPECIALISE liftM5 :: (a1-&gt;a2-&gt;a3-&gt;a4-&gt;a5-&gt;r) -&gt; Maybe a1 -&gt; Maybe a2 -&gt; Maybe a3 -&gt; Maybe a4 -&gt; Maybe a5 -&gt; Maybe r #-}</span>
<a name="line-980"></a>
<a name="line-981"></a><span class='hs-comment'>{- | In many situations, the 'liftM' operations can be replaced by uses of
<a name="line-982"></a>'ap', which promotes function application.
<a name="line-983"></a>
<a name="line-984"></a>&gt; return f `ap` x1 `ap` ... `ap` xn
<a name="line-985"></a>
<a name="line-986"></a>is equivalent to
<a name="line-987"></a>
<a name="line-988"></a>&gt; liftMn f x1 x2 ... xn
<a name="line-989"></a>
<a name="line-990"></a>-}</span>
<a name="line-991"></a>
<a name="line-992"></a><a name="ap"></a><span class='hs-definition'>ap</span>                <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-993"></a><span class='hs-definition'>ap</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-994"></a><span class='hs-comment'>-- Since many Applicative instances define (&lt;*&gt;) = ap, we</span>
<a name="line-995"></a><span class='hs-comment'>-- cannot define ap = (&lt;*&gt;)</span>
<a name="line-996"></a><span class='hs-comment'>{-# INLINABLE ap #-}</span>
<a name="line-997"></a><span class='hs-comment'>{-# SPECIALISE ap :: IO (a -&gt; b) -&gt; IO a -&gt; IO b #-}</span>
<a name="line-998"></a><span class='hs-comment'>{-# SPECIALISE ap :: Maybe (a -&gt; b) -&gt; Maybe a -&gt; Maybe b #-}</span>
<a name="line-999"></a>
<a name="line-1000"></a><span class='hs-comment'>-- instances for Prelude types</span>
<a name="line-1001"></a>
<a name="line-1002"></a><a name="instance%20Functor%20((-%3e)%20r)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1003"></a><a name="instance%20Functor%20((-%3e)%20r)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-1004"></a>    <span class='hs-varid'>fmap</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>.</span><span class='hs-layout'>)</span>
<a name="line-1005"></a>
<a name="line-1006"></a><a name="instance%20Applicative%20((-%3e)%20r)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1007"></a><a name="instance%20Applicative%20((-%3e)%20r)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-1008"></a>    <span class='hs-varid'>pure</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>const</span>
<a name="line-1009"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span> <span class='hs-varid'>g</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>g</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1010"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-varid'>q</span> <span class='hs-varid'>f</span> <span class='hs-varid'>g</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>q</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>g</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1011"></a>
<a name="line-1012"></a><a name="instance%20Monad%20((-%3e)%20r)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1013"></a><a name="instance%20Monad%20((-%3e)%20r)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-1014"></a>    <span class='hs-varid'>f</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>k</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span>
<a name="line-1015"></a>
<a name="line-1016"></a><a name="instance%20Functor%20Solo"></a><span class='hs-comment'>-- | @since 4.15</span>
<a name="line-1017"></a><a name="instance%20Functor%20Solo"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-conid'>Solo</span> <span class='hs-keyword'>where</span>
<a name="line-1018"></a>  <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Solo</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Solo</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-1019"></a>
<a name="line-1020"></a>  <span class='hs-comment'>-- Being strict in the `Solo` argument here seems most consistent</span>
<a name="line-1021"></a>  <span class='hs-comment'>-- with the concept behind `Solo`: always strict in the wrapper and lazy</span>
<a name="line-1022"></a>  <span class='hs-comment'>-- in the contents.</span>
<a name="line-1023"></a>  <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;$</span> <span class='hs-conid'>Solo</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Solo</span> <span class='hs-varid'>x</span>
<a name="line-1024"></a>
<a name="line-1025"></a><a name="instance%20Functor%20((,)%20a)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1026"></a><a name="instance%20Functor%20((,)%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,)</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-1027"></a>    <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1028"></a>
<a name="line-1029"></a><a name="instance%20Functor%20Maybe"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1030"></a><a name="instance%20Functor%20Maybe"></a><span class='hs-keyword'>instance</span>  <span class='hs-conid'>Functor</span> <span class='hs-conid'>Maybe</span>  <span class='hs-keyword'>where</span>
<a name="line-1031"></a>    <span class='hs-varid'>fmap</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Nothing</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1032"></a>    <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-1033"></a>
<a name="line-1034"></a><a name="instance%20Applicative%20Maybe"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1035"></a><a name="instance%20Applicative%20Maybe"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyword'>where</span>
<a name="line-1036"></a>    <span class='hs-varid'>pure</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span>
<a name="line-1037"></a>
<a name="line-1038"></a>    <span class='hs-conid'>Just</span> <span class='hs-varid'>f</span>  <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>m</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m</span>
<a name="line-1039"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-sel'>_m</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1040"></a>
<a name="line-1041"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1042"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1043"></a>
<a name="line-1044"></a>    <span class='hs-conid'>Just</span> <span class='hs-sel'>_m1</span> <span class='hs-varop'>*&gt;</span> <span class='hs-varid'>m2</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m2</span>
<a name="line-1045"></a>    <span class='hs-conid'>Nothing</span>  <span class='hs-varop'>*&gt;</span> <span class='hs-sel'>_m2</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1046"></a>
<a name="line-1047"></a><a name="instance%20Monad%20Maybe"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1048"></a><a name="instance%20Monad%20Maybe"></a><span class='hs-keyword'>instance</span>  <span class='hs-conid'>Monad</span> <span class='hs-conid'>Maybe</span>  <span class='hs-keyword'>where</span>
<a name="line-1049"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-varid'>x</span>
<a name="line-1050"></a>    <span class='hs-conid'>Nothing</span>  <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1051"></a>
<a name="line-1052"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>*&gt;</span><span class='hs-layout'>)</span>
<a name="line-1053"></a>
<a name="line-1054"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-1055"></a><span class='hs-comment'>-- The Alternative class definition</span>
<a name="line-1056"></a>
<a name="line-1057"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>3</span> <span class='hs-varop'>&lt;|&gt;</span>
<a name="line-1058"></a>
<a name="line-1059"></a><a name="Alternative"></a><span class='hs-comment'>-- | A monoid on applicative functors.</span>
<a name="line-1060"></a><a name="Alternative"></a><span class='hs-comment'>--</span>
<a name="line-1061"></a><a name="Alternative"></a><span class='hs-comment'>-- If defined, 'some' and 'many' should be the least solutions</span>
<a name="line-1062"></a><a name="Alternative"></a><span class='hs-comment'>-- of the equations:</span>
<a name="line-1063"></a><a name="Alternative"></a><span class='hs-comment'>--</span>
<a name="line-1064"></a><a name="Alternative"></a><span class='hs-comment'>-- * @'some' v = (:) 'Prelude.&lt;$&gt;' v '&lt;*&gt;' 'many' v@</span>
<a name="line-1065"></a><a name="Alternative"></a><span class='hs-comment'>--</span>
<a name="line-1066"></a><a name="Alternative"></a><span class='hs-comment'>-- * @'many' v = 'some' v '&lt;|&gt;' 'pure' []@</span>
<a name="line-1067"></a><a name="Alternative"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Alternative</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<a name="line-1068"></a>    <span class='hs-comment'>-- | The identity of '&lt;|&gt;'</span>
<a name="line-1069"></a>    <span class='hs-varid'>empty</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-1070"></a>    <span class='hs-comment'>-- | An associative binary operation</span>
<a name="line-1071"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;|&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-1072"></a>
<a name="line-1073"></a>    <span class='hs-comment'>-- | One or more.</span>
<a name="line-1074"></a>    <span class='hs-varid'>some</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1075"></a>    <span class='hs-varid'>some</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>some_v</span>
<a name="line-1076"></a>      <span class='hs-keyword'>where</span>
<a name="line-1077"></a>        <span class='hs-varid'>many_v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>some_v</span> <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>[]</span>
<a name="line-1078"></a>        <span class='hs-varid'>some_v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span> <span class='hs-varid'>many_v</span>
<a name="line-1079"></a>
<a name="line-1080"></a>    <span class='hs-comment'>-- | Zero or more.</span>
<a name="line-1081"></a>    <span class='hs-varid'>many</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1082"></a>    <span class='hs-varid'>many</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>many_v</span>
<a name="line-1083"></a>      <span class='hs-keyword'>where</span>
<a name="line-1084"></a>        <span class='hs-varid'>many_v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>some_v</span> <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>[]</span>
<a name="line-1085"></a>        <span class='hs-varid'>some_v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span> <span class='hs-varid'>many_v</span>
<a name="line-1086"></a>
<a name="line-1087"></a>
<a name="line-1088"></a><a name="instance%20Alternative%20Maybe"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1089"></a><a name="instance%20Alternative%20Maybe"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Alternative</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyword'>where</span>
<a name="line-1090"></a>    <span class='hs-varid'>empty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1091"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-1092"></a>    <span class='hs-varid'>l</span>       <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>l</span>
<a name="line-1093"></a>
<a name="line-1094"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-1095"></a><span class='hs-comment'>-- The MonadPlus class definition</span>
<a name="line-1096"></a>
<a name="line-1097"></a><a name="MonadPlus"></a><span class='hs-comment'>-- | Monads that also support choice and failure.</span>
<a name="line-1098"></a><a name="MonadPlus"></a><span class='hs-keyword'>class</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alternative</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>MonadPlus</span> <span class='hs-varid'>m</span> <span class='hs-keyword'>where</span>
<a name="line-1099"></a>   <span class='hs-comment'>-- | The identity of 'mplus'.  It should also satisfy the equations</span>
<a name="line-1100"></a>   <span class='hs-comment'>--</span>
<a name="line-1101"></a>   <span class='hs-comment'>-- &gt; mzero &gt;&gt;= f  =  mzero</span>
<a name="line-1102"></a>   <span class='hs-comment'>-- &gt; v &gt;&gt; mzero   =  mzero</span>
<a name="line-1103"></a>   <span class='hs-comment'>--</span>
<a name="line-1104"></a>   <span class='hs-comment'>-- The default definition is</span>
<a name="line-1105"></a>   <span class='hs-comment'>--</span>
<a name="line-1106"></a>   <span class='hs-comment'>-- @</span>
<a name="line-1107"></a>   <span class='hs-comment'>-- mzero = 'empty'</span>
<a name="line-1108"></a>   <span class='hs-comment'>-- @</span>
<a name="line-1109"></a>   <span class='hs-varid'>mzero</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-1110"></a>   <span class='hs-varid'>mzero</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>empty</span>
<a name="line-1111"></a>
<a name="line-1112"></a>   <span class='hs-comment'>-- | An associative operation. The default definition is</span>
<a name="line-1113"></a>   <span class='hs-comment'>--</span>
<a name="line-1114"></a>   <span class='hs-comment'>-- @</span>
<a name="line-1115"></a>   <span class='hs-comment'>-- mplus = ('&lt;|&gt;')</span>
<a name="line-1116"></a>   <span class='hs-comment'>-- @</span>
<a name="line-1117"></a>   <span class='hs-varid'>mplus</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-1118"></a>   <span class='hs-varid'>mplus</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;|&gt;</span><span class='hs-layout'>)</span>
<a name="line-1119"></a>
<a name="line-1120"></a><a name="instance%20MonadPlus%20Maybe"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1121"></a><a name="instance%20MonadPlus%20Maybe"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>MonadPlus</span> <span class='hs-conid'>Maybe</span>
<a name="line-1122"></a>
<a name="line-1123"></a><span class='hs-comment'>---------------------------------------------</span>
<a name="line-1124"></a><span class='hs-comment'>-- The non-empty list type</span>
<a name="line-1125"></a>
<a name="line-1126"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>5</span> <span class='hs-conop'>:|</span>
<a name="line-1127"></a>
<a name="line-1128"></a><a name="NonEmpty"></a><span class='hs-comment'>-- | Non-empty (and non-strict) list type.</span>
<a name="line-1129"></a><a name="NonEmpty"></a><span class='hs-comment'>--</span>
<a name="line-1130"></a><a name="NonEmpty"></a><span class='hs-comment'>-- @since 4.9.0.0</span>
<a name="line-1131"></a><a name="NonEmpty"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1132"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Eq</span>  <span class='hs-comment'>-- ^ @since 4.9.0.0</span>
<a name="line-1133"></a>           <span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span> <span class='hs-comment'>-- ^ @since 4.9.0.0</span>
<a name="line-1134"></a>           <span class='hs-layout'>)</span>
<a name="line-1135"></a>
<a name="line-1136"></a><a name="instance%20Functor%20NonEmpty"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-1137"></a><a name="instance%20Functor%20NonEmpty"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-keyword'>where</span>
<a name="line-1138"></a>  <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>as</span>
<a name="line-1139"></a>  <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;$</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span>   <span class='hs-conop'>:|</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&lt;$</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-1140"></a>
<a name="line-1141"></a><a name="instance%20Applicative%20NonEmpty"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-1142"></a><a name="instance%20Applicative%20NonEmpty"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-keyword'>where</span>
<a name="line-1143"></a>  <span class='hs-varid'>pure</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-conid'>[]</span>
<a name="line-1144"></a>  <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ap</span>
<a name="line-1145"></a>  <span class='hs-varid'>liftA2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftM2</span>
<a name="line-1146"></a>
<a name="line-1147"></a><a name="instance%20Monad%20NonEmpty"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-1148"></a><a name="instance%20Monad%20NonEmpty"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monad</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-keyword'>where</span>
<a name="line-1149"></a>  <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:|</span> <span class='hs-layout'>(</span><span class='hs-varid'>bs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>bs'</span><span class='hs-layout'>)</span>
<a name="line-1150"></a>    <span class='hs-keyword'>where</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:|</span> <span class='hs-varid'>bs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-1151"></a>          <span class='hs-varid'>bs'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>as</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>toList</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f</span>
<a name="line-1152"></a>          <span class='hs-varid'>toList</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>c</span> <span class='hs-conop'>:|</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>c</span> <span class='hs-conop'>:</span> <span class='hs-varid'>cs</span>
<a name="line-1153"></a>
<a name="line-1154"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1155"></a><span class='hs-comment'>-- The list type</span>
<a name="line-1156"></a>
<a name="line-1157"></a><a name="instance%20Functor%20%5b%5d"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1158"></a><a name="instance%20Functor%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-1159"></a>    <span class='hs-comment'>{-# INLINE fmap #-}</span>
<a name="line-1160"></a>    <span class='hs-varid'>fmap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span>
<a name="line-1161"></a>
<a name="line-1162"></a><a name="instance%20Applicative%20%5b%5d"></a><span class='hs-comment'>-- See Note: [List comprehensions and inlining]</span>
<a name="line-1163"></a><a name="instance%20Applicative%20%5b%5d"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1164"></a><a name="instance%20Applicative%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-1165"></a>    <span class='hs-comment'>{-# INLINE pure #-}</span>
<a name="line-1166"></a>    <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>
<a name="line-1167"></a>    <span class='hs-comment'>{-# INLINE (&lt;*&gt;) #-}</span>
<a name="line-1168"></a>    <span class='hs-varid'>fs</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>fs</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-keyglyph'>]</span>
<a name="line-1169"></a>    <span class='hs-comment'>{-# INLINE liftA2 #-}</span>
<a name="line-1170"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ys</span><span class='hs-keyglyph'>]</span>
<a name="line-1171"></a>    <span class='hs-comment'>{-# INLINE (*&gt;) #-}</span>
<a name="line-1172"></a>    <span class='hs-varid'>xs</span> <span class='hs-varop'>*&gt;</span> <span class='hs-varid'>ys</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ys</span><span class='hs-keyglyph'>]</span>
<a name="line-1173"></a>
<a name="line-1174"></a><a name="instance%20Monad%20%5b%5d"></a><span class='hs-comment'>-- See Note: [List comprehensions and inlining]</span>
<a name="line-1175"></a><a name="instance%20Monad%20%5b%5d"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1176"></a><a name="instance%20Monad%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monad</span> <span class='hs-conid'>[]</span>  <span class='hs-keyword'>where</span>
<a name="line-1177"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;=) #-}</span>
<a name="line-1178"></a>    <span class='hs-varid'>xs</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>f</span>             <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>
<a name="line-1179"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;) #-}</span>
<a name="line-1180"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>*&gt;</span><span class='hs-layout'>)</span>
<a name="line-1181"></a>
<a name="line-1182"></a><a name="instance%20Alternative%20%5b%5d"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1183"></a><a name="instance%20Alternative%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Alternative</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-1184"></a>    <span class='hs-varid'>empty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-1185"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;|&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span>
<a name="line-1186"></a>
<a name="line-1187"></a><a name="instance%20MonadPlus%20%5b%5d"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1188"></a><a name="instance%20MonadPlus%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>MonadPlus</span> <span class='hs-conid'>[]</span>
<a name="line-1189"></a>
<a name="line-1190"></a><span class='hs-comment'>{-
<a name="line-1191"></a>A few list functions that appear here because they are used here.
<a name="line-1192"></a>The rest of the prelude list functions are in GHC.List.
<a name="line-1193"></a>-}</span>
<a name="line-1194"></a>
<a name="line-1195"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1196"></a><span class='hs-comment'>--      foldr/build/augment</span>
<a name="line-1197"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1198"></a>
<a name="line-1199"></a><span class='hs-comment'>-- | 'foldr', applied to a binary operator, a starting value (typically</span>
<a name="line-1200"></a><span class='hs-comment'>-- the right-identity of the operator), and a list, reduces the list</span>
<a name="line-1201"></a><span class='hs-comment'>-- using the binary operator, from right to left:</span>
<a name="line-1202"></a><span class='hs-comment'>--</span>
<a name="line-1203"></a><span class='hs-comment'>-- &gt; foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)</span>
<a name="line-1204"></a>
<a name="line-1205"></a><span class='hs-definition'>foldr</span>            <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-1206"></a><span class='hs-comment'>-- foldr _ z []     =  z</span>
<a name="line-1207"></a><span class='hs-comment'>-- foldr f z (x:xs) =  f x (foldr f z xs)</span>
<a name="line-1208"></a><span class='hs-comment'>{-# INLINE [0] foldr #-}</span>
<a name="line-1209"></a><span class='hs-comment'>-- Inline only in the final stage, after the foldr/cons rule has had a chance</span>
<a name="line-1210"></a><span class='hs-comment'>-- Also note that we inline it when it has *two* parameters, which are the</span>
<a name="line-1211"></a><span class='hs-comment'>-- ones we are keen about specialising!</span>
<a name="line-1212"></a><span class='hs-definition'>foldr</span> <span class='hs-varid'>k</span> <span class='hs-varid'>z</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span>
<a name="line-1213"></a>          <span class='hs-keyword'>where</span>
<a name="line-1214"></a>            <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span>
<a name="line-1215"></a>            <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>y</span> <span class='hs-varop'>`k`</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ys</span>
<a name="line-1216"></a>
<a name="line-1217"></a><span class='hs-comment'>-- | A list producer that can be fused with 'foldr'.</span>
<a name="line-1218"></a><span class='hs-comment'>-- This function is merely</span>
<a name="line-1219"></a><span class='hs-comment'>--</span>
<a name="line-1220"></a><span class='hs-comment'>-- &gt;    build g = g (:) []</span>
<a name="line-1221"></a><span class='hs-comment'>--</span>
<a name="line-1222"></a><span class='hs-comment'>-- but GHC's simplifier will transform an expression of the form</span>
<a name="line-1223"></a><span class='hs-comment'>-- @'foldr' k z ('build' g)@, which may arise after inlining, to @g k z@,</span>
<a name="line-1224"></a><span class='hs-comment'>-- which avoids producing an intermediate list.</span>
<a name="line-1225"></a>
<a name="line-1226"></a><span class='hs-definition'>build</span>   <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>b</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1227"></a><span class='hs-comment'>{-# INLINE [1] build #-}</span>
<a name="line-1228"></a>        <span class='hs-comment'>-- The INLINE is important, even though build is tiny,</span>
<a name="line-1229"></a>        <span class='hs-comment'>-- because it prevents [] getting inlined in the version that</span>
<a name="line-1230"></a>        <span class='hs-comment'>-- appears in the interface file.  If [] *is* inlined, it</span>
<a name="line-1231"></a>        <span class='hs-comment'>-- won't match with [] appearing in rules in an importing module.</span>
<a name="line-1232"></a>        <span class='hs-comment'>--</span>
<a name="line-1233"></a>        <span class='hs-comment'>-- The "1" says to inline in phase 1</span>
<a name="line-1234"></a>
<a name="line-1235"></a><span class='hs-definition'>build</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span>
<a name="line-1236"></a>
<a name="line-1237"></a><span class='hs-comment'>-- | A list producer that can be fused with 'foldr'.</span>
<a name="line-1238"></a><span class='hs-comment'>-- This function is merely</span>
<a name="line-1239"></a><span class='hs-comment'>--</span>
<a name="line-1240"></a><span class='hs-comment'>-- &gt;    augment g xs = g (:) xs</span>
<a name="line-1241"></a><span class='hs-comment'>--</span>
<a name="line-1242"></a><span class='hs-comment'>-- but GHC's simplifier will transform an expression of the form</span>
<a name="line-1243"></a><span class='hs-comment'>-- @'foldr' k z ('augment' g xs)@, which may arise after inlining, to</span>
<a name="line-1244"></a><span class='hs-comment'>-- @g k ('foldr' k z xs)@, which avoids producing an intermediate list.</span>
<a name="line-1245"></a>
<a name="line-1246"></a><a name="augment"></a><span class='hs-definition'>augment</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>b</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1247"></a><span class='hs-comment'>{-# INLINE [1] augment #-}</span>
<a name="line-1248"></a><span class='hs-definition'>augment</span> <span class='hs-varid'>g</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
<a name="line-1249"></a>
<a name="line-1250"></a><span class='hs-comment'>{-# RULES
<a name="line-1251"></a>"fold/build"    forall k z (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-1252"></a>                foldr k z (build g) = g k z
<a name="line-1253"></a>
<a name="line-1254"></a>"foldr/augment" forall k z xs (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-1255"></a>                foldr k z (augment g xs) = g k (foldr k z xs)
<a name="line-1256"></a>
<a name="line-1257"></a>"foldr/id"                        foldr (:) [] = \x  -&gt; x
<a name="line-1258"></a>"foldr/app"     [1] forall ys. foldr (:) ys = \xs -&gt; xs ++ ys
<a name="line-1259"></a>        -- Only activate this from phase 1, because that's
<a name="line-1260"></a>        -- when we disable the rule that expands (++) into foldr
<a name="line-1261"></a>
<a name="line-1262"></a>-- The foldr/cons rule looks nice, but it can give disastrously
<a name="line-1263"></a>-- bloated code when commpiling
<a name="line-1264"></a>--      array (a,b) [(1,2), (2,2), (3,2), ...very long list... ]
<a name="line-1265"></a>-- i.e. when there are very very long literal lists
<a name="line-1266"></a>-- So I've disabled it for now. We could have special cases
<a name="line-1267"></a>-- for short lists, I suppose.
<a name="line-1268"></a>-- "foldr/cons" forall k z x xs. foldr k z (x:xs) = k x (foldr k z xs)
<a name="line-1269"></a>
<a name="line-1270"></a>"foldr/single"  forall k z x. foldr k z [x] = k x z
<a name="line-1271"></a>"foldr/nil"     forall k z.   foldr k z []  = z
<a name="line-1272"></a>
<a name="line-1273"></a>"foldr/cons/build" forall k z x (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-1274"></a>                           foldr k z (x:build g) = k x (g k z)
<a name="line-1275"></a>
<a name="line-1276"></a>"augment/build" forall (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b)
<a name="line-1277"></a>                       (h::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-1278"></a>                       augment g (build h) = build (\c n -&gt; g c (h c n))
<a name="line-1279"></a>"augment/nil"   forall (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-1280"></a>                        augment g [] = build g
<a name="line-1281"></a> #-}</span>
<a name="line-1282"></a>
<a name="line-1283"></a><span class='hs-comment'>-- This rule is true, but not (I think) useful:</span>
<a name="line-1284"></a><span class='hs-comment'>--      augment g (augment h t) = augment (\cn -&gt; g c (h c n)) t</span>
<a name="line-1285"></a>
<a name="line-1286"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1287"></a><span class='hs-comment'>--              map</span>
<a name="line-1288"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1289"></a>
<a name="line-1290"></a><a name="map"></a><span class='hs-comment'>-- | \(\mathcal{O}(n)\). 'map' @f xs@ is the list obtained by applying @f@ to</span>
<a name="line-1291"></a><span class='hs-comment'>-- each element of @xs@, i.e.,</span>
<a name="line-1292"></a><span class='hs-comment'>--</span>
<a name="line-1293"></a><span class='hs-comment'>-- &gt; map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]</span>
<a name="line-1294"></a><span class='hs-comment'>-- &gt; map f [x1, x2, ...] == [f x1, f x2, ...]</span>
<a name="line-1295"></a><span class='hs-comment'>--</span>
<a name="line-1296"></a><span class='hs-comment'>-- &gt;&gt;&gt; map (+1) [1, 2, 3]</span>
<a name="line-1297"></a><span class='hs-comment'>-- [2,3,4]</span>
<a name="line-1298"></a><span class='hs-definition'>map</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-1299"></a><span class='hs-comment'>{-# NOINLINE [0] map #-}</span>
<a name="line-1300"></a>  <span class='hs-comment'>-- We want the RULEs "map" and "map/coerce" to fire first.</span>
<a name="line-1301"></a>  <span class='hs-comment'>-- map is recursive, so won't inline anyway,</span>
<a name="line-1302"></a>  <span class='hs-comment'>-- but saying so is more explicit, and silences warnings</span>
<a name="line-1303"></a><span class='hs-definition'>map</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-1304"></a><span class='hs-definition'>map</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>map</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span>
<a name="line-1305"></a>
<a name="line-1306"></a><a name="mapFB"></a><span class='hs-comment'>-- Note eta expanded</span>
<a name="line-1307"></a><span class='hs-definition'>mapFB</span> <span class='hs-keyglyph'>::</span>  <span class='hs-layout'>(</span><span class='hs-varid'>elt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lst</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>elt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lst</span>
<a name="line-1308"></a><span class='hs-comment'>{-# INLINE [0] mapFB #-}</span> <span class='hs-comment'>-- See Note [Inline FB functions] in GHC.List</span>
<a name="line-1309"></a><span class='hs-definition'>mapFB</span> <span class='hs-varid'>c</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span>
<a name="line-1310"></a>
<a name="line-1311"></a><span class='hs-comment'>{- Note [The rules for map]
<a name="line-1312"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1313"></a>The rules for map work like this.
<a name="line-1314"></a>
<a name="line-1315"></a>* Up to (but not including) phase 1, we use the "map" rule to
<a name="line-1316"></a>  rewrite all saturated applications of map with its build/fold
<a name="line-1317"></a>  form, hoping for fusion to happen.
<a name="line-1318"></a>
<a name="line-1319"></a>  In phase 1 and 0, we switch off that rule, inline build, and
<a name="line-1320"></a>  switch on the "mapList" rule, which rewrites the foldr/mapFB
<a name="line-1321"></a>  thing back into plain map.
<a name="line-1322"></a>
<a name="line-1323"></a>  It's important that these two rules aren't both active at once
<a name="line-1324"></a>  (along with build's unfolding) else we'd get an infinite loop
<a name="line-1325"></a>  in the rules.  Hence the activation control below.
<a name="line-1326"></a>
<a name="line-1327"></a>* This same pattern is followed by many other functions:
<a name="line-1328"></a>  e.g. append, filter, iterate, repeat, etc. in GHC.List
<a name="line-1329"></a>
<a name="line-1330"></a>  See also Note [Inline FB functions] in GHC.List
<a name="line-1331"></a>
<a name="line-1332"></a>* The "mapFB" rule optimises compositions of map
<a name="line-1333"></a>
<a name="line-1334"></a>* The "mapFB/id" rule gets rid of 'map id' calls.
<a name="line-1335"></a>  You might think that (mapFB c id) will turn into c simply
<a name="line-1336"></a>  when mapFB is inlined; but before that happens the "mapList"
<a name="line-1337"></a>  rule turns
<a name="line-1338"></a>     (foldr (mapFB (:) id) [] a
<a name="line-1339"></a>  back into
<a name="line-1340"></a>     map id
<a name="line-1341"></a>  Which is not very clever.
<a name="line-1342"></a>
<a name="line-1343"></a>* Any similarity to the Functor laws for [] is expected.
<a name="line-1344"></a>-}</span>
<a name="line-1345"></a>
<a name="line-1346"></a><span class='hs-comment'>{-# RULES
<a name="line-1347"></a>"map"       [~1] forall f xs.   map f xs                = build (\c n -&gt; foldr (mapFB c f) n xs)
<a name="line-1348"></a>"mapList"   [1]  forall f.      foldr (mapFB (:) f) []  = map f
<a name="line-1349"></a>"mapFB"     forall c f g.       mapFB (mapFB c f) g     = mapFB c (f.g)
<a name="line-1350"></a>"mapFB/id"  forall c.           mapFB c (\x -&gt; x)       = c
<a name="line-1351"></a>  #-}</span>
<a name="line-1352"></a>
<a name="line-1353"></a><span class='hs-comment'>-- See Breitner, Eisenberg, Peyton Jones, and Weirich, "Safe Zero-cost</span>
<a name="line-1354"></a><span class='hs-comment'>-- Coercions for Haskell", section 6.5:</span>
<a name="line-1355"></a><span class='hs-comment'>--   <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf">http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf</a></span>
<a name="line-1356"></a>
<a name="line-1357"></a><span class='hs-comment'>{-# RULES "map/coerce" [1] map coerce = coerce #-}</span>
<a name="line-1358"></a><span class='hs-comment'>-- See Note [Getting the map/coerce RULE to work] in CoreOpt</span>
<a name="line-1359"></a>
<a name="line-1360"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1361"></a><span class='hs-comment'>--              append</span>
<a name="line-1362"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1363"></a>
<a name="line-1364"></a><span class='hs-comment'>-- | Append two lists, i.e.,</span>
<a name="line-1365"></a><span class='hs-comment'>--</span>
<a name="line-1366"></a><span class='hs-comment'>-- &gt; [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]</span>
<a name="line-1367"></a><span class='hs-comment'>-- &gt; [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]</span>
<a name="line-1368"></a><span class='hs-comment'>--</span>
<a name="line-1369"></a><span class='hs-comment'>-- If the first list is not finite, the result is the first list.</span>
<a name="line-1370"></a>
<a name="line-1371"></a><a name="++"></a><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1372"></a><span class='hs-comment'>{-# NOINLINE [1] (++) #-}</span>    <span class='hs-comment'>-- We want the RULE to fire first.</span>
<a name="line-1373"></a>                             <span class='hs-comment'>-- It's recursive, so won't inline anyway,</span>
<a name="line-1374"></a>                             <span class='hs-comment'>-- but saying so is more explicit</span>
<a name="line-1375"></a><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span>     <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ys</span>
<a name="line-1376"></a><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>ys</span>
<a name="line-1377"></a>
<a name="line-1378"></a><span class='hs-comment'>{-# RULES
<a name="line-1379"></a>"++"    [~1] forall xs ys. xs ++ ys = augment (\c n -&gt; foldr c n xs) ys
<a name="line-1380"></a>  #-}</span>
<a name="line-1381"></a>
<a name="line-1382"></a>
<a name="line-1383"></a><span class='hs-comment'>-- |'otherwise' is defined as the value 'True'.  It helps to make</span>
<a name="line-1384"></a><span class='hs-comment'>-- guards more readable.  eg.</span>
<a name="line-1385"></a><span class='hs-comment'>--</span>
<a name="line-1386"></a><span class='hs-comment'>-- &gt;  f x | x &lt; 0     = ...</span>
<a name="line-1387"></a><span class='hs-comment'>-- &gt;      | otherwise = ...</span>
<a name="line-1388"></a><span class='hs-definition'>otherwise</span>               <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-1389"></a><span class='hs-definition'>otherwise</span>               <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>True</span>
<a name="line-1390"></a>
<a name="line-1391"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1392"></a><span class='hs-comment'>-- Type Char and String</span>
<a name="line-1393"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1394"></a>
<a name="line-1395"></a><a name="String"></a><span class='hs-comment'>-- | A 'String' is a list of characters.  String constants in Haskell are values</span>
<a name="line-1396"></a><a name="String"></a><span class='hs-comment'>-- of type 'String'.</span>
<a name="line-1397"></a><a name="String"></a><span class='hs-comment'>--</span>
<a name="line-1398"></a><a name="String"></a><span class='hs-comment'>-- See "Data.List" for operations on lists.</span>
<a name="line-1399"></a><a name="String"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<a name="line-1400"></a>
<a name="line-1401"></a><a name="unsafeChr"></a><span class='hs-definition'>unsafeChr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Char</span>
<a name="line-1402"></a><span class='hs-definition'>unsafeChr</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>i</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>chr</span><span class='hs-cpp'>#</span> <span class='hs-varid'>i</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1403"></a>
<a name="line-1404"></a><a name="ord"></a><span class='hs-comment'>-- | The 'Prelude.fromEnum' method restricted to the type 'Data.Char.Char'.</span>
<a name="line-1405"></a><span class='hs-definition'>ord</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Char</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1406"></a><span class='hs-definition'>ord</span> <span class='hs-layout'>(</span><span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-varid'>c</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>ord</span><span class='hs-cpp'>#</span> <span class='hs-varid'>c</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1407"></a>
<a name="line-1408"></a><a name="eqString"></a><span class='hs-comment'>-- | This 'String' equality predicate is used when desugaring</span>
<a name="line-1409"></a><span class='hs-comment'>-- pattern-matches against strings.</span>
<a name="line-1410"></a><span class='hs-definition'>eqString</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1411"></a><span class='hs-definition'>eqString</span> <span class='hs-conid'>[]</span>       <span class='hs-conid'>[]</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1412"></a><span class='hs-definition'>eqString</span> <span class='hs-layout'>(</span><span class='hs-varid'>c1</span><span class='hs-conop'>:</span><span class='hs-varid'>cs1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>c2</span><span class='hs-conop'>:</span><span class='hs-varid'>cs2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>c1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>c2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>cs1</span> <span class='hs-varop'>`eqString`</span> <span class='hs-varid'>cs2</span>
<a name="line-1413"></a><span class='hs-definition'>eqString</span> <span class='hs-keyword'>_</span>        <span class='hs-keyword'>_</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1414"></a>
<a name="line-1415"></a><span class='hs-comment'>{-# RULES "eqString" (==) = eqString #-}</span>
<a name="line-1416"></a><span class='hs-comment'>-- eqString also has a BuiltInRule in GHC.Core.Opt.ConstantFold:</span>
<a name="line-1417"></a><span class='hs-comment'>--      eqString (unpackCString# (Lit s1)) (unpackCString# (Lit s2)) = s1==s2</span>
<a name="line-1418"></a>
<a name="line-1419"></a>
<a name="line-1420"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1421"></a><span class='hs-comment'>-- 'Int' related definitions</span>
<a name="line-1422"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1423"></a>
<a name="line-1424"></a><a name="maxInt"></a><span class='hs-definition'>maxInt</span><span class='hs-layout'>,</span> <span class='hs-varid'>minInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-1425"></a>
<a name="line-1426"></a><span class='hs-comment'>{- Seems clumsy. Should perhaps put minInt and MaxInt directly into MachDeps.h -}</span>
<a name="line-1427"></a><span class='hs-cpp'>#if WORD_SIZE_IN_BITS == 31</span>
<a name="line-1428"></a><a name="minInt"></a><span class='hs-definition'>minInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>0x40000000</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1429"></a><span class='hs-definition'>maxInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-num'>0x3FFFFFFF</span><span class='hs-cpp'>#</span>
<a name="line-1430"></a><span class='hs-cpp'>#elif WORD_SIZE_IN_BITS == 32</span>
<a name="line-1431"></a><span class='hs-definition'>minInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>0x80000000</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1432"></a><span class='hs-definition'>maxInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-num'>0x7FFFFFFF</span><span class='hs-cpp'>#</span>
<a name="line-1433"></a><span class='hs-cpp'>#else</span>
<a name="line-1434"></a><span class='hs-definition'>minInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>0x8000000000000000</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1435"></a><span class='hs-definition'>maxInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-num'>0x7FFFFFFFFFFFFFFF</span><span class='hs-cpp'>#</span>
<a name="line-1436"></a><span class='hs-cpp'>#endif</span>
<a name="line-1437"></a>
<a name="line-1438"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1439"></a><span class='hs-comment'>-- The function type</span>
<a name="line-1440"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1441"></a>
<a name="line-1442"></a><a name="id"></a><span class='hs-comment'>-- | Identity function.</span>
<a name="line-1443"></a><span class='hs-comment'>--</span>
<a name="line-1444"></a><span class='hs-comment'>-- &gt; id x = x</span>
<a name="line-1445"></a><span class='hs-definition'>id</span>                      <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1446"></a><span class='hs-definition'>id</span> <span class='hs-varid'>x</span>                    <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>x</span>
<a name="line-1447"></a>
<a name="line-1448"></a><span class='hs-comment'>-- Assertion function.  This simply ignores its boolean argument.</span>
<a name="line-1449"></a><span class='hs-comment'>-- The compiler may rewrite it to @('assertError' line)@.</span>
<a name="line-1450"></a>
<a name="line-1451"></a><span class='hs-comment'>-- | If the first argument evaluates to 'True', then the result is the</span>
<a name="line-1452"></a><span class='hs-comment'>-- second argument.  Otherwise an 'Control.Exception.AssertionFailed' exception</span>
<a name="line-1453"></a><span class='hs-comment'>-- is raised, containing a 'String' with the source file and line number of the</span>
<a name="line-1454"></a><span class='hs-comment'>-- call to 'assert'.</span>
<a name="line-1455"></a><span class='hs-comment'>--</span>
<a name="line-1456"></a><span class='hs-comment'>-- Assertions can normally be turned on or off with a compiler flag</span>
<a name="line-1457"></a><span class='hs-comment'>-- (for GHC, assertions are normally on unless optimisation is turned on</span>
<a name="line-1458"></a><span class='hs-comment'>-- with @-O@ or the @-fignore-asserts@</span>
<a name="line-1459"></a><span class='hs-comment'>-- option is given).  When assertions are turned off, the first</span>
<a name="line-1460"></a><span class='hs-comment'>-- argument to 'assert' is ignored, and the second argument is</span>
<a name="line-1461"></a><span class='hs-comment'>-- returned as the result.</span>
<a name="line-1462"></a>
<a name="line-1463"></a><a name="assert"></a><span class='hs-comment'>--      SLPJ: in 5.04 etc 'assert' is in GHC.Prim,</span>
<a name="line-1464"></a><span class='hs-comment'>--      but from Template Haskell onwards it's simply</span>
<a name="line-1465"></a><span class='hs-comment'>--      defined here in Base.hs</span>
<a name="line-1466"></a><span class='hs-definition'>assert</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1467"></a><span class='hs-definition'>assert</span> <span class='hs-sel'>_pred</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-1468"></a>
<a name="line-1469"></a><a name="breakpoint"></a><span class='hs-definition'>breakpoint</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1470"></a><span class='hs-definition'>breakpoint</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-1471"></a>
<a name="line-1472"></a><a name="breakpointCond"></a><span class='hs-definition'>breakpointCond</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1473"></a><span class='hs-definition'>breakpointCond</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-1474"></a>
<a name="line-1475"></a><a name="Opaque"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Opaque</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-conid'>O</span> <span class='hs-varid'>a</span>
<a name="line-1476"></a><a name="const"></a><span class='hs-comment'>-- | @const x@ is a unary function which evaluates to @x@ for all inputs.</span>
<a name="line-1477"></a><span class='hs-comment'>--</span>
<a name="line-1478"></a><span class='hs-comment'>-- &gt;&gt;&gt; const 42 "hello"</span>
<a name="line-1479"></a><span class='hs-comment'>-- 42</span>
<a name="line-1480"></a><span class='hs-comment'>--</span>
<a name="line-1481"></a><span class='hs-comment'>-- &gt;&gt;&gt; map (const 42) [0..3]</span>
<a name="line-1482"></a><span class='hs-comment'>-- [42,42,42,42]</span>
<a name="line-1483"></a><span class='hs-definition'>const</span>                   <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1484"></a><span class='hs-definition'>const</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>x</span>
<a name="line-1485"></a>
<a name="line-1486"></a><a name="."></a><span class='hs-comment'>-- | Function composition.</span>
<a name="line-1487"></a><span class='hs-comment'>{-# INLINE (.) #-}</span>
<a name="line-1488"></a><span class='hs-comment'>-- Make sure it has TWO args only on the left, so that it inlines</span>
<a name="line-1489"></a><span class='hs-comment'>-- when applied to two functions, even if there is no final argument</span>
<a name="line-1490"></a><span class='hs-layout'>(</span><span class='hs-varop'>.</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span>
<a name="line-1491"></a><span class='hs-layout'>(</span><span class='hs-varop'>.</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>g</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1492"></a>
<a name="line-1493"></a><a name="flip"></a><span class='hs-comment'>-- | @'flip' f@ takes its (first) two arguments in the reverse order of @f@.</span>
<a name="line-1494"></a><span class='hs-comment'>--</span>
<a name="line-1495"></a><span class='hs-comment'>-- &gt;&gt;&gt; flip (++) "hello" "world"</span>
<a name="line-1496"></a><span class='hs-comment'>-- "worldhello"</span>
<a name="line-1497"></a><span class='hs-definition'>flip</span>                    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span>
<a name="line-1498"></a><span class='hs-definition'>flip</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>              <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>f</span> <span class='hs-varid'>y</span> <span class='hs-varid'>x</span>
<a name="line-1499"></a>
<a name="line-1500"></a><a name="$"></a><span class='hs-comment'>-- | Application operator.  This operator is redundant, since ordinary</span>
<a name="line-1501"></a><span class='hs-comment'>-- application @(f x)@ means the same as @(f '$' x)@. However, '$' has</span>
<a name="line-1502"></a><span class='hs-comment'>-- low, right-associative binding precedence, so it sometimes allows</span>
<a name="line-1503"></a><span class='hs-comment'>-- parentheses to be omitted; for example:</span>
<a name="line-1504"></a><span class='hs-comment'>--</span>
<a name="line-1505"></a><span class='hs-comment'>-- &gt; f $ g $ h x  =  f (g (h x))</span>
<a name="line-1506"></a><span class='hs-comment'>--</span>
<a name="line-1507"></a><span class='hs-comment'>-- It is also useful in higher-order situations, such as @'map' ('$' 0) xs@,</span>
<a name="line-1508"></a><span class='hs-comment'>-- or @'Data.List.zipWith' ('$') fs xs@.</span>
<a name="line-1509"></a><span class='hs-comment'>--</span>
<a name="line-1510"></a><span class='hs-comment'>-- Note that @('$')@ is levity-polymorphic in its result type, so that</span>
<a name="line-1511"></a><span class='hs-comment'>-- @foo '$' True@ where @foo :: Bool -&gt; Int#@ is well-typed.</span>
<a name="line-1512"></a><span class='hs-comment'>{-# INLINE ($) #-}</span>
<a name="line-1513"></a><span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>r</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TYPE</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-1514"></a><span class='hs-definition'>f</span> <span class='hs-varop'>$</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>f</span> <span class='hs-varid'>x</span>
<a name="line-1515"></a>
<a name="line-1516"></a><span class='hs-comment'>-- | Strict (call-by-value) application operator. It takes a function and an</span>
<a name="line-1517"></a><span class='hs-comment'>-- argument, evaluates the argument to weak head normal form (WHNF), then calls</span>
<a name="line-1518"></a><span class='hs-comment'>-- the function with that value.</span>
<a name="line-1519"></a>
<a name="line-1520"></a><a name="$!"></a><span class='hs-layout'>(</span><span class='hs-varop'>$!</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>r</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TYPE</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-1521"></a><span class='hs-comment'>{-# INLINE ($!) #-}</span>
<a name="line-1522"></a><span class='hs-definition'>f</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>vx</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>in</span> <span class='hs-varid'>f</span> <span class='hs-varid'>vx</span>  <span class='hs-comment'>-- see #2273</span>
<a name="line-1523"></a>
<a name="line-1524"></a><a name="until"></a><span class='hs-comment'>-- | @'until' p f@ yields the result of applying @f@ until @p@ holds.</span>
<a name="line-1525"></a><span class='hs-definition'>until</span>                   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1526"></a><span class='hs-definition'>until</span> <span class='hs-varid'>p</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span>
<a name="line-1527"></a>  <span class='hs-keyword'>where</span>
<a name="line-1528"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
<a name="line-1529"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1530"></a>
<a name="line-1531"></a><a name="asTypeOf"></a><span class='hs-comment'>-- | 'asTypeOf' is a type-restricted version of 'const'.  It is usually</span>
<a name="line-1532"></a><span class='hs-comment'>-- used as an infix operator, and its typing forces its first argument</span>
<a name="line-1533"></a><span class='hs-comment'>-- (which is usually overloaded) to have the same type as the second.</span>
<a name="line-1534"></a><span class='hs-definition'>asTypeOf</span>                <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1535"></a><span class='hs-definition'>asTypeOf</span>                <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>const</span>
<a name="line-1536"></a>
<a name="line-1537"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1538"></a><span class='hs-comment'>-- Functor/Applicative/Monad instances for IO</span>
<a name="line-1539"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1540"></a>
<a name="line-1541"></a><a name="instance%20Functor%20IO"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1542"></a><a name="instance%20Functor%20IO"></a><span class='hs-keyword'>instance</span>  <span class='hs-conid'>Functor</span> <span class='hs-conid'>IO</span> <span class='hs-keyword'>where</span>
<a name="line-1543"></a>   <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-layout'>(</span><span class='hs-varid'>pure</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span>
<a name="line-1544"></a>
<a name="line-1545"></a><a name="instance%20Applicative%20IO"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1546"></a><a name="instance%20Applicative%20IO"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>IO</span> <span class='hs-keyword'>where</span>
<a name="line-1547"></a>    <span class='hs-comment'>{-# INLINE pure #-}</span>
<a name="line-1548"></a>    <span class='hs-comment'>{-# INLINE (*&gt;) #-}</span>
<a name="line-1549"></a>    <span class='hs-comment'>{-# INLINE liftA2 #-}</span>
<a name="line-1550"></a>    <span class='hs-varid'>pure</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>returnIO</span>
<a name="line-1551"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>*&gt;</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>thenIO</span>
<a name="line-1552"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ap</span>
<a name="line-1553"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftM2</span>
<a name="line-1554"></a>
<a name="line-1555"></a><a name="instance%20Monad%20IO"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1556"></a><a name="instance%20Monad%20IO"></a><span class='hs-keyword'>instance</span>  <span class='hs-conid'>Monad</span> <span class='hs-conid'>IO</span>  <span class='hs-keyword'>where</span>
<a name="line-1557"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;)   #-}</span>
<a name="line-1558"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;=)  #-}</span>
<a name="line-1559"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>*&gt;</span><span class='hs-layout'>)</span>
<a name="line-1560"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;=</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bindIO</span>
<a name="line-1561"></a>
<a name="line-1562"></a><a name="instance%20Alternative%20IO"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-1563"></a><a name="instance%20Alternative%20IO"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Alternative</span> <span class='hs-conid'>IO</span> <span class='hs-keyword'>where</span>
<a name="line-1564"></a>    <span class='hs-varid'>empty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failIO</span> <span class='hs-str'>"mzero"</span>
<a name="line-1565"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;|&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mplusIO</span>
<a name="line-1566"></a>
<a name="line-1567"></a><a name="instance%20MonadPlus%20IO%20returnIO%20::%20a%20-%3e%20IO%20a%20returnIO%20x%20=%20IO%20(%5c%20s%20-%3e%20("></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-1568"></a><a name="instance%20MonadPlus%20IO%20returnIO%20::%20a%20-%3e%20IO%20a%20returnIO%20x%20=%20IO%20(%5c%20s%20-%3e%20("></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>MonadPlus</span> <span class='hs-conid'>IO</span>
<a name="line-1569"></a>
<a name="line-1570"></a><a name="returnIO"></a><span class='hs-definition'>returnIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<a name="line-1571"></a><span class='hs-definition'>returnIO</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1572"></a>
<a name="line-1573"></a><a name="bindIO"></a><span class='hs-definition'>bindIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span>
<a name="line-1574"></a><span class='hs-definition'>bindIO</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>m</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>new_s</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unIO</span> <span class='hs-layout'>(</span><span class='hs-varid'>k</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_s</span><span class='hs-layout'>)</span>
<a name="line-1575"></a>
<a name="line-1576"></a><a name="thenIO"></a><span class='hs-definition'>thenIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span>
<a name="line-1577"></a><span class='hs-definition'>thenIO</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>m</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>new_s</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unIO</span> <span class='hs-varid'>k</span> <span class='hs-varid'>new_s</span><span class='hs-layout'>)</span>
<a name="line-1578"></a>
<a name="line-1579"></a><a name="failIO"></a><span class='hs-comment'>-- Note that it is import that we do not SOURCE import this as</span>
<a name="line-1580"></a><span class='hs-comment'>-- its demand signature encodes knowledge of its bottoming</span>
<a name="line-1581"></a><span class='hs-comment'>-- behavior, which can expose useful simplifications. See</span>
<a name="line-1582"></a><span class='hs-comment'>-- #16588.</span>
<a name="line-1583"></a><span class='hs-definition'>failIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<a name="line-1584"></a><span class='hs-definition'>failIO</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-varid'>raiseIO</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkUserError</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1585"></a>
<a name="line-1586"></a><a name="unIO"></a><span class='hs-definition'>unIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>State</span><span class='hs-cpp'>#</span> <span class='hs-conid'>RealWorld</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-conid'>State</span><span class='hs-cpp'>#</span> <span class='hs-conid'>RealWorld</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1587"></a><span class='hs-definition'>unIO</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span>
<a name="line-1588"></a>
<a name="line-1589"></a><a name="getTag"></a><span class='hs-comment'>{- |
<a name="line-1590"></a>Returns the tag of a constructor application; this function is used
<a name="line-1591"></a>by the deriving code for Eq, Ord and Enum.
<a name="line-1592"></a>-}</span>
<a name="line-1593"></a><span class='hs-comment'>{-# INLINE getTag #-}</span>
<a name="line-1594"></a><span class='hs-definition'>getTag</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-1595"></a><span class='hs-definition'>getTag</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataToTag</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span>
<a name="line-1596"></a>
<a name="line-1597"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1598"></a><span class='hs-comment'>-- Numeric primops</span>
<a name="line-1599"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1600"></a>
<a name="line-1601"></a><span class='hs-comment'>-- Definitions of the boxed PrimOps; these will be</span>
<a name="line-1602"></a><span class='hs-comment'>-- used in the case of partial applications, etc.</span>
<a name="line-1603"></a>
<a name="line-1604"></a><span class='hs-comment'>-- See Note [INLINE division wrappers]</span>
<a name="line-1605"></a><span class='hs-comment'>{-# INLINE quotInt #-}</span>
<a name="line-1606"></a><span class='hs-comment'>{-# INLINE remInt #-}</span>
<a name="line-1607"></a><span class='hs-comment'>{-# INLINE divInt #-}</span>
<a name="line-1608"></a><span class='hs-comment'>{-# INLINE modInt #-}</span>
<a name="line-1609"></a><span class='hs-comment'>{-# INLINE quotRemInt #-}</span>
<a name="line-1610"></a><span class='hs-comment'>{-# INLINE divModInt #-}</span>
<a name="line-1611"></a>
<a name="line-1612"></a><a name="quotInt"></a><span class='hs-definition'>quotInt</span><span class='hs-layout'>,</span> <span class='hs-varid'>remInt</span><span class='hs-layout'>,</span> <span class='hs-varid'>divInt</span><span class='hs-layout'>,</span> <span class='hs-varid'>modInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1613"></a><a name="quotInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`quotInt`</span>  <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1614"></a><a name="remInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`remInt`</span>   <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>remInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span>  <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1615"></a><a name="divInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`divInt`</span>   <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>divInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span>  <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1616"></a><a name="modInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`modInt`</span>   <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>modInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span>  <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1617"></a>
<a name="line-1618"></a><a name="quotRemInt"></a><span class='hs-definition'>quotRemInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<a name="line-1619"></a><a name="quotRemInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`quotRemInt`</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotRemInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>of</span>
<a name="line-1620"></a>                             <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1621"></a>                                 <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-1622"></a>
<a name="line-1623"></a><a name="divModInt"></a><span class='hs-definition'>divModInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<a name="line-1624"></a><a name="divModInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`divModInt`</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>divModInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>of</span>
<a name="line-1625"></a>                            <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-1626"></a>
<a name="line-1627"></a><span class='hs-definition'>divModInt</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1628"></a><a name="x"></a><span class='hs-definition'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>`</span><span class='hs-varid'>divModInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span>
<a name="line-1629"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>&gt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-varop'>&lt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-1630"></a>                                    <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotRemInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-keyword'>of</span>
<a name="line-1631"></a>                                      <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-varop'>+#</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-varop'>+#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1632"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>&lt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-varop'>&gt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-1633"></a>                                    <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>+#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotRemInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-keyword'>of</span>
<a name="line-1634"></a>                                      <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-varop'>+#</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1635"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                                <span class='hs-keyglyph'>=</span>
<a name="line-1636"></a>                                    <span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotRemInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span>
<a name="line-1637"></a>
<a name="line-1638"></a><span class='hs-comment'>{- Note [INLINE division wrappers]
<a name="line-1639"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1640"></a>The Int division functions such as 'quotRemInt' and 'divModInt' have
<a name="line-1641"></a>been manually worker/wrappered, presumably because they construct
<a name="line-1642"></a>*nested* products.
<a name="line-1643"></a>We intend to preserve the exact worker/wrapper split, hence we mark
<a name="line-1644"></a>the wrappers INLINE (#19267). That makes sure the optimiser doesn't
<a name="line-1645"></a>accidentally inline the worker into the wrapper, undoing the manual
<a name="line-1646"></a>split again.
<a name="line-1647"></a>-}</span>
<a name="line-1648"></a>
<a name="line-1649"></a><span class='hs-comment'>-- Wrappers for the shift operations.  The uncheckedShift# family are</span>
<a name="line-1650"></a><span class='hs-comment'>-- undefined when the amount being shifted by is greater than the size</span>
<a name="line-1651"></a><span class='hs-comment'>-- in bits of Int#, so these wrappers perform a check and return</span>
<a name="line-1652"></a><span class='hs-comment'>-- either zero or -1 appropriately.</span>
<a name="line-1653"></a><span class='hs-comment'>--</span>
<a name="line-1654"></a><span class='hs-comment'>-- Note that these wrappers still produce undefined results when the</span>
<a name="line-1655"></a><span class='hs-comment'>-- second argument (the shift amount) is negative.</span>
<a name="line-1656"></a>
<a name="line-1657"></a><a name="shiftL"></a><span class='hs-comment'>-- | Shift the argument left by the specified number of bits</span>
<a name="line-1658"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1659"></a><span class='hs-definition'>shiftL</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Word</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word</span><span class='hs-cpp'>#</span>
<a name="line-1660"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>shiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span><span class='hs-cpp'>##</span>
<a name="line-1661"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1662"></a>
<a name="line-1663"></a><a name="shiftRL"></a><span class='hs-comment'>-- | Shift the argument right by the specified number of bits</span>
<a name="line-1664"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1665"></a><span class='hs-comment'>-- The "RL" means "right, logical" (as opposed to RA for arithmetic)</span>
<a name="line-1666"></a><span class='hs-comment'>-- (although an arithmetic right shift wouldn't make sense for Word#)</span>
<a name="line-1667"></a><span class='hs-definition'>shiftRL</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Word</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word</span><span class='hs-cpp'>#</span>
<a name="line-1668"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>shiftRL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span><span class='hs-cpp'>##</span>
<a name="line-1669"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedShiftRL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1670"></a>
<a name="line-1671"></a><a name="iShiftL"></a><span class='hs-comment'>-- | Shift the argument left by the specified number of bits</span>
<a name="line-1672"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1673"></a><span class='hs-definition'>iShiftL</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-1674"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>iShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-1675"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1676"></a>
<a name="line-1677"></a><a name="iShiftRA"></a><span class='hs-comment'>-- | Shift the argument right (signed) by the specified number of bits</span>
<a name="line-1678"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1679"></a><span class='hs-comment'>-- The "RA" means "right, arithmetic" (as opposed to RL for logical)</span>
<a name="line-1680"></a><span class='hs-definition'>iShiftRA</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-1681"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>iShiftRA</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>&lt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1682"></a>                                                          <span class='hs-keyword'>then</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1683"></a>                                                          <span class='hs-keyword'>else</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-1684"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftRA</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1685"></a>
<a name="line-1686"></a><a name="iShiftRL"></a><span class='hs-comment'>-- | Shift the argument right (unsigned) by the specified number of bits</span>
<a name="line-1687"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1688"></a><span class='hs-comment'>-- The "RL" means "right, logical" (as opposed to RA for arithmetic)</span>
<a name="line-1689"></a><span class='hs-definition'>iShiftRL</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-1690"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>iShiftRL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-1691"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftRL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1692"></a>
<a name="line-1693"></a><span class='hs-comment'>-- Rules for C strings (the functions themselves are now in GHC.CString)</span>
<a name="line-1694"></a><span class='hs-comment'>{-# RULES
<a name="line-1695"></a>"unpack"       [~1] forall a   . unpackCString# a             = build (unpackFoldrCString# a)
<a name="line-1696"></a>"unpack-list"  [1]  forall a   . unpackFoldrCString# a (:) [] = unpackCString# a
<a name="line-1697"></a>"unpack-append"     forall a n . unpackFoldrCString# a (:) n  = unpackAppendCString# a n
<a name="line-1698"></a>
<a name="line-1699"></a>"unpack-utf8"       [~1] forall a   . unpackCStringUtf8# a             = build (unpackFoldrCStringUtf8# a)
<a name="line-1700"></a>"unpack-list-utf8"  [1]  forall a   . unpackFoldrCStringUtf8# a (:) [] = unpackCStringUtf8# a
<a name="line-1701"></a>"unpack-append-utf8"     forall a n . unpackFoldrCStringUtf8# a (:) n  = unpackAppendCStringUtf8# a n
<a name="line-1702"></a>
<a name="line-1703"></a>-- There's a built-in rule (in GHC.Core.Op.ConstantFold) for
<a name="line-1704"></a>--      unpackFoldr "foo" c (unpackFoldr "baz" c n)  =  unpackFoldr "foobaz" c n
<a name="line-1705"></a>
<a name="line-1706"></a>-- See also the Note [String literals in GHC] in CString.hs
<a name="line-1707"></a>
<a name="line-1708"></a>  #-}</span>
</pre></body>
</html>

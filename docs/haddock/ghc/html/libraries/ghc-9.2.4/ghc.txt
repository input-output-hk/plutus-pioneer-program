-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The GHC API
--   
--   GHC's functionality can be useful for more things than just compiling
--   Haskell programs. Important use cases are programs that analyse (and
--   perhaps transform) Haskell code. Others include loading Haskell code
--   dynamically in a GHCi-like manner. For this reason, a lot of GHC's
--   functionality is made available through this package.
--   
--   See
--   <a>https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler</a>
--   for more information.
@package ghc
@version 9.2.4

module GHC.Platform.Constants
data PlatformConstants
PlatformConstants :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> !Integer -> !Integer -> !Integer -> PlatformConstants
[pc_CONTROL_GROUP_CONST_291] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_STD_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_PROF_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCK_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCKS_PER_MBLOCK] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TICKY_BIN_COUNT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR7] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR8] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR9] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR10] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rL1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCCCS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentTSO] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentNursery] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpAlloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgEagerBlackholeInfo] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCEnter1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCFun] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_Capability_r] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_start] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_free] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_blocks] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_flags] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_CostCentreStack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ldvw] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSMPThunkHeader] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_registeredp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_link] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_entry_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgUpdateFrame_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_size] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSmallMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgSmallMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgArrBytes_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgArrBytes_bytes] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_alloc_limit] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_cccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_stackobj] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_sp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_stack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgUpdateFrame_updatee] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgFunInfoExtraRev] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_SELECTEE_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_AP_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_PAYLOAD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MUT_ARR_PTRS_CARD_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_C_STACK_BYTES] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_STACK_WORDS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_AP_STACK_SPLIM] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_WORD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CINT_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_LONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BITMAP_BITS_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TAG_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_LDV_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_ILDV_CREATE_MASK] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_CREATE] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_USE] :: PlatformConstants -> !Integer
parseConstantsHeader :: FilePath -> IO PlatformConstants
instance GHC.Classes.Eq GHC.Platform.Constants.PlatformConstants
instance GHC.Read.Read GHC.Platform.Constants.PlatformConstants
instance GHC.Show.Show GHC.Platform.Constants.PlatformConstants


-- | Custom GHC <a>Prelude</a>
--   
--   This module serves as a replacement for the <a>Prelude</a> module and
--   abstracts over differences between the bootstrapping GHC version, and
--   may also provide a common default vocabulary.
module GHC.Prelude

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++
seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a', 'b']
--   [(1,'a'),(2,'b')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `rem`
infixl 7 `quot`
infixl 7 `mod`
infixl 7 `div`

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>
infixl 1 >>=

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 7 *
infixl 6 +
infixl 6 -
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>Â±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*
infixl 4 *>
infixl 4 <*>

-- | The Foldable class represents data structures that can be reduced to a
--   summary value one element at a time. Strict left-associative folds are
--   a good fit for space-efficient reduction, while lazy right-associative
--   folds are a good fit for corecursive iteration, or for folds that
--   short-circuit after processing an initial subsequence of the
--   structure's elements.
--   
--   Instances can be derived automatically by enabling the
--   <tt>DeriveFoldable</tt> extension. For example, a derived instance for
--   a binary tree might be:
--   
--   <pre>
--   {-# LANGUAGE DeriveFoldable #-}
--   data Tree a = Empty
--               | Leaf a
--               | Node (Tree a) a (Tree a)
--       deriving Foldable
--   </pre>
--   
--   A more detailed description can be found in the <b>Overview</b>
--   section of <a>Data.Foldable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Foldable#laws</a>.
class Foldable (t :: TYPE LiftedRep -> Type)

-- | Map each element of the structure into a monoid, and combine the
--   results with <tt>(<a>&lt;&gt;</a>)</tt>. This fold is
--   right-associative and lazy in the accumulator. For strict
--   left-associative folds consider <a>foldMap'</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Sum [1, 3, 5]
--   Sum {getSum = 9}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Product [1, 3, 5]
--   Product {getProduct = 15}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap (replicate 3) [1, 2, 3]
--   [1,1,1,2,2,2,3,3,3]
--   </pre>
--   
--   When a Monoid's <tt>(<a>&lt;&gt;</a>)</tt> is lazy in its second
--   argument, <a>foldMap</a> can return a result even from an unbounded
--   structure. For example, lazy accumulation enables
--   <a>Data.ByteString.Builder</a> to efficiently serialise large data
--   structures and produce the output incrementally:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy as L
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Builder as B
--   
--   &gt;&gt;&gt; let bld :: Int -&gt; B.Builder; bld i = B.intDec i &lt;&gt; B.word8 0x20
--   
--   &gt;&gt;&gt; let lbs = B.toLazyByteString $ foldMap bld [0..]
--   
--   &gt;&gt;&gt; L.take 64 lbs
--   "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"
--   </pre>
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   â ï¸ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain &lt;math&gt;
--   elements long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to Weak Head Normal
--   Form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite structure to a single strict result (e.g. <a>sum</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be transformed to
--   structures of the <i>same shape</i> by performing an
--   <a>Applicative</a> (or, therefore, <a>Monad</a>) action on each
--   element from left to right.
--   
--   A more detailed description of what <i>same shape</i> means, the
--   various methods, how traversals are constructed, and example advanced
--   use-cases can be found in the <b>Overview</b> section of
--   <a>Data.Traversable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Traversable#laws</a>.
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   In the first two examples we show each evaluated action mapping to the
--   output structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse Just [1,2,3,4]
--   Just [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   In the next examples, we show that <a>Nothing</a> and <a>Left</a>
--   values short circuit the created structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
--   Left 0
--   </pre>
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   For the first two examples we show sequenceA fully evaluating a a
--   structure and collecting the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3]
--   Right [1,2,3]
--   </pre>
--   
--   The next two example show <a>Nothing</a> and <a>Just</a> will short
--   circuit the resulting structure if present in the input. For more
--   context, check the <a>Traversable</a> instances for <a>Either</a> and
--   <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3, Nothing]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3, Left 4]
--   Left 4
--   </pre>
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
class Semigroup a

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
--   
--   See <a>Data.List</a> for operations on lists.
type String = [Char]
data Char
data Double
data Float
data Int
data Integer

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer
data IO a
data Word

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOException</a> instead of returning a
--   result. For a more general type of exception, including also those
--   that arise in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Construct an <a>IOException</a> value with a string describing the
--   error. The <tt>fail</tt> method of the <a>IO</a> instance of the
--   <a>Monad</a> class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]
odd :: Integral a => a -> Bool

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a
even :: Integral a => a -> Bool

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of the function
--   applied to corresponding elements, analogous to <a>zipWith</a>. It is
--   capable of list fusion, but it is restricted to its first list
--   argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   For example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; take 3 []
--   []
--   
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   
--   &gt;&gt;&gt; tail [1]
--   []
--   
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>
tail :: [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanl1 (+) [1..]
--   * Hangs forever *
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   
--   &gt;&gt;&gt; scanl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <pre>
--   &gt;&gt;&gt; take 20 $ repeat 17
--   [17,17,17,17,17,17,17,17,17...
--   </pre>
repeat :: a -> [a]

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
last :: [a] -> a

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False...
--   
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63...
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
init :: [a] -> [a]

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   
--   &gt;&gt;&gt; head [1..]
--   1
--   
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>
head :: [a] -> a

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   
--   &gt;&gt;&gt; drop 3 []
--   []
--   
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   
--   &gt;&gt;&gt; take 20 $ cycle [42]
--   [42,42,42,42,42,42,42,42,42,42...
--   
--   &gt;&gt;&gt; take 20 $ cycle [2, 5, 7]
--   [2,5,7,2,5,7,2,5,7,2,5,7...
--   </pre>
cycle :: [a] -> [a]

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: forall (r :: RuntimeRep) (a :: TYPE r). [Char] -> a

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => [Char] -> a
(&&) :: Bool -> Bool -> Bool
not :: Bool -> Bool
(||) :: Bool -> Bool -> Bool

-- | The <a>FiniteBits</a> class denotes types with a finite, fixed number
--   of bits.
class Bits b => FiniteBits b

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Moreover, <a>finiteBitSize</a> is
--   total, in contrast to the deprecated <a>bitSize</a> function it
--   replaces.
--   
--   <pre>
--   <a>finiteBitSize</a> = <a>bitSize</a>
--   <a>bitSizeMaybe</a> = <a>Just</a> . <a>finiteBitSize</a>
--   </pre>
finiteBitSize :: FiniteBits b => b -> Int

-- | Count number of zero bits preceding the most significant set bit.
--   
--   <pre>
--   <a>countLeadingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   </pre>
--   
--   <a>countLeadingZeros</a> can be used to compute log base 2 via
--   
--   <pre>
--   logBase2 x = <a>finiteBitSize</a> x - 1 - <a>countLeadingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countLeadingZeros :: FiniteBits b => b -> Int

-- | Count number of zero bits following the least significant set bit.
--   
--   <pre>
--   <a>countTrailingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   <a>countTrailingZeros</a> . <a>negate</a> = <a>countTrailingZeros</a>
--   </pre>
--   
--   The related <a>find-first-set operation</a> can be expressed in terms
--   of <a>countTrailingZeros</a> as follows
--   
--   <pre>
--   findFirstSet x = 1 + <a>countTrailingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countTrailingZeros :: FiniteBits b => b -> Int

-- | The <a>Bits</a> class defines bitwise operations over integral types.
--   
--   <ul>
--   <li>Bits are numbered from 0 with bit 0 being the least significant
--   bit.</li>
--   </ul>
class Eq a => Bits a

-- | Bitwise "and"
(.&.) :: Bits a => a -> a -> a

-- | Bitwise "or"
(.|.) :: Bits a => a -> a -> a

-- | Bitwise "xor"
xor :: Bits a => a -> a -> a

-- | Reverse all the bits in the argument
complement :: Bits a => a -> a

-- | <tt><a>shift</a> x i</tt> shifts <tt>x</tt> left by <tt>i</tt> bits if
--   <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise. Right
--   shifts perform sign extension on signed number types; i.e. they fill
--   the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this unified <a>shift</a> or
--   <a>shiftL</a> and <a>shiftR</a>, depending on which is more convenient
--   for the type in question.
shift :: Bits a => a -> Int -> a

-- | <tt><a>rotate</a> x i</tt> rotates <tt>x</tt> left by <tt>i</tt> bits
--   if <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise.
--   
--   For unbounded types like <a>Integer</a>, <a>rotate</a> is equivalent
--   to <a>shift</a>.
--   
--   An instance can define either this unified <a>rotate</a> or
--   <a>rotateL</a> and <a>rotateR</a>, depending on which is more
--   convenient for the type in question.
rotate :: Bits a => a -> Int -> a

-- | <a>zeroBits</a> is the value with all bits unset.
--   
--   The following laws ought to hold (for all valid bit indices
--   <tt><i>n</i></tt>):
--   
--   <ul>
--   <li><pre><a>clearBit</a> <a>zeroBits</a> <i>n</i> ==
--   <a>zeroBits</a></pre></li>
--   <li><pre><a>setBit</a> <a>zeroBits</a> <i>n</i> == <a>bit</a>
--   <i>n</i></pre></li>
--   <li><pre><a>testBit</a> <a>zeroBits</a> <i>n</i> == False</pre></li>
--   <li><pre><a>popCount</a> <a>zeroBits</a> == 0</pre></li>
--   </ul>
--   
--   This method uses <tt><a>clearBit</a> (<a>bit</a> 0) 0</tt> as its
--   default implementation (which ought to be equivalent to
--   <a>zeroBits</a> for types which possess a 0th bit).
zeroBits :: Bits a => a

-- | <tt>bit <i>i</i></tt> is a value with the <tt><i>i</i></tt>th bit set
--   and all other bits clear.
--   
--   Can be implemented using <a>bitDefault</a> if <tt>a</tt> is also an
--   instance of <a>Num</a>.
--   
--   See also <a>zeroBits</a>.
bit :: Bits a => Int -> a

-- | <tt>x `setBit` i</tt> is the same as <tt>x .|. bit i</tt>
setBit :: Bits a => a -> Int -> a

-- | <tt>x `clearBit` i</tt> is the same as <tt>x .&amp;. complement (bit
--   i)</tt>
clearBit :: Bits a => a -> Int -> a

-- | <tt>x `complementBit` i</tt> is the same as <tt>x `xor` bit i</tt>
complementBit :: Bits a => a -> Int -> a

-- | <tt>x `testBit` i</tt> is the same as <tt>x .&amp;. bit n /= 0</tt>
--   
--   In other words it returns True if the bit at offset @n is set.
--   
--   Can be implemented using <a>testBitDefault</a> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
testBit :: Bits a => a -> Int -> Bool

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Returns Nothing for types that do
--   not have a fixed bitsize, like <a>Integer</a>.
bitSizeMaybe :: Bits a => a -> Maybe Int

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. The function <a>bitSize</a> is
--   undefined for types that do not have a fixed bitsize, like
--   <a>Integer</a>.
--   
--   Default implementation based upon <a>bitSizeMaybe</a> provided since
--   4.12.0.0.
bitSize :: Bits a => a -> Int

-- | Return <a>True</a> if the argument is a signed type. The actual value
--   of the argument is ignored
isSigned :: Bits a => a -> Bool

-- | Shift the argument left by the specified number of bits. The result is
--   undefined for negative shift amounts and shift amounts greater or
--   equal to the <a>bitSize</a>.
--   
--   Defaults to <a>shiftL</a> unless defined explicitly by an instance.
unsafeShiftL :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits, which
--   must be non-negative and smaller than the number of bits in the type.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   Defaults to <a>shiftR</a> unless defined explicitly by an instance.
unsafeShiftR :: Bits a => a -> Int -> a

-- | Rotate the argument left by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateR</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateL :: Bits a => a -> Int -> a

-- | Rotate the argument right by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateL</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateR :: Bits a => a -> Int -> a

-- | Return the number of set bits in the argument. This number is known as
--   the population count or the Hamming weight.
--   
--   Can be implemented using <a>popCountDefault</a> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
popCount :: Bits a => a -> Int
infixl 6 `xor`
infixl 8 `shift`
infixl 8 `rotateR`
infixl 8 `rotateL`
infixl 8 `rotate`
infixl 7 .&.
infixl 5 .|.

-- | Attempt to convert an <a>Integral</a> type <tt>a</tt> to an
--   <a>Integral</a> type <tt>b</tt> using the size of the types as
--   measured by <a>Bits</a> methods.
--   
--   A simpler version of this function is:
--   
--   <pre>
--   toIntegral :: (Integral a, Integral b) =&gt; a -&gt; Maybe b
--   toIntegral x
--     | toInteger x == y = Just (fromInteger y)
--     | otherwise        = Nothing
--     where
--       y = toInteger x
--   </pre>
--   
--   This version requires going through <a>Integer</a>, which can be
--   inefficient. However, <tt>toIntegralSized</tt> is optimized to allow
--   GHC to statically determine the relative type sizes (as measured by
--   <a>bitSizeMaybe</a> and <a>isSigned</a>) and avoid going through
--   <a>Integer</a> for many types. (The implementation uses
--   <a>fromIntegral</a>, which is itself optimized with rules for
--   <tt>base</tt> types but may go through <a>Integer</a> for some type
--   pairs.)
toIntegralSized :: (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b

-- | Default implementation for <a>testBit</a>.
--   
--   Note that: <tt>testBitDefault x i = (x .&amp;. bit i) /= 0</tt>
testBitDefault :: (Bits a, Num a) => a -> Int -> Bool

-- | Default implementation for <a>popCount</a>.
--   
--   This implementation is intentionally naive. Instances are expected to
--   provide an optimized implementation for their size.
popCountDefault :: (Bits a, Num a) => a -> Int

-- | Default implementation for <a>bit</a>.
--   
--   Note that: <tt>bitDefault i = 1 <a>shiftL</a> i</tt>
bitDefault :: (Bits a, Num a) => Int -> a
shiftL :: Bits a => a -> Int -> a
shiftR :: Bits a => a -> Int -> a

module GHC.Linker

module GHC.Data.UnionFind

-- | A variable which can be unified; alternately, this can be thought of
--   as an equivalence class with a distinguished representative.
newtype Point s a
Point :: STRef s (Link s a) -> Point s a

-- | Mutable write to a <a>Point</a>
writePoint :: Point s a -> Link s a -> ST s ()

-- | Read the current value of <a>Point</a>.
readPoint :: Point s a -> ST s (Link s a)

-- | The internal data structure for a <a>Point</a>, which either records
--   the representative element of an equivalence class, or a link to the
--   <a>Point</a> that actually stores the representative type.
data Link s a
Info :: {-# UNPACK #-} !STRef s Int -> {-# UNPACK #-} !STRef s a -> Link s a
Link :: {-# UNPACK #-} !Point s a -> Link s a

-- | Create a fresh equivalence class with one element.
fresh :: a -> ST s (Point s a)

-- | Flatten any chains of links, returning a <a>Point</a> which points
--   directly to the canonical representation.
repr :: Point s a -> ST s (Point s a)

-- | Return the canonical element of an equivalence class <a>Point</a>.
find :: Point s a -> ST s a

-- | Unify two equivalence classes, so that they share a canonical element.
--   Keeps the descriptor of point2.
union :: Point s a -> Point s a -> ST s ()

-- | Test if two points are in the same equivalence class.
equivalent :: Point s a -> Point s a -> ST s Bool
instance GHC.Classes.Eq (GHC.Data.UnionFind.Point s a)


-- | Monadic streams
module GHC.Data.Stream

-- | <tt>Stream m a b</tt> is a computation in some Monad <tt>m</tt> that
--   delivers a sequence of elements of type <tt>a</tt> followed by a
--   result of type <tt>b</tt>.
--   
--   More concretely, a value of type <tt>Stream m a b</tt> can be run
--   using <tt>runStreamInternal</tt> in the Monad <tt>m</tt>, and it
--   delivers either
--   
--   <ul>
--   <li>the final result: <tt>Done b</tt>, or</li>
--   <li><tt>Yield a str</tt> where <tt>a</tt> is the next element in the
--   stream, and <tt>str</tt> is the rest of the stream</li>
--   <li><tt>Effect mstr</tt> where <tt>mstr</tt> is some action running in
--   <tt>m</tt> which generates the rest of the stream.</li>
--   </ul>
--   
--   Stream is itself a Monad, and provides an operation <a>yield</a> that
--   produces a new element of the stream. This makes it convenient to turn
--   existing monadic computations into streams.
--   
--   The idea is that Stream is useful for making a monadic computation
--   that produces values from time to time. This can be used for knitting
--   together two complex monadic operations, so that the producer does not
--   have to produce all its values before the consumer starts consuming
--   them. We make the producer into a Stream, and the consumer pulls on
--   the stream each time it wants a new value.
--   
--   <a>Stream</a> is implemented in the "yoneda" style for efficiency. By
--   representing a stream in this manner <a>fmap</a> and <a>&gt;&gt;=</a>
--   operations are accumulated in the function parameters before being
--   applied once when the stream is destroyed. In the old implementation
--   each usage of <a>mapM</a> and <a>&gt;&gt;=</a> would traverse the
--   entire stream in order to apply the substitution at the leaves.
--   
--   The &gt;&gt;= operation for <a>Stream</a> was a hot-spot in the ticky
--   profile for the <a>ManyConstructors</a> test which called the
--   <tt>cg</tt> function many times in <tt>StgToCmm.hs</tt>
newtype Stream m a b
Stream :: (forall r' r. (a -> m r') -> (b -> StreamS m r' r) -> StreamS m r' r) -> Stream m a b
[runStreamInternal] :: Stream m a b -> forall r' r. (a -> m r') -> (b -> StreamS m r' r) -> StreamS m r' r
data StreamS m a b
Yield :: a -> StreamS m a b -> StreamS m a b
Done :: b -> StreamS m a b
Effect :: m (StreamS m a b) -> StreamS m a b
runStream :: Applicative m => Stream m r' r -> StreamS m r' r
yield :: Monad m => a -> Stream m a ()

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   â¢ Couldn't match type âIOâ with âStateT s IOâ
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a

-- | Turn a Stream into an ordinary list, by demanding all the elements.
collect :: Monad m => Stream m a () -> m [a]
consume :: (Monad m, Monad n) => Stream m a b -> (forall a. m a -> n a) -> (a -> n ()) -> n b

-- | Turn a list into a <a>Stream</a>, by yielding each element in turn.
fromList :: Monad m => [a] -> Stream m a ()

-- | Apply a function to each element of a <a>Stream</a>, lazily
map :: Monad m => (a -> b) -> Stream m a x -> Stream m b x

-- | Apply a monadic operation to each element of a <a>Stream</a>, lazily
mapM :: Monad m => (a -> m b) -> Stream m a x -> Stream m b x

-- | Note this is not very efficient because it traverses the whole stream
--   before rebuilding it, avoid using it if you can. mapAccumL used to
--   implemented but it wasn't used anywhere in the compiler and has
--   similar effiency problems.
mapAccumL_ :: forall m a b c r. Monad m => (c -> a -> m (c, b)) -> c -> Stream m a r -> Stream m b (c, r)
instance GHC.Base.Functor (GHC.Data.Stream.Stream f a)
instance GHC.Base.Applicative (GHC.Data.Stream.Stream m a)
instance GHC.Base.Monad (GHC.Data.Stream.Stream m a)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (GHC.Data.Stream.Stream m b)
instance GHC.Base.Monad m => GHC.Base.Functor (GHC.Data.Stream.StreamS m a)
instance GHC.Base.Monad m => GHC.Base.Applicative (GHC.Data.Stream.StreamS m a)
instance GHC.Base.Monad m => GHC.Base.Monad (GHC.Data.Stream.StreamS m a)

module GHC.Data.FiniteMap
insertList :: Ord key => [(key, elt)] -> Map key elt -> Map key elt
insertListWith :: Ord key => (elt -> elt -> elt) -> [(key, elt)] -> Map key elt -> Map key elt
deleteList :: Ord key => [key] -> Map key elt -> Map key elt
foldRight :: (elt -> a -> a) -> a -> Map key elt -> a
foldRightWithKey :: (key -> elt -> a -> a) -> a -> Map key elt -> a

module GHC.Data.FastMutInt
data FastMutInt
newFastMutInt :: Int -> IO FastMutInt
readFastMutInt :: FastMutInt -> IO Int
writeFastMutInt :: FastMutInt -> Int -> IO ()
atomicFetchAddFastMut :: FastMutInt -> Int -> IO Int


-- | A tiny wrapper around <a>IntSet</a> for representing sets of
--   <a>Enum</a> things.
module GHC.Data.EnumSet
data EnumSet a
member :: Enum a => a -> EnumSet a -> Bool
insert :: Enum a => a -> EnumSet a -> EnumSet a
delete :: Enum a => a -> EnumSet a -> EnumSet a
toList :: Enum a => EnumSet a -> [a]
fromList :: Enum a => [a] -> EnumSet a
empty :: EnumSet a
difference :: EnumSet a -> EnumSet a -> EnumSet a

module GHC.CmmToAsm.X86.Cond
data Cond
ALWAYS :: Cond
EQQ :: Cond
GE :: Cond
GEU :: Cond
GTT :: Cond
GU :: Cond
LE :: Cond
LEU :: Cond
LTT :: Cond
LU :: Cond
NE :: Cond
NEG :: Cond
POS :: Cond
CARRY :: Cond
OFLO :: Cond
PARITY :: Cond
NOTPARITY :: Cond
condToUnsigned :: Cond -> Cond

-- | <tt>maybeFlipCond c</tt> returns <tt>Just c'</tt> if it is possible to
--   flip the arguments to the conditional <tt>c</tt>, and the new
--   condition should be <tt>c'</tt>.
maybeFlipCond :: Cond -> Maybe Cond

-- | If we apply <tt>maybeInvertCond</tt> to the condition of a jump we
--   turn jumps taken into jumps not taken and vice versa.
--   
--   Careful! If the used comparison and the conditional jump don't match
--   the above behaviour will NOT hold. When used for FP comparisons this
--   does not consider unordered numbers. Also inverting twice might return
--   a synonym for the original condition.
maybeInvertCond :: Cond -> Maybe Cond
instance GHC.Classes.Eq GHC.CmmToAsm.X86.Cond.Cond

module GHC.CmmToAsm.SPARC.Cond

-- | Branch condition codes.
data Cond
ALWAYS :: Cond
EQQ :: Cond
GE :: Cond
GEU :: Cond
GTT :: Cond
GU :: Cond
LE :: Cond
LEU :: Cond
LTT :: Cond
LU :: Cond
NE :: Cond
NEG :: Cond
NEVER :: Cond
POS :: Cond
VC :: Cond
VS :: Cond
instance GHC.Classes.Eq GHC.CmmToAsm.SPARC.Cond.Cond


-- | The Lengauer-Tarjan graph dominators algorithm.
--   
--   &lt;math&gt; Lengauer, Tarjan, <i>A Fast Algorithm for Finding
--   Dominators in a Flowgraph</i>, 1979.
--   
--   &lt;math&gt; Muchnick, <i>Advanced Compiler Design and
--   Implementation</i>, 1997.
--   
--   &lt;math&gt; Brisk, Sarrafzadeh, <i>Interference Graphs for Procedures
--   in Static Single</i> <i>Information Form are Interval Graphs</i>,
--   2007.
--   
--   <ul>
--   <li>Strictness</li>
--   </ul>
--   
--   Unless stated otherwise all exposed functions might fully evaluate
--   their input but are not guaranteed to do so.
module GHC.CmmToAsm.CFG.Dominators
type Node = Int
type Path = [Node]
type Edge = (Node, Node)
type Graph = IntMap IntSet
type Rooted = (Node, Graph)

-- | <i>Immediate dominators</i>. <i>O(|E|*alpha(|E|,|V|))</i>, where
--   <i>alpha(m,n)</i> is "a functional inverse of Ackermann's function".
--   
--   This Complexity bound assumes <i>O(1)</i> indexing. Since we're using
--   <tt>IntMap</tt>, it has an additional <i>lg |V|</i> factor somewhere
--   in there. I'm not sure where.
idom :: Rooted -> [(Node, Node)]

-- | <i>Immediate post-dominators</i>. Complexity as for <tt>idom</tt>.
ipdom :: Rooted -> [(Node, Node)]

-- | <i>Dominator tree</i>. Complexity as for <tt>idom</tt>.
domTree :: Rooted -> Tree Node

-- | <i>Post-dominator tree</i>. Complexity as for <tt>idom</tt>.
pdomTree :: Rooted -> Tree Node

-- | <i>Dominators</i>. Complexity as for <tt>idom</tt>
dom :: Rooted -> [(Node, Path)]

-- | <i>Post-dominators</i>. Complexity as for <tt>idom</tt>.
pdom :: Rooted -> [(Node, Path)]

-- | <i>Post-dominated depth-first search</i>.
pddfs :: Rooted -> [Node]

-- | <i>Reverse post-dominated depth-first search</i>.
rpddfs :: Rooted -> [Node]
fromAdj :: [(Node, [Node])] -> Graph
fromEdges :: [Edge] -> Graph
toAdj :: Graph -> [(Node, [Node])]
toEdges :: Graph -> [Edge]
asTree :: Rooted -> Tree Node
asGraph :: Tree Node -> Rooted
parents :: Tree a -> [(a, a)]
ancestors :: Tree a -> [(a, [a])]
instance GHC.Base.Functor (GHC.CmmToAsm.CFG.Dominators.S z s)
instance GHC.Base.Monad (GHC.CmmToAsm.CFG.Dominators.S z s)
instance GHC.Base.Applicative (GHC.CmmToAsm.CFG.Dominators.S z s)

module GHC.CmmToAsm.AArch64.Cond
data Cond
ALWAYS :: Cond
EQ :: Cond
NE :: Cond
SLT :: Cond
SLE :: Cond
SGE :: Cond
SGT :: Cond
ULT :: Cond
ULE :: Cond
UGE :: Cond
UGT :: Cond
OLT :: Cond
OLE :: Cond
OGE :: Cond
OGT :: Cond
UOLT :: Cond
UOLE :: Cond
UOGE :: Cond
UOGT :: Cond
NEVER :: Cond
VS :: Cond
VC :: Cond
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Cond.Cond

module GHC.Cmm.Dataflow.Collections
class IsSet set where {
    type ElemOf set;
}
setNull :: IsSet set => set -> Bool
setSize :: IsSet set => set -> Int
setMember :: IsSet set => ElemOf set -> set -> Bool
setEmpty :: IsSet set => set
setSingleton :: IsSet set => ElemOf set -> set
setInsert :: IsSet set => ElemOf set -> set -> set
setDelete :: IsSet set => ElemOf set -> set -> set
setUnion :: IsSet set => set -> set -> set
setDifference :: IsSet set => set -> set -> set
setIntersection :: IsSet set => set -> set -> set
setIsSubsetOf :: IsSet set => set -> set -> Bool
setFilter :: IsSet set => (ElemOf set -> Bool) -> set -> set
setFoldl :: IsSet set => (b -> ElemOf set -> b) -> b -> set -> b
setFoldr :: IsSet set => (ElemOf set -> b -> b) -> b -> set -> b
setElems :: IsSet set => set -> [ElemOf set]
setFromList :: IsSet set => [ElemOf set] -> set
setInsertList :: IsSet set => [ElemOf set] -> set -> set
setDeleteList :: IsSet set => [ElemOf set] -> set -> set
setUnions :: IsSet set => [set] -> set
class IsMap map where {
    type KeyOf map;
}
mapNull :: IsMap map => map a -> Bool
mapSize :: IsMap map => map a -> Int
mapMember :: IsMap map => KeyOf map -> map a -> Bool
mapLookup :: IsMap map => KeyOf map -> map a -> Maybe a
mapFindWithDefault :: IsMap map => a -> KeyOf map -> map a -> a
mapEmpty :: IsMap map => map a
mapSingleton :: IsMap map => KeyOf map -> a -> map a
mapInsert :: IsMap map => KeyOf map -> a -> map a -> map a
mapInsertWith :: IsMap map => (a -> a -> a) -> KeyOf map -> a -> map a -> map a
mapDelete :: IsMap map => KeyOf map -> map a -> map a
mapAlter :: IsMap map => (Maybe a -> Maybe a) -> KeyOf map -> map a -> map a
mapAdjust :: IsMap map => (a -> a) -> KeyOf map -> map a -> map a
mapUnion :: IsMap map => map a -> map a -> map a
mapUnionWithKey :: IsMap map => (KeyOf map -> a -> a -> a) -> map a -> map a -> map a
mapDifference :: IsMap map => map a -> map a -> map a
mapIntersection :: IsMap map => map a -> map a -> map a
mapIsSubmapOf :: (IsMap map, Eq a) => map a -> map a -> Bool
mapMap :: IsMap map => (a -> b) -> map a -> map b
mapMapWithKey :: IsMap map => (KeyOf map -> a -> b) -> map a -> map b
mapFoldl :: IsMap map => (b -> a -> b) -> b -> map a -> b
mapFoldr :: IsMap map => (a -> b -> b) -> b -> map a -> b
mapFoldlWithKey :: IsMap map => (b -> KeyOf map -> a -> b) -> b -> map a -> b
mapFoldMapWithKey :: (IsMap map, Monoid m) => (KeyOf map -> a -> m) -> map a -> m
mapFilter :: IsMap map => (a -> Bool) -> map a -> map a
mapFilterWithKey :: IsMap map => (KeyOf map -> a -> Bool) -> map a -> map a
mapElems :: IsMap map => map a -> [a]
mapKeys :: IsMap map => map a -> [KeyOf map]
mapToList :: IsMap map => map a -> [(KeyOf map, a)]
mapFromList :: IsMap map => [(KeyOf map, a)] -> map a
mapFromListWith :: IsMap map => (a -> a -> a) -> [(KeyOf map, a)] -> map a
mapInsertList :: IsMap map => [(KeyOf map, a)] -> map a -> map a
mapDeleteList :: IsMap map => [KeyOf map] -> map a -> map a
mapUnions :: IsMap map => [map a] -> map a
data UniqueMap v
data UniqueSet
instance GHC.Base.Monoid GHC.Cmm.Dataflow.Collections.UniqueSet
instance GHC.Base.Semigroup GHC.Cmm.Dataflow.Collections.UniqueSet
instance GHC.Show.Show GHC.Cmm.Dataflow.Collections.UniqueSet
instance GHC.Classes.Ord GHC.Cmm.Dataflow.Collections.UniqueSet
instance GHC.Classes.Eq GHC.Cmm.Dataflow.Collections.UniqueSet
instance Data.Traversable.Traversable GHC.Cmm.Dataflow.Collections.UniqueMap
instance Data.Foldable.Foldable GHC.Cmm.Dataflow.Collections.UniqueMap
instance GHC.Base.Functor GHC.Cmm.Dataflow.Collections.UniqueMap
instance GHC.Show.Show v => GHC.Show.Show (GHC.Cmm.Dataflow.Collections.UniqueMap v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (GHC.Cmm.Dataflow.Collections.UniqueMap v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (GHC.Cmm.Dataflow.Collections.UniqueMap v)
instance GHC.Cmm.Dataflow.Collections.IsMap GHC.Cmm.Dataflow.Collections.UniqueMap
instance GHC.Cmm.Dataflow.Collections.IsSet GHC.Cmm.Dataflow.Collections.UniqueSet

module GHC.Cmm.Dataflow.Block

-- | Used at the type level to indicate "open" vs "closed" structure.
data Extensibility

-- | An "open" structure with a unique, unnamed control-flow edge flowing
--   in or out. "Fallthrough" and concatenation are permitted at an open
--   point.
Open :: Extensibility

-- | A "closed" structure which supports control transfer only through the
--   use of named labels---no "fallthrough" is permitted. The number of
--   control-flow edges is unconstrained.
Closed :: Extensibility
type O = 'Open
type C = 'Closed

-- | Maybe type indexed by open/closed
data MaybeO ex t
[JustO] :: t -> MaybeO O t
[NothingO] :: MaybeO C t

-- | Either type indexed by closed/open using type families
type family IndexedCO (ex :: Extensibility) (a :: k) (b :: k) :: k

-- | A sequence of nodes. May be any of four shapes (O<i>O, O</i>C, C<i>O,
--   C</i>C). Open at the entry means single entry, mutatis mutandis for
--   exit. A closed<i>closed block is a </i>basic/ block and can't be
--   extended further. Clients should avoid manipulating blocks and should
--   stick to either nodes or graphs.
data Block n e x
[BlockCO] :: n C O -> Block n O O -> Block n C O
[BlockCC] :: n C O -> Block n O O -> n O C -> Block n C C
[BlockOC] :: Block n O O -> n O C -> Block n O C
[BNil] :: Block n O O
[BMiddle] :: n O O -> Block n O O
[BCat] :: Block n O O -> Block n O O -> Block n O O
[BSnoc] :: Block n O O -> n O O -> Block n O O
[BCons] :: n O O -> Block n O O -> Block n O O
blockAppend :: Block n e O -> Block n O x -> Block n e x
blockCons :: n O O -> Block n O x -> Block n O x
blockFromList :: [n O O] -> Block n O O
blockJoin :: n C O -> Block n O O -> n O C -> Block n C C
blockJoinHead :: n C O -> Block n O x -> Block n C x
blockJoinTail :: Block n e O -> n O C -> Block n e C
blockSnoc :: Block n e O -> n O O -> Block n e O

-- | Split a closed block into its entry node, open middle block, and exit
--   node.
blockSplit :: Block n C C -> (n C O, Block n O O, n O C)
blockSplitHead :: Block n C x -> (n C O, Block n O x)
blockSplitTail :: Block n e C -> (Block n e O, n O C)
blockToList :: Block n O O -> [n O O]
emptyBlock :: Block n O O
firstNode :: Block n C x -> n C O
foldBlockNodesB :: forall n a. (forall e x. n e x -> a -> a) -> forall e x. Block n e x -> IndexedCO x a a -> IndexedCO e a a
foldBlockNodesB3 :: forall n a b c. (n C O -> b -> c, n O O -> b -> b, n O C -> a -> b) -> forall e x. Block n e x -> IndexedCO x a b -> IndexedCO e c b
foldBlockNodesF :: forall n a. (forall e x. n e x -> a -> a) -> forall e x. Block n e x -> IndexedCO e a a -> IndexedCO x a a
isEmptyBlock :: Block n e x -> Bool
lastNode :: Block n x C -> n O C

-- | map a function over the nodes of a <a>Block</a>
mapBlock :: (forall e x. n e x -> n' e x) -> Block n e x -> Block n' e x

-- | A strict <a>mapBlock</a>
mapBlock' :: (forall e x. n e x -> n' e x) -> Block n e x -> Block n' e x

-- | map over a block, with different functions to apply to first nodes,
--   middle nodes and last nodes respectively. The map is strict.
mapBlock3' :: forall n n' e x. (n C O -> n' C O, n O O -> n' O O, n O C -> n' O C) -> Block n e x -> Block n' e x
replaceFirstNode :: Block n C x -> n C O -> Block n C x
replaceLastNode :: Block n x C -> n O C -> Block n x C
instance GHC.Base.Functor (GHC.Cmm.Dataflow.Block.MaybeO ex)

module GHC.Settings.Config
cBuildPlatformString :: String
cHostPlatformString :: String
cProjectName :: String
cBooterVersion :: String
cStage :: String


-- | Compile-time settings
module GHC.Settings.Constants
hiVersion :: Integer
mAX_TUPLE_SIZE :: Int
mAX_CTUPLE_SIZE :: Int
mAX_SUM_SIZE :: Int

-- | Default maximum depth for both class instance search and type family
--   reduction. See also #5395.
mAX_REDUCTION_DEPTH :: Int

-- | Default maximum constraint-solver iterations Typically there should be
--   very few
mAX_SOLVER_ITERATIONS :: Int
wORD64_SIZE :: Int
fLOAT_SIZE :: Int
dOUBLE_SIZE :: Int
tARGET_MAX_CHAR :: Int

module GHC.SysTools.Ar
data ArchiveEntry
ArchiveEntry :: String -> Int -> Int -> Int -> Int -> Int -> ByteString -> ArchiveEntry

-- | File name.
[filename] :: ArchiveEntry -> String

-- | File modification time.
[filetime] :: ArchiveEntry -> Int

-- | File owner.
[fileown] :: ArchiveEntry -> Int

-- | File group.
[filegrp] :: ArchiveEntry -> Int

-- | File mode.
[filemode] :: ArchiveEntry -> Int

-- | File size.
[filesize] :: ArchiveEntry -> Int

-- | File bytes.
[filedata] :: ArchiveEntry -> ByteString
newtype Archive
Archive :: [ArchiveEntry] -> Archive
afilter :: (ArchiveEntry -> Bool) -> Archive -> Archive
parseAr :: ByteString -> Archive
loadAr :: FilePath -> IO Archive
loadObj :: FilePath -> IO ArchiveEntry
writeBSDAr :: FilePath -> Archive -> IO ()
writeGNUAr :: FilePath -> Archive -> IO ()
isBSDSymdef :: ArchiveEntry -> Bool
isGNUSymdef :: ArchiveEntry -> Bool
instance GHC.Show.Show GHC.SysTools.Ar.ArchiveEntry
instance GHC.Classes.Eq GHC.SysTools.Ar.ArchiveEntry
instance GHC.Base.Monoid GHC.SysTools.Ar.Archive
instance GHC.Base.Semigroup GHC.SysTools.Ar.Archive
instance GHC.Show.Show GHC.SysTools.Ar.Archive
instance GHC.Classes.Eq GHC.SysTools.Ar.Archive

module GHC.SysTools.Terminal

-- | Does the controlling terminal support ANSI color sequences? This
--   memoized to avoid thread-safety issues in ncurses (see #17922).
stderrSupportsAnsiColors :: Bool


-- | Haskell Program Coverage (HPC) support
module GHC.Types.HpcInfo

-- | Information about a modules use of Haskell Program Coverage
data HpcInfo
HpcInfo :: Int -> Int -> HpcInfo
[hpcInfoTickCount] :: HpcInfo -> Int
[hpcInfoHash] :: HpcInfo -> Int
NoHpcInfo :: AnyHpcUsage -> HpcInfo

-- | Is hpc used anywhere on the module *tree*?
[hpcUsed] :: HpcInfo -> AnyHpcUsage

-- | This is used to signal if one of my imports used HPC instrumentation
--   even if there is no module-local HPC usage
type AnyHpcUsage = Bool
emptyHpcInfo :: AnyHpcUsage -> HpcInfo

-- | Find out if HPC is used by this module or any of the modules it
--   depends upon
isHpcUsed :: HpcInfo -> AnyHpcUsage

module GHC.Utils.CliOption

-- | When invoking external tools as part of the compilation pipeline, we
--   pass these a sequence of options on the command-line. Rather than just
--   using a list of Strings, we use a type that allows us to distinguish
--   between filepaths and 'other stuff'. The reason for this is that this
--   type gives us a handle on transforming filenames, and filenames only,
--   to whatever format they're expected to be on a particular platform.
data Option
FileOption :: String -> String -> Option
Option :: String -> Option
showOpt :: Option -> String
instance GHC.Classes.Eq GHC.Utils.CliOption.Option

module GHC.Utils.Exception
catchIO :: IO a -> (IOException -> IO a) -> IO a
handleIO :: (IOException -> IO a) -> IO a -> IO a
tryIO :: IO a -> IO (Either IOException a)
type ExceptionMonad m = (MonadCatch m, MonadThrow m, MonadMask m, MonadIO m)

module GHC.Utils.Fingerprint
readHexFingerprint :: String -> Fingerprint
fingerprintByteString :: ByteString -> Fingerprint
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
fingerprint0 :: Fingerprint
fingerprintFingerprints :: [Fingerprint] -> Fingerprint
fingerprintData :: Ptr Word8 -> Int -> IO Fingerprint
fingerprintString :: String -> Fingerprint

-- | Computes the hash of a given file. This function loops over the
--   handle, running in constant memory.
getFileHash :: FilePath -> IO Fingerprint

module GHC.Utils.GlobalVars
v_unsafeHasPprDebug :: IORef Bool
v_unsafeHasNoDebugOutput :: IORef Bool
v_unsafeHasNoStateHack :: IORef Bool
unsafeHasPprDebug :: Bool
unsafeHasNoDebugOutput :: Bool
unsafeHasNoStateHack :: Bool
global :: a -> IORef a
consIORef :: IORef [a] -> a -> IO ()
globalM :: IO a -> IORef a
sharedGlobal :: a -> (Ptr (IORef a) -> IO (Ptr (IORef a))) -> IORef a
sharedGlobalM :: IO a -> (Ptr (IORef a) -> IO (Ptr (IORef a))) -> IORef a

module GHC.Utils.IO.Unsafe
inlinePerformIO :: IO a -> a


-- | Utilities related to Monad and Applicative classes Mostly for
--   backwards compatibility.
module GHC.Utils.Monad

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Monads having fixed points with a 'knot-tying' semantics. Instances of
--   <a>MonadFix</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i>Purity</i> <tt><a>mfix</a> (<a>return</a> . h) = <a>return</a>
--   (<a>fix</a> h)</tt></li>
--   <li><i>Left shrinking (or Tightening)</i> <tt><a>mfix</a> (\x -&gt; a
--   &gt;&gt;= \y -&gt; f x y) = a &gt;&gt;= \y -&gt; <a>mfix</a> (\x -&gt;
--   f x y)</tt></li>
--   <li><i>Sliding</i> <tt><a>mfix</a> (<a>liftM</a> h . f) = <a>liftM</a>
--   h (<a>mfix</a> (f . h))</tt>, for strict <tt>h</tt>.</li>
--   <li><i>Nesting</i> <tt><a>mfix</a> (\x -&gt; <a>mfix</a> (\y -&gt; f x
--   y)) = <a>mfix</a> (\x -&gt; f x x)</tt></li>
--   </ul>
--   
--   This class is used in the translation of the recursive <tt>do</tt>
--   notation supported by GHC and Hugs.
class Monad m => MonadFix (m :: Type -> Type)

-- | The fixed point of a monadic computation. <tt><a>mfix</a> f</tt>
--   executes the action <tt>f</tt> only once, with the eventual output fed
--   back as the input. Hence <tt>f</tt> should not be strict, for then
--   <tt><a>mfix</a> f</tt> would diverge.
mfix :: MonadFix m => (a -> m a) -> m a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   â¢ Couldn't match type âIOâ with âStateT s IOâ
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a
zipWith3M :: Monad m => (a -> b -> c -> m d) -> [a] -> [b] -> [c] -> m [d]
zipWith3M_ :: Monad m => (a -> b -> c -> m d) -> [a] -> [b] -> [c] -> m ()
zipWith4M :: Monad m => (a -> b -> c -> d -> m e) -> [a] -> [b] -> [c] -> [d] -> m [e]
zipWithAndUnzipM :: Monad m => (a -> b -> m (c, d)) -> [a] -> [b] -> m ([c], [d])

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | mapAndUnzipM for triples
mapAndUnzip3M :: Monad m => (a -> m (b, c, d)) -> [a] -> m ([b], [c], [d])
mapAndUnzip4M :: Monad m => (a -> m (b, c, d, e)) -> [a] -> m ([b], [c], [d], [e])
mapAndUnzip5M :: Monad m => (a -> m (b, c, d, e, f)) -> [a] -> m ([b], [c], [d], [e], [f])

-- | Monadic version of mapAccumL
mapAccumLM :: Monad m => (acc -> x -> m (acc, y)) -> acc -> [x] -> m (acc, [y])
liftFstM :: Monad m => (a -> b) -> m (a, r) -> m (b, r)
liftSndM :: Monad m => (a -> b) -> m (r, a) -> m (r, b)

-- | Monadic version of mapSnd
mapSndM :: Monad m => (b -> m c) -> [(a, b)] -> m [(a, c)]

-- | Monadic version of concatMap
concatMapM :: Monad m => (a -> m [b]) -> [a] -> m [b]

-- | Applicative version of mapMaybe
mapMaybeM :: Applicative m => (a -> m (Maybe b)) -> [a] -> m [b]

-- | Monadic version of fmap
fmapMaybeM :: Monad m => (a -> m b) -> Maybe a -> m (Maybe b)

-- | Monadic version of fmap
fmapEitherM :: Monad m => (a -> m b) -> (c -> m d) -> Either a c -> m (Either b d)

-- | Monadic version of <a>any</a>, aborts the computation at the first
--   <tt>True</tt> value
anyM :: Monad m => (a -> m Bool) -> [a] -> m Bool

-- | Monad version of <a>all</a>, aborts the computation at the first
--   <tt>False</tt> value
allM :: Monad m => (a -> m Bool) -> [a] -> m Bool

-- | Monadic version of or
orM :: Monad m => m Bool -> m Bool -> m Bool

-- | Left-to-right monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, ..., w, x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldlM f z t = do
--       aa &lt;- f z a
--       bb &lt;- f aa b
--       ...
--       xx &lt;- f ww x
--       yy &lt;- f xx y
--       return yy -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldlM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldlM f z t =
--       flip f a &gt;=&gt; flip f b &gt;=&gt; ... &gt;=&gt; flip f x &gt;=&gt; flip f y $ z
--   </pre>
--   
--   The monadic effects of <tt>foldlM</tt> are sequenced from left to
--   right.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from an initial segment of the element
--   sequence. If you want to evaluate the monadic effects in right-to-left
--   order, or perhaps be able to short-circuit after processing a tail of
--   the sequence of elements, you'll need to use <a>foldrM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the rightmost element <tt>y</tt>, so that,
--   ignoring effects, the result looks like a left fold:
--   
--   <pre>
--   ((((z `f` a) `f` b) ... `f` w) `f` x) `f` y
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f a e = do { print e ; return $ e : a }
--   
--   &gt;&gt;&gt; foldlM f [] [0..3]
--   0
--   1
--   2
--   3
--   [3,2,1,0]
--   </pre>
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Monadic version of foldl that discards its result
foldlM_ :: (Monad m, Foldable t) => (a -> b -> m a) -> a -> t b -> m ()

-- | Right-to-left monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, c, ..., x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldrM f z t = do
--       yy &lt;- f y z
--       xx &lt;- f x yy
--       ...
--       bb &lt;- f b cc
--       aa &lt;- f a bb
--       return aa -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldrM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldrM f z t = f y &gt;=&gt; f x &gt;=&gt; ... &gt;=&gt; f b &gt;=&gt; f a $ z
--   </pre>
--   
--   The monadic effects of <tt>foldrM</tt> are sequenced from right to
--   left, and e.g. folds of infinite lists will diverge.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from a tail of the element sequence. If
--   you want to evaluate the monadic effects in left-to-right order, or
--   perhaps be able to short-circuit after an initial sequence of
--   elements, you'll need to use <a>foldlM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the leftmost element <tt>a</tt>, so that, ignoring
--   effects, the result looks like a right fold:
--   
--   <pre>
--   a `f` (b `f` (c `f` (... (x `f` (y `f` z))))).
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f i acc = do { print i ; return $ i : acc }
--   
--   &gt;&gt;&gt; foldrM f [] [0..3]
--   3
--   2
--   1
--   0
--   [0,1,2,3]
--   </pre>
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | Monadic version of fmap specialised for Maybe
maybeMapM :: Monad m => (a -> m b) -> Maybe a -> m (Maybe b)

-- | Monadic version of <tt>when</tt>, taking the condition in the monad
whenM :: Monad m => m Bool -> m () -> m ()

-- | Monadic version of <tt>unless</tt>, taking the condition in the monad
unlessM :: Monad m => m Bool -> m () -> m ()

-- | Like <a>filterM</a>, only it reverses the sense of the test.
filterOutM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

module GHC.Utils.Monad.State
newtype State s a
State :: (s -> (# a, s #)) -> State s a
[runState'] :: State s a -> s -> (# a, s #)
get :: State s s
gets :: (s -> a) -> State s a
put :: s -> State s ()
modify :: (s -> s) -> State s ()
evalState :: State s a -> s -> a
execState :: State s a -> s -> s
runState :: State s a -> s -> (a, s)
instance GHC.Base.Functor (GHC.Utils.Monad.State.State s)
instance GHC.Base.Applicative (GHC.Utils.Monad.State.State s)
instance GHC.Base.Monad (GHC.Utils.Monad.State.State s)


-- | Defines a simple exception type and utilities to throw it. The
--   <a>PlainGhcException</a> type is a subset of the <a>GhcException</a>
--   type. It omits the exception constructors that involve pretty-printing
--   via <a>SDoc</a>.
--   
--   There are two reasons for this:
--   
--   <ol>
--   <li>To avoid import cycles / use of boot files.
--   <a>GHC.Utils.Outputable</a> has many transitive dependencies. To throw
--   exceptions from these modules, the functions here can be used without
--   introducing import cycles.</li>
--   <li>To reduce the number of modules that need to be compiled to object
--   code when loading GHC into GHCi. See #13101</li>
--   </ol>
module GHC.Utils.Panic.Plain

-- | This type is very similar to <a>GhcException</a>, but it omits the
--   constructors that involve pretty-printing via <a>SDoc</a>. Due to the
--   implementation of <a>fromException</a> for <a>GhcException</a>, this
--   type can be caught as a <a>GhcException</a>.
--   
--   Note that this should only be used for throwing exceptions, not for
--   catching, as <a>GhcException</a> will not be converted to this type
--   when catching.
data PlainGhcException

-- | Some other fatal signal (SIGHUP,SIGTERM)
PlainSignal :: Int -> PlainGhcException

-- | Prints the short usage msg after the error
PlainUsageError :: String -> PlainGhcException

-- | A problem with the command line arguments, but don't print usage.
PlainCmdLineError :: String -> PlainGhcException

-- | The <tt>impossible</tt> happened.
PlainPanic :: String -> PlainGhcException

-- | The user tickled something that's known not to work yet, but we're not
--   counting it as a bug.
PlainSorry :: String -> PlainGhcException

-- | An installation problem.
PlainInstallationError :: String -> PlainGhcException

-- | An error in the user's code, probably.
PlainProgramError :: String -> PlainGhcException

-- | Append a description of the given exception to this string.
showPlainGhcException :: PlainGhcException -> ShowS

-- | Panics and asserts.
panic :: String -> a

-- | Panics and asserts.
sorry :: String -> a

-- | Panics and asserts.
pgmError :: String -> a
cmdLineError :: String -> a
cmdLineErrorIO :: String -> IO a

-- | Throw a failed assertion exception for a given filename and line
--   number.
assertPanic :: String -> Int -> a

-- | The name of this GHC.
progName :: String
instance GHC.Exception.Type.Exception GHC.Utils.Panic.Plain.PlainGhcException
instance GHC.Show.Show GHC.Utils.Panic.Plain.PlainGhcException


-- | Highly random utility functions
module GHC.Utils.Misc
ghciSupported :: Bool
debugIsOn :: Bool
isWindowsHost :: Bool
isDarwinHost :: Bool

-- | Apply a function iff some condition is met.
applyWhen :: Bool -> (a -> a) -> a -> a

-- | Apply a function <tt>n</tt> times to a given value.
nTimes :: Int -> (a -> a) -> a -> a
zipEqual :: String -> [a] -> [b] -> [(a, b)]
zipWithEqual :: String -> (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3Equal :: String -> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
zipWith4Equal :: String -> (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | <a>zipLazy</a> is a kind of <a>zip</a> that is lazy in the second list
--   (observe the ~)
zipLazy :: [a] -> [b] -> [(a, b)]

-- | <tt>stretchZipWith p z f xs ys</tt> stretches <tt>ys</tt> by inserting
--   <tt>z</tt> in the places where <tt>p</tt> returns <tt>True</tt>
stretchZipWith :: (a -> Bool) -> b -> (a -> b -> c) -> [a] -> [b] -> [c]
zipWithAndUnzip :: (a -> b -> (c, d)) -> [a] -> [b] -> ([c], [d])

-- | This has the effect of making the two lists have equal length by
--   dropping the tail of the longer one.
zipAndUnzip :: [a] -> [b] -> ([a], [b])

-- | <a>zipWithLazy</a> is like <a>zipWith</a> but is lazy in the second
--   list. The length of the output is always the same as the length of the
--   first list.
zipWithLazy :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>zipWith3Lazy</a> is like <a>zipWith3</a> but is lazy in the second
--   and third lists. The length of the output is always the same as the
--   length of the first list.
zipWith3Lazy :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>filterByList</a> takes a list of Bools and a list of some elements
--   and filters out these elements for which the corresponding value in
--   the list of Bools is False. This function does not check whether the
--   lists have equal length.
filterByList :: [Bool] -> [a] -> [a]

-- | <a>filterByLists</a> takes a list of Bools and two lists as input, and
--   outputs a new list consisting of elements from the last two input
--   lists. For each Bool in the list, if it is <a>True</a>, then it takes
--   an element from the former list. If it is <a>False</a>, it takes an
--   element from the latter list. The elements taken correspond to the
--   index of the Bool in its list. For example:
--   
--   <pre>
--   filterByLists [True, False, True, False] "abcd" "wxyz" = "axcz"
--   </pre>
--   
--   This function does not check whether the lists have equal length.
filterByLists :: [Bool] -> [a] -> [a] -> [a]

-- | <a>partitionByList</a> takes a list of Bools and a list of some
--   elements and partitions the list according to the list of Bools.
--   Elements corresponding to <a>True</a> go to the left; elements
--   corresponding to <a>False</a> go to the right. For example,
--   <tt>partitionByList [True, False, True] [1,2,3] == ([1,3], [2])</tt>
--   This function does not check whether the lists have equal length; when
--   one list runs out, the function stops.
partitionByList :: [Bool] -> [a] -> ([a], [a])
unzipWith :: (a -> b -> c) -> [(a, b)] -> [c]
mapFst :: (a -> c) -> [(a, b)] -> [(c, b)]
mapSnd :: (b -> c) -> [(a, b)] -> [(a, c)]
chkAppend :: [a] -> [a] -> [a]
mapAndUnzip :: (a -> (b, c)) -> [a] -> ([b], [c])
mapAndUnzip3 :: (a -> (b, c, d)) -> [a] -> ([b], [c], [d])

-- | Like filter, only it reverses the sense of the test
filterOut :: (a -> Bool) -> [a] -> [a]

-- | Uses a function to determine which of two output lists an input
--   element should join
partitionWith :: (a -> Either b c) -> [a] -> ([b], [c])
dropWhileEndLE :: (a -> Bool) -> [a] -> [a]

-- | <tt>spanEnd p l == reverse (span p (reverse l))</tt>. The first list
--   returns actually comes after the second list (when you look at the
--   input list).
spanEnd :: (a -> Bool) -> [a] -> ([a], [a])

-- | Get the last two elements in a list. Partial!
last2 :: [a] -> (a, a)
lastMaybe :: [a] -> Maybe a

-- | A strict version of <a>foldl1</a>.
foldl1' :: (a -> a -> a) -> [a] -> a
foldl2 :: (acc -> a -> b -> acc) -> acc -> [a] -> [b] -> acc
count :: (a -> Bool) -> [a] -> Int
countWhile :: (a -> Bool) -> [a] -> Int
all2 :: (a -> b -> Bool) -> [a] -> [b] -> Bool

-- | <pre>
--   (lengthExceeds xs n) = (length xs &gt; n)
--   </pre>
lengthExceeds :: [a] -> Int -> Bool

-- | <pre>
--   (lengthIs xs n) = (length xs == n)
--   </pre>
lengthIs :: [a] -> Int -> Bool

-- | <pre>
--   (lengthIsNot xs n) = (length xs /= n)
--   </pre>
lengthIsNot :: [a] -> Int -> Bool

-- | <pre>
--   (lengthAtLeast xs n) = (length xs &gt;= n)
--   </pre>
lengthAtLeast :: [a] -> Int -> Bool

-- | <pre>
--   (lengthAtMost xs n) = (length xs &lt;= n)
--   </pre>
lengthAtMost :: [a] -> Int -> Bool

-- | <pre>
--   (lengthLessThan xs n) == (length xs &lt; n)
--   </pre>
lengthLessThan :: [a] -> Int -> Bool
listLengthCmp :: [a] -> Int -> Ordering

-- | <tt>atLength atLen atEnd ls n</tt> unravels list <tt>ls</tt> to
--   position <tt>n</tt>. Precisely:
--   
--   <pre>
--   atLength atLenPred atEndPred ls n
--    | n &lt; 0         = atLenPred ls
--    | length ls &lt; n = atEndPred (n - length ls)
--    | otherwise     = atLenPred (drop n ls)
--   </pre>
atLength :: ([a] -> b) -> b -> [a] -> Int -> b

-- | True if length xs == length ys
equalLength :: [a] -> [b] -> Bool
compareLength :: [a] -> [b] -> Ordering

-- | True if length xs &lt;= length ys
leLength :: [a] -> [b] -> Bool

-- | True if length xs &lt; length ys
ltLength :: [a] -> [b] -> Bool
isSingleton :: [a] -> Bool
only :: [a] -> a
singleton :: a -> [a]
notNull :: Foldable f => f a -> Bool

-- | Split a list into its last element and the initial part of the list.
--   <tt>snocView xs = Just (init xs, last xs)</tt> for non-empty lists.
--   <tt>snocView xs = Nothing</tt> otherwise. Unless both parts of the
--   result are guaranteed to be used prefer separate calls to
--   <tt>last</tt> + <tt>init</tt>. If you are guaranteed to use both, this
--   will be more efficient.
snocView :: [a] -> Maybe ([a], a)
isIn :: Eq a => String -> a -> [a] -> Bool
isn'tIn :: Eq a => String -> a -> [a] -> Bool

-- | Split a list into chunks of <i>n</i> elements
chunkList :: Int -> [a] -> [[a]]

-- | Replace the last element of a list with another element.
changeLast :: [a] -> a -> [a]

-- | Apply an effectful function to the last list element. Assumes a
--   non-empty list (panics otherwise).
mapLastM :: Functor f => (a -> f a) -> [a] -> f [a]
whenNonEmpty :: Applicative m => [a] -> (NonEmpty a -> m ()) -> m ()

-- | Merge an unsorted list of sorted lists, for example:
--   
--   <pre>
--   mergeListsBy compare [ [2,5,15], [1,10,100] ] = [1,2,5,10,15,100]
--   </pre>
--   
--   &lt;math&gt;
mergeListsBy :: forall a. (a -> a -> Ordering) -> [[a]] -> [a]
isSortedBy :: (a -> a -> Ordering) -> [a] -> Bool
fstOf3 :: (a, b, c) -> a
sndOf3 :: (a, b, c) -> b
thdOf3 :: (a, b, c) -> c
firstM :: Monad m => (a -> m c) -> (a, b) -> m (c, b)
first3M :: Monad m => (a -> m d) -> (a, b, c) -> m (d, b, c)
secondM :: Monad m => (b -> m c) -> (a, b) -> m (a, c)
fst3 :: (a -> d) -> (a, b, c) -> (d, b, c)
snd3 :: (b -> d) -> (a, b, c) -> (a, d, c)
third3 :: (c -> d) -> (a, b, c) -> (a, b, d)
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
liftFst :: (a -> b) -> (a, c) -> (b, c)
liftSnd :: (a -> b) -> (c, a) -> (c, b)
takeList :: [b] -> [a] -> [a]
dropList :: [b] -> [a] -> [a]

-- | Given two lists xs and ys, return `splitAt (length xs) ys`.
splitAtList :: [b] -> [a] -> ([a], [a])
split :: Char -> String -> [String]
dropTail :: Int -> [a] -> [a]

-- | Convert a word to title case by capitalising the first letter
capitalise :: String -> String

-- | The <a>sortWith</a> function sorts a list of elements using the user
--   supplied function to project something out of each element
sortWith :: Ord b => (a -> b) -> [a] -> [a]
minWith :: Ord b => (a -> b) -> [a] -> a
nubSort :: Ord a => [a] -> [a]

-- | Remove duplicates but keep elements in order. O(n * log n)
ordNub :: Ord a => [a] -> [a]
isEqual :: Ordering -> Bool
eqListBy :: (a -> a -> Bool) -> [a] -> [a] -> Bool
eqMaybeBy :: (a -> a -> Bool) -> Maybe a -> Maybe a -> Bool
thenCmp :: Ordering -> Ordering -> Ordering
infixr 9 `thenCmp`
cmpList :: (a -> a -> Ordering) -> [a] -> [a] -> Ordering
removeSpaces :: String -> String
(<&&>) :: Applicative f => f Bool -> f Bool -> f Bool
infixr 3 <&&>
(<||>) :: Applicative f => f Bool -> f Bool -> f Bool
infixr 2 <||>
fuzzyMatch :: String -> [String] -> [String]

-- | Search for possible matches to the users input in the given list,
--   returning a small number of ranked results
fuzzyLookup :: String -> [(String, a)] -> [a]
transitiveClosure :: (a -> [a]) -> (a -> a -> Bool) -> [a] -> [a]
seqList :: [a] -> b -> b
strictMap :: (a -> b) -> [a] -> [b]
strictZipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
looksLikeModuleName :: String -> Bool
looksLikePackageName :: String -> Bool
getCmd :: String -> Either String (String, String)
toCmdArgs :: String -> Either String (String, [String])
toArgs :: String -> Either String [String]

-- | Determine the $log_2$ of exact powers of 2
exactLog2 :: Integer -> Maybe Integer
readRational :: String -> Rational

-- | Parse a string into a significand and exponent. A trivial example
--   might be: ghci&gt; readSignificandExponentPair "1E2" (1,2) In a more
--   complex case we might return a exponent different than that which the
--   user wrote. This is needed in order to use a Integer significand.
--   ghci&gt; readSignificandExponentPair "-1.11E5" (-111,3)
readSignificandExponentPair :: String -> (Integer, Integer)
readHexRational :: String -> Rational

-- | Parse a string into a significand and exponent according to the
--   "Hexadecimal Floats in Haskell" proposal. A trivial example might be:
--   ghci&gt; readHexSignificandExponentPair "0x1p+1" (1,1) Behaves similar
--   to readSignificandExponentPair but the base is 16 and numbers are
--   given in hexadecimal: ghci&gt; readHexSignificandExponentPair "0xAp-4"
--   (10,-4) ghci&gt; readHexSignificandExponentPair "0x1.2p3" (18,-1)
readHexSignificandExponentPair :: String -> (Integer, Integer)
doesDirNameExist :: FilePath -> IO Bool
getModificationUTCTime :: FilePath -> IO UTCTime
modificationTimeIfExists :: FilePath -> IO (Maybe UTCTime)
withAtomicRename :: MonadIO m => FilePath -> (FilePath -> m a) -> m a
type Suffix = String
splitLongestPrefix :: String -> (Char -> Bool) -> (String, String)
escapeSpaces :: String -> String
data Direction
Forwards :: Direction
Backwards :: Direction
reslash :: Direction -> FilePath -> FilePath
makeRelativeTo :: FilePath -> FilePath -> FilePath
abstractConstr :: String -> Constr
abstractDataType :: String -> DataType

-- | Constructs a non-representation for a non-representable type
mkNoRepType :: String -> DataType
charToC :: Word8 -> String

-- | A sample hash function for Strings. We keep multiplying by the golden
--   ratio and adding. The implementation is:
--   
--   <pre>
--   hashString = foldl' f golden
--     where f m c = fromIntegral (ord c) * magic + hashInt32 m
--           magic = 0xdeadbeef
--   </pre>
--   
--   Where hashInt32 works just as hashInt shown above.
--   
--   Knuth argues that repeated multiplication by the golden ratio will
--   minimize gaps in the hash space, and thus it's a good choice for
--   combining together multiple keys to form one.
--   
--   Here we know that individual characters c are often small, and this
--   produces frequent collisions if we use ord c alone. A particular
--   problem are the shorter low ASCII and ISO-8859-1 character strings. We
--   pre-multiply by a magic twiddle factor to obtain a good distribution.
--   In fact, given the following test:
--   
--   <pre>
--   testp :: Int32 -&gt; Int
--   testp k = (n - ) . length . group . sort . map hs . take n $ ls
--     where ls = [] : [c : l | l &lt;- ls, c &lt;- ['\0'..'\xff']]
--           hs = foldl' f golden
--           f m c = fromIntegral (ord c) * k + hashInt32 m
--           n = 100000
--   </pre>
--   
--   We discover that testp magic = 0.
hashString :: String -> Int32

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | A call stack constraint, but only when <tt>isDebugOn</tt>.
type HasDebugCallStack = (() :: Constraint)
data OverridingBool
Auto :: OverridingBool
Always :: OverridingBool
Never :: OverridingBool
overrideWith :: Bool -> OverridingBool -> Bool
instance GHC.Show.Show GHC.Utils.Misc.OverridingBool

module GHC.Data.Maybe
data MaybeErr err val
Succeeded :: val -> MaybeErr err val
Failed :: err -> MaybeErr err val
failME :: err -> MaybeErr err val
isSuccess :: MaybeErr err val -> Bool

-- | Flipped version of <tt>fromMaybe</tt>, useful for chaining.
orElse :: Maybe a -> a -> a
infixr 4 `orElse`
firstJust :: Maybe a -> Maybe a -> Maybe a

-- | Takes a list of <tt>Maybes</tt> and returns the first <tt>Just</tt> if
--   there is one, or <tt>Nothing</tt> otherwise.
firstJusts :: Foldable f => f (Maybe a) -> Maybe a

-- | Takes computations returnings <tt>Maybes</tt>; tries each one in
--   order. The first one to return a <tt>Just</tt> wins. Returns
--   <tt>Nothing</tt> if all computations return <tt>Nothing</tt>.
firstJustsM :: (Monad m, Foldable f) => f (m (Maybe a)) -> m (Maybe a)
whenIsJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
expectJust :: HasCallStack => String -> Maybe a -> a
rightToMaybe :: Either a b -> Maybe b

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype MaybeT (m :: Type -> Type) a
MaybeT :: m (Maybe a) -> MaybeT (m :: Type -> Type) a
[runMaybeT] :: MaybeT (m :: Type -> Type) a -> m (Maybe a)
liftMaybeT :: Monad m => m a -> MaybeT m a

-- | Try performing an <a>IO</a> action, failing on error.
tryMaybeT :: IO a -> MaybeT IO a
instance GHC.Base.Functor (GHC.Data.Maybe.MaybeErr err)
instance GHC.Base.Applicative (GHC.Data.Maybe.MaybeErr err)
instance GHC.Base.Monad (GHC.Data.Maybe.MaybeErr err)


-- | Platform description
module GHC.Platform

-- | Platform description
--   
--   This is used to describe platforms so that we can generate code for
--   them.
data Platform
Platform :: !ArchOS -> !PlatformWordSize -> !ByteOrder -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Maybe PlatformConstants -> Platform

-- | Architecture and OS
[platformArchOS] :: Platform -> !ArchOS

-- | Word size
[platformWordSize] :: Platform -> !PlatformWordSize

-- | Byte order (endianness)
[platformByteOrder] :: Platform -> !ByteOrder
[platformUnregisterised] :: Platform -> !Bool
[platformHasGnuNonexecStack] :: Platform -> !Bool
[platformHasIdentDirective] :: Platform -> !Bool
[platformHasSubsectionsViaSymbols] :: Platform -> !Bool
[platformIsCrossCompiling] :: Platform -> !Bool

-- | Symbols need underscore prefix
[platformLeadingUnderscore] :: Platform -> !Bool

-- | Determines whether we will be compiling info tables that reside just
--   before the entry code, or with an indirection to the entry code. See
--   TABLES_NEXT_TO_CODE in includes<i>rts</i>storage/InfoTables.h.
[platformTablesNextToCode] :: Platform -> !Bool

-- | Constants such as structure offsets, type sizes, etc.
[platform_constants] :: Platform -> !Maybe PlatformConstants
data PlatformWordSize

-- | A 32-bit platform
PW4 :: PlatformWordSize

-- | A 64-bit platform
PW8 :: PlatformWordSize

-- | Platform architecture
platformArch :: Platform -> Arch

-- | Platform OS
platformOS :: Platform -> OS

-- | Platform architecture and OS.
data ArchOS
ArchOS :: Arch -> OS -> ArchOS
[archOS_arch] :: ArchOS -> Arch
[archOS_OS] :: ArchOS -> OS

-- | Architectures
--   
--   TODO: It might be nice to extend these constructors with information
--   about what instruction set extensions an architecture might support.
data Arch
ArchUnknown :: Arch
ArchX86 :: Arch
ArchX86_64 :: Arch
ArchPPC :: Arch
ArchPPC_64 :: PPC_64ABI -> Arch
ArchS390X :: Arch
ArchSPARC :: Arch
ArchSPARC64 :: Arch
ArchARM :: ArmISA -> [ArmISAExt] -> ArmABI -> Arch
ArchAArch64 :: Arch
ArchAlpha :: Arch
ArchMipseb :: Arch
ArchMipsel :: Arch
ArchRISCV64 :: Arch
ArchJavaScript :: Arch

-- | Operating systems.
--   
--   Using OSUnknown to generate code should produce a sensible default,
--   but no promises.
data OS
OSUnknown :: OS
OSLinux :: OS
OSDarwin :: OS
OSSolaris2 :: OS
OSMinGW32 :: OS
OSFreeBSD :: OS
OSDragonFly :: OS
OSOpenBSD :: OS
OSNetBSD :: OS
OSKFreeBSD :: OS
OSHaiku :: OS
OSQNXNTO :: OS
OSAIX :: OS
OSHurd :: OS

-- | ARM Instruction Set Architecture
data ArmISA
ARMv5 :: ArmISA
ARMv6 :: ArmISA
ARMv7 :: ArmISA

-- | ARM extensions
data ArmISAExt
VFPv2 :: ArmISAExt
VFPv3 :: ArmISAExt
VFPv3D16 :: ArmISAExt
NEON :: ArmISAExt
IWMMX2 :: ArmISAExt

-- | ARM ABI
data ArmABI
SOFT :: ArmABI
SOFTFP :: ArmABI
HARD :: ArmABI

-- | PowerPC 64-bit ABI
data PPC_64ABI

-- | PowerPC64
ELF_V1 :: PPC_64ABI

-- | PowerPC64 LE
ELF_V2 :: PPC_64ABI

-- | Byte ordering.
data ByteOrder

-- | most-significant-byte occurs in lowest address.
BigEndian :: ByteOrder

-- | least-significant-byte occurs in lowest address.
LittleEndian :: ByteOrder

-- | This predicate tells us whether the platform is 32-bit.
target32Bit :: Platform -> Bool
isARM :: Arch -> Bool

-- | This predicate tells us whether the OS supports ELF-like shared
--   libraries.
osElfTarget :: OS -> Bool

-- | This predicate tells us whether the OS support Mach-O shared
--   libraries.
osMachOTarget :: OS -> Bool
osSubsectionsViaSymbols :: OS -> Bool
platformUsesFrameworks :: Platform -> Bool
platformWordSizeInBytes :: Platform -> Int
platformWordSizeInBits :: Platform -> Int

-- | Minimum representable Int value for the given platform
platformMinInt :: Platform -> Integer

-- | Maximum representable Int value for the given platform
platformMaxInt :: Platform -> Integer

-- | Maximum representable Word value for the given platform
platformMaxWord :: Platform -> Integer

-- | Test if the given Integer is representable with a platform Int
platformInIntRange :: Platform -> Integer -> Bool

-- | Test if the given Integer is representable with a platform Word
platformInWordRange :: Platform -> Integer -> Bool

-- | For some architectures the C calling convention is that any integer
--   shorter than 64 bits is replaced by its 64 bits representation using
--   sign or zero extension.
platformCConvNeedsExtension :: Platform -> Bool

-- | Platform-specific settings formerly hard-coded in Config.hs.
--   
--   These should probably be all be triaged whether they can be computed
--   from other settings or belong in another another place (like
--   <a>Platform</a> above).
data PlatformMisc
PlatformMisc :: String -> Bool -> Bool -> String -> Bool -> Bool -> String -> PlatformMisc
[platformMisc_targetPlatformString] :: PlatformMisc -> String
[platformMisc_ghcWithInterpreter] :: PlatformMisc -> Bool
[platformMisc_ghcWithSMP] :: PlatformMisc -> Bool
[platformMisc_ghcRTSWays] :: PlatformMisc -> String
[platformMisc_libFFI] :: PlatformMisc -> Bool
[platformMisc_ghcRtsWithLibdw] :: PlatformMisc -> Bool
[platformMisc_llvmTarget] :: PlatformMisc -> String

-- | x86 SSE instructions
data SseVersion
SSE1 :: SseVersion
SSE2 :: SseVersion
SSE3 :: SseVersion
SSE4 :: SseVersion
SSE42 :: SseVersion

-- | x86 BMI (bit manipulation) instructions
data BmiVersion
BMI1 :: BmiVersion
BMI2 :: BmiVersion
data PlatformConstants
PlatformConstants :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> !Integer -> !Integer -> !Integer -> PlatformConstants
[pc_CONTROL_GROUP_CONST_291] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_STD_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_PROF_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCK_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCKS_PER_MBLOCK] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TICKY_BIN_COUNT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR7] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR8] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR9] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR10] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rL1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCCCS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentTSO] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentNursery] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpAlloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgEagerBlackholeInfo] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCEnter1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCFun] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_Capability_r] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_start] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_free] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_blocks] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_flags] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_CostCentreStack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ldvw] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSMPThunkHeader] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_registeredp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_link] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_entry_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgUpdateFrame_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_size] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSmallMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgSmallMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgArrBytes_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgArrBytes_bytes] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_alloc_limit] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_cccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_stackobj] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_sp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_stack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgUpdateFrame_updatee] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgFunInfoExtraRev] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_SELECTEE_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_AP_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_PAYLOAD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MUT_ARR_PTRS_CARD_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_C_STACK_BYTES] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_STACK_WORDS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_AP_STACK_SPLIM] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_WORD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CINT_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_LONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BITMAP_BITS_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TAG_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_LDV_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_ILDV_CREATE_MASK] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_CREATE] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_USE] :: PlatformConstants -> !Integer

-- | Try to locate "DerivedConstants.h" file in the given dirs and to parse
--   the PlatformConstants from it.
--   
--   See Note [Platform constants]
lookupPlatformConstants :: [FilePath] -> IO (Maybe PlatformConstants)
platformConstants :: Platform -> PlatformConstants
platformSOName :: Platform -> FilePath -> FilePath
platformHsSOName :: Platform -> FilePath -> FilePath
platformSOExt :: Platform -> FilePath
genericPlatform :: Platform
instance GHC.Classes.Ord GHC.Platform.PlatformWordSize
instance GHC.Classes.Eq GHC.Platform.PlatformWordSize
instance GHC.Classes.Eq GHC.Platform.Platform
instance GHC.Show.Show GHC.Platform.Platform
instance GHC.Read.Read GHC.Platform.Platform
instance GHC.Classes.Ord GHC.Platform.SseVersion
instance GHC.Classes.Eq GHC.Platform.SseVersion
instance GHC.Classes.Ord GHC.Platform.BmiVersion
instance GHC.Classes.Eq GHC.Platform.BmiVersion
instance GHC.Show.Show GHC.Platform.PlatformWordSize
instance GHC.Read.Read GHC.Platform.PlatformWordSize


-- | Run-time settings
module GHC.Settings
data Settings
Settings :: {-# UNPACK #-} !GhcNameVersion -> {-# UNPACK #-} !FileSettings -> Platform -> {-# UNPACK #-} !ToolSettings -> {-# UNPACK #-} !PlatformMisc -> [(String, String)] -> Settings
[sGhcNameVersion] :: Settings -> {-# UNPACK #-} !GhcNameVersion
[sFileSettings] :: Settings -> {-# UNPACK #-} !FileSettings
[sTargetPlatform] :: Settings -> Platform
[sToolSettings] :: Settings -> {-# UNPACK #-} !ToolSettings
[sPlatformMisc] :: Settings -> {-# UNPACK #-} !PlatformMisc
[sRawSettings] :: Settings -> [(String, String)]

-- | Settings for other executables GHC calls.
--   
--   Probably should further split down by phase, or split between
--   platform-specific and platform-agnostic.
data ToolSettings
ToolSettings :: Bool -> Bool -> Bool -> Bool -> Bool -> String -> (String, [Option]) -> String -> String -> (String, [Option]) -> (String, [Option]) -> (String, [Option]) -> (String, [Option]) -> String -> String -> String -> String -> String -> String -> String -> (String, [Option]) -> (String, [Option]) -> (String, [Option]) -> String -> [String] -> [String] -> Fingerprint -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> ToolSettings
[toolSettings_ldSupportsCompactUnwind] :: ToolSettings -> Bool
[toolSettings_ldSupportsBuildId] :: ToolSettings -> Bool
[toolSettings_ldSupportsFilelist] :: ToolSettings -> Bool
[toolSettings_ldIsGnuLd] :: ToolSettings -> Bool
[toolSettings_ccSupportsNoPie] :: ToolSettings -> Bool
[toolSettings_pgm_L] :: ToolSettings -> String
[toolSettings_pgm_P] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_F] :: ToolSettings -> String
[toolSettings_pgm_c] :: ToolSettings -> String
[toolSettings_pgm_a] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_l] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_lm] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_dll] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_T] :: ToolSettings -> String
[toolSettings_pgm_windres] :: ToolSettings -> String
[toolSettings_pgm_libtool] :: ToolSettings -> String
[toolSettings_pgm_ar] :: ToolSettings -> String
[toolSettings_pgm_otool] :: ToolSettings -> String
[toolSettings_pgm_install_name_tool] :: ToolSettings -> String
[toolSettings_pgm_ranlib] :: ToolSettings -> String

-- | LLVM: opt llvm optimiser
[toolSettings_pgm_lo] :: ToolSettings -> (String, [Option])

-- | LLVM: llc static compiler
[toolSettings_pgm_lc] :: ToolSettings -> (String, [Option])

-- | LLVM: c compiler
[toolSettings_pgm_lcc] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_i] :: ToolSettings -> String
[toolSettings_opt_L] :: ToolSettings -> [String]
[toolSettings_opt_P] :: ToolSettings -> [String]

-- | cached Fingerprint of sOpt_P See Note [Repeated -optP hashing]
[toolSettings_opt_P_fingerprint] :: ToolSettings -> Fingerprint
[toolSettings_opt_F] :: ToolSettings -> [String]
[toolSettings_opt_c] :: ToolSettings -> [String]
[toolSettings_opt_cxx] :: ToolSettings -> [String]
[toolSettings_opt_a] :: ToolSettings -> [String]
[toolSettings_opt_l] :: ToolSettings -> [String]
[toolSettings_opt_lm] :: ToolSettings -> [String]
[toolSettings_opt_windres] :: ToolSettings -> [String]

-- | LLVM: llvm optimiser
[toolSettings_opt_lo] :: ToolSettings -> [String]

-- | LLVM: llc static compiler
[toolSettings_opt_lc] :: ToolSettings -> [String]

-- | LLVM: c compiler
[toolSettings_opt_lcc] :: ToolSettings -> [String]

-- | iserv options
[toolSettings_opt_i] :: ToolSettings -> [String]
[toolSettings_extraGccViaCFlags] :: ToolSettings -> [String]

-- | Paths to various files and directories used by GHC, including those
--   that provide more settings.
data FileSettings
FileSettings :: FilePath -> FilePath -> Maybe FilePath -> FilePath -> String -> FilePath -> FileSettings
[fileSettings_ghcUsagePath] :: FileSettings -> FilePath
[fileSettings_ghciUsagePath] :: FileSettings -> FilePath
[fileSettings_toolDir] :: FileSettings -> Maybe FilePath
[fileSettings_topDir] :: FileSettings -> FilePath
[fileSettings_tmpDir] :: FileSettings -> String
[fileSettings_globalPackageDatabase] :: FileSettings -> FilePath

-- | Settings for what GHC this is.
data GhcNameVersion
GhcNameVersion :: String -> String -> GhcNameVersion
[ghcNameVersion_programName] :: GhcNameVersion -> String
[ghcNameVersion_projectVersion] :: GhcNameVersion -> String

-- | Platform description
--   
--   This is used to describe platforms so that we can generate code for
--   them.
data Platform
Platform :: !ArchOS -> !PlatformWordSize -> !ByteOrder -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Maybe PlatformConstants -> Platform

-- | Architecture and OS
[platformArchOS] :: Platform -> !ArchOS

-- | Word size
[platformWordSize] :: Platform -> !PlatformWordSize

-- | Byte order (endianness)
[platformByteOrder] :: Platform -> !ByteOrder
[platformUnregisterised] :: Platform -> !Bool
[platformHasGnuNonexecStack] :: Platform -> !Bool
[platformHasIdentDirective] :: Platform -> !Bool
[platformHasSubsectionsViaSymbols] :: Platform -> !Bool
[platformIsCrossCompiling] :: Platform -> !Bool

-- | Symbols need underscore prefix
[platformLeadingUnderscore] :: Platform -> !Bool

-- | Determines whether we will be compiling info tables that reside just
--   before the entry code, or with an indirection to the entry code. See
--   TABLES_NEXT_TO_CODE in includes<i>rts</i>storage/InfoTables.h.
[platformTablesNextToCode] :: Platform -> !Bool

-- | Constants such as structure offsets, type sizes, etc.
[platform_constants] :: Platform -> !Maybe PlatformConstants

-- | Platform-specific settings formerly hard-coded in Config.hs.
--   
--   These should probably be all be triaged whether they can be computed
--   from other settings or belong in another another place (like
--   <a>Platform</a> above).
data PlatformMisc
PlatformMisc :: String -> Bool -> Bool -> String -> Bool -> Bool -> String -> PlatformMisc
[platformMisc_targetPlatformString] :: PlatformMisc -> String
[platformMisc_ghcWithInterpreter] :: PlatformMisc -> Bool
[platformMisc_ghcWithSMP] :: PlatformMisc -> Bool
[platformMisc_ghcRTSWays] :: PlatformMisc -> String
[platformMisc_libFFI] :: PlatformMisc -> Bool
[platformMisc_ghcRtsWithLibdw] :: PlatformMisc -> Bool
[platformMisc_llvmTarget] :: PlatformMisc -> String

-- | Dynamic library suffix
dynLibSuffix :: GhcNameVersion -> String
sProgramName :: Settings -> String
sProjectVersion :: Settings -> String
sGhcUsagePath :: Settings -> FilePath
sGhciUsagePath :: Settings -> FilePath
sToolDir :: Settings -> Maybe FilePath
sTopDir :: Settings -> FilePath
sTmpDir :: Settings -> String
sGlobalPackageDatabasePath :: Settings -> FilePath
sLdSupportsCompactUnwind :: Settings -> Bool
sLdSupportsBuildId :: Settings -> Bool
sLdSupportsFilelist :: Settings -> Bool
sLdIsGnuLd :: Settings -> Bool
sGccSupportsNoPie :: Settings -> Bool
sPgm_L :: Settings -> String
sPgm_P :: Settings -> (String, [Option])
sPgm_F :: Settings -> String
sPgm_c :: Settings -> String
sPgm_a :: Settings -> (String, [Option])
sPgm_l :: Settings -> (String, [Option])
sPgm_lm :: Settings -> (String, [Option])
sPgm_dll :: Settings -> (String, [Option])
sPgm_T :: Settings -> String
sPgm_windres :: Settings -> String
sPgm_libtool :: Settings -> String
sPgm_ar :: Settings -> String
sPgm_otool :: Settings -> String
sPgm_install_name_tool :: Settings -> String
sPgm_ranlib :: Settings -> String
sPgm_lo :: Settings -> (String, [Option])
sPgm_lc :: Settings -> (String, [Option])
sPgm_lcc :: Settings -> (String, [Option])
sPgm_i :: Settings -> String
sOpt_L :: Settings -> [String]
sOpt_P :: Settings -> [String]
sOpt_P_fingerprint :: Settings -> Fingerprint
sOpt_F :: Settings -> [String]
sOpt_c :: Settings -> [String]
sOpt_cxx :: Settings -> [String]
sOpt_a :: Settings -> [String]
sOpt_l :: Settings -> [String]
sOpt_lm :: Settings -> [String]
sOpt_windres :: Settings -> [String]
sOpt_lo :: Settings -> [String]
sOpt_lc :: Settings -> [String]
sOpt_lcc :: Settings -> [String]
sOpt_i :: Settings -> [String]
sExtraGccViaCFlags :: Settings -> [String]
sTargetPlatformString :: Settings -> String
sGhcWithInterpreter :: Settings -> Bool
sGhcWithSMP :: Settings -> Bool
sGhcRTSWays :: Settings -> String
sLibFFI :: Settings -> Bool
sGhcRtsWithLibdw :: Settings -> Bool


-- | Code generation backends
module GHC.Driver.Backend

-- | Code generation backends.
--   
--   GHC supports several code generation backends serving different
--   purposes (producing machine code, producing ByteCode for the
--   interpreter) and supporting different platforms.
data Backend

-- | Native code generator backend.
--   
--   Compiles Cmm code into textual assembler, then relies on an external
--   assembler toolchain to produce machine code.
--   
--   Only supports a few platforms (X86, PowerPC, SPARC).
--   
--   See <a>GHC.CmmToAsm</a>.
NCG :: Backend

-- | LLVM backend.
--   
--   Compiles Cmm code into LLVM textual IR, then relies on LLVM toolchain
--   to produce machine code.
--   
--   It relies on LLVM support for the calling convention used by the NCG
--   backend to produce code objects ABI compatible with it (see "cc 10" or
--   "ghccc" calling convention in
--   <a>https://llvm.org/docs/LangRef.html#calling-conventions)</a>.
--   
--   Support a few platforms (X86, AArch64, s390x, ARM).
--   
--   See <a>GHC.CmmToLlvm</a>
LLVM :: Backend

-- | Via-C backend.
--   
--   Compiles Cmm code into C code, then relies on a C compiler to produce
--   machine code.
--   
--   It produces code objects that are *not* ABI compatible with those
--   produced by NCG and LLVM backends.
--   
--   Produced code is expected to be less efficient than the one produced
--   by NCG and LLVM backends because STG registers are not pinned into
--   real registers. On the other hand, it supports more target platforms
--   (those having a valid C toolchain).
--   
--   See <a>GHC.CmmToC</a>
ViaC :: Backend

-- | ByteCode interpreter.
--   
--   Produce ByteCode objects (BCO, see <a>GHC.ByteCode</a>) that can be
--   interpreted. It is used by GHCi.
--   
--   Currently some extensions are not supported (foreign primops).
--   
--   See <a>GHC.StgToByteCode</a>
Interpreter :: Backend

-- | No code generated.
--   
--   Use this to disable code generation. It is particularly useful when
--   GHC is used as a library for other purpose than generating code (e.g.
--   to generate documentation with Haddock) or when the user requested it
--   (via -fno-code) for some reason.
NoBackend :: Backend

-- | Default backend to use for the given platform.
platformDefaultBackend :: Platform -> Backend

-- | Is the platform supported by the Native Code Generator?
platformNcgSupported :: Platform -> Bool

-- | Will this backend produce an object file on the disk?
backendProducesObject :: Backend -> Bool

-- | Does this backend retain *all* top-level bindings for a module, rather
--   than just the exported bindings, in the TypeEnv and compiled code (if
--   any)?
--   
--   Interpreter backend does this, so that GHCi can call functions inside
--   a module.
--   
--   When no backend is used we also do it, so that Haddock can get access
--   to the GlobalRdrEnv for a module after typechecking it.
backendRetainsAllBindings :: Backend -> Bool
instance GHC.Read.Read GHC.Driver.Backend.Backend
instance GHC.Show.Show GHC.Driver.Backend.Backend
instance GHC.Classes.Ord GHC.Driver.Backend.Backend
instance GHC.Classes.Eq GHC.Driver.Backend.Backend


-- | There are two principal string types used internally by GHC:
--   
--   <ul>
--   <li><i><a>FastString</a></i></li>
--   </ul>
--   
--   <ul>
--   <li>A compact, hash-consed, representation of character strings.</li>
--   <li>Generated by <a>fsLit</a>.</li>
--   <li>You can get a <a>Unique</a> from them.</li>
--   <li>Equality test is O(1) (it uses the Unique).</li>
--   <li>Comparison is O(1) or O(n):</li>
--   <li>O(n) but deterministic with lexical comparison
--   (<a>lexicalCompareFS</a>)</li>
--   <li>O(1) but non-deterministic with Unique comparison
--   (<a>uniqCompareFS</a>)</li>
--   <li>Turn into <a>SDoc</a> with <a>ftext</a>.</li>
--   </ul>
--   
--   <ul>
--   <li><i><a>PtrString</a></i></li>
--   </ul>
--   
--   <ul>
--   <li>Pointer and size of a Latin-1 encoded string.</li>
--   <li>Practically no operations.</li>
--   <li>Outputting them is fast.</li>
--   <li>Generated by <a>sLit</a>.</li>
--   <li>Turn into <a>SDoc</a> with <a>ptext</a></li>
--   <li>Requires manual memory management. Improper use may lead to memory
--   leaks or dangling pointers.</li>
--   <li>It assumes Latin-1 as the encoding, therefore it cannot represent
--   arbitrary Unicode strings.</li>
--   </ul>
--   
--   Use <a>PtrString</a> unless you want the facilities of
--   <a>FastString</a>.
module GHC.Data.FastString

-- | Gives the Modified UTF-8 encoded bytes corresponding to a
--   <a>FastString</a>
bytesFS :: FastString -> ByteString

-- | Gives the Modified UTF-8 encoded bytes corresponding to a
--   <a>FastString</a>

-- | <i>Deprecated: Use <a>bytesFS</a> instead</i>
fastStringToByteString :: FastString -> ByteString

-- | Create a <a>FastString</a> by copying an existing <a>ByteString</a>
mkFastStringByteString :: ByteString -> FastString
fastZStringToByteString :: FastZString -> ByteString
unsafeMkByteString :: String -> ByteString
fastStringToShortByteString :: FastString -> ShortByteString

-- | Create a <a>FastString</a> from an existing <a>ShortByteString</a>
--   without copying.
mkFastStringShortByteString :: ShortByteString -> FastString
data FastZString
hPutFZS :: Handle -> FastZString -> IO ()
zString :: FastZString -> String
lengthFZS :: FastZString -> Int

-- | A <a>FastString</a> is a UTF-8 encoded string together with a unique
--   ID. All <a>FastString</a>s are stored in a global hashtable to support
--   fast O(1) comparison.
--   
--   It is also associated with a lazy reference to the Z-encoding of this
--   string which is used by the compiler internally.
data FastString
FastString :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !ShortByteString -> FastZString -> FastString
[uniq] :: FastString -> {-# UNPACK #-} !Int
[n_chars] :: FastString -> {-# UNPACK #-} !Int
[fs_sbs] :: FastString -> {-# UNPACK #-} !ShortByteString

-- | Lazily computed Z-encoding of this string. See Note [Z-Encoding] in
--   GHC.Utils.Encoding.
--   
--   Since <a>FastString</a>s are globally memoized this is computed at
--   most once for any given string.
[fs_zenc] :: FastString -> FastZString

-- | Non-deterministic FastString
--   
--   This is a simple FastString wrapper with an Ord instance using
--   <a>uniqCompareFS</a> (i.e. which compares FastStrings on their
--   Uniques). Hence it is not deterministic from one run to the other.
newtype NonDetFastString
NonDetFastString :: FastString -> NonDetFastString

-- | Lexical FastString
--   
--   This is a simple FastString wrapper with an Ord instance using
--   <a>lexicalCompareFS</a> (i.e. which compares FastStrings on their
--   String representation). Hence it is deterministic from one run to the
--   other.
newtype LexicalFastString
LexicalFastString :: FastString -> LexicalFastString
fsLit :: String -> FastString

-- | Creates a UTF-8 encoded <a>FastString</a> from a <a>String</a>
mkFastString :: String -> FastString
mkFastStringBytes :: Ptr Word8 -> Int -> FastString

-- | Creates a <a>FastString</a> from a UTF-8 encoded <tt>[Word8]</tt>
mkFastStringByteList :: [Word8] -> FastString
mkFastString# :: Addr# -> FastString

-- | Unpacks and decodes the FastString
unpackFS :: FastString -> String
unconsFS :: FastString -> Maybe (Char, FastString)

-- | Returns a Z-encoded version of a <a>FastString</a>. This might be the
--   original, if it was already Z-encoded. The first time this function is
--   applied to a particular <a>FastString</a>, the results are memoized.
zEncodeFS :: FastString -> FastZString
uniqueOfFS :: FastString -> Int

-- | Returns the length of the <a>FastString</a> in characters
lengthFS :: FastString -> Int

-- | Returns <tt>True</tt> if the <a>FastString</a> is empty
nullFS :: FastString -> Bool
appendFS :: FastString -> FastString -> FastString
headFS :: FastString -> Char
concatFS :: [FastString] -> FastString
consFS :: Char -> FastString -> FastString
nilFS :: FastString
isUnderscoreFS :: FastString -> Bool

-- | Compare FastString lexically
--   
--   If you don't care about the lexical ordering, use <a>uniqCompareFS</a>
--   instead.
lexicalCompareFS :: FastString -> FastString -> Ordering

-- | Compare FastString by their Unique (not lexically).
--   
--   Much cheaper than <a>lexicalCompareFS</a> but non-deterministic!
uniqCompareFS :: FastString -> FastString -> Ordering

-- | Outputs a <a>FastString</a> with <i>no decoding at all</i>, that is,
--   you get the actual bytes in the <a>FastString</a> written to the
--   <a>Handle</a>.
hPutFS :: Handle -> FastString -> IO ()
getFastStringTable :: IO [[[FastString]]]
getFastStringZEncCounter :: IO Int

-- | A <a>PtrString</a> is a pointer to some array of Latin-1 encoded
--   chars.
data PtrString
PtrString :: !Ptr Word8 -> !Int -> PtrString
sLit :: String -> PtrString

-- | Wrap an unboxed address into a <a>PtrString</a>.
mkPtrString# :: Addr# -> PtrString

-- | Encode a <a>String</a> into a newly allocated <a>PtrString</a> using
--   Latin-1 encoding. The original string must not contain non-Latin-1
--   characters (above codepoint <tt>0xff</tt>).
mkPtrString :: String -> PtrString

-- | Decode a <a>PtrString</a> back into a <a>String</a> using Latin-1
--   encoding. This does not free the memory associated with
--   <a>PtrString</a>.
unpackPtrString :: PtrString -> String

-- | Return the length of a <a>PtrString</a>
lengthPS :: PtrString -> Int
instance Control.DeepSeq.NFData GHC.Data.FastString.FastZString
instance Data.Data.Data GHC.Data.FastString.NonDetFastString
instance GHC.Classes.Eq GHC.Data.FastString.NonDetFastString
instance Data.Data.Data GHC.Data.FastString.LexicalFastString
instance GHC.Classes.Eq GHC.Data.FastString.LexicalFastString
instance GHC.Classes.Ord GHC.Data.FastString.LexicalFastString
instance GHC.Show.Show GHC.Data.FastString.LexicalFastString
instance GHC.Classes.Ord GHC.Data.FastString.NonDetFastString
instance GHC.Show.Show GHC.Data.FastString.NonDetFastString
instance GHC.Classes.Eq GHC.Data.FastString.FastString
instance Data.String.IsString GHC.Data.FastString.FastString
instance GHC.Base.Semigroup GHC.Data.FastString.FastString
instance GHC.Base.Monoid GHC.Data.FastString.FastString
instance GHC.Show.Show GHC.Data.FastString.FastString
instance Data.Data.Data GHC.Data.FastString.FastString
instance Control.DeepSeq.NFData GHC.Data.FastString.FastString

module GHC.Utils.Lexeme
isLexCon :: FastString -> Bool
isLexVar :: FastString -> Bool
isLexId :: FastString -> Bool
isLexSym :: FastString -> Bool
isLexConId :: FastString -> Bool
isLexConSym :: FastString -> Bool
isLexVarId :: FastString -> Bool
isLexVarSym :: FastString -> Bool
startsVarSym :: Char -> Bool
startsVarId :: Char -> Bool
startsConSym :: Char -> Bool
startsConId :: Char -> Bool

-- | Is this an acceptable variable name?
okVarOcc :: String -> Bool

-- | Is this an acceptable constructor name?
okConOcc :: String -> Bool

-- | Is this an acceptable type name?
okTcOcc :: String -> Bool

-- | Is this an acceptable alphanumeric variable name, assuming it starts
--   with an acceptable letter?
okVarIdOcc :: String -> Bool

-- | Is this an acceptable symbolic variable name, assuming it starts with
--   an acceptable character?
okVarSymOcc :: String -> Bool

-- | Is this an acceptable alphanumeric constructor name, assuming it
--   starts with an acceptable letter?
okConIdOcc :: String -> Bool

-- | Is this an acceptable symbolic constructor name, assuming it starts
--   with an acceptable character?
okConSymOcc :: String -> Bool

module GHC.Utils.BufHandle
data BufHandle
BufHandle :: {-# UNPACK #-} !Ptr Word8 -> {-# UNPACK #-} !FastMutInt -> Handle -> BufHandle
newBufHandle :: Handle -> IO BufHandle
bPutChar :: BufHandle -> Char -> IO ()
bPutStr :: BufHandle -> String -> IO ()
bPutFS :: BufHandle -> FastString -> IO ()
bPutFZS :: BufHandle -> FastZString -> IO ()
bPutPtrString :: BufHandle -> PtrString -> IO ()

-- | Replicate an 8-bit character
bPutReplicate :: BufHandle -> Int -> Char -> IO ()
bFlush :: BufHandle -> IO ()

module GHC.Data.StringBuffer

-- | A StringBuffer is an internal pointer to a sized chunk of bytes. The
--   bytes are intended to be *immutable*. There are pure operations to
--   read the contents of a StringBuffer.
--   
--   A StringBuffer may have a finalizer, depending on how it was obtained.
data StringBuffer
StringBuffer :: {-# UNPACK #-} !ForeignPtr Word8 -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> StringBuffer
[buf] :: StringBuffer -> {-# UNPACK #-} !ForeignPtr Word8
[len] :: StringBuffer -> {-# UNPACK #-} !Int
[cur] :: StringBuffer -> {-# UNPACK #-} !Int

-- | Read a file into a <a>StringBuffer</a>. The resulting buffer is
--   automatically managed by the garbage collector.
hGetStringBuffer :: FilePath -> IO StringBuffer
hGetStringBufferBlock :: Handle -> Int -> IO StringBuffer
hPutStringBuffer :: Handle -> StringBuffer -> IO ()
appendStringBuffers :: StringBuffer -> StringBuffer -> IO StringBuffer

-- | Encode a <a>String</a> into a <a>StringBuffer</a> as UTF-8. The
--   resulting buffer is automatically managed by the garbage collector.
stringToStringBuffer :: String -> StringBuffer

-- | Return the first UTF-8 character of a nonempty <a>StringBuffer</a> and
--   as well the remaining portion (analogous to <a>uncons</a>).
--   <b>Warning:</b> The behavior is undefined if the <a>StringBuffer</a>
--   is empty. The result shares the same buffer as the original. Similar
--   to <a>utf8DecodeChar</a>, if the character cannot be decoded as UTF-8,
--   <tt>'\0'</tt> is returned.
nextChar :: StringBuffer -> (Char, StringBuffer)

-- | Return the first UTF-8 character of a nonempty <a>StringBuffer</a>
--   (analogous to <a>head</a>). <b>Warning:</b> The behavior is undefined
--   if the <a>StringBuffer</a> is empty. Similar to <a>utf8DecodeChar</a>,
--   if the character cannot be decoded as UTF-8, <tt>'\0'</tt> is
--   returned.
currentChar :: StringBuffer -> Char
prevChar :: StringBuffer -> Char -> Char

-- | Check whether a <a>StringBuffer</a> is empty (analogous to
--   <a>null</a>).
atEnd :: StringBuffer -> Bool

-- | Return a <a>StringBuffer</a> with the first UTF-8 character removed
--   (analogous to <a>tail</a>). <b>Warning:</b> The behavior is undefined
--   if the <a>StringBuffer</a> is empty. The result shares the same buffer
--   as the original.
stepOn :: StringBuffer -> StringBuffer

-- | Return a <a>StringBuffer</a> with the first <tt>n</tt> bytes removed.
--   <b>Warning:</b> If there aren't enough characters, the returned
--   <a>StringBuffer</a> will be invalid and any use of it may lead to
--   undefined behavior. The result shares the same buffer as the original.
offsetBytes :: Int -> StringBuffer -> StringBuffer

-- | Compute the difference in offset between two <a>StringBuffer</a>s that
--   share the same buffer. <b>Warning:</b> The behavior is undefined if
--   the <a>StringBuffer</a>s use separate buffers.
byteDiff :: StringBuffer -> StringBuffer -> Int

-- | Computes a <a>StringBuffer</a> which points to the first character of
--   the wanted line. Lines begin at 1.
atLine :: Int -> StringBuffer -> Maybe StringBuffer

-- | Decode the first <tt>n</tt> bytes of a <a>StringBuffer</a> as UTF-8
--   into a <a>String</a>. Similar to <a>utf8DecodeChar</a>, if the
--   character cannot be decoded as UTF-8, they will be replaced with
--   <tt>'\0'</tt>.
lexemeToString :: StringBuffer -> Int -> String
lexemeToFastString :: StringBuffer -> Int -> FastString

-- | Return the previous <tt>n</tt> characters (or fewer if we are less
--   than <tt>n</tt> characters into the buffer.
decodePrevNChars :: Int -> StringBuffer -> String
parseUnsignedInteger :: StringBuffer -> Int -> Integer -> (Char -> Int) -> Integer

-- | Returns true if the buffer contains Unicode bi-directional formatting
--   characters.
--   
--   
--   <a>https://www.unicode.org/reports/tr9/#Bidirectional_Character_Types</a>
--   
--   Bidirectional format characters are one of 'x202a' : "U+202A
--   LEFT-TO-RIGHT EMBEDDING (LRE)" 'x202b' : "U+202B RIGHT-TO-LEFT
--   EMBEDDING (RLE)" 'x202c' : "U+202C POP DIRECTIONAL FORMATTING (PDF)"
--   'x202d' : "U+202D LEFT-TO-RIGHT OVERRIDE (LRO)" 'x202e' : "U+202E
--   RIGHT-TO-LEFT OVERRIDE (RLO)" 'x2066' : "U+2066 LEFT-TO-RIGHT ISOLATE
--   (LRI)" 'x2067' : "U+2067 RIGHT-TO-LEFT ISOLATE (RLI)" 'x2068' :
--   "U+2068 FIRST STRONG ISOLATE (FSI)" 'x2069' : "U+2069 POP DIRECTIONAL
--   ISOLATE (PDI)"
--   
--   This list is encoded in <a>bidirectionalFormatChars</a>
containsBidirectionalFormatChar :: StringBuffer -> Bool
bidirectionalFormatChars :: [(Char, String)]
instance GHC.Show.Show GHC.Data.StringBuffer.StringBuffer


-- | John Hughes's and Simon Peyton Jones's Pretty Printer Combinators
--   
--   Based on <i>The Design of a Pretty-printing Library</i> in Advanced
--   Functional Programming, Johan Jeuring and Erik Meijer (eds), LNCS 925
--   <a>http://www.cse.chalmers.se/~rjmh/Papers/pretty.ps</a>
module GHC.Utils.Ppr

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc

-- | The TextDetails data type
--   
--   A TextDetails represents a fragment of text that will be output at
--   some point.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails
PStr :: FastString -> TextDetails
ZStr :: FastZString -> TextDetails
LStr :: {-# UNPACK #-} !PtrString -> TextDetails
RStr :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Char -> TextDetails

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc
ftext :: FastString -> Doc
ptext :: PtrString -> Doc
ztext :: FastZString -> Doc

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc
hex :: Integer -> Doc
semi :: Doc
comma :: Doc
colon :: Doc
space :: Doc
equals :: Doc
lparen :: Doc
rparen :: Doc
lbrack :: Doc
rbrack :: Doc
lbrace :: Doc
rbrace :: Doc
parens :: Doc -> Doc
brackets :: Doc -> Doc
braces :: Doc -> Doc
quotes :: Doc -> Doc
quote :: Doc -> Doc
doubleQuotes :: Doc -> Doc

-- | Apply <a>parens</a> to <a>Doc</a> if boolean is true.
maybeParens :: Bool -> Doc -> Doc

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc
infixl 6 <>

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc
infixl 6 <+>

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc] -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc
infixl 5 $$

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc -> Doc -> Doc
infixl 5 $+$

-- | List version of <a>$$</a>.
vcat :: [Doc] -> Doc

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc] -> Doc

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc] -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | Apply <a>hang</a> to the arguments if the first <a>Doc</a> is not
--   empty.
hangNotEmpty :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> Bool

-- | A rendering style.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode
[mode] :: Style -> Mode

-- | Length of line, in chars
[lineLength] :: Style -> Int

-- | Ratio of line length to ribbon length
[ribbonsPerLine] :: Style -> Float

-- | The default style (<tt>mode=PageMode False, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc -> String

-- | Rendering mode.
data Mode

-- | Normal
PageMode :: Bool -> Mode
[asciiSpace] :: Mode -> Bool

-- | With zig-zag cuts
ZigZagMode :: Mode

-- | No indentation, infinitely long lines
LeftMode :: Mode

-- | All on one line
OneLineMode :: Mode

-- | The general rendering interface.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a

-- | Default TextDetails printer
txtPrinter :: TextDetails -> String -> String
printDoc :: Mode -> Int -> Handle -> Doc -> IO ()
printDoc_ :: Mode -> Int -> Handle -> Doc -> IO ()
bufLeftRender :: BufHandle -> Doc -> IO ()
instance GHC.Show.Show GHC.Utils.Ppr.Doc

module GHC.Utils.Ppr.Colour

-- | A colour/style for use with <tt>coloured</tt>.
newtype PprColour
PprColour :: String -> PprColour
[renderColour] :: PprColour -> String
renderColourAfresh :: PprColour -> String
colCustom :: String -> PprColour
colReset :: PprColour
colBold :: PprColour
colBlackFg :: PprColour
colRedFg :: PprColour
colGreenFg :: PprColour
colYellowFg :: PprColour
colBlueFg :: PprColour
colMagentaFg :: PprColour
colCyanFg :: PprColour
colWhiteFg :: PprColour
data Scheme
Scheme :: PprColour -> PprColour -> PprColour -> PprColour -> PprColour -> PprColour -> Scheme
[sHeader] :: Scheme -> PprColour
[sMessage] :: Scheme -> PprColour
[sWarning] :: Scheme -> PprColour
[sError] :: Scheme -> PprColour
[sFatal] :: Scheme -> PprColour
[sMargin] :: Scheme -> PprColour
defaultScheme :: Scheme

-- | Parse the colour scheme from a string (presumably from the
--   <tt>GHC_COLORS</tt> environment variable).
parseScheme :: String -> (OverridingBool, Scheme) -> (OverridingBool, Scheme)
instance GHC.Base.Semigroup GHC.Utils.Ppr.Colour.PprColour
instance GHC.Base.Monoid GHC.Utils.Ppr.Colour.PprColour

module Language.Haskell.Syntax.Type

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type

-- | This is used in the syntax. In constructor declaration. It must keep
--   the arrow representation.
data HsScaled pass a
HsScaled :: HsArrow pass -> a -> HsScaled pass a
hsMult :: HsScaled pass a -> HsArrow pass
hsScaledThing :: HsScaled pass a -> a

-- | Denotes the type of arrows in the surface language
data HsArrow pass

-- | a -&gt; b or a â b
HsUnrestrictedArrow :: IsUnicodeSyntax -> HsArrow pass

-- | a %1 -&gt; b or a %1 â b, or a â¸ b
HsLinearArrow :: IsUnicodeSyntax -> Maybe AddEpAnn -> HsArrow pass

-- | a %m -&gt; b or a %m â b (very much including `a %Many -&gt; b`! This
--   is how the programmer wrote it). It is stored as an <a>HsType</a> so
--   as to preserve the syntax as written in the program.
HsExplicitMult :: IsUnicodeSyntax -> Maybe AddEpAnn -> LHsType pass -> HsArrow pass

-- | When creating syntax we use the shorthands. It's better for printing,
--   also, the shorthands work trivially at each pass.
hsLinear :: a -> HsScaled pass a

-- | When creating syntax we use the shorthands. It's better for printing,
--   also, the shorthands work trivially at each pass.
hsUnrestricted :: a -> HsScaled pass a

-- | Haskell Type
data HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnForall</a>,
--   <a>AnnDot</a>,<a>AnnDarrow</a> For details on above see note [exact
--   print annotations] in <a>GHC.Parser.Annotation</a></li>
--   </ul>
HsForAllTy :: XForAllTy pass -> HsForAllTelescope pass -> LHsType pass -> HsType pass
[hst_xforall] :: HsType pass -> XForAllTy pass
[hst_tele] :: HsType pass -> HsForAllTelescope pass
[hst_body] :: HsType pass -> LHsType pass
HsQualTy :: XQualTy pass -> Maybe (LHsContext pass) -> LHsType pass -> HsType pass
[hst_xqual] :: HsType pass -> XQualTy pass
[hst_ctxt] :: HsType pass -> Maybe (LHsContext pass)
[hst_body] :: HsType pass -> LHsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsTyVar :: XTyVar pass -> PromotionFlag -> LIdP pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsAppTy :: XAppTy pass -> LHsType pass -> LHsType pass -> HsType pass
HsAppKindTy :: XAppKindTy pass -> LHsType pass -> LHsKind pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a>,</li>
--   </ul>
HsFunTy :: XFunTy pass -> HsArrow pass -> LHsType pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>, <a>AnnClose</a>
--   <tt>']'</tt></li>
--   </ul>
HsListTy :: XListTy pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(' or '(#'</tt>,
--   <a>AnnClose</a> <tt>')' or '#)'</tt></li>
--   </ul>
HsTupleTy :: XTupleTy pass -> HsTupleSort -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(#'</tt>,
--   <a>AnnClose</a> '#)'@</li>
--   </ul>
HsSumTy :: XSumTy pass -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsOpTy :: XOpTy pass -> LHsType pass -> LIdP pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>, <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
HsParTy :: XParTy pass -> LHsType pass -> HsType pass

-- | <pre>
--   (?x :: ty)
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
HsIParamTy :: XIParamTy pass -> XRec pass HsIPName -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsStarTy :: XStarTy pass -> Bool -> HsType pass

-- | <pre>
--   (ty :: kind)
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>,
--   <a>AnnDcolon</a>,<a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsKindSig :: XKindSig pass -> LHsType pass -> LHsKind pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'$('</tt>,
--   <a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsSpliceTy :: XSpliceTy pass -> HsSplice pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsDocTy :: XDocTy pass -> LHsType pass -> LHsDocString -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# UNPACK' or '{-#
--   NOUNPACK'</tt>, <a>AnnClose</a> <tt>'#-}'</tt> <a>AnnBang</a>
--   <tt>'!'</tt></li>
--   </ul>
HsBangTy :: XBangTy pass -> HsSrcBang -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{'</tt>, <a>AnnClose</a>
--   <tt>'}'</tt></li>
--   </ul>
HsRecTy :: XRecTy pass -> [LConDeclField pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>"'["</tt>,
--   <a>AnnClose</a> <tt>']'</tt></li>
--   </ul>
HsExplicitListTy :: XExplicitListTy pass -> PromotionFlag -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>"'("</tt>,
--   <a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsExplicitTupleTy :: XExplicitTupleTy pass -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsTyLit :: XTyLit pass -> HsTyLit -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsWildCardTy :: XWildCardTy pass -> HsType pass
XHsType :: !XXType pass -> HsType pass
type HsCoreTy = Type

-- | Located Haskell Type
type LHsType pass = XRec pass (HsType pass) " May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when in a list"

-- | Haskell Kind
type HsKind pass = HsType pass

-- | Located Haskell Kind
type LHsKind pass = XRec pass (HsKind pass) " 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon'"

-- | The type variable binders in an <a>HsForAllTy</a>. See also <tt>Note
--   [Variable Specificity and Forall Visibility]</tt> in
--   <a>GHC.Tc.Gen.HsType</a>.
data HsForAllTelescope pass

-- | A visible <tt>forall</tt> (e.g., <tt>forall a -&gt; {...}</tt>). These
--   do not have any notion of specificity, so we use <tt>()</tt> as a
--   placeholder value.
HsForAllVis :: XHsForAllVis pass -> [LHsTyVarBndr () pass] -> HsForAllTelescope pass
[hsf_xvis] :: HsForAllTelescope pass -> XHsForAllVis pass
[hsf_vis_bndrs] :: HsForAllTelescope pass -> [LHsTyVarBndr () pass]

-- | An invisible <tt>forall</tt> (e.g., <tt>forall a {b} c. {...}</tt>),
--   where each binder has a <a>Specificity</a>.
HsForAllInvis :: XHsForAllInvis pass -> [LHsTyVarBndr Specificity pass] -> HsForAllTelescope pass
[hsf_xinvis] :: HsForAllTelescope pass -> XHsForAllInvis pass
[hsf_invis_bndrs] :: HsForAllTelescope pass -> [LHsTyVarBndr Specificity pass]
XHsForAllTelescope :: !XXHsForAllTelescope pass -> HsForAllTelescope pass

-- | Haskell Type Variable Binder The flag annotates the binder. It is
--   <a>Specificity</a> in places where explicit specificity is allowed
--   (e.g. x :: forall {a} b. ...) or <tt>()</tt> in other places.
data HsTyVarBndr flag pass
UserTyVar :: XUserTyVar pass -> flag -> LIdP pass -> HsTyVarBndr flag pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnDcolon</a>,
--   <a>AnnClose</a></li>
--   </ul>
KindedTyVar :: XKindedTyVar pass -> flag -> LIdP pass -> LHsKind pass -> HsTyVarBndr flag pass
XTyVarBndr :: !XXTyVarBndr pass -> HsTyVarBndr flag pass

-- | Located Haskell Type Variable Binder
type LHsTyVarBndr flag pass = XRec pass (HsTyVarBndr flag pass)

-- | Located Haskell Quantified Type Variables
data LHsQTyVars pass
HsQTvs :: XHsQTvs pass -> [LHsTyVarBndr () pass] -> LHsQTyVars pass
[hsq_ext] :: LHsQTyVars pass -> XHsQTvs pass
[hsq_explicit] :: LHsQTyVars pass -> [LHsTyVarBndr () pass]
XLHsQTyVars :: !XXLHsQTyVars pass -> LHsQTyVars pass

-- | The outermost type variables in a type that obeys the
--   <tt>forall</tt>-or-nothing rule. See <tt>Note [forall-or-nothing
--   rule]</tt>.
data HsOuterTyVarBndrs flag pass

-- | Implicit forall, e.g., <tt>f :: a -&gt; b -&gt; b</tt>
HsOuterImplicit :: XHsOuterImplicit pass -> HsOuterTyVarBndrs flag pass
[hso_ximplicit] :: HsOuterTyVarBndrs flag pass -> XHsOuterImplicit pass

-- | Explicit forall, e.g., <tt>f :: forall a b. a -&gt; b -&gt; b</tt>
HsOuterExplicit :: XHsOuterExplicit pass flag -> [LHsTyVarBndr flag (NoGhcTc pass)] -> HsOuterTyVarBndrs flag pass
[hso_xexplicit] :: HsOuterTyVarBndrs flag pass -> XHsOuterExplicit pass flag
[hso_bndrs] :: HsOuterTyVarBndrs flag pass -> [LHsTyVarBndr flag (NoGhcTc pass)]
XHsOuterTyVarBndrs :: !XXHsOuterTyVarBndrs pass -> HsOuterTyVarBndrs flag pass

-- | Used for type-family instance equations, e.g.,
--   
--   <pre>
--   type instance forall a. F [a] = Tree a
--   </pre>
--   
--   The notion of specificity is irrelevant in type family equations, so
--   we use <tt>()</tt> for the <a>HsOuterTyVarBndrs</a> <tt>flag</tt>.
type HsOuterFamEqnTyVarBndrs = HsOuterTyVarBndrs ()

-- | Used for signatures, e.g.,
--   
--   <pre>
--   f :: forall a {b}. blah
--   </pre>
--   
--   We use <a>Specificity</a> for the <a>HsOuterTyVarBndrs</a>
--   <tt>flag</tt> to allow distinguishing between specified and inferred
--   type variables.
type HsOuterSigTyVarBndrs = HsOuterTyVarBndrs Specificity

-- | Haskell Wildcard Binders
data HsWildCardBndrs pass thing
HsWC :: XHsWC pass thing -> thing -> HsWildCardBndrs pass thing
[hswc_ext] :: HsWildCardBndrs pass thing -> XHsWC pass thing
[hswc_body] :: HsWildCardBndrs pass thing -> thing
XHsWildCardBndrs :: !XXHsWildCardBndrs pass thing -> HsWildCardBndrs pass thing

-- | Types that can appear in pattern signatures, as well as the signatures
--   for term-level binders in RULES. See <tt>Note [Pattern signature
--   binders and scoping]</tt>.
--   
--   This is very similar to <tt>HsSigWcType</tt>, but with slightly
--   different semantics: see <tt>Note [HsType binders]</tt>. See also
--   <tt>Note [The wildcard story for types]</tt>.
data HsPatSigType pass
HsPS :: XHsPS pass -> LHsType pass -> HsPatSigType pass

-- | After renamer: <a>HsPSRn</a>
[hsps_ext] :: HsPatSigType pass -> XHsPS pass

-- | Main payload (the type itself)
[hsps_body] :: HsPatSigType pass -> LHsType pass
XHsPatSigType :: !XXHsPatSigType pass -> HsPatSigType pass

-- | The extension field for <a>HsPatSigType</a>, which is only used in the
--   renamer onwards. See <tt>Note [Pattern signature binders and
--   scoping]</tt>.
data HsPSRn
HsPSRn :: [Name] -> [Name] -> HsPSRn

-- | Wildcard names
[hsps_nwcs] :: HsPSRn -> [Name]

-- | Implicitly bound variable names
[hsps_imp_tvs] :: HsPSRn -> [Name]

-- | A type signature that obeys the <tt>forall</tt>-or-nothing rule. In
--   other words, an <a>LHsType</a> that uses an
--   <a>HsOuterSigTyVarBndrs</a> to represent its outermost type variable
--   quantification. See <tt>Note [Representing type signatures]</tt>.
data HsSigType pass
HsSig :: XHsSig pass -> HsOuterSigTyVarBndrs pass -> LHsType pass -> HsSigType pass
[sig_ext] :: HsSigType pass -> XHsSig pass
[sig_bndrs] :: HsSigType pass -> HsOuterSigTyVarBndrs pass
[sig_body] :: HsSigType pass -> LHsType pass
XHsSigType :: !XXHsSigType pass -> HsSigType pass

-- | Located Haskell Signature Type
type LHsSigType pass = XRec pass (HsSigType pass)

-- | Located Haskell Signature Wildcard Type
type LHsSigWcType pass = HsWildCardBndrs pass (LHsSigType pass)

-- | Located Haskell Wildcard Type
type LHsWcType pass = HsWildCardBndrs pass (LHsType pass)

-- | Haskell Tuple Sort
data HsTupleSort
HsUnboxedTuple :: HsTupleSort
HsBoxedOrConstraintTuple :: HsTupleSort

-- | Haskell Context
type HsContext pass = [LHsType pass]

-- | Located Haskell Context
type LHsContext pass = XRec pass (HsContext pass) " 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnUnit' For details on above see note [exact print annotations] in GHC.Parser.Annotation"

-- | Haskell Type Literal
data HsTyLit
HsNumTy :: SourceText -> Integer -> HsTyLit
HsStrTy :: SourceText -> FastString -> HsTyLit
HsCharTy :: SourceText -> Char -> HsTyLit

-- | These names are used early on to store the names of implicit
--   parameters. They completely disappear after type-checking.
newtype HsIPName
HsIPName :: FastString -> HsIPName
hsIPNameFS :: HsIPName -> FastString
data HsArg tm ty
HsValArg :: tm -> HsArg tm ty
HsTypeArg :: SrcSpan -> ty -> HsArg tm ty
HsArgPar :: SrcSpan -> HsArg tm ty
numVisibleArgs :: [HsArg tm ty] -> Arity
type LHsTypeArg p = HsArg (LHsType p) (LHsKind p)

-- | Located Bang Type
type LBangType pass = XRec pass (BangType pass)

-- | Bang Type
--   
--   In the parser, strictness and packedness annotations bind more tightly
--   than docstrings. This means that when consuming a <a>BangType</a> (and
--   looking for <a>HsBangTy</a>) we must be ready to peer behind a
--   potential layer of <a>HsDocTy</a>. See #15206 for motivation and
--   <tt>getBangType</tt> for an example.
type BangType pass = HsType pass

-- | Haskell Source Bang
--   
--   Bangs on data constructor arguments as the user wrote them in the
--   source code.
--   
--   <tt>(HsSrcBang _ SrcUnpack SrcLazy)</tt> and <tt>(HsSrcBang _
--   SrcUnpack NoSrcStrict)</tt> (without StrictData) makes no sense, we
--   emit a warning (in checkValidDataCon) and treat it like <tt>(HsSrcBang
--   _ NoSrcUnpack SrcLazy)</tt>
data HsSrcBang
HsSrcBang :: SourceText -> SrcUnpackedness -> SrcStrictness -> HsSrcBang

-- | Haskell Implementation Bang
--   
--   Bangs of data constructor arguments as generated by the compiler after
--   consulting HsSrcBang, flags, etc.
data HsImplBang

-- | Lazy field, or one with an unlifted type
HsLazy :: HsImplBang

-- | Strict but not unpacked field
HsStrict :: HsImplBang

-- | Strict and unpacked field co :: arg-ty ~ product-ty HsBang
HsUnpack :: Maybe Coercion -> HsImplBang

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie <tt>~</tt>
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {-# UNPACK #-} specified
SrcUnpack :: SrcUnpackedness

-- | {-# NOUNPACK #-} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness

-- | Constructor Declaration Field
data ConDeclField pass
ConDeclField :: XConDeclField pass -> [LFieldOcc pass] -> LBangType pass -> Maybe LHsDocString -> ConDeclField pass
[cd_fld_ext] :: ConDeclField pass -> XConDeclField pass

-- | See Note [ConDeclField passs]
[cd_fld_names] :: ConDeclField pass -> [LFieldOcc pass]
[cd_fld_type] :: ConDeclField pass -> LBangType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
[cd_fld_doc] :: ConDeclField pass -> Maybe LHsDocString
XConDeclField :: !XXConDeclField pass -> ConDeclField pass

-- | Located Constructor Declaration Field
type LConDeclField pass = XRec pass (ConDeclField pass) " May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when in a list"

-- | Describes the arguments to a data constructor. This is a common
--   representation for several constructor-related concepts, including:
--   
--   <ul>
--   <li>The arguments in a Haskell98-style constructor declaration (see
--   <tt>HsConDeclH98Details</tt> in <a>GHC.Hs.Decls</a>).</li>
--   <li>The arguments in constructor patterns in <tt>case</tt>/function
--   definitions (see <tt>HsConPatDetails</tt> in <a>GHC.Hs.Pat</a>).</li>
--   <li>The left-hand side arguments in a pattern synonym binding (see
--   <tt>HsPatSynDetails</tt> in <a>GHC.Hs.Binds</a>).</li>
--   </ul>
--   
--   One notable exception is the arguments in a GADT constructor, which
--   uses a separate data type entirely (see <tt>HsConDeclGADTDetails</tt>
--   in <a>GHC.Hs.Decls</a>). This is because GADT constructors cannot be
--   declared with infix syntax, unlike the concepts above (#18844).
data HsConDetails tyarg arg rec
PrefixCon :: [tyarg] -> [arg] -> HsConDetails tyarg arg rec
RecCon :: rec -> HsConDetails tyarg arg rec
InfixCon :: arg -> arg -> HsConDetails tyarg arg rec

-- | An empty list that can be used to indicate that there are no type
--   arguments allowed in cases where HsConDetails is applied to Void.
noTypeArgs :: [Void]

-- | Field Occurrence
--   
--   Represents an *occurrence* of an unambiguous field. This may or may
--   not be a binding occurrence (e.g. this type is used in
--   <a>ConDeclField</a> and <tt>RecordPatSynField</tt> which bind their
--   fields, but also in <tt>HsRecField</tt> for record construction and
--   patterns, which do not).
--   
--   We store both the <a>RdrName</a> the user originally wrote, and after
--   the renamer, the selector function.
data FieldOcc pass
FieldOcc :: XCFieldOcc pass -> LocatedN RdrName -> FieldOcc pass
[extFieldOcc] :: FieldOcc pass -> XCFieldOcc pass

-- | See Note [Located RdrNames] in <a>GHC.Hs.Expr</a>
[rdrNameFieldOcc] :: FieldOcc pass -> LocatedN RdrName
XFieldOcc :: !XXFieldOcc pass -> FieldOcc pass

-- | Located Field Occurrence
type LFieldOcc pass = XRec pass (FieldOcc pass)

-- | Ambiguous Field Occurrence
--   
--   Represents an *occurrence* of a field that is potentially ambiguous
--   after the renamer, with the ambiguity resolved by the typechecker. We
--   always store the <a>RdrName</a> that the user originally wrote, and
--   store the selector function after the renamer (for unambiguous
--   occurrences) or the typechecker (for ambiguous occurrences).
--   
--   See Note [HsRecField and HsRecUpdField] in <a>GHC.Hs.Pat</a> and Note
--   [Disambiguating record fields] in <a>GHC.Tc.Gen.Head</a>. See Note
--   [Located RdrNames] in <a>GHC.Hs.Expr</a>
data AmbiguousFieldOcc pass
Unambiguous :: XUnambiguous pass -> LocatedN RdrName -> AmbiguousFieldOcc pass
Ambiguous :: XAmbiguous pass -> LocatedN RdrName -> AmbiguousFieldOcc pass
XAmbiguousFieldOcc :: !XXAmbiguousFieldOcc pass -> AmbiguousFieldOcc pass
mapHsOuterImplicit :: (XHsOuterImplicit pass -> XHsOuterImplicit pass) -> HsOuterTyVarBndrs flag pass -> HsOuterTyVarBndrs flag pass
hsQTvExplicit :: LHsQTyVars pass -> [LHsTyVarBndr () pass]

-- | Does this <a>HsTyVarBndr</a> come with an explicit kind annotation?
isHsKindedTyVar :: HsTyVarBndr flag pass -> Bool
hsPatSigType :: HsPatSigType pass -> LHsType pass
instance Data.Data.Data Language.Haskell.Syntax.Type.HsPSRn
instance Data.Data.Data Language.Haskell.Syntax.Type.HsIPName
instance GHC.Classes.Eq Language.Haskell.Syntax.Type.HsIPName
instance Data.Data.Data Language.Haskell.Syntax.Type.HsTyLit
instance Data.Data.Data Language.Haskell.Syntax.Type.HsTupleSort
instance (Data.Data.Data tyarg, Data.Data.Data arg, Data.Data.Data rec) => Data.Data.Data (Language.Haskell.Syntax.Type.HsConDetails tyarg arg rec)
instance (GHC.Classes.Eq (Language.Haskell.Syntax.Extension.XCFieldOcc pass), GHC.Classes.Eq (Language.Haskell.Syntax.Extension.XXFieldOcc pass)) => GHC.Classes.Eq (Language.Haskell.Syntax.Type.FieldOcc pass)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsScaled pass a)
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.FieldOcc pass)
instance GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.Type.FieldOcc pass)
instance GHC.Utils.Outputable.OutputableBndr (GHC.Types.SrcLoc.GenLocated GHC.Types.SrcLoc.SrcSpan (Language.Haskell.Syntax.Type.FieldOcc pass))
instance (GHC.Utils.Outputable.Outputable tm, GHC.Utils.Outputable.Outputable ty) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsArg tm ty)
instance (GHC.Utils.Outputable.Outputable tyarg, GHC.Utils.Outputable.Outputable arg, GHC.Utils.Outputable.Outputable rec) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsConDetails tyarg arg rec)
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Type.HsTyLit
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Type.HsIPName
instance GHC.Utils.Outputable.OutputableBndr Language.Haskell.Syntax.Type.HsIPName

module Language.Haskell.Syntax.Extension

-- | A placeholder type for TTG extension points that are not currently
--   unused to represent any particular value.
--   
--   This should not be confused with <a>NoExtCon</a>, which are found in
--   unused extension <i>constructors</i> and therefore should never be
--   inhabited. In contrast, <a>NoExtField</a> is used in extension
--   <i>points</i> (e.g., as the field of some constructor), so it must
--   have an inhabitant to construct AST passes that manipulate fields with
--   that extension point as their type.
data NoExtField
NoExtField :: NoExtField

-- | Used when constructing a term with an unused extension point.
noExtField :: NoExtField

-- | Used in TTG extension constructors that have yet to be extended with
--   anything. If an extension constructor has <a>NoExtCon</a> as its
--   field, it is not intended to ever be constructed anywhere, and any
--   function that consumes the extension constructor can eliminate it by
--   way of <a>noExtCon</a>.
--   
--   This should not be confused with <a>NoExtField</a>, which are found in
--   unused extension <i>points</i> (not <i>constructors</i>) and therefore
--   can be inhabited.
data NoExtCon

-- | Eliminate a <a>NoExtCon</a>. Much like <a>absurd</a>.
noExtCon :: NoExtCon -> a

-- | GHC's L prefixed variants wrap their vanilla variant in this type
--   family, to add <tt>SrcLoc</tt> info via <tt>Located</tt>. Other passes
--   than <tt>GhcPass</tt> not interested in location information can
--   define this as <tt>type instance XRec NoLocated a = a</tt>. See Note
--   [XRec and SrcSpans in the AST]
type family XRec p a = r | r -> a
type family Anno a = b

-- | We can strip off the XRec to access the underlying data. See Note
--   [XRec and SrcSpans in the AST]
class UnXRec p
unXRec :: UnXRec p => XRec p a -> a

-- | We can map over the underlying type contained in an <tt>XRec</tt>
--   while preserving the annotation as is.
class MapXRec p
mapXRec :: (MapXRec p, Anno a ~ Anno b) => (a -> b) -> XRec p a -> XRec p b

-- | The trivial wrapper that carries no additional information See Note
--   [XRec and SrcSpans in the AST]
class WrapXRec p a
wrapXRec :: WrapXRec p a => a -> XRec p a

-- | Maps the "normal" id type for a given pass
type family IdP p
type LIdP p = XRec p (IdP p)
type family XHsValBinds x x'
type family XHsIPBinds x x'
type family XEmptyLocalBinds x x'
type family XXHsLocalBindsLR x x'
type family XValBinds x x'
type family XXValBindsLR x x'
type family XFunBind x x'
type family XPatBind x x'
type family XVarBind x x'
type family XAbsBinds x x'
type family XPatSynBind x x'
type family XXHsBindsLR x x'
type family XABE x
type family XXABExport x
type family XPSB x x'
type family XXPatSynBind x x'
type family XIPBinds x
type family XXHsIPBinds x
type family XCIPBind x
type family XXIPBind x
type family XTypeSig x
type family XPatSynSig x
type family XClassOpSig x
type family XIdSig x
type family XFixSig x
type family XInlineSig x
type family XSpecSig x
type family XSpecInstSig x
type family XMinimalSig x
type family XSCCFunSig x
type family XCompleteMatchSig x
type family XXSig x
type family XFixitySig x
type family XXFixitySig x
type family XStandaloneKindSig x
type family XXStandaloneKindSig x
type family XTyClD x
type family XInstD x
type family XDerivD x
type family XValD x
type family XSigD x
type family XKindSigD x
type family XDefD x
type family XForD x
type family XWarningD x
type family XAnnD x
type family XRuleD x
type family XSpliceD x
type family XDocD x
type family XRoleAnnotD x
type family XXHsDecl x
type family XCHsGroup x
type family XXHsGroup x
type family XSpliceDecl x
type family XXSpliceDecl x
type family XFamDecl x
type family XSynDecl x
type family XDataDecl x
type family XClassDecl x
type family XXTyClDecl x
type family XCFunDep x
type family XXFunDep x
type family XCTyClGroup x
type family XXTyClGroup x
type family XNoSig x
type family XCKindSig x
type family XTyVarSig x
type family XXFamilyResultSig x
type family XCFamilyDecl x
type family XXFamilyDecl x
type family XCHsDataDefn x
type family XXHsDataDefn x
type family XCHsDerivingClause x
type family XXHsDerivingClause x
type family XDctSingle x
type family XDctMulti x
type family XXDerivClauseTys x
type family XConDeclGADT x
type family XConDeclH98 x
type family XXConDecl x
type family XCFamEqn x r
type family XXFamEqn x r
type family XCTyFamInstDecl x
type family XXTyFamInstDecl x
type family XCClsInstDecl x
type family XXClsInstDecl x
type family XClsInstD x
type family XDataFamInstD x
type family XTyFamInstD x
type family XXInstDecl x
type family XCDerivDecl x
type family XXDerivDecl x
type family XStockStrategy x
type family XAnyClassStrategy x
type family XNewtypeStrategy x
type family XViaStrategy x
type family XCDefaultDecl x
type family XXDefaultDecl x
type family XForeignImport x
type family XForeignExport x
type family XXForeignDecl x
type family XCRuleDecls x
type family XXRuleDecls x
type family XHsRule x
type family XXRuleDecl x
type family XCRuleBndr x
type family XRuleBndrSig x
type family XXRuleBndr x
type family XWarnings x
type family XXWarnDecls x
type family XWarning x
type family XXWarnDecl x
type family XHsAnnotation x
type family XXAnnDecl x
type family XCRoleAnnotDecl x
type family XXRoleAnnotDecl x
type family XCInjectivityAnn x
type family XXInjectivityAnn x
type family XVar x
type family XUnboundVar x
type family XConLikeOut x
type family XRecFld x
type family XOverLabel x
type family XIPVar x
type family XOverLitE x
type family XLitE x
type family XLam x
type family XLamCase x
type family XApp x
type family XAppTypeE x
type family XOpApp x
type family XNegApp x
type family XPar x
type family XSectionL x
type family XSectionR x
type family XExplicitTuple x
type family XExplicitSum x
type family XCase x
type family XIf x
type family XMultiIf x
type family XLet x
type family XDo x
type family XExplicitList x
type family XRecordCon x
type family XRecordUpd x
type family XGetField x
type family XProjection x
type family XExprWithTySig x
type family XArithSeq x
type family XBracket x
type family XRnBracketOut x
type family XTcBracketOut x
type family XSpliceE x
type family XProc x
type family XStatic x
type family XTick x
type family XBinTick x
type family XPragE x
type family XXExpr x
type family XCHsFieldLabel x
type family XXHsFieldLabel x
type family XSCC x
type family XXPragE x
type family XUnambiguous x
type family XAmbiguous x
type family XXAmbiguousFieldOcc x
type family XPresent x
type family XMissing x
type family XXTupArg x
type family XTypedSplice x
type family XUntypedSplice x
type family XQuasiQuote x
type family XSpliced x
type family XXSplice x
type family XExpBr x
type family XPatBr x
type family XDecBrL x
type family XDecBrG x
type family XTypBr x
type family XVarBr x
type family XTExpBr x
type family XXBracket x
type family XCmdTop x
type family XXCmdTop x
type family XMG x b
type family XXMatchGroup x b
type family XCMatch x b
type family XXMatch x b
type family XCGRHSs x b
type family XXGRHSs x b
type family XCGRHS x b
type family XXGRHS x b
type family XLastStmt x x' b
type family XBindStmt x x' b
type family XApplicativeStmt x x' b
type family XBodyStmt x x' b
type family XLetStmt x x' b
type family XParStmt x x' b
type family XTransStmt x x' b
type family XRecStmt x x' b
type family XXStmtLR x x' b
type family XCmdArrApp x
type family XCmdArrForm x
type family XCmdApp x
type family XCmdLam x
type family XCmdPar x
type family XCmdCase x
type family XCmdLamCase x
type family XCmdIf x
type family XCmdLet x
type family XCmdDo x
type family XCmdWrap x
type family XXCmd x
type family XParStmtBlock x x'
type family XXParStmtBlock x x'
type family XApplicativeArgOne x
type family XApplicativeArgMany x
type family XXApplicativeArg x
type family XHsChar x
type family XHsCharPrim x
type family XHsString x
type family XHsStringPrim x
type family XHsInt x
type family XHsIntPrim x
type family XHsWordPrim x
type family XHsInt64Prim x
type family XHsWord64Prim x
type family XHsInteger x
type family XHsRat x
type family XHsFloatPrim x
type family XHsDoublePrim x
type family XXLit x
type family XOverLit x
type family XXOverLit x
type family XWildPat x
type family XVarPat x
type family XLazyPat x
type family XAsPat x
type family XParPat x
type family XBangPat x
type family XListPat x
type family XTuplePat x
type family XSumPat x
type family XConPat x
type family XViewPat x
type family XSplicePat x
type family XLitPat x
type family XNPat x
type family XNPlusKPat x
type family XSigPat x
type family XCoPat x
type family XXPat x
type family XHsRecField x
type family XHsQTvs x
type family XXLHsQTyVars x
type family XHsOuterImplicit x
type family XHsOuterExplicit x flag
type family XXHsOuterTyVarBndrs x
type family XHsSig x
type family XXHsSigType x
type family XHsWC x b
type family XXHsWildCardBndrs x b
type family XHsPS x
type family XXHsPatSigType x
type family XForAllTy x
type family XQualTy x
type family XTyVar x
type family XAppTy x
type family XAppKindTy x
type family XFunTy x
type family XListTy x
type family XTupleTy x
type family XSumTy x
type family XOpTy x
type family XParTy x
type family XIParamTy x
type family XStarTy x
type family XKindSig x
type family XSpliceTy x
type family XDocTy x
type family XBangTy x
type family XRecTy x
type family XExplicitListTy x
type family XExplicitTupleTy x
type family XTyLit x
type family XWildCardTy x
type family XXType x
type family XHsForAllVis x
type family XHsForAllInvis x
type family XXHsForAllTelescope x
type family XUserTyVar x
type family XKindedTyVar x
type family XXTyVarBndr x
type family XConDeclField x
type family XXConDeclField x
type family XCFieldOcc x
type family XXFieldOcc x
type family XCImportDecl x
type family XXImportDecl x
type family XIEVar x
type family XIEThingAbs x
type family XIEThingAll x
type family XIEThingWith x
type family XIEModuleContents x
type family XIEGroup x
type family XIEDoc x
type family XIEDocNamed x
type family XXIE x

-- | See Note [NoGhcTc] in GHC.Hs.Extension. It has to be in this module
--   because it is used like an extension point (in the data definitions of
--   types that should be parameter-agnostic.
type family NoGhcTc (p :: Type)
instance GHC.Classes.Ord Language.Haskell.Syntax.Extension.NoExtField
instance GHC.Classes.Eq Language.Haskell.Syntax.Extension.NoExtField
instance Data.Data.Data Language.Haskell.Syntax.Extension.NoExtField
instance GHC.Classes.Ord Language.Haskell.Syntax.Extension.NoExtCon
instance GHC.Classes.Eq Language.Haskell.Syntax.Extension.NoExtCon
instance Data.Data.Data Language.Haskell.Syntax.Extension.NoExtCon
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Extension.NoExtCon
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Extension.NoExtField


-- | This module defines classes and functions for pretty-printing. It also
--   exports a number of helpful debugging and other utilities such as
--   <tt>trace</tt> and <tt>panic</tt>.
--   
--   The interface to this module is very similar to the standard Hughes-PJ
--   pretty printing module, except that it exports a number of additional
--   functions that are rarely used, and works over the <a>SDoc</a> type.
module GHC.Utils.Outputable

-- | Class designating that some type has an <a>SDoc</a> representation
class Outputable a
ppr :: Outputable a => a -> SDoc

-- | When we print a binder, we often want to print its type too. The
--   <tt>OutputableBndr</tt> class encapsulates this idea.
class Outputable a => OutputableBndr a
pprBndr :: OutputableBndr a => BindingSite -> a -> SDoc
pprPrefixOcc :: OutputableBndr a => a -> SDoc
pprInfixOcc :: OutputableBndr a => a -> SDoc
bndrIsJoin_maybe :: OutputableBndr a => a -> Maybe Int

-- | Outputable class with an additional environment value
--   
--   See Note [The OutputableP class]
class OutputableP env a
pdoc :: OutputableP env a => env -> a -> SDoc

-- | Represents a pretty-printable document.
--   
--   To display an <a>SDoc</a>, use <a>printSDoc</a>, <a>printSDocLn</a>,
--   <a>bufLeftRenderSDoc</a>, or <a>renderWithContext</a>. Avoid calling
--   <a>runSDoc</a> directly as it breaks the abstraction layer.
data SDoc
runSDoc :: SDoc -> SDocContext -> Doc

-- | Wrapper for types having a Outputable instance when an OutputableP
--   instance is required.
newtype PDoc a
PDoc :: a -> PDoc a
docToSDoc :: Doc -> SDoc

-- | Returns the separated concatenation of the pretty printed things.
interppSP :: Outputable a => [a] -> SDoc

-- | Returns the comma-separated concatenation of the pretty printed
--   things.
interpp'SP :: Outputable a => [a] -> SDoc
interpp'SP' :: (a -> SDoc) -> [a] -> SDoc

-- | Returns the comma-separated concatenation of the quoted pretty printed
--   things.
--   
--   <pre>
--   [x,y,z]  ==&gt;  `x', `y', `z'
--   </pre>
pprQuotedList :: Outputable a => [a] -> SDoc
pprWithCommas :: (a -> SDoc) -> [a] -> SDoc
quotedListWithOr :: [SDoc] -> SDoc
quotedListWithNor :: [SDoc] -> SDoc
pprWithBars :: (a -> SDoc) -> [a] -> SDoc
empty :: SDoc
isEmpty :: SDocContext -> SDoc -> Bool

-- | Indent <a>SDoc</a> some specified amount
nest :: Int -> SDoc -> SDoc
char :: Char -> SDoc
text :: String -> SDoc
ftext :: FastString -> SDoc
ptext :: PtrString -> SDoc
ztext :: FastZString -> SDoc
int :: Int -> SDoc
intWithCommas :: Integral a => a -> SDoc
integer :: Integer -> SDoc
word :: Integer -> SDoc
float :: Float -> SDoc
double :: Double -> SDoc
rational :: Rational -> SDoc

-- | <tt>doublePrec p n</tt> shows a floating point number <tt>n</tt> with
--   <tt>p</tt> digits of precision after the decimal point.
doublePrec :: Int -> Double -> SDoc
parens :: SDoc -> SDoc
cparen :: Bool -> SDoc -> SDoc
brackets :: SDoc -> SDoc
braces :: SDoc -> SDoc
quotes :: SDoc -> SDoc
quote :: SDoc -> SDoc
doubleQuotes :: SDoc -> SDoc
angleBrackets :: SDoc -> SDoc
semi :: SDoc
comma :: SDoc
colon :: SDoc
dcolon :: SDoc
space :: SDoc
equals :: SDoc
dot :: SDoc
vbar :: SDoc
arrow :: SDoc
lollipop :: SDoc
larrow :: SDoc
darrow :: SDoc
arrowt :: SDoc
larrowt :: SDoc
arrowtt :: SDoc
larrowtt :: SDoc
lambda :: SDoc
lparen :: SDoc
rparen :: SDoc
lbrack :: SDoc
rbrack :: SDoc
lbrace :: SDoc
rbrace :: SDoc
underscore :: SDoc
mulArrow :: SDoc -> SDoc
blankLine :: SDoc
forAllLit :: SDoc
bullet :: SDoc

-- | Join two <a>SDoc</a> together horizontally without a gap
(<>) :: SDoc -> SDoc -> SDoc

-- | Join two <a>SDoc</a> together horizontally with a gap between them
(<+>) :: SDoc -> SDoc -> SDoc

-- | Concatenate <a>SDoc</a> horizontally
hcat :: [SDoc] -> SDoc

-- | Concatenate <a>SDoc</a> horizontally with a space between each one
hsep :: [SDoc] -> SDoc

-- | Join two <a>SDoc</a> together vertically; if there is no vertical
--   overlap it "dovetails" the two onto one line
($$) :: SDoc -> SDoc -> SDoc

-- | Join two <a>SDoc</a> together vertically
($+$) :: SDoc -> SDoc -> SDoc

-- | Concatenate <a>SDoc</a> vertically with dovetailing
vcat :: [SDoc] -> SDoc

-- | Separate: is either like <a>hsep</a> or like <a>vcat</a>, depending on
--   what fits
sep :: [SDoc] -> SDoc

-- | Catenate: is either like <a>hcat</a> or like <a>vcat</a>, depending on
--   what fits
cat :: [SDoc] -> SDoc

-- | A paragraph-fill combinator. It's much like sep, only it keeps fitting
--   things on one line until it can't fit any more.
fsep :: [SDoc] -> SDoc

-- | This behaves like <a>fsep</a>, but it uses <a>&lt;&gt;</a> for
--   horizontal conposition rather than <a>&lt;+&gt;</a>
fcat :: [SDoc] -> SDoc
hang :: SDoc -> Int -> SDoc -> SDoc

-- | This behaves like <a>hang</a>, but does not indent the second document
--   when the header is empty.
hangNotEmpty :: SDoc -> Int -> SDoc -> SDoc
punctuate :: SDoc -> [SDoc] -> [SDoc]
ppWhen :: Bool -> SDoc -> SDoc
ppUnless :: Bool -> SDoc -> SDoc
ppWhenOption :: (SDocContext -> Bool) -> SDoc -> SDoc
ppUnlessOption :: (SDocContext -> Bool) -> SDoc -> SDoc

-- | Converts an integer to a verbal index:
--   
--   <pre>
--   speakNth 1 = text "first"
--   speakNth 5 = text "fifth"
--   speakNth 21 = text "21st"
--   </pre>
speakNth :: Int -> SDoc

-- | Converts an integer to a verbal multiplicity:
--   
--   <pre>
--   speakN 0 = text "none"
--   speakN 5 = text "five"
--   speakN 10 = text "10"
--   </pre>
speakN :: Int -> SDoc

-- | Converts an integer and object description to a statement about the
--   multiplicity of those objects:
--   
--   <pre>
--   speakNOf 0 (text "melon") = text "no melons"
--   speakNOf 1 (text "melon") = text "one melon"
--   speakNOf 3 (text "melon") = text "three melons"
--   </pre>
speakNOf :: Int -> SDoc -> SDoc

-- | Determines the pluralisation suffix appropriate for the length of a
--   list:
--   
--   <pre>
--   plural [] = char 's'
--   plural ["Hello"] = empty
--   plural ["Hello", "World"] = char 's'
--   </pre>
plural :: [a] -> SDoc

-- | Determines the form of to be appropriate for the length of a list:
--   
--   <pre>
--   isOrAre [] = text "are"
--   isOrAre ["Hello"] = text "is"
--   isOrAre ["Hello", "World"] = text "are"
--   </pre>
isOrAre :: [a] -> SDoc

-- | Determines the form of to do appropriate for the length of a list:
--   
--   <pre>
--   doOrDoes [] = text "do"
--   doOrDoes ["Hello"] = text "does"
--   doOrDoes ["Hello", "World"] = text "do"
--   </pre>
doOrDoes :: [a] -> SDoc

-- | Determines the form of possessive appropriate for the length of a
--   list:
--   
--   <pre>
--   itsOrTheir [x]   = text "its"
--   itsOrTheir [x,y] = text "their"
--   itsOrTheir []    = text "their"  -- probably avoid this
--   </pre>
itsOrTheir :: [a] -> SDoc
unicodeSyntax :: SDoc -> SDoc -> SDoc

-- | Apply the given colour/style for the argument.
--   
--   Only takes effect if colours are enabled.
coloured :: PprColour -> SDoc -> SDoc
keyword :: SDoc -> SDoc

-- | The analog of <a>printDoc_</a> for <a>SDoc</a>, which tries to make
--   sure the terminal doesn't get screwed up by the ANSI color codes if an
--   exception is thrown during pretty-printing.
printSDoc :: SDocContext -> Mode -> Handle -> SDoc -> IO ()

-- | Like <a>printSDoc</a> but appends an extra newline.
printSDocLn :: SDocContext -> Mode -> Handle -> SDoc -> IO ()

-- | An efficient variant of <a>printSDoc</a> specialized for
--   <a>LeftMode</a> that outputs to a <a>BufHandle</a>.
bufLeftRenderSDoc :: SDocContext -> BufHandle -> SDoc -> IO ()
pprCode :: LabelStyle -> SDoc -> SDoc
showSDocUnsafe :: SDoc -> String
showPprUnsafe :: Outputable a => a -> String
showSDocOneLine :: SDocContext -> SDoc -> String
renderWithContext :: SDocContext -> SDoc -> String
pprInfixVar :: Bool -> SDoc -> SDoc
pprPrefixVar :: Bool -> SDoc -> SDoc

-- | Special combinator for showing character literals.
pprHsChar :: Char -> SDoc

-- | Special combinator for showing string literals.
pprHsString :: FastString -> SDoc

-- | Special combinator for showing bytestring literals.
pprHsBytes :: ByteString -> SDoc
primFloatSuffix :: SDoc
primCharSuffix :: SDoc
primDoubleSuffix :: SDoc
primInt8Suffix :: SDoc
primWord8Suffix :: SDoc
primInt16Suffix :: SDoc
primWord16Suffix :: SDoc
primInt32Suffix :: SDoc
primWord32Suffix :: SDoc
primInt64Suffix :: SDoc
primWord64Suffix :: SDoc
primIntSuffix :: SDoc
primWordSuffix :: SDoc

-- | Special combinator for showing unboxed literals.
pprPrimChar :: Char -> SDoc
pprPrimInt :: Integer -> SDoc
pprPrimWord :: Integer -> SDoc
pprPrimInt8 :: Integer -> SDoc
pprPrimWord8 :: Integer -> SDoc
pprPrimInt16 :: Integer -> SDoc
pprPrimWord16 :: Integer -> SDoc
pprPrimInt32 :: Integer -> SDoc
pprPrimWord32 :: Integer -> SDoc
pprPrimInt64 :: Integer -> SDoc
pprPrimWord64 :: Integer -> SDoc
pprFastFilePath :: FastString -> SDoc

-- | Normalise, escape and render a string representing a path
--   
--   e.g. "c:\whatever"
pprFilePathString :: FilePath -> SDoc

-- | <a>BindingSite</a> is used to tell the thing that prints binder what
--   language construct is binding the identifier. This can be used to
--   decide how much info to print. Also see Note [Binding-site specific
--   printing] in <a>GHC.Core.Ppr</a>
data BindingSite

-- | The x in (x. e)
LambdaBind :: BindingSite

-- | The x in case scrut of x { (y,z) -&gt; ... }
CaseBind :: BindingSite

-- | The y,z in case scrut of x { (y,z) -&gt; ... }
CasePatBind :: BindingSite

-- | The x in (let x = rhs in e)
LetBind :: BindingSite
data PprStyle
PprUser :: PrintUnqualified -> Depth -> Coloured -> PprStyle
PprDump :: PrintUnqualified -> PprStyle

-- | Print code; either C or assembler
PprCode :: LabelStyle -> PprStyle

-- | Style of label pretty-printing.
--   
--   When we produce C sources or headers, we have to take into account
--   that C compilers transform C labels when they convert them into
--   symbols. For example, they can add prefixes (e.g., "_" on Darwin) or
--   suffixes (size for stdcalls on Windows). So we provide two ways to
--   pretty-print CLabels: C style or Asm style.
data LabelStyle

-- | C label style (used by C and LLVM backends)
CStyle :: LabelStyle

-- | Asm label style (used by NCG backend)
AsmStyle :: LabelStyle

-- | When printing code that contains original names, we need to map the
--   original names back to something the user understands. This is the
--   purpose of the triple of functions that gets passed around when
--   rendering <a>SDoc</a>.
data PrintUnqualified
QueryQualify :: QueryQualifyName -> QueryQualifyModule -> QueryQualifyPackage -> PrintUnqualified
[queryQualifyName] :: PrintUnqualified -> QueryQualifyName
[queryQualifyModule] :: PrintUnqualified -> QueryQualifyModule
[queryQualifyPackage] :: PrintUnqualified -> QueryQualifyPackage

-- | Given a <tt>Name</tt>'s <a>Module</a> and <a>OccName</a>, decide
--   whether and how to qualify it.
type QueryQualifyName = Module -> OccName -> QualifyName

-- | For a given module, we need to know whether to print it with a package
--   name to disambiguate it.
type QueryQualifyModule = Module -> Bool

-- | For a given package, we need to know whether to print it with the
--   component id to disambiguate it.
type QueryQualifyPackage = Unit -> Bool
reallyAlwaysQualify :: PrintUnqualified
reallyAlwaysQualifyNames :: QueryQualifyName
alwaysQualify :: PrintUnqualified

-- | NB: This won't ever show package IDs
alwaysQualifyNames :: QueryQualifyName
alwaysQualifyModules :: QueryQualifyModule
neverQualify :: PrintUnqualified
neverQualifyNames :: QueryQualifyName
neverQualifyModules :: QueryQualifyModule
alwaysQualifyPackages :: QueryQualifyPackage
neverQualifyPackages :: QueryQualifyPackage
data QualifyName
NameUnqual :: QualifyName
NameQual :: ModuleName -> QualifyName
NameNotInScope1 :: QualifyName
NameNotInScope2 :: QualifyName
queryQual :: PprStyle -> PrintUnqualified
sdocOption :: (SDocContext -> a) -> (a -> SDoc) -> SDoc
updSDocContext :: (SDocContext -> SDocContext) -> SDoc -> SDoc
data SDocContext
SDC :: !PprStyle -> !Scheme -> !PprColour -> !Bool -> !Int -> !Int -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !FastString -> SDoc -> SDocContext
[sdocStyle] :: SDocContext -> !PprStyle
[sdocColScheme] :: SDocContext -> !Scheme

-- | The most recently used colour. This allows nesting colours.
[sdocLastColour] :: SDocContext -> !PprColour
[sdocShouldUseColor] :: SDocContext -> !Bool
[sdocDefaultDepth] :: SDocContext -> !Int
[sdocLineLength] :: SDocContext -> !Int

-- | True if Unicode encoding is supported and not disable by
--   GHC_NO_UNICODE environment variable
[sdocCanUseUnicode] :: SDocContext -> !Bool
[sdocHexWordLiterals] :: SDocContext -> !Bool
[sdocPprDebug] :: SDocContext -> !Bool
[sdocPrintUnicodeSyntax] :: SDocContext -> !Bool
[sdocPrintCaseAsLet] :: SDocContext -> !Bool
[sdocPrintTypecheckerElaboration] :: SDocContext -> !Bool
[sdocPrintAxiomIncomps] :: SDocContext -> !Bool
[sdocPrintExplicitKinds] :: SDocContext -> !Bool
[sdocPrintExplicitCoercions] :: SDocContext -> !Bool
[sdocPrintExplicitRuntimeReps] :: SDocContext -> !Bool
[sdocPrintExplicitForalls] :: SDocContext -> !Bool
[sdocPrintPotentialInstances] :: SDocContext -> !Bool
[sdocPrintEqualityRelations] :: SDocContext -> !Bool
[sdocSuppressTicks] :: SDocContext -> !Bool
[sdocSuppressTypeSignatures] :: SDocContext -> !Bool
[sdocSuppressTypeApplications] :: SDocContext -> !Bool
[sdocSuppressIdInfo] :: SDocContext -> !Bool
[sdocSuppressCoercions] :: SDocContext -> !Bool
[sdocSuppressUnfoldings] :: SDocContext -> !Bool
[sdocSuppressVarKinds] :: SDocContext -> !Bool
[sdocSuppressUniques] :: SDocContext -> !Bool
[sdocSuppressModulePrefixes] :: SDocContext -> !Bool
[sdocSuppressStgExts] :: SDocContext -> !Bool
[sdocErrorSpans] :: SDocContext -> !Bool
[sdocStarIsType] :: SDocContext -> !Bool
[sdocLinearTypes] :: SDocContext -> !Bool
[sdocImpredicativeTypes] :: SDocContext -> !Bool
[sdocPrintTypeAbbreviations] :: SDocContext -> !Bool

-- | Used to map UnitIds to more friendly "package-version:component"
--   strings while pretty-printing.
--   
--   Use <a>pprWithUnitState</a> to set it. Users should never have to set
--   it to pretty-print SDocs emitted by GHC, otherwise it's a bug. It's an
--   internal field used to thread the UnitState so that the Outputable
--   instance of UnitId can use it.
--   
--   See Note [Pretty-printing UnitId] in <a>GHC.Unit</a> for more details.
--   
--   Note that we use <a>FastString</a> instead of <tt>UnitId</tt> to avoid
--   boring module inter-dependency issues.
[sdocUnitIdForUser] :: SDocContext -> !FastString -> SDoc
sdocWithContext :: (SDocContext -> SDoc) -> SDoc

-- | Default pretty-printing options
defaultSDocContext :: SDocContext
getPprStyle :: (PprStyle -> SDoc) -> SDoc
withPprStyle :: PprStyle -> SDoc -> SDoc
setStyleColoured :: Bool -> PprStyle -> PprStyle
pprDeeper :: SDoc -> SDoc

-- | Truncate a list that is longer than the current depth.
pprDeeperList :: ([SDoc] -> SDoc) -> [SDoc] -> SDoc
pprSetDepth :: Depth -> SDoc -> SDoc
codeStyle :: PprStyle -> Bool
userStyle :: PprStyle -> Bool
dumpStyle :: PprStyle -> Bool
asmStyle :: PprStyle -> Bool
qualName :: PprStyle -> QueryQualifyName
qualModule :: PprStyle -> QueryQualifyModule
qualPackage :: PprStyle -> QueryQualifyPackage

-- | Style for printing error messages
mkErrStyle :: PrintUnqualified -> PprStyle

-- | Default style for error messages, when we don't know PrintUnqualified
--   It's a bit of a hack because it doesn't take into account what's in
--   scope Only used for desugarer warnings, and typechecker errors in
--   interface sigs
defaultErrStyle :: PprStyle
defaultDumpStyle :: PprStyle
mkDumpStyle :: PrintUnqualified -> PprStyle
defaultUserStyle :: PprStyle
mkUserStyle :: PrintUnqualified -> Depth -> PprStyle
cmdlineParserStyle :: PprStyle
data Depth
AllTheWay :: Depth

-- | 0 =&gt; stop
PartWay :: Int -> Depth

-- | Use <a>sdocDefaultDepth</a> field as depth
DefaultDepth :: Depth
withUserStyle :: PrintUnqualified -> Depth -> SDoc -> SDoc
withErrStyle :: PrintUnqualified -> SDoc -> SDoc

-- | Says what to do with and without -dppr-debug
ifPprDebug :: SDoc -> SDoc -> SDoc

-- | Says what to do with -dppr-debug; without, return empty
whenPprDebug :: SDoc -> SDoc

-- | Indicate if -dppr-debug mode is enabled
getPprDebug :: (Bool -> SDoc) -> SDoc
instance GHC.Show.Show GHC.Utils.Outputable.LabelStyle
instance GHC.Classes.Ord GHC.Utils.Outputable.LabelStyle
instance GHC.Classes.Eq GHC.Utils.Outputable.LabelStyle
instance GHC.Utils.Outputable.Outputable GHC.Data.FastString.NonDetFastString
instance GHC.Utils.Outputable.Outputable GHC.Data.FastString.LexicalFastString
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.OutputableP env (GHC.Utils.Outputable.PDoc a)
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env [a]
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env (GHC.Maybe.Maybe a)
instance (GHC.Utils.Outputable.OutputableP env a, GHC.Utils.Outputable.OutputableP env b) => GHC.Utils.Outputable.OutputableP env (a, b)
instance (GHC.Utils.Outputable.OutputableP env a, GHC.Utils.Outputable.OutputableP env b, GHC.Utils.Outputable.OutputableP env c) => GHC.Utils.Outputable.OutputableP env (a, b, c)
instance (GHC.Utils.Outputable.OutputableP env key, GHC.Utils.Outputable.OutputableP env elt) => GHC.Utils.Outputable.OutputableP env (Data.Map.Internal.Map key elt)
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env (Data.Graph.SCC a)
instance GHC.Utils.Outputable.OutputableP env GHC.Utils.Outputable.SDoc
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env (Data.Set.Internal.Set a)
instance GHC.Utils.Outputable.Outputable GHC.Utils.Outputable.QualifyName
instance GHC.Utils.Outputable.Outputable GHC.Utils.Outputable.PprStyle
instance GHC.Utils.Outputable.Outputable GHC.Utils.Outputable.SDoc
instance GHC.Utils.Outputable.Outputable GHC.Types.Char
instance GHC.Utils.Outputable.Outputable GHC.Types.Bool
instance GHC.Utils.Outputable.Outputable GHC.Types.Ordering
instance GHC.Utils.Outputable.Outputable GHC.Int.Int32
instance GHC.Utils.Outputable.Outputable GHC.Int.Int64
instance GHC.Utils.Outputable.Outputable GHC.Types.Int
instance GHC.Utils.Outputable.Outputable GHC.Num.Integer.Integer
instance GHC.Utils.Outputable.Outputable GHC.Word.Word16
instance GHC.Utils.Outputable.Outputable GHC.Word.Word32
instance GHC.Utils.Outputable.Outputable GHC.Word.Word64
instance GHC.Utils.Outputable.Outputable GHC.Types.Word
instance GHC.Utils.Outputable.Outputable GHC.Types.Float
instance GHC.Utils.Outputable.Outputable GHC.Types.Double
instance GHC.Utils.Outputable.Outputable ()
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable [a]
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Base.NonEmpty a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (Data.Set.Internal.Set a)
instance GHC.Utils.Outputable.Outputable Data.IntSet.Internal.IntSet
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (a, b)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Maybe.Maybe a)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (Data.Either.Either a b)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c) => GHC.Utils.Outputable.Outputable (a, b, c)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c, GHC.Utils.Outputable.Outputable d) => GHC.Utils.Outputable.Outputable (a, b, c, d)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c, GHC.Utils.Outputable.Outputable d, GHC.Utils.Outputable.Outputable e) => GHC.Utils.Outputable.Outputable (a, b, c, d, e)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c, GHC.Utils.Outputable.Outputable d, GHC.Utils.Outputable.Outputable e, GHC.Utils.Outputable.Outputable f) => GHC.Utils.Outputable.Outputable (a, b, c, d, e, f)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c, GHC.Utils.Outputable.Outputable d, GHC.Utils.Outputable.Outputable e, GHC.Utils.Outputable.Outputable f, GHC.Utils.Outputable.Outputable g) => GHC.Utils.Outputable.Outputable (a, b, c, d, e, f, g)
instance GHC.Utils.Outputable.Outputable GHC.Data.FastString.FastString
instance (GHC.Utils.Outputable.Outputable key, GHC.Utils.Outputable.Outputable elt) => GHC.Utils.Outputable.Outputable (Data.Map.Internal.Map key elt)
instance GHC.Utils.Outputable.Outputable elt => GHC.Utils.Outputable.Outputable (Data.IntMap.Internal.IntMap elt)
instance GHC.Utils.Outputable.Outputable GHC.Fingerprint.Type.Fingerprint
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (Data.Graph.SCC a)
instance GHC.Utils.Outputable.Outputable GHC.Serialized.Serialized
instance GHC.Utils.Outputable.Outputable GHC.LanguageExtensions.Type.Extension
instance Data.String.IsString GHC.Utils.Outputable.SDoc


-- | Unit &amp; Module types
--   
--   This module is used to resolve the loops between Unit and Module types
--   (Module references a Unit and vice-versa).
module GHC.Unit.Types

-- | A generic module is a pair of a unit identifier and a
--   <a>ModuleName</a>.
data GenModule unit
Module :: !unit -> !ModuleName -> GenModule unit

-- | Unit the module belongs to
[moduleUnit] :: GenModule unit -> !unit

-- | Module name (e.g. A.B.C)
[moduleName] :: GenModule unit -> !ModuleName

-- | A Module is a pair of a <a>Unit</a> and a <a>ModuleName</a>.
type Module = GenModule Unit

-- | A <a>InstalledModule</a> is a <a>Module</a> whose unit is identified
--   with an <a>UnitId</a>.
type InstalledModule = GenModule UnitId

-- | An <a>InstantiatedModule</a> is a <a>Module</a> whose unit is
--   identified with an <a>InstantiatedUnit</a>.
type InstantiatedModule = GenModule InstantiatedUnit
mkModule :: u -> ModuleName -> GenModule u
pprModule :: Module -> SDoc
pprInstantiatedModule :: InstantiatedModule -> SDoc

-- | Calculate the free holes of a <a>Module</a>. If this set is non-empty,
--   this module was defined in an indefinite library that had required
--   signatures.
--   
--   If a module has free holes, that means that substitutions can operate
--   on it; if it has no free holes, substituting over a module has no
--   effect.
moduleFreeHoles :: GenModule (GenUnit u) -> UniqDSet ModuleName

-- | Class for types that are used as unit identifiers (UnitKey, UnitId,
--   Unit)
--   
--   We need this class because we create new unit ids for virtual units
--   (see VirtUnit) and they have to to be made from units with different
--   kinds of identifiers.
class IsUnitId u

-- | A unit identifier identifies a (possibly partially) instantiated
--   library. It is primarily used as part of <a>Module</a>, which in turn
--   is used in <tt>Name</tt>, which is used to give names to entities when
--   typechecking.
--   
--   There are two possible forms for a <a>Unit</a>:
--   
--   1) It can be a <a>RealUnit</a>, in which case we just have a
--   <a>DefUnitId</a> that uniquely identifies some fully compiled,
--   installed library we have on disk.
--   
--   2) It can be an <a>VirtUnit</a>. When we are typechecking a library
--   with missing holes, we may need to instantiate a library on the fly
--   (in which case we don't have any on-disk representation.) In that
--   case, you have an <a>InstantiatedUnit</a>, which explicitly records
--   the instantiation, so that we can substitute over it.
data GenUnit uid

-- | Installed definite unit (either a fully instantiated unit or a closed
--   unit)
RealUnit :: !Definite uid -> GenUnit uid

-- | Virtual unit instantiated on-the-fly. It may be definite if all the
--   holes are instantiated but we don't have code objects for it.
VirtUnit :: {-# UNPACK #-} !GenInstantiatedUnit uid -> GenUnit uid

-- | Fake hole unit
HoleUnit :: GenUnit uid
type Unit = GenUnit UnitId

-- | A UnitId identifies a built library in a database and is used to
--   generate unique symbols, etc. It's usually of the form:
--   
--   pkgname-1.2:libname+hash
--   
--   These UnitId are provided to us via the <tt>-this-unit-id</tt> flag.
--   
--   The library in question may be definite or indefinite; if it is
--   indefinite, none of the holes have been filled (we never install
--   partially instantiated libraries as we can cheaply instantiate them
--   on-the-fly, cf VirtUnit). Put another way, an installed unit id is
--   either fully instantiated, or not instantiated at all.
newtype UnitId
UnitId :: FastString -> UnitId

-- | The full hashed unit identifier, including the component id and the
--   hash.
[unitIdFS] :: UnitId -> FastString

-- | A unit key in the database
newtype UnitKey
UnitKey :: FastString -> UnitKey

-- | An instantiated unit.
--   
--   It identifies an indefinite library (with holes) that has been
--   instantiated.
--   
--   This unit may be indefinite or not (i.e. with remaining holes or not).
--   If it is definite, we don't know if it has already been compiled and
--   installed in a database. Nevertheless, we have a mechanism called
--   "improvement" to try to match a fully instantiated unit with existing
--   compiled and installed units: see Note [VirtUnit to RealUnit
--   improvement].
--   
--   An indefinite unit identifier pretty-prints to something like
--   <tt>p[H=<a>H</a>,A=aimpl:A&gt;]</tt> (<tt>p</tt> is the
--   <a>IndefUnitId</a>, and the brackets enclose the module substitution).
data GenInstantiatedUnit unit
InstantiatedUnit :: !FastString -> !Unique -> !Indefinite unit -> !GenInstantiations unit -> UniqDSet ModuleName -> GenInstantiatedUnit unit

-- | A private, uniquely identifying representation of an InstantiatedUnit.
--   This string is completely private to GHC and is just used to get a
--   unique.
[instUnitFS] :: GenInstantiatedUnit unit -> !FastString

-- | Cached unique of <a>unitFS</a>.
[instUnitKey] :: GenInstantiatedUnit unit -> !Unique

-- | The indefinite unit being instantiated.
[instUnitInstanceOf] :: GenInstantiatedUnit unit -> !Indefinite unit

-- | The sorted (by <a>ModuleName</a>) instantiations of this unit.
[instUnitInsts] :: GenInstantiatedUnit unit -> !GenInstantiations unit

-- | A cache of the free module holes of <a>instUnitInsts</a>. This lets us
--   efficiently tell if a <a>InstantiatedUnit</a> has been fully
--   instantiated (empty set of free module holes) and whether or not a
--   substitution can have any effect.
[instUnitHoles] :: GenInstantiatedUnit unit -> UniqDSet ModuleName
type InstantiatedUnit = GenInstantiatedUnit UnitId

-- | An <a>IndefUnitId</a> is an <a>UnitId</a> with the invariant that it
--   only refers to an indefinite library; i.e., one that can be
--   instantiated.
type IndefUnitId = Indefinite UnitId

-- | A <a>DefUnitId</a> is an <a>UnitId</a> with the invariant that it only
--   refers to a definite library; i.e., one we have generated code for.
type DefUnitId = Definite UnitId
type Instantiations = GenInstantiations UnitId
type GenInstantiations unit = [(ModuleName, GenModule (GenUnit unit))]

-- | Create a new <a>GenInstantiatedUnit</a> given an explicit module
--   substitution.
mkInstantiatedUnit :: IsUnitId u => Indefinite u -> GenInstantiations u -> GenInstantiatedUnit u

-- | Generate a uniquely identifying hash (internal unit-id) for an
--   instantiated unit.
--   
--   This is a one-way function. If the indefinite unit has not been
--   instantiated at all, we return its unit-id.
--   
--   This hash is completely internal to GHC and is not used for symbol
--   names or file paths. It is different from the hash Cabal would produce
--   for the same instantiated unit.
mkInstantiatedUnitHash :: IsUnitId u => Indefinite u -> [(ModuleName, GenModule (GenUnit u))] -> FastString

-- | Smart constructor for instantiated GenUnit
mkVirtUnit :: IsUnitId u => Indefinite u -> [(ModuleName, GenModule (GenUnit u))] -> GenUnit u

-- | Map over the unit type of a <a>GenUnit</a>
mapGenUnit :: IsUnitId v => (u -> v) -> GenUnit u -> GenUnit v

-- | Map over the unit identifier of unit instantiations.
mapInstantiations :: IsUnitId v => (u -> v) -> GenInstantiations u -> GenInstantiations v

-- | Retrieve the set of free module holes of a <a>Unit</a>.
unitFreeModuleHoles :: GenUnit u -> UniqDSet ModuleName

-- | Create a new simple unit identifier from a <a>FastString</a>.
--   Internally, this is primarily used to specify wired-in unit
--   identifiers.
fsToUnit :: FastString -> Unit
unitFS :: IsUnitId u => u -> FastString
unitString :: IsUnitId u => u -> String

-- | Return the UnitId of the Unit. For on-the-fly instantiated units,
--   return the UnitId of the indefinite unit this unit is an instance of.
toUnitId :: Unit -> UnitId

-- | Return the virtual UnitId of an on-the-fly instantiated unit.
virtualUnitId :: InstantiatedUnit -> UnitId
stringToUnit :: String -> Unit

-- | Compares unit ids lexically, rather than by their <a>Unique</a>s
stableUnitCmp :: Unit -> Unit -> Ordering

-- | A <a>Unit</a> is definite if it has no free holes.
unitIsDefinite :: Unit -> Bool
isHoleUnit :: GenUnit u -> Bool
unitIdString :: UnitId -> String
stringToUnitId :: String -> UnitId

-- | A definite unit (i.e. without any free module hole)
newtype Definite unit
Definite :: unit -> Definite unit
[unDefinite] :: Definite unit -> unit
newtype Indefinite unit
Indefinite :: unit -> Indefinite unit
[indefUnit] :: Indefinite unit -> unit
primUnitId :: UnitId
bignumUnitId :: UnitId
baseUnitId :: UnitId
rtsUnitId :: UnitId
thUnitId :: UnitId

-- | This is the package Id for the current program. It is the default
--   package Id if you don't specify a package name. We don't add this
--   prefix to symbol names, since there can be only one main package per
--   program.
mainUnitId :: UnitId
thisGhcUnitId :: UnitId
interactiveUnitId :: UnitId
primUnit :: Unit
bignumUnit :: Unit
baseUnit :: Unit
rtsUnit :: Unit
thUnit :: Unit
mainUnit :: Unit
thisGhcUnit :: Unit
interactiveUnit :: Unit
isInteractiveModule :: Module -> Bool
wiredInUnitIds :: [UnitId]

-- | Indicates whether a module name is referring to a boot interface
--   (hs-boot file) or regular module (hs file). We need to treat boot
--   modules specially when building compilation graphs, since they break
--   cycles. Regular source files and signature files are treated
--   equivalently.
data IsBootInterface
NotBoot :: IsBootInterface
IsBoot :: IsBootInterface

-- | This data type just pairs a value <a>mod</a> with an IsBootInterface
--   flag. In practice, <a>mod</a> is usually a <tt>Module</tt> or
--   <tt>ModuleName</tt>'.
data GenWithIsBoot mod
GWIB :: mod -> IsBootInterface -> GenWithIsBoot mod
[gwib_mod] :: GenWithIsBoot mod -> mod
[gwib_isBoot] :: GenWithIsBoot mod -> IsBootInterface
type ModuleNameWithIsBoot = GenWithIsBoot ModuleName
type ModuleWithIsBoot = GenWithIsBoot Module
instance GHC.Base.Functor GHC.Unit.Types.GenModule
instance Data.Data.Data unit => Data.Data.Data (GHC.Unit.Types.GenModule unit)
instance GHC.Classes.Ord unit => GHC.Classes.Ord (GHC.Unit.Types.GenModule unit)
instance GHC.Classes.Eq unit => GHC.Classes.Eq (GHC.Unit.Types.GenModule unit)
instance GHC.Unit.Types.IsUnitId unit => GHC.Unit.Types.IsUnitId (GHC.Unit.Types.Definite unit)
instance GHC.Types.Unique.Uniquable unit => GHC.Types.Unique.Uniquable (GHC.Unit.Types.Definite unit)
instance GHC.Utils.Binary.Binary unit => GHC.Utils.Binary.Binary (GHC.Unit.Types.Definite unit)
instance GHC.Utils.Outputable.Outputable unit => GHC.Utils.Outputable.Outputable (GHC.Unit.Types.Definite unit)
instance GHC.Classes.Ord unit => GHC.Classes.Ord (GHC.Unit.Types.Definite unit)
instance GHC.Classes.Eq unit => GHC.Classes.Eq (GHC.Unit.Types.Definite unit)
instance GHC.Base.Functor GHC.Unit.Types.Definite
instance GHC.Unit.Types.IsUnitId unit => GHC.Unit.Types.IsUnitId (GHC.Unit.Types.Indefinite unit)
instance GHC.Types.Unique.Uniquable unit => GHC.Types.Unique.Uniquable (GHC.Unit.Types.Indefinite unit)
instance GHC.Utils.Binary.Binary unit => GHC.Utils.Binary.Binary (GHC.Unit.Types.Indefinite unit)
instance GHC.Utils.Outputable.Outputable unit => GHC.Utils.Outputable.Outputable (GHC.Unit.Types.Indefinite unit)
instance GHC.Classes.Ord unit => GHC.Classes.Ord (GHC.Unit.Types.Indefinite unit)
instance GHC.Classes.Eq unit => GHC.Classes.Eq (GHC.Unit.Types.Indefinite unit)
instance GHC.Base.Functor GHC.Unit.Types.Indefinite
instance Data.Data.Data GHC.Unit.Types.IsBootInterface
instance GHC.Show.Show GHC.Unit.Types.IsBootInterface
instance GHC.Classes.Ord GHC.Unit.Types.IsBootInterface
instance GHC.Classes.Eq GHC.Unit.Types.IsBootInterface
instance Data.Traversable.Traversable GHC.Unit.Types.GenWithIsBoot
instance Data.Foldable.Foldable GHC.Unit.Types.GenWithIsBoot
instance GHC.Base.Functor GHC.Unit.Types.GenWithIsBoot
instance GHC.Show.Show mod => GHC.Show.Show (GHC.Unit.Types.GenWithIsBoot mod)
instance GHC.Classes.Ord mod => GHC.Classes.Ord (GHC.Unit.Types.GenWithIsBoot mod)
instance GHC.Classes.Eq mod => GHC.Classes.Eq (GHC.Unit.Types.GenWithIsBoot mod)
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Unit.Types.GenWithIsBoot a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Unit.Types.GenWithIsBoot a)
instance GHC.Utils.Binary.Binary GHC.Unit.Types.IsBootInterface
instance GHC.Types.Unique.Uniquable GHC.Unit.Types.Module
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.Module
instance GHC.Classes.Ord GHC.Unit.Types.Unit
instance Data.Data.Data GHC.Unit.Types.Unit
instance Control.DeepSeq.NFData GHC.Unit.Types.Unit
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.Unit
instance GHC.Show.Show GHC.Unit.Types.Unit
instance GHC.Utils.Binary.Binary GHC.Unit.Types.Unit
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.InstantiatedModule
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.InstantiatedUnit
instance GHC.Utils.Binary.Binary GHC.Unit.Types.InstantiatedUnit
instance GHC.Unit.Types.IsUnitId u => GHC.Unit.Types.IsUnitId (GHC.Unit.Types.GenUnit u)
instance GHC.Classes.Eq (GHC.Unit.Types.GenInstantiatedUnit unit)
instance GHC.Classes.Ord (GHC.Unit.Types.GenInstantiatedUnit unit)
instance GHC.Unit.Types.IsUnitId u => GHC.Classes.Eq (GHC.Unit.Types.GenUnit u)
instance GHC.Unit.Types.IsUnitId u => GHC.Types.Unique.Uniquable (GHC.Unit.Types.GenUnit u)
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.InstalledModule
instance GHC.Unit.Types.IsUnitId GHC.Unit.Types.UnitId
instance GHC.Utils.Binary.Binary GHC.Unit.Types.UnitId
instance GHC.Classes.Eq GHC.Unit.Types.UnitId
instance GHC.Classes.Ord GHC.Unit.Types.UnitId
instance GHC.Types.Unique.Uniquable GHC.Unit.Types.UnitId
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.UnitId
instance GHC.Unit.Types.IsUnitId GHC.Unit.Types.UnitKey
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Unit.Types.GenModule a)
instance Control.DeepSeq.NFData (GHC.Unit.Types.GenModule a)

module GHC.Utils.Binary
data Bin a

-- | Do not rely on instance sizes for general types, we use variable
--   length encoding for many of them.
class Binary a
put_ :: Binary a => BinHandle -> a -> IO ()
put :: Binary a => BinHandle -> a -> IO (Bin a)
get :: Binary a => BinHandle -> IO a
data BinHandle
type SymbolTable = Array Int Name
type Dictionary = Array Int FastString
data BinData
BinData :: Int -> BinArray -> BinData
dataHandle :: BinData -> IO BinHandle
handleData :: BinHandle -> IO BinData
openBinMem :: Int -> IO BinHandle
seekBin :: BinHandle -> Bin a -> IO ()
tellBin :: BinHandle -> IO (Bin a)
castBin :: Bin a -> Bin b

-- | Get access to the underlying buffer.
--   
--   It is quite important that no references to the <a>ByteString</a> leak
--   out of the continuation lest terrible things happen.
withBinBuffer :: BinHandle -> (ByteString -> IO a) -> IO a
writeBinMem :: BinHandle -> FilePath -> IO ()
readBinMem :: FilePath -> IO BinHandle
putAt :: Binary a => BinHandle -> Bin a -> a -> IO ()
getAt :: Binary a => BinHandle -> Bin a -> IO a
putByte :: BinHandle -> Word8 -> IO ()
getByte :: BinHandle -> IO Word8
putULEB128 :: forall a. (Integral a, FiniteBits a) => BinHandle -> a -> IO ()
getULEB128 :: forall a. (Integral a, FiniteBits a) => BinHandle -> IO a
putSLEB128 :: forall a. (Integral a, Bits a) => BinHandle -> a -> IO ()
getSLEB128 :: forall a. (Show a, Integral a, FiniteBits a) => BinHandle -> IO a

-- | Encode the argument in it's full length. This is different from many
--   default binary instances which make no guarantee about the actual
--   encoding and might do things use variable length encoding.
newtype FixedLengthEncoding a
FixedLengthEncoding :: a -> FixedLengthEncoding a
[unFixedLength] :: FixedLengthEncoding a -> a
lazyGet :: Binary a => BinHandle -> IO a
lazyPut :: Binary a => BinHandle -> a -> IO ()

-- | Information we keep around during interface file
--   serialization/deserialization. Namely we keep the functions for
--   serializing and deserializing <a>Name</a>s and <a>FastString</a>s. We
--   do this because we actually use serialization in two distinct
--   settings,
--   
--   <ul>
--   <li>When serializing interface files themselves</li>
--   <li>When computing the fingerprint of an IfaceDecl (which we computing
--   by hashing its Binary serialization)</li>
--   </ul>
--   
--   These two settings have different needs while serializing Names:
--   
--   <ul>
--   <li>Names in interface files are serialized via a symbol table (see
--   Note [Symbol table representation of names] in
--   <a>GHC.Iface.Binary</a>).</li>
--   <li>During fingerprinting a binding Name is serialized as the OccName
--   and a non-binding Name is serialized as the fingerprint of the thing
--   they represent. See Note [Fingerprinting IfaceDecls] for further
--   discussion.</li>
--   </ul>
data UserData
UserData :: (BinHandle -> IO Name) -> (BinHandle -> IO FastString) -> (BinHandle -> Name -> IO ()) -> (BinHandle -> Name -> IO ()) -> (BinHandle -> FastString -> IO ()) -> UserData
[ud_get_name] :: UserData -> BinHandle -> IO Name
[ud_get_fs] :: UserData -> BinHandle -> IO FastString

-- | serialize a non-binding <a>Name</a> (e.g. a reference to another
--   binding).
[ud_put_nonbinding_name] :: UserData -> BinHandle -> Name -> IO ()

-- | serialize a binding <a>Name</a> (e.g. the name of an IfaceDecl)
[ud_put_binding_name] :: UserData -> BinHandle -> Name -> IO ()
[ud_put_fs] :: UserData -> BinHandle -> FastString -> IO ()
getUserData :: BinHandle -> UserData
setUserData :: BinHandle -> UserData -> BinHandle
newReadState :: (BinHandle -> IO Name) -> (BinHandle -> IO FastString) -> UserData
newWriteState :: (BinHandle -> Name -> IO ()) -> (BinHandle -> Name -> IO ()) -> (BinHandle -> FastString -> IO ()) -> UserData
putDictionary :: BinHandle -> Int -> UniqFM FastString (Int, FastString) -> IO ()
getDictionary :: BinHandle -> IO Dictionary
putFS :: BinHandle -> FastString -> IO ()
instance forall k (a :: k). GHC.Enum.Bounded (GHC.Utils.Binary.Bin a)
instance forall k (a :: k). GHC.Show.Show (GHC.Utils.Binary.Bin a)
instance forall k (a :: k). GHC.Classes.Ord (GHC.Utils.Binary.Bin a)
instance forall k (a :: k). GHC.Classes.Eq (GHC.Utils.Binary.Bin a)
instance GHC.Utils.Binary.Binary GHC.Data.FastString.NonDetFastString
instance GHC.Utils.Binary.Binary GHC.Data.FastString.LexicalFastString
instance GHC.Utils.Binary.Binary GHC.Utils.Binary.BinData
instance GHC.Utils.Binary.Binary (GHC.Utils.Binary.FixedLengthEncoding GHC.Word.Word8)
instance GHC.Utils.Binary.Binary (GHC.Utils.Binary.FixedLengthEncoding GHC.Word.Word16)
instance GHC.Utils.Binary.Binary (GHC.Utils.Binary.FixedLengthEncoding GHC.Word.Word32)
instance GHC.Utils.Binary.Binary (GHC.Utils.Binary.FixedLengthEncoding GHC.Word.Word64)
instance GHC.Utils.Binary.Binary GHC.Word.Word8
instance GHC.Utils.Binary.Binary GHC.Word.Word16
instance GHC.Utils.Binary.Binary GHC.Word.Word32
instance GHC.Utils.Binary.Binary GHC.Word.Word64
instance GHC.Utils.Binary.Binary GHC.Int.Int8
instance GHC.Utils.Binary.Binary GHC.Int.Int16
instance GHC.Utils.Binary.Binary GHC.Int.Int32
instance GHC.Utils.Binary.Binary GHC.Int.Int64
instance GHC.Utils.Binary.Binary ()
instance GHC.Utils.Binary.Binary GHC.Types.Bool
instance GHC.Utils.Binary.Binary GHC.Types.Char
instance GHC.Utils.Binary.Binary GHC.Types.Int
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary [a]
instance (GHC.Ix.Ix a, GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b) => GHC.Utils.Binary.Binary (GHC.Arr.Array a b)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b) => GHC.Utils.Binary.Binary (a, b)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c) => GHC.Utils.Binary.Binary (a, b, c)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c, GHC.Utils.Binary.Binary d) => GHC.Utils.Binary.Binary (a, b, c, d)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c, GHC.Utils.Binary.Binary d, GHC.Utils.Binary.Binary e) => GHC.Utils.Binary.Binary (a, b, c, d, e)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c, GHC.Utils.Binary.Binary d, GHC.Utils.Binary.Binary e, GHC.Utils.Binary.Binary f) => GHC.Utils.Binary.Binary (a, b, c, d, e, f)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c, GHC.Utils.Binary.Binary d, GHC.Utils.Binary.Binary e, GHC.Utils.Binary.Binary f, GHC.Utils.Binary.Binary g) => GHC.Utils.Binary.Binary (a, b, c, d, e, f, g)
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Maybe.Maybe a)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b) => GHC.Utils.Binary.Binary (Data.Either.Either a b)
instance GHC.Utils.Binary.Binary Data.Time.Clock.Internal.UTCTime.UTCTime
instance GHC.Utils.Binary.Binary Data.Time.Calendar.Days.Day
instance GHC.Utils.Binary.Binary Data.Time.Clock.Internal.DiffTime.DiffTime
instance GHC.Utils.Binary.Binary GHC.Num.Integer.Integer
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Real.Ratio a)
instance forall k (a :: k). GHC.Utils.Binary.Binary (GHC.Utils.Binary.Bin a)
instance GHC.Utils.Binary.Binary Data.ByteString.Internal.ByteString
instance GHC.Utils.Binary.Binary GHC.Data.FastString.FastString
instance GHC.Utils.Binary.Binary GHC.Fingerprint.Type.Fingerprint
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Types.SrcLoc.Located a)
instance GHC.Utils.Binary.Binary GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Utils.Binary.Binary GHC.Types.SrcLoc.BufPos
instance GHC.Utils.Binary.Binary GHC.Types.SrcLoc.BufSpan
instance GHC.Utils.Binary.Binary GHC.Types.SrcLoc.UnhelpfulSpanReason
instance GHC.Utils.Binary.Binary GHC.Types.SrcLoc.SrcSpan
instance Control.DeepSeq.NFData GHC.Utils.Binary.BinData

module GHC.Types.Unique.FM

-- | A finite map from <tt>uniques</tt> of one type to elements in another
--   type.
--   
--   The key is just here to keep us honest. It's always safe to use a
--   single type as key. If two types don't overlap in their uniques it's
--   also safe to index the same map at multiple key types. But this is
--   very much discouraged.
data UniqFM key ele

-- | A wrapper around <a>UniqFM</a> with the sole purpose of informing call
--   sites that the provided <a>Foldable</a> and <a>Traversable</a>
--   instances are nondeterministic. If you use this please provide a
--   justification why it doesn't introduce nondeterminism. See Note
--   [Deterministic UniqFM] in <a>GHC.Types.Unique.DFM</a> to learn about
--   determinism.
newtype NonDetUniqFM key ele
NonDetUniqFM :: UniqFM key ele -> NonDetUniqFM key ele
[getNonDet] :: NonDetUniqFM key ele -> UniqFM key ele
emptyUFM :: UniqFM key elt
unitUFM :: Uniquable key => key -> elt -> UniqFM key elt
unitDirectlyUFM :: Unique -> elt -> UniqFM key elt
zipToUFM :: Uniquable key => [key] -> [elt] -> UniqFM key elt
listToUFM :: Uniquable key => [(key, elt)] -> UniqFM key elt
listToUFM_Directly :: [(Unique, elt)] -> UniqFM key elt
listToUFM_C :: Uniquable key => (elt -> elt -> elt) -> [(key, elt)] -> UniqFM key elt
listToIdentityUFM :: Uniquable key => [key] -> UniqFM key key
addToUFM :: Uniquable key => UniqFM key elt -> key -> elt -> UniqFM key elt
addToUFM_C :: Uniquable key => (elt -> elt -> elt) -> UniqFM key elt -> key -> elt -> UniqFM key elt
addToUFM_Acc :: Uniquable key => (elt -> elts -> elts) -> (elt -> elts) -> UniqFM key elts -> key -> elt -> UniqFM key elts
addListToUFM :: Uniquable key => UniqFM key elt -> [(key, elt)] -> UniqFM key elt

-- | Add elements to the map, combining existing values with inserted ones
--   using the given function.
addListToUFM_C :: Uniquable key => (elt -> elt -> elt) -> UniqFM key elt -> [(key, elt)] -> UniqFM key elt
addToUFM_Directly :: UniqFM key elt -> Unique -> elt -> UniqFM key elt
addListToUFM_Directly :: UniqFM key elt -> [(Unique, elt)] -> UniqFM key elt
adjustUFM :: Uniquable key => (elt -> elt) -> UniqFM key elt -> key -> UniqFM key elt
alterUFM :: Uniquable key => (Maybe elt -> Maybe elt) -> UniqFM key elt -> key -> UniqFM key elt
adjustUFM_Directly :: (elt -> elt) -> UniqFM key elt -> Unique -> UniqFM key elt
delFromUFM :: Uniquable key => UniqFM key elt -> key -> UniqFM key elt
delFromUFM_Directly :: UniqFM key elt -> Unique -> UniqFM key elt
delListFromUFM :: Uniquable key => UniqFM key elt -> [key] -> UniqFM key elt
delListFromUFM_Directly :: UniqFM key elt -> [Unique] -> UniqFM key elt
plusUFM :: UniqFM key elt -> UniqFM key elt -> UniqFM key elt
plusUFM_C :: (elt -> elt -> elt) -> UniqFM key elt -> UniqFM key elt -> UniqFM key elt

-- | `plusUFM_CD f m1 d1 m2 d2` merges the maps using <tt>f</tt> as the
--   combinding function and <tt>d1</tt> resp. <tt>d2</tt> as the default
--   value if there is no entry in <tt>m1</tt> reps. <tt>m2</tt>. The
--   domain is the union of the domains of <tt>m1</tt> and <tt>m2</tt>.
--   
--   IMPORTANT NOTE: This function strictly applies the modification
--   function and forces the result unlike most the other functions in this
--   module.
--   
--   Representative example:
--   
--   <pre>
--   plusUFM_CD f {A: 1, B: 2} 23 {B: 3, C: 4} 42
--      == {A: f 1 42, B: f 2 3, C: f 23 4 }
--   </pre>
plusUFM_CD :: (elta -> eltb -> eltc) -> UniqFM key elta -> elta -> UniqFM key eltb -> eltb -> UniqFM key eltc

-- | `plusUFM_CD2 f m1 m2` merges the maps using <tt>f</tt> as the
--   combining function. Unlike <a>plusUFM_CD</a>, a missing value is not
--   defaulted: it is instead passed as <a>Nothing</a> to <tt>f</tt>.
--   <tt>f</tt> can never have both its arguments be <a>Nothing</a>.
--   
--   IMPORTANT NOTE: This function strictly applies the modification
--   function and forces the result.
--   
--   `plusUFM_CD2 f m1 m2` is the same as `plusUFM_CD f (mapUFM Just m1)
--   Nothing (mapUFM Just m2) Nothing`.
plusUFM_CD2 :: (Maybe elta -> Maybe eltb -> eltc) -> UniqFM key elta -> UniqFM key eltb -> UniqFM key eltc
plusMaybeUFM_C :: (elt -> elt -> Maybe elt) -> UniqFM key elt -> UniqFM key elt -> UniqFM key elt
mergeUFM :: (elta -> eltb -> Maybe eltc) -> (UniqFM key elta -> UniqFM key eltc) -> (UniqFM key eltb -> UniqFM key eltc) -> UniqFM key elta -> UniqFM key eltb -> UniqFM key eltc
plusUFMList :: [UniqFM key elt] -> UniqFM key elt
minusUFM :: UniqFM key elt1 -> UniqFM key elt2 -> UniqFM key elt1
intersectUFM :: UniqFM key elt1 -> UniqFM key elt2 -> UniqFM key elt1
intersectUFM_C :: (elt1 -> elt2 -> elt3) -> UniqFM key elt1 -> UniqFM key elt2 -> UniqFM key elt3
disjointUFM :: UniqFM key elt1 -> UniqFM key elt2 -> Bool
equalKeysUFM :: UniqFM key a -> UniqFM key b -> Bool
nonDetStrictFoldUFM :: (elt -> a -> a) -> a -> UniqFM key elt -> a
foldUFM :: (elt -> a -> a) -> a -> UniqFM key elt -> a
nonDetStrictFoldUFM_Directly :: (Unique -> elt -> a -> a) -> a -> UniqFM key elt -> a
anyUFM :: (elt -> Bool) -> UniqFM key elt -> Bool
allUFM :: (elt -> Bool) -> UniqFM key elt -> Bool
seqEltsUFM :: ([elt] -> ()) -> UniqFM key elt -> ()
mapUFM :: (elt1 -> elt2) -> UniqFM key elt1 -> UniqFM key elt2
mapUFM_Directly :: (Unique -> elt1 -> elt2) -> UniqFM key elt1 -> UniqFM key elt2
mapMaybeUFM :: (elt1 -> Maybe elt2) -> UniqFM key elt1 -> UniqFM key elt2
elemUFM :: Uniquable key => key -> UniqFM key elt -> Bool
elemUFM_Directly :: Unique -> UniqFM key elt -> Bool
filterUFM :: (elt -> Bool) -> UniqFM key elt -> UniqFM key elt
filterUFM_Directly :: (Unique -> elt -> Bool) -> UniqFM key elt -> UniqFM key elt
partitionUFM :: (elt -> Bool) -> UniqFM key elt -> (UniqFM key elt, UniqFM key elt)
sizeUFM :: UniqFM key elt -> Int
isNullUFM :: UniqFM key elt -> Bool
lookupUFM :: Uniquable key => UniqFM key elt -> key -> Maybe elt
lookupUFM_Directly :: UniqFM key elt -> Unique -> Maybe elt
lookupWithDefaultUFM :: Uniquable key => UniqFM key elt -> elt -> key -> elt
lookupWithDefaultUFM_Directly :: UniqFM key elt -> elt -> Unique -> elt
nonDetEltsUFM :: UniqFM key elt -> [elt]
eltsUFM :: UniqFM key elt -> [elt]
nonDetKeysUFM :: UniqFM key elt -> [Unique]
ufmToSet_Directly :: UniqFM key elt -> IntSet
nonDetUFMToList :: UniqFM key elt -> [(Unique, elt)]
ufmToIntMap :: UniqFM key elt -> IntMap elt
unsafeIntMapToUFM :: IntMap elt -> UniqFM key elt

-- | Cast the key domain of a UniqFM.
--   
--   As long as the domains don't overlap in their uniques this is safe.
unsafeCastUFMKey :: UniqFM key1 elt -> UniqFM key2 elt
pprUniqFM :: (a -> SDoc) -> UniqFM key a -> SDoc

-- | Pretty-print a non-deterministic set. The order of variables is
--   non-deterministic and for pretty-printing that shouldn't be a problem.
--   Having this function helps contain the non-determinism created with
--   nonDetEltsUFM.
pprUFM :: UniqFM key a -> ([a] -> SDoc) -> SDoc

-- | Pretty-print a non-deterministic set. The order of variables is
--   non-deterministic and for pretty-printing that shouldn't be a problem.
--   Having this function helps contain the non-determinism created with
--   nonDetUFMToList.
pprUFMWithKeys :: UniqFM key a -> ([(Unique, a)] -> SDoc) -> SDoc

-- | Determines the pluralisation suffix appropriate for the length of a
--   set in the same way that plural from Outputable does for lists.
pluralUFM :: UniqFM key a -> SDoc
instance GHC.Base.Functor (GHC.Types.Unique.FM.UniqFM key)
instance GHC.Classes.Eq ele => GHC.Classes.Eq (GHC.Types.Unique.FM.UniqFM key ele)
instance (Data.Data.Data key, Data.Data.Data ele) => Data.Data.Data (GHC.Types.Unique.FM.UniqFM key ele)
instance GHC.Base.Functor (GHC.Types.Unique.FM.NonDetUniqFM key)
instance Data.Foldable.Foldable (GHC.Types.Unique.FM.NonDetUniqFM key)
instance Data.Traversable.Traversable (GHC.Types.Unique.FM.NonDetUniqFM key)
instance GHC.Base.Semigroup (GHC.Types.Unique.FM.UniqFM key a)
instance GHC.Base.Monoid (GHC.Types.Unique.FM.UniqFM key a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.FM.UniqFM key a)


-- | Defines basic functions for printing error messages.
--   
--   It's hard to put these functions anywhere else without causing some
--   unnecessary loops in the module dependency graph.
module GHC.Utils.Panic

-- | GHC's own exception type error messages all take the form:
--   
--   <pre>
--   &lt;location&gt;: &lt;error&gt;
--   
--   </pre>
--   
--   If the location is on the command line, or in GHC itself, then
--   &lt;location&gt;="ghc". All of the error types below correspond to a
--   &lt;location&gt; of "ghc", except for ProgramError (where the string
--   is assumed to contain a location already, so we don't print one).
data GhcException

-- | Some other fatal signal (SIGHUP,SIGTERM)
Signal :: Int -> GhcException

-- | Prints the short usage msg after the error
UsageError :: String -> GhcException

-- | A problem with the command line arguments, but don't print usage.
CmdLineError :: String -> GhcException

-- | The <tt>impossible</tt> happened.
Panic :: String -> GhcException
PprPanic :: String -> SDoc -> GhcException

-- | The user tickled something that's known not to work yet, but we're not
--   counting it as a bug.
Sorry :: String -> GhcException
PprSorry :: String -> SDoc -> GhcException

-- | An installation problem.
InstallationError :: String -> GhcException

-- | An error in the user's code, probably.
ProgramError :: String -> GhcException
PprProgramError :: String -> SDoc -> GhcException

-- | Append a description of the given exception to this string.
showGhcException :: SDocContext -> GhcException -> ShowS

-- | Append a description of the given exception to this string.
--   
--   Note that this uses <a>defaultSDocContext</a>, which doesn't use the
--   options set by the user via DynFlags.
showGhcExceptionUnsafe :: GhcException -> ShowS
throwGhcException :: GhcException -> a
throwGhcExceptionIO :: GhcException -> IO a
handleGhcException :: ExceptionMonad m => (GhcException -> m a) -> m a -> m a

-- | The name of this GHC.
progName :: String

-- | Panics and asserts.
pgmError :: String -> a

-- | Panics and asserts.
panic :: String -> a

-- | Throw an exception saying "bug in GHC" with a callstack
pprPanic :: HasCallStack => String -> SDoc -> a

-- | Throw a failed assertion exception for a given filename and line
--   number.
assertPanic :: String -> Int -> a

-- | Panic with an assertion failure, recording the given file and line
--   number. Should typically be accessed with the ASSERT family of macros
assertPprPanic :: HasCallStack => String -> Int -> SDoc -> a

-- | Panics and asserts.
sorry :: String -> a

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> and outputs the
--   message to stderr. Depending on your terminal (settings), they may or
--   may not be mixed.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   calling f with x = 123
--   "123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: String -> a -> a

-- | Throw an exception saying "bug in GHC"
panicDoc :: String -> SDoc -> a

-- | Throw an exception saying "this isn't finished yet"
sorryDoc :: String -> SDoc -> a

-- | Throw an exception saying "bug in pgm being compiled" (used for
--   unusual program errors)
pgmErrorDoc :: String -> SDoc -> a
cmdLineError :: String -> a
cmdLineErrorIO :: String -> IO a
callStackDoc :: HasCallStack => SDoc

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | Show an exception as a string.
showException :: Exception e => e -> String

-- | Show an exception which can possibly throw other exceptions. Used when
--   displaying exception thrown within TH code.
safeShowException :: Exception e => e -> IO String

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised then it will be propagated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
try :: Exception e => IO a -> IO (Either e a)

-- | Like try, but pass through UserInterrupt and Panic exceptions. Used
--   when we want soft failures when reading interface files, for example.
--   TODO: I'm not entirely sure if this is catching what we really want to
--   catch
tryMost :: IO a -> IO (Either SomeException a)

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | Temporarily install standard signal handlers for catching ^C, which
--   just throw an exception in the current thread.
withSignalHandlers :: ExceptionMonad m => m a -> m a
instance GHC.Exception.Type.Exception GHC.Utils.Panic.GhcException
instance GHC.Show.Show GHC.Utils.Panic.GhcException

module GHC.Types.Unique

-- | Unique identifier.
--   
--   The type of unique identifiers that are used in many places in GHC for
--   fast ordering and equality tests. You should generate these with the
--   functions from the <tt>UniqSupply</tt> module
--   
--   These are sometimes also referred to as "keys" in comments in GHC.
data Unique

-- | Class of things that we can obtain a <a>Unique</a> from
class Uniquable a
getUnique :: Uniquable a => a -> Unique
uNIQUE_BITS :: Int
hasKey :: Uniquable a => a -> Unique -> Bool
pprUniqueAlways :: Unique -> SDoc
mkUniqueGrimily :: Int -> Unique
getKey :: Unique -> Int
mkUnique :: Char -> Int -> Unique
unpkUnique :: Unique -> (Char, Int)
eqUnique :: Unique -> Unique -> Bool
ltUnique :: Unique -> Unique -> Bool
incrUnique :: Unique -> Unique
stepUnique :: Unique -> Int -> Unique
newTagUnique :: Unique -> Char -> Unique
nonDetCmpUnique :: Unique -> Unique -> Ordering

-- | The interface file symbol-table encoding assumes that known-key
--   uniques fit in 30-bits; verify this.
--   
--   See Note [Symbol table representation of names] in
--   <a>GHC.Iface.Binary</a> for details.
isValidKnownKeyUnique :: Unique -> Bool
mkLocalUnique :: Int -> Unique
minLocalUnique :: Unique
maxLocalUnique :: Unique
instance GHC.Types.Unique.Uniquable GHC.Data.FastString.FastString
instance GHC.Types.Unique.Uniquable GHC.Types.Int
instance GHC.Types.Unique.Uniquable GHC.Types.Unique.Unique
instance GHC.Classes.Eq GHC.Types.Unique.Unique
instance GHC.Utils.Outputable.Outputable GHC.Types.Unique.Unique
instance GHC.Show.Show GHC.Types.Unique.Unique


-- | This module contains types that relate to the positions of things in
--   source files, and allow tagging of those things with locations
module GHC.Types.SrcLoc

-- | Real Source Location
--   
--   Represents a single point within a file
data RealSrcLoc

-- | Source Location
data SrcLoc
RealSrcLoc :: !RealSrcLoc -> !Maybe BufPos -> SrcLoc
UnhelpfulLoc :: FastString -> SrcLoc
mkSrcLoc :: FastString -> Int -> Int -> SrcLoc
mkRealSrcLoc :: FastString -> Int -> Int -> RealSrcLoc

-- | Creates a "bad" <a>SrcLoc</a> that has no detailed information about
--   its location
mkGeneralSrcLoc :: FastString -> SrcLoc

-- | Built-in "bad" <a>SrcLoc</a> values for particular locations
noSrcLoc :: SrcLoc

-- | Built-in "bad" <a>SrcLoc</a> values for particular locations
generatedSrcLoc :: SrcLoc

-- | Built-in "bad" <a>SrcLoc</a> values for particular locations
interactiveSrcLoc :: SrcLoc

-- | Move the <a>SrcLoc</a> down by one line if the character is a newline,
--   to the next 8-char tabstop if it is a tab, and across by one character
--   in any other case
advanceSrcLoc :: RealSrcLoc -> Char -> RealSrcLoc
advanceBufPos :: BufPos -> BufPos

-- | Gives the filename of the <a>SrcLoc</a>
srcLocFile :: RealSrcLoc -> FastString

-- | Raises an error when used on a "bad" <a>SrcLoc</a>
srcLocLine :: RealSrcLoc -> Int

-- | Raises an error when used on a "bad" <a>SrcLoc</a>
srcLocCol :: RealSrcLoc -> Int

-- | A <a>SrcSpan</a> delimits a portion of a text file. It could be
--   represented by a pair of (line,column) coordinates, but in fact we
--   optimise slightly by using more compact representations for
--   single-line and zero-length spans, both of which are quite common.
--   
--   The end position is defined to be the column <i>after</i> the end of
--   the span. That is, a span of (1,1)-(1,2) is one character long, and a
--   span of (1,1)-(1,1) is zero characters long.
--   
--   Real Source Span
data RealSrcSpan

-- | Source Span
--   
--   A <a>SrcSpan</a> identifies either a specific portion of a text file
--   or a human-readable description of a location.
data SrcSpan
RealSrcSpan :: !RealSrcSpan -> !Maybe BufSpan -> SrcSpan
UnhelpfulSpan :: !UnhelpfulSpanReason -> SrcSpan
data UnhelpfulSpanReason
UnhelpfulNoLocationInfo :: UnhelpfulSpanReason
UnhelpfulWiredIn :: UnhelpfulSpanReason
UnhelpfulInteractive :: UnhelpfulSpanReason
UnhelpfulGenerated :: UnhelpfulSpanReason
UnhelpfulOther :: !FastString -> UnhelpfulSpanReason

-- | Create a "bad" <a>SrcSpan</a> that has not location information
mkGeneralSrcSpan :: FastString -> SrcSpan

-- | Create a <a>SrcSpan</a> between two points in a file
mkSrcSpan :: SrcLoc -> SrcLoc -> SrcSpan

-- | Create a <a>SrcSpan</a> between two points in a file
mkRealSrcSpan :: RealSrcLoc -> RealSrcLoc -> RealSrcSpan

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
noSrcSpan :: SrcSpan

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
generatedSrcSpan :: SrcSpan
isGeneratedSrcSpan :: SrcSpan -> Bool

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
wiredInSrcSpan :: SrcSpan

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
interactiveSrcSpan :: SrcSpan

-- | Create a <a>SrcSpan</a> corresponding to a single point
srcLocSpan :: SrcLoc -> SrcSpan
realSrcLocSpan :: RealSrcLoc -> RealSrcSpan

-- | Combines two <a>SrcSpan</a> into one that spans at least all the
--   characters within both spans. Returns UnhelpfulSpan if the files
--   differ.
combineSrcSpans :: SrcSpan -> SrcSpan -> SrcSpan

-- | Convert a SrcSpan into one that represents only its first character
srcSpanFirstCharacter :: SrcSpan -> SrcSpan

-- | Returns the location at the start of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanStart :: SrcSpan -> SrcLoc

-- | Returns the location at the end of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanEnd :: SrcSpan -> SrcLoc
realSrcSpanStart :: RealSrcSpan -> RealSrcLoc
realSrcSpanEnd :: RealSrcSpan -> RealSrcLoc

-- | Obtains the filename for a <a>SrcSpan</a> if it is "good"
srcSpanFileName_maybe :: SrcSpan -> Maybe FastString
pprUserRealSpan :: Bool -> RealSrcSpan -> SDoc
pprUnhelpfulSpanReason :: UnhelpfulSpanReason -> SDoc
pprUserSpan :: Bool -> SrcSpan -> SDoc
unhelpfulSpanFS :: UnhelpfulSpanReason -> FastString
srcSpanToRealSrcSpan :: SrcSpan -> Maybe RealSrcSpan
srcSpanFile :: RealSrcSpan -> FastString
srcSpanStartLine :: RealSrcSpan -> Int
srcSpanEndLine :: RealSrcSpan -> Int
srcSpanStartCol :: RealSrcSpan -> Int
srcSpanEndCol :: RealSrcSpan -> Int

-- | Test if a <a>SrcSpan</a> is "good", i.e. has precise location
--   information
isGoodSrcSpan :: SrcSpan -> Bool

-- | True if the span is known to straddle only one line. For "bad"
--   <a>SrcSpan</a>, it returns False
isOneLineSpan :: SrcSpan -> Bool

-- | True if the span has a width of zero, as returned for "virtual"
--   semicolons in the lexer. For "bad" <a>SrcSpan</a>, it returns False
isZeroWidthSpan :: SrcSpan -> Bool

-- | Tests whether the first span "contains" the other span, meaning that
--   it covers at least as much source code. True where spans are equal.
containsSpan :: RealSrcSpan -> RealSrcSpan -> Bool

-- | 0-based offset identifying the raw location in the
--   <tt>StringBuffer</tt>.
--   
--   The lexer increments the <a>BufPos</a> every time a character (UTF-8
--   code point) is read from the input buffer. As UTF-8 is a
--   variable-length encoding and <tt>StringBuffer</tt> needs a byte offset
--   for indexing, a <a>BufPos</a> cannot be used for indexing.
--   
--   The parser guarantees that <a>BufPos</a> are monotonic. See #17632.
--   This means that syntactic constructs that appear later in the
--   <tt>StringBuffer</tt> are guaranteed to have a higher <a>BufPos</a>.
--   Constrast that with <a>SrcLoc</a>, which does *not* make the analogous
--   guarantee about higher line/column numbers.
--   
--   This is due to #line and {-# LINE ... #-} pragmas that can arbitrarily
--   modify <a>SrcLoc</a>. Notice how <tt>setSrcLoc</tt> and
--   <tt>resetAlrLastLoc</tt> in <a>GHC.Parser.Lexer</a> update
--   <a>PsLoc</a>, modifying <a>SrcLoc</a> but preserving <a>BufPos</a>.
--   
--   Monotonicity makes <a>BufPos</a> useful to determine the order in
--   which syntactic elements appear in the source. Consider this example
--   (haddockA041 in the test suite):
--   
--   haddockA041.hs {-# LANGUAGE CPP #-} -- | Module header documentation
--   module Comments_and_CPP_include where #include "IncludeMe.hs"
--   
--   IncludeMe.hs: -- | Comment on T data T = MkT -- ^ Comment on MkT
--   
--   After the C preprocessor runs, the <tt>StringBuffer</tt> will contain
--   a program that looks like this (unimportant lines at the beginning
--   removed):
--   
--   # 1 "haddockA041.hs" {-# LANGUAGE CPP #-} -- | Module header
--   documentation module Comments_and_CPP_include where # 1 "IncludeMe.hs"
--   1 -- | Comment on T data T = MkT -- ^ Comment on MkT # 7
--   "haddockA041.hs" 2
--   
--   The line pragmas inserted by CPP make the error messages more
--   informative. The downside is that we can't use RealSrcLoc to determine
--   the ordering of syntactic elements.
--   
--   With RealSrcLoc, we have the following location information recorded
--   in the AST: * The module name is located at haddockA041.hs:3:8-31 *
--   The Haddock comment "Comment on T" is located at IncludeMe:1:1-17 *
--   The data declaration is located at IncludeMe.hs:2:1-32
--   
--   Is the Haddock comment located between the module name and the data
--   declaration? This is impossible to tell because the locations are not
--   comparable; they even refer to different files.
--   
--   On the other hand, with <a>BufPos</a>, we have the following location
--   information: * The module name is located at 846-870 * The Haddock
--   comment "Comment on T" is located at 898-915 * The data declaration is
--   located at 916-928
--   
--   Aside: if you're wondering why the numbers are so high, try running
--   <tt>ghc -E haddockA041.hs</tt> and see the extra fluff that CPP
--   inserts at the start of the file.
--   
--   For error messages, <a>BufPos</a> is not useful at all. On the other
--   hand, this is exactly what we need to determine the order of syntactic
--   elements: 870 &lt; 898, therefore the Haddock comment appears *after*
--   the module name. 915 &lt; 916, therefore the Haddock comment appears
--   *before* the data declaration.
--   
--   We use <a>BufPos</a> in in GHC.Parser.PostProcess.Haddock to associate
--   Haddock comments with parts of the AST using location information
--   (#17544).
newtype BufPos
BufPos :: Int -> BufPos
[bufPos] :: BufPos -> Int
getBufPos :: SrcLoc -> Maybe BufPos

-- | StringBuffer Source Span
data BufSpan
BufSpan :: {-# UNPACK #-} !BufPos -> BufSpan
[bufSpanStart, bufSpanEnd] :: BufSpan -> {-# UNPACK #-} !BufPos
getBufSpan :: SrcSpan -> Maybe BufSpan
type Located = GenLocated SrcSpan
type RealLocated = GenLocated RealSrcSpan

-- | We attach SrcSpans to lots of things, so let's have a datatype for it.
data GenLocated l e
L :: l -> e -> GenLocated l e
noLoc :: e -> Located e
mkGeneralLocated :: String -> e -> Located e
getLoc :: GenLocated l e -> l
unLoc :: GenLocated l e -> e
unRealSrcSpan :: RealLocated a -> a
getRealSrcSpan :: RealLocated a -> RealSrcSpan
pprLocated :: (Outputable l, Outputable e) => GenLocated l e -> SDoc
mapLoc :: (a -> b) -> GenLocated l a -> GenLocated l b

-- | Tests whether the two located things are equal
eqLocated :: Eq a => GenLocated l a -> GenLocated l a -> Bool

-- | Tests the ordering of the two located things
cmpLocated :: Ord a => GenLocated l a -> GenLocated l a -> Ordering

-- | Compare the <a>BufSpan</a> of two located things.
--   
--   Precondition: both operands have an associated <a>BufSpan</a>.
cmpBufSpan :: HasDebugCallStack => Located a -> Located a -> Ordering
combineLocs :: Located a -> Located b -> SrcSpan

-- | Combine locations from two <a>Located</a> things and add them to a
--   third thing
addCLoc :: Located a -> Located b -> c -> Located c

-- | Strategies for ordering <a>SrcSpan</a>s
leftmost_smallest :: SrcSpan -> SrcSpan -> Ordering

-- | Strategies for ordering <a>SrcSpan</a>s
leftmost_largest :: SrcSpan -> SrcSpan -> Ordering

-- | Strategies for ordering <a>SrcSpan</a>s
rightmost_smallest :: SrcSpan -> SrcSpan -> Ordering

-- | Determines whether a span encloses a given line and column index
spans :: SrcSpan -> (Int, Int) -> Bool

-- | Determines whether a span is enclosed by another one
isSubspanOf :: SrcSpan -> SrcSpan -> Bool

-- | Determines whether a span is enclosed by another one
isRealSubspanOf :: RealSrcSpan -> RealSrcSpan -> Bool
sortLocated :: [Located a] -> [Located a]
sortRealLocated :: [RealLocated a] -> [RealLocated a]
lookupSrcLoc :: SrcLoc -> Map RealSrcLoc a -> Maybe a
lookupSrcSpan :: SrcSpan -> Map RealSrcSpan a -> Maybe a
liftL :: Monad m => (a -> m b) -> GenLocated l a -> m (GenLocated l b)

-- | A location as produced by the parser. Consists of two components:
--   
--   <ul>
--   <li>The location in the file, adjusted for #line and {-# LINE ... #-}
--   pragmas (RealSrcLoc)</li>
--   <li>The location in the string buffer (BufPos) with monotonicity
--   guarantees (see #17632)</li>
--   </ul>
data PsLoc
PsLoc :: !RealSrcLoc -> !BufPos -> PsLoc
[psRealLoc] :: PsLoc -> !RealSrcLoc
[psBufPos] :: PsLoc -> !BufPos
data PsSpan
PsSpan :: !RealSrcSpan -> !BufSpan -> PsSpan
[psRealSpan] :: PsSpan -> !RealSrcSpan
[psBufSpan] :: PsSpan -> !BufSpan
type PsLocated = GenLocated PsSpan
advancePsLoc :: PsLoc -> Char -> PsLoc
mkPsSpan :: PsLoc -> PsLoc -> PsSpan
psSpanStart :: PsSpan -> PsLoc
psSpanEnd :: PsSpan -> PsLoc
mkSrcSpanPs :: PsSpan -> SrcSpan

-- | Combines two <a>SrcSpan</a> into one that spans at least all the
--   characters within both spans. Assumes the "file" part is the same in
--   both inputs
combineRealSrcSpans :: RealSrcSpan -> RealSrcSpan -> RealSrcSpan

-- | Layout information for declarations.
data LayoutInfo

-- | Explicit braces written by the user.
--   
--   <pre>
--   class C a where { foo :: a; bar :: a }
--   </pre>
ExplicitBraces :: LayoutInfo

-- | Virtual braces inserted by the layout algorithm.
--   
--   <pre>
--   class C a where
--     foo :: a
--     bar :: a
--   </pre>
VirtualBraces :: !Int -> LayoutInfo

-- | Empty or compiler-generated blocks do not have layout information
--   associated with them.
NoLayoutInfo :: LayoutInfo

-- | Indentation level is 1-indexed, so the leftmost column is 1.
leftmostColumn :: Int
instance GHC.Classes.Ord GHC.Types.SrcLoc.RealSrcLoc
instance GHC.Classes.Eq GHC.Types.SrcLoc.RealSrcLoc
instance GHC.Show.Show GHC.Types.SrcLoc.BufPos
instance GHC.Classes.Ord GHC.Types.SrcLoc.BufPos
instance GHC.Classes.Eq GHC.Types.SrcLoc.BufPos
instance GHC.Show.Show GHC.Types.SrcLoc.SrcLoc
instance GHC.Classes.Eq GHC.Types.SrcLoc.SrcLoc
instance GHC.Classes.Eq GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Show.Show GHC.Types.SrcLoc.BufSpan
instance GHC.Classes.Ord GHC.Types.SrcLoc.BufSpan
instance GHC.Classes.Eq GHC.Types.SrcLoc.BufSpan
instance GHC.Show.Show GHC.Types.SrcLoc.UnhelpfulSpanReason
instance GHC.Classes.Eq GHC.Types.SrcLoc.UnhelpfulSpanReason
instance GHC.Show.Show GHC.Types.SrcLoc.SrcSpan
instance GHC.Classes.Eq GHC.Types.SrcLoc.SrcSpan
instance Data.Traversable.Traversable (GHC.Types.SrcLoc.GenLocated l)
instance Data.Foldable.Foldable (GHC.Types.SrcLoc.GenLocated l)
instance GHC.Base.Functor (GHC.Types.SrcLoc.GenLocated l)
instance (Data.Data.Data l, Data.Data.Data e) => Data.Data.Data (GHC.Types.SrcLoc.GenLocated l e)
instance (GHC.Classes.Ord l, GHC.Classes.Ord e) => GHC.Classes.Ord (GHC.Types.SrcLoc.GenLocated l e)
instance (GHC.Classes.Eq l, GHC.Classes.Eq e) => GHC.Classes.Eq (GHC.Types.SrcLoc.GenLocated l e)
instance GHC.Show.Show GHC.Types.SrcLoc.PsLoc
instance GHC.Classes.Ord GHC.Types.SrcLoc.PsLoc
instance GHC.Classes.Eq GHC.Types.SrcLoc.PsLoc
instance GHC.Show.Show GHC.Types.SrcLoc.PsSpan
instance GHC.Classes.Ord GHC.Types.SrcLoc.PsSpan
instance GHC.Classes.Eq GHC.Types.SrcLoc.PsSpan
instance Data.Data.Data GHC.Types.SrcLoc.LayoutInfo
instance GHC.Show.Show GHC.Types.SrcLoc.LayoutInfo
instance GHC.Classes.Ord GHC.Types.SrcLoc.LayoutInfo
instance GHC.Classes.Eq GHC.Types.SrcLoc.LayoutInfo
instance GHC.Utils.Outputable.Outputable e => GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.Located e)
instance GHC.Utils.Outputable.Outputable e => GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.GenLocated GHC.Types.SrcLoc.RealSrcSpan e)
instance Data.Data.Data GHC.Types.SrcLoc.SrcSpan
instance GHC.Utils.Json.ToJson GHC.Types.SrcLoc.SrcSpan
instance Control.DeepSeq.NFData GHC.Types.SrcLoc.SrcSpan
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.SrcSpan
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.UnhelpfulSpanReason
instance GHC.Base.Semigroup GHC.Types.SrcLoc.BufSpan
instance Data.Data.Data GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Utils.Json.ToJson GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Classes.Ord GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Show.Show GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.SrcLoc
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.RealSrcLoc
instance GHC.Show.Show GHC.Types.SrcLoc.RealSrcLoc

module GHC.Utils.Json

-- | Simple data type to represent JSON documents.
data JsonDoc
[JSNull] :: JsonDoc
[JSBool] :: Bool -> JsonDoc
[JSInt] :: Int -> JsonDoc
[JSString] :: String -> JsonDoc
[JSArray] :: [JsonDoc] -> JsonDoc
[JSObject] :: [(String, JsonDoc)] -> JsonDoc
renderJSON :: JsonDoc -> SDoc
escapeJsonString :: String -> String
class ToJson a
json :: ToJson a => a -> JsonDoc


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see
--   <a>GHC.Types.Name.Occurrence#name_types</a></li>
--   <li><a>RdrName</a>: see <a>GHC.Types.Name.Reader#name_types</a></li>
--   <li><a>Name</a> is the type of names that have had their scoping and
--   binding resolved. They have an <a>OccName</a> but also a <a>Unique</a>
--   that disambiguates Names that have the same <a>OccName</a> and indeed
--   is used for all <a>Name</a> comparison. Names also contain information
--   about where they originated from, see
--   <a>GHC.Types.Name#name_sorts</a></li>
--   <li><a>Id</a>: see <a>GHC.Types.Id#name_types</a></li>
--   <li><a>Var</a>: see <a>GHC.Types.Var#name_types</a></li>
--   </ul>
--   
--   Names are one of:
--   
--   <ul>
--   <li>External, if they name things declared in other modules. Some
--   external Names are wired in, i.e. they name primitives defined in the
--   compiler itself</li>
--   <li>Internal, if they name things in the module being compiled. Some
--   internal Names are system names, if they are names manufactured by the
--   compiler</li>
--   </ul>
module GHC.Types.Name

-- | A unique, unambiguous name for something, containing information about
--   where that thing originated.
data Name

-- | BuiltInSyntax is for things like <tt>(:)</tt>, <tt>[]</tt> and tuples,
--   which have special syntactic forms. They aren't in scope as such.
data BuiltInSyntax
BuiltInSyntax :: BuiltInSyntax
UserSyntax :: BuiltInSyntax

-- | Create a name brought into being by the compiler
mkSystemName :: Unique -> OccName -> Name
mkSystemNameAt :: Unique -> OccName -> SrcSpan -> Name

-- | Create a name which is (for now at least) local to the current module
--   and hence does not need a <a>Module</a> to disambiguate it from other
--   <a>Name</a>s
mkInternalName :: Unique -> OccName -> SrcSpan -> Name
mkClonedInternalName :: Unique -> Name -> Name
mkDerivedInternalName :: (OccName -> OccName) -> Unique -> Name -> Name
mkSystemVarName :: Unique -> FastString -> Name
mkSysTvName :: Unique -> FastString -> Name

-- | Make a name for a foreign call
mkFCallName :: Unique -> String -> Name

-- | Create a name which definitely originates in the given module
mkExternalName :: Unique -> Module -> OccName -> SrcSpan -> Name

-- | Create a name which is actually defined by the compiler itself
mkWiredInName :: Module -> OccName -> Unique -> TyThing -> BuiltInSyntax -> Name
nameUnique :: Name -> Unique
setNameUnique :: Name -> Unique -> Name
nameOccName :: Name -> OccName
nameNameSpace :: Name -> NameSpace
nameModule :: HasDebugCallStack => Name -> Module
nameModule_maybe :: Name -> Maybe Module
setNameLoc :: Name -> SrcSpan -> Name
tidyNameOcc :: Name -> OccName -> Name

-- | Make the <a>Name</a> into an internal name, regardless of what it was
--   to begin with
localiseName :: Name -> Name
nameSrcLoc :: Name -> SrcLoc
nameSrcSpan :: Name -> SrcSpan
pprNameDefnLoc :: Name -> SDoc
pprDefinedAt :: Name -> SDoc
isSystemName :: Name -> Bool
isInternalName :: Name -> Bool
isExternalName :: Name -> Bool
isTyVarName :: Name -> Bool
isTyConName :: Name -> Bool
isDataConName :: Name -> Bool
isValName :: Name -> Bool
isVarName :: Name -> Bool

-- | Will the <a>Name</a> come from a dynamically linked package?
isDynLinkName :: Platform -> Module -> Name -> Bool
isWiredInName :: Name -> Bool
isWiredIn :: NamedThing thing => thing -> Bool
isBuiltInSyntax :: Name -> Bool
isHoleName :: Name -> Bool
wiredInNameTyThing_maybe :: Name -> Maybe TyThing

-- | Returns True if the name is (a) Internal (b) External but from the
--   specified module (c) External but from the <tt>interactive</tt>
--   package
--   
--   The key idea is that False means: the entity is defined in some other
--   module you can find the details (type, fixity, instances) in some
--   interface file those details will be stored in the EPT or HPT
--   
--   True means: the entity is defined in this module or earlier in the
--   GHCi session you can find details (type, fixity, instances) in the
--   TcGblEnv or TcLclEnv
--   
--   The isInteractiveModule part is because successive interactions of a
--   GHCi session each give rise to a fresh module (Ghci1, Ghci2, etc), but
--   they all come from the magic <tt>interactive</tt> package; and all the
--   details are kept in the TcLclEnv, TcGblEnv, NOT in the HPT or EPT. See
--   Note [The interactive package] in <a>GHC.Runtime.Context</a>
nameIsLocalOrFrom :: Module -> Name -> Bool
nameIsHomePackage :: Module -> Name -> Bool
nameIsHomePackageImport :: Module -> Name -> Bool

-- | Returns True if the Name comes from some other package: neither this
--   package nor the interactive package.
nameIsFromExternalPackage :: HomeUnit -> Name -> Bool

-- | Compare Names lexicographically This only works for Names that
--   originate in the source code or have been tidied.
stableNameCmp :: Name -> Name -> Ordering

-- | A class allowing convenient access to the <a>Name</a> of various
--   datatypes
class NamedThing a
getOccName :: NamedThing a => a -> OccName
getName :: NamedThing a => a -> Name
getSrcLoc :: NamedThing a => a -> SrcLoc
getSrcSpan :: NamedThing a => a -> SrcSpan
getOccString :: NamedThing a => a -> String
getOccFS :: NamedThing a => a -> FastString
pprInfixName :: (Outputable a, NamedThing a) => a -> SDoc
pprPrefixName :: NamedThing a => a -> SDoc
pprModulePrefix :: PprStyle -> Module -> OccName -> SDoc

-- | Print the string of Name unqualifiedly directly.
pprNameUnqualified :: Name -> SDoc

-- | Get a string representation of a <a>Name</a> that's unique and stable
--   across recompilations. Used for deterministic generation of binds for
--   derived instances. eg.
--   "$aeson_70dylHtv1FFGeai1IoxcQr$Data.Aeson.Types.Internal$String"
nameStableString :: Name -> String
instance GHC.Types.Name.NamedThing GHC.Types.Name.Name
instance GHC.Types.Name.NamedThing e => GHC.Types.Name.NamedThing (GHC.Types.SrcLoc.Located e)
instance Control.DeepSeq.NFData GHC.Types.Name.Name
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Name.Name
instance GHC.Classes.Eq GHC.Types.Name.Name
instance GHC.Classes.Ord GHC.Types.Name.Name
instance GHC.Types.Unique.Uniquable GHC.Types.Name.Name
instance Data.Data.Data GHC.Types.Name.Name
instance GHC.Utils.Binary.Binary GHC.Types.Name.Name
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Name
instance GHC.Utils.Outputable.OutputableBndr GHC.Types.Name.Name
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.NameSort
instance Control.DeepSeq.NFData GHC.Types.Name.NameSort

module GHC.Unit.Module

-- | Given a possibly on-the-fly instantiated module, split it into a
--   <a>Module</a> that we definitely can find on-disk, as well as an
--   instantiation if we need to instantiate it on the fly. If the
--   instantiation is <tt>Nothing</tt> no on-the-fly renaming is needed.
getModuleInstantiation :: Module -> (InstalledModule, Maybe InstantiatedModule)

-- | Return the unit-id this unit is an instance of and the module
--   instantiations (if any).
getUnitInstantiations :: Unit -> (UnitId, Maybe InstantiatedUnit)

-- | Remove instantiations of the given instantiated unit
uninstantiateInstantiatedUnit :: InstantiatedUnit -> InstantiatedUnit

-- | Remove instantiations of the given module instantiated unit
uninstantiateInstantiatedModule :: InstantiatedModule -> InstantiatedModule

-- | Create a hole Module
mkHoleModule :: ModuleName -> GenModule (GenUnit u)

-- | Test if a Module is not instantiated
isHoleModule :: GenModule (GenUnit u) -> Bool

-- | This gives a stable ordering, as opposed to the Ord instance which
--   gives an ordering based on the <tt>Unique</tt>s of the components,
--   which may not be stable from run to run of the compiler.
stableModuleCmp :: Module -> Module -> Ordering

-- | Get a string representation of a <a>Module</a> that's unique and
--   stable across recompilations. eg.
--   "$aeson_70dylHtv1FFGeai1IoxcQr$Data.Aeson.Types.Internal"
moduleStableString :: Module -> String

-- | A <a>Module</a> is definite if it has no free holes.
moduleIsDefinite :: Module -> Bool
class HasModule m
getModule :: HasModule m => m Module
class ContainsModule t
extractModule :: ContainsModule t => t -> Module

-- | Test if a <a>Module</a> corresponds to a given <a>InstalledModule</a>,
--   modulo instantiation.
installedModuleEq :: InstalledModule -> Module -> Bool


-- | The ModuleName type
module GHC.Unit.Module.Name

-- | A ModuleName is essentially a simple string, e.g. <tt>Data.List</tt>.
data ModuleName
pprModuleName :: ModuleName -> SDoc
moduleNameFS :: ModuleName -> FastString
moduleNameString :: ModuleName -> String

-- | Returns the string version of the module name, with dots replaced by
--   slashes.
moduleNameSlashes :: ModuleName -> String

-- | Returns the string version of the module name, with dots replaced by
--   colons.
moduleNameColons :: ModuleName -> String
mkModuleName :: String -> ModuleName
mkModuleNameFS :: FastString -> ModuleName

-- | Compares module names lexically, rather than by their <a>Unique</a>s
stableModuleNameCmp :: ModuleName -> ModuleName -> Ordering
parseModuleName :: ReadP ModuleName
instance GHC.Show.Show GHC.Unit.Module.Name.ModuleName
instance GHC.Types.Unique.Uniquable GHC.Unit.Module.Name.ModuleName
instance GHC.Classes.Eq GHC.Unit.Module.Name.ModuleName
instance GHC.Classes.Ord GHC.Unit.Module.Name.ModuleName
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Name.ModuleName
instance GHC.Utils.Binary.Binary GHC.Unit.Module.Name.ModuleName
instance Data.Data.Data GHC.Unit.Module.Name.ModuleName
instance Control.DeepSeq.NFData GHC.Unit.Module.Name.ModuleName


-- | Module location
module GHC.Unit.Module.Location

-- | Module Location
--   
--   Where a module lives on the file system: the actual locations of the
--   .hs, .hi and .o files, if we have them.
--   
--   For a module in another unit, the ml_hs_file and ml_obj_file
--   components of ModLocation are undefined.
--   
--   The locations specified by a ModLocation may or may not correspond to
--   actual files yet: for example, even if the object file doesn't exist,
--   the ModLocation still contains the path to where the object file will
--   reside if/when it is created.
data ModLocation
ModLocation :: Maybe FilePath -> FilePath -> FilePath -> FilePath -> ModLocation

-- | The source file, if we have one. Package modules probably don't have
--   source files.
[ml_hs_file] :: ModLocation -> Maybe FilePath

-- | Where the .hi file is, whether or not it exists yet. Always of form
--   foo.hi, even if there is an hi-boot file (we add the -boot suffix
--   later)
[ml_hi_file] :: ModLocation -> FilePath

-- | Where the .o file is, whether or not it exists yet. (might not exist
--   either because the module hasn't been compiled yet, or because it is
--   part of a unit with a .a file)
[ml_obj_file] :: ModLocation -> FilePath

-- | Where the .hie file is, whether or not it exists yet.
[ml_hie_file] :: ModLocation -> FilePath

-- | Add the <tt>-boot</tt> suffix to .hs, .hi and .o files
addBootSuffix :: FilePath -> FilePath

-- | Add the <tt>-boot</tt> suffix if the <tt>Bool</tt> argument is
--   <tt>True</tt>
addBootSuffix_maybe :: IsBootInterface -> FilePath -> FilePath

-- | Add the <tt>-boot</tt> suffix to all file paths associated with the
--   module
addBootSuffixLocn :: ModLocation -> ModLocation

-- | Add the <tt>-boot</tt> suffix to all output file paths associated with
--   the module, not including the input file itself
addBootSuffixLocnOut :: ModLocation -> ModLocation

-- | Remove the <tt>-boot</tt> suffix to .hs, .hi and .o files
removeBootSuffix :: FilePath -> FilePath
instance GHC.Show.Show GHC.Unit.Module.Location.ModLocation
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Location.ModLocation


-- | Module environment
module GHC.Unit.Module.Env

-- | A map keyed off of <a>Module</a>s
data ModuleEnv elt
elemModuleEnv :: Module -> ModuleEnv a -> Bool
extendModuleEnv :: ModuleEnv a -> Module -> a -> ModuleEnv a
extendModuleEnvList :: ModuleEnv a -> [(Module, a)] -> ModuleEnv a
extendModuleEnvList_C :: (a -> a -> a) -> ModuleEnv a -> [(Module, a)] -> ModuleEnv a
plusModuleEnv_C :: (a -> a -> a) -> ModuleEnv a -> ModuleEnv a -> ModuleEnv a
delModuleEnvList :: ModuleEnv a -> [Module] -> ModuleEnv a
delModuleEnv :: ModuleEnv a -> Module -> ModuleEnv a
plusModuleEnv :: ModuleEnv a -> ModuleEnv a -> ModuleEnv a
lookupModuleEnv :: ModuleEnv a -> Module -> Maybe a
lookupWithDefaultModuleEnv :: ModuleEnv a -> a -> Module -> a
mapModuleEnv :: (a -> b) -> ModuleEnv a -> ModuleEnv b
mkModuleEnv :: [(Module, a)] -> ModuleEnv a
emptyModuleEnv :: ModuleEnv a
moduleEnvKeys :: ModuleEnv a -> [Module]
moduleEnvElts :: ModuleEnv a -> [a]
moduleEnvToList :: ModuleEnv a -> [(Module, a)]
unitModuleEnv :: Module -> a -> ModuleEnv a
isEmptyModuleEnv :: ModuleEnv a -> Bool
extendModuleEnvWith :: (a -> a -> a) -> ModuleEnv a -> Module -> a -> ModuleEnv a
filterModuleEnv :: (Module -> a -> Bool) -> ModuleEnv a -> ModuleEnv a

-- | A map keyed off of <a>ModuleName</a>s (actually, their <a>Unique</a>s)
type ModuleNameEnv elt = UniqFM ModuleName elt

-- | A map keyed off of <a>ModuleName</a>s (actually, their <a>Unique</a>s)
--   Has deterministic folds and can be deterministically converted to a
--   list
type DModuleNameEnv elt = UniqDFM ModuleName elt

-- | A set of <a>Module</a>s
type ModuleSet = Set NDModule
emptyModuleSet :: ModuleSet
mkModuleSet :: [Module] -> ModuleSet
moduleSetElts :: ModuleSet -> [Module]
extendModuleSet :: ModuleSet -> Module -> ModuleSet
extendModuleSetList :: ModuleSet -> [Module] -> ModuleSet
delModuleSet :: ModuleSet -> Module -> ModuleSet
elemModuleSet :: Module -> ModuleSet -> Bool
intersectModuleSet :: ModuleSet -> ModuleSet -> ModuleSet
minusModuleSet :: ModuleSet -> ModuleSet -> ModuleSet
unionModuleSet :: ModuleSet -> ModuleSet -> ModuleSet
unitModuleSet :: Module -> ModuleSet

-- | A map keyed off of <a>InstalledModule</a>
data InstalledModuleEnv elt
emptyInstalledModuleEnv :: InstalledModuleEnv a
lookupInstalledModuleEnv :: InstalledModuleEnv a -> InstalledModule -> Maybe a
extendInstalledModuleEnv :: InstalledModuleEnv a -> InstalledModule -> a -> InstalledModuleEnv a
filterInstalledModuleEnv :: (InstalledModule -> a -> Bool) -> InstalledModuleEnv a -> InstalledModuleEnv a
delInstalledModuleEnv :: InstalledModuleEnv a -> InstalledModule -> InstalledModuleEnv a
instance GHC.Classes.Eq GHC.Unit.Module.Env.NDModule
instance GHC.Classes.Ord GHC.Unit.Module.Env.NDModule

module GHC.Types.Unique.DFM

-- | Type of unique deterministic finite maps
--   
--   The key is just here to keep us honest. It's always safe to use a
--   single type as key. If two types don't overlap in their uniques it's
--   also safe to index the same map at multiple key types. But this is
--   very much discouraged.
data UniqDFM key ele
emptyUDFM :: UniqDFM key elt
unitUDFM :: Uniquable key => key -> elt -> UniqDFM key elt
addToUDFM :: Uniquable key => UniqDFM key elt -> key -> elt -> UniqDFM key elt
addToUDFM_C :: Uniquable key => (elt -> elt -> elt) -> UniqDFM key elt -> key -> elt -> UniqDFM key elt
addToUDFM_C_Directly :: (elt -> elt -> elt) -> UniqDFM key elt -> Unique -> elt -> UniqDFM key elt
addToUDFM_Directly :: UniqDFM key elt -> Unique -> elt -> UniqDFM key elt
addListToUDFM :: Uniquable key => UniqDFM key elt -> [(key, elt)] -> UniqDFM key elt
delFromUDFM :: Uniquable key => UniqDFM key elt -> key -> UniqDFM key elt

-- | Delete a list of elements from a UniqDFM
delListFromUDFM :: Uniquable key => UniqDFM key elt -> [key] -> UniqDFM key elt

-- | Apply a function to a particular element
adjustUDFM :: Uniquable key => (elt -> elt) -> UniqDFM key elt -> key -> UniqDFM key elt

-- | Apply a function to a particular element
adjustUDFM_Directly :: (elt -> elt) -> UniqDFM key elt -> Unique -> UniqDFM key elt

-- | The expression (alterUDFM f k map) alters value x at k, or absence
--   thereof. alterUDFM can be used to insert, delete, or update a value in
--   UniqDFM. Use addToUDFM, delFromUDFM or adjustUDFM when possible, they
--   are more efficient.
alterUDFM :: Uniquable key => (Maybe elt -> Maybe elt) -> UniqDFM key elt -> key -> UniqDFM key elt

-- | Map a function over every value in a UniqDFM
mapUDFM :: (elt1 -> elt2) -> UniqDFM key elt1 -> UniqDFM key elt2
mapMaybeUDFM :: forall elt1 elt2 key. (elt1 -> Maybe elt2) -> UniqDFM key elt1 -> UniqDFM key elt2
plusUDFM :: UniqDFM key elt -> UniqDFM key elt -> UniqDFM key elt
plusUDFM_C :: (elt -> elt -> elt) -> UniqDFM key elt -> UniqDFM key elt -> UniqDFM key elt
lookupUDFM :: Uniquable key => UniqDFM key elt -> key -> Maybe elt
lookupUDFM_Directly :: UniqDFM key elt -> Unique -> Maybe elt
elemUDFM :: Uniquable key => key -> UniqDFM key elt -> Bool

-- | Performs a deterministic fold over the UniqDFM. It's O(n log n) while
--   the corresponding function on <a>UniqFM</a> is O(n).
foldUDFM :: (elt -> a -> a) -> a -> UniqDFM key elt -> a
eltsUDFM :: UniqDFM key elt -> [elt]
filterUDFM :: (elt -> Bool) -> UniqDFM key elt -> UniqDFM key elt
filterUDFM_Directly :: (Unique -> elt -> Bool) -> UniqDFM key elt -> UniqDFM key elt
isNullUDFM :: UniqDFM key elt -> Bool
sizeUDFM :: UniqDFM key elt -> Int
intersectUDFM :: UniqDFM key elt -> UniqDFM key elt -> UniqDFM key elt
udfmIntersectUFM :: UniqDFM key elt1 -> UniqFM key elt2 -> UniqDFM key elt1
disjointUDFM :: UniqDFM key elt -> UniqDFM key elt -> Bool
disjointUdfmUfm :: UniqDFM key elt -> UniqFM key elt2 -> Bool
equalKeysUDFM :: UniqDFM key a -> UniqDFM key b -> Bool
minusUDFM :: UniqDFM key elt1 -> UniqDFM key elt2 -> UniqDFM key elt1
listToUDFM :: Uniquable key => [(key, elt)] -> UniqDFM key elt
listToUDFM_Directly :: [(Unique, elt)] -> UniqDFM key elt
udfmMinusUFM :: UniqDFM key elt1 -> UniqFM key elt2 -> UniqDFM key elt1
ufmMinusUDFM :: UniqFM key elt1 -> UniqDFM key elt2 -> UniqFM key elt1

-- | Partition UniqDFM into two UniqDFMs according to the predicate
partitionUDFM :: (elt -> Bool) -> UniqDFM key elt -> (UniqDFM key elt, UniqDFM key elt)
anyUDFM :: (elt -> Bool) -> UniqDFM key elt -> Bool
allUDFM :: (elt -> Bool) -> UniqDFM key elt -> Bool
pprUniqDFM :: (a -> SDoc) -> UniqDFM key a -> SDoc
pprUDFM :: UniqDFM key a -> ([a] -> SDoc) -> SDoc

-- | Converts <a>UniqDFM</a> to a list, with elements in deterministic
--   order. It's O(n log n) while the corresponding function on
--   <a>UniqFM</a> is O(n).
udfmToList :: UniqDFM key elt -> [(Unique, elt)]

-- | This allows for lossy conversion from UniqDFM to UniqFM
udfmToUfm :: UniqDFM key elt -> UniqFM key elt

-- | Performs a nondeterministic strict fold over the UniqDFM. It's O(n),
--   same as the corresponding function on <a>UniqFM</a>. If you use this
--   please provide a justification why it doesn't introduce
--   nondeterminism.
nonDetStrictFoldUDFM :: (elt -> a -> a) -> a -> UniqDFM key elt -> a

-- | Cast the key domain of a UniqFM.
--   
--   As long as the domains don't overlap in their uniques this is safe.
unsafeCastUDFMKey :: UniqDFM key1 elt -> UniqDFM key2 elt
alwaysUnsafeUfmToUdfm :: UniqFM key elt -> UniqDFM key elt
instance Data.Traversable.Traversable GHC.Types.Unique.DFM.TaggedVal
instance Data.Foldable.Foldable GHC.Types.Unique.DFM.TaggedVal
instance GHC.Base.Functor GHC.Types.Unique.DFM.TaggedVal
instance Data.Data.Data val => Data.Data.Data (GHC.Types.Unique.DFM.TaggedVal val)
instance GHC.Base.Functor (GHC.Types.Unique.DFM.UniqDFM key)
instance (Data.Data.Data key, Data.Data.Data ele) => Data.Data.Data (GHC.Types.Unique.DFM.UniqDFM key ele)
instance Data.Foldable.Foldable (GHC.Types.Unique.DFM.UniqDFM key)
instance Data.Traversable.Traversable (GHC.Types.Unique.DFM.UniqDFM key)
instance GHC.Base.Semigroup (GHC.Types.Unique.DFM.UniqDFM key a)
instance GHC.Base.Monoid (GHC.Types.Unique.DFM.UniqDFM key a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.DFM.UniqDFM key a)
instance GHC.Classes.Eq val => GHC.Classes.Eq (GHC.Types.Unique.DFM.TaggedVal val)


-- | Specialised deterministic sets, for things with <tt>Uniques</tt>
--   
--   Based on <a>UniqDFM</a>s (as you would expect). See Note
--   [Deterministic UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation
--   why we need it.
--   
--   Basically, the things need to be in class <a>Uniquable</a>.
module GHC.Types.Unique.DSet
data UniqDSet a
getUniqDSet :: UniqDSet a -> UniqDFM a a
pprUniqDSet :: (a -> SDoc) -> UniqDSet a -> SDoc
delOneFromUniqDSet :: Uniquable a => UniqDSet a -> a -> UniqDSet a
delListFromUniqDSet :: Uniquable a => UniqDSet a -> [a] -> UniqDSet a
emptyUniqDSet :: UniqDSet a
unitUniqDSet :: Uniquable a => a -> UniqDSet a
mkUniqDSet :: Uniquable a => [a] -> UniqDSet a
addOneToUniqDSet :: Uniquable a => UniqDSet a -> a -> UniqDSet a
addListToUniqDSet :: Uniquable a => UniqDSet a -> [a] -> UniqDSet a
unionUniqDSets :: UniqDSet a -> UniqDSet a -> UniqDSet a
unionManyUniqDSets :: [UniqDSet a] -> UniqDSet a
minusUniqDSet :: UniqDSet a -> UniqDSet a -> UniqDSet a
uniqDSetMinusUniqSet :: UniqDSet a -> UniqSet a -> UniqDSet a
intersectUniqDSets :: UniqDSet a -> UniqDSet a -> UniqDSet a
uniqDSetIntersectUniqSet :: UniqDSet a -> UniqSet a -> UniqDSet a
nonDetStrictFoldUniqDSet :: (a -> b -> b) -> b -> UniqDSet a -> b
elementOfUniqDSet :: Uniquable a => a -> UniqDSet a -> Bool
filterUniqDSet :: (a -> Bool) -> UniqDSet a -> UniqDSet a
sizeUniqDSet :: UniqDSet a -> Int
isEmptyUniqDSet :: UniqDSet a -> Bool
lookupUniqDSet :: Uniquable a => UniqDSet a -> a -> Maybe a
uniqDSetToList :: UniqDSet a -> [a]
partitionUniqDSet :: (a -> Bool) -> UniqDSet a -> (UniqDSet a, UniqDSet a)
mapUniqDSet :: Uniquable b => (a -> b) -> UniqDSet a -> UniqDSet b
instance GHC.Base.Monoid (GHC.Types.Unique.DSet.UniqDSet a)
instance GHC.Base.Semigroup (GHC.Types.Unique.DSet.UniqDSet a)
instance Data.Data.Data a => Data.Data.Data (GHC.Types.Unique.DSet.UniqDSet a)
instance GHC.Classes.Eq (GHC.Types.Unique.DSet.UniqDSet a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.DSet.UniqDSet a)

module GHC.Types.Unique.Set
data UniqSet a
getUniqSet :: UniqSet a -> UniqFM a a
pprUniqSet :: (a -> SDoc) -> UniqSet a -> SDoc
emptyUniqSet :: UniqSet a
unitUniqSet :: Uniquable a => a -> UniqSet a
mkUniqSet :: Uniquable a => [a] -> UniqSet a
addOneToUniqSet :: Uniquable a => UniqSet a -> a -> UniqSet a
addListToUniqSet :: Uniquable a => UniqSet a -> [a] -> UniqSet a
delOneFromUniqSet :: Uniquable a => UniqSet a -> a -> UniqSet a
delOneFromUniqSet_Directly :: UniqSet a -> Unique -> UniqSet a
delListFromUniqSet :: Uniquable a => UniqSet a -> [a] -> UniqSet a
delListFromUniqSet_Directly :: UniqSet a -> [Unique] -> UniqSet a
unionUniqSets :: UniqSet a -> UniqSet a -> UniqSet a
unionManyUniqSets :: [UniqSet a] -> UniqSet a
minusUniqSet :: UniqSet a -> UniqSet a -> UniqSet a
uniqSetMinusUFM :: UniqSet key -> UniqFM key b -> UniqSet key
uniqSetMinusUDFM :: UniqSet key -> UniqDFM key b -> UniqSet key
intersectUniqSets :: UniqSet a -> UniqSet a -> UniqSet a
disjointUniqSets :: UniqSet a -> UniqSet a -> Bool
restrictUniqSetToUFM :: UniqSet key -> UniqFM key b -> UniqSet key
uniqSetAny :: (a -> Bool) -> UniqSet a -> Bool
uniqSetAll :: (a -> Bool) -> UniqSet a -> Bool
elementOfUniqSet :: Uniquable a => a -> UniqSet a -> Bool
elemUniqSet_Directly :: Unique -> UniqSet a -> Bool
filterUniqSet :: (a -> Bool) -> UniqSet a -> UniqSet a
filterUniqSet_Directly :: (Unique -> elt -> Bool) -> UniqSet elt -> UniqSet elt
sizeUniqSet :: UniqSet a -> Int
isEmptyUniqSet :: UniqSet a -> Bool

-- | What's the point you might ask? We might have changed an object
--   without it's key changing. In which case this lookup makes sense.
lookupUniqSet :: Uniquable key => UniqSet key -> key -> Maybe key
lookupUniqSet_Directly :: UniqSet a -> Unique -> Maybe a
partitionUniqSet :: (a -> Bool) -> UniqSet a -> (UniqSet a, UniqSet a)
mapUniqSet :: Uniquable b => (a -> b) -> UniqSet a -> UniqSet b

-- | <a>unsafeUFMToUniqSet</a> converts a <tt><a>UniqFM</a> a</tt> into a
--   <tt><a>UniqSet</a> a</tt> assuming, without checking, that it maps
--   each <a>Unique</a> to a value that has that <a>Unique</a>. See Note
--   [UniqSet invariant].
unsafeUFMToUniqSet :: UniqFM a a -> UniqSet a
nonDetEltsUniqSet :: UniqSet elt -> [elt]
nonDetKeysUniqSet :: UniqSet elt -> [Unique]
nonDetStrictFoldUniqSet :: (elt -> a -> a) -> a -> UniqSet elt -> a
instance GHC.Base.Monoid (GHC.Types.Unique.Set.UniqSet a)
instance GHC.Base.Semigroup (GHC.Types.Unique.Set.UniqSet a)
instance Data.Data.Data a => Data.Data.Data (GHC.Types.Unique.Set.UniqSet a)
instance GHC.Classes.Eq (GHC.Types.Unique.Set.UniqSet a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.Set.UniqSet a)


-- | The home unit is the unit (i.e. compiled package) that contains the
--   module we are compiling/typechecking.
module GHC.Unit.Home

-- | Information about the home unit (i.e., the until that will contain the
--   modules we are compiling)
--   
--   The unit identifier of the instantiating units is left open to allow
--   switching from UnitKey (what is provided by the user) to UnitId
--   (internal unit identifier) with <a>homeUnitMap</a>.
--   
--   TODO: this isn't implemented yet. UnitKeys are still converted too
--   early into UnitIds in GHC.Unit.State.readUnitDataBase
data GenHomeUnit u

-- | Definite home unit (i.e. that we can compile).
--   
--   Nothing: not an instantiated unit Just (i,insts): made definite by
--   instantiating "i" with "insts"
DefiniteHomeUnit :: UnitId -> Maybe (u, GenInstantiations u) -> GenHomeUnit u

-- | Indefinite home unit (i.e. that we can only typecheck)
--   
--   All the holes are instantiated with fake modules from the Hole unit.
--   See Note [Representation of module/name variables] in <a>GHC.Unit</a>
IndefiniteHomeUnit :: UnitId -> GenInstantiations u -> GenHomeUnit u
type HomeUnit = GenHomeUnit UnitId

-- | Return home unit id
homeUnitId :: GenHomeUnit u -> UnitId

-- | Return home unit instantiations
homeUnitInstantiations :: GenHomeUnit u -> GenInstantiations u

-- | Return the unit id of the unit that is instantiated by the home unit.
--   
--   E.g. if home unit = q[A=p:B,...] we return q.
--   
--   If the home unit is not an instance of another unit, we return its own
--   unit id (it is an instance of itself if you will).
homeUnitInstanceOf :: HomeUnit -> UnitId

-- | Return the unit id of the unit that is instantiated by the home unit.
--   
--   E.g. if home unit = q[A=p:B,...] we return (Just q).
--   
--   If the home unit is not an instance of another unit, we return
--   Nothing.
homeUnitInstanceOfMaybe :: GenHomeUnit u -> Maybe u

-- | Return the home unit as a normal unit.
--   
--   We infer from the home unit itself the kind of unit we create: 1. If
--   the home unit is definite, we must be compiling so we return a real
--   unit. The definite home unit may be the result of a unit
--   instantiation, say `p = q[A=r:X]`. In this case we could have returned
--   a virtual unit `q[A=r:X]` but it's not what the clients of this
--   function expect, especially because <tt>p</tt> is lost when we do
--   this. The unit id of a virtual unit is made up internally so
--   `unitId(q[A=r:X])` is not equal to <tt>p</tt>.
--   
--   <ol>
--   <li>If the home unit is indefinite we can only create a virtual unit
--   from it. It's ok because we must be only typechecking the home unit so
--   we won't produce any code object that rely on the unit id of this
--   virtual unit.</li>
--   </ol>
homeUnitAsUnit :: HomeUnit -> Unit

-- | Map over the unit identifier for instantiating units
homeUnitMap :: IsUnitId v => (u -> v) -> GenHomeUnit u -> GenHomeUnit v

-- | Test if we are type-checking an indefinite unit
--   
--   (if it is not, we should never use on-the-fly renaming)
isHomeUnitIndefinite :: GenHomeUnit u -> Bool

-- | Test if we are compiling a definite unit
--   
--   (if it is, we should never use on-the-fly renaming)
isHomeUnitDefinite :: GenHomeUnit u -> Bool

-- | Test if we are compiling by instantiating a definite unit
isHomeUnitInstantiating :: GenHomeUnit u -> Bool

-- | Test if the unit is the home unit
isHomeUnit :: HomeUnit -> Unit -> Bool

-- | Test if the unit-id is the home unit-id
isHomeUnitId :: GenHomeUnit u -> UnitId -> Bool

-- | Test if the home unit is an instance of the given unit-id
isHomeUnitInstanceOf :: HomeUnit -> UnitId -> Bool

-- | Test if the module comes from the home unit
isHomeModule :: HomeUnit -> Module -> Bool

-- | Test if the module comes from the home unit
isHomeInstalledModule :: GenHomeUnit u -> InstalledModule -> Bool

-- | Test if a module doesn't come from the given home unit
notHomeModule :: HomeUnit -> Module -> Bool

-- | Test if a module doesn't come from the given home unit
notHomeModuleMaybe :: Maybe HomeUnit -> Module -> Bool

-- | Test if a module doesn't come from the given home unit
notHomeInstalledModule :: GenHomeUnit u -> InstalledModule -> Bool

-- | Test if a module doesn't come from the given home unit
notHomeInstalledModuleMaybe :: Maybe (GenHomeUnit u) -> InstalledModule -> Bool

-- | Make a module in home unit
mkHomeModule :: HomeUnit -> ModuleName -> Module

-- | Make a module in home unit
mkHomeInstalledModule :: GenHomeUnit u -> ModuleName -> InstalledModule

-- | Return the module that is used to instantiate the given home module.
--   
--   If the given module isn't a module hole, return the actual home
--   module.
--   
--   E.g., the instantiating module of <tt>p:A</tt> in <tt>p[A=q[]:B]</tt>
--   is <tt>q[]:B</tt>. the instantiating module of <tt>r:A</tt> in
--   <tt>p[A=q[]:B]</tt> is <tt>r:A</tt>. the instantiating module of
--   <tt>p:A</tt> in <tt>p</tt> is <tt>p:A</tt>. the instantiating module
--   of <tt>r:A</tt> in <tt>p</tt> is <tt>r:A</tt>.
homeModuleInstantiation :: HomeUnit -> Module -> Module

-- | Return the module that is used to instantiate the given home module
--   name. If the ModuleName doesn't refer to a signature, return the
--   actual home module.
--   
--   E.g., the instantiating module of <tt>A</tt> in <tt>p[A=q[]:B]</tt> is
--   <tt>q[]:B</tt>. the instantiating module of <tt>A</tt> in <tt>p</tt>
--   is <tt>p:A</tt>.
homeModuleNameInstantiation :: HomeUnit -> ModuleName -> Module


-- | A global typecheckable-thing, essentially anything that has a name.
module GHC.Types.TyThing

-- | A global typecheckable-thing, essentially anything that has a name.
--   Not to be confused with a <tt>TcTyThing</tt>, which is also a
--   typecheckable thing but in the *local* context. See
--   <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a> given a
--   <a>Name</a>.
data TyThing
AnId :: Id -> TyThing
AConLike :: ConLike -> TyThing
ATyCon :: TyCon -> TyThing
ACoAxiom :: CoAxiom Branched -> TyThing

-- | Class that abstracts out the common ability of the monads in GHC to
--   lookup a <a>TyThing</a> in the monadic environment by <a>Name</a>.
--   Provides a number of related convenience functions for accessing
--   particular kinds of <a>TyThing</a>
class Monad m => MonadThings m
lookupThing :: MonadThings m => Name -> m TyThing
lookupId :: MonadThings m => Name -> m Id
lookupDataCon :: MonadThings m => Name -> m DataCon
lookupTyCon :: MonadThings m => Name -> m TyCon
mkATyCon :: TyCon -> TyThing
mkAnId :: Id -> TyThing
pprShortTyThing :: TyThing -> SDoc
pprTyThingCategory :: TyThing -> SDoc
tyThingCategory :: TyThing -> String

-- | Determine the <a>TyThing</a>s brought into scope by another
--   <a>TyThing</a> <i>other</i> than itself. For example, Id's don't have
--   any implicit TyThings as they just bring themselves into scope, but
--   classes bring their dictionary datatype, type constructor and some
--   selector functions into scope, just for a start!
implicitTyThings :: TyThing -> [TyThing]
implicitConLikeThings :: ConLike -> [TyThing]
implicitClassThings :: Class -> [TyThing]
implicitTyConThings :: TyCon -> [TyThing]
implicitCoTyCon :: TyCon -> [TyThing]

-- | Returns <tt>True</tt> if there should be no interface-file declaration
--   for this thing on its own: either it is built-in, or it is part of
--   some other declaration, or it is generated implicitly by some other
--   declaration.
isImplicitTyThing :: TyThing -> Bool

-- | tyThingParent_maybe x returns (Just p) when pprTyThingInContext should
--   print a declaration for p (albeit with some "..." in it) when asked to
--   show x It returns the *immediate* parent. So a datacon returns its
--   tycon but the tycon could be the associated type of a class, so it in
--   turn might have a parent.
tyThingParent_maybe :: TyThing -> Maybe TyThing
tyThingsTyCoVars :: [TyThing] -> TyCoVarSet

-- | The Names that a TyThing should bring into scope. Used to build the
--   GlobalRdrEnv for the InteractiveContext.
tyThingAvailInfo :: TyThing -> [AvailInfo]

-- | Get the <a>TyCon</a> from a <a>TyThing</a> if it is a type constructor
--   thing. Panics otherwise
tyThingTyCon :: HasDebugCallStack => TyThing -> TyCon

-- | Get the <a>CoAxiom</a> from a <a>TyThing</a> if it is a coercion axiom
--   thing. Panics otherwise
tyThingCoAxiom :: HasDebugCallStack => TyThing -> CoAxiom Branched

-- | Get the <a>DataCon</a> from a <a>TyThing</a> if it is a data
--   constructor thing. Panics otherwise
tyThingDataCon :: HasDebugCallStack => TyThing -> DataCon

-- | Get the <a>ConLike</a> from a <a>TyThing</a> if it is a data
--   constructor thing. Panics otherwise
tyThingConLike :: HasDebugCallStack => TyThing -> ConLike

-- | Get the <a>Id</a> from a <a>TyThing</a> if it is a id *or* data
--   constructor thing. Panics otherwise
tyThingId :: HasDebugCallStack => TyThing -> Id
instance GHC.Types.TyThing.MonadThings m => GHC.Types.TyThing.MonadThings (Control.Monad.Trans.Reader.ReaderT s m)
instance GHC.Utils.Outputable.Outputable GHC.Types.TyThing.TyThing
instance GHC.Types.Name.NamedThing GHC.Types.TyThing.TyThing

module GHC.Types.Var.Set

-- | A non-deterministic Variable Set
--   
--   A non-deterministic set of variables. See Note [Deterministic UniqFM]
--   in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DVarSet if the set eventually
--   gets converted into a list or folded over in a way where the order
--   changes the generated code, for example when abstracting variables.
type VarSet = UniqSet Var

-- | Identifier Set
type IdSet = UniqSet Id

-- | Type Variable Set
type TyVarSet = UniqSet TyVar

-- | Coercion Variable Set
type CoVarSet = UniqSet CoVar

-- | Type or Coercion Variable Set
type TyCoVarSet = UniqSet TyCoVar
emptyVarSet :: VarSet
unitVarSet :: Var -> VarSet
mkVarSet :: [Var] -> VarSet
extendVarSet :: VarSet -> Var -> VarSet
extendVarSetList :: VarSet -> [Var] -> VarSet
elemVarSet :: Var -> VarSet -> Bool
subVarSet :: VarSet -> VarSet -> Bool
unionVarSet :: VarSet -> VarSet -> VarSet
unionVarSets :: [VarSet] -> VarSet

-- | map the function over the list, and union the results
mapUnionVarSet :: (a -> VarSet) -> [a] -> VarSet
intersectVarSet :: VarSet -> VarSet -> VarSet
intersectsVarSet :: VarSet -> VarSet -> Bool
disjointVarSet :: VarSet -> VarSet -> Bool
isEmptyVarSet :: VarSet -> Bool
delVarSet :: VarSet -> Var -> VarSet
delVarSetList :: VarSet -> [Var] -> VarSet
delVarSetByKey :: VarSet -> Unique -> VarSet
minusVarSet :: VarSet -> VarSet -> VarSet
filterVarSet :: (Var -> Bool) -> VarSet -> VarSet
mapVarSet :: Uniquable b => (a -> b) -> UniqSet a -> UniqSet b
anyVarSet :: (Var -> Bool) -> VarSet -> Bool
allVarSet :: (Var -> Bool) -> VarSet -> Bool
transCloVarSet :: (VarSet -> VarSet) -> VarSet -> VarSet
fixVarSet :: (VarSet -> VarSet) -> VarSet -> VarSet
lookupVarSet_Directly :: VarSet -> Unique -> Maybe Var
lookupVarSet :: VarSet -> Var -> Maybe Var
lookupVarSetByName :: VarSet -> Name -> Maybe Var
sizeVarSet :: VarSet -> Int
seqVarSet :: VarSet -> ()
elemVarSetByKey :: Unique -> VarSet -> Bool
partitionVarSet :: (Var -> Bool) -> VarSet -> (VarSet, VarSet)

-- | Determines the pluralisation suffix appropriate for the length of a
--   set in the same way that plural from Outputable does for lists.
pluralVarSet :: VarSet -> SDoc

-- | Pretty-print a non-deterministic set. The order of variables is
--   non-deterministic and for pretty-printing that shouldn't be a problem.
--   Having this function helps contain the non-determinism created with
--   nonDetEltsUFM. Passing a list to the pretty-printing function allows
--   the caller to decide on the order of Vars (eg. toposort them) without
--   them having to use nonDetEltsUFM at the call site. This prevents from
--   let-binding non-deterministically ordered lists and reusing them where
--   determinism matters.
pprVarSet :: VarSet -> ([Var] -> SDoc) -> SDoc
nonDetStrictFoldVarSet :: (Var -> a -> a) -> a -> VarSet -> a

-- | Deterministic Variable Set
type DVarSet = UniqDSet Var

-- | Deterministic Identifier Set
type DIdSet = UniqDSet Id

-- | Deterministic Type Variable Set
type DTyVarSet = UniqDSet TyVar

-- | Deterministic Type or Coercion Variable Set
type DTyCoVarSet = UniqDSet TyCoVar
emptyDVarSet :: DVarSet
unitDVarSet :: Var -> DVarSet
mkDVarSet :: [Var] -> DVarSet
extendDVarSet :: DVarSet -> Var -> DVarSet

-- | Add a list of variables to DVarSet
extendDVarSetList :: DVarSet -> [Var] -> DVarSet
elemDVarSet :: Var -> DVarSet -> Bool
dVarSetElems :: DVarSet -> [Var]
subDVarSet :: DVarSet -> DVarSet -> Bool
unionDVarSet :: DVarSet -> DVarSet -> DVarSet
unionDVarSets :: [DVarSet] -> DVarSet

-- | Map the function over the list, and union the results
mapUnionDVarSet :: (a -> DVarSet) -> [a] -> DVarSet
intersectDVarSet :: DVarSet -> DVarSet -> DVarSet
dVarSetIntersectVarSet :: DVarSet -> VarSet -> DVarSet

-- | True if non-empty intersection
intersectsDVarSet :: DVarSet -> DVarSet -> Bool

-- | True if empty intersection
disjointDVarSet :: DVarSet -> DVarSet -> Bool
isEmptyDVarSet :: DVarSet -> Bool
delDVarSet :: DVarSet -> Var -> DVarSet

-- | Delete a list of variables from DVarSet
delDVarSetList :: DVarSet -> [Var] -> DVarSet
minusDVarSet :: DVarSet -> DVarSet -> DVarSet
nonDetStrictFoldDVarSet :: (Var -> a -> a) -> a -> DVarSet -> a
filterDVarSet :: (Var -> Bool) -> DVarSet -> DVarSet
mapDVarSet :: Uniquable b => (a -> b) -> UniqDSet a -> UniqDSet b
dVarSetMinusVarSet :: DVarSet -> VarSet -> DVarSet
anyDVarSet :: (Var -> Bool) -> DVarSet -> Bool
allDVarSet :: (Var -> Bool) -> DVarSet -> Bool

-- | transCloVarSet for DVarSet
transCloDVarSet :: (DVarSet -> DVarSet) -> DVarSet -> DVarSet
sizeDVarSet :: DVarSet -> Int
seqDVarSet :: DVarSet -> ()

-- | Partition DVarSet according to the predicate given
partitionDVarSet :: (Var -> Bool) -> DVarSet -> (DVarSet, DVarSet)

-- | Convert a DVarSet to a VarSet by forgetting the order of insertion
dVarSetToVarSet :: DVarSet -> VarSet


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see
--   <a>GHC.Types.Name.Occurrence#name_types</a></li>
--   <li><a>RdrName</a>: see <a>GHC.Types.Name.Reader#name_types</a></li>
--   <li><a>Name</a>: see <a>GHC.Types.Name#name_types</a></li>
--   <li><a>Id</a>: see <a>GHC.Types.Id#name_types</a></li>
--   <li><a>Var</a> is a synonym for the <a>Id</a> type but it may
--   additionally potentially contain type variables, which have a
--   <a>Kind</a> rather than a <a>Type</a> and only contain some extra
--   details during typechecking.</li>
--   </ul>
--   
--   These <a>Var</a> names may either be global or local, see
--   <a>GHC.Types.Var#globalvslocal</a>
--   
--   Global <a>Var</a>s and <a>Var</a>s are those that are imported or
--   correspond to a data constructor, primitive operation, or record
--   selectors. Local <a>Var</a>s and <a>Var</a>s are those bound within an
--   expression (e.g. by a lambda) or at the top level of the module being
--   compiled.
module GHC.Types.Var

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Coercion Variable
type CoVar = Id

-- | Identifier
type Id = Var

type NcId = Id

-- | Dictionary Identifier
type DictId = EvId

-- | Dictionary Function Identifier
type DFunId = Id

-- | Evidence Variable
type EvVar = EvId

-- | Equality Variable
type EqVar = EvId

-- | Evidence Identifier
type EvId = Id

-- | Implicit parameter Identifier
type IpId = EvId
type JoinId = Id

-- | Type or kind Variable
type TyVar = Var

-- | Type variable that might be a metavariable
type TcTyVar = Var

-- | Type Variable
type TypeVar = Var

-- | Kind Variable
type KindVar = Var

-- | Type or Kind Variable
type TKVar = Var

-- | Type or Coercion Variable
type TyCoVar = Id
type InVar = Var
type InCoVar = CoVar
type InId = Id
type InTyVar = TyVar
type OutVar = Var
type OutCoVar = CoVar
type OutId = Id
type OutTyVar = TyVar
varName :: Var -> Name
varUnique :: Var -> Unique

-- | The type or kind of the <a>Var</a> in question
varType :: Var -> Kind
varMult :: Var -> Mult
varMultMaybe :: Id -> Maybe Mult
setVarName :: Var -> Name -> Var
setVarUnique :: Var -> Unique -> Var
setVarType :: Var -> Type -> Var

-- | Update a <a>Var</a>s type. Does not update the <i>multiplicity</i>
--   stored in an <a>Var</a>, if any. Because of the possibility for abuse,
--   ASSERTs that there is no multiplicity to update.
updateVarType :: (Type -> Type) -> Var -> Var

-- | Update a <a>Var</a>s type monadically. Does not update the
--   <i>multiplicity</i> stored in an <a>Var</a>, if any. Because of the
--   possibility for abuse, ASSERTs that there is no multiplicity to
--   update.
updateVarTypeM :: Monad m => (Type -> m Type) -> Var -> m Var
mkGlobalVar :: IdDetails -> Name -> Type -> IdInfo -> Id
mkLocalVar :: IdDetails -> Name -> Mult -> Type -> IdInfo -> Id

-- | Exported <a>Var</a>s will not be removed as dead code
mkExportedLocalVar :: IdDetails -> Name -> Type -> IdInfo -> Id
mkCoVar :: Name -> Type -> CoVar
idInfo :: HasDebugCallStack => Id -> IdInfo
idDetails :: Id -> IdDetails
lazySetIdInfo :: Id -> IdInfo -> Var
setIdDetails :: Id -> IdDetails -> Id

-- | If it's a local, make it global
globaliseId :: Id -> Id

-- | Exports the given local <a>Var</a>. Can also be called on global
--   <a>Var</a>s, such as data constructors and class operations, which are
--   born as global <a>Var</a>s and automatically exported
setIdExported :: Id -> Id

-- | We can only do this to LocalIds
setIdNotExported :: Id -> Id
setIdMult :: Id -> Mult -> Id
updateIdTypeButNotMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMultM :: Monad m => (Type -> m Type) -> Id -> m Id

-- | Is this a value-level (i.e., computationally relevant)
--   <a>Var</a>entifier? Satisfies <tt>isId = not . isTyVar</tt>.
isId :: Var -> Bool

-- | Is this a type-level (i.e., computationally irrelevant, thus erasable)
--   variable? Satisfies <tt>isTyVar = not . isId</tt>.
isTyVar :: Var -> Bool
isTcTyVar :: Var -> Bool

-- | <a>isLocalVar</a> returns <tt>True</tt> for type variables as well as
--   local <a>Var</a>s These are the variables that we need to pay
--   attention to when finding free variables, or doing dependency
--   analysis.
isLocalVar :: Var -> Bool
isLocalId :: Var -> Bool

-- | Is this a coercion variable? Satisfies <tt><a>isId</a> v ==&gt;
--   <a>isCoVar</a> v == not (<a>isNonCoVarId</a> v)</tt>.
isCoVar :: Var -> Bool

-- | Is this a term variable (<a>Var</a>) that is <i>not</i> a coercion
--   variable? Satisfies <tt><a>isId</a> v ==&gt; <a>isCoVar</a> v == not
--   (<a>isNonCoVarId</a> v)</tt>.
isNonCoVarId :: Var -> Bool
isTyCoVar :: Var -> Bool
isGlobalId :: Var -> Bool

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool

-- | <a>mustHaveLocalBinding</a> returns <tt>True</tt> of <a>Var</a>s and
--   <a>Var</a>s that must have a binding in this module. The converse is
--   not quite right: there are some global <a>Var</a>s that must have
--   bindings, such as record selectors. But that doesn't matter, because
--   it's only used for assertions
mustHaveLocalBinding :: Var -> Bool

-- | Argument Flag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, TyCoVarBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ArgFlag
Invisible :: Specificity -> ArgFlag
Required :: ArgFlag
pattern Specified :: ArgFlag
pattern Inferred :: ArgFlag

-- | The non-dependent version of <a>ArgFlag</a>. See Note [AnonArgFlag]
--   Appears here partly so that it's together with its friends ArgFlag and
--   ForallVisFlag, but also because it is used in IfaceType, rather early
--   in the compilation chain
data AnonArgFlag

-- | Used for <tt>(-&gt;)</tt>: an ordinary non-dependent arrow. The
--   argument is visible in source code.
VisArg :: AnonArgFlag

-- | Used for <tt>(=&gt;)</tt>: a non-dependent predicate arrow. The
--   argument is invisible in source code.
InvisArg :: AnonArgFlag

-- | Whether an <a>Invisible</a> argument may appear in source Haskell.
data Specificity

-- | the argument may not appear in source Haskell, it is only inferred.
InferredSpec :: Specificity

-- | the argument may appear in source Haskell, but isn't required.
SpecifiedSpec :: Specificity

-- | Does this <a>ArgFlag</a> classify an argument that is written in
--   Haskell?
isVisibleArgFlag :: ArgFlag -> Bool

-- | Does this <a>ArgFlag</a> classify an argument that is not written in
--   Haskell?
isInvisibleArgFlag :: ArgFlag -> Bool
isInferredArgFlag :: ArgFlag -> Bool

-- | Do these denote the same level of visibility? <a>Required</a>
--   arguments are visible, others are not. So this function equates
--   <a>Specified</a> and <a>Inferred</a>. Used for printing.
sameVis :: ArgFlag -> ArgFlag -> Bool
data VarBndr var argf
Bndr :: var -> argf -> VarBndr var argf

-- | Variable Binder
--   
--   A <a>TyCoVarBinder</a> is the binder of a ForAllTy It's convenient to
--   define this synonym here rather its natural home in
--   <a>GHC.Core.TyCo.Rep</a>, because it's used in
--   GHC.Core.DataCon.hs-boot
--   
--   A <a>TyVarBinder</a> is a binder with only TyVar
type TyCoVarBinder = VarBndr TyCoVar ArgFlag
type TyVarBinder = VarBndr TyVar ArgFlag
type InvisTVBinder = VarBndr TyVar Specificity
type ReqTVBinder = VarBndr TyVar ()
binderVar :: VarBndr tv argf -> tv
binderVars :: [VarBndr tv argf] -> [tv]
binderArgFlag :: VarBndr tv argf -> argf
binderType :: VarBndr TyCoVar argf -> Type

-- | Make a named binder
mkTyCoVarBinder :: vis -> TyCoVar -> VarBndr TyCoVar vis

-- | Make many named binders
mkTyCoVarBinders :: vis -> [TyCoVar] -> [VarBndr TyCoVar vis]

-- | Make a named binder <tt>var</tt> should be a type variable
mkTyVarBinder :: vis -> TyVar -> VarBndr TyVar vis

-- | Make many named binders Input vars should be type variables
mkTyVarBinders :: vis -> [TyVar] -> [VarBndr TyVar vis]
isTyVarBinder :: TyCoVarBinder -> Bool
tyVarSpecToBinder :: VarBndr a Specificity -> VarBndr a ArgFlag
tyVarSpecToBinders :: [VarBndr a Specificity] -> [VarBndr a ArgFlag]
tyVarReqToBinder :: VarBndr a () -> VarBndr a ArgFlag
tyVarReqToBinders :: [VarBndr a ()] -> [VarBndr a ArgFlag]
mapVarBndr :: (var -> var') -> VarBndr var flag -> VarBndr var' flag
mapVarBndrs :: (var -> var') -> [VarBndr var flag] -> [VarBndr var' flag]
lookupVarBndr :: Eq var => var -> [VarBndr var flag] -> Maybe flag
mkTyVar :: Name -> Kind -> TyVar
mkTcTyVar :: Name -> Kind -> TcTyVarDetails -> TyVar
tyVarName :: TyVar -> Name
tyVarKind :: TyVar -> Kind
tcTyVarDetails :: TyVar -> TcTyVarDetails
setTcTyVarDetails :: TyVar -> TcTyVarDetails -> TyVar
setTyVarName :: TyVar -> Name -> TyVar
setTyVarUnique :: TyVar -> Unique -> TyVar
setTyVarKind :: TyVar -> Kind -> TyVar
updateTyVarKind :: (Kind -> Kind) -> TyVar -> TyVar
updateTyVarKindM :: Monad m => (Kind -> m Kind) -> TyVar -> m TyVar

-- | Compare Vars by their Uniques. This is what Ord Var does, provided
--   here to make it explicit at the call-site that it can introduce
--   non-determinism. See Note [Unique Determinism]
nonDetCmpVar :: Var -> Var -> Ordering
instance Data.Data.Data GHC.Types.Var.Specificity
instance GHC.Classes.Ord GHC.Types.Var.Specificity
instance GHC.Classes.Eq GHC.Types.Var.Specificity
instance Data.Data.Data GHC.Types.Var.ArgFlag
instance GHC.Classes.Ord GHC.Types.Var.ArgFlag
instance GHC.Classes.Eq GHC.Types.Var.ArgFlag
instance Data.Data.Data GHC.Types.Var.AnonArgFlag
instance GHC.Classes.Ord GHC.Types.Var.AnonArgFlag
instance GHC.Classes.Eq GHC.Types.Var.AnonArgFlag
instance (Data.Data.Data var, Data.Data.Data argf) => Data.Data.Data (GHC.Types.Var.VarBndr var argf)
instance GHC.Utils.Outputable.Outputable tv => GHC.Utils.Outputable.Outputable (GHC.Types.Var.VarBndr tv GHC.Types.Var.ArgFlag)
instance GHC.Utils.Outputable.Outputable tv => GHC.Utils.Outputable.Outputable (GHC.Types.Var.VarBndr tv GHC.Types.Var.Specificity)
instance (GHC.Utils.Binary.Binary tv, GHC.Utils.Binary.Binary vis) => GHC.Utils.Binary.Binary (GHC.Types.Var.VarBndr tv vis)
instance GHC.Types.Name.NamedThing tv => GHC.Types.Name.NamedThing (GHC.Types.Var.VarBndr tv flag)
instance GHC.Utils.Outputable.Outputable GHC.Types.Var.AnonArgFlag
instance GHC.Utils.Binary.Binary GHC.Types.Var.AnonArgFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Var.ArgFlag
instance GHC.Utils.Binary.Binary GHC.Types.Var.ArgFlag
instance GHC.Utils.Binary.Binary GHC.Types.Var.Specificity
instance GHC.Utils.Outputable.Outputable GHC.Types.Var.Var
instance GHC.Types.Name.NamedThing GHC.Types.Var.Var
instance GHC.Types.Unique.Uniquable GHC.Types.Var.Var
instance GHC.Classes.Eq GHC.Types.Var.Var
instance GHC.Classes.Ord GHC.Types.Var.Var
instance Data.Data.Data GHC.Types.Var.Var
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Var.Var

module GHC.Types.Id.Info

-- | Identifier Details
--   
--   The <a>IdDetails</a> of an <tt>Id</tt> give stable, and necessary,
--   information about the Id.
data IdDetails
VanillaId :: IdDetails

-- | The <tt>Id</tt> for a record selector
RecSelId :: RecSelParent -> Bool -> IdDetails
[sel_tycon] :: IdDetails -> RecSelParent
[sel_naughty] :: IdDetails -> Bool

-- | The <tt>Id</tt> is for a data constructor <i>worker</i>
DataConWorkId :: DataCon -> IdDetails

-- | The <tt>Id</tt> is for a data constructor <i>wrapper</i>
DataConWrapId :: DataCon -> IdDetails

-- | The <tt>Id</tt> is a superclass selector, or class operation of a
--   class
ClassOpId :: Class -> IdDetails

-- | The <tt>Id</tt> is for a primitive operator
PrimOpId :: PrimOp -> IdDetails

-- | The <tt>Id</tt> is for a foreign call. Type will be simple: no type
--   families, newtypes, etc
FCallId :: ForeignCall -> IdDetails

-- | The <tt>Id</tt> is for a HPC tick box (both traditional and binary)
TickBoxOpId :: TickBoxOp -> IdDetails

-- | A dictionary function. Bool = True <a>=</a> the class has only one
--   method, so may be implemented with a newtype, so it might be bad to be
--   strict on this dictionary
DFunId :: Bool -> IdDetails

-- | A coercion variable This only covers <i>un-lifted</i> coercions, of
--   type (t1 ~# t2) or (t1 ~R# t2), not their lifted variants
CoVarId :: IdDetails

-- | An <tt>Id</tt> for a join point taking n arguments Note [Join points]
--   in <a>GHC.Core</a>
JoinId :: JoinArity -> IdDetails
pprIdDetails :: IdDetails -> SDoc

-- | Just a synonym for <a>CoVarId</a>. Written separately so it can be
--   exported in the hs-boot file.
coVarDetails :: IdDetails

-- | Check if an <a>IdDetails</a> says <a>CoVarId</a>.
isCoVarDetails :: IdDetails -> Bool

-- | The number of arguments that a join point takes. Unlike the arity of a
--   function, this is a purely syntactic property and is fixed when the
--   join point is created (or converted from a value). Both type and value
--   arguments are counted.
type JoinArity = Int
isJoinIdDetails_maybe :: IdDetails -> Maybe JoinArity

-- | Recursive Selector Parent
data RecSelParent
RecSelData :: TyCon -> RecSelParent
RecSelPatSyn :: PatSyn -> RecSelParent

-- | Identifier Information
--   
--   An <a>IdInfo</a> gives <i>optional</i> information about an
--   <tt>Id</tt>. If present it never lies, but it may not be present, in
--   which case there is always a conservative assumption which can be
--   made.
--   
--   Two <tt>Id</tt>s may have different info even though they have the
--   same <tt>Unique</tt> (and are hence the same <tt>Id</tt>); for
--   example, one might lack the properties attached to the other.
--   
--   Most of the <a>IdInfo</a> gives information about the value, or
--   definition, of the <tt>Id</tt>, independent of its usage. Exceptions
--   to this are <a>demandInfo</a>, <a>occInfo</a>, <a>oneShotInfo</a> and
--   <a>callArityInfo</a>.
--   
--   Performance note: when we update <a>IdInfo</a>, we have to reallocate
--   this entire record, so it is a good idea not to let this data
--   structure get too big.
data IdInfo

-- | Basic <a>IdInfo</a> that carries no useful information whatsoever
vanillaIdInfo :: IdInfo

-- | More informative <a>IdInfo</a> we can use when we know the <tt>Id</tt>
--   has no CAF references
noCafIdInfo :: IdInfo

-- | If the <tt>Id</tt> is a lambda-bound variable then it may have
--   lambda-bound variable info. Sometimes we know whether the lambda
--   binding this variable is a "one-shot" lambda; that is, whether it is
--   applied at most once.
--   
--   This information may be useful in optimisation, as computations may
--   safely be floated inside such a lambda without risk of duplicating
--   work.
--   
--   See also Note [OneShotInfo overview] above.
data OneShotInfo

-- | No information
NoOneShotInfo :: OneShotInfo

-- | The lambda is applied at most once.
OneShotLam :: OneShotInfo

-- | Info about a lambda-bound variable, if the <tt>Id</tt> is one
oneShotInfo :: IdInfo -> OneShotInfo

-- | It is always safe to assume that an <tt>Id</tt> has no lambda-bound
--   variable information
noOneShotInfo :: OneShotInfo
hasNoOneShotInfo :: OneShotInfo -> Bool
setOneShotInfo :: IdInfo -> OneShotInfo -> IdInfo
infixl 1 `setOneShotInfo`

-- | This is used to remove information on lambda binders that we have
--   setup as part of a lambda group, assuming they will be applied all at
--   once, but turn out to be part of an unsaturated lambda as in e.g:
--   
--   <pre>
--   (\x1. \x2. e) arg1
--   </pre>
zapLamInfo :: IdInfo -> Maybe IdInfo

-- | Zap info that depends on free variables
zapFragileInfo :: IdInfo -> Maybe IdInfo

-- | Remove all demand info on the <a>IdInfo</a>
zapDemandInfo :: IdInfo -> Maybe IdInfo

-- | Remove usage (but not strictness) info on the <a>IdInfo</a>
zapUsageInfo :: IdInfo -> Maybe IdInfo

-- | Remove usage environment info from the strictness signature on the
--   <a>IdInfo</a>
zapUsageEnvInfo :: IdInfo -> Maybe IdInfo
zapUsedOnceInfo :: IdInfo -> Maybe IdInfo
zapTailCallInfo :: IdInfo -> Maybe IdInfo
zapCallArityInfo :: IdInfo -> IdInfo
zapUnfolding :: Unfolding -> Unfolding

-- | Arity Information
--   
--   An <a>ArityInfo</a> of <tt>n</tt> tells us that partial application of
--   this <tt>Id</tt> to up to <tt>n-1</tt> value arguments does
--   essentially no work.
--   
--   That is not necessarily the same as saying that it has <tt>n</tt>
--   leading lambdas, because coerces may get in the way.
--   
--   The arity might increase later in the compilation process, if an extra
--   lambda floats up to the binding site.
type ArityInfo = Arity

-- | It is always safe to assume that an <tt>Id</tt> has an arity of 0
unknownArity :: Arity

-- | <tt>Id</tt> arity, as computed by <a>GHC.Core.Opt.Arity</a>. Specifies
--   how many arguments this <tt>Id</tt> has to be applied to before it
--   doesn any meaningful work.
arityInfo :: IdInfo -> ArityInfo
setArityInfo :: IdInfo -> ArityInfo -> IdInfo
infixl 1 `setArityInfo`
ppArityInfo :: Int -> SDoc

-- | How this is called. This is the number of arguments to which a binding
--   can be eta-expanded without losing any sharing. n <a>=</a> all calls
--   have at least n arguments
callArityInfo :: IdInfo -> ArityInfo
setCallArityInfo :: IdInfo -> ArityInfo -> IdInfo

-- | A strictness signature. Digests how a function uses its arguments if
--   applied to at least <a>arityInfo</a> arguments.
strictnessInfo :: IdInfo -> StrictSig
setStrictnessInfo :: IdInfo -> StrictSig -> IdInfo
infixl 1 `setStrictnessInfo`

-- | Information on whether the function will ultimately return a freshly
--   allocated constructor.
cprInfo :: IdInfo -> CprSig
setCprInfo :: IdInfo -> CprSig -> IdInfo
infixl 1 `setCprInfo`

-- | ID demand information
demandInfo :: IdInfo -> Demand
setDemandInfo :: IdInfo -> Demand -> IdInfo
infixl 1 `setDemandInfo`
pprStrictness :: StrictSig -> SDoc

-- | The <tt>Id</tt>s unfolding
unfoldingInfo :: IdInfo -> Unfolding
setUnfoldingInfo :: IdInfo -> Unfolding -> IdInfo
infixl 1 `setUnfoldingInfo`

-- | Inline Pragma Information
--   
--   Tells when the inlining is active. When it is active the thing may be
--   inlined, depending on how big it is.
--   
--   If there was an <tt>INLINE</tt> pragma, then as a separate matter, the
--   RHS will have been made to look small with a Core inline <tt>Note</tt>
--   
--   The default <a>InlinePragInfo</a> is <a>AlwaysActive</a>, so the info
--   serves entirely as a way to inhibit inlining until we want it
type InlinePragInfo = InlinePragma

-- | Any inline pragma attached to the <tt>Id</tt>
inlinePragInfo :: IdInfo -> InlinePragma
setInlinePragInfo :: IdInfo -> InlinePragma -> IdInfo
infixl 1 `setInlinePragInfo`

-- | identifier Occurrence Information
data OccInfo

-- | There are many occurrences, or unknown occurrences
ManyOccs :: !TailCallInfo -> OccInfo
[occ_tail] :: OccInfo -> !TailCallInfo

-- | Marks unused variables. Sometimes useful for lambda and case-bound
--   variables.
IAmDead :: OccInfo

-- | Occurs exactly once (per branch), not inside a rule
OneOcc :: !InsideLam -> {-# UNPACK #-} !BranchCount -> !InterestingCxt -> !TailCallInfo -> OccInfo
[occ_in_lam] :: OccInfo -> !InsideLam
[occ_n_br] :: OccInfo -> {-# UNPACK #-} !BranchCount
[occ_int_cxt] :: OccInfo -> !InterestingCxt
[occ_tail] :: OccInfo -> !TailCallInfo

-- | This identifier breaks a loop of mutually recursive functions. The
--   field marks whether it is only a loop breaker due to a reference in a
--   rule
IAmALoopBreaker :: !RulesOnly -> !TailCallInfo -> OccInfo
[occ_rules_only] :: OccInfo -> !RulesOnly
[occ_tail] :: OccInfo -> !TailCallInfo
isDeadOcc :: OccInfo -> Bool
isStrongLoopBreaker :: OccInfo -> Bool
isWeakLoopBreaker :: OccInfo -> Bool

-- | How the <tt>Id</tt> occurs in the program
occInfo :: IdInfo -> OccInfo
setOccInfo :: IdInfo -> OccInfo -> IdInfo
infixl 1 `setOccInfo`

-- | Inside Lambda
data InsideLam

-- | Occurs inside a non-linear lambda Substituting a redex for this
--   occurrence is dangerous because it might duplicate work.
IsInsideLam :: InsideLam
NotInsideLam :: InsideLam
type BranchCount = Int
data TailCallInfo
AlwaysTailCalled :: JoinArity -> TailCallInfo
NoTailCallInfo :: TailCallInfo
tailCallInfo :: OccInfo -> TailCallInfo
isAlwaysTailCalled :: OccInfo -> Bool

-- | Rule Information
--   
--   Records the specializations of this <tt>Id</tt> that we know about in
--   the form of rewrite <a>CoreRule</a>s that target them
data RuleInfo
RuleInfo :: [CoreRule] -> DVarSet -> RuleInfo

-- | Assume that no specializations exist: always safe
emptyRuleInfo :: RuleInfo
isEmptyRuleInfo :: RuleInfo -> Bool

-- | Retrieve the locally-defined free variables of both the left and right
--   hand sides of the specialization rules
ruleInfoFreeVars :: RuleInfo -> DVarSet
ruleInfoRules :: RuleInfo -> [CoreRule]

-- | Change the name of the function the rule is keyed on all of the
--   <a>CoreRule</a>s
setRuleInfoHead :: Name -> RuleInfo -> RuleInfo

-- | Specialisations of the <tt>Id</tt>s function which exist. See Note
--   [Specialisations and RULES in IdInfo]
ruleInfo :: IdInfo -> RuleInfo
setRuleInfo :: IdInfo -> RuleInfo -> IdInfo
infixl 1 `setRuleInfo`

-- | Constant applicative form Information
--   
--   Records whether an <tt>Id</tt> makes Constant Applicative Form
--   references
data CafInfo

-- | Indicates that the <tt>Id</tt> is for either:
--   
--   <ol>
--   <li>A function or static constructor that refers to one or more CAFs,
--   or</li>
--   <li>A real live CAF</li>
--   </ol>
MayHaveCafRefs :: CafInfo

-- | A function or static constructor that refers to no CAFs.
NoCafRefs :: CafInfo
ppCafInfo :: CafInfo -> SDoc
mayHaveCafRefs :: CafInfo -> Bool

-- | <tt>Id</tt> CAF info
cafInfo :: IdInfo -> CafInfo
setCafInfo :: IdInfo -> CafInfo -> IdInfo
infixl 1 `setCafInfo`

-- | Information about an identifier, from the code generator's point of
--   view. Every identifier is bound to a LambdaFormInfo in the
--   environment, which gives the code generator enough info to be able to
--   tail call or return that identifier.
data LambdaFormInfo
LFReEntrant :: !TopLevelFlag -> !RepArity -> !Bool -> !ArgDescr -> LambdaFormInfo
LFThunk :: !TopLevelFlag -> !Bool -> !Bool -> !StandardFormInfo -> !Bool -> LambdaFormInfo
LFCon :: !DataCon -> LambdaFormInfo
LFUnknown :: !Bool -> LambdaFormInfo
LFUnlifted :: LambdaFormInfo
LFLetNoEscape :: LambdaFormInfo
lfInfo :: IdInfo -> Maybe LambdaFormInfo
setLFInfo :: IdInfo -> LambdaFormInfo -> IdInfo

-- | Tick box for Hpc-style coverage
data TickBoxOp
TickBox :: Module -> {-# UNPACK #-} !TickBoxId -> TickBoxOp
type TickBoxId = Int
data LevityInfo

-- | When applied, will this Id ever have a levity-polymorphic type?
levityInfo :: IdInfo -> LevityInfo

-- | Marks an IdInfo describing an Id that is never levity polymorphic
--   (even when applied). The Type is only there for checking that it's
--   really never levity polymorphic
setNeverLevPoly :: HasDebugCallStack => IdInfo -> Type -> IdInfo
infixl 1 `setNeverLevPoly`
setLevityInfoWithType :: IdInfo -> Type -> IdInfo
infixl 1 `setLevityInfoWithType`
isNeverLevPolyIdInfo :: IdInfo -> Bool
instance GHC.Classes.Eq GHC.Types.Id.Info.RecSelParent
instance GHC.Classes.Ord GHC.Types.Id.Info.CafInfo
instance GHC.Classes.Eq GHC.Types.Id.Info.CafInfo
instance GHC.Classes.Eq GHC.Types.Id.Info.LevityInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.LevityInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.IdDetails
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.TickBoxOp
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.CafInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.RecSelParent

module GHC.Types.ForeignCall
newtype ForeignCall
CCall :: CCallSpec -> ForeignCall
isSafeForeignCall :: ForeignCall -> Bool
data Safety

-- | Might invoke Haskell GC, or do a call back, or switch threads, etc. So
--   make sure things are tidy before the call. Additionally, in the
--   threaded RTS we arrange for the external call to be executed by a
--   separate OS thread, i.e., _concurrently_ to the execution of other
--   Haskell threads.
PlaySafe :: Safety

-- | Like PlaySafe, but additionally the worker thread running this foreign
--   call may be unceremoniously killed, so it must be scheduled on an
--   unbound thread.
PlayInterruptible :: Safety

-- | None of the above can happen; the call will return without interacting
--   with the runtime system at all. Specifically:
--   
--   <ul>
--   <li>No GC</li>
--   <li>No call backs</li>
--   <li>No blocking</li>
--   <li>No precise exceptions</li>
--   </ul>
PlayRisky :: Safety
playSafe :: Safety -> Bool
playInterruptible :: Safety -> Bool
data CExportSpec
CExportStatic :: SourceText -> CLabelString -> CCallConv -> CExportSpec
type CLabelString = FastString
isCLabelString :: CLabelString -> Bool
pprCLabelString :: CLabelString -> SDoc
data CCallSpec
CCallSpec :: CCallTarget -> CCallConv -> Safety -> CCallSpec

-- | How to call a particular function in C-land.
data CCallTarget
StaticTarget :: SourceText -> CLabelString -> Maybe Unit -> Bool -> CCallTarget
DynamicTarget :: CCallTarget
isDynamicTarget :: CCallTarget -> Bool
data CCallConv
CCallConv :: CCallConv
CApiConv :: CCallConv
StdCallConv :: CCallConv
PrimCallConv :: CCallConv
JavaScriptCallConv :: CCallConv
defaultCCallConv :: CCallConv
ccallConvToInt :: CCallConv -> Int
ccallConvAttribute :: CCallConv -> SDoc
data Header
Header :: SourceText -> FastString -> Header

-- | A C type, used in CAPI FFI calls
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# CTYPE'</tt>,
--   <a>AnnHeader</a>,<a>AnnVal</a>, <a>AnnClose</a> <tt>'#-}'</tt>,</li>
--   </ul>
data CType
CType :: SourceText -> Maybe Header -> (SourceText, FastString) -> CType
instance Data.Data.Data GHC.Types.ForeignCall.Safety
instance GHC.Show.Show GHC.Types.ForeignCall.Safety
instance GHC.Classes.Eq GHC.Types.ForeignCall.Safety
instance Data.Data.Data GHC.Types.ForeignCall.CCallConv
instance GHC.Classes.Eq GHC.Types.ForeignCall.CCallConv
instance Data.Data.Data GHC.Types.ForeignCall.CCallTarget
instance GHC.Classes.Eq GHC.Types.ForeignCall.CCallTarget
instance GHC.Classes.Eq GHC.Types.ForeignCall.CCallSpec
instance GHC.Classes.Eq GHC.Types.ForeignCall.ForeignCall
instance Data.Data.Data GHC.Types.ForeignCall.CExportSpec
instance Data.Data.Data GHC.Types.ForeignCall.Header
instance GHC.Classes.Eq GHC.Types.ForeignCall.Header
instance Data.Data.Data GHC.Types.ForeignCall.CType
instance GHC.Classes.Eq GHC.Types.ForeignCall.CType
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.CType
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CType
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.Header
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.Header
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.CExportSpec
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CExportSpec
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.ForeignCall
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.ForeignCall
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.CCallSpec
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CCallSpec
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CCallTarget
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.CCallConv
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CCallConv
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.Safety
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.Safety


-- | Source text
--   
--   Keeping Source Text for source to source conversions
module GHC.Types.SourceText
data SourceText
SourceText :: String -> SourceText

-- | For when code is generated, e.g. TH, deriving. The pretty printer will
--   then make its own representation of the item.
NoSourceText :: SourceText

-- | Special combinator for showing string literals.
pprWithSourceText :: SourceText -> SDoc -> SDoc

-- | Integral Literal
--   
--   Used (instead of Integer) to represent negative zegative zero which is
--   required for NegativeLiterals extension to correctly parse
--   `-0::Double` as negative zero. See also #13211.
data IntegralLit
IL :: SourceText -> Bool -> Integer -> IntegralLit
[il_text] :: IntegralLit -> SourceText
[il_neg] :: IntegralLit -> Bool
[il_value] :: IntegralLit -> Integer

-- | Fractional Literal
--   
--   Used (instead of Rational) to represent exactly the floating point
--   literal that we encountered in the user's source program. This allows
--   us to pretty-print exactly what the user wrote, which is important
--   e.g. for floating point numbers that can't represented as Doubles (we
--   used to via Double for pretty-printing). See also #2245. Note
--   [FractionalLit representation] in GHC.HsToCore.Match.Literal The
--   actual value then is: sign * fl_signi * (fl_exp_base^fl_exp) where
--   sign = if fl_neg then (-1) else 1
--   
--   For example FL { fl_neg = True, fl_signi = 5.3, fl_exp = 4,
--   fl_exp_base = Base10 } denotes -5300
data FractionalLit
FL :: SourceText -> Bool -> Rational -> Integer -> FractionalExponentBase -> FractionalLit

-- | How the value was written in the source
[fl_text] :: FractionalLit -> SourceText
[fl_neg] :: FractionalLit -> Bool
[fl_signi] :: FractionalLit -> Rational
[fl_exp] :: FractionalLit -> Integer
[fl_exp_base] :: FractionalLit -> FractionalExponentBase

-- | A String Literal in the source, including its original raw format for
--   use by source to source manipulation tools.
data StringLiteral
StringLiteral :: SourceText -> FastString -> Maybe RealSrcSpan -> StringLiteral
[sl_st] :: StringLiteral -> SourceText
[sl_fs] :: StringLiteral -> FastString
[sl_tc] :: StringLiteral -> Maybe RealSrcSpan
negateIntegralLit :: IntegralLit -> IntegralLit
negateFractionalLit :: FractionalLit -> FractionalLit
mkIntegralLit :: Integral a => a -> IntegralLit
mkTHFractionalLit :: Rational -> FractionalLit
rationalFromFractionalLit :: FractionalLit -> Rational

-- | The integer should already be negated if it's negative.
integralFractionalLit :: Bool -> Integer -> FractionalLit

-- | The arguments should already be negated if they are negative.
mkSourceFractionalLit :: String -> Bool -> Integer -> Integer -> FractionalExponentBase -> FractionalLit
data FractionalExponentBase
Base2 :: FractionalExponentBase
Base10 :: FractionalExponentBase
fractionalLitFromRational :: Rational -> FractionalLit
mkFractionalLit :: SourceText -> Bool -> Rational -> Integer -> FractionalExponentBase -> FractionalLit
instance GHC.Classes.Eq GHC.Types.SourceText.SourceText
instance GHC.Show.Show GHC.Types.SourceText.SourceText
instance Data.Data.Data GHC.Types.SourceText.SourceText
instance GHC.Show.Show GHC.Types.SourceText.IntegralLit
instance Data.Data.Data GHC.Types.SourceText.IntegralLit
instance GHC.Show.Show GHC.Types.SourceText.FractionalExponentBase
instance Data.Data.Data GHC.Types.SourceText.FractionalExponentBase
instance GHC.Classes.Ord GHC.Types.SourceText.FractionalExponentBase
instance GHC.Classes.Eq GHC.Types.SourceText.FractionalExponentBase
instance GHC.Show.Show GHC.Types.SourceText.FractionalLit
instance Data.Data.Data GHC.Types.SourceText.FractionalLit
instance Data.Data.Data GHC.Types.SourceText.StringLiteral
instance GHC.Classes.Eq GHC.Types.SourceText.StringLiteral
instance GHC.Utils.Outputable.Outputable GHC.Types.SourceText.StringLiteral
instance GHC.Utils.Binary.Binary GHC.Types.SourceText.StringLiteral
instance GHC.Classes.Eq GHC.Types.SourceText.FractionalLit
instance GHC.Classes.Ord GHC.Types.SourceText.FractionalLit
instance GHC.Utils.Outputable.Outputable GHC.Types.SourceText.FractionalLit
instance GHC.Classes.Eq GHC.Types.SourceText.IntegralLit
instance GHC.Classes.Ord GHC.Types.SourceText.IntegralLit
instance GHC.Utils.Outputable.Outputable GHC.Types.SourceText.IntegralLit
instance GHC.Utils.Outputable.Outputable GHC.Types.SourceText.SourceText
instance GHC.Utils.Binary.Binary GHC.Types.SourceText.SourceText


-- | A language to express the evaluation context of an expression as a
--   <a>Demand</a> and track how an expression evaluates free variables and
--   arguments in turn as a <a>DmdType</a>.
--   
--   Lays out the abstract domain for <a>GHC.Core.Opt.DmdAnal</a>.
module GHC.Types.Demand

-- | Describes an interval of <i>evaluation cardinalities</i>. See Note
--   [Evaluation cardinalities]
data Card

-- | {0} Absent.
C_00 :: Card

-- | {0,1} Used at most once.
C_01 :: Card

-- | {0,1,n} Every possible cardinality; the top element.
C_0N :: Card

-- | {1} Strict and used once.
C_11 :: Card

-- | {1,n} Strict and used (possibly) many times.
C_1N :: Card

-- | {} The empty interval; the bottom element of the lattice.
C_10 :: Card

-- | A demand describes a <i>scaled evaluation context</i>, e.g. how many
--   times and how deep the denoted thing is evaluated.
--   
--   The "how many" component is represented by a <a>Card</a>inality. The
--   "how deep" component is represented by a <a>SubDemand</a>. Examples
--   (using Note [Demand notation]):
--   
--   <ul>
--   <li><a>seq</a> puts demand <tt>1A</tt> on its first argument: It
--   evaluates the argument strictly (<tt>1</tt>), but not any deeper
--   (<tt>A</tt>).</li>
--   <li><a>fst</a> puts demand <tt>1P(1L,A)</tt> on its argument: It
--   evaluates the argument pair strictly and the first component strictly,
--   but no nested info beyond that (<tt>L</tt>). Its second argument is
--   not used at all.</li>
--   <li><a>$</a> puts demand <tt>1C1(L)</tt> on its first argument: It
--   calls (<tt>C</tt>) the argument function with one argument, exactly
--   once (<tt>1</tt>). No info on how the result of that call is evaluated
--   (<tt>L</tt>).</li>
--   <li><a>maybe</a> puts demand <tt>MCM(L)</tt> on its second argument:
--   It evaluates the argument function at most once ((M)aybe) and calls it
--   once when it is evaluated.</li>
--   <li><tt>fst p + fst p</tt> puts demand <tt>SP(SL,A)</tt> on
--   <tt>p</tt>: It's <tt>1P(1L,A)</tt> multiplied by two, so we get
--   <tt>S</tt> (used at least once, possibly multiple times).</li>
--   </ul>
--   
--   This data type is quite similar to <tt><tt>Scaled</tt>
--   <a>SubDemand</a></tt>, but it's scaled by <a>Card</a>, which is an
--   <i>interval</i> on <tt>Multiplicity</tt>, the upper bound of which
--   could be used to infer uniqueness types.
data Demand
(:*) :: !Card -> !SubDemand -> Demand

-- | A sub-demand describes an <i>evaluation context</i>, e.g. how deep the
--   denoted thing is evaluated. See <a>Demand</a> for examples.
--   
--   The nested <a>SubDemand</a> <tt>d</tt> of a <a>Call</a> <tt>Cn(d)</tt>
--   is <i>relative</i> to a single such call. E.g. The expression <tt>f 1
--   2 + f 3 4</tt> puts call demand <tt>SCS(C1(L))</tt> on <tt>f</tt>:
--   <tt>f</tt> is called exactly twice (<tt>S</tt>), each time exactly
--   once (<tt>1</tt>) with an additional argument.
--   
--   The nested <a>Demand</a>s <tt>dn</tt> of a <a>Prod</a>
--   <tt>P(d1,d2,...)</tt> apply <i>absolutely</i>: If <tt>dn</tt> is a
--   used once demand (cf. <a>isUsedOnce</a>), then that means that the
--   denoted sub-expression is used once in the entire evaluation context
--   described by the surrounding <a>Demand</a>. E.g., <tt>LP(ML)</tt>
--   means that the field of the denoted expression is used at most once,
--   although the entire expression might be used many times.
--   
--   See Note [Call demands are relative] and Note [Demand notation].
data SubDemand

-- | <tt>Prod ds</tt> describes the evaluation context of a case
--   scrutinisation on an expression of product type, where the product
--   components are evaluated according to <tt>ds</tt>.
Prod :: ![Demand] -> SubDemand

-- | A smart constructor for <a>Prod</a>, applying rewrite rules along the
--   semantic equality <tt>Prod [polyDmd n, ...] === polyDmd n</tt>,
--   simplifying to <a>Poly</a> <a>SubDemand</a>s when possible. Note that
--   this degrades boxity information! E.g. a polymorphic demand will never
--   unbox.
mkProd :: [Demand] -> SubDemand

-- | <tt>viewProd n sd</tt> interprets <tt>sd</tt> as a <a>Prod</a> of
--   arity <tt>n</tt>, expanding <a>Poly</a> demands as necessary.
viewProd :: Arity -> SubDemand -> Maybe [Demand]
absDmd :: Demand
topDmd :: Demand
botDmd :: Demand
seqDmd :: Demand
topSubDmd :: SubDemand

-- | Denotes <tt>âª</tt> on <a>Card</a>.
lubCard :: Card -> Card -> Card

-- | Denotes <tt>âª</tt> on <a>Demand</a>.
lubDmd :: Demand -> Demand -> Demand

-- | Denotes <tt>âª</tt> on <a>SubDemand</a>.
lubSubDmd :: SubDemand -> SubDemand -> SubDemand

-- | Denotes <a>+</a> on <a>Card</a>.
plusCard :: Card -> Card -> Card

-- | Denotes <a>+</a> on <a>Demand</a>.
plusDmd :: Demand -> Demand -> Demand

-- | Denotes <a>+</a> on <a>SubDemand</a>.
plusSubDmd :: SubDemand -> SubDemand -> SubDemand

-- | Denotes <a>*</a> on <a>Card</a>.
multCard :: Card -> Card -> Card
multDmd :: Card -> Demand -> Demand
multSubDmd :: Card -> SubDemand -> SubDemand

-- | True <a>=</a> upper bound is 0.
isAbs :: Card -> Bool

-- | True <a>=</a> upper bound is 1.
isUsedOnce :: Card -> Bool

-- | True <a>=</a> lower bound is 1.
isStrict :: Card -> Bool
isAbsDmd :: Demand -> Bool

-- | Is the value used at most once?
isUsedOnceDmd :: Demand -> Bool

-- | Not absent and used strictly. See Note [Strict demands]
isStrUsedDmd :: Demand -> Bool

-- | Contrast with isStrictUsedDmd. See Note [Strict demands]
isStrictDmd :: Demand -> Bool

-- | Used to suppress pretty-printing of an uninformative demand
isTopDmd :: Demand -> Bool
isSeqDmd :: Demand -> Bool

-- | We try to avoid tracking weak free variable demands in strictness
--   signatures for analysis performance reasons. See Note [Lazy and
--   unleashable free variables] in <a>GHC.Core.Opt.DmdAnal</a>.
isWeakDmd :: Demand -> Bool
evalDmd :: Demand

-- | First argument of catch#: <tt>MCM(L)</tt>. Evaluates its arg lazily,
--   but then applies it exactly once to one argument.
lazyApply1Dmd :: Demand

-- | Second argument of catch#: <tt>MCM(C1(L))</tt>. Calls its arg lazily,
--   but then applies it exactly once to an additional argument.
lazyApply2Dmd :: Demand

-- | First argument of 'GHC.Exts.maskAsyncExceptions#': <tt>1C1(L)</tt>.
--   Called exactly once.
strictOnceApply1Dmd :: Demand

-- | First argument of 'GHC.Exts.atomically#': <tt>SCS(L)</tt>. Called at
--   least once, possibly many times.
strictManyApply1Dmd :: Demand

-- | Intersect with [0,1].
oneifyCard :: Card -> Card

-- | Make a <a>Demand</a> evaluated at-most-once.
oneifyDmd :: Demand -> Demand

-- | Make a <a>Demand</a> evaluated at-least-once (e.g. strict).
strictifyDmd :: Demand -> Demand

-- | If the argument is a used non-newtype dictionary, give it strict
--   demand. Also split the product type &amp; demand and recur in order to
--   similarly strictify the argument's contained used non-newtype
--   superclass dictionaries. We use the demand as our recursive measure to
--   guarantee termination.
strictifyDictDmd :: Type -> Demand -> Demand
mkWorkerDemand :: Int -> Demand

-- | Peels one call level from the sub-demand, and also returns how many
--   times we entered the lambda body.
peelCallDmd :: SubDemand -> (Card, SubDemand)
peelManyCalls :: Int -> SubDemand -> Card

-- | Wraps the <a>SubDemand</a> with a one-shot call demand: <tt>d</tt>
--   -&gt; <tt>C1(d)</tt>.
mkCalledOnceDmd :: SubDemand -> SubDemand

-- | <tt>mkCalledOnceDmds n d</tt> returns <tt>C1(C1...(C1 d))</tt> where
--   there are <tt>n</tt> <tt>C1</tt>'s.
mkCalledOnceDmds :: Arity -> SubDemand -> SubDemand
addCaseBndrDmd :: SubDemand -> [Demand] -> [Demand]

-- | See Note [Computing one-shot info]
argOneShots :: Demand -> [OneShotInfo]

-- | See Note [Computing one-shot info]
argsOneShots :: StrictSig -> Arity -> [[OneShotInfo]]

-- | <tt>saturatedByOneShots n CM(CM(...)) = True</tt> <a>=</a> There are
--   at least n nested CM(..) calls. See Note [Demand on the worker] in
--   GHC.Core.Opt.WorkWrap
saturatedByOneShots :: Int -> Demand -> Bool
type DmdEnv = VarEnv Demand
emptyDmdEnv :: DmdEnv

-- | <tt>keepAliveDmdType dt vs</tt> makes sure that the Ids in <tt>vs</tt>
--   have <i>some</i> usage in the returned demand types -- they are not
--   Absent. See Note [Absence analysis for stable unfoldings and RULES] in
--   <a>GHC.Core.Opt.DmdAnal</a>.
keepAliveDmdEnv :: DmdEnv -> IdSet -> DmdEnv
reuseEnv :: DmdEnv -> DmdEnv

-- | <a>Divergence</a> characterises whether something surely diverges.
--   Models a subset lattice of the following exhaustive set of divergence
--   results:
--   
--   <ul>
--   <li><i>n</i> nontermination (e.g. loops)</li>
--   <li><i>i</i> throws imprecise exception</li>
--   <li><i>p</i> throws precise exceTtion</li>
--   <li><i>c</i> converges (reduces to WHNF).</li>
--   </ul>
--   
--   The different lattice elements correspond to different subsets,
--   indicated by juxtaposition of indicators (e.g. <b>nc</b> definitely
--   doesn't throw an exception, and may or may not reduce to WHNF).
--   
--   <pre>
--    Dunno (nipc)
--         |
--   ExnOrDiv (nip)
--         |
--   Diverges (ni)
--   </pre>
--   
--   As you can see, we don't distinguish <b>n</b> and <b>i</b>. See Note
--   [Precise exceptions and strictness analysis] for why <b>p</b> is so
--   special compared to <b>i</b>.
data Divergence

-- | Definitely throws an imprecise exception or diverges.
Diverges :: Divergence

-- | Definitely throws a *precise* exception, an imprecise exception or
--   diverges. Never converges, hence <a>isDeadEndDiv</a>! See scenario 1
--   in Note [Precise exceptions and strictness analysis].
ExnOrDiv :: Divergence

-- | Might diverge, throw any kind of exception or converge.
Dunno :: Divergence
topDiv :: Divergence
botDiv :: Divergence
exnDiv :: Divergence
lubDivergence :: Divergence -> Divergence -> Divergence

-- | True if the <a>Divergence</a> indicates that evaluation will not
--   return. See Note [Dead ends].
isDeadEndDiv :: Divergence -> Bool

-- | Characterises how an expression * Evaluates its free variables
--   (<a>dt_env</a>) * Evaluates its arguments (<a>dt_args</a>) * Diverges
--   on every code path or not (<a>dt_div</a>)
data DmdType
DmdType :: !DmdEnv -> ![Demand] -> !Divergence -> DmdType

-- | Demand on explicitly-mentioned free variables
[dt_env] :: DmdType -> !DmdEnv

-- | Demand on arguments
[dt_args] :: DmdType -> ![Demand]

-- | Whether evaluation diverges. See Note [Demand type Divergence]
[dt_div] :: DmdType -> !Divergence
dmdTypeDepth :: DmdType -> Arity

-- | The demand type of doing nothing (lazy, absent, no Divergence
--   information). Note that it is '<tt>not'</tt> the top of the lattice
--   (which would be "may use everything"), so it is (no longer) called
--   topDmdType.
nopDmdType :: DmdType
botDmdType :: DmdType

-- | Compute the least upper bound of two <a>DmdType</a>s elicited /by the
--   same incoming demand/!
lubDmdType :: DmdType -> DmdType -> DmdType
plusDmdType :: DmdType -> PlusDmdArg -> DmdType
multDmdType :: Card -> DmdType -> DmdType
type PlusDmdArg = (DmdEnv, Divergence)
mkPlusDmdArg :: DmdEnv -> PlusDmdArg
toPlusDmdArg :: DmdType -> PlusDmdArg
peelFV :: DmdType -> Var -> (DmdType, Demand)
findIdDemand :: DmdType -> Var -> Demand
addDemand :: Demand -> DmdType -> DmdType
splitDmdTy :: DmdType -> (Demand, DmdType)

-- | When e is evaluated after executing an IO action that may throw a
--   precise exception, we act as if there is an additional control flow
--   path that is taken if e throws a precise exception. The demand type of
--   this control flow path * is lazy and absent (<a>topDmd</a>) in all
--   free variables and arguments * has <a>exnDiv</a> <a>Divergence</a>
--   result So we can simply take a variant of <a>nopDmdType</a>,
--   <a>exnDmdType</a>. Why not <a>nopDmdType</a>? Because then the result
--   of <tt>e</tt> can never be <a>exnDiv</a>! That means failure to drop
--   dead-ends, see #18086. See Note [Precise exceptions and strictness
--   analysis]
deferAfterPreciseException :: DmdType -> DmdType

-- | See <a>keepAliveDmdEnv</a>.
keepAliveDmdType :: DmdType -> VarSet -> DmdType

-- | The depth of the wrapped <a>DmdType</a> encodes the arity at which it
--   is safe to unleash. Better construct this through
--   <a>mkStrictSigForArity</a>. See Note [Understanding DmdType and
--   StrictSig]
newtype StrictSig
StrictSig :: DmdType -> StrictSig

-- | Turns a <a>DmdType</a> computed for the particular <a>Arity</a> into a
--   <a>StrictSig</a> unleashable at that arity. See Note [Understanding
--   DmdType and StrictSig]
mkStrictSigForArity :: Arity -> DmdType -> StrictSig
mkClosedStrictSig :: [Demand] -> Divergence -> StrictSig
splitStrictSig :: StrictSig -> ([Demand], Divergence)
strictSigDmdEnv :: StrictSig -> DmdEnv
hasDemandEnvSig :: StrictSig -> Bool
nopSig :: StrictSig
botSig :: StrictSig
isTopSig :: StrictSig -> Bool

-- | True if the signature diverges or throws an exception in a saturated
--   call. See Note [Dead ends].
isDeadEndSig :: StrictSig -> Bool

-- | Returns true if an application to n value args would diverge or throw
--   an exception.
--   
--   If a function having <a>botDiv</a> is applied to a less number of
--   arguments than its syntactic arity, we cannot say for sure that it is
--   going to diverge. Hence this function conservatively returns False in
--   that case. See Note [Dead ends].
isDeadEndAppSig :: StrictSig -> Int -> Bool

-- | Add extra (<a>topDmd</a>) arguments to a strictness signature. In
--   contrast to <a>etaConvertStrictSig</a>, this <i>prepends</i>
--   additional argument demands. This is used by FloatOut.
prependArgsStrictSig :: Int -> StrictSig -> StrictSig

-- | We are expanding (x y. e) to (x y z. e z) or reducing from the latter
--   to the former (when the Simplifier identifies a new join points, for
--   example). In contrast to <a>prependArgsStrictSig</a>, this
--   <i>appends</i> extra arg demands if necessary. This works by looking
--   at the <a>DmdType</a> (which was produced under a call demand for the
--   old arity) and trying to transfer as many facts as we can to the call
--   demand of new arity. An arity increase (resulting in a stronger
--   incoming demand) can retain much of the info, while an arity decrease
--   (a weakening of the incoming demand) must fall back to a conservative
--   default.
etaConvertStrictSig :: Arity -> StrictSig -> StrictSig

-- | A <i>demand transformer</i> is a monotone function from an incoming
--   evaluation context (<a>SubDemand</a>) to a <a>DmdType</a>, describing
--   how the denoted thing (i.e. expression, function) uses its arguments
--   and free variables, and whether it diverges.
--   
--   See Note [Understanding DmdType and StrictSig] and Note [What are
--   demand signatures?].
type DmdTransformer = SubDemand -> DmdType

-- | Extrapolate a demand signature (<a>StrictSig</a>) into a
--   <a>DmdTransformer</a>.
--   
--   Given a function's <a>StrictSig</a> and a <a>SubDemand</a> for the
--   evaluation context, return how the function evaluates its free
--   variables and arguments.
dmdTransformSig :: StrictSig -> DmdTransformer

-- | A special <a>DmdTransformer</a> for data constructors that feeds
--   product demands into the constructor arguments.
dmdTransformDataConSig :: Arity -> DmdTransformer

-- | A special <a>DmdTransformer</a> for dictionary selectors that feeds
--   the demand on the result into the indicated dictionary component (if
--   saturated).
dmdTransformDictSelSig :: StrictSig -> DmdTransformer
data TypeShape
TsFun :: TypeShape -> TypeShape
TsProd :: [TypeShape] -> TypeShape
TsUnk :: TypeShape
trimToType :: Demand -> TypeShape -> Demand
seqDemand :: Demand -> ()
seqDemandList :: [Demand] -> ()
seqDmdType :: DmdType -> ()
seqStrictSig :: StrictSig -> ()
zapUsageDemand :: Demand -> Demand

-- | Remove the demand environment from the signature.
zapDmdEnvSig :: StrictSig -> StrictSig

-- | Remove all `C_01 :*` info (but not <tt>CM</tt> sub-demands) from the
--   demand
zapUsedOnceDemand :: Demand -> Demand

-- | Remove all `C_01 :*` info (but not <tt>CM</tt> sub-demands) from the
--   strictness signature
zapUsedOnceSig :: StrictSig -> StrictSig
instance GHC.Classes.Eq GHC.Types.Demand.Card
instance GHC.Classes.Eq GHC.Types.Demand.Demand
instance GHC.Classes.Eq GHC.Types.Demand.SubDemand
instance GHC.Classes.Eq GHC.Types.Demand.Divergence
instance GHC.Classes.Eq GHC.Types.Demand.StrictSig
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.TypeShape
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.StrictSig
instance GHC.Utils.Binary.Binary GHC.Types.Demand.StrictSig
instance GHC.Classes.Eq GHC.Types.Demand.DmdType
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.DmdType
instance GHC.Utils.Binary.Binary GHC.Types.Demand.DmdType
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.Divergence
instance GHC.Utils.Binary.Binary GHC.Types.Demand.Divergence
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.Demand
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.SubDemand
instance GHC.Utils.Binary.Binary GHC.Types.Demand.Demand
instance GHC.Utils.Binary.Binary GHC.Types.Demand.SubDemand
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.Card
instance GHC.Utils.Binary.Binary GHC.Types.Demand.Card

module GHC.Types.Var.Env

-- | Variable Environment
type VarEnv elt = UniqFM Var elt

-- | Identifier Environment
type IdEnv elt = UniqFM Id elt

-- | Type Variable Environment
type TyVarEnv elt = UniqFM Var elt

-- | Coercion Variable Environment
type CoVarEnv elt = UniqFM CoVar elt

-- | Type or Coercion Variable Environment
type TyCoVarEnv elt = UniqFM TyCoVar elt
emptyVarEnv :: VarEnv a
unitVarEnv :: Var -> a -> VarEnv a
mkVarEnv :: [(Var, a)] -> VarEnv a
mkVarEnv_Directly :: [(Unique, a)] -> VarEnv a
elemVarEnv :: Var -> VarEnv a -> Bool
disjointVarEnv :: VarEnv a -> VarEnv a -> Bool
extendVarEnv :: VarEnv a -> Var -> a -> VarEnv a
extendVarEnv_C :: (a -> a -> a) -> VarEnv a -> Var -> a -> VarEnv a
extendVarEnv_Acc :: (a -> b -> b) -> (a -> b) -> VarEnv b -> Var -> a -> VarEnv b
extendVarEnvList :: VarEnv a -> [(Var, a)] -> VarEnv a
plusVarEnv :: VarEnv a -> VarEnv a -> VarEnv a
plusVarEnv_C :: (a -> a -> a) -> VarEnv a -> VarEnv a -> VarEnv a
plusVarEnv_CD :: (a -> a -> a) -> VarEnv a -> a -> VarEnv a -> a -> VarEnv a
plusMaybeVarEnv_C :: (a -> a -> Maybe a) -> VarEnv a -> VarEnv a -> VarEnv a
plusVarEnvList :: [VarEnv a] -> VarEnv a
alterVarEnv :: (Maybe a -> Maybe a) -> VarEnv a -> Var -> VarEnv a
delVarEnvList :: VarEnv a -> [Var] -> VarEnv a
delVarEnv :: VarEnv a -> Var -> VarEnv a
minusVarEnv :: VarEnv a -> VarEnv b -> VarEnv a
lookupVarEnv :: VarEnv a -> Var -> Maybe a
lookupVarEnv_NF :: VarEnv a -> Var -> a
lookupWithDefaultVarEnv :: VarEnv a -> a -> Var -> a
mapVarEnv :: (a -> b) -> VarEnv a -> VarEnv b
zipVarEnv :: [Var] -> [a] -> VarEnv a
modifyVarEnv :: (a -> a) -> VarEnv a -> Var -> VarEnv a
modifyVarEnv_Directly :: (a -> a) -> UniqFM key a -> Unique -> UniqFM key a
isEmptyVarEnv :: VarEnv a -> Bool
elemVarEnvByKey :: Unique -> VarEnv a -> Bool
filterVarEnv :: (a -> Bool) -> VarEnv a -> VarEnv a
restrictVarEnv :: VarEnv a -> VarSet -> VarEnv a
partitionVarEnv :: (a -> Bool) -> VarEnv a -> (VarEnv a, VarEnv a)

-- | Deterministic Variable Environment
type DVarEnv elt = UniqDFM Var elt

-- | Deterministic Identifier Environment Sadly not always indexed by Id,
--   but it is in the common case.
type DIdEnv elt = UniqDFM Var elt

-- | Deterministic Type Variable Environment
type DTyVarEnv elt = UniqDFM TyVar elt
emptyDVarEnv :: DVarEnv a
mkDVarEnv :: [(Var, a)] -> DVarEnv a
dVarEnvElts :: DVarEnv a -> [a]
extendDVarEnv :: DVarEnv a -> Var -> a -> DVarEnv a
extendDVarEnv_C :: (a -> a -> a) -> DVarEnv a -> Var -> a -> DVarEnv a
extendDVarEnvList :: DVarEnv a -> [(Var, a)] -> DVarEnv a
lookupDVarEnv :: DVarEnv a -> Var -> Maybe a
elemDVarEnv :: Var -> DVarEnv a -> Bool
isEmptyDVarEnv :: DVarEnv a -> Bool
foldDVarEnv :: (a -> b -> b) -> b -> DVarEnv a -> b
nonDetStrictFoldDVarEnv :: (a -> b -> b) -> b -> DVarEnv a -> b
mapDVarEnv :: (a -> b) -> DVarEnv a -> DVarEnv b
filterDVarEnv :: (a -> Bool) -> DVarEnv a -> DVarEnv a
modifyDVarEnv :: (a -> a) -> DVarEnv a -> Var -> DVarEnv a
alterDVarEnv :: (Maybe a -> Maybe a) -> DVarEnv a -> Var -> DVarEnv a
plusDVarEnv :: DVarEnv a -> DVarEnv a -> DVarEnv a
plusDVarEnv_C :: (a -> a -> a) -> DVarEnv a -> DVarEnv a -> DVarEnv a
unitDVarEnv :: Var -> a -> DVarEnv a
delDVarEnv :: DVarEnv a -> Var -> DVarEnv a
delDVarEnvList :: DVarEnv a -> [Var] -> DVarEnv a
minusDVarEnv :: DVarEnv a -> DVarEnv a' -> DVarEnv a
partitionDVarEnv :: (a -> Bool) -> DVarEnv a -> (DVarEnv a, DVarEnv a)
anyDVarEnv :: (a -> Bool) -> DVarEnv a -> Bool

-- | A set of variables that are in scope at some point "Secrets of the
--   Glasgow Haskell Compiler inliner" Section 3.2 provides the motivation
--   for this abstraction.
data InScopeSet
emptyInScopeSet :: InScopeSet
mkInScopeSet :: VarSet -> InScopeSet
delInScopeSet :: InScopeSet -> Var -> InScopeSet
extendInScopeSet :: InScopeSet -> Var -> InScopeSet
extendInScopeSetList :: InScopeSet -> [Var] -> InScopeSet
extendInScopeSetSet :: InScopeSet -> VarSet -> InScopeSet
getInScopeVars :: InScopeSet -> VarSet

-- | Look up a variable the <a>InScopeSet</a>. This lets you map from the
--   variable's identity (unique) to its full value.
lookupInScope :: InScopeSet -> Var -> Maybe Var
lookupInScope_Directly :: InScopeSet -> Unique -> Maybe Var
unionInScope :: InScopeSet -> InScopeSet -> InScopeSet
elemInScopeSet :: Var -> InScopeSet -> Bool

-- | <tt>uniqAway in_scope v</tt> finds a unique that is not used in the
--   in-scope set, and gives that to v. See Note [Local uniques].
uniqAway :: InScopeSet -> Var -> Var
varSetInScope :: VarSet -> InScopeSet -> Bool

-- | <tt>unsafeGetFreshUnique in_scope</tt> finds a unique that is not
--   in-scope in the given <a>InScopeSet</a>. This must be used very
--   carefully since one can very easily introduce non-unique
--   <a>Unique</a>s this way. See Note [Local uniques].
unsafeGetFreshLocalUnique :: InScopeSet -> Unique

-- | Rename Environment 2
--   
--   When we are comparing (or matching) types or terms, we are faced with
--   "going under" corresponding binders. E.g. when comparing:
--   
--   <pre>
--   \x. e1     ~   \y. e2
--   </pre>
--   
--   Basically we want to rename [<tt>x</tt> -&gt; <tt>y</tt>] or
--   [<tt>y</tt> -&gt; <tt>x</tt>], but there are lots of things we must be
--   careful of. In particular, <tt>x</tt> might be free in <tt>e2</tt>, or
--   y in <tt>e1</tt>. So the idea is that we come up with a fresh binder
--   that is free in neither, and rename <tt>x</tt> and <tt>y</tt>
--   respectively. That means we must maintain:
--   
--   <ol>
--   <li>A renaming for the left-hand expression</li>
--   <li>A renaming for the right-hand expressions</li>
--   <li>An in-scope set</li>
--   </ol>
--   
--   Furthermore, when matching, we want to be able to have an 'occurs
--   check', to prevent:
--   
--   <pre>
--   \x. f   ~   \y. y
--   </pre>
--   
--   matching with [<tt>f</tt> -&gt; <tt>y</tt>]. So for each expression we
--   want to know that set of locally-bound variables. That is precisely
--   the domain of the mappings 1. and 2., but we must ensure that we
--   always extend the mappings as we go in.
--   
--   All of this information is bundled up in the <a>RnEnv2</a>
data RnEnv2
mkRnEnv2 :: InScopeSet -> RnEnv2

-- | <tt>rnBndr2 env bL bR</tt> goes under a binder <tt>bL</tt> in the Left
--   term, and binder <tt>bR</tt> in the Right term. It finds a new binder,
--   <tt>new_b</tt>, and returns an environment mapping <tt>bL -&gt;
--   new_b</tt> and <tt>bR -&gt; new_b</tt>
rnBndr2 :: RnEnv2 -> Var -> Var -> RnEnv2

-- | Applies <a>rnBndr2</a> to several variables: the two variable lists
--   must be of equal length
rnBndrs2 :: RnEnv2 -> [Var] -> [Var] -> RnEnv2

-- | Similar to <a>rnBndr2</a> but returns the new variable as well as the
--   new environment
rnBndr2_var :: RnEnv2 -> Var -> Var -> (RnEnv2, Var)

-- | Look up the renaming of an occurrence in the left or right term
rnOccL :: RnEnv2 -> Var -> Var

-- | Look up the renaming of an occurrence in the left or right term
rnOccR :: RnEnv2 -> Var -> Var

-- | Tells whether a variable is locally bound
inRnEnvL :: RnEnv2 -> Var -> Bool

-- | Tells whether a variable is locally bound
inRnEnvR :: RnEnv2 -> Var -> Bool

-- | Look up the renaming of an occurrence in the left or right term
rnOccL_maybe :: RnEnv2 -> Var -> Maybe Var

-- | Look up the renaming of an occurrence in the left or right term
rnOccR_maybe :: RnEnv2 -> Var -> Maybe Var

-- | Similar to <a>rnBndr2</a> but used when there's a binder on the left
--   side only.
rnBndrL :: RnEnv2 -> Var -> (RnEnv2, Var)

-- | Similar to <a>rnBndr2</a> but used when there's a binder on the right
--   side only.
rnBndrR :: RnEnv2 -> Var -> (RnEnv2, Var)

-- | Wipe the left or right side renaming
nukeRnEnvL :: RnEnv2 -> RnEnv2

-- | Wipe the left or right side renaming
nukeRnEnvR :: RnEnv2 -> RnEnv2

-- | swap the meaning of left and right
rnSwap :: RnEnv2 -> RnEnv2
delBndrL :: RnEnv2 -> Var -> RnEnv2
delBndrR :: RnEnv2 -> Var -> RnEnv2
delBndrsL :: RnEnv2 -> [Var] -> RnEnv2
delBndrsR :: RnEnv2 -> [Var] -> RnEnv2
extendRnInScopeSetList :: RnEnv2 -> [Var] -> RnEnv2

-- | Similar to <a>rnBndrL</a> but used for eta expansion See Note [Eta
--   expansion]
rnEtaL :: RnEnv2 -> Var -> (RnEnv2, Var)

-- | Similar to <a>rnBndr2</a> but used for eta expansion See Note [Eta
--   expansion]
rnEtaR :: RnEnv2 -> Var -> (RnEnv2, Var)
rnInScope :: Var -> RnEnv2 -> Bool
rnInScopeSet :: RnEnv2 -> InScopeSet
lookupRnInScope :: RnEnv2 -> Var -> Var

-- | Retrieve the left mapping
rnEnvL :: RnEnv2 -> VarEnv Var

-- | Retrieve the right mapping
rnEnvR :: RnEnv2 -> VarEnv Var

-- | Tidy Environment
--   
--   When tidying up print names, we keep a mapping of in-scope occ-names
--   (the <a>TidyOccEnv</a>) and a Var-to-Var of the current renamings
type TidyEnv = (TidyOccEnv, VarEnv Var)
emptyTidyEnv :: TidyEnv
mkEmptyTidyEnv :: TidyOccEnv -> TidyEnv
delTidyEnvList :: TidyEnv -> [Var] -> TidyEnv
instance GHC.Utils.Outputable.Outputable GHC.Types.Var.Env.InScopeSet


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a> represents names as strings with just a little more
--   information: the "namespace" that the name came from, e.g. the
--   namespace of value, type constructors or data constructors</li>
--   <li><a>RdrName</a>: see <a>GHC.Types.Name.Reader#name_types</a></li>
--   <li><a>Name</a>: see <a>GHC.Types.Name#name_types</a></li>
--   <li><a>Id</a>: see <a>GHC.Types.Id#name_types</a></li>
--   <li><a>Var</a>: see <a>GHC.Types.Var#name_types</a></li>
--   </ul>
module GHC.Types.Name.Occurrence
data NameSpace
nameSpacesRelated :: NameSpace -> NameSpace -> Bool
tcName :: NameSpace
clsName :: NameSpace
tcClsName :: NameSpace
dataName :: NameSpace
varName :: NameSpace
tvName :: NameSpace
srcDataName :: NameSpace
pprNameSpace :: NameSpace -> SDoc
pprNonVarNameSpace :: NameSpace -> SDoc
pprNameSpaceBrief :: NameSpace -> SDoc

-- | Occurrence Name
--   
--   In this context that means: "classified (i.e. as a type name, value
--   name, etc) but not qualified and not yet resolved"
data OccName
pprOccName :: OccName -> SDoc
mkOccName :: NameSpace -> String -> OccName
mkOccNameFS :: NameSpace -> FastString -> OccName
mkVarOcc :: String -> OccName
mkVarOccFS :: FastString -> OccName
mkDataOcc :: String -> OccName
mkDataOccFS :: FastString -> OccName
mkTyVarOcc :: String -> OccName
mkTyVarOccFS :: FastString -> OccName
mkTcOcc :: String -> OccName
mkTcOccFS :: FastString -> OccName
mkClsOcc :: String -> OccName
mkClsOccFS :: FastString -> OccName
mkDFunOcc :: String -> Bool -> OccSet -> OccName
setOccNameSpace :: NameSpace -> OccName -> OccName
demoteOccName :: OccName -> Maybe OccName
promoteOccName :: OccName -> Maybe OccName

-- | Other names in the compiler add additional information to an OccName.
--   This class provides a consistent way to access the underlying OccName.
class HasOccName name
occName :: HasOccName name => name -> OccName

-- | Test for definitions internally generated by GHC. This predicate is
--   used to suppress printing of internal definitions in some debug prints
isDerivedOccName :: OccName -> Bool
mkDataConWrapperOcc :: OccName -> OccName
mkWorkerOcc :: OccName -> OccName
mkMatcherOcc :: OccName -> OccName
mkBuilderOcc :: OccName -> OccName
mkDefaultMethodOcc :: OccName -> OccName
isDefaultMethodOcc :: OccName -> Bool

-- | Is an <a>OccName</a> one of a Typeable <tt>TyCon</tt> or
--   <tt>Module</tt> binding? This is needed as these bindings are renamed
--   differently. See Note [Grand plan for Typeable] in
--   <a>GHC.Tc.Instance.Typeable</a>.
isTypeableBindOcc :: OccName -> Bool
mkNewTyCoOcc :: OccName -> OccName
mkClassOpAuxOcc :: OccName -> OccName
mkCon2TagOcc :: OccName -> OccName
mkTag2ConOcc :: OccName -> OccName
mkMaxTagOcc :: OccName -> OccName
mkClassDataConOcc :: OccName -> OccName
mkDictOcc :: OccName -> OccName
mkIPOcc :: OccName -> OccName
mkSpecOcc :: OccName -> OccName
mkForeignExportOcc :: OccName -> OccName
mkRepEqOcc :: OccName -> OccName
mkGenR :: OccName -> OccName
mkGen1R :: OccName -> OccName
mkDataTOcc :: OccName -> OccName
mkDataCOcc :: OccName -> OccName
mkDataConWorkerOcc :: OccName -> OccName
mkSuperDictSelOcc :: Int -> OccName -> OccName
mkSuperDictAuxOcc :: Int -> OccName -> OccName
mkLocalOcc :: Unique -> OccName -> OccName
mkMethodOcc :: OccName -> OccName

-- | Derive a name for the representation type constructor of a
--   <tt>data</tt>/<tt>newtype</tt> instance.
mkInstTyTcOcc :: String -> OccSet -> OccName
mkInstTyCoOcc :: OccName -> OccName
mkEqPredCoOcc :: OccName -> OccName
mkRecFldSelOcc :: String -> OccName
mkTyConRepOcc :: OccName -> OccName
occNameFS :: OccName -> FastString
occNameString :: OccName -> String
occNameSpace :: OccName -> NameSpace
isVarOcc :: OccName -> Bool
isTvOcc :: OccName -> Bool
isTcOcc :: OccName -> Bool
isDataOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is a data constructor that starts with a
--   symbol (e.g. <tt>:</tt>, or <tt>[]</tt>)
isDataSymOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is that for any operator (whether it is a
--   data constructor or variable or whatever)
isSymOcc :: OccName -> Bool

-- | <i>Value</i> <tt>OccNames</tt>s are those that are either in the
--   variable or data constructor namespaces
isValOcc :: OccName -> Bool

-- | Wrap parens around an operator
parenSymOcc :: OccName -> SDoc -> SDoc

-- | Haskell 98 encourages compilers to suppress warnings about unused
--   names in a pattern if they start with <tt>_</tt>: this implements that
--   test
startsWithUnderscore :: OccName -> Bool
isTcClsNameSpace :: NameSpace -> Bool
isTvNameSpace :: NameSpace -> Bool
isDataConNameSpace :: NameSpace -> Bool
isVarNameSpace :: NameSpace -> Bool
isValNameSpace :: NameSpace -> Bool
data OccEnv a
emptyOccEnv :: OccEnv a
unitOccEnv :: OccName -> a -> OccEnv a
extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a
mapOccEnv :: (a -> b) -> OccEnv a -> OccEnv b
lookupOccEnv :: OccEnv a -> OccName -> Maybe a
mkOccEnv :: [(OccName, a)] -> OccEnv a
mkOccEnv_C :: (a -> a -> a) -> [(OccName, a)] -> OccEnv a
extendOccEnvList :: OccEnv a -> [(OccName, a)] -> OccEnv a
elemOccEnv :: OccName -> OccEnv a -> Bool
occEnvElts :: OccEnv a -> [a]
foldOccEnv :: (a -> b -> b) -> b -> OccEnv a -> b
plusOccEnv :: OccEnv a -> OccEnv a -> OccEnv a
plusOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccEnv a -> OccEnv a
extendOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccName -> a -> OccEnv a
extendOccEnv_Acc :: (a -> b -> b) -> (a -> b) -> OccEnv b -> OccName -> a -> OccEnv b
filterOccEnv :: (elt -> Bool) -> OccEnv elt -> OccEnv elt
delListFromOccEnv :: OccEnv a -> [OccName] -> OccEnv a
delFromOccEnv :: OccEnv a -> OccName -> OccEnv a
alterOccEnv :: (Maybe elt -> Maybe elt) -> OccEnv elt -> OccName -> OccEnv elt
pprOccEnv :: (a -> SDoc) -> OccEnv a -> SDoc
type OccSet = UniqSet OccName
emptyOccSet :: OccSet
unitOccSet :: OccName -> OccSet
mkOccSet :: [OccName] -> OccSet
extendOccSet :: OccSet -> OccName -> OccSet
extendOccSetList :: OccSet -> [OccName] -> OccSet
unionOccSets :: OccSet -> OccSet -> OccSet
unionManyOccSets :: [OccSet] -> OccSet
minusOccSet :: OccSet -> OccSet -> OccSet
elemOccSet :: OccName -> OccSet -> Bool
isEmptyOccSet :: OccSet -> Bool
intersectOccSet :: OccSet -> OccSet -> OccSet
filterOccSet :: (OccName -> Bool) -> OccSet -> OccSet
type TidyOccEnv = UniqFM FastString Int
emptyTidyOccEnv :: TidyOccEnv
initTidyOccEnv :: [OccName] -> TidyOccEnv
tidyOccName :: TidyOccEnv -> OccName -> (TidyOccEnv, OccName)
avoidClashesOccEnv :: TidyOccEnv -> [OccName] -> TidyOccEnv
delTidyOccEnvList :: TidyOccEnv -> [FastString] -> TidyOccEnv

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DFastStringEnv if the set
--   eventually gets converted into a list or folded over in a way where
--   the order changes the generated code.
type FastStringEnv a = UniqFM FastString a
emptyFsEnv :: FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
mkFsEnv :: [(FastString, a)] -> FastStringEnv a
instance GHC.Classes.Ord GHC.Types.Name.Occurrence.NameSpace
instance GHC.Classes.Eq GHC.Types.Name.Occurrence.NameSpace
instance Data.Data.Data a => Data.Data.Data (GHC.Types.Name.Occurrence.OccEnv a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Name.Occurrence.OccEnv a)
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Name.Occurrence.OccName
instance GHC.Classes.Eq GHC.Types.Name.Occurrence.OccName
instance GHC.Classes.Ord GHC.Types.Name.Occurrence.OccName
instance Data.Data.Data GHC.Types.Name.Occurrence.OccName
instance Control.DeepSeq.NFData GHC.Types.Name.Occurrence.OccName
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Occurrence.OccName
instance GHC.Utils.Outputable.OutputableBndr GHC.Types.Name.Occurrence.OccName
instance GHC.Types.Unique.Uniquable GHC.Types.Name.Occurrence.OccName
instance GHC.Utils.Binary.Binary GHC.Types.Name.Occurrence.OccName
instance GHC.Utils.Binary.Binary GHC.Types.Name.Occurrence.NameSpace


module GHC.Data.FastString.Env

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DFastStringEnv if the set
--   eventually gets converted into a list or folded over in a way where
--   the order changes the generated code.
type FastStringEnv a = UniqFM FastString a
mkFsEnv :: [(FastString, a)] -> FastStringEnv a
emptyFsEnv :: FastStringEnv a
unitFsEnv :: FastString -> a -> FastStringEnv a
extendFsEnv_C :: (a -> a -> a) -> FastStringEnv a -> FastString -> a -> FastStringEnv a
extendFsEnv_Acc :: (a -> b -> b) -> (a -> b) -> FastStringEnv b -> FastString -> a -> FastStringEnv b
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
extendFsEnvList :: FastStringEnv a -> [(FastString, a)] -> FastStringEnv a
extendFsEnvList_C :: (a -> a -> a) -> FastStringEnv a -> [(FastString, a)] -> FastStringEnv a
filterFsEnv :: (elt -> Bool) -> FastStringEnv elt -> FastStringEnv elt
plusFsEnv :: FastStringEnv a -> FastStringEnv a -> FastStringEnv a
plusFsEnv_C :: (a -> a -> a) -> FastStringEnv a -> FastStringEnv a -> FastStringEnv a
alterFsEnv :: (Maybe a -> Maybe a) -> FastStringEnv a -> FastString -> FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
lookupFsEnv_NF :: FastStringEnv a -> FastString -> a
delFromFsEnv :: FastStringEnv a -> FastString -> FastStringEnv a
delListFromFsEnv :: FastStringEnv a -> [FastString] -> FastStringEnv a
elemFsEnv :: FastString -> FastStringEnv a -> Bool
mapFsEnv :: (elt1 -> elt2) -> FastStringEnv elt1 -> FastStringEnv elt2
type DFastStringEnv a = UniqDFM FastString a
mkDFsEnv :: [(FastString, a)] -> DFastStringEnv a
emptyDFsEnv :: DFastStringEnv a
dFsEnvElts :: DFastStringEnv a -> [a]
lookupDFsEnv :: DFastStringEnv a -> FastString -> Maybe a


-- | This is where we define a mapping from Uniques to their associated
--   known-key Names for things associated with tuples and sums. We use
--   this mapping while deserializing known-key Names in interface file
--   symbol tables, which are encoded as their Unique. See Note [Symbol
--   table representation of names] for details.
module GHC.Builtin.Uniques

-- | Get the <a>Name</a> associated with a known-key <a>Unique</a>.
knownUniqueName :: Unique -> Maybe Name
mkSumTyConUnique :: Arity -> Unique
mkSumDataConUnique :: ConTagZ -> Arity -> Unique
mkTupleTyConUnique :: Boxity -> Arity -> Unique
mkTupleDataConUnique :: Boxity -> Arity -> Unique
mkCTupleTyConUnique :: Arity -> Unique
mkCTupleDataConUnique :: Arity -> Unique
mkCTupleSelIdUnique :: ConTagZ -> Arity -> Unique
mkAlphaTyVarUnique :: Int -> Unique
mkPrimOpIdUnique :: Int -> Unique
mkPrimOpWrapperUnique :: Int -> Unique
mkPreludeMiscIdUnique :: Int -> Unique
mkPreludeDataConUnique :: Arity -> Unique
mkPreludeTyConUnique :: Int -> Unique
mkPreludeClassUnique :: Int -> Unique
mkCoVarUnique :: Int -> Unique
mkVarOccUnique :: FastString -> Unique
mkDataOccUnique :: FastString -> Unique
mkTvOccUnique :: FastString -> Unique
mkTcOccUnique :: FastString -> Unique
mkRegSingleUnique :: Int -> Unique
mkRegPairUnique :: Int -> Unique
mkRegClassUnique :: Int -> Unique
mkRegSubUnique :: Int -> Unique
mkCostCentreUnique :: Int -> Unique
mkBuiltinUnique :: Int -> Unique
mkPseudoUniqueD :: Int -> Unique
mkPseudoUniqueE :: Int -> Unique
mkPseudoUniqueH :: Int -> Unique
tyConRepNameUnique :: Unique -> Unique
dataConWorkerUnique :: Unique -> Unique
dataConTyRepNameUnique :: Unique -> Unique
initTyVarUnique :: Unique
initExitJoinUnique :: Unique


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see
--   <a>GHC.Types.Name.Occurrence#name_types</a></li>
--   <li><a>RdrName</a>: see <a>GHC.Types.Name.Reader#name_types</a></li>
--   <li><a>Name</a>: see <a>GHC.Types.Name#name_types</a></li>
--   <li><a>Id</a> represents names that not only have a <a>Name</a> but
--   also a <a>Type</a> and some additional details (a <a>IdInfo</a> and
--   one of LocalIdDetails or GlobalIdDetails) that are added, modified and
--   inspected by various compiler passes. These <a>Var</a> names may
--   either be global or local, see <a>GHC.Types.Var#globalvslocal</a></li>
--   <li><a>Var</a>: see <a>GHC.Types.Var#name_types</a></li>
--   </ul>
module GHC.Types.Id

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Identifier
type Id = Var

-- | Is this a value-level (i.e., computationally relevant)
--   <a>Var</a>entifier? Satisfies <tt>isId = not . isTyVar</tt>.
isId :: Var -> Bool
type InVar = Var
type InId = Id
type OutVar = Var
type OutId = Id

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>GHC.Types.Var.Var#globalvslocal</a>
mkGlobalId :: IdDetails -> Name -> Type -> IdInfo -> Id

-- | Make a global <a>Id</a> without any extra information at all
mkVanillaGlobal :: Name -> Type -> Id

-- | Make a global <a>Id</a> with no global information but some generic
--   <a>IdInfo</a>
mkVanillaGlobalWithInfo :: Name -> Type -> IdInfo -> Id

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>GHC.Types.Var#globalvslocal</a>
mkLocalId :: HasDebugCallStack => Name -> Mult -> Type -> Id

-- | Make a local CoVar
mkLocalCoVar :: Name -> Type -> CoVar

-- | Like <a>mkLocalId</a>, but checks the type to see if it should make a
--   covar
mkLocalIdOrCoVar :: Name -> Mult -> Type -> Id
mkLocalIdWithInfo :: HasDebugCallStack => Name -> Mult -> Type -> IdInfo -> Id

-- | Create a local <a>Id</a> that is marked as exported. This prevents
--   things attached to it from being removed as dead code. See Note
--   [Exported LocalIds]
mkExportedLocalId :: IdDetails -> Name -> Type -> Id
mkExportedVanillaId :: Name -> Type -> Id

-- | Create a system local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>Var#globalvslocal</a>) that are created by the compiler out of thin
--   air
mkSysLocal :: FastString -> Unique -> Mult -> Type -> Id
mkSysLocalM :: MonadUnique m => FastString -> Mult -> Type -> m Id

-- | Like <a>mkSysLocal</a>, but checks to see if we have a covar type
mkSysLocalOrCoVar :: FastString -> Unique -> Mult -> Type -> Id
mkSysLocalOrCoVarM :: MonadUnique m => FastString -> Mult -> Type -> m Id

-- | Create a user local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>GHC.Types.Var#globalvslocal</a>) with a name and location that the
--   user might recognize
mkUserLocal :: OccName -> Unique -> Mult -> Type -> SrcSpan -> Id

-- | Like <a>mkUserLocal</a>, but checks if we have a coercion type
mkUserLocalOrCoVar :: OccName -> Unique -> Mult -> Type -> SrcSpan -> Id

-- | Create a template local for a series of types
mkTemplateLocals :: [Type] -> [Id]

-- | Create a template local for a series of type, but start from a
--   specified template local
mkTemplateLocalsNum :: Int -> [Type] -> [Id]

-- | Create a <i>template local</i>: a family of system local <a>Id</a>s in
--   bijection with <tt>Int</tt>s, typically used in unfoldings
mkTemplateLocal :: Int -> Type -> Id
mkScaledTemplateLocal :: Int -> Scaled Type -> Id

-- | Workers get local names. <a>CoreTidy</a> will externalise these if
--   necessary
mkWorkerId :: Unique -> Id -> Type -> Id
idName :: Id -> Name
idType :: Id -> Kind
idMult :: Id -> Mult
idScaledType :: Id -> Scaled Type
idUnique :: Id -> Unique
idInfo :: HasDebugCallStack => Id -> IdInfo
idDetails :: Id -> IdDetails

-- | If the <a>Id</a> is that for a record selector, extract the
--   <a>sel_tycon</a>. Panic otherwise.
recordSelectorTyCon :: Id -> RecSelParent
recordSelectorTyCon_maybe :: Id -> Maybe RecSelParent
setIdName :: Id -> Name -> Id
setIdUnique :: Id -> Unique -> Id

-- | Not only does this set the <a>Id</a> <a>Type</a>, it also evaluates
--   the type to try and reduce space usage
setIdType :: Id -> Type -> Id
setIdMult :: Id -> Mult -> Id
updateIdTypeButNotMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMultM :: Monad m => (Type -> m Type) -> Id -> m Id
setIdExported :: Id -> Id
setIdNotExported :: Id -> Id

-- | If it's a local, make it global
globaliseId :: Id -> Id
localiseId :: Id -> Id
setIdInfo :: Id -> IdInfo -> Id
lazySetIdInfo :: Id -> IdInfo -> Id
modifyIdInfo :: HasDebugCallStack => (IdInfo -> IdInfo) -> Id -> Id
maybeModifyIdInfo :: Maybe IdInfo -> Id -> Id
zapLamIdInfo :: Id -> Id
zapIdDemandInfo :: Id -> Id
zapIdUsageInfo :: Id -> Id
zapIdUsageEnvInfo :: Id -> Id
zapIdUsedOnceInfo :: Id -> Id
zapIdTailCallInfo :: Id -> Id
zapFragileIdInfo :: Id -> Id
zapIdStrictness :: Id -> Id
zapStableUnfolding :: Id -> Id
transferPolyIdInfo :: Id -> [Var] -> Id -> Id
scaleIdBy :: Mult -> Id -> Id

-- | Like <a>scaleIdBy</a>, but skips non-Ids. Useful for scaling a mixed
--   list of ids and tyvars.
scaleVarBy :: Mult -> Var -> Var

-- | <a>isImplicitId</a> tells whether an <a>Id</a>s info is implied by
--   other declarations, so we don't need to put its signature in an
--   interface file, even if it's mentioned in some other interface
--   unfolding.
isImplicitId :: Id -> Bool
isDeadBinder :: Id -> Bool

-- | This predicate says whether the <a>Id</a> has a strict demand placed
--   on it or has a type such that it can always be evaluated strictly (i.e
--   an unlifted type, as of GHC 7.6). We need to check separately whether
--   the <a>Id</a> has a so-called "strict type" because if the demand for
--   the given <tt>id</tt> hasn't been computed yet but <tt>id</tt> has a
--   strict type, we still want <tt>isStrictId id</tt> to be <tt>True</tt>.
isStrictId :: Id -> Bool

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool
isLocalId :: Var -> Bool
isGlobalId :: Var -> Bool
isRecordSelector :: Id -> Bool
isNaughtyRecordSelector :: Id -> Bool
isPatSynRecordSelector :: Id -> Bool
isDataConRecordSelector :: Id -> Bool
isClassOpId :: Id -> Bool
isClassOpId_maybe :: Id -> Maybe Class
isDFunId :: Id -> Bool
isPrimOpId :: Id -> Bool
isPrimOpId_maybe :: Id -> Maybe PrimOp
isFCallId :: Id -> Bool
isFCallId_maybe :: Id -> Maybe ForeignCall
isDataConWorkId :: Id -> Bool
isDataConWorkId_maybe :: Id -> Maybe DataCon
isDataConWrapId :: Id -> Bool
isDataConWrapId_maybe :: Id -> Maybe DataCon
isDataConId_maybe :: Id -> Maybe DataCon

-- | Get from either the worker or the wrapper <a>Id</a> to the
--   <a>DataCon</a>. Currently used only in the desugarer.
--   
--   INVARIANT: <tt>idDataCon (dataConWrapId d) = d</tt>: remember,
--   <a>dataConWrapId</a> can return either the wrapper or the worker
idDataCon :: Id -> DataCon
isConLikeId :: Id -> Bool

-- | Returns true if an application to n args diverges or throws an
--   exception See Note [Dead ends] in <a>GHC.Types.Demand</a>.
isDeadEndId :: Var -> Bool
idIsFrom :: Module -> Id -> Bool

-- | Returns <tt>True</tt> of an <a>Id</a> which may not have a binding,
--   even though it is defined in this module.
hasNoBinding :: Id -> Bool
type JoinId = Id
isJoinId :: Var -> Bool
isJoinId_maybe :: Var -> Maybe JoinArity
idJoinArity :: JoinId -> JoinArity
asJoinId :: Id -> JoinArity -> JoinId
infixl 1 `asJoinId`
asJoinId_maybe :: Id -> Maybe JoinArity -> Id
infixl 1 `asJoinId_maybe`
zapJoinId :: Id -> Id
idInlinePragma :: Id -> InlinePragma
setInlinePragma :: Id -> InlinePragma -> Id
infixl 1 `setInlinePragma`
modifyInlinePragma :: Id -> (InlinePragma -> InlinePragma) -> Id
idInlineActivation :: Id -> Activation
setInlineActivation :: Id -> Activation -> Id
infixl 1 `setInlineActivation`
idRuleMatchInfo :: Id -> RuleMatchInfo

-- | Returns whether the lambda associated with the <a>Id</a> is certainly
--   applied at most once This one is the "business end", called
--   externally. It works on type variables as well as Ids, returning True
--   Its main purpose is to encapsulate the Horrible State Hack See Note
--   [The state-transformer hack] in <a>GHC.Core.Opt.Arity</a>
isOneShotBndr :: Var -> Bool
isProbablyOneShotLambda :: Id -> Bool
setOneShotLambda :: Id -> Id
clearOneShotLambda :: Id -> Id
updOneShotInfo :: Id -> OneShotInfo -> Id
setIdOneShotInfo :: Id -> OneShotInfo -> Id
infixl 1 `setIdOneShotInfo`
isStateHackType :: Type -> Bool

-- | Should we apply the state hack to values of this <a>Type</a>?
stateHackOneShot :: OneShotInfo
typeOneShot :: Type -> OneShotInfo
idArity :: Id -> Arity
idCallArity :: Id -> Arity
idFunRepArity :: Id -> RepArity
idUnfolding :: Id -> Unfolding
realIdUnfolding :: Id -> Unfolding
idSpecialisation :: Id -> RuleInfo
idCoreRules :: Id -> [CoreRule]
idHasRules :: Id -> Bool
idCafInfo :: Id -> CafInfo
infixl 1 `idCafInfo`
idLFInfo_maybe :: Id -> Maybe LambdaFormInfo
idOneShotInfo :: Id -> OneShotInfo

-- | Like <a>idOneShotInfo</a>, but taking the Horrible State Hack in to
--   account See Note [The state-transformer hack] in
--   <a>GHC.Core.Opt.Arity</a>
idStateHackOneShotInfo :: Id -> OneShotInfo
idOccInfo :: Id -> OccInfo
isNeverLevPolyId :: Id -> Bool
setIdUnfolding :: Id -> Unfolding -> Id
infixl 1 `setIdUnfolding`
setCaseBndrEvald :: StrictnessMark -> Id -> Id
setIdArity :: Id -> Arity -> Id
infixl 1 `setIdArity`
setIdCallArity :: Id -> Arity -> Id
infixl 1 `setIdCallArity`
setIdSpecialisation :: Id -> RuleInfo -> Id
infixl 1 `setIdSpecialisation`
setIdCafInfo :: Id -> CafInfo -> Id
setIdOccInfo :: Id -> OccInfo -> Id
infixl 1 `setIdOccInfo`
zapIdOccInfo :: Id -> Id
setIdLFInfo :: Id -> LambdaFormInfo -> Id
setIdDemandInfo :: Id -> Demand -> Id
infixl 1 `setIdDemandInfo`
setIdStrictness :: Id -> StrictSig -> Id
infixl 1 `setIdStrictness`
setIdCprInfo :: Id -> CprSig -> Id
infixl 1 `setIdCprInfo`
idDemandInfo :: Id -> Demand

-- | Accesses the <tt>Id'</tt>s <a>strictnessInfo</a>.
idStrictness :: Id -> StrictSig
idCprInfo :: Id -> CprSig

module GHC.Types.Unique.Supply

-- | Unique Supply
--   
--   A value of type <a>UniqSupply</a> is unique, and it can supply
--   <i>one</i> distinct <a>Unique</a>. Also, from the supply, one can also
--   manufacture an arbitrary number of further <tt>UniqueSupply</tt>
--   values, which will be distinct from the first and from all others.
data UniqSupply

-- | Obtain the <a>Unique</a> from this particular <a>UniqSupply</a>
uniqFromSupply :: UniqSupply -> Unique

-- | Obtain an infinite list of <a>Unique</a> that can be generated by
--   constant splitting of the supply
uniqsFromSupply :: UniqSupply -> [Unique]

-- | Obtain the <a>Unique</a> from this particular <a>UniqSupply</a>, and a
--   new supply
takeUniqFromSupply :: UniqSupply -> (Unique, UniqSupply)
uniqFromMask :: Char -> IO Unique

-- | Create a unique supply out of thin air. The "mask" (Char) supplied is
--   purely cosmetic, making it easier to figure out where a Unique was
--   born. See Note [Uniques and masks].
--   
--   The payload part of the Uniques allocated from this UniqSupply are
--   guaranteed distinct wrt all other supplies, regardless of their
--   "mask". This is achieved by allocating the payload part from a single
--   source of Uniques, namely <a>genSym</a>, shared across all
--   UniqSupply's.
mkSplitUniqSupply :: Char -> IO UniqSupply

-- | Build two <a>UniqSupply</a> from a single one, each of which can
--   supply its own <a>Unique</a>.
splitUniqSupply :: UniqSupply -> (UniqSupply, UniqSupply)

-- | Create an infinite list of <a>UniqSupply</a> from a single one
listSplitUniqSupply :: UniqSupply -> [UniqSupply]

-- | A monad which just gives the ability to obtain <a>Unique</a>s
data UniqSM result

-- | A monad for generating unique identifiers
class Monad m => MonadUnique m

-- | Get a new UniqueSupply
getUniqueSupplyM :: MonadUnique m => m UniqSupply

-- | Get a new unique identifier
getUniqueM :: MonadUnique m => m Unique

-- | Get an infinite list of new unique identifiers
getUniquesM :: MonadUnique m => m [Unique]

-- | Run the <a>UniqSM</a> action, returning the final <a>UniqSupply</a>
initUs :: UniqSupply -> UniqSM a -> (a, UniqSupply)

-- | Run the <a>UniqSM</a> action, discarding the final <a>UniqSupply</a>
initUs_ :: UniqSupply -> UniqSM a -> a
initUniqSupply :: Word -> Int -> IO ()
instance GHC.Types.Unique.Supply.MonadUnique GHC.Types.Unique.Supply.UniqSM
instance GHC.Base.Functor GHC.Types.Unique.Supply.UniqSM
instance GHC.Base.Monad GHC.Types.Unique.Supply.UniqSM
instance GHC.Base.Applicative GHC.Types.Unique.Supply.UniqSM
instance Control.Monad.Fail.MonadFail GHC.Types.Unique.Supply.UniqSM
instance Control.Monad.Fix.MonadFix GHC.Types.Unique.Supply.UniqSM

module GHC.Types.RepType
type UnaryType = Type
type NvUnaryType = Type
isNvUnaryType :: Type -> Bool

-- | Gets rid of the stuff that prevents us from understanding the runtime
--   representation of a type. Including: 1. Casts 2. Newtypes 3. Foralls
--   4. Synonyms But not type/data families, because we don't have the envs
--   to hand.
unwrapType :: Type -> Type

-- | True if the type has zero width.
isVoidTy :: Type -> Bool

-- | Discovers the primitive representation of a <a>Type</a>. Returns a
--   list of <a>PrimRep</a>: it's a list because of the possibility of no
--   runtime representation (void) or multiple (unboxed tuple/sum) See also
--   Note [Getting from RuntimeRep to PrimRep]
typePrimRep :: HasDebugCallStack => Type -> [PrimRep]

-- | Like <a>typePrimRep</a>, but assumes that there is precisely one
--   <a>PrimRep</a> output; an empty list of PrimReps becomes a VoidRep.
--   This assumption holds after unarise, see Note [Post-unarisation
--   invariants]. Before unarise it may or may not hold. See also Note
--   [RuntimeRep and PrimRep] and Note [VoidRep]
typePrimRep1 :: HasDebugCallStack => UnaryType -> PrimRep

-- | Take a type of kind RuntimeRep and extract the list of <a>PrimRep</a>
--   that it encodes. See also Note [Getting from RuntimeRep to PrimRep]
runtimeRepPrimRep :: HasDebugCallStack => SDoc -> Type -> [PrimRep]
typePrimRepArgs :: HasDebugCallStack => Type -> [PrimRep]

-- | A <a>PrimRep</a> is an abstraction of a type. It contains information
--   that the code generator needs in order to pass arguments, return
--   results, and store values of this type. See also Note [RuntimeRep and
--   PrimRep] in <a>GHC.Types.RepType</a> and Note [VoidRep] in
--   <a>GHC.Types.RepType</a>.
data PrimRep
VoidRep :: PrimRep
LiftedRep :: PrimRep

-- | Unlifted pointer
UnliftedRep :: PrimRep

-- | Signed, 8-bit value
Int8Rep :: PrimRep

-- | Signed, 16-bit value
Int16Rep :: PrimRep

-- | Signed, 32-bit value
Int32Rep :: PrimRep

-- | Signed, 64 bit value
Int64Rep :: PrimRep

-- | Signed, word-sized value
IntRep :: PrimRep

-- | Unsigned, 8 bit value
Word8Rep :: PrimRep

-- | Unsigned, 16 bit value
Word16Rep :: PrimRep

-- | Unsigned, 32 bit value
Word32Rep :: PrimRep

-- | Unsigned, 64 bit value
Word64Rep :: PrimRep

-- | Unsigned, word-sized value
WordRep :: PrimRep

-- | A pointer, but <i>not</i> to a Haskell value (use '(Un)liftedRep')
AddrRep :: PrimRep
FloatRep :: PrimRep
DoubleRep :: PrimRep

-- | A vector
VecRep :: Int -> PrimElemRep -> PrimRep

-- | Convert a PrimRep back to a Type. Used only in the unariser to give
--   types to fresh Ids. Really, only the type's representation matters.
--   See also Note [RuntimeRep and PrimRep]
primRepToType :: PrimRep -> Type
countFunRepArgs :: Arity -> Type -> RepArity
countConRepArgs :: DataCon -> RepArity

-- | Find the runtime representation of a <a>TyCon</a>. Defined here to
--   avoid module loops. Returns a list of the register shapes necessary.
--   See also Note [Getting from RuntimeRep to PrimRep]
tyConPrimRep :: HasDebugCallStack => TyCon -> [PrimRep]

-- | Like <a>tyConPrimRep</a>, but assumed that there is precisely zero or
--   one <a>PrimRep</a> output See also Note [Getting from RuntimeRep to
--   PrimRep] and Note [VoidRep]
tyConPrimRep1 :: HasDebugCallStack => TyCon -> PrimRep

-- | Given the arguments of a sum type constructor application, return the
--   unboxed sum rep type.
--   
--   E.g.
--   
--   (# Int# | Maybe Int | (# Int#, Float# #) #)
--   
--   We call `ubxSumRepType [ [IntRep], [LiftedRep], [IntRep, FloatRep] ]`,
--   which returns [WordSlot, PtrSlot, WordSlot, FloatSlot]
--   
--   INVARIANT: Result slots are sorted (via Ord SlotTy), except that at
--   the head of the list we have the slot for the tag.
ubxSumRepType :: [[PrimRep]] -> [SlotTy]
layoutUbxSum :: SortedSlotTys -> [SlotTy] -> [Int]
typeSlotTy :: UnaryType -> Maybe SlotTy
data SlotTy
PtrLiftedSlot :: SlotTy
PtrUnliftedSlot :: SlotTy
WordSlot :: SlotTy
Word64Slot :: SlotTy
FloatSlot :: SlotTy
DoubleSlot :: SlotTy
slotPrimRep :: SlotTy -> PrimRep
primRepSlot :: PrimRep -> SlotTy
instance GHC.Classes.Ord GHC.Types.RepType.SlotTy
instance GHC.Classes.Eq GHC.Types.RepType.SlotTy
instance GHC.Utils.Outputable.Outputable GHC.Types.RepType.SlotTy

module GHC.Types.Basic
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight
pickLR :: LeftOrRight -> (a, a) -> a

-- | A *one-index* constructor tag
--   
--   Type of the tags associated with each constructor possibility or
--   superclass selector
type ConTag = Int

-- | A *zero-indexed* constructor tag
type ConTagZ = Int

-- | Tags are allocated from here for real constructors or for superclass
--   selectors
fIRST_TAG :: ConTag

-- | The number of value arguments that can be applied to a value before it
--   does "real work". So: fib 100 has arity 0 x -&gt; fib x has arity 1
--   See also Note [Definition of arity] in <a>GHC.Core.Opt.Arity</a>
type Arity = Int

-- | Representation Arity
--   
--   The number of represented arguments that can be applied to a value
--   before it does "real work". So: fib 100 has representation arity 0 x
--   -&gt; fib x has representation arity 1 (# x, y #) -&gt; fib (x + y)
--   has representation arity 2
type RepArity = Int

-- | The number of arguments that a join point takes. Unlike the arity of a
--   function, this is a purely syntactic property and is fixed when the
--   join point is created (or converted from a value). Both type and value
--   arguments are counted.
type JoinArity = Int

-- | FullArgCount is the number of type or value arguments in an
--   application, or the number of type or value binders in a lambda. Note:
--   it includes both type and value arguments!
type FullArgCount = Int

-- | A power-of-two alignment
data Alignment
mkAlignment :: Int -> Alignment
alignmentOf :: Int -> Alignment
alignmentBytes :: Alignment -> Int

-- | Is a TyCon a promoted data constructor or just a normal type
--   constructor?
data PromotionFlag
NotPromoted :: PromotionFlag
IsPromoted :: PromotionFlag
isPromoted :: PromotionFlag -> Bool
data FunctionOrData
IsFunction :: FunctionOrData
IsData :: FunctionOrData

-- | Recursivity Flag
data RecFlag
Recursive :: RecFlag
NonRecursive :: RecFlag
isRec :: RecFlag -> Bool
isNonRec :: RecFlag -> Bool
boolToRecFlag :: Bool -> RecFlag
data Origin
FromSource :: Origin
Generated :: Origin
isGenerated :: Origin -> Bool
type RuleName = FastString
pprRuleName :: RuleName -> SDoc
data TopLevelFlag
TopLevel :: TopLevelFlag
NotTopLevel :: TopLevelFlag
isTopLevel :: TopLevelFlag -> Bool
isNotTopLevel :: TopLevelFlag -> Bool

-- | The semantics allowed for overlapping instances for a particular
--   instance. See Note [Safe Haskell isSafeOverlap] (in
--   <a>GHC.Core.InstEnv</a>) for a explanation of the <a>isSafeOverlap</a>
--   field.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# OVERLAPPABLE'</tt>
--   or <tt>'{-# OVERLAPPING'</tt> or <tt>'{-# OVERLAPS'</tt> or <tt>'{-#
--   INCOHERENT'</tt>, <a>AnnClose</a> <tt>`#-}`</tt>,</li>
--   </ul>
data OverlapFlag
OverlapFlag :: OverlapMode -> Bool -> OverlapFlag
[overlapMode] :: OverlapFlag -> OverlapMode
[isSafeOverlap] :: OverlapFlag -> Bool
data OverlapMode

-- | This instance must not overlap another <a>NoOverlap</a> instance.
--   However, it may be overlapped by <a>Overlapping</a> instances, and it
--   may overlap <a>Overlappable</a> instances.
NoOverlap :: SourceText -> OverlapMode

-- | Silently ignore this instance if you find a more specific one that
--   matches the constraint you are trying to resolve
--   
--   Example: constraint (Foo [Int]) instance Foo [Int] instance {-#
--   OVERLAPPABLE #-} Foo [a]
--   
--   Since the second instance has the Overlappable flag, the first
--   instance will be chosen (otherwise its ambiguous which to choose)
Overlappable :: SourceText -> OverlapMode

-- | Silently ignore any more general instances that may be used to solve
--   the constraint.
--   
--   Example: constraint (Foo [Int]) instance {-# OVERLAPPING #-} Foo [Int]
--   instance Foo [a]
--   
--   Since the first instance has the Overlapping flag, the second---more
--   general---instance will be ignored (otherwise it is ambiguous which to
--   choose)
Overlapping :: SourceText -> OverlapMode

-- | Equivalent to having both <a>Overlapping</a> and <a>Overlappable</a>
--   flags.
Overlaps :: SourceText -> OverlapMode

-- | Behave like Overlappable and Overlapping, and in addition pick an
--   arbitrary one if there are multiple matching candidates, and don't
--   worry about later instantiation
--   
--   Example: constraint (Foo [b]) instance {-# INCOHERENT -} Foo [Int]
--   instance Foo [a] Without the Incoherent flag, we'd complain that
--   instantiating <tt>b</tt> would change which instance was chosen. See
--   also note [Incoherent instances] in <a>GHC.Core.InstEnv</a>
Incoherent :: SourceText -> OverlapMode
setOverlapModeMaybe :: OverlapFlag -> Maybe OverlapMode -> OverlapFlag
hasOverlappingFlag :: OverlapMode -> Bool
hasOverlappableFlag :: OverlapMode -> Bool
hasIncoherentFlag :: OverlapMode -> Bool
data Boxity
Boxed :: Boxity
Unboxed :: Boxity
isBoxed :: Boxity -> Bool

-- | A general-purpose pretty-printing precedence type.
newtype PprPrec
PprPrec :: Int -> PprPrec
topPrec :: PprPrec
sigPrec :: PprPrec
opPrec :: PprPrec
funPrec :: PprPrec
starPrec :: PprPrec
appPrec :: PprPrec
maybeParen :: PprPrec -> PprPrec -> SDoc -> SDoc
data TupleSort
BoxedTuple :: TupleSort
UnboxedTuple :: TupleSort
ConstraintTuple :: TupleSort
tupleSortBoxity :: TupleSort -> Boxity
boxityTupleSort :: Boxity -> TupleSort
tupleParens :: TupleSort -> SDoc -> SDoc
sumParens :: SDoc -> SDoc

-- | Pretty print an alternative in an unboxed sum e.g. "| a | |".
pprAlternative :: (a -> SDoc) -> a -> ConTag -> Arity -> SDoc

-- | If the <tt>Id</tt> is a lambda-bound variable then it may have
--   lambda-bound variable info. Sometimes we know whether the lambda
--   binding this variable is a "one-shot" lambda; that is, whether it is
--   applied at most once.
--   
--   This information may be useful in optimisation, as computations may
--   safely be floated inside such a lambda without risk of duplicating
--   work.
--   
--   See also Note [OneShotInfo overview] above.
data OneShotInfo

-- | No information
NoOneShotInfo :: OneShotInfo

-- | The lambda is applied at most once.
OneShotLam :: OneShotInfo

-- | It is always safe to assume that an <tt>Id</tt> has no lambda-bound
--   variable information
noOneShotInfo :: OneShotInfo
hasNoOneShotInfo :: OneShotInfo -> Bool
isOneShotInfo :: OneShotInfo -> Bool
bestOneShot :: OneShotInfo -> OneShotInfo -> OneShotInfo
worstOneShot :: OneShotInfo -> OneShotInfo -> OneShotInfo

-- | identifier Occurrence Information
data OccInfo

-- | There are many occurrences, or unknown occurrences
ManyOccs :: !TailCallInfo -> OccInfo
[occ_tail] :: OccInfo -> !TailCallInfo

-- | Marks unused variables. Sometimes useful for lambda and case-bound
--   variables.
IAmDead :: OccInfo

-- | Occurs exactly once (per branch), not inside a rule
OneOcc :: !InsideLam -> {-# UNPACK #-} !BranchCount -> !InterestingCxt -> !TailCallInfo -> OccInfo
[occ_in_lam] :: OccInfo -> !InsideLam
[occ_n_br] :: OccInfo -> {-# UNPACK #-} !BranchCount
[occ_int_cxt] :: OccInfo -> !InterestingCxt
[occ_tail] :: OccInfo -> !TailCallInfo

-- | This identifier breaks a loop of mutually recursive functions. The
--   field marks whether it is only a loop breaker due to a reference in a
--   rule
IAmALoopBreaker :: !RulesOnly -> !TailCallInfo -> OccInfo
[occ_rules_only] :: OccInfo -> !RulesOnly
[occ_tail] :: OccInfo -> !TailCallInfo
noOccInfo :: OccInfo
seqOccInfo :: OccInfo -> ()
zapFragileOcc :: OccInfo -> OccInfo
isOneOcc :: OccInfo -> Bool
isDeadOcc :: OccInfo -> Bool
isStrongLoopBreaker :: OccInfo -> Bool
isWeakLoopBreaker :: OccInfo -> Bool
isManyOccs :: OccInfo -> Bool
isNoOccInfo :: OccInfo -> Bool
strongLoopBreaker :: OccInfo
weakLoopBreaker :: OccInfo

-- | Inside Lambda
data InsideLam

-- | Occurs inside a non-linear lambda Substituting a redex for this
--   occurrence is dangerous because it might duplicate work.
IsInsideLam :: InsideLam
NotInsideLam :: InsideLam
type BranchCount = Int
oneBranch :: BranchCount

-- | Interesting Context
data InterestingCxt

-- | Function: is applied Data value: scrutinised by a case with at least
--   one non-DEFAULT branch
IsInteresting :: InterestingCxt
NotInteresting :: InterestingCxt
data TailCallInfo
AlwaysTailCalled :: JoinArity -> TailCallInfo
NoTailCallInfo :: TailCallInfo
tailCallInfo :: OccInfo -> TailCallInfo
zapOccTailCallInfo :: OccInfo -> OccInfo
isAlwaysTailCalled :: OccInfo -> Bool

-- | Embedding Projection pair
data EP a
EP :: a -> a -> EP a
[fromEP] :: EP a -> a
[toEP] :: EP a -> a

-- | Default Method Specification
data DefMethSpec ty
VanillaDM :: DefMethSpec ty
GenericDM :: ty -> DefMethSpec ty
data SwapFlag
NotSwapped :: SwapFlag
IsSwapped :: SwapFlag
flipSwap :: SwapFlag -> SwapFlag
unSwap :: SwapFlag -> (a -> a -> b) -> a -> a -> b
isSwapped :: SwapFlag -> Bool
data CompilerPhase
InitialPhase :: CompilerPhase
Phase :: PhaseNum -> CompilerPhase
FinalPhase :: CompilerPhase

-- | Phase Number
type PhaseNum = Int
data Activation
AlwaysActive :: Activation
ActiveBefore :: SourceText -> PhaseNum -> Activation
ActiveAfter :: SourceText -> PhaseNum -> Activation
FinalActive :: Activation
NeverActive :: Activation
isActive :: CompilerPhase -> Activation -> Bool
competesWith :: Activation -> Activation -> Bool
isNeverActive :: Activation -> Bool
isAlwaysActive :: Activation -> Bool
activeInFinalPhase :: Activation -> Bool
activateAfterInitial :: Activation
activateDuringFinal :: Activation

-- | Rule Match Information
data RuleMatchInfo
ConLike :: RuleMatchInfo
FunLike :: RuleMatchInfo
isConLike :: RuleMatchInfo -> Bool
isFunLike :: RuleMatchInfo -> Bool

-- | Inline Specification
data InlineSpec
Inline :: InlineSpec
Inlinable :: InlineSpec
NoInline :: InlineSpec
NoUserInlinePrag :: InlineSpec
noUserInlineSpec :: InlineSpec -> Bool
data InlinePragma
InlinePragma :: SourceText -> InlineSpec -> Maybe Arity -> Activation -> RuleMatchInfo -> InlinePragma
[inl_src] :: InlinePragma -> SourceText
[inl_inline] :: InlinePragma -> InlineSpec
[inl_sat] :: InlinePragma -> Maybe Arity
[inl_act] :: InlinePragma -> Activation
[inl_rule] :: InlinePragma -> RuleMatchInfo
defaultInlinePragma :: InlinePragma
alwaysInlinePragma :: InlinePragma
neverInlinePragma :: InlinePragma
dfunInlinePragma :: InlinePragma
isDefaultInlinePragma :: InlinePragma -> Bool
isInlinePragma :: InlinePragma -> Bool
isInlinablePragma :: InlinePragma -> Bool
isAnyInlinePragma :: InlinePragma -> Bool
inlinePragmaSpec :: InlinePragma -> InlineSpec
inlinePragmaSat :: InlinePragma -> Maybe Arity
inlinePragmaActivation :: InlinePragma -> Activation
inlinePragmaRuleMatchInfo :: InlinePragma -> RuleMatchInfo
setInlinePragmaActivation :: InlinePragma -> Activation -> InlinePragma
setInlinePragmaRuleMatchInfo :: InlinePragma -> RuleMatchInfo -> InlinePragma
pprInline :: InlinePragma -> SDoc
pprInlineDebug :: InlinePragma -> SDoc
data SuccessFlag
Succeeded :: SuccessFlag
Failed :: SuccessFlag
succeeded :: SuccessFlag -> Bool
failed :: SuccessFlag -> Bool
successIf :: Bool -> SuccessFlag

-- | An integer or infinity
data IntWithInf

-- | A representation of infinity
infinity :: IntWithInf

-- | Turn a positive number into an <a>IntWithInf</a>, where 0 represents
--   infinity
treatZeroAsInf :: Int -> IntWithInf

-- | Inject any integer into an <a>IntWithInf</a>
mkIntWithInf :: Int -> IntWithInf
intGtLimit :: Int -> IntWithInf -> Bool
data SpliceExplicitFlag

-- | <a>=</a> $(f x y)
ExplicitSplice :: SpliceExplicitFlag

-- | <a>=</a> f x y, i.e. a naked top level expression
ImplicitSplice :: SpliceExplicitFlag

-- | Flag to see whether we're type-checking terms or kind-checking types
data TypeOrKind
TypeLevel :: TypeOrKind
KindLevel :: TypeOrKind
isTypeLevel :: TypeOrKind -> Bool
isKindLevel :: TypeOrKind -> Bool
data ForeignSrcLang
LangC :: ForeignSrcLang
LangCxx :: ForeignSrcLang
LangObjc :: ForeignSrcLang
LangObjcxx :: ForeignSrcLang
LangAsm :: ForeignSrcLang
RawObject :: ForeignSrcLang
instance Data.Data.Data GHC.Types.Basic.LeftOrRight
instance GHC.Classes.Eq GHC.Types.Basic.LeftOrRight
instance GHC.Classes.Ord GHC.Types.Basic.Alignment
instance GHC.Classes.Eq GHC.Types.Basic.Alignment
instance GHC.Classes.Eq GHC.Types.Basic.OneShotInfo
instance Data.Data.Data GHC.Types.Basic.PromotionFlag
instance GHC.Classes.Eq GHC.Types.Basic.PromotionFlag
instance Data.Data.Data GHC.Types.Basic.FunctionOrData
instance GHC.Classes.Ord GHC.Types.Basic.FunctionOrData
instance GHC.Classes.Eq GHC.Types.Basic.FunctionOrData
instance Data.Data.Data GHC.Types.Basic.TopLevelFlag
instance Data.Data.Data GHC.Types.Basic.Boxity
instance GHC.Classes.Eq GHC.Types.Basic.Boxity
instance Data.Data.Data GHC.Types.Basic.RecFlag
instance GHC.Classes.Eq GHC.Types.Basic.RecFlag
instance Data.Data.Data GHC.Types.Basic.Origin
instance GHC.Classes.Eq GHC.Types.Basic.Origin
instance Data.Data.Data GHC.Types.Basic.OverlapMode
instance GHC.Classes.Eq GHC.Types.Basic.OverlapMode
instance Data.Data.Data GHC.Types.Basic.OverlapFlag
instance GHC.Classes.Eq GHC.Types.Basic.OverlapFlag
instance GHC.Show.Show GHC.Types.Basic.PprPrec
instance GHC.Classes.Ord GHC.Types.Basic.PprPrec
instance GHC.Classes.Eq GHC.Types.Basic.PprPrec
instance Data.Data.Data GHC.Types.Basic.TupleSort
instance GHC.Classes.Eq GHC.Types.Basic.TupleSort
instance GHC.Classes.Eq GHC.Types.Basic.InterestingCxt
instance GHC.Classes.Eq GHC.Types.Basic.InsideLam
instance GHC.Classes.Eq GHC.Types.Basic.TailCallInfo
instance GHC.Classes.Eq GHC.Types.Basic.OccInfo
instance GHC.Classes.Eq GHC.Types.Basic.CompilerPhase
instance Data.Data.Data GHC.Types.Basic.Activation
instance GHC.Classes.Eq GHC.Types.Basic.Activation
instance GHC.Show.Show GHC.Types.Basic.RuleMatchInfo
instance Data.Data.Data GHC.Types.Basic.RuleMatchInfo
instance GHC.Classes.Eq GHC.Types.Basic.RuleMatchInfo
instance GHC.Show.Show GHC.Types.Basic.InlineSpec
instance Data.Data.Data GHC.Types.Basic.InlineSpec
instance GHC.Classes.Eq GHC.Types.Basic.InlineSpec
instance Data.Data.Data GHC.Types.Basic.InlinePragma
instance GHC.Classes.Eq GHC.Types.Basic.InlinePragma
instance GHC.Classes.Eq GHC.Types.Basic.IntWithInf
instance Data.Data.Data GHC.Types.Basic.SpliceExplicitFlag
instance GHC.Classes.Eq GHC.Types.Basic.TypeOrKind
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.TypeOrKind
instance GHC.Classes.Ord GHC.Types.Basic.IntWithInf
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.IntWithInf
instance GHC.Num.Num GHC.Types.Basic.IntWithInf
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.InlinePragma
instance GHC.Utils.Binary.Binary GHC.Types.Basic.InlinePragma
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.InlineSpec
instance GHC.Utils.Binary.Binary GHC.Types.Basic.InlineSpec
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.RuleMatchInfo
instance GHC.Utils.Binary.Binary GHC.Types.Basic.RuleMatchInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.Activation
instance GHC.Utils.Binary.Binary GHC.Types.Basic.Activation
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.CompilerPhase
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.SuccessFlag
instance GHC.Utils.Outputable.Outputable (GHC.Types.Basic.DefMethSpec ty)
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.OccInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.TailCallInfo
instance GHC.Base.Semigroup GHC.Types.Basic.InsideLam
instance GHC.Base.Monoid GHC.Types.Basic.InsideLam
instance GHC.Base.Semigroup GHC.Types.Basic.InterestingCxt
instance GHC.Base.Monoid GHC.Types.Basic.InterestingCxt
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.TupleSort
instance GHC.Utils.Binary.Binary GHC.Types.Basic.TupleSort
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.OverlapFlag
instance GHC.Utils.Binary.Binary GHC.Types.Basic.OverlapFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.OverlapMode
instance GHC.Utils.Binary.Binary GHC.Types.Basic.OverlapMode
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.Origin
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.RecFlag
instance GHC.Utils.Binary.Binary GHC.Types.Basic.RecFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.Boxity
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.TopLevelFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.FunctionOrData
instance GHC.Utils.Binary.Binary GHC.Types.Basic.FunctionOrData
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.PromotionFlag
instance GHC.Utils.Binary.Binary GHC.Types.Basic.PromotionFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.SwapFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.OneShotInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.Alignment
instance GHC.Utils.Outputable.OutputableP env GHC.Types.Basic.Alignment
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.LeftOrRight
instance GHC.Utils.Binary.Binary GHC.Types.Basic.LeftOrRight


-- | Main functions for manipulating types and type-related things
module GHC.Core.Type
data Type

-- | Argument Flag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, TyCoVarBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ArgFlag
Invisible :: Specificity -> ArgFlag
Required :: ArgFlag
pattern Specified :: ArgFlag
pattern Inferred :: ArgFlag

-- | The non-dependent version of <a>ArgFlag</a>. See Note [AnonArgFlag]
--   Appears here partly so that it's together with its friends ArgFlag and
--   ForallVisFlag, but also because it is used in IfaceType, rather early
--   in the compilation chain
data AnonArgFlag

-- | Used for <tt>(-&gt;)</tt>: an ordinary non-dependent arrow. The
--   argument is visible in source code.
VisArg :: AnonArgFlag

-- | Used for <tt>(=&gt;)</tt>: a non-dependent predicate arrow. The
--   argument is invisible in source code.
InvisArg :: AnonArgFlag

-- | Whether an <a>Invisible</a> argument may appear in source Haskell.
data Specificity

-- | the argument may not appear in source Haskell, it is only inferred.
InferredSpec :: Specificity

-- | the argument may appear in source Haskell, but isn't required.
SpecifiedSpec :: Specificity

-- | The key representation of types within the compiler
type KindOrType = Type

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Type or kind Variable
type TyVar = Var

-- | Is this a type-level (i.e., computationally irrelevant, thus erasable)
--   variable? Satisfies <tt>isTyVar = not . isId</tt>.
isTyVar :: Var -> Bool

-- | Type or Coercion Variable
type TyCoVar = Id

-- | A <a>TyCoBinder</a> represents an argument to a function. TyCoBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [TyCoBinders]
data TyCoBinder

-- | Variable Binder
--   
--   A <a>TyCoVarBinder</a> is the binder of a ForAllTy It's convenient to
--   define this synonym here rather its natural home in
--   <a>GHC.Core.TyCo.Rep</a>, because it's used in
--   GHC.Core.DataCon.hs-boot
--   
--   A <a>TyVarBinder</a> is a binder with only TyVar
type TyCoVarBinder = VarBndr TyCoVar ArgFlag
type TyVarBinder = VarBndr TyVar ArgFlag

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type

-- | A shorthand for data with an attached <a>Mult</a> element (the
--   multiplicity).
data Scaled a

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   <a>GHC.Tc.TyCl</a>
type KnotTied ty = ty
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]

-- | Attempts to obtain the type variable underlying a <a>Type</a>, and
--   panics with the given message if this is not a type variable type. See
--   also <a>getTyVar_maybe</a>
getTyVar :: String -> Type -> TyVar

-- | Attempts to obtain the type variable underlying a <a>Type</a>
getTyVar_maybe :: Type -> Maybe TyVar

-- | Attempts to obtain the type variable underlying a <a>Type</a>, without
--   any expansion
repGetTyVar_maybe :: Type -> Maybe TyVar

-- | If the type is a tyvar, possibly under a cast, returns it, along with
--   the coercion. Thus, the co is :: kind tv ~N kind ty
getCastedTyVar_maybe :: Type -> Maybe (TyVar, CoercionN)
tyVarKind :: TyVar -> Kind

-- | The type or kind of the <a>Var</a> in question
varType :: Var -> Kind

-- | Applies a type to another, as in e.g. <tt>k a</tt>
mkAppTy :: Type -> Type -> Type
mkAppTys :: Type -> [Type] -> Type

-- | Attempts to take a type application apart, as in
--   <a>splitAppTy_maybe</a>, and panics if this is not possible
splitAppTy :: Type -> (Type, Type)

-- | Recursively splits a type as far as is possible, leaving a residual
--   type being applied to and the type arguments applied to it. Never
--   fails, even if that means returning an empty list of type
--   applications.
splitAppTys :: Type -> (Type, [Type])

-- | Like <a>splitAppTys</a>, but doesn't look through type synonyms
repSplitAppTys :: HasDebugCallStack => Type -> (Type, [Type])

-- | Attempt to take a type application apart, whether it is a function,
--   type constructor, or plain type application. Note that type family
--   applications are NEVER unsaturated by this!
splitAppTy_maybe :: Type -> Maybe (Type, Type)

-- | Does the AppTy split as in <a>splitAppTy_maybe</a>, but assumes that
--   any Core view stuff is already done
repSplitAppTy_maybe :: HasDebugCallStack => Type -> Maybe (Type, Type)

-- | Does the AppTy split as in <tt>tcSplitAppTy_maybe</tt>, but assumes
--   that any coreView stuff is already done. Refuses to look through (c
--   =&gt; t)
tcRepSplitAppTy_maybe :: Type -> Maybe (Type, Type)
mkFunTy :: AnonArgFlag -> Mult -> Type -> Type -> Type
infixr 3 `mkFunTy`
mkVisFunTy :: Mult -> Type -> Type -> Type
infixr 3 `mkVisFunTy`
mkInvisFunTy :: Mult -> Type -> Type -> Type
infixr 3 `mkInvisFunTy`

-- | Make nested arrow types
mkVisFunTys :: [Scaled Type] -> Type -> Type

-- | Special, common, case: Arrow type with mult Many
mkVisFunTyMany :: Type -> Type -> Type
infixr 3 `mkVisFunTyMany`
mkInvisFunTyMany :: Type -> Type -> Type
infixr 3 `mkInvisFunTyMany`
mkVisFunTysMany :: [Type] -> Type -> Type
mkInvisFunTysMany :: [Type] -> Type -> Type

-- | Attempts to extract the multiplicity, argument and result types from a
--   type, and panics if that is not possible. See also
--   <a>splitFunTy_maybe</a>
splitFunTy :: Type -> (Mult, Type, Type)

-- | Attempts to extract the multiplicity, argument and result types from a
--   type
splitFunTy_maybe :: Type -> Maybe (Mult, Type, Type)
splitFunTys :: Type -> ([Scaled Type], Type)

-- | Extract the function result type and panic if that is not possible
funResultTy :: Type -> Type

-- | Just like <a>piResultTys</a> but for a single argument Try not to
--   iterate <a>piResultTy</a>, because it's inefficient to substitute one
--   variable at a time; instead use 'piResultTys"
--   
--   Extract the function argument type and panic if that is not possible
funArgTy :: Type -> Type

-- | A key function: builds a <a>TyConApp</a> or <a>FunTy</a> as
--   appropriate to its arguments. Applies its arguments to the constructor
--   from left to right.
mkTyConApp :: TyCon -> [Type] -> Type

-- | Create the plain type constructor type which has been applied to no
--   type arguments at all.
mkTyConTy :: TyCon -> Type

-- | Given a <tt>RuntimeRep</tt>, applies <tt>TYPE</tt> to it. See Note
--   [TYPE and RuntimeRep] in GHC.Builtin.Types.Prim.
tYPE :: Type -> Type

-- | The same as <tt>fst . splitTyConApp</tt>
tyConAppTyCon_maybe :: Type -> Maybe TyCon

-- | Retrieve the tycon heading this type, if there is one. Does <i>not</i>
--   look through synonyms.
tyConAppTyConPicky_maybe :: Type -> Maybe TyCon

-- | The same as <tt>snd . splitTyConApp</tt>
tyConAppArgs_maybe :: Type -> Maybe [Type]
tyConAppTyCon :: Type -> TyCon
tyConAppArgs :: Type -> [Type]

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor
splitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor. Panics if
--   that is not possible. See also <a>splitTyConApp_maybe</a>
splitTyConApp :: Type -> (TyCon, [Type])
tyConAppArgN :: Int -> Type -> Type

-- | Split a type constructor application into its type constructor and
--   applied types. Note that this may fail in the case of a <a>FunTy</a>
--   with an argument of unknown kind <a>FunTy</a> (e.g. <tt>FunTy (a :: k)
--   Int</tt>. since the kind of <tt>a</tt> isn't of the form <tt>TYPE
--   rep</tt>). Consequently, you may need to zonk your type before using
--   this function.
--   
--   This does *not* split types headed with (=&gt;), as that's not a TyCon
--   in the type-checker.
--   
--   If you only need the <a>TyCon</a>, consider using
--   <tt>tcTyConAppTyCon_maybe</tt>.
tcSplitTyConApp_maybe :: HasCallStack => Type -> Maybe (TyCon, [Type])

-- | Attempts to tease a list type apart and gives the type of the elements
--   if successful (looks through type synonyms)
splitListTyConApp_maybe :: Type -> Maybe Type

-- | Like <a>splitTyConApp_maybe</a>, but doesn't look through synonyms.
--   This assumes the synonyms have already been dealt with.
repSplitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])

-- | Like <a>tcSplitTyConApp_maybe</a>, but doesn't look through synonyms.
--   This assumes the synonyms have already been dealt with.
--   
--   Moreover, for a FunTy, it only succeeds if the argument types have
--   enough info to extract the runtime-rep arguments that the funTyCon
--   requires. This will usually be true; but may be temporarily false
--   during canonicalization: see Note [Decomposing FunTy] in
--   GHC.Tc.Solver.Canonical and Note [The Purely Kinded Type Invariant
--   (PKTI)] in GHC.Tc.Gen.HsType, Wrinkle around FunTy
tcRepSplitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])

-- | Like <tt>mkTyCoForAllTy</tt>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: TyCoVar -> ArgFlag -> Type -> Type

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [TyCoVarBinder] -> Type -> Type

-- | Wraps foralls over the type using the provided <a>InvisTVBinder</a>s
--   from left to right
mkInvisForAllTys :: [InvisTVBinder] -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Inferred</a>, a common case
mkTyCoInvForAllTys :: [TyCoVar] -> Type -> Type

-- | Like <a>mkForAllTy</a>, but assumes the variable is dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTys :: [TyVar] -> Type -> Type

-- | Like mkForAllTys, but assumes all variables are dependent and visible
mkVisForAllTys :: [TyVar] -> Type -> Type

-- | Make a dependent forall over an <a>Inferred</a> variable
mkTyCoInvForAllTy :: TyCoVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTy</a>, but tv should be a tyvar
mkInfForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTys</a>, but tvs should be a list of tyvar
mkInfForAllTys :: [TyVar] -> Type -> Type

-- | Take a ForAllTy apart, returning the list of tycovars and the result
--   type. This always succeeds, even if it returns only an empty list.
--   Note that the result type returned may have free variables that were
--   bound by a forall.
splitForAllTyCoVars :: Type -> ([TyCoVar], Type)

-- | Like <a>splitForAllTyCoVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Required</a> type variable binders. Furthermore, each returned
--   tyvar is annotated with <tt>()</tt>.
splitForAllReqTVBinders :: Type -> ([ReqTVBinder], Type)

-- | Like <a>splitForAllTyCoVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Invisible</a> type variable binders. Furthermore, each returned
--   tyvar is annotated with its <a>Specificity</a>.
splitForAllInvisTVBinders :: Type -> ([InvisTVBinder], Type)

-- | Like <a>splitPiTys</a> but split off only <i>named</i> binders and
--   returns <a>TyCoVarBinder</a>s rather than <a>TyCoBinder</a>s
splitForAllTyCoVarBinders :: Type -> ([TyCoVarBinder], Type)

-- | Attempts to take a forall type apart, but only if it's a proper
--   forall, with a named binder
splitForAllTyCoVar_maybe :: Type -> Maybe (TyCoVar, Type)

-- | Take a forall type apart, or panics if that is not possible.
splitForAllTyCoVar :: Type -> (TyCoVar, Type)

-- | Like <a>splitForAllTyCoVar_maybe</a>, but only returns Just if it is a
--   tyvar binder.
splitForAllTyVar_maybe :: Type -> Maybe (TyCoVar, Type)

-- | Like <a>splitForAllTyCoVar_maybe</a>, but only returns Just if it is a
--   covar binder.
splitForAllCoVar_maybe :: Type -> Maybe (TyCoVar, Type)

-- | Attempts to take a forall type apart; works with proper foralls and
--   functions
splitPiTy_maybe :: Type -> Maybe (TyCoBinder, Type)

-- | Takes a forall type apart, or panics
splitPiTy :: Type -> (TyCoBinder, Type)

-- | Split off all TyCoBinders to a type, splitting both proper foralls and
--   functions
splitPiTys :: Type -> ([TyCoBinder], Type)

-- | Given a list of type-level vars and the free vars of a result kind,
--   makes TyCoBinders, preferring anonymous binders if the variable is, in
--   fact, not dependent. e.g. mkTyConBindersPreferAnon
--   <a>(k:*),(b:k),(c:k)</a> We want (k:*) Named, (b:k) Anon, (c:k) Anon
--   
--   All non-coercion binders are <i>visible</i>.
mkTyConBindersPreferAnon :: [TyVar] -> TyCoVarSet -> [TyConBinder]
mkPiTy :: TyCoBinder -> Type -> Type
mkPiTys :: [TyCoBinder] -> Type -> Type
piResultTy :: HasDebugCallStack => Type -> Type -> Type

-- | (piResultTys f_ty [ty1, .., tyn]) gives the type of (f ty1 .. tyn)
--   where f :: f_ty <a>piResultTys</a> is interesting because: 1.
--   <tt>f_ty</tt> may have more for-alls than there are args 2. Less
--   obviously, it may have fewer for-alls For case 2. think of:
--   piResultTys (forall a.a) [forall b.b, Int] This really can happen, but
--   only (I think) in situations involving undefined. For example:
--   undefined :: forall a. a Term: undefined <tt>(forall b. b-&gt;b)
--   </tt>Int This term should have type (Int -&gt; Int), but notice that
--   there are more type args than foralls in <a>undefined</a>s type.
piResultTys :: HasDebugCallStack => Type -> [Type] -> Type
applyTysX :: [TyVar] -> Type -> [Type] -> Type

-- | Drops all ForAllTys
dropForAlls :: Type -> Type

-- | Given a family instance TyCon and its arg types, return the
--   corresponding family type. E.g:
--   
--   <pre>
--   data family T a
--   data instance T (Maybe b) = MkT b
--   </pre>
--   
--   Where the instance tycon is :RTL, so:
--   
--   <pre>
--   mkFamilyTyConApp :RTL Int  =  T (Maybe Int)
--   </pre>
mkFamilyTyConApp :: TyCon -> [Type] -> Type
buildSynTyCon :: Name -> [KnotTied TyConBinder] -> Kind -> [Role] -> KnotTied Type -> TyCon
mkNumLitTy :: Integer -> Type

-- | Is this a numeric literal. We also look through type synonyms.
isNumLitTy :: Type -> Maybe Integer
mkStrLitTy :: FastString -> Type

-- | Is this a symbol literal. We also look through type synonyms.
isStrLitTy :: Type -> Maybe FastString
mkCharLitTy :: Char -> Type

-- | Is this a char literal? We also look through type synonyms.
isCharLitTy :: Type -> Maybe Char

-- | Is this a type literal (symbol, numeric, or char)?
isLitTy :: Type -> Maybe TyLit
isPredTy :: HasDebugCallStack => Type -> Bool

-- | Extract the RuntimeRep classifier of a type. For instance,
--   <tt>getRuntimeRep_maybe Int = LiftedRep</tt>. Returns <a>Nothing</a>
--   if this is not possible.
getRuntimeRep_maybe :: HasDebugCallStack => Type -> Maybe Type

-- | Given a kind (TYPE rr), extract its RuntimeRep classifier rr. For
--   example, <tt>kindRep_maybe * = Just LiftedRep</tt> Returns
--   <a>Nothing</a> if the kind is not of form (TYPE rr) Treats * and
--   Constraint as the same
kindRep_maybe :: HasDebugCallStack => Kind -> Maybe Type

-- | Extract the RuntimeRep classifier of a type from its kind. For
--   example, <tt>kindRep * = LiftedRep</tt>; Panics if this is not
--   possible. Treats * and Constraint as the same
kindRep :: HasDebugCallStack => Kind -> Type

-- | Make a <a>CastTy</a>. The Coercion must be nominal. Checks the
--   Coercion for reflexivity, dropping it if it's reflexive. See Note
--   [Respecting definitional equality] in <a>GHC.Core.TyCo.Rep</a>
mkCastTy :: Type -> Coercion -> Type
mkCoercionTy :: Coercion -> Type
splitCastTy_maybe :: Type -> Maybe (Type, Coercion)

-- | Is this type a custom user error? If so, give us the kind and the
--   error message.
userTypeError_maybe :: Type -> Maybe Type

-- | Render a type corresponding to a user type error into a SDoc.
pprUserTypeErrorTy :: Type -> SDoc

-- | Get the type on the LHS of a coercion induced by a type/data family
--   instance.
coAxNthLHS :: CoAxiom br -> Int -> Type
stripCoercionTy :: Type -> Coercion

-- | Like <a>splitPiTys</a>, but returns only *invisible* binders,
--   including constraints. Stops at the first visible binder.
splitInvisPiTys :: Type -> ([TyCoBinder], Type)

-- | Same as <a>splitInvisPiTys</a>, but stop when - you have found
--   <tt>n</tt> <a>TyCoBinder</a>s, - or you run out of invisible binders
splitInvisPiTysN :: Int -> Type -> ([TyCoBinder], Type)
invisibleTyBndrCount :: Type -> Int

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   invisible (i.e., <a>Inferred</a> or <a>Specified</a>) arguments.
filterOutInvisibleTypes :: TyCon -> [Type] -> [Type]

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   <a>Inferred</a> arguments.
filterOutInferredTypes :: TyCon -> [Type] -> [Type]

-- | Given a <a>TyCon</a> and a list of argument types, partition the
--   arguments into:
--   
--   <ol>
--   <li><a>Inferred</a> or <a>Specified</a> (i.e., invisible) arguments
--   and</li>
--   <li><a>Required</a> (i.e., visible) arguments</li>
--   </ol>
partitionInvisibleTypes :: TyCon -> [Type] -> ([Type], [Type])

-- | Given a list of things paired with their visibilities, partition the
--   things into (invisible things, visible things).
partitionInvisibles :: [(a, ArgFlag)] -> ([a], [a])

-- | Given a <a>TyCon</a> and a list of argument types to which the
--   <a>TyCon</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Wrinkle: consider the following scenario:
--   
--   <pre>
--   T :: forall k. k -&gt; k
--   tyConArgFlags T [forall m. m -&gt; m -&gt; m, S, R, Q]
--   </pre>
--   
--   After substituting, we get
--   
--   <pre>
--   T (forall m. m -&gt; m -&gt; m) :: (forall m. m -&gt; m -&gt; m) -&gt; forall n. n -&gt; n -&gt; n
--   </pre>
--   
--   Thus, the first argument is invisible, <tt>S</tt> is visible,
--   <tt>R</tt> is invisible again, and <tt>Q</tt> is visible.
tyConArgFlags :: TyCon -> [Type] -> [ArgFlag]

-- | Given a <a>Type</a> and a list of argument types to which the
--   <a>Type</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Most of the time, the arguments will be <a>Required</a>, but not
--   always. Consider <tt>f :: forall a. a -&gt; Type</tt>. In <tt>f Type
--   Bool</tt>, the first argument (<tt>Type</tt>) is <a>Specified</a> and
--   the second argument (<tt>Bool</tt>) is <a>Required</a>. It is
--   precisely this sort of higher-rank situation in which
--   <a>appTyArgFlags</a> comes in handy, since <tt>f Type Bool</tt> would
--   be represented in Core using <a>AppTy</a>s. (See also #15792).
appTyArgFlags :: Type -> [Type] -> [ArgFlag]

-- | This describes how a "map" operation over a type/coercion should
--   behave
data TyCoMapper env m
TyCoMapper :: (env -> TyVar -> m Type) -> (env -> CoVar -> m Coercion) -> (env -> CoercionHole -> m Coercion) -> (env -> TyCoVar -> ArgFlag -> m (env, TyCoVar)) -> (TyCon -> m TyCon) -> TyCoMapper env m
[tcm_tyvar] :: TyCoMapper env m -> env -> TyVar -> m Type
[tcm_covar] :: TyCoMapper env m -> env -> CoVar -> m Coercion

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcm_hole] :: TyCoMapper env m -> env -> CoercionHole -> m Coercion

-- | The returned env is used in the extended scope
[tcm_tycobinder] :: TyCoMapper env m -> env -> TyCoVar -> ArgFlag -> m (env, TyCoVar)

-- | This is used only for TcTyCons a) To zonk TcTyCons b) To turn TcTyCons
--   into TyCons. See Note [Type checking recursive type and class
--   declarations] in <a>GHC.Tc.TyCl</a>
[tcm_tycon] :: TyCoMapper env m -> TyCon -> m TyCon
mapTyCo :: Monad m => TyCoMapper () m -> (Type -> m Type, [Type] -> m [Type], Coercion -> m Coercion, [Coercion] -> m [Coercion])
mapTyCoX :: Monad m => TyCoMapper env m -> (env -> Type -> m Type, env -> [Type] -> m [Type], env -> Coercion -> m Coercion, env -> [Coercion] -> m [Coercion])
data TyCoFolder env a
TyCoFolder :: (Type -> Maybe Type) -> (env -> TyVar -> a) -> (env -> CoVar -> a) -> (env -> CoercionHole -> a) -> (env -> TyCoVar -> ArgFlag -> env) -> TyCoFolder env a
[tcf_view] :: TyCoFolder env a -> Type -> Maybe Type
[tcf_tyvar] :: TyCoFolder env a -> env -> TyVar -> a
[tcf_covar] :: TyCoFolder env a -> env -> CoVar -> a

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcf_hole] :: TyCoFolder env a -> env -> CoercionHole -> a

-- | The returned env is used in the extended scope
[tcf_tycobinder] :: TyCoFolder env a -> env -> TyCoVar -> ArgFlag -> env
foldTyCo :: Monoid a => TyCoFolder env a -> env -> (Type -> a, [Type] -> a, Coercion -> a, [Coercion] -> a)

-- | Unwrap one <tt>layer</tt> of newtype on a type constructor and its
--   arguments, using an eta-reduced version of the <tt>newtype</tt> if
--   possible. This requires tys to have at least <tt>newTyConInstArity
--   tycon</tt> elements.
newTyConInstRhs :: TyCon -> [Type] -> Type

-- | Do these denote the same level of visibility? <a>Required</a>
--   arguments are visible, others are not. So this function equates
--   <a>Specified</a> and <a>Inferred</a>. Used for printing.
sameVis :: ArgFlag -> ArgFlag -> Bool

-- | Make a named binder
mkTyCoVarBinder :: vis -> TyCoVar -> VarBndr TyCoVar vis

-- | Make many named binders
mkTyCoVarBinders :: vis -> [TyCoVar] -> [VarBndr TyCoVar vis]

-- | Make a named binder <tt>var</tt> should be a type variable
mkTyVarBinder :: vis -> TyVar -> VarBndr TyVar vis

-- | Make many named binders Input vars should be type variables
mkTyVarBinders :: vis -> [TyVar] -> [VarBndr TyVar vis]
tyVarSpecToBinders :: [VarBndr a Specificity] -> [VarBndr a ArgFlag]

-- | Make an anonymous binder
mkAnonBinder :: AnonArgFlag -> Scaled Type -> TyCoBinder

-- | Does this binder bind a variable that is <i>not</i> erased? Returns
--   <a>True</a> for anonymous binders.
isAnonTyCoBinder :: TyCoBinder -> Bool
binderVar :: VarBndr tv argf -> tv
binderVars :: [VarBndr tv argf] -> [tv]
binderType :: VarBndr TyCoVar argf -> Type
binderArgFlag :: VarBndr tv argf -> argf
tyCoBinderType :: TyCoBinder -> Type
tyCoBinderVar_maybe :: TyCoBinder -> Maybe TyCoVar
tyBinderType :: TyBinder -> Type

-- | Extract a relevant type, if there is one.
binderRelevantType_maybe :: TyCoBinder -> Maybe Type

-- | Does this <a>ArgFlag</a> classify an argument that is written in
--   Haskell?
isVisibleArgFlag :: ArgFlag -> Bool

-- | Does this <a>ArgFlag</a> classify an argument that is not written in
--   Haskell?
isInvisibleArgFlag :: ArgFlag -> Bool

-- | Does this binder bind a visible argument?
isVisibleBinder :: TyCoBinder -> Bool

-- | Does this binder bind an invisible argument?
isInvisibleBinder :: TyCoBinder -> Bool
isNamedBinder :: TyCoBinder -> Bool
tyConBindersTyCoBinders :: [TyConBinder] -> [TyCoBinder]

-- | The <tt>FUN</tt> type constructor.
--   
--   <pre>
--   FUN :: forall (m :: Multiplicity) -&gt;
--          forall {rep1 :: RuntimeRep} {rep2 :: RuntimeRep}.
--          TYPE rep1 -&gt; TYPE rep2 -&gt; *
--   </pre>
--   
--   The runtime representations quantification is left inferred. This
--   means they cannot be specified with <tt>-XTypeApplications</tt>.
--   
--   This is a deliberate choice to allow future extensions to the function
--   arrow. To allow visible application a type synonym can be defined:
--   
--   <pre>
--   type Arr :: forall (rep1 :: RuntimeRep) (rep2 :: RuntimeRep).
--               TYPE rep1 -&gt; TYPE rep2 -&gt; Type
--   type Arr = FUN 'Many
--   </pre>
funTyCon :: TyCon
unrestrictedFunTyCon :: TyCon
isTyVarTy :: Type -> Bool

-- | Is this a function?
isFunTy :: Type -> Bool
isCoercionTy :: Type -> Bool
isCoercionTy_maybe :: Type -> Maybe Coercion

-- | Checks whether this is a proper forall (with a named binder)
isForAllTy :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a tyvar binder
isForAllTy_ty :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a covar binder
isForAllTy_co :: Type -> Bool

-- | Is this a function or forall?
isPiTy :: Type -> Bool
isTauTy :: Type -> Bool
isFamFreeTy :: Type -> Bool

-- | Does this type classify a core (unlifted) Coercion? At either role
--   nominal or representational (t1 ~# t2) or (t1 ~R# t2) See Note [Types
--   for coercions, predicates, and evidence] in <a>GHC.Core.TyCo.Rep</a>
isCoVarType :: Type -> Bool
isAtomicTy :: Type -> Bool

-- | Determine whether a type could be the type of a join point of given
--   total arity, according to the polymorphism rule. A join point cannot
--   be polymorphic in its return type, since given join j <tt>a </tt>b x y
--   z = e1 in e2, the types of e1 and e2 must be the same, and a and b are
--   not in scope for e2. (See Note [The polymorphism rule of join points]
--   in <a>GHC.Core</a>.) Returns False also if the type simply doesn't
--   have enough arguments.
--   
--   Note that we need to know how many arguments (type *and* value) the
--   putative join point takes; for instance, if j :: forall a. a -&gt; Int
--   then j could be a binary join point returning an Int, but it could
--   *not* be a unary join point returning a -&gt; Int.
--   
--   TODO: See Note [Excess polymorphism and join points]
isValidJoinPointType :: JoinArity -> Type -> Bool

-- | Does a <a>TyCon</a> (that is applied to some number of arguments) need
--   to be ascribed with an explicit kind signature to resolve ambiguity if
--   rendered as a source-syntax type? (See <tt>Note [When does a tycon
--   application need an explicit kind signature?]</tt> for a full
--   explanation of what this function checks for.)
tyConAppNeedsKindSig :: Bool -> TyCon -> Int -> Bool

-- | Returns Just True if this type is surely lifted, Just False if it is
--   surely unlifted, Nothing if we can't be sure (i.e., it is levity
--   polymorphic), and panics if the kind does not have the shape TYPE r.
isLiftedType_maybe :: HasDebugCallStack => Type -> Maybe Bool

-- | This version considers Constraint to be the same as *. Returns True if
--   the argument is equivalent to Type/Constraint and False otherwise. See
--   Note [Kind Constraint and kind Type]
isLiftedTypeKind :: Kind -> Bool

-- | Returns True if the kind classifies unlifted types (like 'Int#') and
--   False otherwise. Note that this returns False for levity-polymorphic
--   kinds, which may be specialized to a kind that classifies unlifted
--   types.
isUnliftedTypeKind :: Kind -> Bool

-- | Returns True if the kind classifies types which are allocated on the
--   GC'd heap and False otherwise. Note that this returns False for
--   levity-polymorphic kinds, which may be specialized to a kind that
--   classifies AddrRep or even unboxed kinds.
isBoxedTypeKind :: Kind -> Bool
pickyIsLiftedTypeKind :: Kind -> Bool
isLiftedRuntimeRep :: Type -> Bool
isUnliftedRuntimeRep :: Type -> Bool

-- | See <a>isBoxedRuntimeRep_maybe</a>.
isBoxedRuntimeRep :: Type -> Bool
isLiftedLevity :: Type -> Bool
isUnliftedLevity :: Type -> Bool

-- | See <a>Type#type_classification</a> for what an unlifted type is.
--   Panics on levity polymorphic types; See <a>mightBeUnliftedType</a> for
--   a more approximate predicate that behaves better in the presence of
--   levity polymorphism.
isUnliftedType :: HasDebugCallStack => Type -> Bool

-- | See <a>Type#type_classification</a> for what a boxed type is. Panics
--   on levity polymorphic types; See <a>mightBeUnliftedType</a> for a more
--   approximate predicate that behaves better in the presence of levity
--   polymorphism.
isBoxedType :: Type -> Bool

-- | Returns:
--   
--   <ul>
--   <li><a>False</a> if the type is <i>guaranteed</i> lifted or</li>
--   <li><a>True</a> if it is unlifted, OR we aren't sure (e.g. in a
--   levity-polymorphic case)</li>
--   </ul>
mightBeUnliftedType :: Type -> Bool
isUnboxedTupleType :: Type -> Bool
isUnboxedSumType :: Type -> Bool

-- | See <a>Type#type_classification</a> for what an algebraic type is.
--   Should only be applied to <i>types</i>, as opposed to e.g. partially
--   saturated type constructors
isAlgType :: Type -> Bool

-- | Check whether a type is a data family type
isDataFamilyAppType :: Type -> Bool

-- | Returns true of types that are opaque to Haskell.
isPrimitiveType :: Type -> Bool

-- | Computes whether an argument (or let right hand side) should be
--   computed strictly or lazily, based only on its type. Currently, it's
--   just <a>isUnliftedType</a>. Panics on levity-polymorphic types.
isStrictType :: HasDebugCallStack => Type -> Bool

-- | Is this the type <tt>Levity</tt>?
isLevityTy :: Type -> Bool

-- | Is a tyvar of type <tt>Levity</tt>?
isLevityVar :: TyVar -> Bool

-- | Is this the type <a>RuntimeRep</a>?
isRuntimeRepTy :: Type -> Bool

-- | Is a tyvar of type <a>RuntimeRep</a>?
isRuntimeRepVar :: TyVar -> Bool

-- | Is this a type of kind RuntimeRep? (e.g. LiftedRep)
isRuntimeRepKindedTy :: Type -> Bool

-- | Drops prefix of RuntimeRep constructors in <a>TyConApp</a>s. Useful
--   for e.g. dropping 'LiftedRep arguments of unboxed tuple TyCon
--   applications:
--   
--   dropRuntimeRepArgs [ 'LiftedRep, 'IntRep , String, Int# ] == [String,
--   Int#]
dropRuntimeRepArgs :: [Type] -> [Type]

-- | Extract the RuntimeRep classifier of a type. For instance,
--   <tt>getRuntimeRep_maybe Int = LiftedRep</tt>. Panics if this is not
--   possible.
getRuntimeRep :: HasDebugCallStack => Type -> Type

-- | Is this the type <tt>Multiplicity</tt>?
isMultiplicityTy :: Type -> Bool

-- | Is a tyvar of type <tt>Multiplicity</tt>?
isMultiplicityVar :: TyVar -> Bool

-- | Scale a payload by Many
unrestricted :: a -> Scaled a

-- | Scale a payload by One
linear :: a -> Scaled a

-- | Scale a payload by Many; used for type arguments in core
tymult :: a -> Scaled a
mkScaled :: Mult -> a -> Scaled a
irrelevantMult :: Scaled a -> a
scaledSet :: Scaled a -> b -> Scaled b
pattern One :: Mult
pattern Many :: Mult
isOneDataConTy :: Mult -> Bool
isManyDataConTy :: Mult -> Bool

-- | <tt>isLinear t</tt> returns <tt>True</tt> of a if <tt>t</tt> is a type
--   of (curried) function where at least one argument is linear (or
--   otherwise non-unrestricted). We use this function to check whether it
--   is safe to eta reduce an Id in CorePrep. It is always safe to return
--   <a>True</a>, because <a>True</a> deactivates the optimisation.
isLinearType :: Type -> Bool

-- | The key type representing kinds in the compiler.
type Kind = Type
typeKind :: HasDebugCallStack => Type -> Kind
tcTypeKind :: HasDebugCallStack => Type -> Kind

-- | Returns True if a type is levity polymorphic. Should be the same as
--   (isKindLevPoly . typeKind) but much faster. Precondition: The type has
--   kind (TYPE blah)
isTypeLevPoly :: Type -> Bool

-- | Looking past all pi-types, is the end result potentially levity
--   polymorphic? Example: True for (forall r (a :: TYPE r). String -&gt;
--   a) Example: False for (forall r1 r2 (a :: TYPE r1) (b :: TYPE r2). a
--   -&gt; b -&gt; Type)
resultIsLevPoly :: Type -> Bool

-- | Is this kind equivalent to <a>Type</a>?
--   
--   This considers <tt>Constraint</tt> to be distinct from <a>Type</a>.
--   For a version that treats them as the same type, see
--   <a>isLiftedTypeKind</a>.
tcIsLiftedTypeKind :: Kind -> Bool
tcIsConstraintKind :: Kind -> Bool
tcReturnsConstraintKind :: Kind -> Bool

-- | Is this kind equivalent to <tt>TYPE (BoxedRep l)</tt> for some <tt>l
--   :: Levity</tt>?
--   
--   This considers <tt>Constraint</tt> to be distinct from <a>Type</a>.
--   For a version that treats them as the same type, see
--   <a>isLiftedTypeKind</a>.
tcIsBoxedTypeKind :: Kind -> Bool

-- | Is this kind equivalent to <tt>TYPE r</tt> (for some unknown r)?
--   
--   This considers <tt>Constraint</tt> to be distinct from <tt>*</tt>.
tcIsRuntimeTypeKind :: Kind -> Bool
liftedTypeKind :: Kind
unliftedTypeKind :: Kind

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in <a>GHC.Utils.FV</a>.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in <a>GHC.Utils.FV</a> for explanation.
tyCoFVsOfType :: Type -> FV
tyCoFVsBndr :: TyCoVarBinder -> FV -> FV
tyCoFVsVarBndr :: Var -> FV -> FV
tyCoFVsVarBndrs :: [Var] -> FV -> FV
tyCoVarsOfType :: Type -> TyCoVarSet
tyCoVarsOfTypes :: [Type] -> TyCoVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet
coVarsOfType :: Type -> CoVarSet
coVarsOfTypes :: [Type] -> CoVarSet
anyFreeVarsOfType :: (TyCoVar -> Bool) -> Type -> Bool
anyFreeVarsOfTypes :: (TyCoVar -> Bool) -> [Type] -> Bool
noFreeVarsOfType :: Type -> Bool

-- | Retrieve the free variables in this type, splitting them based on
--   whether they are used visibly or invisibly. Invisible ones come first.
splitVisVarsOfType :: Type -> Pair TyCoVarSet
splitVisVarsOfTypes :: [Type] -> Pair TyCoVarSet

-- | Expand out all type synonyms. Actually, it'd suffice to expand out
--   just the ones that discard type variables (e.g. type Funny a = Int)
--   But we don't know which those are currently, so we just expand all.
--   
--   <a>expandTypeSynonyms</a> only expands out type synonyms mentioned in
--   the type, not in the kinds of any TyCon or TyVar mentioned in the
--   type.
--   
--   Keep this synchronized with <tt>synonymTyConsOfType</tt>
expandTypeSynonyms :: Type -> Type
typeSize :: Type -> Int
occCheckExpand :: [Var] -> Type -> Maybe Type

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministically ordered list.
closeOverKindsList :: [TyVar] -> [TyVar]
closeOverKinds :: TyCoVarSet -> TyCoVarSet

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in <a>GHC.Rename.HsType</a>
scopedSort :: [TyCoVar] -> [TyCoVar]

-- | Get the free vars of a type in scoped order
tyCoVarsOfTypeWellScoped :: Type -> [TyVar]

-- | Get the free vars of types in scoped order
tyCoVarsOfTypesWellScoped :: [Type] -> [TyVar]

-- | Type equality on source types. Does not look through <tt>newtypes</tt>
--   or <a>PredType</a>s, but it does look through type synonyms. This
--   first checks that the kinds of the types are equal and then checks
--   whether the types are equal, ignoring casts and coercions. (The kind
--   check is a recursive call, but since all kinds have type
--   <tt>Type</tt>, there is no need to check the types of kinds.) See also
--   Note [Non-trivial definitional equality] in <a>GHC.Core.TyCo.Rep</a>.
eqType :: Type -> Type -> Bool

-- | Compare types with respect to a (presumably) non-empty <a>RnEnv2</a>.
eqTypeX :: RnEnv2 -> Type -> Type -> Bool

-- | Type equality on lists of types, looking through type synonyms but not
--   newtypes.
eqTypes :: [Type] -> [Type] -> Bool
nonDetCmpType :: Type -> Type -> Ordering
nonDetCmpTypes :: [Type] -> [Type] -> Ordering
nonDetCmpTypeX :: RnEnv2 -> Type -> Type -> Ordering
nonDetCmpTypesX :: RnEnv2 -> [Type] -> [Type] -> Ordering

-- | Compare two <a>TyCon</a>s. NB: This should <i>never</i> see
--   <tt>Constraint</tt> (as recognized by Kind.isConstraintKindCon) which
--   is considered a synonym for <a>Type</a> in Core. See Note [Kind
--   Constraint and kind Type] in <a>GHC.Core.Type</a>. See Note
--   [nonDetCmpType nondeterminism]
nonDetCmpTc :: TyCon -> TyCon -> Ordering
eqVarBndrs :: RnEnv2 -> [Var] -> [Var] -> Maybe RnEnv2
seqType :: Type -> ()
seqTypes :: [Type] -> ()

-- | This function strips off the <i>top layer only</i> of a type synonym
--   application (if any) its underlying representation type. Returns
--   <a>Nothing</a> if there is nothing to look through. This function
--   considers <tt>Constraint</tt> to be a synonym of <tt>Type</tt>.
--   
--   By being non-recursive and inlined, this case analysis gets
--   efficiently joined onto the case analysis that the caller is already
--   doing
coreView :: Type -> Maybe Type

-- | Gives the typechecker view of a type. This unwraps synonyms but leaves
--   <tt>Constraint</tt> alone. c.f. <a>coreView</a>, which turns
--   <tt>Constraint</tt> into <a>Type</a>. Returns <a>Nothing</a> if no
--   unwrapping happens. See also Note [coreView vs tcView]
tcView :: Type -> Maybe Type

-- | All type constructors occurring in the type; looking through type
--   synonyms, but not newtypes. When it finds a Class, it returns the
--   class TyCon.
tyConsOfType :: Type -> UniqSet TyCon

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | Type &amp; coercion substitution
--   
--   The following invariants must hold of a <a>TCvSubst</a>:
--   
--   <ol>
--   <li>The in-scope set is needed <i>only</i> to guide the generation of
--   fresh uniques</li>
--   <li>In particular, the <i>kind</i> of the type variables in the
--   in-scope set is not relevant</li>
--   <li>The substitution is only applied ONCE! This is because in general
--   such application will not reach a fixed point.</li>
--   </ol>
data TCvSubst
TCvSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> TCvSubst
emptyTvSubstEnv :: TvSubstEnv
emptyTCvSubst :: TCvSubst
mkEmptyTCvSubst :: InScopeSet -> TCvSubst
mkTCvSubst :: InScopeSet -> (TvSubstEnv, CvSubstEnv) -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
zipTvSubst :: HasDebugCallStack => [TyVar] -> [Type] -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
mkTvSubstPrs :: [(TyVar, Type)] -> TCvSubst
zipTCvSubst :: HasDebugCallStack => [TyCoVar] -> [Type] -> TCvSubst
notElemTCvSubst :: Var -> TCvSubst -> Bool
getTvSubstEnv :: TCvSubst -> TvSubstEnv
setTvSubstEnv :: TCvSubst -> TvSubstEnv -> TCvSubst
zapTCvSubst :: TCvSubst -> TCvSubst
getTCvInScope :: TCvSubst -> InScopeSet

-- | Returns the free variables of the types in the range of a substitution
--   as a non-deterministic set.
getTCvSubstRangeFVs :: TCvSubst -> VarSet
extendTCvInScope :: TCvSubst -> Var -> TCvSubst
extendTCvInScopeList :: TCvSubst -> [Var] -> TCvSubst
extendTCvInScopeSet :: TCvSubst -> VarSet -> TCvSubst
extendTCvSubst :: TCvSubst -> TyCoVar -> Type -> TCvSubst
extendCvSubst :: TCvSubst -> CoVar -> Coercion -> TCvSubst
extendTvSubst :: TCvSubst -> TyVar -> Type -> TCvSubst
extendTvSubstBinderAndInScope :: TCvSubst -> TyCoBinder -> Type -> TCvSubst
extendTvSubstList :: TCvSubst -> [Var] -> [Type] -> TCvSubst
extendTvSubstAndInScope :: TCvSubst -> TyVar -> Type -> TCvSubst
extendTCvSubstList :: TCvSubst -> [Var] -> [Type] -> TCvSubst
extendTvSubstWithClone :: TCvSubst -> TyVar -> TyVar -> TCvSubst
extendTCvSubstWithClone :: TCvSubst -> TyCoVar -> TyCoVar -> TCvSubst
isInScope :: Var -> TCvSubst -> Bool

-- | <tt>(compose env1 env2)(x)</tt> is <tt>env1(env2(x))</tt>; i.e. apply
--   <tt>env2</tt> then <tt>env1</tt>. It assumes that both are idempotent.
--   Typically, <tt>env1</tt> is the refinement to a base substitution
--   <tt>env2</tt>
composeTCvSubstEnv :: InScopeSet -> (TvSubstEnv, CvSubstEnv) -> (TvSubstEnv, CvSubstEnv) -> (TvSubstEnv, CvSubstEnv)

-- | Composes two substitutions, applying the second one provided first,
--   like in function composition.
composeTCvSubst :: TCvSubst -> TCvSubst -> TCvSubst
zipTyEnv :: HasDebugCallStack => [TyVar] -> [Type] -> TvSubstEnv
zipCoEnv :: HasDebugCallStack => [CoVar] -> [Coercion] -> CvSubstEnv
isEmptyTCvSubst :: TCvSubst -> Bool
unionTCvSubst :: TCvSubst -> TCvSubst -> TCvSubst

-- | Substitute within a <a>Type</a> The substitution has to satisfy the
--   invariants described in Note [The substitution invariant].
substTy :: HasCallStack => TCvSubst -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasCallStack => TCvSubst -> [Type] -> [Type]
substScaledTy :: HasCallStack => TCvSubst -> Scaled Type -> Scaled Type
substScaledTys :: HasCallStack => TCvSubst -> [Scaled Type] -> [Scaled Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Type substitution, see <a>zipTvSubst</a>
substTysWith :: [TyVar] -> [Type] -> [Type] -> [Type]

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasCallStack => TCvSubst -> ThetaType -> ThetaType

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: TCvSubst -> Type -> Type

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: TCvSubst -> Type -> Type

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: TCvSubst -> [Type] -> [Type]
substScaledTyUnchecked :: HasCallStack => TCvSubst -> Scaled Type -> Scaled Type
substScaledTysUnchecked :: TCvSubst -> [Scaled Type] -> [Scaled Type]

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: TCvSubst -> ThetaType -> ThetaType

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: TCvSubst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion
substTyVarBndr :: HasCallStack => TCvSubst -> TyVar -> (TCvSubst, TyVar)
substTyVarBndrs :: HasCallStack => TCvSubst -> [TyVar] -> (TCvSubst, [TyVar])
substTyVar :: TCvSubst -> TyVar -> Type
substTyVars :: TCvSubst -> [TyVar] -> [Type]
substVarBndr :: HasCallStack => TCvSubst -> TyCoVar -> (TCvSubst, TyCoVar)
substVarBndrs :: HasCallStack => TCvSubst -> [TyCoVar] -> (TCvSubst, [TyCoVar])
substTyCoBndr :: TCvSubst -> TyCoBinder -> (TCvSubst, TyCoBinder)
cloneTyVarBndr :: TCvSubst -> TyVar -> Unique -> (TCvSubst, TyVar)
cloneTyVarBndrs :: TCvSubst -> [TyVar] -> UniqSupply -> (TCvSubst, [TyVar])
lookupTyVar :: TCvSubst -> TyVar -> Maybe Type

-- | Tidy a Type
--   
--   See Note [Strictness in tidyType and friends]
tidyType :: TidyEnv -> Type -> Type

-- | Tidy a list of Types
--   
--   See Note [Strictness in tidyType and friends]
tidyTypes :: TidyEnv -> [Type] -> [Type]
tidyOpenType :: TidyEnv -> Type -> (TidyEnv, Type)

-- | Grabs the free type variables, tidies them and then uses
--   <a>tidyType</a> to work over the type itself
tidyOpenTypes :: TidyEnv -> [Type] -> (TidyEnv, [Type])
tidyOpenKind :: TidyEnv -> Kind -> (TidyEnv, Kind)
tidyVarBndr :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)

-- | This tidies up a type for printing in an error message, or in an
--   interface file.
--   
--   It doesn't change the uniques at all, just the print names.
tidyVarBndrs :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])

-- | Add the free <a>TyVar</a>s to the env in tidy form, so that we can
--   tidy the type they are free in
tidyFreeTyCoVars :: TidyEnv -> [TyCoVar] -> TidyEnv

-- | Treat a new <a>TyCoVar</a> as a binder, and give it a fresh tidy name
--   using the environment if one has not already been allocated. See also
--   <a>tidyVarBndr</a>
tidyOpenTyCoVar :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)
tidyOpenTyCoVars :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])
tidyTyCoVarOcc :: TidyEnv -> TyCoVar -> TyCoVar

-- | Calls <a>tidyType</a> on a top-level type (i.e. with an empty tidying
--   environment)
tidyTopType :: Type -> Type
tidyKind :: TidyEnv -> Kind -> Kind
tidyTyCoVarBinder :: TidyEnv -> VarBndr TyCoVar vis -> (TidyEnv, VarBndr TyCoVar vis)
tidyTyCoVarBinders :: TidyEnv -> [VarBndr TyCoVar vis] -> (TidyEnv, [VarBndr TyCoVar vis])

-- | Returns <tt>True</tt> for the <a>TyCon</a> of the <tt>Constraint</tt>
--   kind.
isConstraintKindCon :: TyCon -> Bool

-- | Does this classify a type allowed to have values? Responds True to
--   things like *, #, TYPE Lifted, TYPE v, Constraint.
--   
--   True of any sub-kind of OpenTypeKind
classifiesTypeWithValues :: Kind -> Bool

-- | Tests whether the given kind (which should look like <tt>TYPE x</tt>)
--   is something other than a constructor tree (that is, constructors at
--   every node). E.g. True of TYPE k, TYPE (F Int) False of TYPE
--   'LiftedRep
isKindLevPoly :: Kind -> Bool
instance GHC.Enum.Bounded GHC.Core.Type.TypeOrdering
instance GHC.Enum.Enum GHC.Core.Type.TypeOrdering
instance GHC.Classes.Ord GHC.Core.Type.TypeOrdering
instance GHC.Classes.Eq GHC.Core.Type.TypeOrdering


-- | Utilities for efficiently and deterministically computing free
--   variables.
module GHC.Utils.FV
type FV = InterestingVarFun -> VarSet -> VarAcc -> VarAcc

-- | Predicate on possible free variables: returns <tt>True</tt> iff the
--   variable is interesting
type InterestingVarFun = Var -> Bool

-- | Run a free variable computation, returning a list of distinct free
--   variables in deterministic order.
fvVarList :: FV -> [Var]

-- | Run a free variable computation, returning a non-deterministic set of
--   free variables. Don't use if the set will be later converted to a list
--   and the order of that list will impact the generated code.
fvVarSet :: FV -> VarSet

-- | Run a free variable computation, returning a deterministic set of free
--   variables. Note that this is just a wrapper around the version that
--   returns a deterministic list. If you need a list you should use
--   <a>fvVarList</a>.
fvDVarSet :: FV -> DVarSet

-- | Add a variable - when free, to the returned free variables. Ignores
--   duplicates and respects the filtering function.
unitFV :: Id -> FV

-- | Return no free variables.
emptyFV :: FV

-- | Add multiple variables - when free, to the returned free variables.
--   Ignores duplicates and respects the filtering function.
mkFVs :: [Var] -> FV

-- | Union two free variable computations.
unionFV :: FV -> FV -> FV

-- | Union many free variable computations.
unionsFV :: [FV] -> FV

-- | Mark the variable as not free by putting it in scope.
delFV :: Var -> FV -> FV

-- | Mark many free variables as not free.
delFVs :: VarSet -> FV -> FV

-- | Filter a free variable computation.
filterFV :: InterestingVarFun -> FV -> FV

-- | Map a free variable computation over a list and union the results.
mapUnionFV :: (a -> FV) -> [a] -> FV

module GHC.Data.Pair
data Pair a
Pair :: a -> a -> Pair a
[pFst] :: Pair a -> a
[pSnd] :: Pair a -> a
unPair :: Pair a -> (a, a)
toPair :: (a, a) -> Pair a
swap :: Pair a -> Pair a
pLiftFst :: (a -> a) -> Pair a -> Pair a
pLiftSnd :: (a -> a) -> Pair a -> Pair a
instance GHC.Base.Functor GHC.Data.Pair.Pair
instance GHC.Base.Applicative GHC.Data.Pair.Pair
instance Data.Foldable.Foldable GHC.Data.Pair.Pair
instance Data.Traversable.Traversable GHC.Data.Pair.Pair
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Data.Pair.Pair a)
instance (GHC.Base.Semigroup a, GHC.Base.Monoid a) => GHC.Base.Monoid (GHC.Data.Pair.Pair a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Data.Pair.Pair a)


-- | Set-like operations on lists
--   
--   Avoid using them as much as possible
module GHC.Data.List.SetOps

-- | Assumes that the arguments contain no duplicates
unionLists :: (HasDebugCallStack, Outputable a, Eq a) => [a] -> [a] -> [a]

-- | Calculate the set difference of two lists. This is <i>O((m + n) log
--   n)</i>, where we subtract a list of <i>n</i> elements from a list of
--   <i>m</i> elements.
--   
--   Extremely short cases are handled specially: When <i>m</i> or <i>n</i>
--   is 0, this takes <i>O(1)</i> time. When <i>m</i> is 1, it takes
--   <i>O(n)</i> time.
minusList :: Ord a => [a] -> [a] -> [a]

-- | A finite mapping based on equality and association lists.
type Assoc a b = [(a, b)]
assoc :: Eq a => String -> Assoc a b -> a -> b

-- | Lookup key, fail gracefully using Nothing if not found.
assocMaybe :: Eq a => Assoc a b -> a -> Maybe b
assocUsing :: (a -> a -> Bool) -> String -> Assoc a b -> a -> b
assocDefault :: Eq a => b -> Assoc a b -> a -> b
assocDefaultUsing :: (a -> a -> Bool) -> b -> Assoc a b -> a -> b
hasNoDups :: Eq a => [a] -> Bool
removeDups :: (a -> a -> Ordering) -> [a] -> ([a], [NonEmpty a])
findDupsEq :: (a -> a -> Bool) -> [a] -> [NonEmpty a]
equivClasses :: (a -> a -> Ordering) -> [a] -> [NonEmpty a]
getNth :: Outputable a => [a] -> Int -> a


-- | Printing related functions that depend on session state (DynFlags)
module GHC.Driver.Ppr

-- | Show a SDoc as a String with the default user style
showSDoc :: DynFlags -> SDoc -> String

-- | Allows caller to specify the PrintUnqualified to use
showSDocForUser :: DynFlags -> UnitState -> PrintUnqualified -> SDoc -> String
showSDocDebug :: DynFlags -> SDoc -> String
showSDocDump :: SDocContext -> SDoc -> String
showPpr :: Outputable a => DynFlags -> a -> String
pprDebugAndThen :: SDocContext -> (String -> a) -> SDoc -> SDoc -> a
printForUser :: DynFlags -> Handle -> PrintUnqualified -> Depth -> SDoc -> IO ()

-- | Like <a>printSDocLn</a> but specialized with <a>LeftMode</a> and
--   <tt><a>PprCode</a> <a>CStyle</a></tt>. This is typically used to
--   output C-- code.
printForC :: DynFlags -> Handle -> SDoc -> IO ()

-- | Just warn about an assertion failure, recording the given file and
--   line number. Should typically be accessed with the WARN macros
warnPprTrace :: HasCallStack => Bool -> String -> Int -> SDoc -> a -> a

-- | If debug output is on, show some <a>SDoc</a> on the screen
pprTrace :: String -> SDoc -> a -> a

-- | If debug output is on, show some <a>SDoc</a> on the screen
pprTraceWithFlags :: DynFlags -> String -> SDoc -> a -> a
pprTraceM :: Applicative f => String -> SDoc -> f ()
pprTraceDebug :: String -> SDoc -> a -> a

-- | <tt>pprTraceIt desc x</tt> is equivalent to <tt>pprTrace desc (ppr x)
--   x</tt>
pprTraceIt :: Outputable a => String -> a -> a

-- | If debug output is on, show some <a>SDoc</a> on the screen along with
--   a call stack when available.
pprSTrace :: HasCallStack => SDoc -> a -> a

-- | <tt>pprTraceException desc x action</tt> runs action, printing a
--   message if it throws an exception.
pprTraceException :: ExceptionMonad m => String -> SDoc -> m a -> m a


-- | Unit manipulation
module GHC.Unit.State
data UnitState
UnitState :: UnitInfoMap -> PreloadUnitClosure -> UniqFM PackageName IndefUnitId -> Map UnitId UnitId -> Map UnitId UnitId -> [UnitId] -> [Unit] -> !ModuleNameProvidersMap -> !ModuleNameProvidersMap -> Map ModuleName [InstantiatedModule] -> !Bool -> UnitState

-- | A mapping of <a>Unit</a> to <a>UnitInfo</a>. This list is adjusted so
--   that only valid units are here. <a>UnitInfo</a> reflects what was
--   stored *on disk*, except for the <tt>trusted</tt> flag, which is
--   adjusted at runtime. (In particular, some units in this map may have
--   the <tt>exposed</tt> flag be <a>False</a>.)
[unitInfoMap] :: UnitState -> UnitInfoMap

-- | The set of transitively reachable units according to the explicitly
--   provided command line arguments. A fully instantiated VirtUnit may
--   only be replaced by a RealUnit from this set. See Note [VirtUnit to
--   RealUnit improvement]
[preloadClosure] :: UnitState -> PreloadUnitClosure

-- | A mapping of <a>PackageName</a> to <a>IndefUnitId</a>. This is used
--   when users refer to packages in Backpack includes.
[packageNameMap] :: UnitState -> UniqFM PackageName IndefUnitId

-- | A mapping from database unit keys to wired in unit ids.
[wireMap] :: UnitState -> Map UnitId UnitId

-- | A mapping from wired in unit ids to unit keys from the database.
[unwireMap] :: UnitState -> Map UnitId UnitId

-- | The units we're going to link in eagerly. This list should be in
--   reverse dependency order; that is, a unit is always mentioned before
--   the units it depends on.
[preloadUnits] :: UnitState -> [UnitId]

-- | Units which we explicitly depend on (from a command line flag). We'll
--   use this to generate version macros.
[explicitUnits] :: UnitState -> [Unit]

-- | This is a full map from <a>ModuleName</a> to all modules which may
--   possibly be providing it. These providers may be hidden (but we'll
--   still want to report them in error messages), or it may be an
--   ambiguous import.
[moduleNameProvidersMap] :: UnitState -> !ModuleNameProvidersMap

-- | A map, like <a>moduleNameProvidersMap</a>, but controlling plugin
--   visibility.
[pluginModuleNameProvidersMap] :: UnitState -> !ModuleNameProvidersMap

-- | A map saying, for each requirement, what interfaces must be merged
--   together when we use them. For example, if our dependencies are
--   <tt>p[A=&lt;A&gt;]</tt> and
--   <tt>q[A=&lt;A&gt;,B=r[C=&lt;A&gt;]:B]</tt>, then the interfaces to
--   merge for A are <tt>p[A=&lt;A&gt;]:A</tt>,
--   <tt>q[A=&lt;A&gt;,B=r[C=&lt;A&gt;]:B]:A</tt> and
--   <tt>r[C=&lt;A&gt;]:C</tt>.
--   
--   There's an entry in this map for each hole in our home library.
[requirementContext] :: UnitState -> Map ModuleName [InstantiatedModule]

-- | Indicate if we can instantiate units on-the-fly.
--   
--   This should only be true when we are type-checking an indefinite unit.
--   See Note [About units] in GHC.Unit.
[allowVirtualUnits] :: UnitState -> !Bool
type PreloadUnitClosure = UniqSet UnitId

-- | Unit database
data UnitDatabase unit
UnitDatabase :: FilePath -> [GenUnitInfo unit] -> UnitDatabase unit
[unitDatabasePath] :: UnitDatabase unit -> FilePath
[unitDatabaseUnits] :: UnitDatabase unit -> [GenUnitInfo unit]
data UnitErr
CloseUnitErr :: !UnitId -> !Maybe UnitId -> UnitErr
PackageFlagErr :: !PackageFlag -> ![(UnitInfo, UnusableUnitReason)] -> UnitErr
TrustFlagErr :: !TrustFlag -> ![(UnitInfo, UnusableUnitReason)] -> UnitErr
emptyUnitState :: UnitState

-- | Read the unit database files, and sets up various internal tables of
--   unit information, according to the unit-related flags on the
--   command-line (<tt>-package</tt>, <tt>-hide-package</tt> etc.)
--   
--   <a>initUnits</a> can be called again subsequently after updating the
--   <a>packageFlags</a> field of the <a>DynFlags</a>, and it will update
--   the <tt>unitState</tt> in <a>DynFlags</a>.
initUnits :: Logger -> DynFlags -> Maybe [UnitDatabase UnitId] -> IO ([UnitDatabase UnitId], UnitState, HomeUnit, Maybe PlatformConstants)
readUnitDatabases :: (Int -> SDoc -> IO ()) -> UnitConfig -> IO [UnitDatabase UnitId]
readUnitDatabase :: (Int -> SDoc -> IO ()) -> UnitConfig -> FilePath -> IO (UnitDatabase UnitId)
getUnitDbRefs :: UnitConfig -> IO [PkgDbRef]

-- | Return the path of a package database from a <a>PkgDbRef</a>. Return
--   <a>Nothing</a> when the user database filepath is expected but the
--   latter doesn't exist.
--   
--   NB: This logic is reimplemented in Cabal, so if you change it, make
--   sure you update Cabal. (Or, better yet, dump it in the compiler info
--   so Cabal can use the info.)
resolveUnitDatabase :: UnitConfig -> PkgDbRef -> IO (Maybe FilePath)

-- | Get a list of entries from the unit database. NB: be careful with this
--   function, although all units in this map are "visible", this does not
--   imply that the exposed-modules of the unit are available (they may
--   have been thinned or renamed).
listUnitInfo :: UnitState -> [UnitInfo]
type UnitInfoMap = Map UnitId UnitInfo

-- | Find the unit we know about with the given unit, if any
lookupUnit :: UnitState -> Unit -> Maybe UnitInfo

-- | A more specialized interface, which doesn't require a <a>UnitState</a>
--   (so it can be used while we're initializing <a>DynFlags</a>)
--   
--   Parameters: * a boolean specifying whether or not to look for
--   on-the-fly renamed interfaces * a <a>UnitInfoMap</a> * a
--   <a>PreloadUnitClosure</a>
lookupUnit' :: Bool -> UnitInfoMap -> PreloadUnitClosure -> Unit -> Maybe UnitInfo

-- | Looks up the given unit in the unit state, panicing if it is not found
unsafeLookupUnit :: HasDebugCallStack => UnitState -> Unit -> UnitInfo

-- | Find the unit we know about with the given unit id, if any
lookupUnitId :: UnitState -> UnitId -> Maybe UnitInfo

-- | Find the unit we know about with the given unit id, if any
lookupUnitId' :: UnitInfoMap -> UnitId -> Maybe UnitInfo

-- | Looks up the given unit id in the unit state, panicing if it is not
--   found
unsafeLookupUnitId :: HasDebugCallStack => UnitState -> UnitId -> UnitInfo

-- | Find the unit we know about with the given package name (e.g.
--   <tt>foo</tt>), if any (NB: there might be a locally defined unit name
--   which overrides this)
lookupPackageName :: UnitState -> PackageName -> Maybe IndefUnitId

-- | Given a fully instantiated <a>InstantiatedUnit</a>, improve it into a
--   <a>RealUnit</a> if we can find it in the package database.
improveUnit :: UnitState -> Unit -> Unit

-- | Search for units with a given package ID (e.g. "foo-0.1")
searchPackageId :: UnitState -> PackageId -> [UnitInfo]
listVisibleModuleNames :: UnitState -> [ModuleName]

-- | Takes a <a>ModuleName</a>, and if the module is in any package returns
--   list of modules which take that name.
lookupModuleInAllUnits :: UnitState -> ModuleName -> [(Module, UnitInfo)]
lookupModuleWithSuggestions :: UnitState -> ModuleName -> Maybe FastString -> LookupResult

-- | The package which the module **appears** to come from, this could be
--   the one which reexports the module from it's original package. This
--   function is currently only used for -Wunused-packages
lookupModulePackage :: UnitState -> ModuleName -> Maybe FastString -> Maybe [UnitInfo]
lookupPluginModuleWithSuggestions :: UnitState -> ModuleName -> Maybe FastString -> LookupResult

-- | Return this list of requirement interfaces that need to be merged to
--   form <tt>mod_name</tt>, or <tt>[]</tt> if this is not a requirement.
requirementMerges :: UnitState -> ModuleName -> [InstantiatedModule]

-- | The result of performing a lookup
data LookupResult

-- | Found the module uniquely, nothing else to do
LookupFound :: Module -> (UnitInfo, ModuleOrigin) -> LookupResult

-- | Multiple modules with the same name in scope
LookupMultiple :: [(Module, ModuleOrigin)] -> LookupResult

-- | No modules found, but there were some hidden ones with an exact name
--   match. First is due to package hidden, second is due to module being
--   hidden
LookupHidden :: [(Module, ModuleOrigin)] -> [(Module, ModuleOrigin)] -> LookupResult

-- | No modules found, but there were some unusable ones with an exact name
--   match
LookupUnusable :: [(Module, ModuleOrigin)] -> LookupResult

-- | Nothing found, here are some suggested different names
LookupNotFound :: [ModuleSuggestion] -> LookupResult
data ModuleSuggestion
SuggestVisible :: ModuleName -> Module -> ModuleOrigin -> ModuleSuggestion
SuggestHidden :: ModuleName -> Module -> ModuleOrigin -> ModuleSuggestion

-- | Given a module name, there may be multiple ways it came into scope,
--   possibly simultaneously. This data type tracks all the possible ways
--   it could have come into scope. Warning: don't use the record
--   functions, they're partial!
data ModuleOrigin

-- | Module is hidden, and thus never will be available for import. (But
--   maybe the user didn't realize), so we'll still keep track of these
--   modules.)
ModHidden :: ModuleOrigin

-- | Module is unavailable because the package is unusable.
ModUnusable :: UnusableUnitReason -> ModuleOrigin

-- | Module is public, and could have come from some places.
ModOrigin :: Maybe Bool -> [UnitInfo] -> [UnitInfo] -> Bool -> ModuleOrigin

-- | <tt>Just False</tt> means that this module is in someone's
--   <tt>exported-modules</tt> list, but that package is hidden; <tt>Just
--   True</tt> means that it is available; <tt>Nothing</tt> means neither
--   applies.
[fromOrigUnit] :: ModuleOrigin -> Maybe Bool

-- | Is the module available from a reexport of an exposed package? There
--   could be multiple.
[fromExposedReexport] :: ModuleOrigin -> [UnitInfo]

-- | Is the module available from a reexport of a hidden package?
[fromHiddenReexport] :: ModuleOrigin -> [UnitInfo]

-- | Did the module export come from a package flag? (ToDo: track more
--   information.
[fromPackageFlag] :: ModuleOrigin -> Bool

-- | The reason why a unit is unusable.
data UnusableUnitReason

-- | We ignored it explicitly using <tt>-ignore-package</tt>.
IgnoredWithFlag :: UnusableUnitReason

-- | This unit transitively depends on a unit that was never present in any
--   of the provided databases.
BrokenDependencies :: [UnitId] -> UnusableUnitReason

-- | This unit transitively depends on a unit involved in a cycle. Note
--   that the list of <a>UnitId</a> reports the direct dependencies of this
--   unit that (transitively) depended on the cycle, and not the actual
--   cycle itself (which we report separately at high verbosity.)
CyclicDependencies :: [UnitId] -> UnusableUnitReason

-- | This unit transitively depends on a unit which was ignored.
IgnoredDependencies :: [UnitId] -> UnusableUnitReason

-- | This unit transitively depends on a unit which was shadowed by an
--   ABI-incompatible unit.
ShadowedDependencies :: [UnitId] -> UnusableUnitReason
pprReason :: SDoc -> UnusableUnitReason -> SDoc

-- | Takes a list of UnitIds (and their "parent" dependency, used for error
--   messages), and returns the list with dependencies included, in reverse
--   dependency order (a units appears before those it depends on).
closeUnitDeps :: UnitInfoMap -> [(UnitId, Maybe UnitId)] -> MaybeErr UnitErr [UnitId]

-- | Similar to closeUnitDeps but takes a list of already loaded units as
--   an additional argument.
closeUnitDeps' :: UnitInfoMap -> [UnitId] -> [(UnitId, Maybe UnitId)] -> MaybeErr UnitErr [UnitId]
mayThrowUnitErr :: MaybeErr UnitErr a -> IO a

-- | Substitution on module variables, mapping module names to module
--   identifiers.
type ShHoleSubst = ModuleNameEnv Module

-- | Substitutes holes in a <a>Unit</a>, suitable for renaming when an
--   include occurs; see Note [Representation of module/name variable].
--   
--   <tt>p[A=&lt;A&gt;]</tt> maps to <tt>p[A=&lt;B&gt;]</tt> with
--   <tt>A=&lt;B&gt;</tt>.
renameHoleUnit :: UnitState -> ShHoleSubst -> Unit -> Unit

-- | Substitutes holes in a <a>Module</a>. NOT suitable for being called
--   directly on a <tt>nameModule</tt>, see Note [Representation of
--   module/name variable]. <tt>p[A=&lt;A&gt;]:B</tt> maps to
--   <tt>p[A=q():A]:B</tt> with <tt>A=q():A</tt>; similarly,
--   <tt>&lt;A&gt;</tt> maps to <tt>q():A</tt>.
renameHoleModule :: UnitState -> ShHoleSubst -> Module -> Module

-- | Like 'renameHoleUnit, but requires only <tt>ClosureUnitInfoMap</tt> so
--   it can be used by <a>GHC.Unit.State</a>.
renameHoleUnit' :: UnitInfoMap -> PreloadUnitClosure -> ShHoleSubst -> Unit -> Unit

-- | Like <a>renameHoleModule</a>, but requires only
--   <tt>ClosureUnitInfoMap</tt> so it can be used by
--   <a>GHC.Unit.State</a>.
renameHoleModule' :: UnitInfoMap -> PreloadUnitClosure -> ShHoleSubst -> Module -> Module

-- | Check the database to see if we already have an installed unit that
--   corresponds to the given <a>InstantiatedUnit</a>.
--   
--   Return a <a>UnitId</a> which either wraps the <a>InstantiatedUnit</a>
--   unchanged or references a matching installed unit.
--   
--   See Note [VirtUnit to RealUnit improvement]
instUnitToUnit :: UnitState -> InstantiatedUnit -> Unit

-- | Injects an <a>InstantiatedModule</a> to <a>Module</a> (see also
--   <a>instUnitToUnit</a>.
instModuleToModule :: UnitState -> InstantiatedModule -> Module
pprFlag :: PackageFlag -> SDoc

-- | Show (very verbose) package info
pprUnits :: UnitState -> SDoc

-- | Show simplified unit info.
--   
--   The idea is to only print package id, and any information that might
--   be different from the package databases (exposure, trust)
pprUnitsSimple :: UnitState -> SDoc

-- | Pretty-print a UnitId for the user.
--   
--   Cabal packages may contain several components (programs, libraries,
--   etc.). As far as GHC is concerned, installed package components
--   ("units") are identified by an opaque IndefUnitId string provided by
--   Cabal. As the string contains a hash, we don't want to display it to
--   users so GHC queries the database to retrieve some infos about the
--   original source package (name, version, component name).
--   
--   Instead we want to display: packagename-version[:componentname]
--   
--   Component name is only displayed if it isn't the default library
--   
--   To do this we need to query a unit database.
pprUnitIdForUser :: UnitState -> UnitId -> SDoc
pprUnitInfoForUser :: UnitInfo -> SDoc

-- | Show the mapping of modules to where they come from.
pprModuleMap :: ModuleNameProvidersMap -> SDoc

-- | Print unit-ids with UnitInfo found in the given UnitState
pprWithUnitState :: UnitState -> SDoc -> SDoc

-- | Given a wired-in <a>Unit</a>, "unwire" it into the <a>Unit</a> that it
--   was recorded as in the package database.
unwireUnit :: UnitState -> Unit -> Unit
instance GHC.Utils.Outputable.Outputable GHC.Unit.State.UnitErr
instance GHC.Utils.Outputable.Outputable GHC.Unit.State.ModuleOrigin
instance GHC.Base.Semigroup GHC.Unit.State.ModuleOrigin
instance GHC.Base.Monoid GHC.Unit.State.ModuleOrigin
instance GHC.Utils.Outputable.Outputable GHC.Unit.State.UnusableUnitReason
instance GHC.Utils.Outputable.Outputable GHC.Unit.State.UnitVisibility
instance GHC.Base.Semigroup GHC.Unit.State.UnitVisibility
instance GHC.Base.Monoid GHC.Unit.State.UnitVisibility


-- | Logger
module GHC.Utils.Logger
data Logger
initLogger :: IO Logger
class HasLogger m
getLogger :: HasLogger m => m Logger
class ContainsLogger t
extractLogger :: ContainsLogger t => t -> Logger
type LogAction = DynFlags -> WarnReason -> Severity -> SrcSpan -> SDoc -> IO ()
type DumpAction = DynFlags -> PprStyle -> DumpFlag -> String -> DumpFormat -> SDoc -> IO ()
type TraceAction a = DynFlags -> String -> SDoc -> a -> a

-- | Format of a dump
--   
--   Dump formats are loosely defined: dumps may contain various additional
--   headers and annotations and they may be partial. <a>DumpFormat</a> is
--   mainly a hint (e.g. for syntax highlighters).
data DumpFormat

-- | Haskell
FormatHaskell :: DumpFormat

-- | Core
FormatCore :: DumpFormat

-- | STG
FormatSTG :: DumpFormat

-- | ByteCode
FormatByteCode :: DumpFormat

-- | Cmm
FormatCMM :: DumpFormat

-- | Assembly code
FormatASM :: DumpFormat

-- | C code/header
FormatC :: DumpFormat

-- | LLVM bytecode
FormatLLVM :: DumpFormat

-- | Unstructured dump
FormatText :: DumpFormat

-- | Log something
putLogMsg :: Logger -> LogAction

-- | Dump something
putDumpMsg :: Logger -> DumpAction

-- | Trace something
putTraceMsg :: Logger -> TraceAction a

-- | Pop a log hook
popLogHook :: Logger -> Logger

-- | Push a log hook
pushLogHook :: (LogAction -> LogAction) -> Logger -> Logger

-- | Pop a dump hook
popDumpHook :: Logger -> Logger

-- | Push a dump hook
pushDumpHook :: (DumpAction -> DumpAction) -> Logger -> Logger

-- | Pop a trace hook
popTraceHook :: Logger -> Logger

-- | Push a trace hook
pushTraceHook :: (forall a. TraceAction a -> TraceAction a) -> Logger -> Logger

-- | Make the logger thread-safe
makeThreadSafe :: Logger -> IO Logger
jsonLogAction :: LogAction
defaultLogAction :: LogAction

-- | Like <a>defaultLogActionHPutStrDoc</a> but appends an extra newline.
defaultLogActionHPrintDoc :: DynFlags -> Bool -> Handle -> SDoc -> IO ()

-- | The boolean arguments let's the pretty printer know if it can optimize
--   indent by writing ascii ' ' characters without going through decoding.
defaultLogActionHPutStrDoc :: DynFlags -> Bool -> Handle -> SDoc -> IO ()

-- | Default action for <tt>dumpAction</tt> hook
defaultDumpAction :: DumpCache -> LogAction -> DumpAction

-- | Run an action with the handle of a <a>DumpFlag</a> if we are
--   outputting to a file, otherwise <a>Nothing</a>.
withDumpFileHandle :: DumpCache -> DynFlags -> DumpFlag -> (Maybe Handle -> IO ()) -> IO ()

-- | Ensure that a dump file is created even if it stays empty
touchDumpFile :: Logger -> DynFlags -> DumpFlag -> IO ()
dumpIfSet :: Logger -> DynFlags -> Bool -> String -> SDoc -> IO ()

-- | A wrapper around <tt>dumpAction</tt>. First check whether the dump
--   flag is set Do nothing if it is unset
dumpIfSet_dyn :: Logger -> DynFlags -> DumpFlag -> String -> DumpFormat -> SDoc -> IO ()

-- | A wrapper around <a>putDumpMsg</a>. First check whether the dump flag
--   is set Do nothing if it is unset
--   
--   Unlike <a>dumpIfSet_dyn</a>, has a printer argument
dumpIfSet_dyn_printer :: PrintUnqualified -> Logger -> DynFlags -> DumpFlag -> String -> DumpFormat -> SDoc -> IO ()

-- | Default action for <tt>traceAction</tt> hook
defaultTraceAction :: TraceAction a
instance GHC.Classes.Eq GHC.Utils.Logger.DumpFormat
instance GHC.Show.Show GHC.Utils.Logger.DumpFormat

module GHC.Types.Error

-- | A collection of messages emitted by GHC during error reporting. A
--   diagnostic message is typically a warning or an error. See Note
--   [Messages].
data Messages e
type WarningMessages = Bag (MsgEnvelope DecoratedSDoc)
type ErrorMessages = Bag (MsgEnvelope DecoratedSDoc)
mkMessages :: Bag (MsgEnvelope e) -> Messages e
emptyMessages :: Messages e
isEmptyMessages :: Messages e -> Bool
addMessage :: MsgEnvelope e -> Messages e -> Messages e

-- | Joins two collections of messages together.
unionMessages :: Messages e -> Messages e -> Messages e

-- | An envelope for GHC's facts about a running program, parameterised
--   over the <i>domain-specific</i> (i.e. parsing, typecheck-renaming,
--   etc) diagnostics.
--   
--   To say things differently, GHC emits <i>diagnostics</i> about the
--   running program, each of which is wrapped into a <a>MsgEnvelope</a>
--   that carries specific information like where the error happened, its
--   severity, etc. Finally, multiple <a>MsgEnvelope</a>s are aggregated
--   into <a>Messages</a> that are returned to the user.
data MsgEnvelope e
MsgEnvelope :: SrcSpan -> PrintUnqualified -> e -> Severity -> WarnReason -> MsgEnvelope e

-- | The SrcSpan is used for sorting errors into line-number order
[errMsgSpan] :: MsgEnvelope e -> SrcSpan
[errMsgContext] :: MsgEnvelope e -> PrintUnqualified
[errMsgDiagnostic] :: MsgEnvelope e -> e
[errMsgSeverity] :: MsgEnvelope e -> Severity
[errMsgReason] :: MsgEnvelope e -> WarnReason
type WarnMsg = MsgEnvelope DecoratedSDoc

-- | Represents a pretty-printable document.
--   
--   To display an <a>SDoc</a>, use <a>printSDoc</a>, <a>printSDocLn</a>,
--   <a>bufLeftRenderSDoc</a>, or <a>renderWithContext</a>. Avoid calling
--   <a>runSDoc</a> directly as it breaks the abstraction layer.
data SDoc

-- | A <a>DecoratedSDoc</a> is isomorphic to a '[SDoc]' but it carries the
--   invariant that the input '[SDoc]' needs to be rendered
--   <i>decorated</i> into its final form, where the typical case would be
--   adding bullets between each elements of the list. The type of
--   decoration depends on the formatting function used, but in practice
--   GHC uses the <tt>formatBulleted</tt>.
data DecoratedSDoc
data Severity
SevOutput :: Severity
SevFatal :: Severity
SevInteractive :: Severity

-- | Log message intended for compiler developers No file/line/column stuff
SevDump :: Severity

-- | Log messages intended for end users. No file/line/column stuff.
SevInfo :: Severity
SevWarning :: Severity

-- | SevWarning and SevError are used for warnings and errors o The message
--   has a file/line/column heading, plus "warning:" or "error:", added by
--   mkLocMessags o Output is intended for end users
SevError :: Severity

-- | A class for types (typically errors and warnings) which can be
--   "rendered" into an opaque <a>DecoratedSDoc</a>. For more information,
--   see Note [Rendering Messages].
class RenderableDiagnostic a
renderDiagnostic :: RenderableDiagnostic a => a -> DecoratedSDoc
pprMessageBag :: Bag SDoc -> SDoc

-- | Creates a new <a>DecoratedSDoc</a> out of a list of <a>SDoc</a>.
mkDecorated :: [SDoc] -> DecoratedSDoc

-- | Make an unannotated error message with location info.
mkLocMessage :: Severity -> SrcSpan -> SDoc -> SDoc

-- | Make a possibly annotated error message with location info.
mkLocMessageAnn :: Maybe String -> Severity -> SrcSpan -> SDoc -> SDoc
getSeverityColour :: Severity -> Scheme -> PprColour
getCaretDiagnostic :: Severity -> SrcSpan -> IO SDoc
makeIntoWarning :: WarnReason -> MsgEnvelope e -> MsgEnvelope e

-- | A short (one-line) error message
mkMsgEnvelope :: SrcSpan -> PrintUnqualified -> SDoc -> MsgEnvelope DecoratedSDoc

-- | Variant that doesn't care about qualified/unqualified names
mkPlainMsgEnvelope :: SrcSpan -> SDoc -> MsgEnvelope DecoratedSDoc
mkErr :: SrcSpan -> PrintUnqualified -> e -> MsgEnvelope e

-- | A long (multi-line) error message
mkLongMsgEnvelope :: SrcSpan -> PrintUnqualified -> SDoc -> SDoc -> MsgEnvelope DecoratedSDoc

-- | A short (one-line) error message
mkWarnMsg :: SrcSpan -> PrintUnqualified -> SDoc -> MsgEnvelope DecoratedSDoc

-- | Variant that doesn't care about qualified/unqualified names
mkPlainWarnMsg :: SrcSpan -> SDoc -> MsgEnvelope DecoratedSDoc

-- | A long (multi-line) error message
mkLongWarnMsg :: SrcSpan -> PrintUnqualified -> SDoc -> SDoc -> MsgEnvelope DecoratedSDoc
isErrorMessage :: MsgEnvelope e -> Bool
isWarningMessage :: MsgEnvelope e -> Bool
getErrorMessages :: Messages e -> Bag (MsgEnvelope e)
getWarningMessages :: Messages e -> Bag (MsgEnvelope e)

-- | Partitions the <a>Messages</a> and returns a tuple which first element
--   are the warnings, and the second the errors.
partitionMessages :: Messages e -> (Bag (MsgEnvelope e), Bag (MsgEnvelope e))
errorsFound :: Messages e -> Bool
instance GHC.Show.Show GHC.Types.Error.Severity
instance GHC.Classes.Eq GHC.Types.Error.Severity
instance GHC.Base.Functor GHC.Types.Error.MsgEnvelope
instance GHC.Base.Functor GHC.Types.Error.Messages
instance GHC.Show.Show (GHC.Types.Error.MsgEnvelope GHC.Types.Error.DecoratedSDoc)
instance GHC.Utils.Json.ToJson GHC.Types.Error.Severity
instance GHC.Types.Error.RenderableDiagnostic GHC.Types.Error.DecoratedSDoc

module GHC.Driver.Flags

-- | Debugging flags
data DumpFlag
Opt_D_dump_cmm :: DumpFlag
Opt_D_dump_cmm_from_stg :: DumpFlag
Opt_D_dump_cmm_raw :: DumpFlag
Opt_D_dump_cmm_verbose_by_proc :: DumpFlag
Opt_D_dump_cmm_verbose :: DumpFlag
Opt_D_dump_cmm_cfg :: DumpFlag
Opt_D_dump_cmm_cbe :: DumpFlag
Opt_D_dump_cmm_switch :: DumpFlag
Opt_D_dump_cmm_proc :: DumpFlag
Opt_D_dump_cmm_sp :: DumpFlag
Opt_D_dump_cmm_sink :: DumpFlag
Opt_D_dump_cmm_caf :: DumpFlag
Opt_D_dump_cmm_procmap :: DumpFlag
Opt_D_dump_cmm_split :: DumpFlag
Opt_D_dump_cmm_info :: DumpFlag
Opt_D_dump_cmm_cps :: DumpFlag

-- | Dump the cfg used for block layout.
Opt_D_dump_cfg_weights :: DumpFlag
Opt_D_dump_asm :: DumpFlag
Opt_D_dump_asm_native :: DumpFlag
Opt_D_dump_asm_liveness :: DumpFlag
Opt_D_dump_asm_regalloc :: DumpFlag
Opt_D_dump_asm_regalloc_stages :: DumpFlag
Opt_D_dump_asm_conflicts :: DumpFlag
Opt_D_dump_asm_stats :: DumpFlag
Opt_D_dump_asm_expanded :: DumpFlag
Opt_D_dump_c_backend :: DumpFlag
Opt_D_dump_llvm :: DumpFlag
Opt_D_dump_core_stats :: DumpFlag
Opt_D_dump_deriv :: DumpFlag
Opt_D_dump_ds :: DumpFlag
Opt_D_dump_ds_preopt :: DumpFlag
Opt_D_dump_foreign :: DumpFlag
Opt_D_dump_inlinings :: DumpFlag
Opt_D_dump_rule_firings :: DumpFlag
Opt_D_dump_rule_rewrites :: DumpFlag
Opt_D_dump_simpl_trace :: DumpFlag
Opt_D_dump_occur_anal :: DumpFlag
Opt_D_dump_parsed :: DumpFlag
Opt_D_dump_parsed_ast :: DumpFlag
Opt_D_dump_rn :: DumpFlag
Opt_D_dump_rn_ast :: DumpFlag
Opt_D_dump_simpl :: DumpFlag
Opt_D_dump_simpl_iterations :: DumpFlag
Opt_D_dump_spec :: DumpFlag
Opt_D_dump_prep :: DumpFlag

-- | Initial STG (CoreToStg output)
Opt_D_dump_stg_from_core :: DumpFlag

-- | STG after unarise
Opt_D_dump_stg_unarised :: DumpFlag

-- | Final STG (after stg2stg)
Opt_D_dump_stg_final :: DumpFlag
Opt_D_dump_call_arity :: DumpFlag
Opt_D_dump_exitify :: DumpFlag
Opt_D_dump_stranal :: DumpFlag
Opt_D_dump_str_signatures :: DumpFlag
Opt_D_dump_cpranal :: DumpFlag
Opt_D_dump_cpr_signatures :: DumpFlag
Opt_D_dump_tc :: DumpFlag
Opt_D_dump_tc_ast :: DumpFlag
Opt_D_dump_hie :: DumpFlag
Opt_D_dump_types :: DumpFlag
Opt_D_dump_rules :: DumpFlag
Opt_D_dump_cse :: DumpFlag
Opt_D_dump_worker_wrapper :: DumpFlag
Opt_D_dump_rn_trace :: DumpFlag
Opt_D_dump_rn_stats :: DumpFlag
Opt_D_dump_opt_cmm :: DumpFlag
Opt_D_dump_simpl_stats :: DumpFlag
Opt_D_dump_cs_trace :: DumpFlag
Opt_D_dump_tc_trace :: DumpFlag
Opt_D_dump_ec_trace :: DumpFlag
Opt_D_dump_if_trace :: DumpFlag
Opt_D_dump_vt_trace :: DumpFlag
Opt_D_dump_splices :: DumpFlag
Opt_D_th_dec_file :: DumpFlag
Opt_D_dump_BCOs :: DumpFlag
Opt_D_dump_ticked :: DumpFlag
Opt_D_dump_rtti :: DumpFlag
Opt_D_source_stats :: DumpFlag
Opt_D_verbose_stg2stg :: DumpFlag
Opt_D_dump_hi :: DumpFlag
Opt_D_dump_hi_diffs :: DumpFlag
Opt_D_dump_mod_cycles :: DumpFlag
Opt_D_dump_mod_map :: DumpFlag
Opt_D_dump_timings :: DumpFlag
Opt_D_dump_view_pattern_commoning :: DumpFlag
Opt_D_verbose_core2core :: DumpFlag
Opt_D_dump_debug :: DumpFlag
Opt_D_dump_json :: DumpFlag
Opt_D_ppr_debug :: DumpFlag
Opt_D_no_debug_output :: DumpFlag
Opt_D_dump_faststrings :: DumpFlag

-- | Enumerates the simple on-or-off dynamic flags
data GeneralFlag

-- | Append dump output to files instead of stdout.
Opt_DumpToFile :: GeneralFlag
Opt_D_faststring_stats :: GeneralFlag
Opt_D_dump_minimal_imports :: GeneralFlag
Opt_DoCoreLinting :: GeneralFlag
Opt_DoLinearCoreLinting :: GeneralFlag
Opt_DoStgLinting :: GeneralFlag
Opt_DoCmmLinting :: GeneralFlag
Opt_DoAsmLinting :: GeneralFlag
Opt_DoAnnotationLinting :: GeneralFlag
Opt_DoBoundsChecking :: GeneralFlag
Opt_NoLlvmMangler :: GeneralFlag
Opt_FastLlvm :: GeneralFlag
Opt_NoTypeableBinds :: GeneralFlag
Opt_DistinctConstructorTables :: GeneralFlag
Opt_InfoTableMap :: GeneralFlag
Opt_WarnIsError :: GeneralFlag
Opt_ShowWarnGroups :: GeneralFlag
Opt_HideSourcePaths :: GeneralFlag
Opt_PrintExplicitForalls :: GeneralFlag
Opt_PrintExplicitKinds :: GeneralFlag
Opt_PrintExplicitCoercions :: GeneralFlag
Opt_PrintExplicitRuntimeReps :: GeneralFlag
Opt_PrintEqualityRelations :: GeneralFlag
Opt_PrintAxiomIncomps :: GeneralFlag
Opt_PrintUnicodeSyntax :: GeneralFlag
Opt_PrintExpandedSynonyms :: GeneralFlag
Opt_PrintPotentialInstances :: GeneralFlag
Opt_PrintTypecheckerElaboration :: GeneralFlag
Opt_CallArity :: GeneralFlag
Opt_Exitification :: GeneralFlag
Opt_Strictness :: GeneralFlag
Opt_LateDmdAnal :: GeneralFlag
Opt_KillAbsence :: GeneralFlag
Opt_KillOneShot :: GeneralFlag
Opt_FullLaziness :: GeneralFlag
Opt_FloatIn :: GeneralFlag
Opt_LateSpecialise :: GeneralFlag
Opt_Specialise :: GeneralFlag
Opt_SpecialiseAggressively :: GeneralFlag
Opt_CrossModuleSpecialise :: GeneralFlag
Opt_InlineGenerics :: GeneralFlag
Opt_InlineGenericsAggressively :: GeneralFlag
Opt_StaticArgumentTransformation :: GeneralFlag
Opt_CSE :: GeneralFlag
Opt_StgCSE :: GeneralFlag
Opt_StgLiftLams :: GeneralFlag
Opt_LiberateCase :: GeneralFlag
Opt_SpecConstr :: GeneralFlag
Opt_SpecConstrKeen :: GeneralFlag
Opt_DoLambdaEtaExpansion :: GeneralFlag
Opt_IgnoreAsserts :: GeneralFlag
Opt_DoEtaReduction :: GeneralFlag
Opt_CaseMerge :: GeneralFlag
Opt_CaseFolding :: GeneralFlag
Opt_UnboxStrictFields :: GeneralFlag
Opt_UnboxSmallStrictFields :: GeneralFlag
Opt_DictsCheap :: GeneralFlag
Opt_EnableRewriteRules :: GeneralFlag
Opt_EnableThSpliceWarnings :: GeneralFlag
Opt_RegsGraph :: GeneralFlag
Opt_RegsIterative :: GeneralFlag
Opt_PedanticBottoms :: GeneralFlag
Opt_LlvmTBAA :: GeneralFlag
Opt_LlvmFillUndefWithGarbage :: GeneralFlag
Opt_IrrefutableTuples :: GeneralFlag
Opt_CmmSink :: GeneralFlag
Opt_CmmStaticPred :: GeneralFlag
Opt_CmmElimCommonBlocks :: GeneralFlag
Opt_AsmShortcutting :: GeneralFlag
Opt_OmitYields :: GeneralFlag
Opt_FunToThunk :: GeneralFlag
Opt_DictsStrict :: GeneralFlag

-- | deprecated, no effect and behaviour is now default. Allowed switching
--   of a special demand transformer for dictionary selectors
Opt_DmdTxDictSel :: GeneralFlag
Opt_Loopification :: GeneralFlag

-- | Use the cfg based block layout algorithm.
Opt_CfgBlocklayout :: GeneralFlag

-- | Layout based on last instruction per block.
Opt_WeightlessBlocklayout :: GeneralFlag
Opt_CprAnal :: GeneralFlag
Opt_WorkerWrapper :: GeneralFlag
Opt_SolveConstantDicts :: GeneralFlag
Opt_AlignmentSanitisation :: GeneralFlag
Opt_CatchBottoms :: GeneralFlag
Opt_NumConstantFolding :: GeneralFlag
Opt_SimplPreInlining :: GeneralFlag
Opt_IgnoreInterfacePragmas :: GeneralFlag
Opt_OmitInterfacePragmas :: GeneralFlag
Opt_ExposeAllUnfoldings :: GeneralFlag
Opt_WriteInterface :: GeneralFlag
Opt_WriteHie :: GeneralFlag
Opt_AutoSccsOnIndividualCafs :: GeneralFlag
Opt_ProfCountEntries :: GeneralFlag
Opt_Pp :: GeneralFlag
Opt_ForceRecomp :: GeneralFlag
Opt_IgnoreOptimChanges :: GeneralFlag
Opt_IgnoreHpcChanges :: GeneralFlag
Opt_ExcessPrecision :: GeneralFlag
Opt_EagerBlackHoling :: GeneralFlag
Opt_NoHsMain :: GeneralFlag
Opt_SplitSections :: GeneralFlag
Opt_StgStats :: GeneralFlag
Opt_HideAllPackages :: GeneralFlag
Opt_HideAllPluginPackages :: GeneralFlag
Opt_PrintBindResult :: GeneralFlag
Opt_Haddock :: GeneralFlag
Opt_HaddockOptions :: GeneralFlag
Opt_BreakOnException :: GeneralFlag
Opt_BreakOnError :: GeneralFlag
Opt_PrintEvldWithShow :: GeneralFlag
Opt_PrintBindContents :: GeneralFlag
Opt_GenManifest :: GeneralFlag
Opt_EmbedManifest :: GeneralFlag
Opt_SharedImplib :: GeneralFlag
Opt_BuildingCabalPackage :: GeneralFlag
Opt_IgnoreDotGhci :: GeneralFlag
Opt_GhciSandbox :: GeneralFlag
Opt_GhciHistory :: GeneralFlag
Opt_GhciLeakCheck :: GeneralFlag
Opt_ValidateHie :: GeneralFlag
Opt_LocalGhciHistory :: GeneralFlag
Opt_NoIt :: GeneralFlag
Opt_HelpfulErrors :: GeneralFlag
Opt_DeferTypeErrors :: GeneralFlag
Opt_DeferTypedHoles :: GeneralFlag
Opt_DeferOutOfScopeVariables :: GeneralFlag

-- | <pre>
--   -fPIC
--   </pre>
Opt_PIC :: GeneralFlag

-- | <pre>
--   -fPIE
--   </pre>
Opt_PIE :: GeneralFlag

-- | <pre>
--   -pie
--   </pre>
Opt_PICExecutable :: GeneralFlag
Opt_ExternalDynamicRefs :: GeneralFlag
Opt_Ticky :: GeneralFlag
Opt_Ticky_Allocd :: GeneralFlag
Opt_Ticky_LNE :: GeneralFlag
Opt_Ticky_Dyn_Thunk :: GeneralFlag
Opt_RPath :: GeneralFlag
Opt_RelativeDynlibPaths :: GeneralFlag

-- | <pre>
--   -fcompact-unwind
--   </pre>
Opt_CompactUnwind :: GeneralFlag
Opt_Hpc :: GeneralFlag
Opt_FamAppCache :: GeneralFlag
Opt_ExternalInterpreter :: GeneralFlag
Opt_OptimalApplicativeDo :: GeneralFlag
Opt_VersionMacros :: GeneralFlag
Opt_WholeArchiveHsLibs :: GeneralFlag
Opt_SingleLibFolder :: GeneralFlag
Opt_ExposeInternalSymbols :: GeneralFlag
Opt_KeepCAFs :: GeneralFlag
Opt_KeepGoing :: GeneralFlag
Opt_ByteCode :: GeneralFlag
Opt_LinkRts :: GeneralFlag
Opt_ErrorSpans :: GeneralFlag
Opt_DeferDiagnostics :: GeneralFlag
Opt_DiagnosticsShowCaret :: GeneralFlag
Opt_PprCaseAsLet :: GeneralFlag
Opt_PprShowTicks :: GeneralFlag
Opt_ShowHoleConstraints :: GeneralFlag
Opt_ShowValidHoleFits :: GeneralFlag
Opt_SortValidHoleFits :: GeneralFlag
Opt_SortBySizeHoleFits :: GeneralFlag
Opt_SortBySubsumHoleFits :: GeneralFlag
Opt_AbstractRefHoleFits :: GeneralFlag
Opt_UnclutterValidHoleFits :: GeneralFlag
Opt_ShowTypeAppOfHoleFits :: GeneralFlag
Opt_ShowTypeAppVarsOfHoleFits :: GeneralFlag
Opt_ShowDocsOfHoleFits :: GeneralFlag
Opt_ShowTypeOfHoleFits :: GeneralFlag
Opt_ShowProvOfHoleFits :: GeneralFlag
Opt_ShowMatchesOfHoleFits :: GeneralFlag
Opt_ShowLoadedModules :: GeneralFlag
Opt_HexWordLiterals :: GeneralFlag
Opt_SuppressCoercions :: GeneralFlag
Opt_SuppressVarKinds :: GeneralFlag
Opt_SuppressModulePrefixes :: GeneralFlag
Opt_SuppressTypeApplications :: GeneralFlag
Opt_SuppressIdInfo :: GeneralFlag
Opt_SuppressUnfoldings :: GeneralFlag
Opt_SuppressTypeSignatures :: GeneralFlag
Opt_SuppressUniques :: GeneralFlag
Opt_SuppressStgExts :: GeneralFlag
Opt_SuppressTicks :: GeneralFlag

-- | Suppress timestamps in dumps
Opt_SuppressTimestamps :: GeneralFlag
Opt_AutoLinkPackages :: GeneralFlag
Opt_ImplicitImportQualified :: GeneralFlag
Opt_KeepHscppFiles :: GeneralFlag
Opt_KeepHiDiffs :: GeneralFlag
Opt_KeepHcFiles :: GeneralFlag
Opt_KeepSFiles :: GeneralFlag
Opt_KeepTmpFiles :: GeneralFlag
Opt_KeepRawTokenStream :: GeneralFlag
Opt_KeepLlvmFiles :: GeneralFlag
Opt_KeepHiFiles :: GeneralFlag
Opt_KeepOFiles :: GeneralFlag
Opt_BuildDynamicToo :: GeneralFlag
Opt_DistrustAllPackages :: GeneralFlag
Opt_PackageTrust :: GeneralFlag
Opt_PluginTrustworthy :: GeneralFlag
Opt_G_NoStateHack :: GeneralFlag
Opt_G_NoOptCoercion :: GeneralFlag
data WarningFlag
Opt_WarnDuplicateExports :: WarningFlag
Opt_WarnDuplicateConstraints :: WarningFlag
Opt_WarnRedundantConstraints :: WarningFlag
Opt_WarnHiShadows :: WarningFlag
Opt_WarnImplicitPrelude :: WarningFlag
Opt_WarnIncompletePatterns :: WarningFlag
Opt_WarnIncompleteUniPatterns :: WarningFlag
Opt_WarnIncompletePatternsRecUpd :: WarningFlag
Opt_WarnOverflowedLiterals :: WarningFlag
Opt_WarnEmptyEnumerations :: WarningFlag
Opt_WarnMissingFields :: WarningFlag
Opt_WarnMissingImportList :: WarningFlag
Opt_WarnMissingMethods :: WarningFlag
Opt_WarnMissingSignatures :: WarningFlag
Opt_WarnMissingLocalSignatures :: WarningFlag
Opt_WarnNameShadowing :: WarningFlag
Opt_WarnOverlappingPatterns :: WarningFlag
Opt_WarnTypeDefaults :: WarningFlag
Opt_WarnMonomorphism :: WarningFlag
Opt_WarnUnusedTopBinds :: WarningFlag
Opt_WarnUnusedLocalBinds :: WarningFlag
Opt_WarnUnusedPatternBinds :: WarningFlag
Opt_WarnUnusedImports :: WarningFlag
Opt_WarnUnusedMatches :: WarningFlag
Opt_WarnUnusedTypePatterns :: WarningFlag
Opt_WarnUnusedForalls :: WarningFlag
Opt_WarnUnusedRecordWildcards :: WarningFlag
Opt_WarnRedundantBangPatterns :: WarningFlag
Opt_WarnRedundantRecordWildcards :: WarningFlag
Opt_WarnWarningsDeprecations :: WarningFlag
Opt_WarnDeprecatedFlags :: WarningFlag
Opt_WarnMissingMonadFailInstances :: WarningFlag
Opt_WarnSemigroup :: WarningFlag
Opt_WarnDodgyExports :: WarningFlag
Opt_WarnDodgyImports :: WarningFlag
Opt_WarnOrphans :: WarningFlag
Opt_WarnAutoOrphans :: WarningFlag
Opt_WarnIdentities :: WarningFlag
Opt_WarnTabs :: WarningFlag
Opt_WarnUnrecognisedPragmas :: WarningFlag
Opt_WarnDodgyForeignImports :: WarningFlag
Opt_WarnUnusedDoBind :: WarningFlag
Opt_WarnWrongDoBind :: WarningFlag
Opt_WarnAlternativeLayoutRuleTransitional :: WarningFlag
Opt_WarnUnsafe :: WarningFlag
Opt_WarnSafe :: WarningFlag
Opt_WarnTrustworthySafe :: WarningFlag
Opt_WarnMissedSpecs :: WarningFlag
Opt_WarnAllMissedSpecs :: WarningFlag
Opt_WarnUnsupportedCallingConventions :: WarningFlag
Opt_WarnUnsupportedLlvmVersion :: WarningFlag
Opt_WarnMissedExtraSharedLib :: WarningFlag
Opt_WarnInlineRuleShadowing :: WarningFlag
Opt_WarnTypedHoles :: WarningFlag
Opt_WarnPartialTypeSignatures :: WarningFlag
Opt_WarnMissingExportedSignatures :: WarningFlag
Opt_WarnUntickedPromotedConstructors :: WarningFlag
Opt_WarnDerivingTypeable :: WarningFlag
Opt_WarnDeferredTypeErrors :: WarningFlag
Opt_WarnDeferredOutOfScopeVariables :: WarningFlag
Opt_WarnNonCanonicalMonadInstances :: WarningFlag
Opt_WarnNonCanonicalMonadFailInstances :: WarningFlag
Opt_WarnNonCanonicalMonoidInstances :: WarningFlag
Opt_WarnMissingPatternSynonymSignatures :: WarningFlag
Opt_WarnUnrecognisedWarningFlags :: WarningFlag
Opt_WarnSimplifiableClassConstraints :: WarningFlag
Opt_WarnCPPUndef :: WarningFlag
Opt_WarnUnbangedStrictPatterns :: WarningFlag
Opt_WarnMissingHomeModules :: WarningFlag
Opt_WarnPartialFields :: WarningFlag
Opt_WarnMissingExportList :: WarningFlag
Opt_WarnInaccessibleCode :: WarningFlag
Opt_WarnStarIsType :: WarningFlag
Opt_WarnStarBinder :: WarningFlag
Opt_WarnImplicitKindVars :: WarningFlag
Opt_WarnSpaceAfterBang :: WarningFlag
Opt_WarnMissingDerivingStrategies :: WarningFlag
Opt_WarnPrepositiveQualifiedModule :: WarningFlag
Opt_WarnUnusedPackages :: WarningFlag
Opt_WarnInferredSafeImports :: WarningFlag
Opt_WarnMissingSafeHaskellMode :: WarningFlag
Opt_WarnCompatUnqualifiedImports :: WarningFlag
Opt_WarnDerivingDefaults :: WarningFlag
Opt_WarnInvalidHaddock :: WarningFlag
Opt_WarnOperatorWhitespaceExtConflict :: WarningFlag
Opt_WarnOperatorWhitespace :: WarningFlag
Opt_WarnAmbiguousFields :: WarningFlag
Opt_WarnImplicitLift :: WarningFlag
Opt_WarnMissingKindSignatures :: WarningFlag
Opt_WarnUnicodeBidirectionalFormatCharacters :: WarningFlag

-- | Used when outputting warnings: if a reason is given, it is displayed.
--   If a warning isn't controlled by a flag, this is made explicit at the
--   point of use.
data WarnReason
NoReason :: WarnReason

-- | Warning was enabled with the flag
Reason :: !WarningFlag -> WarnReason

-- | Warning was made an error because of -Werror or -Werror=WarningFlag
ErrReason :: !Maybe WarningFlag -> WarnReason
data Language
Haskell98 :: Language
Haskell2010 :: Language
GHC2021 :: Language
optimisationFlags :: EnumSet GeneralFlag
instance GHC.Enum.Enum GHC.Driver.Flags.DumpFlag
instance GHC.Show.Show GHC.Driver.Flags.DumpFlag
instance GHC.Classes.Eq GHC.Driver.Flags.DumpFlag
instance GHC.Enum.Enum GHC.Driver.Flags.GeneralFlag
instance GHC.Show.Show GHC.Driver.Flags.GeneralFlag
instance GHC.Classes.Eq GHC.Driver.Flags.GeneralFlag
instance GHC.Enum.Enum GHC.Driver.Flags.WarningFlag
instance GHC.Show.Show GHC.Driver.Flags.WarningFlag
instance GHC.Classes.Ord GHC.Driver.Flags.WarningFlag
instance GHC.Classes.Eq GHC.Driver.Flags.WarningFlag
instance GHC.Show.Show GHC.Driver.Flags.WarnReason
instance GHC.Enum.Bounded GHC.Driver.Flags.Language
instance GHC.Show.Show GHC.Driver.Flags.Language
instance GHC.Enum.Enum GHC.Driver.Flags.Language
instance GHC.Classes.Eq GHC.Driver.Flags.Language
instance GHC.Utils.Outputable.Outputable GHC.Driver.Flags.Language
instance GHC.Utils.Outputable.Outputable GHC.Driver.Flags.WarnReason
instance GHC.Utils.Json.ToJson GHC.Driver.Flags.WarnReason

module GHC.Data.Bag
data Bag a
emptyBag :: Bag a
unitBag :: a -> Bag a
unionBags :: Bag a -> Bag a -> Bag a
unionManyBags :: [Bag a] -> Bag a
mapBag :: (a -> b) -> Bag a -> Bag b
elemBag :: Eq a => a -> Bag a -> Bool
lengthBag :: Bag a -> Int
filterBag :: (a -> Bool) -> Bag a -> Bag a
partitionBag :: (a -> Bool) -> Bag a -> (Bag a, Bag a)
partitionBagWith :: (a -> Either b c) -> Bag a -> (Bag b, Bag c)
concatBag :: Bag (Bag a) -> Bag a
catBagMaybes :: Bag (Maybe a) -> Bag a
foldBag :: (r -> r -> r) -> (a -> r) -> r -> Bag a -> r
isEmptyBag :: Bag a -> Bool
isSingletonBag :: Bag a -> Bool
consBag :: a -> Bag a -> Bag a
infixr 3 `consBag`
snocBag :: Bag a -> a -> Bag a
infixl 3 `snocBag`
anyBag :: (a -> Bool) -> Bag a -> Bool
allBag :: (a -> Bool) -> Bag a -> Bool
listToBag :: [a] -> Bag a
nonEmptyToBag :: NonEmpty a -> Bag a
bagToList :: Bag a -> [a]
mapAccumBagL :: (acc -> x -> (acc, y)) -> acc -> Bag x -> (acc, Bag y)
concatMapBag :: (a -> Bag b) -> Bag a -> Bag b
concatMapBagPair :: (a -> (Bag b, Bag c)) -> Bag a -> (Bag b, Bag c)
mapMaybeBag :: (a -> Maybe b) -> Bag a -> Bag b
mapBagM :: Monad m => (a -> m b) -> Bag a -> m (Bag b)
mapBagM_ :: Monad m => (a -> m b) -> Bag a -> m ()
flatMapBagM :: Monad m => (a -> m (Bag b)) -> Bag a -> m (Bag b)
flatMapBagPairM :: Monad m => (a -> m (Bag b, Bag c)) -> Bag a -> m (Bag b, Bag c)
mapAndUnzipBagM :: Monad m => (a -> m (b, c)) -> Bag a -> m (Bag b, Bag c)
mapAccumBagLM :: Monad m => (acc -> x -> m (acc, y)) -> acc -> Bag x -> m (acc, Bag y)
anyBagM :: Monad m => (a -> m Bool) -> Bag a -> m Bool
filterBagM :: Monad m => (a -> m Bool) -> Bag a -> m (Bag a)
instance GHC.Base.Functor GHC.Data.Bag.Bag
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Data.Bag.Bag a)
instance Data.Data.Data a => Data.Data.Data (GHC.Data.Bag.Bag a)
instance Data.Foldable.Foldable GHC.Data.Bag.Bag
instance Data.Traversable.Traversable GHC.Data.Bag.Bag
instance GHC.Exts.IsList (GHC.Data.Bag.Bag a)


-- | Dynamic flags
--   
--   Most flags are dynamic flags, which means they can change from
--   compilation to compilation using <tt>OPTIONS_GHC</tt> pragmas, and in
--   a multi-session GHC each session can be using different dynamic flags.
--   Dynamic flags can also be set at the prompt in GHCi.
--   
--   (c) The University of Glasgow 2005
module GHC.Driver.Session

-- | Debugging flags
data DumpFlag
Opt_D_dump_cmm :: DumpFlag
Opt_D_dump_cmm_from_stg :: DumpFlag
Opt_D_dump_cmm_raw :: DumpFlag
Opt_D_dump_cmm_verbose_by_proc :: DumpFlag
Opt_D_dump_cmm_verbose :: DumpFlag
Opt_D_dump_cmm_cfg :: DumpFlag
Opt_D_dump_cmm_cbe :: DumpFlag
Opt_D_dump_cmm_switch :: DumpFlag
Opt_D_dump_cmm_proc :: DumpFlag
Opt_D_dump_cmm_sp :: DumpFlag
Opt_D_dump_cmm_sink :: DumpFlag
Opt_D_dump_cmm_caf :: DumpFlag
Opt_D_dump_cmm_procmap :: DumpFlag
Opt_D_dump_cmm_split :: DumpFlag
Opt_D_dump_cmm_info :: DumpFlag
Opt_D_dump_cmm_cps :: DumpFlag

-- | Dump the cfg used for block layout.
Opt_D_dump_cfg_weights :: DumpFlag
Opt_D_dump_asm :: DumpFlag
Opt_D_dump_asm_native :: DumpFlag
Opt_D_dump_asm_liveness :: DumpFlag
Opt_D_dump_asm_regalloc :: DumpFlag
Opt_D_dump_asm_regalloc_stages :: DumpFlag
Opt_D_dump_asm_conflicts :: DumpFlag
Opt_D_dump_asm_stats :: DumpFlag
Opt_D_dump_asm_expanded :: DumpFlag
Opt_D_dump_c_backend :: DumpFlag
Opt_D_dump_llvm :: DumpFlag
Opt_D_dump_core_stats :: DumpFlag
Opt_D_dump_deriv :: DumpFlag
Opt_D_dump_ds :: DumpFlag
Opt_D_dump_ds_preopt :: DumpFlag
Opt_D_dump_foreign :: DumpFlag
Opt_D_dump_inlinings :: DumpFlag
Opt_D_dump_rule_firings :: DumpFlag
Opt_D_dump_rule_rewrites :: DumpFlag
Opt_D_dump_simpl_trace :: DumpFlag
Opt_D_dump_occur_anal :: DumpFlag
Opt_D_dump_parsed :: DumpFlag
Opt_D_dump_parsed_ast :: DumpFlag
Opt_D_dump_rn :: DumpFlag
Opt_D_dump_rn_ast :: DumpFlag
Opt_D_dump_simpl :: DumpFlag
Opt_D_dump_simpl_iterations :: DumpFlag
Opt_D_dump_spec :: DumpFlag
Opt_D_dump_prep :: DumpFlag

-- | Initial STG (CoreToStg output)
Opt_D_dump_stg_from_core :: DumpFlag

-- | STG after unarise
Opt_D_dump_stg_unarised :: DumpFlag

-- | Final STG (after stg2stg)
Opt_D_dump_stg_final :: DumpFlag
Opt_D_dump_call_arity :: DumpFlag
Opt_D_dump_exitify :: DumpFlag
Opt_D_dump_stranal :: DumpFlag
Opt_D_dump_str_signatures :: DumpFlag
Opt_D_dump_cpranal :: DumpFlag
Opt_D_dump_cpr_signatures :: DumpFlag
Opt_D_dump_tc :: DumpFlag
Opt_D_dump_tc_ast :: DumpFlag
Opt_D_dump_hie :: DumpFlag
Opt_D_dump_types :: DumpFlag
Opt_D_dump_rules :: DumpFlag
Opt_D_dump_cse :: DumpFlag
Opt_D_dump_worker_wrapper :: DumpFlag
Opt_D_dump_rn_trace :: DumpFlag
Opt_D_dump_rn_stats :: DumpFlag
Opt_D_dump_opt_cmm :: DumpFlag
Opt_D_dump_simpl_stats :: DumpFlag
Opt_D_dump_cs_trace :: DumpFlag
Opt_D_dump_tc_trace :: DumpFlag
Opt_D_dump_ec_trace :: DumpFlag
Opt_D_dump_if_trace :: DumpFlag
Opt_D_dump_vt_trace :: DumpFlag
Opt_D_dump_splices :: DumpFlag
Opt_D_th_dec_file :: DumpFlag
Opt_D_dump_BCOs :: DumpFlag
Opt_D_dump_ticked :: DumpFlag
Opt_D_dump_rtti :: DumpFlag
Opt_D_source_stats :: DumpFlag
Opt_D_verbose_stg2stg :: DumpFlag
Opt_D_dump_hi :: DumpFlag
Opt_D_dump_hi_diffs :: DumpFlag
Opt_D_dump_mod_cycles :: DumpFlag
Opt_D_dump_mod_map :: DumpFlag
Opt_D_dump_timings :: DumpFlag
Opt_D_dump_view_pattern_commoning :: DumpFlag
Opt_D_verbose_core2core :: DumpFlag
Opt_D_dump_debug :: DumpFlag
Opt_D_dump_json :: DumpFlag
Opt_D_ppr_debug :: DumpFlag
Opt_D_no_debug_output :: DumpFlag
Opt_D_dump_faststrings :: DumpFlag

-- | Enumerates the simple on-or-off dynamic flags
data GeneralFlag

-- | Append dump output to files instead of stdout.
Opt_DumpToFile :: GeneralFlag
Opt_D_faststring_stats :: GeneralFlag
Opt_D_dump_minimal_imports :: GeneralFlag
Opt_DoCoreLinting :: GeneralFlag
Opt_DoLinearCoreLinting :: GeneralFlag
Opt_DoStgLinting :: GeneralFlag
Opt_DoCmmLinting :: GeneralFlag
Opt_DoAsmLinting :: GeneralFlag
Opt_DoAnnotationLinting :: GeneralFlag
Opt_DoBoundsChecking :: GeneralFlag
Opt_NoLlvmMangler :: GeneralFlag
Opt_FastLlvm :: GeneralFlag
Opt_NoTypeableBinds :: GeneralFlag
Opt_DistinctConstructorTables :: GeneralFlag
Opt_InfoTableMap :: GeneralFlag
Opt_WarnIsError :: GeneralFlag
Opt_ShowWarnGroups :: GeneralFlag
Opt_HideSourcePaths :: GeneralFlag
Opt_PrintExplicitForalls :: GeneralFlag
Opt_PrintExplicitKinds :: GeneralFlag
Opt_PrintExplicitCoercions :: GeneralFlag
Opt_PrintExplicitRuntimeReps :: GeneralFlag
Opt_PrintEqualityRelations :: GeneralFlag
Opt_PrintAxiomIncomps :: GeneralFlag
Opt_PrintUnicodeSyntax :: GeneralFlag
Opt_PrintExpandedSynonyms :: GeneralFlag
Opt_PrintPotentialInstances :: GeneralFlag
Opt_PrintTypecheckerElaboration :: GeneralFlag
Opt_CallArity :: GeneralFlag
Opt_Exitification :: GeneralFlag
Opt_Strictness :: GeneralFlag
Opt_LateDmdAnal :: GeneralFlag
Opt_KillAbsence :: GeneralFlag
Opt_KillOneShot :: GeneralFlag
Opt_FullLaziness :: GeneralFlag
Opt_FloatIn :: GeneralFlag
Opt_LateSpecialise :: GeneralFlag
Opt_Specialise :: GeneralFlag
Opt_SpecialiseAggressively :: GeneralFlag
Opt_CrossModuleSpecialise :: GeneralFlag
Opt_InlineGenerics :: GeneralFlag
Opt_InlineGenericsAggressively :: GeneralFlag
Opt_StaticArgumentTransformation :: GeneralFlag
Opt_CSE :: GeneralFlag
Opt_StgCSE :: GeneralFlag
Opt_StgLiftLams :: GeneralFlag
Opt_LiberateCase :: GeneralFlag
Opt_SpecConstr :: GeneralFlag
Opt_SpecConstrKeen :: GeneralFlag
Opt_DoLambdaEtaExpansion :: GeneralFlag
Opt_IgnoreAsserts :: GeneralFlag
Opt_DoEtaReduction :: GeneralFlag
Opt_CaseMerge :: GeneralFlag
Opt_CaseFolding :: GeneralFlag
Opt_UnboxStrictFields :: GeneralFlag
Opt_UnboxSmallStrictFields :: GeneralFlag
Opt_DictsCheap :: GeneralFlag
Opt_EnableRewriteRules :: GeneralFlag
Opt_EnableThSpliceWarnings :: GeneralFlag
Opt_RegsGraph :: GeneralFlag
Opt_RegsIterative :: GeneralFlag
Opt_PedanticBottoms :: GeneralFlag
Opt_LlvmTBAA :: GeneralFlag
Opt_LlvmFillUndefWithGarbage :: GeneralFlag
Opt_IrrefutableTuples :: GeneralFlag
Opt_CmmSink :: GeneralFlag
Opt_CmmStaticPred :: GeneralFlag
Opt_CmmElimCommonBlocks :: GeneralFlag
Opt_AsmShortcutting :: GeneralFlag
Opt_OmitYields :: GeneralFlag
Opt_FunToThunk :: GeneralFlag
Opt_DictsStrict :: GeneralFlag

-- | deprecated, no effect and behaviour is now default. Allowed switching
--   of a special demand transformer for dictionary selectors
Opt_DmdTxDictSel :: GeneralFlag
Opt_Loopification :: GeneralFlag

-- | Use the cfg based block layout algorithm.
Opt_CfgBlocklayout :: GeneralFlag

-- | Layout based on last instruction per block.
Opt_WeightlessBlocklayout :: GeneralFlag
Opt_CprAnal :: GeneralFlag
Opt_WorkerWrapper :: GeneralFlag
Opt_SolveConstantDicts :: GeneralFlag
Opt_AlignmentSanitisation :: GeneralFlag
Opt_CatchBottoms :: GeneralFlag
Opt_NumConstantFolding :: GeneralFlag
Opt_SimplPreInlining :: GeneralFlag
Opt_IgnoreInterfacePragmas :: GeneralFlag
Opt_OmitInterfacePragmas :: GeneralFlag
Opt_ExposeAllUnfoldings :: GeneralFlag
Opt_WriteInterface :: GeneralFlag
Opt_WriteHie :: GeneralFlag
Opt_AutoSccsOnIndividualCafs :: GeneralFlag
Opt_ProfCountEntries :: GeneralFlag
Opt_Pp :: GeneralFlag
Opt_ForceRecomp :: GeneralFlag
Opt_IgnoreOptimChanges :: GeneralFlag
Opt_IgnoreHpcChanges :: GeneralFlag
Opt_ExcessPrecision :: GeneralFlag
Opt_EagerBlackHoling :: GeneralFlag
Opt_NoHsMain :: GeneralFlag
Opt_SplitSections :: GeneralFlag
Opt_StgStats :: GeneralFlag
Opt_HideAllPackages :: GeneralFlag
Opt_HideAllPluginPackages :: GeneralFlag
Opt_PrintBindResult :: GeneralFlag
Opt_Haddock :: GeneralFlag
Opt_HaddockOptions :: GeneralFlag
Opt_BreakOnException :: GeneralFlag
Opt_BreakOnError :: GeneralFlag
Opt_PrintEvldWithShow :: GeneralFlag
Opt_PrintBindContents :: GeneralFlag
Opt_GenManifest :: GeneralFlag
Opt_EmbedManifest :: GeneralFlag
Opt_SharedImplib :: GeneralFlag
Opt_BuildingCabalPackage :: GeneralFlag
Opt_IgnoreDotGhci :: GeneralFlag
Opt_GhciSandbox :: GeneralFlag
Opt_GhciHistory :: GeneralFlag
Opt_GhciLeakCheck :: GeneralFlag
Opt_ValidateHie :: GeneralFlag
Opt_LocalGhciHistory :: GeneralFlag
Opt_NoIt :: GeneralFlag
Opt_HelpfulErrors :: GeneralFlag
Opt_DeferTypeErrors :: GeneralFlag
Opt_DeferTypedHoles :: GeneralFlag
Opt_DeferOutOfScopeVariables :: GeneralFlag

-- | <pre>
--   -fPIC
--   </pre>
Opt_PIC :: GeneralFlag

-- | <pre>
--   -fPIE
--   </pre>
Opt_PIE :: GeneralFlag

-- | <pre>
--   -pie
--   </pre>
Opt_PICExecutable :: GeneralFlag
Opt_ExternalDynamicRefs :: GeneralFlag
Opt_Ticky :: GeneralFlag
Opt_Ticky_Allocd :: GeneralFlag
Opt_Ticky_LNE :: GeneralFlag
Opt_Ticky_Dyn_Thunk :: GeneralFlag
Opt_RPath :: GeneralFlag
Opt_RelativeDynlibPaths :: GeneralFlag

-- | <pre>
--   -fcompact-unwind
--   </pre>
Opt_CompactUnwind :: GeneralFlag
Opt_Hpc :: GeneralFlag
Opt_FamAppCache :: GeneralFlag
Opt_ExternalInterpreter :: GeneralFlag
Opt_OptimalApplicativeDo :: GeneralFlag
Opt_VersionMacros :: GeneralFlag
Opt_WholeArchiveHsLibs :: GeneralFlag
Opt_SingleLibFolder :: GeneralFlag
Opt_ExposeInternalSymbols :: GeneralFlag
Opt_KeepCAFs :: GeneralFlag
Opt_KeepGoing :: GeneralFlag
Opt_ByteCode :: GeneralFlag
Opt_LinkRts :: GeneralFlag
Opt_ErrorSpans :: GeneralFlag
Opt_DeferDiagnostics :: GeneralFlag
Opt_DiagnosticsShowCaret :: GeneralFlag
Opt_PprCaseAsLet :: GeneralFlag
Opt_PprShowTicks :: GeneralFlag
Opt_ShowHoleConstraints :: GeneralFlag
Opt_ShowValidHoleFits :: GeneralFlag
Opt_SortValidHoleFits :: GeneralFlag
Opt_SortBySizeHoleFits :: GeneralFlag
Opt_SortBySubsumHoleFits :: GeneralFlag
Opt_AbstractRefHoleFits :: GeneralFlag
Opt_UnclutterValidHoleFits :: GeneralFlag
Opt_ShowTypeAppOfHoleFits :: GeneralFlag
Opt_ShowTypeAppVarsOfHoleFits :: GeneralFlag
Opt_ShowDocsOfHoleFits :: GeneralFlag
Opt_ShowTypeOfHoleFits :: GeneralFlag
Opt_ShowProvOfHoleFits :: GeneralFlag
Opt_ShowMatchesOfHoleFits :: GeneralFlag
Opt_ShowLoadedModules :: GeneralFlag
Opt_HexWordLiterals :: GeneralFlag
Opt_SuppressCoercions :: GeneralFlag
Opt_SuppressVarKinds :: GeneralFlag
Opt_SuppressModulePrefixes :: GeneralFlag
Opt_SuppressTypeApplications :: GeneralFlag
Opt_SuppressIdInfo :: GeneralFlag
Opt_SuppressUnfoldings :: GeneralFlag
Opt_SuppressTypeSignatures :: GeneralFlag
Opt_SuppressUniques :: GeneralFlag
Opt_SuppressStgExts :: GeneralFlag
Opt_SuppressTicks :: GeneralFlag

-- | Suppress timestamps in dumps
Opt_SuppressTimestamps :: GeneralFlag
Opt_AutoLinkPackages :: GeneralFlag
Opt_ImplicitImportQualified :: GeneralFlag
Opt_KeepHscppFiles :: GeneralFlag
Opt_KeepHiDiffs :: GeneralFlag
Opt_KeepHcFiles :: GeneralFlag
Opt_KeepSFiles :: GeneralFlag
Opt_KeepTmpFiles :: GeneralFlag
Opt_KeepRawTokenStream :: GeneralFlag
Opt_KeepLlvmFiles :: GeneralFlag
Opt_KeepHiFiles :: GeneralFlag
Opt_KeepOFiles :: GeneralFlag
Opt_BuildDynamicToo :: GeneralFlag
Opt_DistrustAllPackages :: GeneralFlag
Opt_PackageTrust :: GeneralFlag
Opt_PluginTrustworthy :: GeneralFlag
Opt_G_NoStateHack :: GeneralFlag
Opt_G_NoOptCoercion :: GeneralFlag
data WarningFlag
Opt_WarnDuplicateExports :: WarningFlag
Opt_WarnDuplicateConstraints :: WarningFlag
Opt_WarnRedundantConstraints :: WarningFlag
Opt_WarnHiShadows :: WarningFlag
Opt_WarnImplicitPrelude :: WarningFlag
Opt_WarnIncompletePatterns :: WarningFlag
Opt_WarnIncompleteUniPatterns :: WarningFlag
Opt_WarnIncompletePatternsRecUpd :: WarningFlag
Opt_WarnOverflowedLiterals :: WarningFlag
Opt_WarnEmptyEnumerations :: WarningFlag
Opt_WarnMissingFields :: WarningFlag
Opt_WarnMissingImportList :: WarningFlag
Opt_WarnMissingMethods :: WarningFlag
Opt_WarnMissingSignatures :: WarningFlag
Opt_WarnMissingLocalSignatures :: WarningFlag
Opt_WarnNameShadowing :: WarningFlag
Opt_WarnOverlappingPatterns :: WarningFlag
Opt_WarnTypeDefaults :: WarningFlag
Opt_WarnMonomorphism :: WarningFlag
Opt_WarnUnusedTopBinds :: WarningFlag
Opt_WarnUnusedLocalBinds :: WarningFlag
Opt_WarnUnusedPatternBinds :: WarningFlag
Opt_WarnUnusedImports :: WarningFlag
Opt_WarnUnusedMatches :: WarningFlag
Opt_WarnUnusedTypePatterns :: WarningFlag
Opt_WarnUnusedForalls :: WarningFlag
Opt_WarnUnusedRecordWildcards :: WarningFlag
Opt_WarnRedundantBangPatterns :: WarningFlag
Opt_WarnRedundantRecordWildcards :: WarningFlag
Opt_WarnWarningsDeprecations :: WarningFlag
Opt_WarnDeprecatedFlags :: WarningFlag
Opt_WarnMissingMonadFailInstances :: WarningFlag
Opt_WarnSemigroup :: WarningFlag
Opt_WarnDodgyExports :: WarningFlag
Opt_WarnDodgyImports :: WarningFlag
Opt_WarnOrphans :: WarningFlag
Opt_WarnAutoOrphans :: WarningFlag
Opt_WarnIdentities :: WarningFlag
Opt_WarnTabs :: WarningFlag
Opt_WarnUnrecognisedPragmas :: WarningFlag
Opt_WarnDodgyForeignImports :: WarningFlag
Opt_WarnUnusedDoBind :: WarningFlag
Opt_WarnWrongDoBind :: WarningFlag
Opt_WarnAlternativeLayoutRuleTransitional :: WarningFlag
Opt_WarnUnsafe :: WarningFlag
Opt_WarnSafe :: WarningFlag
Opt_WarnTrustworthySafe :: WarningFlag
Opt_WarnMissedSpecs :: WarningFlag
Opt_WarnAllMissedSpecs :: WarningFlag
Opt_WarnUnsupportedCallingConventions :: WarningFlag
Opt_WarnUnsupportedLlvmVersion :: WarningFlag
Opt_WarnMissedExtraSharedLib :: WarningFlag
Opt_WarnInlineRuleShadowing :: WarningFlag
Opt_WarnTypedHoles :: WarningFlag
Opt_WarnPartialTypeSignatures :: WarningFlag
Opt_WarnMissingExportedSignatures :: WarningFlag
Opt_WarnUntickedPromotedConstructors :: WarningFlag
Opt_WarnDerivingTypeable :: WarningFlag
Opt_WarnDeferredTypeErrors :: WarningFlag
Opt_WarnDeferredOutOfScopeVariables :: WarningFlag
Opt_WarnNonCanonicalMonadInstances :: WarningFlag
Opt_WarnNonCanonicalMonadFailInstances :: WarningFlag
Opt_WarnNonCanonicalMonoidInstances :: WarningFlag
Opt_WarnMissingPatternSynonymSignatures :: WarningFlag
Opt_WarnUnrecognisedWarningFlags :: WarningFlag
Opt_WarnSimplifiableClassConstraints :: WarningFlag
Opt_WarnCPPUndef :: WarningFlag
Opt_WarnUnbangedStrictPatterns :: WarningFlag
Opt_WarnMissingHomeModules :: WarningFlag
Opt_WarnPartialFields :: WarningFlag
Opt_WarnMissingExportList :: WarningFlag
Opt_WarnInaccessibleCode :: WarningFlag
Opt_WarnStarIsType :: WarningFlag
Opt_WarnStarBinder :: WarningFlag
Opt_WarnImplicitKindVars :: WarningFlag
Opt_WarnSpaceAfterBang :: WarningFlag
Opt_WarnMissingDerivingStrategies :: WarningFlag
Opt_WarnPrepositiveQualifiedModule :: WarningFlag
Opt_WarnUnusedPackages :: WarningFlag
Opt_WarnInferredSafeImports :: WarningFlag
Opt_WarnMissingSafeHaskellMode :: WarningFlag
Opt_WarnCompatUnqualifiedImports :: WarningFlag
Opt_WarnDerivingDefaults :: WarningFlag
Opt_WarnInvalidHaddock :: WarningFlag
Opt_WarnOperatorWhitespaceExtConflict :: WarningFlag
Opt_WarnOperatorWhitespace :: WarningFlag
Opt_WarnAmbiguousFields :: WarningFlag
Opt_WarnImplicitLift :: WarningFlag
Opt_WarnMissingKindSignatures :: WarningFlag
Opt_WarnUnicodeBidirectionalFormatCharacters :: WarningFlag

-- | Used when outputting warnings: if a reason is given, it is displayed.
--   If a warning isn't controlled by a flag, this is made explicit at the
--   point of use.
data WarnReason
NoReason :: WarnReason

-- | Warning was enabled with the flag
Reason :: !WarningFlag -> WarnReason

-- | Warning was made an error because of -Werror or -Werror=WarningFlag
ErrReason :: !Maybe WarningFlag -> WarnReason
data Language
Haskell98 :: Language
Haskell2010 :: Language
GHC2021 :: Language
data PlatformConstants
PlatformConstants :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> !Integer -> !Integer -> !Integer -> PlatformConstants
[pc_CONTROL_GROUP_CONST_291] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_STD_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_PROF_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCK_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCKS_PER_MBLOCK] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TICKY_BIN_COUNT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR7] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR8] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR9] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR10] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rL1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCCCS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentTSO] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentNursery] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpAlloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgEagerBlackholeInfo] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCEnter1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCFun] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_Capability_r] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_start] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_free] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_blocks] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_flags] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_CostCentreStack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ldvw] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSMPThunkHeader] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_registeredp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_link] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_entry_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgUpdateFrame_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_size] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSmallMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgSmallMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgArrBytes_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgArrBytes_bytes] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_alloc_limit] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_cccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_stackobj] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_sp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_stack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgUpdateFrame_updatee] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgFunInfoExtraRev] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_SELECTEE_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_AP_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_PAYLOAD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MUT_ARR_PTRS_CARD_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_C_STACK_BYTES] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_STACK_WORDS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_AP_STACK_SPLIM] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_WORD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CINT_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_LONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BITMAP_BITS_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TAG_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_LDV_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_ILDV_CREATE_MASK] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_CREATE] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_USE] :: PlatformConstants -> !Integer
type FatalMessager = String -> IO ()
newtype FlushOut
FlushOut :: IO () -> FlushOut
newtype FlushErr
FlushErr :: IO () -> FlushErr
data ProfAuto

-- | no SCC annotations added
NoProfAuto :: ProfAuto

-- | top-level and nested functions are annotated
ProfAutoAll :: ProfAuto

-- | top-level functions annotated only
ProfAutoTop :: ProfAuto

-- | exported functions annotated only
ProfAutoExports :: ProfAuto

-- | annotate call-sites
ProfAutoCalls :: ProfAuto
glasgowExtsFlags :: [Extension]

-- | Warning groups.
--   
--   As all warnings are in the Weverything set, it is ignored when
--   displaying to the user which group a warning is in.
warningGroups :: [(String, [WarningFlag])]

-- | Warning group hierarchies, where there is an explicit inclusion
--   relation.
--   
--   Each inner list is a hierarchy of warning groups, ordered from
--   smallest to largest, where each group is a superset of the one before
--   it.
--   
--   Separating this from <a>warningGroups</a> allows for multiple
--   hierarchies with no inherent relation to be defined.
--   
--   The special-case Weverything group is not included.
warningHierarchies :: [[String]]
hasPprDebug :: DynFlags -> Bool
hasNoDebugOutput :: DynFlags -> Bool
hasNoStateHack :: DynFlags -> Bool
hasNoOptCoercion :: DynFlags -> Bool

-- | Test whether a <a>DumpFlag</a> is set
dopt :: DumpFlag -> DynFlags -> Bool

-- | Set a <a>DumpFlag</a>
dopt_set :: DynFlags -> DumpFlag -> DynFlags

-- | Unset a <a>DumpFlag</a>
dopt_unset :: DynFlags -> DumpFlag -> DynFlags

-- | Test whether a <a>GeneralFlag</a> is set
--   
--   Note that <a>dynamicNow</a> (i.e., dynamic objects built with
--   `-dynamic-too`) always implicitly enables Opt_PIC,
--   Opt_ExternalDynamicRefs, and disables Opt_SplitSections.
gopt :: GeneralFlag -> DynFlags -> Bool

-- | Set a <a>GeneralFlag</a>
gopt_set :: DynFlags -> GeneralFlag -> DynFlags

-- | Unset a <a>GeneralFlag</a>
gopt_unset :: DynFlags -> GeneralFlag -> DynFlags
setGeneralFlag' :: GeneralFlag -> DynFlags -> DynFlags
unSetGeneralFlag' :: GeneralFlag -> DynFlags -> DynFlags

-- | Test whether a <a>WarningFlag</a> is set
wopt :: WarningFlag -> DynFlags -> Bool

-- | Set a <a>WarningFlag</a>
wopt_set :: DynFlags -> WarningFlag -> DynFlags

-- | Unset a <a>WarningFlag</a>
wopt_unset :: DynFlags -> WarningFlag -> DynFlags

-- | Test whether a <a>WarningFlag</a> is set as fatal
wopt_fatal :: WarningFlag -> DynFlags -> Bool

-- | Mark a <a>WarningFlag</a> as fatal (do not set the flag)
wopt_set_fatal :: DynFlags -> WarningFlag -> DynFlags

-- | Mark a <a>WarningFlag</a> as not fatal
wopt_unset_fatal :: DynFlags -> WarningFlag -> DynFlags

-- | Test whether a <a>Extension</a> is set
xopt :: Extension -> DynFlags -> Bool

-- | Set a <a>Extension</a>
xopt_set :: DynFlags -> Extension -> DynFlags

-- | Unset a <a>Extension</a>
xopt_unset :: DynFlags -> Extension -> DynFlags

-- | Set or unset a <a>Extension</a>, unless it has been explicitly set or
--   unset before.
xopt_set_unlessExplSpec :: Extension -> (DynFlags -> Extension -> DynFlags) -> DynFlags -> DynFlags
xopt_DuplicateRecordFields :: DynFlags -> DuplicateRecordFields
xopt_FieldSelectors :: DynFlags -> FieldSelectors
lang_set :: DynFlags -> Maybe Language -> DynFlags
data DynamicTooState

-- | Don't try to build dynamic objects too
DT_Dont :: DynamicTooState

-- | Won't try to generate dynamic objects for some reason
DT_Failed :: DynamicTooState

-- | Will still try to generate dynamic objects
DT_OK :: DynamicTooState

-- | Currently generating dynamic objects (in the backend)
DT_Dyn :: DynamicTooState
dynamicTooState :: MonadIO m => DynFlags -> m DynamicTooState
setDynamicNow :: DynFlags -> DynFlags
setDynamicTooFailed :: MonadIO m => DynFlags -> m ()

-- | Compute the path of the dynamic object corresponding to an object
--   file.
dynamicOutputFile :: DynFlags -> FilePath -> FilePath
dynamicOutputHi :: DynFlags -> FilePath -> FilePath

-- | Indicate if cost-centre profiling is enabled
sccProfilingEnabled :: DynFlags -> Bool

-- | Indicate whether we need to generate source notes
needSourceNotes :: DynFlags -> Bool

-- | Contains not only a collection of <a>GeneralFlag</a>s but also a
--   plethora of information relating to the compilation of a single file
--   or GHC session
data DynFlags
DynFlags :: GhcMode -> GhcLink -> !Backend -> {-# UNPACK #-} !GhcNameVersion -> {-# UNPACK #-} !FileSettings -> Platform -> {-# UNPACK #-} !ToolSettings -> {-# UNPACK #-} !PlatformMisc -> [(String, String)] -> LlvmConfig -> Int -> Int -> Int -> Int -> Int -> Maybe String -> Maybe String -> [Int] -> Maybe Int -> Bool -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Int -> Int -> Int -> Maybe Int -> Maybe Int -> Int -> Word -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Bool -> Maybe Int -> Int -> [FilePath] -> ModuleName -> Maybe String -> IntWithInf -> IntWithInf -> UnitId -> Maybe UnitId -> [(ModuleName, Module)] -> Ways -> Maybe (String, Int) -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> String -> String -> String -> String -> IORef Bool -> String -> String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> DynLibLoader -> !Bool -> Maybe FilePath -> Maybe FilePath -> [Option] -> IncludeSpecs -> [String] -> [String] -> [String] -> Maybe String -> RtsOptsEnabled -> Bool -> String -> [ModuleName] -> [(ModuleName, String)] -> [String] -> FilePath -> Bool -> Bool -> [ModuleName] -> [String] -> [PackageDBFlag] -> [IgnorePackageFlag] -> [PackageFlag] -> [PackageFlag] -> [TrustFlag] -> Maybe FilePath -> EnumSet DumpFlag -> EnumSet GeneralFlag -> EnumSet WarningFlag -> EnumSet WarningFlag -> Maybe Language -> SafeHaskellMode -> Bool -> Bool -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> [OnOff Extension] -> EnumSet Extension -> !UnfoldingOpts -> Int -> Int -> FlushOut -> FlushErr -> Maybe FilePath -> Maybe String -> [String] -> Int -> Int -> Bool -> OverridingBool -> Bool -> Scheme -> ProfAuto -> [CallerCcFilter] -> Maybe String -> IORef (ModuleEnv Int) -> Maybe SseVersion -> Maybe BmiVersion -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> IORef (Maybe LinkerInfo) -> IORef (Maybe CompilerInfo) -> Int -> Int -> Int -> Bool -> Maybe Int -> Word -> Int -> Weights -> DynFlags
[ghcMode] :: DynFlags -> GhcMode
[ghcLink] :: DynFlags -> GhcLink

-- | The backend to use (if any).
--   
--   Whenever you change the backend, also make sure to set <a>ghcLink</a>
--   to something sensible.
--   
--   <a>NoBackend</a> can be used to avoid generating any output, however,
--   note that:
--   
--   <ul>
--   <li>If a program uses Template Haskell the typechecker may need to run
--   code from an imported module. To facilitate this, code generation is
--   enabled for modules imported by modules that use template haskell,
--   using the default backend for the platform. See Note [-fno-code
--   mode].</li>
--   </ul>
[backend] :: DynFlags -> !Backend
[ghcNameVersion] :: DynFlags -> {-# UNPACK #-} !GhcNameVersion
[fileSettings] :: DynFlags -> {-# UNPACK #-} !FileSettings
[targetPlatform] :: DynFlags -> Platform
[toolSettings] :: DynFlags -> {-# UNPACK #-} !ToolSettings
[platformMisc] :: DynFlags -> {-# UNPACK #-} !PlatformMisc
[rawSettings] :: DynFlags -> [(String, String)]

-- | N.B. It's important that this field is lazy since we load the LLVM
--   configuration lazily. See Note [LLVM Configuration] in
--   <a>GHC.SysTools</a>.
[llvmConfig] :: DynFlags -> LlvmConfig

-- | Verbosity level: see Note [Verbosity levels]
[verbosity] :: DynFlags -> Int

-- | Optimisation level
[optLevel] :: DynFlags -> Int

-- | How much debug information to produce
[debugLevel] :: DynFlags -> Int

-- | Number of simplifier phases
[simplPhases] :: DynFlags -> Int

-- | Max simplifier iterations
[maxSimplIterations] :: DynFlags -> Int
[ruleCheck] :: DynFlags -> Maybe String

-- | A prefix to report inlining decisions about
[inlineCheck] :: DynFlags -> Maybe String

-- | Additional demand analysis
[strictnessBefore] :: DynFlags -> [Int]

-- | The number of modules to compile in parallel in --make mode, where
--   Nothing ==&gt; compile as many in parallel as there are CPUs.
[parMakeCount] :: DynFlags -> Maybe Int

-- | Enable RTS timing statistics?
[enableTimeStats] :: DynFlags -> Bool

-- | The heap size to set.
[ghcHeapSize] :: DynFlags -> Maybe Int

-- | Maximum number of bindings from the type envt to show in type error
--   messages
[maxRelevantBinds] :: DynFlags -> Maybe Int

-- | Maximum number of hole fits to show in typed hole error messages
[maxValidHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of refinement hole fits to show in typed hole error
--   messages
[maxRefHoleFits] :: DynFlags -> Maybe Int

-- | Maximum level of refinement for refinement hole fits in typed hole
--   error messages
[refLevelHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of unmatched patterns to show in non-exhaustiveness
--   warnings
[maxUncoveredPatterns] :: DynFlags -> Int

-- | Soft limit on the number of models the pattern match checker checks a
--   pattern against. A safe guard against exponential blow-up.
[maxPmCheckModels] :: DynFlags -> Int

-- | Multiplier for simplifier ticks
[simplTickFactor] :: DynFlags -> Int

-- | Threshold for SpecConstr
[specConstrThreshold] :: DynFlags -> Maybe Int

-- | Max number of specialisations for any one function
[specConstrCount] :: DynFlags -> Maybe Int

-- | Max number of specialisations for recursive types Not optional;
--   otherwise ForceSpecConstr can diverge.
[specConstrRecursive] :: DynFlags -> Int

-- | Binary literals (e.g. strings) whose size is above this threshold will
--   be dumped in a binary file by the assembler code generator (0 to
--   disable)
[binBlobThreshold] :: DynFlags -> Word

-- | Threshold for LiberateCase
[liberateCaseThreshold] :: DynFlags -> Maybe Int

-- | Arg count for lambda floating See <a>FloatOutSwitches</a>
[floatLamArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a recursive function.
[liftLamsRecArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a non-recursive
--   function.
[liftLamsNonRecArgs] :: DynFlags -> Maybe Int

-- | Lambda lift even when this turns a known call into an unknown call.
[liftLamsKnown] :: DynFlags -> Bool

-- | Align Cmm functions at this boundary or use default.
[cmmProcAlignment] :: DynFlags -> Maybe Int

-- | Simplification history size
[historySize] :: DynFlags -> Int
[importPaths] :: DynFlags -> [FilePath]
[mainModuleNameIs] :: DynFlags -> ModuleName
[mainFunIs] :: DynFlags -> Maybe String

-- | Typechecker maximum stack depth
[reductionDepth] :: DynFlags -> IntWithInf

-- | Number of iterations in the constraints solver Typically only 1 is
--   needed
[solverIterations] :: DynFlags -> IntWithInf

-- | Target home unit-id
[homeUnitId_] :: DynFlags -> UnitId

-- | Id of the unit to instantiate
[homeUnitInstanceOf_] :: DynFlags -> Maybe UnitId

-- | Module instantiations
[homeUnitInstantiations_] :: DynFlags -> [(ModuleName, Module)]

-- | Target way flags from the command line
[targetWays_] :: DynFlags -> Ways
[splitInfo] :: DynFlags -> Maybe (String, Int)
[objectDir] :: DynFlags -> Maybe String
[dylibInstallName] :: DynFlags -> Maybe String
[hiDir] :: DynFlags -> Maybe String
[hieDir] :: DynFlags -> Maybe String
[stubDir] :: DynFlags -> Maybe String
[dumpDir] :: DynFlags -> Maybe String
[objectSuf_] :: DynFlags -> String
[hcSuf] :: DynFlags -> String
[hiSuf_] :: DynFlags -> String
[hieSuf] :: DynFlags -> String
[dynamicTooFailed] :: DynFlags -> IORef Bool
[dynObjectSuf_] :: DynFlags -> String
[dynHiSuf_] :: DynFlags -> String
[outputFile_] :: DynFlags -> Maybe String
[dynOutputFile_] :: DynFlags -> Maybe String
[outputHi] :: DynFlags -> Maybe String
[dynOutputHi] :: DynFlags -> Maybe String
[dynLibLoader] :: DynFlags -> DynLibLoader

-- | Indicate if we are now generating dynamic output because of
--   -dynamic-too. This predicate is used to query the appropriate fields
--   (outputFile/dynOutputFile, ways, etc.)
[dynamicNow] :: DynFlags -> !Bool

-- | This is set by <a>runPipeline</a> or 'ghc.GHCi.UI.runStmt' based on
--   where its output is going.
[dumpPrefix] :: DynFlags -> Maybe FilePath

-- | Override the <a>dumpPrefix</a> set by <a>runPipeline</a> or
--   'ghc.GHCi.UI.runStmt'. Set by <tt>-ddump-file-prefix</tt>
[dumpPrefixForce] :: DynFlags -> Maybe FilePath
[ldInputs] :: DynFlags -> [Option]
[includePaths] :: DynFlags -> IncludeSpecs
[libraryPaths] :: DynFlags -> [String]
[frameworkPaths] :: DynFlags -> [String]
[cmdlineFrameworks] :: DynFlags -> [String]
[rtsOpts] :: DynFlags -> Maybe String
[rtsOptsEnabled] :: DynFlags -> RtsOptsEnabled
[rtsOptsSuggestions] :: DynFlags -> Bool

-- | Path to store the .mix files
[hpcDir] :: DynFlags -> String
[pluginModNames] :: DynFlags -> [ModuleName]
[pluginModNameOpts] :: DynFlags -> [(ModuleName, String)]

-- | the <tt>-ffrontend-opt</tt> flags given on the command line, in
--   *reverse* order that they're specified on the command line.
[frontendPluginOpts] :: DynFlags -> [String]
[depMakefile] :: DynFlags -> FilePath
[depIncludePkgDeps] :: DynFlags -> Bool
[depIncludeCppDeps] :: DynFlags -> Bool
[depExcludeMods] :: DynFlags -> [ModuleName]
[depSuffixes] :: DynFlags -> [String]

-- | The <tt>-package-db</tt> flags given on the command line, In *reverse*
--   order that they're specified on the command line. This is intended to
--   be applied with the list of "initial" package databases derived from
--   <tt>GHC_PACKAGE_PATH</tt>; see <tt>getUnitDbRefs</tt>.
[packageDBFlags] :: DynFlags -> [PackageDBFlag]

-- | The <tt>-ignore-package</tt> flags from the command line. In *reverse*
--   order that they're specified on the command line.
[ignorePackageFlags] :: DynFlags -> [IgnorePackageFlag]

-- | The <tt>-package</tt> and <tt>-hide-package</tt> flags from the
--   command-line. In *reverse* order that they're specified on the command
--   line.
[packageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-plugin-package-id</tt> flags from command line. In *reverse*
--   order that they're specified on the command line.
[pluginPackageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-trust</tt> and <tt>-distrust</tt> flags. In *reverse* order
--   that they're specified on the command line.
[trustFlags] :: DynFlags -> [TrustFlag]

-- | Filepath to the package environment file (if overriding default)
[packageEnv] :: DynFlags -> Maybe FilePath
[dumpFlags] :: DynFlags -> EnumSet DumpFlag
[generalFlags] :: DynFlags -> EnumSet GeneralFlag
[warningFlags] :: DynFlags -> EnumSet WarningFlag
[fatalWarningFlags] :: DynFlags -> EnumSet WarningFlag
[language] :: DynFlags -> Maybe Language

-- | Safe Haskell mode
[safeHaskell] :: DynFlags -> SafeHaskellMode
[safeInfer] :: DynFlags -> Bool
[safeInferred] :: DynFlags -> Bool
[thOnLoc] :: DynFlags -> SrcSpan
[newDerivOnLoc] :: DynFlags -> SrcSpan
[deriveViaOnLoc] :: DynFlags -> SrcSpan
[overlapInstLoc] :: DynFlags -> SrcSpan
[incoherentOnLoc] :: DynFlags -> SrcSpan
[pkgTrustOnLoc] :: DynFlags -> SrcSpan
[warnSafeOnLoc] :: DynFlags -> SrcSpan
[warnUnsafeOnLoc] :: DynFlags -> SrcSpan
[trustworthyOnLoc] :: DynFlags -> SrcSpan
[extensions] :: DynFlags -> [OnOff Extension]
[extensionFlags] :: DynFlags -> EnumSet Extension

-- | Unfolding control See Note [Discounts and thresholds] in
--   GHC.Core.Unfold
[unfoldingOpts] :: DynFlags -> !UnfoldingOpts
[maxWorkerArgs] :: DynFlags -> Int
[ghciHistSize] :: DynFlags -> Int
[flushOut] :: DynFlags -> FlushOut
[flushErr] :: DynFlags -> FlushErr
[ghcVersionFile] :: DynFlags -> Maybe FilePath
[haddockOptions] :: DynFlags -> Maybe String

-- | GHCi scripts specified by -ghci-script, in reverse order
[ghciScripts] :: DynFlags -> [String]
[pprUserLength] :: DynFlags -> Int
[pprCols] :: DynFlags -> Int
[useUnicode] :: DynFlags -> Bool
[useColor] :: DynFlags -> OverridingBool
[canUseColor] :: DynFlags -> Bool
[colScheme] :: DynFlags -> Scheme

-- | what kind of {-# SCC #-} to add automatically
[profAuto] :: DynFlags -> ProfAuto
[callerCcFilters] :: DynFlags -> [CallerCcFilter]
[interactivePrint] :: DynFlags -> Maybe String
[nextWrapperNum] :: DynFlags -> IORef (ModuleEnv Int)

-- | Machine dependent flags (-m&lt;blah&gt; stuff)
[sseVersion] :: DynFlags -> Maybe SseVersion
[bmiVersion] :: DynFlags -> Maybe BmiVersion
[avx] :: DynFlags -> Bool
[avx2] :: DynFlags -> Bool
[avx512cd] :: DynFlags -> Bool
[avx512er] :: DynFlags -> Bool
[avx512f] :: DynFlags -> Bool
[avx512pf] :: DynFlags -> Bool

-- | Run-time linker information (what options we need, etc.)
[rtldInfo] :: DynFlags -> IORef (Maybe LinkerInfo)

-- | Run-time compiler information
[rtccInfo] :: DynFlags -> IORef (Maybe CompilerInfo)

-- | Max size, in bytes, of inline array allocations.
[maxInlineAllocSize] :: DynFlags -> Int

-- | Only inline memcpy if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemcpyInsns] :: DynFlags -> Int

-- | Only inline memset if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemsetInsns] :: DynFlags -> Int

-- | Reverse the order of error messages in GHC/GHCi
[reverseErrors] :: DynFlags -> Bool

-- | Limit the maximum number of errors to show
[maxErrors] :: DynFlags -> Maybe Int

-- | Unique supply configuration for testing build determinism
[initialUnique] :: DynFlags -> Word
[uniqueIncrement] :: DynFlags -> Int

-- | Temporary: CFG Edge weights for fast iterations
[cfgWeights] :: DynFlags -> Weights
outputFile :: DynFlags -> Maybe String
hiSuf :: DynFlags -> String
objectSuf :: DynFlags -> String
ways :: DynFlags -> Ways
data FlagSpec flag
FlagSpec :: String -> flag -> (TurnOnFlag -> DynP ()) -> GhcFlagMode -> FlagSpec flag

-- | Flag in string form
[flagSpecName] :: FlagSpec flag -> String

-- | Flag in internal form
[flagSpecFlag] :: FlagSpec flag -> flag

-- | Extra action to run when the flag is found Typically, emit a warning
--   or error
[flagSpecAction] :: FlagSpec flag -> TurnOnFlag -> DynP ()

-- | In which ghc mode the flag has effect
[flagSpecGhcMode] :: FlagSpec flag -> GhcFlagMode
class HasDynFlags m
getDynFlags :: HasDynFlags m => m DynFlags
class ContainsDynFlags t
extractDynFlags :: ContainsDynFlags t => t -> DynFlags
data RtsOptsEnabled
RtsOptsNone :: RtsOptsEnabled
RtsOptsIgnore :: RtsOptsEnabled
RtsOptsIgnoreAll :: RtsOptsEnabled
RtsOptsSafeOnly :: RtsOptsEnabled
RtsOptsAll :: RtsOptsEnabled

-- | The <a>GhcMode</a> tells us whether we're doing multi-module
--   compilation (controlled via the <a>GHC</a> API) or one-shot
--   (single-module) compilation. This makes a difference primarily to the
--   <a>GHC.Unit.Finder</a>: in one-shot mode we look for interface files
--   for imported modules, but in multi-module mode we look for source
--   files in order to check whether they need to be recompiled.
data GhcMode

-- | <tt>--make</tt>, GHCi, etc.
CompManager :: GhcMode

-- | <pre>
--   ghc -c Foo.hs
--   </pre>
OneShot :: GhcMode

-- | <tt>ghc -M</tt>, see <a>GHC.Unit.Finder</a> for why we need this
MkDepend :: GhcMode
isOneShot :: GhcMode -> Bool

-- | What to do in the link step, if there is one.
data GhcLink

-- | Don't link at all
NoLink :: GhcLink

-- | Link object code into a binary
LinkBinary :: GhcLink

-- | Use the in-memory dynamic linker (works for both bytecode and object
--   code).
LinkInMemory :: GhcLink

-- | Link objects into a dynamic lib (DLL on Windows, DSO on ELF platforms)
LinkDynLib :: GhcLink

-- | Link objects into a static lib
LinkStaticLib :: GhcLink
isNoLink :: GhcLink -> Bool

-- | Flags for manipulating packages visibility.
data PackageFlag

-- | <tt>-package</tt>, <tt>-package-id</tt>
ExposePackage :: String -> PackageArg -> ModRenaming -> PackageFlag

-- | <pre>
--   -hide-package
--   </pre>
HidePackage :: String -> PackageFlag

-- | We accept flags which make packages visible, but how they select the
--   package varies; this data type reflects what selection criterion is
--   used.
data PackageArg

-- | <tt>-package</tt>, by <tt>PackageName</tt>
PackageArg :: String -> PackageArg

-- | <tt>-package-id</tt>, by <a>Unit</a>
UnitIdArg :: Unit -> PackageArg

-- | Represents the renaming that may be associated with an exposed
--   package, e.g. the <tt>rns</tt> part of <tt>-package "foo (rns)"</tt>.
--   
--   Here are some example parsings of the package flags (where a string
--   literal is punned to be a <a>ModuleName</a>:
--   
--   <ul>
--   <li><tt>-package foo</tt> is <tt>ModRenaming True []</tt></li>
--   <li><tt>-package foo ()</tt> is <tt>ModRenaming False []</tt></li>
--   <li><tt>-package foo (A)</tt> is <tt>ModRenaming False [(<a>A</a>,
--   <a>A</a>)]</tt></li>
--   <li><tt>-package foo (A as B)</tt> is <tt>ModRenaming False
--   [(<a>A</a>, <a>B</a>)]</tt></li>
--   <li><tt>-package foo with (A as B)</tt> is <tt>ModRenaming True
--   [(<a>A</a>, <a>B</a>)]</tt></li>
--   </ul>
data ModRenaming
ModRenaming :: Bool -> [(ModuleName, ModuleName)] -> ModRenaming

-- | Bring all exposed modules into scope?
[modRenamingWithImplicit] :: ModRenaming -> Bool

-- | Bring module <tt>m</tt> into scope under name <tt>n</tt>.
[modRenamings] :: ModRenaming -> [(ModuleName, ModuleName)]
packageFlagsChanged :: DynFlags -> DynFlags -> Bool

-- | Flags for manipulating the set of non-broken packages.
newtype IgnorePackageFlag

-- | <pre>
--   -ignore-package
--   </pre>
IgnorePackage :: String -> IgnorePackageFlag

-- | Flags for manipulating package trust.
data TrustFlag

-- | <pre>
--   -trust
--   </pre>
TrustPackage :: String -> TrustFlag

-- | <pre>
--   -distrust
--   </pre>
DistrustPackage :: String -> TrustFlag
data PackageDBFlag
PackageDB :: PkgDbRef -> PackageDBFlag
NoUserPackageDB :: PackageDBFlag
NoGlobalPackageDB :: PackageDBFlag
ClearPackageDBs :: PackageDBFlag
data PkgDbRef
GlobalPkgDb :: PkgDbRef
UserPkgDb :: PkgDbRef
PkgDbPath :: FilePath -> PkgDbRef

-- | When invoking external tools as part of the compilation pipeline, we
--   pass these a sequence of options on the command-line. Rather than just
--   using a list of Strings, we use a type that allows us to distinguish
--   between filepaths and 'other stuff'. The reason for this is that this
--   type gives us a handle on transforming filenames, and filenames only,
--   to whatever format they're expected to be on a particular platform.
data Option
FileOption :: String -> String -> Option
Option :: String -> Option
showOpt :: Option -> String
data DynLibLoader
Deployable :: DynLibLoader
SystemDependent :: DynLibLoader

-- | These <tt>-f&lt;blah&gt;</tt> flags can all be reversed with
--   <tt>-fno-&lt;blah&gt;</tt>
fFlags :: [FlagSpec GeneralFlag]

-- | These <tt>-f&lt;blah&gt;</tt> flags can all be reversed with
--   <tt>-fno-&lt;blah&gt;</tt>
fLangFlags :: [FlagSpec Extension]

-- | These -X<a>blah</a> flags can all be reversed with -XNo<a>blah</a>
xFlags :: [FlagSpec Extension]

-- | These <tt>-W&lt;blah&gt;</tt> flags can all be reversed with
--   <tt>-Wno-&lt;blah&gt;</tt>
wWarningFlags :: [FlagSpec WarningFlag]

-- | Find the <a>FlagSpec</a> for a <a>WarningFlag</a>.
wWarningFlagMap :: Map WarningFlag (FlagSpec WarningFlag)

-- | Some modules have dependencies on others through the DynFlags rather
--   than textual imports
dynFlagDependencies :: DynFlags -> [ModuleName]

-- | Resolve any internal inconsistencies in a set of <a>DynFlags</a>.
--   Returns the consistent <a>DynFlags</a> as well as a list of warnings
--   to report to the user.
makeDynFlagsConsistent :: DynFlags -> (DynFlags, [Located String])

-- | Are we building with <tt>-fPIE</tt> or <tt>-fPIC</tt> enabled?
positionIndependent :: DynFlags -> Bool
optimisationFlags :: EnumSet GeneralFlag
setFlagsFromEnvFile :: FilePath -> String -> DynP ()

-- | Pretty-print the difference between 2 DynFlags.
--   
--   For now only their general flags but it could be extended. Useful
--   mostly for debugging.
pprDynFlagsDiff :: DynFlags -> DynFlags -> SDoc
flagSpecOf :: WarningFlag -> Maybe (FlagSpec WarningFlag)

-- | Find the smallest group in every hierarchy which a warning belongs to,
--   excluding Weverything.
smallestGroups :: WarningFlag -> [String]

-- | Get target profile
targetProfile :: DynFlags -> Profile

-- | Is Safe Haskell on in some way (including inference mode)
safeHaskellOn :: DynFlags -> Bool
safeHaskellModeEnabled :: DynFlags -> Bool

-- | Test if Safe Imports are on in some form
safeImportsOn :: DynFlags -> Bool

-- | Is the Safe Haskell safe language in use
safeLanguageOn :: DynFlags -> Bool

-- | Is the Safe Haskell safe inference mode active
safeInferOn :: DynFlags -> Bool

-- | Is the -fpackage-trust mode on
packageTrustOn :: DynFlags -> Bool

-- | Are all direct imports required to be safe for this Safe Haskell mode?
--   Direct imports are when the code explicitly imports a module
safeDirectImpsReq :: DynFlags -> Bool

-- | Are all implicit imports required to be safe for this Safe Haskell
--   mode? Implicit imports are things in the prelude. e.g System.IO when
--   print is used.
safeImplicitImpsReq :: DynFlags -> Bool

-- | A list of unsafe flags under Safe Haskell. Tuple elements are: * name
--   of the flag * function to get srcspan that enabled the flag * function
--   to test if the flag is on * function to turn the flag off
unsafeFlags :: [(String, DynFlags -> SrcSpan, DynFlags -> Bool, DynFlags -> DynFlags)]

-- | A list of unsafe flags under Safe Haskell. Tuple elements are: * name
--   of the flag * function to get srcspan that enabled the flag * function
--   to test if the flag is on * function to turn the flag off
unsafeFlagsForInfer :: [(String, DynFlags -> SrcSpan, DynFlags -> Bool, DynFlags -> DynFlags)]
data LlvmTarget
LlvmTarget :: String -> String -> [String] -> LlvmTarget
[lDataLayout] :: LlvmTarget -> String
[lCPU] :: LlvmTarget -> String
[lAttributes] :: LlvmTarget -> [String]

-- | See Note [LLVM Configuration] in <a>GHC.SysTools</a>.
data LlvmConfig
LlvmConfig :: [(String, LlvmTarget)] -> [(Int, String)] -> LlvmConfig
[llvmTargets] :: LlvmConfig -> [(String, LlvmTarget)]
[llvmPasses] :: LlvmConfig -> [(Int, String)]
data Settings
Settings :: {-# UNPACK #-} !GhcNameVersion -> {-# UNPACK #-} !FileSettings -> Platform -> {-# UNPACK #-} !ToolSettings -> {-# UNPACK #-} !PlatformMisc -> [(String, String)] -> Settings
[sGhcNameVersion] :: Settings -> {-# UNPACK #-} !GhcNameVersion
[sFileSettings] :: Settings -> {-# UNPACK #-} !FileSettings
[sTargetPlatform] :: Settings -> Platform
[sToolSettings] :: Settings -> {-# UNPACK #-} !ToolSettings
[sPlatformMisc] :: Settings -> {-# UNPACK #-} !PlatformMisc
[sRawSettings] :: Settings -> [(String, String)]
sProgramName :: Settings -> String
sProjectVersion :: Settings -> String
sGhcUsagePath :: Settings -> FilePath
sGhciUsagePath :: Settings -> FilePath
sToolDir :: Settings -> Maybe FilePath
sTopDir :: Settings -> FilePath
sTmpDir :: Settings -> String
sGlobalPackageDatabasePath :: Settings -> FilePath
sLdSupportsCompactUnwind :: Settings -> Bool
sLdSupportsBuildId :: Settings -> Bool
sLdSupportsFilelist :: Settings -> Bool
sLdIsGnuLd :: Settings -> Bool
sGccSupportsNoPie :: Settings -> Bool
sPgm_L :: Settings -> String
sPgm_P :: Settings -> (String, [Option])
sPgm_F :: Settings -> String
sPgm_c :: Settings -> String
sPgm_a :: Settings -> (String, [Option])
sPgm_l :: Settings -> (String, [Option])
sPgm_lm :: Settings -> (String, [Option])
sPgm_dll :: Settings -> (String, [Option])
sPgm_T :: Settings -> String
sPgm_windres :: Settings -> String
sPgm_libtool :: Settings -> String
sPgm_ar :: Settings -> String
sPgm_ranlib :: Settings -> String
sPgm_lo :: Settings -> (String, [Option])
sPgm_lc :: Settings -> (String, [Option])
sPgm_lcc :: Settings -> (String, [Option])
sPgm_i :: Settings -> String
sOpt_L :: Settings -> [String]
sOpt_P :: Settings -> [String]
sOpt_P_fingerprint :: Settings -> Fingerprint
sOpt_F :: Settings -> [String]
sOpt_c :: Settings -> [String]
sOpt_cxx :: Settings -> [String]
sOpt_a :: Settings -> [String]
sOpt_l :: Settings -> [String]
sOpt_lm :: Settings -> [String]
sOpt_windres :: Settings -> [String]
sOpt_lo :: Settings -> [String]
sOpt_lc :: Settings -> [String]
sOpt_lcc :: Settings -> [String]
sOpt_i :: Settings -> [String]
sExtraGccViaCFlags :: Settings -> [String]
sTargetPlatformString :: Settings -> String
sGhcWithInterpreter :: Settings -> Bool
sGhcWithSMP :: Settings -> Bool
sGhcRTSWays :: Settings -> String
sLibFFI :: Settings -> Bool
sGhcRtsWithLibdw :: Settings -> Bool

-- | Settings for what GHC this is.
data GhcNameVersion
GhcNameVersion :: String -> String -> GhcNameVersion
[ghcNameVersion_programName] :: GhcNameVersion -> String
[ghcNameVersion_projectVersion] :: GhcNameVersion -> String

-- | Paths to various files and directories used by GHC, including those
--   that provide more settings.
data FileSettings
FileSettings :: FilePath -> FilePath -> Maybe FilePath -> FilePath -> String -> FilePath -> FileSettings
[fileSettings_ghcUsagePath] :: FileSettings -> FilePath
[fileSettings_ghciUsagePath] :: FileSettings -> FilePath
[fileSettings_toolDir] :: FileSettings -> Maybe FilePath
[fileSettings_topDir] :: FileSettings -> FilePath
[fileSettings_tmpDir] :: FileSettings -> String
[fileSettings_globalPackageDatabase] :: FileSettings -> FilePath

-- | Platform-specific settings formerly hard-coded in Config.hs.
--   
--   These should probably be all be triaged whether they can be computed
--   from other settings or belong in another another place (like
--   <a>Platform</a> above).
data PlatformMisc
PlatformMisc :: String -> Bool -> Bool -> String -> Bool -> Bool -> String -> PlatformMisc
[platformMisc_targetPlatformString] :: PlatformMisc -> String
[platformMisc_ghcWithInterpreter] :: PlatformMisc -> Bool
[platformMisc_ghcWithSMP] :: PlatformMisc -> Bool
[platformMisc_ghcRTSWays] :: PlatformMisc -> String
[platformMisc_libFFI] :: PlatformMisc -> Bool
[platformMisc_ghcRtsWithLibdw] :: PlatformMisc -> Bool
[platformMisc_llvmTarget] :: PlatformMisc -> String

-- | "unbuild" a <a>Settings</a> from a <a>DynFlags</a>. This shouldn't be
--   needed in the vast majority of code. But GHCi questionably uses this
--   to produce a default <a>DynFlags</a> from which to compute a flags
--   diff for printing.
settings :: DynFlags -> Settings
programName :: DynFlags -> String
projectVersion :: DynFlags -> String
ghcUsagePath :: DynFlags -> FilePath
ghciUsagePath :: DynFlags -> FilePath
topDir :: DynFlags -> FilePath
tmpDir :: DynFlags -> String

-- | The directory for this version of ghc in the user's app directory The
--   appdir used to be in ~/.ghc but to respect the XDG specification we
--   want to move it under $XDG_DATA_HOME/ However, old tooling (like
--   cabal) might still write package environments to the old directory, so
--   we prefer that if a subdirectory of ~/.ghc with the correct target and
--   GHC version suffix exists.
--   
--   i.e. if ~<i>.ghc</i>$UNIQUE_SUBDIR exists we use that otherwise we use
--   $XDG_DATA_HOME/$UNIQUE_SUBDIR
--   
--   UNIQUE_SUBDIR is typically a combination of the target platform and
--   GHC version
versionedAppDir :: String -> ArchOS -> MaybeT IO FilePath
versionedFilePath :: ArchOS -> FilePath
extraGccViaCFlags :: DynFlags -> [String]
globalPackageDatabasePath :: DynFlags -> FilePath
pgm_L :: DynFlags -> String
pgm_P :: DynFlags -> (String, [Option])
pgm_F :: DynFlags -> String
pgm_c :: DynFlags -> String
pgm_a :: DynFlags -> (String, [Option])
pgm_l :: DynFlags -> (String, [Option])
pgm_lm :: DynFlags -> (String, [Option])
pgm_dll :: DynFlags -> (String, [Option])
pgm_T :: DynFlags -> String
pgm_windres :: DynFlags -> String
pgm_libtool :: DynFlags -> String
pgm_ar :: DynFlags -> String
pgm_otool :: DynFlags -> String
pgm_install_name_tool :: DynFlags -> String
pgm_ranlib :: DynFlags -> String
pgm_lo :: DynFlags -> (String, [Option])
pgm_lc :: DynFlags -> (String, [Option])
pgm_lcc :: DynFlags -> (String, [Option])
pgm_i :: DynFlags -> String
opt_L :: DynFlags -> [String]
opt_P :: DynFlags -> [String]
opt_F :: DynFlags -> [String]
opt_c :: DynFlags -> [String]
opt_cxx :: DynFlags -> [String]
opt_a :: DynFlags -> [String]
opt_l :: DynFlags -> [String]
opt_lm :: DynFlags -> [String]
opt_i :: DynFlags -> [String]
opt_P_signature :: DynFlags -> ([String], Fingerprint)
opt_windres :: DynFlags -> [String]
opt_lo :: DynFlags -> [String]
opt_lc :: DynFlags -> [String]
opt_lcc :: DynFlags -> [String]
updatePlatformConstants :: DynFlags -> Maybe PlatformConstants -> IO DynFlags
addPluginModuleName :: String -> DynFlags -> DynFlags

-- | The normal <a>DynFlags</a>. Note that they are not suitable for use in
--   this form and must be fully initialized by <a>runGhc</a> first.
defaultDynFlags :: Settings -> LlvmConfig -> DynFlags

-- | Used by <a>runGhc</a> to partially initialize a new <a>DynFlags</a>
--   value
initDynFlags :: DynFlags -> IO DynFlags
defaultFatalMessager :: FatalMessager
defaultFlushOut :: FlushOut
defaultFlushErr :: FlushErr

-- | Retrieve the options corresponding to a particular <tt>opt_*</tt>
--   field in the correct order
getOpts :: DynFlags -> (DynFlags -> [a]) -> [a]

-- | Gets the verbosity flag for the current verbosity level. This is fed
--   to other tools, so GHC-specific verbosity flags like
--   <tt>-ddump-most</tt> are not included
getVerbFlags :: DynFlags -> [String]

-- | Sets the <a>DynFlags</a> to be appropriate to the optimisation level
updOptLevel :: Int -> DynFlags -> DynFlags
setTmpDir :: FilePath -> DynFlags -> DynFlags
setUnitId :: String -> DynFlags -> DynFlags
type TurnOnFlag = Bool
turnOn :: TurnOnFlag
turnOff :: TurnOnFlag
impliedGFlags :: [(GeneralFlag, TurnOnFlag, GeneralFlag)]
impliedOffGFlags :: [(GeneralFlag, TurnOnFlag, GeneralFlag)]
impliedXFlags :: [(Extension, TurnOnFlag, Extension)]

-- | Parse dynamic flags from a list of command line arguments. Returns the
--   parsed <a>DynFlags</a>, the left-over arguments, and a list of
--   warnings. Throws a <a>UsageError</a> if errors occurred during parsing
--   (such as unknown flags or missing arguments).
parseDynamicFlagsCmdLine :: MonadIO m => DynFlags -> [Located String] -> m (DynFlags, [Located String], [Warn])

-- | Like <a>parseDynamicFlagsCmdLine</a> but does not allow the package
--   flags (-package, -hide-package, -ignore-package, -hide-all-packages,
--   -package-db). Used to parse flags set in a modules pragma.
parseDynamicFilePragma :: MonadIO m => DynFlags -> [Located String] -> m (DynFlags, [Located String], [Warn])

-- | Parses the dynamically set flags for GHC. This is the most general
--   form of the dynamic flag parser that the other methods simply wrap. It
--   allows saying which flags are valid flags and indicating if we are
--   parsing arguments from the command line or from a file pragma.
parseDynamicFlagsFull :: MonadIO m => [Flag (CmdLineP DynFlags)] -> Bool -> DynFlags -> [Located String] -> m (DynFlags, [Located String], [Warn])

-- | All dynamic flags option strings without the deprecated ones. These
--   are the user facing strings for enabling and disabling options.
allNonDeprecatedFlags :: [String]
flagsAll :: [Flag (CmdLineP DynFlags)]
flagsDynamic :: [Flag (CmdLineP DynFlags)]
flagsPackage :: [Flag (CmdLineP DynFlags)]

-- | Make a list of flags for shell completion. Filter all available flags
--   into two groups, for interactive GHC vs all other.
flagsForCompletion :: Bool -> [String]
supportedLanguagesAndExtensions :: ArchOS -> [String]

-- | The language extensions implied by the various language variants. When
--   updating this be sure to update the flag documentation in
--   <tt>docs<i>users_guide</i>exts</tt>.
languageExtensions :: Maybe Language -> [Extension]
picCCOpts :: DynFlags -> [String]
picPOpts :: DynFlags -> [String]
compilerInfo :: DynFlags -> [(String, String)]
wordAlignment :: Platform -> Alignment
setUnsafeGlobalDynFlags :: DynFlags -> IO ()
isSseEnabled :: Platform -> Bool
isSse2Enabled :: Platform -> Bool
isSse4_2Enabled :: DynFlags -> Bool
isBmiEnabled :: DynFlags -> Bool
isBmi2Enabled :: DynFlags -> Bool
isAvxEnabled :: DynFlags -> Bool
isAvx2Enabled :: DynFlags -> Bool
isAvx512cdEnabled :: DynFlags -> Bool
isAvx512erEnabled :: DynFlags -> Bool
isAvx512fEnabled :: DynFlags -> Bool
isAvx512pfEnabled :: DynFlags -> Bool
data LinkerInfo
GnuLD :: [Option] -> LinkerInfo
GnuGold :: [Option] -> LinkerInfo
LlvmLLD :: [Option] -> LinkerInfo
DarwinLD :: [Option] -> LinkerInfo
SolarisLD :: [Option] -> LinkerInfo
AixLD :: [Option] -> LinkerInfo
UnknownLD :: LinkerInfo
data CompilerInfo
GCC :: CompilerInfo
Clang :: CompilerInfo
AppleClang :: CompilerInfo
AppleClang51 :: CompilerInfo
UnknownCC :: CompilerInfo

-- | Should we use `-XLinker -rpath` when linking or not? See Note
--   [-fno-use-rpaths]
useXLinkerRPath :: DynFlags -> OS -> Bool

-- | Used to differentiate the scope an include needs to apply to. We have
--   to split the include paths to avoid accidentally forcing recursive
--   includes since -I overrides the system search paths. See #14312.
data IncludeSpecs
IncludeSpecs :: [String] -> [String] -> [String] -> IncludeSpecs
[includePathsQuote] :: IncludeSpecs -> [String]
[includePathsGlobal] :: IncludeSpecs -> [String]

-- | See note [Implicit include paths]
[includePathsQuoteImplicit] :: IncludeSpecs -> [String]

-- | Append to the list of includes a path that shall be included using
--   `-I` when the C compiler is called. These paths override system search
--   paths.
addGlobalInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Append to the list of includes a path that shall be included using
--   `-iquote` when the C compiler is called. These paths only apply when
--   quoted includes are used. e.g. #include "foo.h"
addQuoteInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Concatenate and flatten the list of global and quoted includes
--   returning just a flat list of paths.
flattenIncludes :: IncludeSpecs -> [String]

-- | These includes are not considered while fingerprinting the flags for
--   iface | See note [Implicit include paths]
addImplicitQuoteInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Initialize the pretty-printing options
initSDocContext :: DynFlags -> PprStyle -> SDocContext

-- | Initialize the pretty-printing options using the default user style
initDefaultSDocContext :: DynFlags -> SDocContext
instance GHC.Show.Show GHC.Driver.Session.IncludeSpecs
instance GHC.Enum.Enum GHC.Driver.Session.ProfAuto
instance GHC.Classes.Eq GHC.Driver.Session.ProfAuto
instance GHC.Classes.Eq GHC.Driver.Session.GhcMode
instance GHC.Show.Show GHC.Driver.Session.GhcLink
instance GHC.Classes.Eq GHC.Driver.Session.GhcLink
instance GHC.Show.Show GHC.Driver.Session.PackageArg
instance GHC.Classes.Eq GHC.Driver.Session.PackageArg
instance GHC.Classes.Eq GHC.Driver.Session.ModRenaming
instance GHC.Classes.Eq GHC.Driver.Session.IgnorePackageFlag
instance GHC.Classes.Eq GHC.Driver.Session.TrustFlag
instance GHC.Classes.Eq GHC.Driver.Session.PackageFlag
instance GHC.Classes.Eq GHC.Driver.Session.DynLibLoader
instance GHC.Show.Show GHC.Driver.Session.RtsOptsEnabled
instance GHC.Classes.Ord GHC.Driver.Session.DynamicTooState
instance GHC.Show.Show GHC.Driver.Session.DynamicTooState
instance GHC.Classes.Eq GHC.Driver.Session.DynamicTooState
instance GHC.Show.Show a => GHC.Show.Show (GHC.Driver.Session.OnOff a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Driver.Session.OnOff a)
instance GHC.Classes.Ord GHC.Driver.Session.Deprecation
instance GHC.Classes.Eq GHC.Driver.Session.Deprecation
instance GHC.Classes.Eq GHC.Driver.Session.PkgDbRef
instance GHC.Classes.Eq GHC.Driver.Session.PackageDBFlag
instance GHC.Classes.Eq GHC.Driver.Session.LinkerInfo
instance GHC.Classes.Eq GHC.Driver.Session.CompilerInfo
instance (GHC.Base.Monoid a, GHC.Base.Monad m, GHC.Driver.Session.HasDynFlags m) => GHC.Driver.Session.HasDynFlags (Control.Monad.Trans.Writer.Lazy.WriterT a m)
instance (GHC.Base.Monad m, GHC.Driver.Session.HasDynFlags m) => GHC.Driver.Session.HasDynFlags (Control.Monad.Trans.Reader.ReaderT a m)
instance (GHC.Base.Monad m, GHC.Driver.Session.HasDynFlags m) => GHC.Driver.Session.HasDynFlags (Control.Monad.Trans.Maybe.MaybeT m)
instance (GHC.Base.Monad m, GHC.Driver.Session.HasDynFlags m) => GHC.Driver.Session.HasDynFlags (Control.Monad.Trans.Except.ExceptT e m)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Driver.Session.OnOff a)
instance GHC.Utils.Outputable.Outputable GHC.Driver.Session.PackageFlag
instance GHC.Utils.Outputable.Outputable GHC.Driver.Session.ModRenaming
instance GHC.Utils.Outputable.Outputable GHC.Driver.Session.PackageArg
instance GHC.Utils.Outputable.Outputable GHC.Driver.Session.GhcMode


-- | Parsers for unit/module identifiers
module GHC.Unit.Parser
parseUnit :: ReadP Unit
parseIndefUnitId :: ReadP IndefUnitId
parseHoleyModule :: ReadP Module
parseModSubst :: ReadP [(ModuleName, Module)]


-- | This stuff here is related to supporting the Safe Haskell extension,
--   primarily about storing under what trust type a module has been
--   compiled.
module GHC.Types.SafeHaskell

-- | Is an import a safe import?
type IsSafeImport = Bool

-- | The various Safe Haskell modes
data SafeHaskellMode

-- | inferred unsafe
Sf_None :: SafeHaskellMode

-- | declared and checked
Sf_Unsafe :: SafeHaskellMode

-- | declared and checked
Sf_Trustworthy :: SafeHaskellMode

-- | declared and checked
Sf_Safe :: SafeHaskellMode

-- | inferred as safe
Sf_SafeInferred :: SafeHaskellMode

-- | <tt>-fno-safe-haskell</tt> state
Sf_Ignore :: SafeHaskellMode

-- | Safe Haskell information for <tt>ModIface</tt> Simply a wrapper around
--   SafeHaskellMode to sepperate iface and flags
data IfaceTrustInfo
getSafeMode :: IfaceTrustInfo -> SafeHaskellMode
setSafeMode :: SafeHaskellMode -> IfaceTrustInfo
noIfaceTrustInfo :: IfaceTrustInfo
instance GHC.Classes.Eq GHC.Types.SafeHaskell.SafeHaskellMode
instance GHC.Utils.Outputable.Outputable GHC.Types.SafeHaskell.IfaceTrustInfo
instance GHC.Utils.Binary.Binary GHC.Types.SafeHaskell.IfaceTrustInfo
instance GHC.Show.Show GHC.Types.SafeHaskell.SafeHaskellMode
instance GHC.Utils.Outputable.Outputable GHC.Types.SafeHaskell.SafeHaskellMode

module GHC.Types.FieldLabel

-- | Field labels are just represented as strings; they are not necessarily
--   unique (even within a module)
type FieldLabelString = FastString

-- | A map from labels to all the auxiliary information
type FieldLabelEnv = DFastStringEnv FieldLabel

-- | Fields in an algebraic record type; see Note [FieldLabel].
data FieldLabel
FieldLabel :: FieldLabelString -> DuplicateRecordFields -> FieldSelectors -> Name -> FieldLabel

-- | User-visible label of the field
[flLabel] :: FieldLabel -> FieldLabelString

-- | Was <tt>DuplicateRecordFields</tt> on in the defining module for this
--   datatype?
[flHasDuplicateRecordFields] :: FieldLabel -> DuplicateRecordFields

-- | Was <tt>FieldSelectors</tt> enabled in the defining module for this
--   datatype? See Note [NoFieldSelectors] in GHC.Rename.Env
[flHasFieldSelector] :: FieldLabel -> FieldSelectors

-- | Record selector function
[flSelector] :: FieldLabel -> Name

-- | Record selector OccNames are built from the underlying field name and
--   the name of the first data constructor of the type, to support
--   duplicate record field names. See Note [Why selector names include
--   data constructors].
fieldSelectorOccName :: FieldLabelString -> OccName -> DuplicateRecordFields -> FieldSelectors -> OccName

-- | Undo the name mangling described in Note [FieldLabel] to produce a
--   Name that has the user-visible OccName (but the selector's unique).
--   This should be used only when generating output, when we want to show
--   the label, but may need to qualify it with a module prefix.
fieldLabelPrintableName :: FieldLabel -> Name

-- | Flag to indicate whether the DuplicateRecordFields extension is
--   enabled.
data DuplicateRecordFields

-- | Fields may be duplicated in a single module
DuplicateRecordFields :: DuplicateRecordFields

-- | Fields must be unique within a module (the default)
NoDuplicateRecordFields :: DuplicateRecordFields

-- | Flag to indicate whether the FieldSelectors extension is enabled.
data FieldSelectors

-- | Selector functions are available (the default)
FieldSelectors :: FieldSelectors

-- | Selector functions are not available
NoFieldSelectors :: FieldSelectors
flIsOverloaded :: FieldLabel -> Bool
instance Data.Data.Data GHC.Types.FieldLabel.DuplicateRecordFields
instance GHC.Classes.Eq GHC.Types.FieldLabel.DuplicateRecordFields
instance GHC.Show.Show GHC.Types.FieldLabel.DuplicateRecordFields
instance Data.Data.Data GHC.Types.FieldLabel.FieldSelectors
instance GHC.Classes.Eq GHC.Types.FieldLabel.FieldSelectors
instance GHC.Show.Show GHC.Types.FieldLabel.FieldSelectors
instance GHC.Classes.Eq GHC.Types.FieldLabel.FieldLabel
instance Data.Data.Data GHC.Types.FieldLabel.FieldLabel
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.FieldLabel.FieldLabel
instance GHC.Utils.Outputable.Outputable GHC.Types.FieldLabel.FieldLabel
instance GHC.Utils.Binary.Binary GHC.Types.Name.Name => GHC.Utils.Binary.Binary GHC.Types.FieldLabel.FieldLabel
instance GHC.Utils.Binary.Binary GHC.Types.FieldLabel.FieldSelectors
instance GHC.Utils.Outputable.Outputable GHC.Types.FieldLabel.FieldSelectors
instance GHC.Utils.Binary.Binary GHC.Types.FieldLabel.DuplicateRecordFields
instance GHC.Utils.Outputable.Outputable GHC.Types.FieldLabel.DuplicateRecordFields

module GHC.SysTools.BaseDir

-- | Expand occurrences of the <tt>$topdir</tt> interpolation in a string.
expandTopDir :: FilePath -> String -> String

-- | Expand occurrences of the <tt>$tooldir</tt> interpolation in a string
--   on Windows, leave the string untouched otherwise.
expandToolDir :: Maybe FilePath -> String -> String

-- | Returns a Unix-format path pointing to TopDir.
findTopDir :: Maybe String -> IO String
findToolDir :: FilePath -> IO (Maybe FilePath)
tryFindTopDir :: Maybe String -> IO (Maybe String)


-- | Ways
--   
--   The central concept of a "way" is that all objects in a given program
--   must be compiled in the same "way". Certain options change parameters
--   of the virtual machine, eg. profiling adds an extra word to the object
--   header, so profiling objects cannot be linked with non-profiling
--   objects.
--   
--   After parsing the command-line options, we determine which "way" we
--   are building - this might be a combination way, eg.
--   profiling+threaded.
--   
--   There are two kinds of ways: - RTS only: only affect the runtime
--   system (RTS) and don't affect code generation (e.g. threaded, debug) -
--   Full ways: affect code generation and the RTS (e.g. profiling, dynamic
--   linking)
--   
--   We then find the "build-tag" associated with this way, and this
--   becomes the suffix used to find .hi files and libraries used in this
--   compilation.
module GHC.Platform.Ways

-- | A way
--   
--   Don't change the constructor order as it us used by <a>waysTag</a> to
--   create a unique tag (e.g. thr_debug_p) which is expected by other
--   tools (e.g. Cabal).
data Way

-- | for GHC API clients building custom variants
WayCustom :: String -> Way

-- | (RTS only) Multithreaded runtime system
WayThreaded :: Way

-- | Debugging, enable trace messages and extra checks
WayDebug :: Way

-- | Profiling, enable cost-centre stacks and profiling reports
WayProf :: Way

-- | (RTS only) enable event logging (tracing)
WayTracing :: Way

-- | Dynamic linking
WayDyn :: Way
type Ways = Set Way

-- | Test if a ways is enabled
hasWay :: Ways -> Way -> Bool

-- | Add a way
addWay :: Way -> Ways -> Ways

-- | Check if a combination of ways is allowed
allowed_combination :: Ways -> Bool

-- | Turn these flags on when enabling this way
wayGeneralFlags :: Platform -> Way -> [GeneralFlag]

-- | Turn these flags off when enabling this way
wayUnsetGeneralFlags :: Platform -> Way -> [GeneralFlag]

-- | Pass these options to the C compiler when enabling this way
wayOptc :: Platform -> Way -> [String]

-- | Pass these options to linker when enabling this way
wayOptl :: Platform -> Way -> [String]

-- | Pass these options to the preprocessor when enabling this way
wayOptP :: Platform -> Way -> [String]
wayDesc :: Way -> String

-- | Return true for ways that only impact the RTS, not the generated code
wayRTSOnly :: Way -> Bool

-- | Unique build-tag associated to a way
wayTag :: Way -> String

-- | Unique tag associated to a list of ways
waysTag :: Ways -> String

-- | Unique build-tag associated to a list of ways
--   
--   RTS only ways are filtered out because they have no impact on the
--   build.
waysBuildTag :: Ways -> String

-- | Filter ways that have an impact on compilation
fullWays :: Ways -> Ways

-- | Filter RTS-only ways (ways that don't have an impact on compilation)
rtsWays :: Ways -> Ways

-- | Host ways.
hostWays :: Ways

-- | Host "full" ways (i.e. ways that have an impact on the compilation,
--   not RTS only ways).
--   
--   These ways must be used when compiling codes targeting the internal
--   interpreter.
hostFullWays :: Ways

-- | Consult the RTS to find whether it has been built with profiling
--   enabled.
hostIsProfiled :: Bool

-- | Consult the RTS to find whether GHC itself has been built with dynamic
--   linking. This can't be statically known at compile-time, because we
--   build both the static and dynamic versions together with -dynamic-too.
hostIsDynamic :: Bool

-- | Consult the RTS to find whether it is threaded.
hostIsThreaded :: Bool

-- | Consult the RTS to find whether it is debugged.
hostIsDebugged :: Bool

-- | Consult the RTS to find whether it is tracing.
hostIsTracing :: Bool
instance GHC.Show.Show GHC.Platform.Ways.Way
instance GHC.Classes.Ord GHC.Platform.Ways.Way
instance GHC.Classes.Eq GHC.Platform.Ways.Way


-- | Platform profiles
module GHC.Platform.Profile

-- | A platform profile fully describes the kind of objects that are
--   generated for a platform.
--   
--   <a>Platform</a> doesn't fully describe the ABI of an object. Compiler
--   ways (profiling, debug, dynamic) also modify the ABI.
data Profile
Profile :: !Platform -> !Ways -> Profile

-- | Platform
[profilePlatform] :: Profile -> !Platform

-- | Ways
[profileWays] :: Profile -> !Ways

-- | Unique build tag for the profile
profileBuildTag :: Profile -> String

-- | Get platform constants
profileConstants :: Profile -> PlatformConstants

-- | Is profiling enabled
profileIsProfiling :: Profile -> Bool

-- | Word size in bytes
profileWordSizeInBytes :: Profile -> Int

module GHC.Driver.Phases
data Phase
Unlit :: HscSource -> Phase
Cpp :: HscSource -> Phase
HsPp :: HscSource -> Phase
Hsc :: HscSource -> Phase
Ccxx :: Phase
Cc :: Phase
Cobjc :: Phase
Cobjcxx :: Phase
HCc :: Phase
As :: Bool -> Phase
LlvmOpt :: Phase
LlvmLlc :: Phase
LlvmMangle :: Phase
CmmCpp :: Phase
Cmm :: Phase
MergeForeign :: Phase
StopLn :: Phase
happensBefore :: Platform -> Phase -> Phase -> Bool
eqPhase :: Phase -> Phase -> Bool
anyHsc :: Phase
isStopLn :: Phase -> Bool
startPhase :: String -> Phase
phaseInputExt :: Phase -> String
isHaskellishSuffix :: String -> Bool
isHaskellSrcSuffix :: String -> Bool
isBackpackishSuffix :: String -> Bool
isObjectSuffix :: Platform -> String -> Bool
isCishSuffix :: String -> Bool
isDynLibSuffix :: Platform -> String -> Bool
isHaskellUserSrcSuffix :: String -> Bool
isHaskellSigSuffix :: String -> Bool
isSourceSuffix :: String -> Bool

-- | When we are given files (modified by -x arguments) we need to
--   determine if they are Haskellish or not to figure out how we should
--   try to compile it. The rules are:
--   
--   <ol>
--   <li>If no -x flag was specified, we check to see if the file looks
--   like a module name, has no extension, or has a Haskell source
--   extension.</li>
--   <li>If an -x flag was specified, we just make sure the specified
--   suffix is a Haskell one.</li>
--   </ol>
isHaskellishTarget :: (String, Maybe Phase) -> Bool
isHaskellishFilename :: FilePath -> Bool
isHaskellSrcFilename :: FilePath -> Bool
isHaskellSigFilename :: FilePath -> Bool
isObjectFilename :: Platform -> FilePath -> Bool
isCishFilename :: FilePath -> Bool
isDynLibFilename :: Platform -> FilePath -> Bool
isHaskellUserSrcFilename :: FilePath -> Bool
isSourceFilename :: FilePath -> Bool

-- | Foreign language of the phase if the phase deals with a foreign code
phaseForeignLanguage :: Phase -> Maybe ForeignSrcLang
instance GHC.Show.Show GHC.Driver.Phases.Phase
instance GHC.Classes.Eq GHC.Driver.Phases.Phase
instance GHC.Utils.Outputable.Outputable GHC.Driver.Phases.Phase

module GHC.Types.SourceFile
data HscSource

-- | .hs file
HsSrcFile :: HscSource

-- | .hs-boot file
HsBootFile :: HscSource

-- | .hsig file
HsigFile :: HscSource

-- | Indicates whether a given module's source has been modified since it
--   was last compiled.
data SourceModified

-- | the source has been modified
SourceModified :: SourceModified

-- | the source has not been modified. Compilation may or may not be
--   necessary, depending on whether any dependencies have changed since we
--   last compiled.
SourceUnmodified :: SourceModified

-- | the source has not been modified, and furthermore all of its
--   (transitive) dependencies are up to date; it definitely does not need
--   to be recompiled. This is important for two reasons: (a) we can omit
--   the version check in checkOldIface, and (b) if the module used TH
--   splices we don't need to force recompilation.
SourceUnmodifiedAndStable :: SourceModified
isHsBootOrSig :: HscSource -> Bool
isHsigFile :: HscSource -> Bool
hscSourceString :: HscSource -> String
instance GHC.Show.Show GHC.Types.SourceFile.HscSource
instance GHC.Classes.Ord GHC.Types.SourceFile.HscSource
instance GHC.Classes.Eq GHC.Types.SourceFile.HscSource
instance GHC.Utils.Binary.Binary GHC.Types.SourceFile.HscSource


-- | Command-line parser
--   
--   This is an abstract command-line parser used by DynFlags.
--   
--   (c) The University of Glasgow 2005
module GHC.Driver.CmdLine
processArgs :: Monad m => [Flag m] -> [Located String] -> m ([Located String], [Err], [Warn])
data OptKind m
NoArg :: EwM m () -> OptKind m
HasArg :: (String -> EwM m ()) -> OptKind m
SepArg :: (String -> EwM m ()) -> OptKind m
Prefix :: (String -> EwM m ()) -> OptKind m
OptPrefix :: (String -> EwM m ()) -> OptKind m
OptIntSuffix :: (Maybe Int -> EwM m ()) -> OptKind m
IntSuffix :: (Int -> EwM m ()) -> OptKind m
WordSuffix :: (Word -> EwM m ()) -> OptKind m
FloatSuffix :: (Float -> EwM m ()) -> OptKind m
PassFlag :: (String -> EwM m ()) -> OptKind m
AnySuffix :: (String -> EwM m ()) -> OptKind m

-- | GHC flag modes describing when a flag has an effect.
data GhcFlagMode

-- | The flag only affects the non-interactive GHC
OnlyGhc :: GhcFlagMode

-- | The flag only affects the interactive GHC
OnlyGhci :: GhcFlagMode

-- | The flag affects multiple ghc modes
AllModes :: GhcFlagMode

-- | This flag should not be seen in cli completion
HiddenFlag :: GhcFlagMode
newtype CmdLineP s a
CmdLineP :: (s -> (a, s)) -> CmdLineP s a
[runCmdLine] :: CmdLineP s a -> s -> (a, s)
getCmdLineState :: CmdLineP s s
putCmdLineState :: s -> CmdLineP s ()
data Flag m
Flag :: String -> OptKind m -> GhcFlagMode -> Flag m
[flagName] :: Flag m -> String
[flagOptKind] :: Flag m -> OptKind m
[flagGhcMode] :: Flag m -> GhcFlagMode
defFlag :: String -> OptKind m -> Flag m
defGhcFlag :: String -> OptKind m -> Flag m
defGhciFlag :: String -> OptKind m -> Flag m
defHiddenFlag :: String -> OptKind m -> Flag m
errorsToGhcException :: [(String, String)] -> GhcException

-- | A command-line error message
newtype Err
Err :: Located String -> Err
[errMsg] :: Err -> Located String

-- | A command-line warning message and the reason it arose
data Warn
Warn :: WarnReason -> Located String -> Warn
[warnReason] :: Warn -> WarnReason
[warnMsg] :: Warn -> Located String

-- | Used when filtering warnings: if a reason is given it can be filtered
--   out when displaying.
data WarnReason
NoReason :: WarnReason
ReasonDeprecatedFlag :: WarnReason
ReasonUnrecognisedFlag :: WarnReason
data EwM m a
runEwM :: EwM m a -> m (Errs, Warns, a)
addErr :: Monad m => String -> EwM m ()
addWarn :: Monad m => String -> EwM m ()
addFlagWarn :: Monad m => WarnReason -> String -> EwM m ()
getArg :: Monad m => EwM m String
getCurLoc :: Monad m => EwM m SrcSpan
liftEwM :: Monad m => m a -> EwM m a
deprecate :: Monad m => String -> EwM m ()
instance GHC.Show.Show GHC.Driver.CmdLine.WarnReason
instance GHC.Classes.Eq GHC.Driver.CmdLine.WarnReason
instance GHC.Base.Functor (GHC.Driver.CmdLine.CmdLineP s)
instance GHC.Base.Applicative (GHC.Driver.CmdLine.CmdLineP s)
instance GHC.Base.Monad (GHC.Driver.CmdLine.CmdLineP s)
instance GHC.Base.Monad m => GHC.Base.Functor (GHC.Driver.CmdLine.EwM m)
instance GHC.Base.Monad m => GHC.Base.Applicative (GHC.Driver.CmdLine.EwM m)
instance GHC.Base.Monad m => GHC.Base.Monad (GHC.Driver.CmdLine.EwM m)
instance GHC.Utils.Outputable.Outputable GHC.Driver.CmdLine.WarnReason
instance GHC.Utils.Json.ToJson GHC.Driver.CmdLine.WarnReason

module GHC.Core.Unfold

-- | Records the <i>unfolding</i> of an identifier, which is approximately
--   the form the identifier would have if we substituted its definition in
--   for the identifier. This type should be treated as abstract everywhere
--   except in <a>GHC.Core.Unfold</a>
data Unfolding

-- | <a>UnfoldingGuidance</a> says when unfolding should take place
data UnfoldingGuidance

-- | Unfolding options
data UnfoldingOpts
UnfoldingOpts :: !Int -> !Int -> !Int -> !Int -> !Bool -> !Int -> !Int -> UnfoldingOpts

-- | Threshold above which unfoldings are not *created*
[unfoldingCreationThreshold] :: UnfoldingOpts -> !Int

-- | Threshold above which unfoldings are not *inlined*
[unfoldingUseThreshold] :: UnfoldingOpts -> !Int

-- | Discount for lambdas that are used (applied)
[unfoldingFunAppDiscount] :: UnfoldingOpts -> !Int

-- | Discount for dictionaries
[unfoldingDictDiscount] :: UnfoldingOpts -> !Int

-- | Force inlining in many more cases
[unfoldingVeryAggressive] :: UnfoldingOpts -> !Bool
[unfoldingCaseThreshold] :: UnfoldingOpts -> !Int
[unfoldingCaseScaling] :: UnfoldingOpts -> !Int
defaultUnfoldingOpts :: UnfoldingOpts
updateCreationThreshold :: Int -> UnfoldingOpts -> UnfoldingOpts
updateUseThreshold :: Int -> UnfoldingOpts -> UnfoldingOpts
updateFunAppDiscount :: Int -> UnfoldingOpts -> UnfoldingOpts
updateDictDiscount :: Int -> UnfoldingOpts -> UnfoldingOpts
updateVeryAggressive :: Bool -> UnfoldingOpts -> UnfoldingOpts
updateCaseScaling :: Int -> UnfoldingOpts -> UnfoldingOpts
updateCaseThreshold :: Int -> UnfoldingOpts -> UnfoldingOpts
data ArgSummary
TrivArg :: ArgSummary
NonTrivArg :: ArgSummary
ValueArg :: ArgSummary
couldBeSmallEnoughToInline :: UnfoldingOpts -> Int -> CoreExpr -> Bool
inlineBoringOk :: CoreExpr -> Bool

-- | Sees if the unfolding is pretty certain to inline. If so, return a
--   *stable* unfolding for it, that will always inline.
certainlyWillInline :: UnfoldingOpts -> IdInfo -> Maybe Unfolding
smallEnoughToInline :: UnfoldingOpts -> Unfolding -> Bool
callSiteInline :: Logger -> DynFlags -> Int -> Id -> Bool -> Bool -> [ArgSummary] -> CallCtxt -> Maybe CoreExpr
data CallCtxt
BoringCtxt :: CallCtxt
RhsCtxt :: CallCtxt
DiscArgCtxt :: CallCtxt
RuleArgCtxt :: CallCtxt
ValAppCtxt :: CallCtxt
CaseCtxt :: CallCtxt
calcUnfoldingGuidance :: UnfoldingOpts -> Bool -> CoreExpr -> UnfoldingGuidance
instance GHC.Utils.Outputable.Outputable GHC.Core.Unfold.CallCtxt
instance GHC.Utils.Outputable.Outputable GHC.Core.Unfold.ArgSummary
instance GHC.Utils.Outputable.Outputable GHC.Core.Unfold.ExprSize

module GHC.Types.Tickish
data GenTickish pass

-- | An <tt>{-# SCC #-}</tt> profiling annotation, either automatically
--   added by the desugarer as a result of -auto-all, or added by the user.
ProfNote :: CostCentre -> !Bool -> !Bool -> GenTickish pass

-- | the cost centre
[profNoteCC] :: GenTickish pass -> CostCentre

-- | bump the entry count?
[profNoteCount] :: GenTickish pass -> !Bool

-- | scopes over the enclosed expression (i.e. not just a tick)
[profNoteScope] :: GenTickish pass -> !Bool

-- | A "tick" used by HPC to track the execution of each subexpression in
--   the original source code.
HpcTick :: Module -> !Int -> GenTickish pass
[tickModule] :: GenTickish pass -> Module
[tickId] :: GenTickish pass -> !Int

-- | A breakpoint for the GHCi debugger. This behaves like an HPC tick, but
--   has a list of free variables which will be available for inspection in
--   GHCi when the program stops at the breakpoint.
--   
--   NB. we must take account of these Ids when (a) counting free
--   variables, and (b) substituting (don't substitute for them)
Breakpoint :: XBreakpoint pass -> !Int -> [XTickishId pass] -> GenTickish pass
[breakpointExt] :: GenTickish pass -> XBreakpoint pass
[breakpointId] :: GenTickish pass -> !Int

-- | the order of this list is important: it matches the order of the lists
--   in the appropriate entry in <a>ModBreaks</a>.
--   
--   Careful about substitution! See Note [substTickish] in
--   <a>GHC.Core.Subst</a>.
[breakpointFVs] :: GenTickish pass -> [XTickishId pass]

-- | A source note.
--   
--   Source notes are pure annotations: Their presence should neither
--   influence compilation nor execution. The semantics are given by
--   causality: The presence of a source note means that a local change in
--   the referenced source code span will possibly provoke the generated
--   code to change. On the flip-side, the functionality of annotated code
--   *must* be invariant against changes to all source code *except* the
--   spans referenced in the source notes (see "Causality of optimized
--   Haskell" paper for details).
--   
--   Therefore extending the scope of any given source note is always
--   valid. Note that it is still undesirable though, as this reduces their
--   usefulness for debugging and profiling. Therefore we will generally
--   try only to make use of this property where it is necessary to enable
--   optimizations.
SourceNote :: RealSrcSpan -> String -> GenTickish pass

-- | Source covered
[sourceSpan] :: GenTickish pass -> RealSrcSpan

-- | Name for source location (uses same names as CCs)
[sourceName] :: GenTickish pass -> String
type CoreTickish = GenTickish 'TickishPassCore
type StgTickish = GenTickish 'TickishPassStg

-- | Tickish in Cmm context (annotations only)
type CmmTickish = GenTickish 'TickishPassCmm
type family XTickishId (pass :: TickishPass)

-- | A "counting tick" (where tickishCounts is True) is one that counts
--   evaluations in some way. We cannot discard a counting tick, and the
--   compiler should preserve the number of counting ticks as far as
--   possible.
--   
--   However, we still allow the simplifier to increase or decrease
--   sharing, so in practice the actual number of ticks may vary, except
--   that we never change the value from zero to non-zero or vice versa.
tickishCounts :: GenTickish pass -> Bool

-- | Specifies the scoping behaviour of ticks. This governs the behaviour
--   of ticks that care about the covered code and the cost associated with
--   it. Important for ticks relating to profiling.
data TickishScoping

-- | No scoping: The tick does not care about what code it covers.
--   Transformations can freely move code inside as well as outside without
--   any additional annotation obligations
NoScope :: TickishScoping

-- | Soft scoping: We want all code that is covered to stay covered. Note
--   that this scope type does not forbid transformations from happening,
--   as long as all results of the transformations are still covered by
--   this tick or a copy of it. For example
--   
--   let x = tick<a>...</a> (let y = foo in bar) in baz ===&gt; let x =
--   tick<a>...</a> bar; y = tick<a>...</a> foo in baz
--   
--   Is a valid transformation as far as "bar" and "foo" is concerned,
--   because both still are scoped over by the tick.
--   
--   Note though that one might object to the "let" not being covered by
--   the tick any more. However, we are generally lax with this - constant
--   costs don't matter too much, and given that the "let" was effectively
--   merged we can view it as having lost its identity anyway.
--   
--   Also note that this scoping behaviour allows floating a tick "upwards"
--   in pretty much any situation. For example:
--   
--   case foo of x -&gt; tick<a>...</a> bar ==&gt; tick<a>...</a> case foo
--   of x -&gt; bar
--   
--   While this is always legal, we want to make a best effort to only make
--   us of this where it exposes transformation opportunities.
SoftScope :: TickishScoping

-- | Cost centre scoping: We don't want any costs to move to other
--   cost-centre stacks. This means we not only want no code or cost to get
--   moved out of their cost centres, but we also object to code getting
--   associated with new cost-centre ticks - or changing the order in which
--   they get applied.
--   
--   A rule of thumb is that we don't want any code to gain new
--   annotations. However, there are notable exceptions, for example:
--   
--   let f = y -&gt; foo in tick<a>...</a> ... (f x) ... ==&gt;
--   tick<a>...</a> ... foo[x/y] ...
--   
--   In-lining lambdas like this is always legal, because inlining a
--   function does not change the cost-centre stack when the function is
--   called.
CostCentreScope :: TickishScoping

-- | Returns the intended scoping rule for a Tickish
tickishScoped :: GenTickish pass -> TickishScoping

-- | Returns whether the tick scoping rule is at least as permissive as the
--   given scoping rule.
tickishScopesLike :: GenTickish pass -> TickishScoping -> Bool

-- | Returns <tt>True</tt> for ticks that can be floated upwards easily
--   even where it might change execution counts, such as:
--   
--   Just (tick<a>...</a> foo) ==&gt; tick<a>...</a> (Just foo)
--   
--   This is a combination of <tt>tickishSoftScope</tt> and
--   <tt>tickishCounts</tt>. Note that in principle splittable ticks can
--   become floatable using <tt>mkNoTick</tt> -- even though there's
--   currently no tickish for which that is the case.
tickishFloatable :: GenTickish pass -> Bool

-- | Returns <tt>True</tt> for a tick that is both counting <i>and</i>
--   scoping and can be split into its (tick, scope) parts using
--   <a>mkNoScope</a> and <tt>mkNoTick</tt> respectively.
tickishCanSplit :: GenTickish pass -> Bool
mkNoCount :: GenTickish pass -> GenTickish pass
mkNoScope :: GenTickish pass -> GenTickish pass

-- | Return <tt>True</tt> if this source annotation compiles to some
--   backend code. Without this flag, the tickish is seen as a simple
--   annotation that does not have any associated evaluation code.
--   
--   What this means that we are allowed to disregard the tick if doing so
--   means that we can skip generating any code in the first place. A
--   typical example is top-level bindings:
--   
--   foo = tick<a>...</a> y -&gt; ... ==&gt; foo = y -&gt; tick<a>...</a>
--   ...
--   
--   Here there is just no operational difference between the first and the
--   second version. Therefore code generation should simply translate the
--   code as if it found the latter.
tickishIsCode :: GenTickish pass -> Bool

-- | Governs the kind of expression that the tick gets placed on when
--   annotating for example using <tt>mkTick</tt>. If we find that we want
--   to put a tickish on an expression ruled out here, we try to float it
--   inwards until we find a suitable expression.
data TickishPlacement

-- | Place ticks exactly on run-time expressions. We can still move the
--   tick through pure compile-time constructs such as other ticks, casts
--   or type lambdas. This is the most restrictive placement rule for
--   ticks, as all tickishs have in common that they want to track runtime
--   processes. The only legal placement rule for counting ticks.
PlaceRuntime :: TickishPlacement

-- | As <tt>PlaceRuntime</tt>, but we float the tick through all lambdas.
--   This makes sense where there is little difference between annotating
--   the lambda and annotating the lambda's code.
PlaceNonLam :: TickishPlacement

-- | In addition to floating through lambdas, cost-centre style tickishs
--   can also be moved from constructors, non-function variables and
--   literals. For example:
--   
--   let x = scc<a>...</a> C (scc<a>...</a> y) (scc<a>...</a> 3) in ...
--   
--   Neither the constructor application, the variable or the literal are
--   likely to have any cost worth mentioning. And even if y names a thunk,
--   the call would not care about the evaluation context. Therefore
--   removing all annotations in the above example is safe.
PlaceCostCentre :: TickishPlacement

-- | Placement behaviour we want for the ticks
tickishPlace :: GenTickish pass -> TickishPlacement

-- | Returns whether one tick "contains" the other one, therefore making
--   the second tick redundant.
tickishContains :: Eq (GenTickish pass) => GenTickish pass -> GenTickish pass -> Bool
instance GHC.Classes.Eq GHC.Types.Tickish.TickishScoping
instance GHC.Classes.Eq GHC.Types.Tickish.TickishPlacement
instance GHC.Classes.Eq (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCore)
instance GHC.Classes.Ord (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCore)
instance Data.Data.Data (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCore)
instance Data.Data.Data (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassStg)
instance GHC.Classes.Eq (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCmm)
instance GHC.Classes.Ord (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCmm)
instance Data.Data.Data (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCmm)

module GHC.Types.CostCentre

-- | A Cost Centre is a single <tt>{-# SCC #-}</tt> annotation.
data CostCentre
NormalCC :: CCFlavour -> CcName -> Module -> SrcSpan -> CostCentre

-- | Two cost centres may have the same name and module but different
--   SrcSpans, so we need a way to distinguish them easily and give them
--   different object-code labels. So every CostCentre has an associated
--   flavour that indicates how it was generated, and flavours that allow
--   multiple instances of the same name and module have a deterministic
--   0-based index.
[cc_flavour] :: CostCentre -> CCFlavour

-- | Name of the cost centre itself
[cc_name] :: CostCentre -> CcName

-- | Name of module defining this CC.
[cc_mod] :: CostCentre -> Module
[cc_loc] :: CostCentre -> SrcSpan
AllCafsCC :: Module -> SrcSpan -> CostCentre

-- | Name of module defining this CC.
[cc_mod] :: CostCentre -> Module
[cc_loc] :: CostCentre -> SrcSpan
type CcName = FastString

-- | The flavour of a cost centre.
--   
--   Index fields represent 0-based indices giving source-code ordering of
--   centres with the same module, name, and flavour.
data CCFlavour

-- | Auto-generated top-level thunk
CafCC :: CCFlavour

-- | Explicitly annotated expression
ExprCC :: !CostCentreIndex -> CCFlavour

-- | Explicitly annotated declaration
DeclCC :: !CostCentreIndex -> CCFlavour

-- | Generated by HPC for coverage
HpcCC :: !CostCentreIndex -> CCFlavour

-- | A Cost Centre Stack is something that can be attached to a closure.
--   This is either:
--   
--   <ul>
--   <li>the current cost centre stack (CCCS)</li>
--   <li>a pre-defined cost centre stack (there are several pre-defined
--   CCSs, see below).</li>
--   </ul>
data CostCentreStack
type CollectedCCs = ([CostCentre], [CostCentreStack])
emptyCollectedCCs :: CollectedCCs
collectCC :: CostCentre -> CostCentreStack -> CollectedCCs -> CollectedCCs
currentCCS :: CostCentreStack
dontCareCCS :: CostCentreStack
isCurrentCCS :: CostCentreStack -> Bool
maybeSingletonCCS :: CostCentreStack -> Maybe CostCentre
mkUserCC :: FastString -> Module -> SrcSpan -> CCFlavour -> CostCentre
mkAutoCC :: Id -> Module -> CostCentre
mkAllCafsCC :: Module -> SrcSpan -> CostCentre
mkSingletonCCS :: CostCentre -> CostCentreStack
isCafCCS :: CostCentreStack -> Bool
isCafCC :: CostCentre -> Bool

-- | Is this a cost-centre which records scc counts
isSccCountCC :: CostCentre -> Bool

-- | Is this a cost-centre which can be sccd ?
sccAbleCC :: CostCentre -> Bool
ccFromThisModule :: CostCentre -> Module -> Bool

-- | Print a flavour in Core
pprCostCentreCore :: CostCentre -> SDoc
costCentreUserName :: CostCentre -> String
costCentreUserNameFS :: CostCentre -> FastString
costCentreSrcSpan :: CostCentre -> SrcSpan
cmpCostCentre :: CostCentre -> CostCentre -> Ordering
instance Data.Data.Data GHC.Types.CostCentre.CCFlavour
instance GHC.Classes.Ord GHC.Types.CostCentre.CCFlavour
instance GHC.Classes.Eq GHC.Types.CostCentre.CCFlavour
instance Data.Data.Data GHC.Types.CostCentre.CostCentre
instance GHC.Classes.Ord GHC.Types.CostCentre.CostCentreStack
instance GHC.Classes.Eq GHC.Types.CostCentre.CostCentreStack
instance GHC.Utils.Outputable.Outputable GHC.Types.CostCentre.CostCentreStack
instance GHC.Classes.Eq GHC.Types.CostCentre.CostCentre
instance GHC.Classes.Ord GHC.Types.CostCentre.CostCentre
instance GHC.Utils.Outputable.Outputable GHC.Types.CostCentre.CostCentre
instance GHC.Utils.Binary.Binary GHC.Types.CostCentre.CostCentre
instance GHC.Utils.Binary.Binary GHC.Types.CostCentre.CCFlavour

module GHC.Types.CostCentre.State

-- | Per-module state for tracking cost centre indices.
--   
--   See documentation of <a>cc_flavour</a> for more details.
data CostCentreState

-- | Initialize cost centre state.
newCostCentreState :: CostCentreState

-- | An index into a given cost centre module,name,flavour set
data CostCentreIndex
unCostCentreIndex :: CostCentreIndex -> Int

-- | Get a new index for a given cost centre name.
getCCIndex :: FastString -> CostCentreState -> (CostCentreIndex, CostCentreState)
instance GHC.Utils.Binary.Binary GHC.Types.CostCentre.State.CostCentreIndex
instance Data.Data.Data GHC.Types.CostCentre.State.CostCentreIndex
instance GHC.Classes.Ord GHC.Types.CostCentre.State.CostCentreIndex
instance GHC.Classes.Eq GHC.Types.CostCentre.State.CostCentreIndex


-- | Core literals
module GHC.Types.Literal

-- | So-called <a>Literal</a>s are one of:
--   
--   <ul>
--   <li>An unboxed numeric literal or floating-point literal which is
--   presumed to be surrounded by appropriate constructors (<tt>Int#</tt>,
--   etc.), so that the overall thing makes sense.</li>
--   </ul>
--   
--   We maintain the invariant that the <a>Integer</a> in the
--   <a>LitNumber</a> constructor is actually in the (possibly
--   target-dependent) range. The mkLit{Int,Word}*Wrap smart constructors
--   ensure this by applying the target machine's wrapping semantics. Use
--   these in situations where you know the wrapping semantics are correct.
--   
--   <ul>
--   <li>The literal derived from the label mentioned in a "foreign label"
--   declaration (<a>LitLabel</a>)</li>
--   <li>A <a>LitRubbish</a> to be used in place of values of
--   <a>PrimRep</a> (i.e. <a>MutVar#</a>) when the value is never
--   used.</li>
--   <li>A character</li>
--   <li>A string</li>
--   <li>The NULL pointer</li>
--   </ul>
data Literal

-- | <tt>Char#</tt> - at least 31 bits. Create with <a>mkLitChar</a>
LitChar :: Char -> Literal

-- | Any numeric literal that can be internally represented with an
--   Integer.
LitNumber :: !LitNumType -> !Integer -> Literal

-- | A string-literal: stored and emitted UTF-8 encoded, we'll arrange to
--   decode it at runtime. Also emitted with a <tt>'\0'</tt> terminator.
--   Create with <a>mkLitString</a>
LitString :: !ByteString -> Literal

-- | The <tt>NULL</tt> pointer, the only pointer value that can be
--   represented as a Literal. Create with <a>nullAddrLit</a>
LitNullAddr :: Literal

-- | A nonsense value; always boxed, but True <a>=</a> lifted, False
--   <a>=</a> unlifted Used when a binding is absent. See Note [Rubbish
--   literals]
LitRubbish :: Bool -> Literal

-- | <tt>Float#</tt>. Create with <a>mkLitFloat</a>
LitFloat :: Rational -> Literal

-- | <tt>Double#</tt>. Create with <a>mkLitDouble</a>
LitDouble :: Rational -> Literal

-- | A label literal. Parameters:
--   
--   1) The name of the symbol mentioned in the declaration
--   
--   2) The size (in bytes) of the arguments the label expects. Only
--   applicable with <tt>stdcall</tt> labels. <tt>Just x</tt> =&gt;
--   <tt>&lt;x&gt;</tt> will be appended to label name when emitting
--   assembly.
--   
--   3) Flag indicating whether the symbol references a function or a data
LitLabel :: FastString -> Maybe Int -> FunctionOrData -> Literal

-- | Numeric literal type
data LitNumType

-- | <tt>Integer</tt> (see Note [BigNum literals])
LitNumInteger :: LitNumType

-- | <tt>Natural</tt> (see Note [BigNum literals])
LitNumNatural :: LitNumType

-- | <tt>Int#</tt> - according to target machine
LitNumInt :: LitNumType

-- | <tt>Int8#</tt> - exactly 8 bits
LitNumInt8 :: LitNumType

-- | <tt>Int16#</tt> - exactly 16 bits
LitNumInt16 :: LitNumType

-- | <tt>Int32#</tt> - exactly 32 bits
LitNumInt32 :: LitNumType

-- | <tt>Int64#</tt> - exactly 64 bits
LitNumInt64 :: LitNumType

-- | <tt>Word#</tt> - according to target machine
LitNumWord :: LitNumType

-- | <tt>Word8#</tt> - exactly 8 bits
LitNumWord8 :: LitNumType

-- | <tt>Word16#</tt> - exactly 16 bits
LitNumWord16 :: LitNumType

-- | <tt>Word32#</tt> - exactly 32 bits
LitNumWord32 :: LitNumType

-- | <tt>Word64#</tt> - exactly 64 bits
LitNumWord64 :: LitNumType

-- | Creates a <a>Literal</a> of type <tt>Int#</tt>
mkLitInt :: Platform -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int#</tt>. If the argument is out
--   of the (target-dependent) range, it is wrapped. See Note [Word<i>Int
--   underflow</i>overflow]
mkLitIntWrap :: Platform -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int#</tt>, as well as a
--   <a>Bool</a>ean flag indicating overflow. That is, if the argument is
--   out of the (target-dependent) range the argument is wrapped and the
--   overflow flag will be set. See Note [Word<i>Int underflow</i>overflow]
mkLitIntWrapC :: Platform -> Integer -> (Literal, Bool)

-- | Creates a <a>Literal</a> of type <tt>Int#</tt> without checking its
--   range.
mkLitIntUnchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word#</tt>
mkLitWord :: Platform -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word#</tt>. If the argument is
--   out of the (target-dependent) range, it is wrapped. See Note
--   [Word<i>Int underflow</i>overflow]
mkLitWordWrap :: Platform -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word#</tt>, as well as a
--   <a>Bool</a>ean flag indicating carry. That is, if the argument is out
--   of the (target-dependent) range the argument is wrapped and the carry
--   flag will be set. See Note [Word<i>Int underflow</i>overflow]
mkLitWordWrapC :: Platform -> Integer -> (Literal, Bool)

-- | Creates a <a>Literal</a> of type <tt>Int8#</tt>
mkLitInt8 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int8#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitInt8Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word8#</tt>
mkLitWord8 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word8#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitWord8Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int16#</tt>
mkLitInt16 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int16#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitInt16Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word16#</tt>
mkLitWord16 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word16#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitWord16Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int32#</tt>
mkLitInt32 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int32#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitInt32Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word32#</tt>
mkLitWord32 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word32#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitWord32Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int64#</tt>
mkLitInt64 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int64#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitInt64Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word64#</tt>
mkLitWord64 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word64#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitWord64Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Float#</tt>
mkLitFloat :: Rational -> Literal

-- | Creates a <a>Literal</a> of type <tt>Double#</tt>
mkLitDouble :: Rational -> Literal

-- | Creates a <a>Literal</a> of type <tt>Char#</tt>
mkLitChar :: Char -> Literal

-- | Creates a <a>Literal</a> of type <tt>Addr#</tt>, which is appropriate
--   for passing to e.g. some of the "error" functions in GHC.Err such as
--   <tt>GHC.Err.runtimeError</tt>
mkLitString :: String -> Literal
mkLitInteger :: Integer -> Literal
mkLitNatural :: Integer -> Literal

-- | Create a numeric <a>Literal</a> of the given type
mkLitNumber :: Platform -> LitNumType -> Integer -> Literal

-- | Make a literal number using wrapping semantics if the value is out of
--   bound.
mkLitNumberWrap :: Platform -> LitNumType -> Integer -> Literal

-- | Find the Haskell <a>Type</a> the literal occupies
literalType :: Literal -> Type
absentLiteralOf :: TyCon -> Maybe Literal
pprLiteral :: (SDoc -> SDoc) -> Literal -> SDoc

-- | Indicate if a numeric literal type supports negative numbers
litNumIsSigned :: LitNumType -> Bool

-- | Check that a given number is in the range of a numeric literal
litNumCheckRange :: Platform -> LitNumType -> Integer -> Bool

-- | Wrap a literal number according to its type using wrapping semantics.
litNumWrap :: Platform -> Literal -> Literal

-- | Coerce a literal number into another using wrapping semantics.
litNumCoerce :: LitNumType -> Platform -> Literal -> Literal

-- | Narrow a literal number by converting it into another number type and
--   then converting it back to its original type.
litNumNarrow :: LitNumType -> Platform -> Literal -> Literal

-- | Number of bits
litNumBitSize :: Platform -> LitNumType -> Maybe Word
isMinBound :: Platform -> Literal -> Bool
isMaxBound :: Platform -> Literal -> Bool

-- | True if code space does not go bad if we duplicate this literal
litIsDupable :: Platform -> Literal -> Bool

-- | True if there is absolutely no penalty to duplicating the literal.
--   False principally of strings.
--   
--   "Why?", you say? I'm glad you asked. Well, for one duplicating strings
--   would blow up code sizes. Not only this, it's also unsafe.
--   
--   Consider a program that wants to traverse a string. One way it might
--   do this is to first compute the Addr# pointing to the end of the
--   string, and then, starting from the beginning, bump a pointer using
--   eqAddr# to determine the end. For instance,
--   
--   <pre>
--   -- Given pointers to the start and end of a string, count how many zeros
--   -- the string contains.
--   countZeros :: Addr# -&gt; Addr# -&gt; -&gt; Int
--   countZeros start end = go start 0
--     where
--       go off n
--         | off <tt>addrEq#</tt> end = n
--         | otherwise         = go (off <a>plusAddr#</a> 1) n'
--         where n' | isTrue# (indexInt8OffAddr# off 0# ==# 0#) = n + 1
--                  | otherwise                                 = n
--   </pre>
--   
--   Consider what happens if we considered strings to be trivial (and
--   therefore duplicable) and emitted a call like <tt>countZeros "hello"#
--   ("hello"# <tt>plusAddr</tt># 5)</tt>. The beginning and end pointers
--   do not belong to the same string, meaning that an iteration like the
--   above would blow up terribly. This is what happened in #12757.
--   
--   Ultimately the solution here is to make primitive strings a bit more
--   structured, ensuring that the compiler can't inline in ways that will
--   break user code. One approach to this is described in #8472.
litIsTrivial :: Literal -> Bool
litIsLifted :: Literal -> Bool
inCharRange :: Char -> Bool

-- | Tests whether the literal represents a zero of whatever type it is
isZeroLit :: Literal -> Bool

-- | Tests whether the literal represents a one of whatever type it is
isOneLit :: Literal -> Bool
litFitsInChar :: Literal -> Bool

-- | Returns the <a>Integer</a> contained in the <a>Literal</a>, for when
--   that makes sense, i.e. for <a>Char</a>, <a>Int</a>, <a>Word</a>,
--   <tt>LitInteger</tt> and <tt>LitNatural</tt>.
litValue :: Literal -> Integer

-- | Apply a function to the <a>Integer</a> contained in the
--   <a>Literal</a>, for when that makes sense, e.g. for <a>Char</a> and
--   numbers. For fixed-size integral literals, the result will be wrapped
--   in accordance with the semantics of the target type. See Note
--   [Word<i>Int underflow</i>overflow]
mapLitValue :: Platform -> (Integer -> Integer) -> Literal -> Literal

-- | Returns the <a>Integer</a> contained in the <a>Literal</a>, for when
--   that makes sense, i.e. for <a>Char</a> and numbers.
isLitValue_maybe :: Literal -> Maybe Integer
narrowInt8Lit :: Literal -> Literal
narrowInt16Lit :: Literal -> Literal
narrowInt32Lit :: Literal -> Literal
narrowInt64Lit :: Literal -> Literal
narrowWord8Lit :: Literal -> Literal
narrowWord16Lit :: Literal -> Literal
narrowWord32Lit :: Literal -> Literal
narrowWord64Lit :: Literal -> Literal

-- | Extend or narrow a fixed-width literal (e.g. <a>Int16#</a>) to a
--   target word-sized literal (<a>Int#</a> or <a>Word#</a>). Narrowing can
--   only happen on 32-bit architectures when we convert a 64-bit literal
--   into a 32-bit one.
convertToIntLit :: Platform -> Literal -> Literal

-- | Extend or narrow a fixed-width literal (e.g. <a>Int16#</a>) to a
--   target word-sized literal (<a>Int#</a> or <a>Word#</a>). Narrowing can
--   only happen on 32-bit architectures when we convert a 64-bit literal
--   into a 32-bit one.
convertToWordLit :: Platform -> Literal -> Literal
charToIntLit :: Literal -> Literal
intToCharLit :: Literal -> Literal
floatToIntLit :: Literal -> Literal
intToFloatLit :: Literal -> Literal
doubleToIntLit :: Literal -> Literal
intToDoubleLit :: Literal -> Literal
nullAddrLit :: Literal
floatToDoubleLit :: Literal -> Literal
doubleToFloatLit :: Literal -> Literal

-- | A rubbish literal; see Note [Rubbish literals]
rubbishLit :: Bool -> Literal
isRubbishLit :: Literal -> Bool
instance GHC.Classes.Ord GHC.Types.Literal.LitNumType
instance GHC.Classes.Eq GHC.Types.Literal.LitNumType
instance GHC.Enum.Enum GHC.Types.Literal.LitNumType
instance Data.Data.Data GHC.Types.Literal.LitNumType
instance Data.Data.Data GHC.Types.Literal.Literal
instance GHC.Utils.Binary.Binary GHC.Types.Literal.Literal
instance GHC.Utils.Outputable.Outputable GHC.Types.Literal.Literal
instance GHC.Classes.Eq GHC.Types.Literal.Literal
instance GHC.Classes.Ord GHC.Types.Literal.Literal
instance GHC.Utils.Binary.Binary GHC.Types.Literal.LitNumType

module GHC.Core.TyCon

-- | TyCons represent type constructors. Type constructors are introduced
--   by things such as:
--   
--   1) Data declarations: <tt>data Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor of kind <tt>*</tt>
--   
--   2) Type synonyms: <tt>type Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor
--   
--   3) Newtypes: <tt>newtype Foo a = MkFoo ...</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>* -&gt; *</tt>
--   
--   4) Class declarations: <tt>class Foo where</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>*</tt>
--   
--   This data type also encodes a number of primitive, built in type
--   constructors such as those for function and tuple types.
data TyCon

-- | Represents right-hand-sides of <a>TyCon</a>s for algebraic types
data AlgTyConRhs

-- | Says that we know nothing about this data type, except that it's
--   represented by a pointer. Used when we export a data type abstractly
--   into an .hi file.
AbstractTyCon :: AlgTyConRhs

-- | Information about those <a>TyCon</a>s derived from a <tt>data</tt>
--   declaration. This includes data types with no constructors at all.
DataTyCon :: [DataCon] -> Int -> Bool -> AlgTyConRhs

-- | The data type constructors; can be empty if the user declares the type
--   to have no constructors
--   
--   INVARIANT: Kept in order of increasing <a>DataCon</a> tag (see the tag
--   assignment in mkTyConTagMap)
[data_cons] :: AlgTyConRhs -> [DataCon]

-- | Cached value: length data_cons
[data_cons_size] :: AlgTyConRhs -> Int

-- | Cached value: is this an enumeration type? See Note [Enumeration
--   types]
[is_enum] :: AlgTyConRhs -> Bool
TupleTyCon :: DataCon -> TupleSort -> AlgTyConRhs

-- | The unique constructor for the <tt>newtype</tt>. It has no
--   existentials
[data_con] :: AlgTyConRhs -> DataCon

-- | Is this a boxed, unboxed or constraint tuple?
[tup_sort] :: AlgTyConRhs -> TupleSort

-- | An unboxed sum type.
SumTyCon :: [DataCon] -> Int -> AlgTyConRhs

-- | The data type constructors; can be empty if the user declares the type
--   to have no constructors
--   
--   INVARIANT: Kept in order of increasing <a>DataCon</a> tag (see the tag
--   assignment in mkTyConTagMap)
[data_cons] :: AlgTyConRhs -> [DataCon]

-- | Cached value: length data_cons
[data_cons_size] :: AlgTyConRhs -> Int

-- | Information about those <a>TyCon</a>s derived from a <tt>newtype</tt>
--   declaration
NewTyCon :: DataCon -> Type -> ([TyVar], Type) -> CoAxiom Unbranched -> Bool -> AlgTyConRhs

-- | The unique constructor for the <tt>newtype</tt>. It has no
--   existentials
[data_con] :: AlgTyConRhs -> DataCon

-- | Cached value: the argument type of the constructor, which is just the
--   representation type of the <a>TyCon</a> (remember that
--   <tt>newtype</tt>s do not exist at runtime so need a different
--   representation type).
--   
--   The free <a>TyVar</a>s of this type are the <a>tyConTyVars</a> from
--   the corresponding <a>TyCon</a>
[nt_rhs] :: AlgTyConRhs -> Type

-- | Same as the <a>nt_rhs</a>, but this time eta-reduced. Hence the list
--   of <a>TyVar</a>s in this field may be shorter than the declared arity
--   of the <a>TyCon</a>.
[nt_etad_rhs] :: AlgTyConRhs -> ([TyVar], Type)
[nt_co] :: AlgTyConRhs -> CoAxiom Unbranched
[nt_lev_poly] :: AlgTyConRhs -> Bool

-- | Both type classes as well as family instances imply implicit type
--   constructors. These implicit type constructors refer to their parent
--   structure (ie, the class or family from which they derive) using a
--   type of the following form.
--   
--   Extract those <a>DataCon</a>s that we are able to learn about. Note
--   that visibility in this sense does not correspond to visibility in the
--   context of any particular user program!
visibleDataCons :: AlgTyConRhs -> [DataCon]
data AlgTyConFlav

-- | An ordinary type constructor has no parent.
VanillaAlgTyCon :: TyConRepName -> AlgTyConFlav

-- | An unboxed type constructor. The TyConRepName is a Maybe since we
--   currently don't allow unboxed sums to be Typeable since there are too
--   many of them. See #13276.
UnboxedAlgTyCon :: Maybe TyConRepName -> AlgTyConFlav

-- | Type constructors representing a class dictionary. See Note [ATyCon
--   for classes] in <a>GHC.Core.TyCo.Rep</a>
ClassTyCon :: Class -> TyConRepName -> AlgTyConFlav

-- | Type constructors representing an *instance* of a *data* family.
--   Parameters:
--   
--   1) The type family in question
--   
--   2) Instance types; free variables are the <a>tyConTyVars</a> of the
--   current <a>TyCon</a> (not the family one). INVARIANT: the number of
--   types matches the arity of the family <a>TyCon</a>
--   
--   3) A <tt>CoTyCon</tt> identifying the representation type with the
--   type instance family
DataFamInstTyCon :: CoAxiom Unbranched -> TyCon -> [Type] -> AlgTyConFlav
isNoParent :: AlgTyConFlav -> Bool

-- | Information pertaining to the expansion of a type synonym
--   (<tt>type</tt>)
data FamTyConFlav

-- | Represents an open type family without a fixed right hand side.
--   Additional instances can appear at any time.
--   
--   These are introduced by either a top level declaration:
--   
--   <pre>
--   data family T a :: *
--   </pre>
--   
--   Or an associated data type declaration, within a class declaration:
--   
--   <pre>
--   class C a b where
--     data T b :: *
--   </pre>
DataFamilyTyCon :: TyConRepName -> FamTyConFlav

-- | An open type synonym family e.g. <tt>type family F x y :: * -&gt;
--   *</tt>
OpenSynFamilyTyCon :: FamTyConFlav

-- | A closed type synonym family e.g. <tt>type family F x where { F Int =
--   Bool }</tt>
ClosedSynFamilyTyCon :: Maybe (CoAxiom Branched) -> FamTyConFlav

-- | A closed type synonym family declared in an hs-boot file with type
--   family F a where ..
AbstractClosedSynFamilyTyCon :: FamTyConFlav

-- | Built-in type family used by the TypeNats solver
BuiltInSynFamTyCon :: BuiltInSynFamily -> FamTyConFlav
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
data Injectivity
NotInjective :: Injectivity
Injective :: [Bool] -> Injectivity

-- | Some promoted datacons signify extra info relevant to GHC. For
--   example, the <tt>IntRep</tt> constructor of <tt>RuntimeRep</tt>
--   corresponds to the <a>IntRep</a> constructor of <a>PrimRep</a>. This
--   data structure allows us to store this information right in the
--   <a>TyCon</a>. The other approach would be to look up things like
--   <tt>RuntimeRep</tt>'s <tt>PrimRep</tt> by known-key every time. See
--   also Note [Getting from RuntimeRep to PrimRep] in
--   <a>GHC.Types.RepType</a>
data RuntimeRepInfo

-- | an ordinary promoted data con
NoRRI :: RuntimeRepInfo

-- | A constructor of <tt>RuntimeRep</tt>. The argument to the function
--   should be the list of arguments to the promoted datacon.
RuntimeRep :: ([Type] -> [PrimRep]) -> RuntimeRepInfo

-- | A constructor of <tt>VecCount</tt>
VecCount :: Int -> RuntimeRepInfo

-- | A constructor of <tt>VecElem</tt>
VecElem :: PrimElemRep -> RuntimeRepInfo

-- | A constructor of <tt>Levity</tt>
LiftedInfo :: RuntimeRepInfo

-- | A constructor of <tt>Levity</tt>
UnliftedInfo :: RuntimeRepInfo

-- | Paints a picture of what a <a>TyCon</a> represents, in broad strokes.
--   This is used towards more informative error messages.
data TyConFlavour
ClassFlavour :: TyConFlavour
TupleFlavour :: Boxity -> TyConFlavour
SumFlavour :: TyConFlavour
DataTypeFlavour :: TyConFlavour
NewtypeFlavour :: TyConFlavour
AbstractTypeFlavour :: TyConFlavour
DataFamilyFlavour :: Maybe TyCon -> TyConFlavour
OpenTypeFamilyFlavour :: Maybe TyCon -> TyConFlavour
ClosedTypeFamilyFlavour :: TyConFlavour
TypeSynonymFlavour :: TyConFlavour

-- | e.g., the <tt>(-&gt;)</tt> <a>TyCon</a>.
BuiltInTypeFlavour :: TyConFlavour
PromotedDataConFlavour :: TyConFlavour
type TyConBinder = VarBndr TyVar TyConBndrVis
data TyConBndrVis
NamedTCB :: ArgFlag -> TyConBndrVis
AnonTCB :: AnonArgFlag -> TyConBndrVis
type TyConTyCoBinder = VarBndr TyCoVar TyConBndrVis
mkNamedTyConBinder :: ArgFlag -> TyVar -> TyConBinder
mkNamedTyConBinders :: ArgFlag -> [TyVar] -> [TyConBinder]

-- | Make a Required TyConBinder. It chooses between NamedTCB and AnonTCB
--   based on whether the tv is mentioned in the dependent set
mkRequiredTyConBinder :: TyCoVarSet -> TyVar -> TyConBinder
mkAnonTyConBinder :: AnonArgFlag -> TyVar -> TyConBinder
mkAnonTyConBinders :: AnonArgFlag -> [TyVar] -> [TyConBinder]
tyConBinderArgFlag :: TyConBinder -> ArgFlag
tyConBndrVisArgFlag :: TyConBndrVis -> ArgFlag
isNamedTyConBinder :: TyConBinder -> Bool
isVisibleTyConBinder :: VarBndr tv TyConBndrVis -> Bool
isInvisibleTyConBinder :: VarBndr tv TyConBndrVis -> Bool

-- | The labels for the fields of this particular <a>TyCon</a>
tyConFieldLabels :: TyCon -> [FieldLabel]

-- | Look up a field label belonging to this <a>TyCon</a>
lookupTyConFieldLabel :: FieldLabelString -> TyCon -> Maybe FieldLabel

-- | This is the making of an algebraic <a>TyCon</a>.
mkAlgTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> Maybe CType -> [PredType] -> AlgTyConRhs -> AlgTyConFlav -> Bool -> TyCon

-- | Simpler specialization of <a>mkAlgTyCon</a> for classes
mkClassTyCon :: Name -> [TyConBinder] -> [Role] -> AlgTyConRhs -> Class -> Name -> TyCon

-- | Given the name of the function type constructor and it's kind, create
--   the corresponding <a>TyCon</a>. It is recommended to use
--   <a>funTyCon</a> if you want this functionality
mkFunTyCon :: Name -> [TyConBinder] -> Name -> TyCon

-- | Create an unlifted primitive <a>TyCon</a>, such as <tt>Int#</tt>.
mkPrimTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> TyCon

-- | Kind constructors
mkKindTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> Name -> TyCon

-- | Create a lifted primitive <a>TyCon</a> such as <tt>RealWorld</tt>
mkLiftedPrimTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> TyCon
mkTupleTyCon :: Name -> [TyConBinder] -> Kind -> Arity -> DataCon -> TupleSort -> AlgTyConFlav -> TyCon
mkSumTyCon :: Name -> [TyConBinder] -> Kind -> Arity -> [TyVar] -> [DataCon] -> AlgTyConFlav -> TyCon
mkDataTyConRhs :: [DataCon] -> AlgTyConRhs

-- | Create a type synonym <a>TyCon</a>
mkSynonymTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> Type -> Bool -> Bool -> Bool -> TyCon

-- | Create a type family <a>TyCon</a>
mkFamilyTyCon :: Name -> [TyConBinder] -> Kind -> Maybe Name -> FamTyConFlav -> Maybe Class -> Injectivity -> TyCon

-- | Create a promoted data constructor <a>TyCon</a> Somewhat dodgily, we
--   give it the same Name as the data constructor itself; when we
--   pretty-print the TyCon we add a quote; see the Outputable TyCon
--   instance
mkPromotedDataCon :: DataCon -> Name -> TyConRepName -> [TyConTyCoBinder] -> Kind -> [Role] -> RuntimeRepInfo -> TyCon

-- | Makes a tycon suitable for use during type-checking. It stores a
--   variety of details about the definition of the TyCon, but no
--   right-hand side. It lives only during the type-checking of a
--   mutually-recursive group of tycons; it is then zonked to a proper
--   TyCon in zonkTcTyCon. See also Note [Kind checking recursive type and
--   class declarations] in <a>GHC.Tc.TyCl</a>.
mkTcTyCon :: Name -> [TyConBinder] -> Kind -> [(Name, TcTyVar)] -> Bool -> TyConFlavour -> TyCon

-- | No scoped type variables (to be used with mkTcTyCon).
noTcTyConScopedTyVars :: [(Name, TcTyVar)]

-- | Returns <tt>True</tt> if the supplied <a>TyCon</a> resulted from
--   either a <tt>data</tt> or <tt>newtype</tt> declaration
isAlgTyCon :: TyCon -> Bool

-- | Returns <tt>True</tt> for vanilla AlgTyCons -- that is, those created
--   with a <tt>data</tt> or <tt>newtype</tt> declaration.
isVanillaAlgTyCon :: TyCon -> Bool

-- | Returns <tt>True</tt> for the <a>TyCon</a> of the <tt>Constraint</tt>
--   kind.
isConstraintKindCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a class instance?
isClassTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a data family instance?
isFamInstTyCon :: TyCon -> Bool
isFunTyCon :: TyCon -> Bool

-- | Does this <a>TyCon</a> represent something that cannot be defined in
--   Haskell?
isPrimTyCon :: TyCon -> Bool

-- | Does this <a>TyCon</a> represent a tuple?
--   
--   NB: when compiling <tt>Data.Tuple</tt>, the tycons won't reply
--   <tt>True</tt> to <a>isTupleTyCon</a>, because they are built as
--   <tt>AlgTyCons</tt>. However they get spat into the interface file as
--   tuple tycons, so I don't think it matters.
isTupleTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for an unboxed tuple?
isUnboxedTupleTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for a boxed tuple?
isBoxedTupleTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for an unboxed sum?
isUnboxedSumTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for a <i>promoted</i> tuple?
isPromotedTupleTyCon :: TyCon -> Bool
isLiftedAlgTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a> representing a regular H98 type synonym
--   (<tt>type</tt>)?
isTypeSynonymTyCon :: TyCon -> Bool

-- | True iff we can decompose (T a b c) into ((T a b) c) I.e. is it
--   injective and generative w.r.t nominal equality? That is, if (T a b)
--   ~N d e f, is it always the case that (T ~N d), (a ~N e) and (b ~N f)?
--   Specifically NOT true of synonyms (open and otherwise)
--   
--   It'd be unusual to call mustBeSaturated on a regular H98 type synonym,
--   because you should probably have expanded it first But regardless,
--   it's not decomposable
mustBeSaturated :: TyCon -> Bool

-- | Is this a PromotedDataCon?
isPromotedDataCon :: TyCon -> Bool

-- | Retrieves the promoted DataCon if this is a PromotedDataCon;
isPromotedDataCon_maybe :: TyCon -> Maybe DataCon

-- | Is this tycon really meant for use at the kind level? That is, should
--   it be permitted without -XDataKinds?
isKindTyCon :: TyCon -> Bool
isLiftedTypeKindTyConName :: Name -> Bool
isTauTyCon :: TyCon -> Bool

-- | Is this tycon neither a type family nor a synonym that expands to a
--   type family?
isFamFreeTyCon :: TyCon -> Bool

-- | Is this a forgetful type synonym? If this is a type synonym whose RHS
--   does not mention one (or more) of its bound variables, returns True.
--   Thus, False means that all bound variables appear on the RHS; True may
--   not mean anything, as the test to set this flag is conservative.
isForgetfulSynTyCon :: TyCon -> Bool

-- | Returns <tt>True</tt> for data types that are <i>definitely</i>
--   represented by heap-allocated constructors. These are scrutinised by
--   Core-level <tt>case</tt> expressions, and they get info tables
--   allocated for them.
--   
--   Generally, the function will be true for all <tt>data</tt> types and
--   false for <tt>newtype</tt>s, unboxed tuples, unboxed sums and type
--   family <a>TyCon</a>s. But it is not guaranteed to return <tt>True</tt>
--   in all cases that it could.
--   
--   NB: for a data type family, only the <i>instance</i> <a>TyCon</a>s get
--   an info table. The family declaration <a>TyCon</a> does not
isDataTyCon :: TyCon -> Bool

-- | Is this an algebraic <a>TyCon</a> which is just an enumeration of
--   values?
isEnumerationTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a <tt>newtype</tt>
isNewTyCon :: TyCon -> Bool

-- | Test if the <a>TyCon</a> is algebraic but abstract (invisible data
--   constructors)
isAbstractTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family?
isFamilyTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family
--   with instances?
isOpenFamilyTyCon :: TyCon -> Bool

-- | Is this a synonym <a>TyCon</a> that can have may have further
--   instances appear?
isTypeFamilyTyCon :: TyCon -> Bool

-- | Is this a synonym <a>TyCon</a> that can have may have further
--   instances appear?
isDataFamilyTyCon :: TyCon -> Bool

-- | Is this an open type family TyCon?
isOpenTypeFamilyTyCon :: TyCon -> Bool

-- | Is this a non-empty closed type family? Returns <a>Nothing</a> for
--   abstract or empty closed families.
isClosedSynFamilyTyConWithAxiom_maybe :: TyCon -> Maybe (CoAxiom Branched)

-- | <tt><a>tyConInjectivityInfo</a> tc</tt> returns <tt><a>Injective</a>
--   is</tt> if <tt>tc</tt> is an injective tycon (where <tt>is</tt> states
--   for which <a>tyConBinders</a> <tt>tc</tt> is injective), or
--   <a>NotInjective</a> otherwise.
tyConInjectivityInfo :: TyCon -> Injectivity
isBuiltInSynFamTyCon_maybe :: TyCon -> Maybe BuiltInSynFamily

-- | Is this <a>TyCon</a> unlifted (i.e. cannot contain bottom)? Note that
--   this can only be true for primitive and unboxed-tuple <a>TyCon</a>s
isUnliftedTyCon :: TyCon -> Bool

-- | Is this an algebraic <a>TyCon</a> declared with the GADT syntax?
isGadtSyntaxTyCon :: TyCon -> Bool

-- | <a>isInjectiveTyCon</a> is true of <a>TyCon</a>s for which this
--   property holds (where X is the role passed in): If (T a1 b1 c1) ~X (T
--   a2 b2 c2), then (a1 ~X1 a2), (b1 ~X2 b2), and (c1 ~X3 c2) (where X1,
--   X2, and X3, are the roles given by tyConRolesX tc X) See also Note
--   [Decomposing equality] in <a>GHC.Tc.Solver.Canonical</a>
isInjectiveTyCon :: TyCon -> Role -> Bool

-- | <a>isGenerativeTyCon</a> is true of <a>TyCon</a>s for which this
--   property holds (where X is the role passed in): If (T tys ~X t), then
--   (t's head ~X T). See also Note [Decomposing equality] in
--   <a>GHC.Tc.Solver.Canonical</a>
isGenerativeTyCon :: TyCon -> Role -> Bool

-- | Is this an <a>AlgTyConRhs</a> of a <a>TyCon</a> that is generative and
--   injective with respect to representational equality?
isGenInjAlgRhs :: AlgTyConRhs -> Bool

-- | Is this TyCon for an associated type?
isTyConAssoc :: TyCon -> Bool

-- | Get the enclosing class TyCon (if there is one) for the given TyCon.
tyConAssoc_maybe :: TyCon -> Maybe TyCon

-- | Get the enclosing class TyCon (if there is one) for the given
--   TyConFlavour
tyConFlavourAssoc_maybe :: TyConFlavour -> Maybe TyCon

-- | Identifies implicit tycons that, in particular, do not go into
--   interface files (because they are implicitly reconstructed when the
--   interface is read).
--   
--   Note that:
--   
--   <ul>
--   <li>Associated families are implicit, as they are re-constructed from
--   the class declaration in which they reside, and</li>
--   <li>Family instances are <i>not</i> implicit as they represent the
--   instance body (similar to a <tt>dfun</tt> does that for a class
--   instance).</li>
--   <li>Tuples are implicit iff they have a wired-in name (namely: boxed
--   and unboxed tuples are wired-in and implicit, but constraint tuples
--   are not)</li>
--   </ul>
isImplicitTyCon :: TyCon -> Bool

-- | Check if the tycon actually refers to a proper `data` or `newtype`
--   with user defined constructors rather than one from a class or other
--   construction.
isTyConWithSrcDataCons :: TyCon -> Bool

-- | Is this a TcTyCon? (That is, one only used during type-checking?)
isTcTyCon :: TyCon -> Bool
setTcTyConKind :: TyCon -> Kind -> TyCon

-- | Could this TyCon ever be levity-polymorphic when fully applied? True
--   is safe. False means we're sure. Does only a quick check based on the
--   TyCon's category. Precondition: The fully-applied TyCon has kind (TYPE
--   blah)
isTcLevPoly :: TyCon -> Bool

-- | Name of the constructor
tyConName :: TyCon -> Name

-- | Returns whether or not this <a>TyCon</a> is definite, or a hole that
--   may be filled in at some later point. See Note [Skolem abstract data]
tyConSkolem :: TyCon -> Bool

-- | Kind of this TyCon
tyConKind :: TyCon -> Kind

-- | A Unique of this TyCon. Invariant: identical to Unique of Name stored
--   in tyConName field.
tyConUnique :: TyCon -> Unique

-- | TyVar binders
tyConTyVars :: TyCon -> [TyVar]
tyConVisibleTyVars :: TyCon -> [TyVar]

-- | The C type that should be used for this type when using the FFI and
--   CAPI
tyConCType :: TyCon -> Maybe CType
tyConCType_maybe :: TyCon -> Maybe CType

-- | As <a>tyConDataCons_maybe</a>, but returns the empty list of
--   constructors if no constructors could be found
tyConDataCons :: TyCon -> [DataCon]

-- | Determine the <a>DataCon</a>s originating from the given <a>TyCon</a>,
--   if the <a>TyCon</a> is the sort that can have any constructors (note:
--   this does not include abstract algebraic types)
tyConDataCons_maybe :: TyCon -> Maybe [DataCon]

-- | If the given <a>TyCon</a> has a <i>single</i> data constructor, i.e.
--   it is a <tt>data</tt> type with one alternative, a tuple type or a
--   <tt>newtype</tt> then that constructor is returned. If the
--   <a>TyCon</a> has more than one constructor, or represents a primitive
--   or function type constructor then <tt>Nothing</tt> is returned.
tyConSingleDataCon_maybe :: TyCon -> Maybe DataCon

-- | Like <a>tyConSingleDataCon_maybe</a>, but panics if <a>Nothing</a>.
tyConSingleDataCon :: TyCon -> DataCon

-- | Returns <tt>Just dcs</tt> if the given <a>TyCon</a> is a <tt>data</tt>
--   type, a tuple type or a sum type with data constructors dcs. If the
--   <a>TyCon</a> has more than one constructor, or represents a primitive
--   or function type constructor then <tt>Nothing</tt> is returned.
--   
--   Like <a>tyConDataCons_maybe</a>, but returns <a>Nothing</a> for
--   newtypes.
tyConAlgDataCons_maybe :: TyCon -> Maybe [DataCon]

-- | Like <a>tyConSingleDataCon_maybe</a>, but returns <a>Nothing</a> for
--   newtypes.
tyConSingleAlgDataCon_maybe :: TyCon -> Maybe DataCon

-- | Determine the number of value constructors a <a>TyCon</a> has. Panics
--   if the <a>TyCon</a> is not algebraic or a tuple
tyConFamilySize :: TyCon -> Int

-- | Find the "stupid theta" of the <a>TyCon</a>. A "stupid theta" is the
--   context to the left of an algebraic type declaration, e.g. <tt>Eq
--   a</tt> in the declaration <tt>data Eq a =&gt; T a ...</tt>
tyConStupidTheta :: TyCon -> [PredType]

-- | Arity
tyConArity :: TyCon -> Arity

-- | A pre-allocated <tt>TyConApp tycon []</tt>
tyConNullaryTy :: TyCon -> Type

-- | Get the list of roles for the type parameters of a TyCon
tyConRoles :: TyCon -> [Role]
tyConFlavour :: TyCon -> TyConFlavour
tyConTuple_maybe :: TyCon -> Maybe TupleSort

-- | If this <a>TyCon</a> is that for a class instance, return the class it
--   is for. Otherwise returns <tt>Nothing</tt>
tyConClass_maybe :: TyCon -> Maybe Class

-- | Return the associated types of the <a>TyCon</a>, if any
tyConATs :: TyCon -> [TyCon]

-- | If this <a>TyCon</a> is that of a data family instance, return the
--   family in question and the instance types. Otherwise, return
--   <tt>Nothing</tt>
tyConFamInst_maybe :: TyCon -> Maybe (TyCon, [Type])
tyConFamInstSig_maybe :: TyCon -> Maybe (TyCon, [Type], CoAxiom Unbranched)

-- | If this <a>TyCon</a> is that of a data family instance, return a
--   <a>TyCon</a> which represents a coercion identifying the
--   representation type with the type instance family. Otherwise, return
--   <tt>Nothing</tt>
tyConFamilyCoercion_maybe :: TyCon -> Maybe (CoAxiom Unbranched)

-- | Extract type variable naming the result of injective type family
tyConFamilyResVar_maybe :: TyCon -> Maybe Name

-- | Extract the <a>TyVar</a>s bound by a vanilla type synonym and the
--   corresponding (unsubstituted) right hand side.
synTyConDefn_maybe :: TyCon -> Maybe ([TyVar], Type)

-- | Extract the information pertaining to the right hand side of a type
--   synonym (<tt>type</tt>) declaration.
synTyConRhs_maybe :: TyCon -> Maybe Type

-- | Extract the flavour of a type family (with all the extra information
--   that it carries)
famTyConFlav_maybe :: TyCon -> Maybe FamTyConFlav

-- | Name of result type variable, used for pretty-printing with
--   --show-iface and for reifying TyCon in Template Haskell
famTcResVar :: TyCon -> Maybe Name

-- | Extract an <a>AlgTyConRhs</a> with information about data constructors
--   from an algebraic or tuple <a>TyCon</a>. Panics for any other sort of
--   <a>TyCon</a>
algTyConRhs :: TyCon -> AlgTyConRhs

-- | Extract the bound type variables and type expansion of a type synonym
--   <a>TyCon</a>. Panics if the <a>TyCon</a> is not a synonym
newTyConRhs :: TyCon -> ([TyVar], Type)

-- | The number of type parameters that need to be passed to a newtype to
--   resolve it. May be less than in the definition if it can be
--   eta-contracted.
newTyConEtadArity :: TyCon -> Int

-- | Extract the bound type variables and type expansion of an
--   eta-contracted type synonym <a>TyCon</a>. Panics if the <a>TyCon</a>
--   is not a synonym
newTyConEtadRhs :: TyCon -> ([TyVar], Type)

-- | Take a <a>TyCon</a> apart into the <a>TyVar</a>s it scopes over, the
--   <a>Type</a> it expands into, and (possibly) a coercion from the
--   representation type to the <tt>newtype</tt>. Returns <tt>Nothing</tt>
--   if this is not possible.
unwrapNewTyCon_maybe :: TyCon -> Maybe ([TyVar], Type, CoAxiom Unbranched)
unwrapNewTyConEtad_maybe :: TyCon -> Maybe ([TyVar], Type, CoAxiom Unbranched)
newTyConDataCon_maybe :: TyCon -> Maybe DataCon

-- | Maps a label to information about the field
algTcFields :: TyCon -> FieldLabelEnv

-- | Extract any <a>RuntimeRepInfo</a> from this TyCon
tyConRuntimeRepInfo :: TyCon -> RuntimeRepInfo

-- | Full binders
tyConBinders :: TyCon -> [TyConBinder]

-- | Result kind
tyConResKind :: TyCon -> Kind
tyConInvisTVBinders :: [TyConBinder] -> [InvisTVBinder]

-- | Scoped tyvars over the tycon's body See Note [Scoped tyvars in a
--   TcTyCon]
tcTyConScopedTyVars :: TyCon -> [(Name, TyVar)]

-- | Is this TcTyCon already generalized?
tcTyConIsPoly :: TyCon -> Bool
mkTyConTagMap :: TyCon -> NameEnv ConTag
expandSynTyCon_maybe :: TyCon -> [tyco] -> Maybe ([(TyVar, tyco)], Type, [tyco])
newTyConCo :: TyCon -> CoAxiom Unbranched

-- | Extracts the <tt>newtype</tt> coercion from such a <a>TyCon</a>, which
--   can be used to construct something with the <tt>newtype</tt>s type
--   from its representation type (right hand side). If the supplied
--   <a>TyCon</a> is not a <tt>newtype</tt>, returns <tt>Nothing</tt>
newTyConCo_maybe :: TyCon -> Maybe (CoAxiom Unbranched)
pprPromotionQuote :: TyCon -> SDoc
mkTyConKind :: [TyConBinder] -> Kind -> Kind

-- | Is this flavour of <a>TyCon</a> an open type family or a data family?
tcFlavourIsOpen :: TyConFlavour -> Bool
type TyConRepName = Name
tyConRepName_maybe :: TyCon -> Maybe TyConRepName

-- | Make a <a>Name</a> for the <tt>Typeable</tt> representation of the
--   given wired-in type
mkPrelTyConRepName :: Name -> TyConRepName

-- | The name (and defining module) for the Typeable representation (TyCon)
--   of a type constructor.
--   
--   See Note [Grand plan for Typeable] in <a>GHC.Tc.Instance.Typeable</a>.
tyConRepModOcc :: Module -> OccName -> (Module, OccName)

-- | A <a>PrimRep</a> is an abstraction of a type. It contains information
--   that the code generator needs in order to pass arguments, return
--   results, and store values of this type. See also Note [RuntimeRep and
--   PrimRep] in <a>GHC.Types.RepType</a> and Note [VoidRep] in
--   <a>GHC.Types.RepType</a>.
data PrimRep
VoidRep :: PrimRep
LiftedRep :: PrimRep

-- | Unlifted pointer
UnliftedRep :: PrimRep

-- | Signed, 8-bit value
Int8Rep :: PrimRep

-- | Signed, 16-bit value
Int16Rep :: PrimRep

-- | Signed, 32-bit value
Int32Rep :: PrimRep

-- | Signed, 64 bit value
Int64Rep :: PrimRep

-- | Signed, word-sized value
IntRep :: PrimRep

-- | Unsigned, 8 bit value
Word8Rep :: PrimRep

-- | Unsigned, 16 bit value
Word16Rep :: PrimRep

-- | Unsigned, 32 bit value
Word32Rep :: PrimRep

-- | Unsigned, 64 bit value
Word64Rep :: PrimRep

-- | Unsigned, word-sized value
WordRep :: PrimRep

-- | A pointer, but <i>not</i> to a Haskell value (use '(Un)liftedRep')
AddrRep :: PrimRep
FloatRep :: PrimRep
DoubleRep :: PrimRep

-- | A vector
VecRep :: Int -> PrimElemRep -> PrimRep
data PrimElemRep
Int8ElemRep :: PrimElemRep
Int16ElemRep :: PrimElemRep
Int32ElemRep :: PrimElemRep
Int64ElemRep :: PrimElemRep
Word8ElemRep :: PrimElemRep
Word16ElemRep :: PrimElemRep
Word32ElemRep :: PrimElemRep
Word64ElemRep :: PrimElemRep
FloatElemRep :: PrimElemRep
DoubleElemRep :: PrimElemRep
isVoidRep :: PrimRep -> Bool
isGcPtrRep :: PrimRep -> Bool

-- | The size of a <a>PrimRep</a> in bytes.
--   
--   This applies also when used in a constructor, where we allow packing
--   the fields. For instance, in <tt>data Foo = Foo Float# Float#</tt> the
--   two fields will take only 8 bytes, which for 64-bit arch will be equal
--   to 1 word. See also mkVirtHeapOffsetsWithPadding for details of how
--   data fields are laid out.
primRepSizeB :: Platform -> PrimRep -> Int
primElemRepSizeB :: PrimElemRep -> Int

-- | Return if Rep stands for floating type, returns Nothing for vector
--   types.
primRepIsFloat :: PrimRep -> Maybe Bool
primRepsCompatible :: Platform -> [PrimRep] -> [PrimRep] -> Bool
primRepCompatible :: Platform -> PrimRep -> PrimRep -> Bool
instance GHC.Classes.Eq GHC.Core.TyCon.Injectivity
instance GHC.Show.Show GHC.Core.TyCon.PrimElemRep
instance GHC.Classes.Eq GHC.Core.TyCon.PrimElemRep
instance GHC.Show.Show GHC.Core.TyCon.PrimRep
instance GHC.Classes.Eq GHC.Core.TyCon.PrimRep
instance GHC.Classes.Eq GHC.Core.TyCon.TyConFlavour
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.AlgTyConFlav
instance GHC.Classes.Eq GHC.Core.TyCon.TyCon
instance GHC.Types.Unique.Uniquable GHC.Core.TyCon.TyCon
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.TyCon
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.TyConFlavour
instance GHC.Types.Name.NamedThing GHC.Core.TyCon.TyCon
instance Data.Data.Data GHC.Core.TyCon.TyCon
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.PrimRep
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.PrimElemRep
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.FamTyConFlav
instance GHC.Utils.Binary.Binary GHC.Core.TyCon.Injectivity
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.TyConBndrVis
instance GHC.Utils.Outputable.OutputableBndr tv => GHC.Utils.Outputable.Outputable (GHC.Types.Var.VarBndr tv GHC.Core.TyCon.TyConBndrVis)
instance GHC.Utils.Binary.Binary GHC.Core.TyCon.TyConBndrVis

module GHC.Types.Name.Env

-- | Name Environment
type NameEnv a = UniqFM Name a
mkNameEnv :: [(Name, a)] -> NameEnv a
mkNameEnvWith :: (a -> Name) -> [a] -> NameEnv a
emptyNameEnv :: NameEnv a
isEmptyNameEnv :: NameEnv a -> Bool
unitNameEnv :: Name -> a -> NameEnv a
nameEnvElts :: NameEnv a -> [a]
extendNameEnv_C :: (a -> a -> a) -> NameEnv a -> Name -> a -> NameEnv a
extendNameEnv_Acc :: (a -> b -> b) -> (a -> b) -> NameEnv b -> Name -> a -> NameEnv b
extendNameEnv :: NameEnv a -> Name -> a -> NameEnv a
extendNameEnvList :: NameEnv a -> [(Name, a)] -> NameEnv a
extendNameEnvList_C :: (a -> a -> a) -> NameEnv a -> [(Name, a)] -> NameEnv a
filterNameEnv :: (elt -> Bool) -> NameEnv elt -> NameEnv elt
anyNameEnv :: (elt -> Bool) -> NameEnv elt -> Bool
plusNameEnv :: NameEnv a -> NameEnv a -> NameEnv a
plusNameEnv_C :: (a -> a -> a) -> NameEnv a -> NameEnv a -> NameEnv a
plusNameEnv_CD :: (a -> a -> a) -> NameEnv a -> a -> NameEnv a -> a -> NameEnv a
plusNameEnv_CD2 :: (Maybe a -> Maybe a -> a) -> NameEnv a -> NameEnv a -> NameEnv a
alterNameEnv :: (Maybe a -> Maybe a) -> NameEnv a -> Name -> NameEnv a
lookupNameEnv :: NameEnv a -> Name -> Maybe a
lookupNameEnv_NF :: NameEnv a -> Name -> a
delFromNameEnv :: NameEnv a -> Name -> NameEnv a
delListFromNameEnv :: NameEnv a -> [Name] -> NameEnv a
elemNameEnv :: Name -> NameEnv a -> Bool
mapNameEnv :: (elt1 -> elt2) -> NameEnv elt1 -> NameEnv elt2
disjointNameEnv :: NameEnv a -> NameEnv a -> Bool

-- | Deterministic Name Environment
--   
--   See Note [Deterministic UniqFM] in <a>GHC.Types.Unique.DFM</a> for
--   explanation why we need DNameEnv.
type DNameEnv a = UniqDFM Name a
emptyDNameEnv :: DNameEnv a
lookupDNameEnv :: DNameEnv a -> Name -> Maybe a
delFromDNameEnv :: DNameEnv a -> Name -> DNameEnv a
filterDNameEnv :: (a -> Bool) -> DNameEnv a -> DNameEnv a
mapDNameEnv :: (a -> b) -> DNameEnv a -> DNameEnv b
adjustDNameEnv :: (a -> a) -> DNameEnv a -> Name -> DNameEnv a
alterDNameEnv :: (Maybe a -> Maybe a) -> DNameEnv a -> Name -> DNameEnv a
extendDNameEnv :: DNameEnv a -> Name -> a -> DNameEnv a
depAnal :: forall node. (node -> [Name]) -> (node -> [Name]) -> [node] -> [SCC node]

module GHC.Data.Graph.Directed
data Graph node
graphFromEdgedVerticesOrd :: Ord key => [Node key payload] -> Graph (Node key payload)
graphFromEdgedVerticesUniq :: Uniquable key => [Node key payload] -> Graph (Node key payload)

-- | Strongly connected component.
data SCC vertex

-- | A single vertex that is not in any cycle.
AcyclicSCC :: vertex -> SCC vertex

-- | A maximal set of mutually reachable vertices.
CyclicSCC :: [vertex] -> SCC vertex

-- | Representation for nodes of the Graph.
--   
--   <ul>
--   <li>The <tt>payload</tt> is user data, just carried around in this
--   module</li>
--   <li>The <tt>key</tt> is the node identifier. Key has an Ord instance
--   for performance reasons.</li>
--   <li>The <tt>[key]</tt> are the dependencies of the node; it's ok to
--   have extra keys in the dependencies that are not the key of any Node
--   in the graph</li>
--   </ul>
data Node key payload
DigraphNode :: payload -> key -> [key] -> Node key payload

-- | User data
[node_payload] :: Node key payload -> payload

-- | User defined node id
[node_key] :: Node key payload -> key

-- | Dependencies/successors of the node
[node_dependencies] :: Node key payload -> [key]

-- | The vertices of a strongly connected component.
flattenSCC :: SCC vertex -> [vertex]

-- | The vertices of a list of strongly connected components.
flattenSCCs :: [SCC a] -> [a]
stronglyConnCompG :: Graph node -> [SCC node]
topologicalSortG :: Graph node -> [node]
verticesG :: Graph node -> [node]
edgesG :: Graph node -> [Edge node]
hasVertexG :: Graph node -> node -> Bool
reachableG :: Graph node -> node -> [node]

-- | Given a list of roots return all reachable nodes.
reachablesG :: Graph node -> [node] -> [node]
transposeG :: Graph node -> Graph node
emptyG :: Graph node -> Bool

-- | Find a reasonably short cycle a-&gt;b-&gt;c-&gt;a, in a strongly
--   connected component. The input nodes are presumed to be a SCC, so you
--   can start anywhere.
findCycle :: forall payload key. Ord key => [Node key payload] -> Maybe [payload]
stronglyConnCompFromEdgedVerticesOrd :: Ord key => [Node key payload] -> [SCC payload]
stronglyConnCompFromEdgedVerticesOrdR :: Ord key => [Node key payload] -> [SCC (Node key payload)]
stronglyConnCompFromEdgedVerticesUniq :: Uniquable key => [Node key payload] -> [SCC payload]
stronglyConnCompFromEdgedVerticesUniqR :: Uniquable key => [Node key payload] -> [SCC (Node key payload)]

-- | Edge direction based on DFS Classification
data EdgeType
Forward :: EdgeType
Cross :: EdgeType

-- | Loop back towards the root node. Eg backjumps in loops
Backward :: EdgeType

-- | v -&gt; v
SelfLoop :: EdgeType

-- | Given a start vertex, a way to get successors from a node and a list
--   of (directed) edges classify the types of edges.
classifyEdges :: forall key. Uniquable key => key -> (key -> [key]) -> [(key, key)] -> [((key, key), EdgeType)]
instance GHC.Classes.Ord GHC.Data.Graph.Directed.EdgeType
instance GHC.Classes.Eq GHC.Data.Graph.Directed.EdgeType
instance GHC.Utils.Outputable.Outputable GHC.Data.Graph.Directed.Time
instance GHC.Num.Num GHC.Data.Graph.Directed.Time
instance GHC.Classes.Ord GHC.Data.Graph.Directed.Time
instance GHC.Classes.Eq GHC.Data.Graph.Directed.Time
instance GHC.Utils.Outputable.Outputable GHC.Data.Graph.Directed.EdgeType
instance GHC.Utils.Outputable.Outputable node => GHC.Utils.Outputable.Outputable (GHC.Data.Graph.Directed.Graph node)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (GHC.Data.Graph.Directed.Node a b)
instance GHC.Utils.Outputable.Outputable node => GHC.Utils.Outputable.Outputable (GHC.Data.Graph.Directed.Edge node)

module GHC.Core.TyCo.Rep
data Type

-- | Vanilla type or kind variable (*never* a coercion variable)
TyVarTy :: Var -> Type

-- | Type application to something other than a <a>TyCon</a>. Parameters:
--   
--   1) Function: must <i>not</i> be a <a>TyConApp</a> or <a>CastTy</a>,
--   must be another <a>AppTy</a>, or <a>TyVarTy</a> See Note [Respecting
--   definitional equality] (EQ1) about the no <a>CastTy</a> requirement
--   
--   2) Argument type
AppTy :: Type -> Type -> Type

-- | Application of a <a>TyCon</a>, including newtypes <i>and</i> synonyms.
--   Invariant: saturated applications of <tt>FunTyCon</tt> must use
--   <a>FunTy</a> and saturated synonyms must use their own constructors.
--   However, <i>unsaturated</i> <tt>FunTyCon</tt>s do appear as
--   <a>TyConApp</a>s. Parameters:
--   
--   1) Type constructor being applied to.
--   
--   2) Type arguments. Might not have enough type arguments here to
--   saturate the constructor. Even type synonyms are not necessarily
--   saturated; for example unsaturated type synonyms can appear as the
--   right hand side of a type synonym.
TyConApp :: TyCon -> [KindOrType] -> Type

-- | A Î  type. INVARIANT: If the binder is a coercion variable, it must be
--   mentioned in the Type. See Note [Unused coercion variable in ForAllTy]
ForAllTy :: {-# UNPACK #-} !TyCoVarBinder -> Type -> Type

-- | FUN m t1 t2 Very common, so an important special case See Note
--   [Function types]
FunTy :: AnonArgFlag -> Mult -> Type -> Type -> Type
[ft_af] :: Type -> AnonArgFlag
[ft_mult] :: Type -> Mult
[ft_arg] :: Type -> Type
[ft_res] :: Type -> Type

-- | Type literals are similar to type constructors.
LitTy :: TyLit -> Type

-- | A kind cast. The coercion is always nominal. INVARIANT: The cast is
--   never reflexive (EQ2) INVARIANT: The Type is not a CastTy (use TransCo
--   instead) (EQ3) INVARIANT: The Type is not a ForAllTy over a tyvar
--   (EQ4) See Note [Respecting definitional equality]
CastTy :: Type -> KindCoercion -> Type

-- | Injection of a Coercion into a type This should only ever be used in
--   the RHS of an AppTy, in the list of a TyConApp, when applying a
--   promoted GADT data constructor
CoercionTy :: Coercion -> Type
data TyLit
NumTyLit :: Integer -> TyLit
StrTyLit :: FastString -> TyLit
CharTyLit :: Char -> TyLit

-- | The key representation of types within the compiler
type KindOrType = Type

-- | The key type representing kinds in the compiler.
type Kind = Type

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   <a>GHC.Tc.TyCl</a>
type KnotTied ty = ty

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]

-- | Argument Flag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, TyCoVarBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ArgFlag
Invisible :: Specificity -> ArgFlag
Required :: ArgFlag
pattern Specified :: ArgFlag
pattern Inferred :: ArgFlag

-- | The non-dependent version of <a>ArgFlag</a>. See Note [AnonArgFlag]
--   Appears here partly so that it's together with its friends ArgFlag and
--   ForallVisFlag, but also because it is used in IfaceType, rather early
--   in the compilation chain
data AnonArgFlag

-- | Used for <tt>(-&gt;)</tt>: an ordinary non-dependent arrow. The
--   argument is visible in source code.
VisArg :: AnonArgFlag

-- | Used for <tt>(=&gt;)</tt>: a non-dependent predicate arrow. The
--   argument is invisible in source code.
InvisArg :: AnonArgFlag

-- | A <a>Coercion</a> is concrete evidence of the equality/convertibility
--   of two types.
data Coercion
Refl :: Type -> Coercion
GRefl :: Role -> Type -> MCoercionN -> Coercion
TyConAppCo :: Role -> TyCon -> [Coercion] -> Coercion
AppCo :: Coercion -> CoercionN -> Coercion
ForAllCo :: TyCoVar -> KindCoercion -> Coercion -> Coercion
FunCo :: Role -> CoercionN -> Coercion -> Coercion -> Coercion
CoVarCo :: CoVar -> Coercion
AxiomInstCo :: CoAxiom Branched -> BranchIndex -> [Coercion] -> Coercion
AxiomRuleCo :: CoAxiomRule -> [Coercion] -> Coercion
UnivCo :: UnivCoProvenance -> Role -> Type -> Type -> Coercion
SymCo :: Coercion -> Coercion
TransCo :: Coercion -> Coercion -> Coercion
NthCo :: Role -> Int -> Coercion -> Coercion
LRCo :: LeftOrRight -> CoercionN -> Coercion
InstCo :: Coercion -> CoercionN -> Coercion
KindCo :: Coercion -> Coercion
SubCo :: CoercionN -> Coercion

-- | See Note [Coercion holes] Only present during typechecking
HoleCo :: CoercionHole -> Coercion

-- | For simplicity, we have just one UnivCo that represents a coercion
--   from some type to some other type, with (in general) no restrictions
--   on the type. The UnivCoProvenance specifies more exactly what the
--   coercion really is and why a program should (or shouldn't!) trust the
--   coercion. It is reasonable to consider each constructor of
--   <a>UnivCoProvenance</a> as a totally independent coercion form; their
--   only commonality is that they don't tell you what types they coercion
--   between. (That info is in the <a>UnivCo</a> constructor of
--   <a>Coercion</a>.
data UnivCoProvenance

-- | See Note [Phantom coercions]. Only in Phantom roled coercions
PhantomProv :: KindCoercion -> UnivCoProvenance

-- | From the fact that any two coercions are considered equivalent. See
--   Note [ProofIrrelProv]. Can be used in Nominal or Representational
--   coercions
ProofIrrelProv :: KindCoercion -> UnivCoProvenance

-- | From a plugin, which asserts that this coercion is sound. The string
--   is for the use of the plugin.
PluginProv :: String -> UnivCoProvenance
CorePrepProv :: Bool -> UnivCoProvenance

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
CoercionHole :: CoVar -> IORef (Maybe Coercion) -> CoercionHole
[ch_co_var] :: CoercionHole -> CoVar
[ch_ref] :: CoercionHole -> IORef (Maybe Coercion)
coHoleCoVar :: CoercionHole -> CoVar
setCoHoleCoVar :: CoercionHole -> CoVar -> CoercionHole
type CoercionN = Coercion
type CoercionR = Coercion
type CoercionP = Coercion
type KindCoercion = CoercionN

-- | A semantically more meaningful type to represent what may or may not
--   be a useful <a>Coercion</a>.
data MCoercion
MRefl :: MCoercion
MCo :: Coercion -> MCoercion
type MCoercionR = MCoercion
type MCoercionN = MCoercion

-- | Create a nullary <a>TyConApp</a>. In general you should rather use
--   <a>mkTyConTy</a>. This merely exists to break the import cycle between
--   <a>TyCon</a> and this module.
mkTyConTy_ :: TyCon -> Type
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]
mkTyCoVarTy :: TyCoVar -> Type
mkTyCoVarTys :: [TyCoVar] -> [Type]
mkFunTy :: AnonArgFlag -> Mult -> Type -> Type -> Type
infixr 3 `mkFunTy`
mkVisFunTy :: Mult -> Type -> Type -> Type
infixr 3 `mkVisFunTy`
mkInvisFunTy :: Mult -> Type -> Type -> Type
infixr 3 `mkInvisFunTy`

-- | Make nested arrow types
mkVisFunTys :: [Scaled Type] -> Type -> Type

-- | Like <tt>mkTyCoForAllTy</tt>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: TyCoVar -> ArgFlag -> Type -> Type

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [TyCoVarBinder] -> Type -> Type

-- | Wraps foralls over the type using the provided <a>InvisTVBinder</a>s
--   from left to right
mkInvisForAllTys :: [InvisTVBinder] -> Type -> Type
mkPiTy :: TyCoBinder -> Type -> Type
mkPiTys :: [TyCoBinder] -> Type -> Type
mkFunTyMany :: AnonArgFlag -> Type -> Type -> Type
mkScaledFunTy :: AnonArgFlag -> Scaled Type -> Type -> Type

-- | Special, common, case: Arrow type with mult Many
mkVisFunTyMany :: Type -> Type -> Type
infixr 3 `mkVisFunTyMany`
mkVisFunTysMany :: [Type] -> Type -> Type
mkInvisFunTyMany :: Type -> Type -> Type
infixr 3 `mkInvisFunTyMany`
mkInvisFunTysMany :: [Type] -> Type -> Type
nonDetCmpTyLit :: TyLit -> TyLit -> Ordering
cmpTyLit :: TyLit -> TyLit -> Ordering

-- | A <a>TyCoBinder</a> represents an argument to a function. TyCoBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [TyCoBinders]
data TyCoBinder
Named :: TyCoVarBinder -> TyCoBinder
Anon :: AnonArgFlag -> Scaled Type -> TyCoBinder

-- | Variable Binder
--   
--   A <a>TyCoVarBinder</a> is the binder of a ForAllTy It's convenient to
--   define this synonym here rather its natural home in
--   <a>GHC.Core.TyCo.Rep</a>, because it's used in
--   GHC.Core.DataCon.hs-boot
--   
--   A <a>TyVarBinder</a> is a binder with only TyVar
type TyCoVarBinder = VarBndr TyCoVar ArgFlag

-- | <a>TyBinder</a> is like <a>TyCoBinder</a>, but there can only be
--   <a>TyVarBinder</a> in the <a>Named</a> field.
type TyBinder = TyCoBinder
binderVar :: VarBndr tv argf -> tv
binderVars :: [VarBndr tv argf] -> [tv]
binderType :: VarBndr TyCoVar argf -> Type
binderArgFlag :: VarBndr tv argf -> argf

-- | Remove the binder's variable from the set, if the binder has a
--   variable.
delBinderVar :: VarSet -> TyCoVarBinder -> VarSet

-- | Does this <a>ArgFlag</a> classify an argument that is not written in
--   Haskell?
isInvisibleArgFlag :: ArgFlag -> Bool

-- | Does this <a>ArgFlag</a> classify an argument that is written in
--   Haskell?
isVisibleArgFlag :: ArgFlag -> Bool

-- | Does this binder bind an invisible argument?
isInvisibleBinder :: TyCoBinder -> Bool

-- | Does this binder bind a visible argument?
isVisibleBinder :: TyCoBinder -> Bool

-- | If its a named binder, is the binder a tyvar? Returns True for
--   nondependent binder. This check that we're really returning a
--   *Ty*Binder (as opposed to a coercion binder). That way, if/when we
--   allow coercion quantification in more places, we'll know we missed
--   updating some function.
isTyBinder :: TyCoBinder -> Bool
isNamedBinder :: TyCoBinder -> Bool
pickLR :: LeftOrRight -> (a, a) -> a
data TyCoFolder env a
TyCoFolder :: (Type -> Maybe Type) -> (env -> TyVar -> a) -> (env -> CoVar -> a) -> (env -> CoercionHole -> a) -> (env -> TyCoVar -> ArgFlag -> env) -> TyCoFolder env a
[tcf_view] :: TyCoFolder env a -> Type -> Maybe Type
[tcf_tyvar] :: TyCoFolder env a -> env -> TyVar -> a
[tcf_covar] :: TyCoFolder env a -> env -> CoVar -> a

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcf_hole] :: TyCoFolder env a -> env -> CoercionHole -> a

-- | The returned env is used in the extended scope
[tcf_tycobinder] :: TyCoFolder env a -> env -> TyCoVar -> ArgFlag -> env
foldTyCo :: Monoid a => TyCoFolder env a -> env -> (Type -> a, [Type] -> a, Coercion -> a, [Coercion] -> a)
typeSize :: Type -> Int
coercionSize :: Coercion -> Int
provSize :: UnivCoProvenance -> Int

-- | A shorthand for data with an attached <a>Mult</a> element (the
--   multiplicity).
data Scaled a
Scaled :: !Mult -> a -> Scaled a
scaledMult :: Scaled a -> Mult
scaledThing :: Scaled a -> a

-- | Apply a function to both the Mult and the Type in a 'Scaled Type'
mapScaledType :: (Type -> Type) -> Scaled Type -> Scaled Type

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type
instance Data.Data.Data GHC.Core.TyCo.Rep.TyLit
instance GHC.Classes.Eq GHC.Core.TyCo.Rep.TyLit
instance Data.Data.Data GHC.Core.TyCo.Rep.MCoercion
instance Data.Data.Data GHC.Core.TyCo.Rep.UnivCoProvenance
instance Data.Data.Data GHC.Core.TyCo.Rep.Coercion
instance Data.Data.Data GHC.Core.TyCo.Rep.Type
instance Data.Data.Data a => Data.Data.Data (GHC.Core.TyCo.Rep.Scaled a)
instance Data.Data.Data GHC.Core.TyCo.Rep.TyCoBinder
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.TyCoBinder
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.TyCo.Rep.Scaled a)
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.Type
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.Coercion
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.MCoercion
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.UnivCoProvenance
instance Data.Data.Data GHC.Core.TyCo.Rep.CoercionHole
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.CoercionHole
instance GHC.Types.Unique.Uniquable GHC.Core.TyCo.Rep.CoercionHole
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.TyLit

module GHC.Iface.Type
type IfExtName = Name
type IfLclName = FastString

-- | A kind of universal type, used for types and kinds.
--   
--   Any time a <tt>Type</tt> is pretty-printed, it is first converted to
--   an <a>IfaceType</a> before being printed. See Note [Pretty printing
--   via Iface syntax] in <a>GHC.Types.TyThing.Ppr</a>
data IfaceType
IfaceFreeTyVar :: TyVar -> IfaceType
IfaceTyVar :: IfLclName -> IfaceType
IfaceLitTy :: IfaceTyLit -> IfaceType
IfaceAppTy :: IfaceType -> IfaceAppArgs -> IfaceType
IfaceFunTy :: AnonArgFlag -> IfaceMult -> IfaceType -> IfaceType -> IfaceType
IfaceForAllTy :: IfaceForAllBndr -> IfaceType -> IfaceType
IfaceTyConApp :: IfaceTyCon -> IfaceAppArgs -> IfaceType
IfaceCastTy :: IfaceType -> IfaceCoercion -> IfaceType
IfaceCoercionTy :: IfaceCoercion -> IfaceType
IfaceTupleTy :: TupleSort -> PromotionFlag -> IfaceAppArgs -> IfaceType
type IfacePredType = IfaceType
type IfaceKind = IfaceType
data IfaceCoercion
IfaceReflCo :: IfaceType -> IfaceCoercion
IfaceGReflCo :: Role -> IfaceType -> IfaceMCoercion -> IfaceCoercion
IfaceFunCo :: Role -> IfaceCoercion -> IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceTyConAppCo :: Role -> IfaceTyCon -> [IfaceCoercion] -> IfaceCoercion
IfaceAppCo :: IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceForAllCo :: IfaceBndr -> IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceCoVarCo :: IfLclName -> IfaceCoercion
IfaceAxiomInstCo :: IfExtName -> BranchIndex -> [IfaceCoercion] -> IfaceCoercion
IfaceAxiomRuleCo :: IfLclName -> [IfaceCoercion] -> IfaceCoercion
IfaceUnivCo :: IfaceUnivCoProv -> Role -> IfaceType -> IfaceType -> IfaceCoercion
IfaceSymCo :: IfaceCoercion -> IfaceCoercion
IfaceTransCo :: IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceNthCo :: Int -> IfaceCoercion -> IfaceCoercion
IfaceLRCo :: LeftOrRight -> IfaceCoercion -> IfaceCoercion
IfaceInstCo :: IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceKindCo :: IfaceCoercion -> IfaceCoercion
IfaceSubCo :: IfaceCoercion -> IfaceCoercion
IfaceFreeCoVar :: CoVar -> IfaceCoercion

-- | See Note [Holes in IfaceCoercion]
IfaceHoleCo :: CoVar -> IfaceCoercion
data IfaceMCoercion
IfaceMRefl :: IfaceMCoercion
IfaceMCo :: IfaceCoercion -> IfaceMCoercion
data IfaceUnivCoProv
IfacePhantomProv :: IfaceCoercion -> IfaceUnivCoProv
IfaceProofIrrelProv :: IfaceCoercion -> IfaceUnivCoProv
IfacePluginProv :: String -> IfaceUnivCoProv
IfaceCorePrepProv :: Bool -> IfaceUnivCoProv
type IfaceMult = IfaceType
data IfaceTyCon
IfaceTyCon :: IfExtName -> IfaceTyConInfo -> IfaceTyCon
[ifaceTyConName] :: IfaceTyCon -> IfExtName
[ifaceTyConInfo] :: IfaceTyCon -> IfaceTyConInfo
data IfaceTyConInfo
IfaceTyConInfo :: PromotionFlag -> IfaceTyConSort -> IfaceTyConInfo
[ifaceTyConIsPromoted] :: IfaceTyConInfo -> PromotionFlag
[ifaceTyConSort] :: IfaceTyConInfo -> IfaceTyConSort
mkIfaceTyConInfo :: PromotionFlag -> IfaceTyConSort -> IfaceTyConInfo

-- | The various types of TyCons which have special, built-in syntax.
data IfaceTyConSort

-- | a regular tycon
IfaceNormalTyCon :: IfaceTyConSort

-- | e.g. <tt>(a, b, c)</tt> or <tt>(#a, b, c#)</tt>. The arity is the
--   tuple width, not the tycon arity (which is twice the width in the case
--   of unboxed tuples).
IfaceTupleTyCon :: !Arity -> !TupleSort -> IfaceTyConSort

-- | e.g. <tt>(a | b | c)</tt>
IfaceSumTyCon :: !Arity -> IfaceTyConSort

-- | A heterogeneous equality TyCon (i.e. eqPrimTyCon, eqReprPrimTyCon,
--   heqTyCon) that is actually being applied to two types of the same
--   kind. This affects pretty-printing only: see Note [Equality predicates
--   in IfaceType]
IfaceEqualityTyCon :: IfaceTyConSort
data IfaceTyLit
IfaceNumTyLit :: Integer -> IfaceTyLit
IfaceStrTyLit :: FastString -> IfaceTyLit
IfaceCharTyLit :: Char -> IfaceTyLit

-- | Stores the arguments in a type application as a list. See <tt>Note
--   [Suppressing invisible arguments]</tt>.
data IfaceAppArgs
IA_Nil :: IfaceAppArgs
IA_Arg :: IfaceType -> ArgFlag -> IfaceAppArgs -> IfaceAppArgs
type IfaceContext = [IfacePredType]
data IfaceBndr
IfaceIdBndr :: {-# UNPACK #-} !IfaceIdBndr -> IfaceBndr
IfaceTvBndr :: {-# UNPACK #-} !IfaceTvBndr -> IfaceBndr
data IfaceOneShot
IfaceNoOneShot :: IfaceOneShot
IfaceOneShot :: IfaceOneShot
type IfaceLamBndr = (IfaceBndr, IfaceOneShot)
type IfaceTvBndr = (IfLclName, IfaceKind)
type IfaceIdBndr = (IfaceType, IfLclName, IfaceType)
type IfaceTyConBinder = VarBndr IfaceBndr TyConBndrVis
type IfaceForAllSpecBndr = VarBndr IfaceBndr Specificity
type IfaceForAllBndr = VarBndr IfaceBndr ArgFlag

-- | Argument Flag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, TyCoVarBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ArgFlag
Invisible :: Specificity -> ArgFlag
Required :: ArgFlag
pattern Specified :: ArgFlag
pattern Inferred :: ArgFlag

-- | The non-dependent version of <a>ArgFlag</a>. See Note [AnonArgFlag]
--   Appears here partly so that it's together with its friends ArgFlag and
--   ForallVisFlag, but also because it is used in IfaceType, rather early
--   in the compilation chain
data AnonArgFlag

-- | Used for <tt>(-&gt;)</tt>: an ordinary non-dependent arrow. The
--   argument is visible in source code.
VisArg :: AnonArgFlag

-- | Used for <tt>(=&gt;)</tt>: a non-dependent predicate arrow. The
--   argument is invisible in source code.
InvisArg :: AnonArgFlag

-- | Show forall flag
--   
--   Unconditionally show the forall quantifier with
--   (<a>ShowForAllMust</a>) or when (<a>ShowForAllWhen</a>) the names used
--   are free in the binder or when compiling with
--   -fprint-explicit-foralls.
data ShowForAllFlag
ShowForAllMust :: ShowForAllFlag
ShowForAllWhen :: ShowForAllFlag

-- | Make an <a>IfaceForAllBndr</a> from an <a>IfaceTvBndr</a>.
mkIfaceForAllTvBndr :: ArgFlag -> IfaceTvBndr -> IfaceForAllBndr

-- | Build the <a>tyConKind</a> from the binders and the result kind. Keep
--   in sync with <a>mkTyConKind</a> in <a>GHC.Core.TyCon</a>.
mkIfaceTyConKind :: [IfaceTyConBinder] -> IfaceKind -> IfaceKind
ifaceForAllSpecToBndrs :: [IfaceForAllSpecBndr] -> [IfaceForAllBndr]
ifaceForAllSpecToBndr :: IfaceForAllSpecBndr -> IfaceForAllBndr

-- | Extract an <a>IfaceBndr</a> from an <a>IfaceForAllBndr</a>.
ifForAllBndrVar :: IfaceForAllBndr -> IfaceBndr

-- | Extract the variable name from an <a>IfaceForAllBndr</a>.
ifForAllBndrName :: IfaceForAllBndr -> IfLclName
ifaceBndrName :: IfaceBndr -> IfLclName

-- | Extract an <a>IfaceBndr</a> from an <a>IfaceTyConBinder</a>.
ifTyConBinderVar :: IfaceTyConBinder -> IfaceBndr

-- | Extract the variable name from an <a>IfaceTyConBinder</a>.
ifTyConBinderName :: IfaceTyConBinder -> IfLclName

-- | Given a kind K, is K of the form (TYPE ('BoxedRep 'LiftedRep))?
isIfaceLiftedTypeKind :: IfaceKind -> Bool
appArgsIfaceTypes :: IfaceAppArgs -> [IfaceType]
appArgsIfaceTypesArgFlags :: IfaceAppArgs -> [(IfaceType, ArgFlag)]

-- | Do we want to suppress kind annotations on binders? See Note
--   [Suppressing binder signatures]
newtype SuppressBndrSig
SuppressBndrSig :: Bool -> SuppressBndrSig
newtype UseBndrParens
UseBndrParens :: Bool -> UseBndrParens
newtype PrintExplicitKinds
PrintExplicitKinds :: Bool -> PrintExplicitKinds
pprIfaceType :: IfaceType -> SDoc
pprParendIfaceType :: IfaceType -> SDoc
pprPrecIfaceType :: PprPrec -> IfaceType -> SDoc

-- | Prints a context or <tt>()</tt> if empty You give it the context
--   precedence
pprIfaceContext :: PprPrec -> [IfacePredType] -> SDoc

-- | Prints "(C a, D b) =&gt;", including the arrow. Used when we want to
--   print a context in a type, so we use <a>funPrec</a> to decide whether
--   to parenthesise a singleton predicate; e.g. Num a =&gt; a -&gt; a
pprIfaceContextArr :: [IfacePredType] -> SDoc
pprIfaceIdBndr :: IfaceIdBndr -> SDoc
pprIfaceLamBndr :: IfaceLamBndr -> SDoc
pprIfaceTvBndr :: IfaceTvBndr -> SuppressBndrSig -> UseBndrParens -> SDoc
pprIfaceTyConBinders :: SuppressBndrSig -> [IfaceTyConBinder] -> SDoc
pprIfaceBndrs :: [IfaceBndr] -> SDoc
pprIfaceAppArgs :: IfaceAppArgs -> SDoc
pprParendIfaceAppArgs :: IfaceAppArgs -> SDoc
pprIfaceForAllPart :: [IfaceForAllBndr] -> [IfacePredType] -> SDoc -> SDoc

-- | Like <a>pprIfaceForAllPart</a>, but always uses an explicit
--   <tt>forall</tt>.
pprIfaceForAllPartMust :: [IfaceForAllBndr] -> [IfacePredType] -> SDoc -> SDoc

-- | Render the "forall ... ." or "forall ... -&gt;" bit of a type.
pprIfaceForAll :: [IfaceForAllBndr] -> SDoc
pprIfaceSigmaType :: ShowForAllFlag -> IfaceType -> SDoc
pprIfaceTyLit :: IfaceTyLit -> SDoc
pprIfaceCoercion :: IfaceCoercion -> SDoc
pprParendIfaceCoercion :: IfaceCoercion -> SDoc
splitIfaceSigmaTy :: IfaceType -> ([IfaceForAllBndr], [IfacePredType], IfaceType)
pprIfaceTypeApp :: PprPrec -> IfaceTyCon -> IfaceAppArgs -> SDoc
pprUserIfaceForAll :: [IfaceForAllBndr] -> SDoc
pprIfaceCoTcApp :: PprPrec -> IfaceTyCon -> [IfaceCoercion] -> SDoc
pprTyTcApp :: PprPrec -> IfaceTyCon -> IfaceAppArgs -> SDoc
pprIfacePrefixApp :: PprPrec -> SDoc -> [SDoc] -> SDoc
ppr_fun_arrow :: IfaceMult -> SDoc
isIfaceTauType :: IfaceType -> Bool
suppressIfaceInvisibles :: PrintExplicitKinds -> [IfaceTyConBinder] -> [a] -> [a]
stripIfaceInvisVars :: PrintExplicitKinds -> [IfaceTyConBinder] -> [IfaceTyConBinder]
stripInvisArgs :: PrintExplicitKinds -> IfaceAppArgs -> IfaceAppArgs
mkIfaceTySubst :: [(IfLclName, IfaceType)] -> IfaceTySubst
substIfaceTyVar :: IfaceTySubst -> IfLclName -> IfaceType
substIfaceAppArgs :: IfaceTySubst -> IfaceAppArgs -> IfaceAppArgs
inDomIfaceTySubst :: IfaceTySubst -> IfaceTvBndr -> Bool
many_ty :: IfaceType
instance GHC.Classes.Eq GHC.Iface.Type.IfaceTyLit
instance GHC.Classes.Eq GHC.Iface.Type.IfaceTyConSort
instance GHC.Classes.Eq GHC.Iface.Type.IfaceTyConInfo
instance GHC.Classes.Eq GHC.Iface.Type.IfaceTyCon
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceBndr
instance GHC.Base.Semigroup GHC.Iface.Type.IfaceAppArgs
instance GHC.Base.Monoid GHC.Iface.Type.IfaceAppArgs
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceBndr
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceType
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceAppArgs
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceCoercion
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceAppArgs
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceType
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceMCoercion
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceCoercion
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceUnivCoProv
instance GHC.Utils.Binary.Binary (GHC.Types.Basic.DefMethSpec GHC.Iface.Type.IfaceType)
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceType
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceCoercion
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceUnivCoProv
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceMCoercion
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceBndr
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceAppArgs
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceTyCon
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceTyCon
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceTyCon
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceTyConInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceTyConInfo
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceTyConInfo
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceTyConSort
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceTyConSort
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceTyConSort
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceTyLit
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceTyLit
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceTyLit
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceOneShot
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceOneShot
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceOneShot


-- | Types used in the typechecker
--   
--   This module provides the Type interface for front-end parts of the
--   compiler. These parts
--   
--   <ul>
--   <li>treat "source types" as opaque: newtypes, and predicates are
--   meaningful.</li>
--   <li>look through usage types</li>
--   </ul>
module GHC.Tc.Utils.TcType
type TcType = Type
type TcSigmaType = TcType
type TcRhoType = TcType
type TcTauType = TcType
type TcPredType = PredType
type TcThetaType = ThetaType

-- | Type variable that might be a metavariable
type TcTyVar = Var
type TcTyVarSet = TyVarSet
type TcDTyVarSet = DTyVarSet
type TcTyCoVarSet = TyCoVarSet
type TcDTyCoVarSet = DTyCoVarSet
type TcKind = Kind
type TcCoVar = CoVar
type TcTyCoVar = Var
type TcTyVarBinder = TyVarBinder
type TcInvisTVBinder = InvisTVBinder
type TcReqTVBinder = ReqTVBinder
type TcTyCon = TyCon

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   <a>GHC.Tc.TyCl</a>
type KnotTied ty = ty

-- | An expected type to check against during type-checking. See Note
--   [ExpType] in <a>GHC.Tc.Utils.TcMType</a>, where you'll also find
--   manipulators.
data ExpType
Check :: TcType -> ExpType
Infer :: !InferResult -> ExpType
data InferResult
IR :: Unique -> TcLevel -> IORef (Maybe TcType) -> InferResult
[ir_uniq] :: InferResult -> Unique
[ir_lvl] :: InferResult -> TcLevel
[ir_ref] :: InferResult -> IORef (Maybe TcType)
type ExpSigmaType = ExpType
type ExpRhoType = ExpType

-- | Make an <a>ExpType</a> suitable for checking.
mkCheckExpType :: TcType -> ExpType

-- | What to expect for an argument to a rebindable-syntax operator. Quite
--   like <a>Type</a>, but allows for holes to be filled in by tcSyntaxOp.
--   The callback called from tcSyntaxOp gets a list of types; the meaning
--   of these types is determined by a left-to-right depth-first traversal
--   of the <a>SyntaxOpType</a> tree. So if you pass in
--   
--   <pre>
--   SynAny `SynFun` (SynList `SynFun` SynType Int) `SynFun` SynAny
--   </pre>
--   
--   you'll get three types back: one for the first <a>SynAny</a>, the
--   <i>element</i> type of the list, and one for the last <a>SynAny</a>.
--   You don't get anything for the <a>SynType</a>, because you've said
--   positively that it should be an Int, and so it shall be.
--   
--   You'll also get three multiplicities back: one for each function
--   arrow. See also Note [Linear types] in Multiplicity.
--   
--   This is defined here to avoid defining it in <a>GHC.Tc.Gen.Expr</a>
--   boot file.
data SyntaxOpType

-- | Any type
SynAny :: SyntaxOpType

-- | A rho type, skolemised or instantiated as appropriate
SynRho :: SyntaxOpType

-- | A list type. You get back the element type of the list
SynList :: SyntaxOpType

-- | A function.
SynFun :: SyntaxOpType -> SyntaxOpType -> SyntaxOpType

-- | A known type.
SynType :: ExpType -> SyntaxOpType
infixr 0 `SynFun`

-- | Like <a>SynType</a> but accepts a regular TcType
synKnownType :: TcType -> SyntaxOpType

-- | Like <tt>mkFunTys</tt> but for <a>SyntaxOpType</a>
mkSynFunTys :: [SyntaxOpType] -> ExpType -> SyntaxOpType
newtype TcLevel
TcLevel :: Int -> TcLevel
topTcLevel :: TcLevel
pushTcLevel :: TcLevel -> TcLevel
isTopTcLevel :: TcLevel -> Bool
strictlyDeeperThan :: TcLevel -> TcLevel -> Bool
deeperThanOrSame :: TcLevel -> TcLevel -> Bool
sameDepthAs :: TcLevel -> TcLevel -> Bool
tcTypeLevel :: TcType -> TcLevel
tcTyVarLevel :: TcTyVar -> TcLevel
maxTcLevel :: TcLevel -> TcLevel -> TcLevel
promoteSkolem :: TcLevel -> TcTyVar -> TcTyVar

-- | Change the TcLevel in a skolem, extending a substitution
promoteSkolemX :: TcLevel -> TCvSubst -> TcTyVar -> (TCvSubst, TcTyVar)
promoteSkolemsX :: TcLevel -> TCvSubst -> [TcTyVar] -> (TCvSubst, [TcTyVar])
data TcTyVarDetails
SkolemTv :: TcLevel -> Bool -> TcTyVarDetails
RuntimeUnk :: TcTyVarDetails
MetaTv :: MetaInfo -> IORef MetaDetails -> TcLevel -> TcTyVarDetails
[mtv_info] :: TcTyVarDetails -> MetaInfo
[mtv_ref] :: TcTyVarDetails -> IORef MetaDetails
[mtv_tclvl] :: TcTyVarDetails -> TcLevel
pprTcTyVarDetails :: TcTyVarDetails -> SDoc
vanillaSkolemTv :: TcTyVarDetails
superSkolemTv :: TcTyVarDetails
data MetaDetails
Flexi :: MetaDetails
Indirect :: TcType -> MetaDetails
data MetaInfo
TauTv :: MetaInfo
TyVarTv :: MetaInfo
RuntimeUnkTv :: MetaInfo
CycleBreakerTv :: MetaInfo
isImmutableTyVar :: TyVar -> Bool
isSkolemTyVar :: TcTyVar -> Bool
isMetaTyVar :: TcTyVar -> Bool
isMetaTyVarTy :: TcType -> Bool
isTyVarTy :: Type -> Bool
tcIsTcTyVar :: TcTyVar -> Bool
isTyVarTyVar :: Var -> Bool
isOverlappableTyVar :: TcTyVar -> Bool
isTyConableTyVar :: TcTyVar -> Bool
isAmbiguousTyVar :: TcTyVar -> Bool
isCycleBreakerTyVar :: TcTyVar -> Bool
metaTyVarRef :: TyVar -> IORef MetaDetails
metaTyVarInfo :: TcTyVar -> MetaInfo
isFlexi :: MetaDetails -> Bool
isIndirect :: MetaDetails -> Bool
isRuntimeUnkSkol :: TyVar -> Bool
metaTyVarTcLevel :: TcTyVar -> TcLevel
setMetaTyVarTcLevel :: TcTyVar -> TcLevel -> TcTyVar
metaTyVarTcLevel_maybe :: TcTyVar -> Maybe TcLevel
isTouchableMetaTyVar :: TcLevel -> TcTyVar -> Bool
isPromotableMetaTyVar :: TcTyVar -> Bool
findDupTyVarTvs :: [(Name, TcTyVar)] -> [(Name, Name)]
mkTyVarNamePairs :: [TyVar] -> [(Name, TyVar)]
mkPhiTy :: [PredType] -> Type -> Type

-- | Make a sigma ty where all type variables are <a>Inferred</a>. That is,
--   they cannot be used with visible type application.
mkInfSigmaTy :: [TyCoVar] -> [PredType] -> Type -> Type

-- | Make a sigma ty where all type variables are "specified". That is,
--   they can be used with visible type application
mkSpecSigmaTy :: [TyVar] -> [PredType] -> Type -> Type
mkSigmaTy :: [TyCoVarBinder] -> [PredType] -> Type -> Type
mkTcAppTy :: Type -> Type -> Type
mkTcAppTys :: Type -> [Type] -> Type
mkTcCastTy :: Type -> Coercion -> Type

-- | Attempts to obtain the type variable underlying a <a>Type</a>, and
--   panics with the given message if this is not a type variable type. See
--   also <a>getTyVar_maybe</a>
getTyVar :: String -> Type -> TyVar
tcSplitForAllTyVarBinder_maybe :: Type -> Maybe (TyVarBinder, Type)

-- | Like <a>tcSplitPiTys</a>, but splits off only named binders, returning
--   just the tyvars.
tcSplitForAllTyVars :: Type -> ([TyVar], Type)

-- | Like <a>tcSplitForAllTyVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Invisible</a> type variable binders.
tcSplitForAllInvisTyVars :: Type -> ([TyVar], Type)

-- | Like <a>tcSplitForAllTyVars</a>, but only splits a <a>ForAllTy</a> if
--   <tt>argf_pred argf</tt> is <a>True</a>, where <tt>argf</tt> is the
--   visibility of the <tt>ForAllTy</tt>'s binder and <tt>argf_pred</tt> is
--   a predicate over visibilities provided as an argument to this
--   function.
tcSplitSomeForAllTyVars :: (ArgFlag -> Bool) -> Type -> ([TyVar], Type)

-- | Like <a>tcSplitForAllTyVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Required</a> type variable binders. All split tyvars are annotated
--   with <tt>()</tt>.
tcSplitForAllReqTVBinders :: Type -> ([TcReqTVBinder], Type)

-- | Like <a>tcSplitForAllTyVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Invisible</a> type variable binders. All split tyvars are annotated
--   with their <a>Specificity</a>.
tcSplitForAllInvisTVBinders :: Type -> ([TcInvisTVBinder], Type)

-- | Splits a forall type into a list of <a>TyBinder</a>s and the inner
--   type. Always succeeds, even if it returns an empty list.
tcSplitPiTys :: Type -> ([TyBinder], Type)

-- | Splits a type into a TyBinder and a body, if possible. Panics
--   otherwise
tcSplitPiTy_maybe :: Type -> Maybe (TyBinder, Type)

-- | Like <a>tcSplitForAllTyVars</a>, but splits off only named binders.
tcSplitForAllTyVarBinders :: Type -> ([TyVarBinder], Type)
tcSplitPhiTy :: Type -> (ThetaType, Type)
tcSplitPredFunTy_maybe :: Type -> Maybe (PredType, Type)
tcSplitFunTy_maybe :: Type -> Maybe (Scaled Type, Type)
tcSplitFunTys :: Type -> ([Scaled Type], Type)
tcFunArgTy :: Type -> Scaled Type
tcFunResultTy :: Type -> Type

-- | Strips off n *visible* arguments and returns the resulting type
tcFunResultTyN :: HasDebugCallStack => Arity -> Type -> Type

-- | Split off exactly the specified number argument types Returns (Left m)
--   if there are <tt>m</tt> missing arrows in the type (Right (tys,res))
--   if the type looks like t1 -&gt; ... -&gt; tn -&gt; res
tcSplitFunTysN :: Arity -> TcRhoType -> Either Arity ([Scaled TcSigmaType], TcSigmaType)
tcSplitTyConApp :: Type -> (TyCon, [Type])

-- | Split a type constructor application into its type constructor and
--   applied types. Note that this may fail in the case of a <a>FunTy</a>
--   with an argument of unknown kind <a>FunTy</a> (e.g. <tt>FunTy (a :: k)
--   Int</tt>. since the kind of <tt>a</tt> isn't of the form <tt>TYPE
--   rep</tt>). Consequently, you may need to zonk your type before using
--   this function.
--   
--   This does *not* split types headed with (=&gt;), as that's not a TyCon
--   in the type-checker.
--   
--   If you only need the <a>TyCon</a>, consider using
--   <tt>tcTyConAppTyCon_maybe</tt>.
tcSplitTyConApp_maybe :: HasCallStack => Type -> Maybe (TyCon, [Type])
tcTyConAppTyCon :: Type -> TyCon

-- | Like <a>tcRepSplitTyConApp_maybe</a>, but only returns the
--   <a>TyCon</a>.
tcTyConAppTyCon_maybe :: Type -> Maybe TyCon
tcTyConAppArgs :: Type -> [Type]
tcSplitAppTy_maybe :: Type -> Maybe (Type, Type)
tcSplitAppTy :: Type -> (Type, Type)
tcSplitAppTys :: Type -> (Type, [Type])

-- | Does the AppTy split as in <tt>tcSplitAppTy_maybe</tt>, but assumes
--   that any coreView stuff is already done. Refuses to look through (c
--   =&gt; t)
tcRepSplitAppTy_maybe :: Type -> Maybe (Type, Type)

-- | Returns the number of arguments in the given type, without looking
--   through synonyms. This is used only for error reporting. We don't look
--   through synonyms because of #11313.
tcRepGetNumAppTys :: Type -> Arity

-- | If the type is a tyvar, possibly under a cast, returns it, along with
--   the coercion. Thus, the co is :: kind tv ~N kind type
tcGetCastedTyVar_maybe :: Type -> Maybe (TyVar, CoercionN)
tcGetTyVar_maybe :: Type -> Maybe TyVar
tcGetTyVar :: String -> Type -> TyVar

-- | Split a sigma type into its parts. This only splits <i>invisible</i>
--   type variable binders, as these are the only forms of binder that the
--   typechecker will implicitly instantiate.
tcSplitSigmaTy :: Type -> ([TyVar], ThetaType, Type)

-- | Split a sigma type into its parts, going underneath as many arrows and
--   foralls as possible. See Note [tcSplitNestedSigmaTys]
tcSplitNestedSigmaTys :: Type -> ([TyVar], ThetaType, Type)

-- | Type equality on source types. Does not look through <tt>newtypes</tt>
--   or <a>PredType</a>s, but it does look through type synonyms. This
--   first checks that the kinds of the types are equal and then checks
--   whether the types are equal, ignoring casts and coercions. (The kind
--   check is a recursive call, but since all kinds have type
--   <tt>Type</tt>, there is no need to check the types of kinds.) See also
--   Note [Non-trivial definitional equality] in <a>GHC.Core.TyCo.Rep</a>.
eqType :: Type -> Type -> Bool

-- | Type equality on lists of types, looking through type synonyms but not
--   newtypes.
eqTypes :: [Type] -> [Type] -> Bool
nonDetCmpType :: Type -> Type -> Ordering
nonDetCmpTypes :: [Type] -> [Type] -> Ordering

-- | Compare types with respect to a (presumably) non-empty <a>RnEnv2</a>.
eqTypeX :: RnEnv2 -> Type -> Type -> Bool

-- | Like <tt>pickyEqTypeVis</tt>, but returns a Bool for convenience
pickyEqType :: TcType -> TcType -> Bool

-- | tcEqType implements typechecker equality, as described in <tt>Note
--   [Typechecker equality vs definitional equality]</tt>.
tcEqType :: HasDebugCallStack => TcType -> TcType -> Bool
tcEqKind :: HasDebugCallStack => TcKind -> TcKind -> Bool

-- | Just like <a>tcEqType</a>, but will return True for types of different
--   kinds as long as their non-coercion structure is identical.
tcEqTypeNoKindCheck :: TcType -> TcType -> Bool

-- | Like <a>tcEqType</a>, but returns True if the <i>visible</i> part of
--   the types are equal, even if they are really unequal (in the invisible
--   bits)
tcEqTypeVis :: TcType -> TcType -> Bool

-- | Check whether two TyConApps are the same; if the number of arguments
--   are different, just checks the common prefix of arguments.
tcEqTyConApps :: TyCon -> [Type] -> TyCon -> [Type] -> Bool
isSigmaTy :: TcType -> Bool
isRhoTy :: TcType -> Bool

-- | Like <a>isRhoTy</a>, but also says <a>True</a> for <a>Infer</a> types
isRhoExpTy :: ExpType -> Bool
isOverloadedTy :: Type -> Bool

-- | Does a type represent a floating-point number?
isFloatingTy :: Type -> Bool
isDoubleTy :: Type -> Bool
isFloatTy :: Type -> Bool
isIntTy :: Type -> Bool
isWordTy :: Type -> Bool

-- | Is a type <a>String</a>?
isStringTy :: Type -> Bool
isIntegerTy :: Type -> Bool
isNaturalTy :: Type -> Bool
isBoolTy :: Type -> Bool
isUnitTy :: Type -> Bool
isCharTy :: Type -> Bool

-- | Is a type a <tt>CallStack</tt>?
isCallStackTy :: Type -> Bool

-- | Is a <a>PredType</a> a <tt>CallStack</tt> implicit parameter?
--   
--   If so, return the name of the parameter.
isCallStackPred :: Class -> [Type] -> Maybe FastString
isTauTy :: Type -> Bool
isTauTyCon :: TyCon -> Bool
tcIsTyVarTy :: Type -> Bool

-- | Is this a ForAllTy with a named binder?
tcIsForAllTy :: Type -> Bool
isPredTy :: HasDebugCallStack => Type -> Bool
isTyVarClassPred :: PredType -> Bool
checkValidClsArgs :: Bool -> Class -> [KindOrType] -> Bool
hasTyVarHead :: Type -> Bool
isRigidTy :: TcType -> Bool
deNoteType :: Type -> Type
orphNamesOfType :: Type -> NameSet
orphNamesOfCo :: Coercion -> NameSet
orphNamesOfTypes :: [Type] -> NameSet
orphNamesOfCoCon :: CoAxiom br -> NameSet
getDFunTyKey :: Type -> OccName
evVarPred :: EvVar -> PredType
mkMinimalBySCs :: forall a. (a -> PredType) -> [a] -> [a]
transSuperClasses :: PredType -> [PredType]

-- | When inferring types, should we quantify over a given predicate?
--   Generally true of classes; generally false of equality constraints.
--   Equality constraints that mention quantified type variables and
--   implicit variables complicate the story. See Notes [Inheriting
--   implicit parameters] and [Quantifying over equality constraints]
pickQuantifiablePreds :: TyVarSet -> TcThetaType -> TcThetaType
pickCapturedPreds :: TyVarSet -> TcThetaType -> TcThetaType
immSuperClasses :: Class -> [Type] -> [PredType]
boxEqPred :: EqRel -> Type -> Type -> Maybe (Class, [Type])
isImprovementPred :: PredType -> Bool

-- | Finds outermost type-family applications occurring in a type, after
--   expanding synonyms. In the list (F, tys) that is returned we guarantee
--   that tys matches F's arity. For example, given type family F a :: *
--   -&gt; * (arity 1) calling tcTyFamInsts on (Maybe (F Int Bool) will
--   return (F, [Int]), not (F, [Int,Bool])
--   
--   This is important for its use in deciding termination of type
--   instances (see #11581). E.g. type instance G [Int] = ...(F Int &lt;big
--   type&gt;)... we don't need to take &lt;big type&gt; into account when
--   asking if the calls on the RHS are smaller than the LHS
tcTyFamInsts :: Type -> [(TyCon, [Type])]

-- | Like <a>tcTyFamInsts</a>, except that the output records whether the
--   type family and its arguments occur as an <i>invisible</i> argument in
--   some type application. This information is useful because it helps GHC
--   know when to turn on <tt>-fprint-explicit-kinds</tt> during error
--   reporting so that users can actually see the type family being
--   mentioned.
--   
--   As an example, consider:
--   
--   <pre>
--   class C a
--   data T (a :: k)
--   type family F a :: k
--   instance C (T @(F Int) (F Bool))
--   </pre>
--   
--   There are two occurrences of the type family <tt>F</tt> in that
--   <tt>C</tt> instance, so <tt><a>tcTyFamInstsAndVis</a> (C (T @(F Int)
--   (F Bool)))</tt> will return:
--   
--   <pre>
--   [ (<a>True</a>,  F, [Int])
--   , (<a>False</a>, F, [Bool]) ]
--   </pre>
--   
--   <tt>F Int</tt> is paired with <a>True</a> since it appears as an
--   <i>invisible</i> argument to <tt>C</tt>, whereas <tt>F Bool</tt> is
--   paired with <a>False</a> since it appears an a <i>visible</i> argument
--   to <tt>C</tt>.
--   
--   See also <tt>Note [Kind arguments in error messages]</tt> in
--   <a>GHC.Tc.Errors</a>.
tcTyFamInstsAndVis :: Type -> [(Bool, TyCon, [Type])]

-- | In an application of a <a>TyCon</a> to some arguments, find the
--   outermost occurrences of type family applications within the
--   arguments. This function will not consider the <a>TyCon</a> itself
--   when checking for type family applications.
--   
--   See <a>tcTyFamInstsAndVis</a> for more details on how this works (as
--   this function is called inside of <a>tcTyFamInstsAndVis</a>).
tcTyConAppTyFamInstsAndVis :: TyCon -> [Type] -> [(Bool, TyCon, [Type])]

-- | Check that a type does not contain any type family applications.
isTyFamFree :: Type -> Bool
exactTyCoVarsOfType :: Type -> TyCoVarSet
exactTyCoVarsOfTypes :: [Type] -> TyCoVarSet
anyRewritableTyVar :: Bool -> EqRel -> (EqRel -> TcTyVar -> Bool) -> TcType -> Bool
anyRewritableTyFamApp :: EqRel -> (EqRel -> TyCon -> [TcType] -> Bool) -> TcType -> Bool
anyRewritableCanEqLHS :: EqRel -> (EqRel -> TcTyVar -> Bool) -> (EqRel -> TyCon -> [TcType] -> Bool) -> TcType -> Bool
isFFIArgumentTy :: DynFlags -> Safety -> Type -> Validity
isFFIImportResultTy :: DynFlags -> Type -> Validity
isFFIExportResultTy :: Type -> Validity
isFFIExternalTy :: Type -> Validity
isFFIDynTy :: Type -> Type -> Validity
isFFIPrimArgumentTy :: DynFlags -> Type -> Validity
isFFIPrimResultTy :: DynFlags -> Type -> Validity
isFFILabelTy :: Type -> Validity
isFFITy :: Type -> Bool
isFunPtrTy :: Type -> Bool
tcSplitIOType_maybe :: Type -> Maybe (TyCon, Type)

-- | The key type representing kinds in the compiler.
type Kind = Type
tcTypeKind :: HasDebugCallStack => Type -> Kind
liftedTypeKind :: Kind
constraintKind :: Kind

-- | This version considers Constraint to be the same as *. Returns True if
--   the argument is equivalent to Type/Constraint and False otherwise. See
--   Note [Kind Constraint and kind Type]
isLiftedTypeKind :: Kind -> Bool

-- | Returns True if the kind classifies unlifted types (like 'Int#') and
--   False otherwise. Note that this returns False for levity-polymorphic
--   kinds, which may be specialized to a kind that classifies unlifted
--   types.
isUnliftedTypeKind :: Kind -> Bool

-- | Does this classify a type allowed to have values? Responds True to
--   things like *, #, TYPE Lifted, TYPE v, Constraint.
--   
--   True of any sub-kind of OpenTypeKind
classifiesTypeWithValues :: Kind -> Bool
data Type

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]

-- | A <a>TyCoBinder</a> represents an argument to a function. TyCoBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [TyCoBinders]
data TyCoBinder

-- | Argument Flag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, TyCoVarBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ArgFlag
Invisible :: Specificity -> ArgFlag
Required :: ArgFlag
pattern Specified :: ArgFlag
pattern Inferred :: ArgFlag

-- | The non-dependent version of <a>ArgFlag</a>. See Note [AnonArgFlag]
--   Appears here partly so that it's together with its friends ArgFlag and
--   ForallVisFlag, but also because it is used in IfaceType, rather early
--   in the compilation chain
data AnonArgFlag

-- | Used for <tt>(-&gt;)</tt>: an ordinary non-dependent arrow. The
--   argument is visible in source code.
VisArg :: AnonArgFlag

-- | Used for <tt>(=&gt;)</tt>: a non-dependent predicate arrow. The
--   argument is invisible in source code.
InvisArg :: AnonArgFlag

-- | Like <tt>mkTyCoForAllTy</tt>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: TyCoVar -> ArgFlag -> Type -> Type

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [TyCoVarBinder] -> Type -> Type

-- | Wraps foralls over the type using the provided <a>InvisTVBinder</a>s
--   from left to right
mkInvisForAllTys :: [InvisTVBinder] -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Inferred</a>, a common case
mkTyCoInvForAllTys :: [TyCoVar] -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTys :: [TyVar] -> Type -> Type

-- | Make a dependent forall over an <a>Inferred</a> variable
mkTyCoInvForAllTy :: TyCoVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTy</a>, but tv should be a tyvar
mkInfForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTys</a>, but tvs should be a list of tyvar
mkInfForAllTys :: [TyVar] -> Type -> Type
mkVisFunTy :: Mult -> Type -> Type -> Type
infixr 3 `mkVisFunTy`

-- | Make nested arrow types
mkVisFunTys :: [Scaled Type] -> Type -> Type
mkInvisFunTy :: Mult -> Type -> Type -> Type
infixr 3 `mkInvisFunTy`
mkInvisFunTyMany :: Type -> Type -> Type
infixr 3 `mkInvisFunTyMany`

-- | Special, common, case: Arrow type with mult Many
mkVisFunTyMany :: Type -> Type -> Type
infixr 3 `mkVisFunTyMany`
mkVisFunTysMany :: [Type] -> Type -> Type
mkInvisFunTysMany :: [Type] -> Type -> Type

-- | A key function: builds a <a>TyConApp</a> or <a>FunTy</a> as
--   appropriate to its arguments. Applies its arguments to the constructor
--   from left to right.
mkTyConApp :: TyCon -> [Type] -> Type

-- | Applies a type to another, as in e.g. <tt>k a</tt>
mkAppTy :: Type -> Type -> Type
mkAppTys :: Type -> [Type] -> Type

-- | Create the plain type constructor type which has been applied to no
--   type arguments at all.
mkTyConTy :: TyCon -> Type
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]
mkTyCoVarTy :: TyCoVar -> Type
mkTyCoVarTys :: [TyCoVar] -> [Type]
isClassPred :: PredType -> Bool
isEqPrimPred :: PredType -> Bool
isIPLikePred :: Type -> Bool
isEqPred :: PredType -> Bool
isEqPredClass :: Class -> Bool
mkClassPred :: Class -> [Type] -> PredType
tcSplitDFunTy :: Type -> ([TyVar], [Type], Class, [Type])
tcSplitDFunHead :: Type -> (Class, [Type])
tcSplitMethodTy :: Type -> ([TyVar], PredType, Type)

-- | Is a tyvar of type <a>RuntimeRep</a>?
isRuntimeRepVar :: TyVar -> Bool

-- | Tests whether the given kind (which should look like <tt>TYPE x</tt>)
--   is something other than a constructor tree (that is, constructors at
--   every node). E.g. True of TYPE k, TYPE (F Int) False of TYPE
--   'LiftedRep
isKindLevPoly :: Kind -> Bool

-- | Does this binder bind a visible argument?
isVisibleBinder :: TyCoBinder -> Bool

-- | Does this binder bind an invisible argument?
isInvisibleBinder :: TyCoBinder -> Bool

-- | Type &amp; coercion substitution
--   
--   The following invariants must hold of a <a>TCvSubst</a>:
--   
--   <ol>
--   <li>The in-scope set is needed <i>only</i> to guide the generation of
--   fresh uniques</li>
--   <li>In particular, the <i>kind</i> of the type variables in the
--   in-scope set is not relevant</li>
--   <li>The substitution is only applied ONCE! This is because in general
--   such application will not reach a fixed point.</li>
--   </ol>
data TCvSubst
TCvSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> TCvSubst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type
emptyTCvSubst :: TCvSubst
mkEmptyTCvSubst :: InScopeSet -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
zipTvSubst :: HasDebugCallStack => [TyVar] -> [Type] -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
mkTvSubstPrs :: [(TyVar, Type)] -> TCvSubst
notElemTCvSubst :: Var -> TCvSubst -> Bool
unionTCvSubst :: TCvSubst -> TCvSubst -> TCvSubst
getTvSubstEnv :: TCvSubst -> TvSubstEnv
setTvSubstEnv :: TCvSubst -> TvSubstEnv -> TCvSubst
getTCvInScope :: TCvSubst -> InScopeSet
extendTCvInScope :: TCvSubst -> Var -> TCvSubst
extendTCvInScopeList :: TCvSubst -> [Var] -> TCvSubst
extendTCvInScopeSet :: TCvSubst -> VarSet -> TCvSubst
extendTvSubstAndInScope :: TCvSubst -> TyVar -> Type -> TCvSubst
lookupTyVar :: TCvSubst -> TyVar -> Maybe Type
extendTCvSubst :: TCvSubst -> TyCoVar -> Type -> TCvSubst
substTyVarBndr :: HasCallStack => TCvSubst -> TyVar -> (TCvSubst, TyVar)
extendTvSubst :: TCvSubst -> TyVar -> Type -> TCvSubst
isInScope :: Var -> TCvSubst -> Bool
mkTCvSubst :: InScopeSet -> (TvSubstEnv, CvSubstEnv) -> TCvSubst

-- | Make a TCvSubst with specified tyvar subst and empty covar subst
mkTvSubst :: InScopeSet -> TvSubstEnv -> TCvSubst
zipTyEnv :: HasDebugCallStack => [TyVar] -> [Type] -> TvSubstEnv
zipCoEnv :: HasDebugCallStack => [CoVar] -> [Coercion] -> CvSubstEnv

-- | Substitute within a <a>Type</a> The substitution has to satisfy the
--   invariants described in Note [The substitution invariant].
substTy :: HasCallStack => TCvSubst -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasCallStack => TCvSubst -> [Type] -> [Type]
substScaledTys :: HasCallStack => TCvSubst -> [Scaled Type] -> [Scaled Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Substitute covars within a type
substTyWithCoVars :: [CoVar] -> [Coercion] -> Type -> Type

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: TCvSubst -> Type -> Type

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: TCvSubst -> Type -> Type

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: TCvSubst -> [Type] -> [Type]
substScaledTyUnchecked :: HasCallStack => TCvSubst -> Scaled Type -> Scaled Type

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: TCvSubst -> ThetaType -> ThetaType

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: TCvSubst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasCallStack => TCvSubst -> ThetaType -> ThetaType

-- | See <a>Type#type_classification</a> for what an unlifted type is.
--   Panics on levity polymorphic types; See <a>mightBeUnliftedType</a> for
--   a more approximate predicate that behaves better in the presence of
--   levity polymorphism.
isUnliftedType :: HasDebugCallStack => Type -> Bool
isUnboxedTupleType :: Type -> Bool

-- | Returns true of types that are opaque to Haskell.
isPrimitiveType :: Type -> Bool

-- | Gives the typechecker view of a type. This unwraps synonyms but leaves
--   <tt>Constraint</tt> alone. c.f. <a>coreView</a>, which turns
--   <tt>Constraint</tt> into <a>Type</a>. Returns <a>Nothing</a> if no
--   unwrapping happens. See also Note [coreView vs tcView]
tcView :: Type -> Maybe Type

-- | This function strips off the <i>top layer only</i> of a type synonym
--   application (if any) its underlying representation type. Returns
--   <a>Nothing</a> if there is nothing to look through. This function
--   considers <tt>Constraint</tt> to be a synonym of <tt>Type</tt>.
--   
--   By being non-recursive and inlined, this case analysis gets
--   efficiently joined onto the case analysis that the caller is already
--   doing
coreView :: Type -> Maybe Type
tyCoVarsOfType :: Type -> TyCoVarSet
tyCoVarsOfTypes :: [Type] -> TyCoVarSet
closeOverKinds :: TyCoVarSet -> TyCoVarSet

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in <a>GHC.Utils.FV</a>.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in <a>GHC.Utils.FV</a> for explanation.
tyCoFVsOfType :: Type -> FV
tyCoFVsOfTypes :: [Type] -> FV

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet

-- | Returns free variables of types, including kind variables as a
--   deterministic set. For type synonyms it does <i>not</i> expand the
--   synonym.
tyCoVarsOfTypesDSet :: [Type] -> DTyCoVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in
--   deterministic order. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeList :: Type -> [TyCoVar]

-- | Returns free variables of types, including kind variables as a
--   deterministically ordered list. For type synonyms it does <i>not</i>
--   expand the synonym.
tyCoVarsOfTypesList :: [Type] -> [TyCoVar]
noFreeVarsOfType :: Type -> Bool
pprKind :: Kind -> SDoc
pprParendKind :: Kind -> SDoc
pprSigmaType :: Type -> SDoc
pprType :: Type -> SDoc
pprParendType :: Type -> SDoc
pprTypeApp :: TyCon -> [Type] -> SDoc
pprTheta :: ThetaType -> SDoc
pprParendTheta :: ThetaType -> SDoc
pprThetaArrowTy :: ThetaType -> SDoc
pprClassPred :: Class -> [Type] -> SDoc
pprTCvBndr :: TyCoVarBinder -> SDoc
pprTCvBndrs :: [TyCoVarBinder] -> SDoc
type TypeSize = IntWithInf
sizeType :: Type -> TypeSize
sizeTypes :: [Type] -> TypeSize

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in <a>GHC.Rename.HsType</a>
scopedSort :: [TyCoVar] -> [TyCoVar]

-- | For every arg a tycon can take, the returned list says True if the
--   argument is taken visibly, and False otherwise. Ends with an infinite
--   tail of Trues to allow for oversaturation.
tcTyConVisibilities :: TyCon -> [Bool]

-- | If the tycon is applied to the types, is the next argument visible?
isNextTyConArgVisible :: TyCon -> [Type] -> Bool

-- | Should this type be applied to a visible argument?
isNextArgVisible :: TcType -> Bool
instance GHC.Classes.Ord GHC.Tc.Utils.TcType.TcLevel
instance GHC.Classes.Eq GHC.Tc.Utils.TcType.TcLevel
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.ExpType
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.InferResult
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.TcTyVarDetails
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.TcLevel
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.MetaInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.MetaDetails

module GHC.Utils.Error
data Validity

-- | Everything is fine
IsValid :: Validity

-- | A problem, and some indication of why
NotValid :: SDoc -> Validity
andValid :: Validity -> Validity -> Validity

-- | If they aren't all valid, return the first
allValid :: [Validity] -> Validity
isValid :: Validity -> Bool
getInvalids :: [Validity] -> [SDoc]
orValid :: Validity -> Validity -> Validity
data Severity
SevOutput :: Severity
SevFatal :: Severity
SevInteractive :: Severity

-- | Log message intended for compiler developers No file/line/column stuff
SevDump :: Severity

-- | Log messages intended for end users. No file/line/column stuff.
SevInfo :: Severity
SevWarning :: Severity

-- | SevWarning and SevError are used for warnings and errors o The message
--   has a file/line/column heading, plus "warning:" or "error:", added by
--   mkLocMessags o Output is intended for end users
SevError :: Severity
type WarnMsg = MsgEnvelope DecoratedSDoc

-- | An envelope for GHC's facts about a running program, parameterised
--   over the <i>domain-specific</i> (i.e. parsing, typecheck-renaming,
--   etc) diagnostics.
--   
--   To say things differently, GHC emits <i>diagnostics</i> about the
--   running program, each of which is wrapped into a <a>MsgEnvelope</a>
--   that carries specific information like where the error happened, its
--   severity, etc. Finally, multiple <a>MsgEnvelope</a>s are aggregated
--   into <a>Messages</a> that are returned to the user.
data MsgEnvelope e
MsgEnvelope :: SrcSpan -> PrintUnqualified -> e -> Severity -> WarnReason -> MsgEnvelope e

-- | The SrcSpan is used for sorting errors into line-number order
[errMsgSpan] :: MsgEnvelope e -> SrcSpan
[errMsgContext] :: MsgEnvelope e -> PrintUnqualified
[errMsgDiagnostic] :: MsgEnvelope e -> e
[errMsgSeverity] :: MsgEnvelope e -> Severity
[errMsgReason] :: MsgEnvelope e -> WarnReason

-- | Represents a pretty-printable document.
--   
--   To display an <a>SDoc</a>, use <a>printSDoc</a>, <a>printSDocLn</a>,
--   <a>bufLeftRenderSDoc</a>, or <a>renderWithContext</a>. Avoid calling
--   <a>runSDoc</a> directly as it breaks the abstraction layer.
data SDoc

-- | A <a>DecoratedSDoc</a> is isomorphic to a '[SDoc]' but it carries the
--   invariant that the input '[SDoc]' needs to be rendered
--   <i>decorated</i> into its final form, where the typical case would be
--   adding bullets between each elements of the list. The type of
--   decoration depends on the formatting function used, but in practice
--   GHC uses the <tt>formatBulleted</tt>.
data DecoratedSDoc

-- | A collection of messages emitted by GHC during error reporting. A
--   diagnostic message is typically a warning or an error. See Note
--   [Messages].
data Messages e
type ErrorMessages = Bag (MsgEnvelope DecoratedSDoc)
type WarningMessages = Bag (MsgEnvelope DecoratedSDoc)

-- | Joins two collections of messages together.
unionMessages :: Messages e -> Messages e -> Messages e
errorsFound :: Messages e -> Bool
isEmptyMessages :: Messages e -> Bool
pprMessageBag :: Bag SDoc -> SDoc
pprMsgEnvelopeBagWithLoc :: Bag (MsgEnvelope DecoratedSDoc) -> [SDoc]
pprLocMsgEnvelope :: RenderableDiagnostic e => MsgEnvelope e -> SDoc

-- | Formats the input list of structured document, where each element of
--   the list gets a bullet.
formatBulleted :: SDocContext -> DecoratedSDoc -> SDoc
emptyMessages :: Messages e

-- | Creates a new <a>DecoratedSDoc</a> out of a list of <a>SDoc</a>.
mkDecorated :: [SDoc] -> DecoratedSDoc

-- | Make an unannotated error message with location info.
mkLocMessage :: Severity -> SrcSpan -> SDoc -> SDoc

-- | Make a possibly annotated error message with location info.
mkLocMessageAnn :: Maybe String -> Severity -> SrcSpan -> SDoc -> SDoc
makeIntoWarning :: WarnReason -> MsgEnvelope e -> MsgEnvelope e

-- | A short (one-line) error message
mkMsgEnvelope :: SrcSpan -> PrintUnqualified -> SDoc -> MsgEnvelope DecoratedSDoc

-- | Variant that doesn't care about qualified/unqualified names
mkPlainMsgEnvelope :: SrcSpan -> SDoc -> MsgEnvelope DecoratedSDoc
mkErr :: SrcSpan -> PrintUnqualified -> e -> MsgEnvelope e

-- | A long (multi-line) error message
mkLongMsgEnvelope :: SrcSpan -> PrintUnqualified -> SDoc -> SDoc -> MsgEnvelope DecoratedSDoc

-- | A short (one-line) error message
mkWarnMsg :: SrcSpan -> PrintUnqualified -> SDoc -> MsgEnvelope DecoratedSDoc

-- | Variant that doesn't care about qualified/unqualified names
mkPlainWarnMsg :: SrcSpan -> SDoc -> MsgEnvelope DecoratedSDoc

-- | A long (multi-line) error message
mkLongWarnMsg :: SrcSpan -> PrintUnqualified -> SDoc -> SDoc -> MsgEnvelope DecoratedSDoc
doIfSet :: Bool -> IO () -> IO ()
doIfSet_dyn :: DynFlags -> GeneralFlag -> IO () -> IO ()
getCaretDiagnostic :: Severity -> SrcSpan -> IO SDoc
putMsg :: Logger -> DynFlags -> SDoc -> IO ()
printInfoForUser :: Logger -> DynFlags -> PrintUnqualified -> SDoc -> IO ()
printOutputForUser :: Logger -> DynFlags -> PrintUnqualified -> SDoc -> IO ()
logInfo :: Logger -> DynFlags -> SDoc -> IO ()

-- | Like <a>logInfo</a> but with <a>SevOutput</a> rather then
--   <a>SevInfo</a>
logOutput :: Logger -> DynFlags -> SDoc -> IO ()
errorMsg :: Logger -> DynFlags -> SDoc -> IO ()
warningMsg :: Logger -> DynFlags -> SDoc -> IO ()
fatalErrorMsg :: Logger -> DynFlags -> SDoc -> IO ()
fatalErrorMsg'' :: FatalMessager -> String -> IO ()
compilationProgressMsg :: Logger -> DynFlags -> SDoc -> IO ()
showPass :: Logger -> DynFlags -> String -> IO ()

-- | Time a compilation phase.
--   
--   When timings are enabled (e.g. with the <tt>-v2</tt> flag), the
--   allocations and CPU time used by the phase will be reported to stderr.
--   Consider a typical usage: <tt>withTiming getDynFlags (text "simplify")
--   force PrintTimings pass</tt>. When timings are enabled the following
--   costs are included in the produced accounting,
--   
--   <ul>
--   <li>The cost of executing <tt>pass</tt> to a result <tt>r</tt> in
--   WHNF</li>
--   <li>The cost of evaluating <tt>force r</tt> to WHNF (e.g.
--   <tt>()</tt>)</li>
--   </ul>
--   
--   The choice of the <tt>force</tt> function depends upon the amount of
--   forcing desired; the goal here is to ensure that the cost of
--   evaluating the result is, to the greatest extent possible, included in
--   the accounting provided by <a>withTiming</a>. Often the pass already
--   sufficiently forces its result during construction; in this case
--   <tt>const ()</tt> is a reasonable choice. In other cases, it is
--   necessary to evaluate the result to normal form, in which case
--   something like <tt>Control.DeepSeq.rnf</tt> is appropriate.
--   
--   To avoid adversely affecting compiler performance when timings are not
--   requested, the result is only forced when timings are enabled.
--   
--   See Note [withTiming] for more.
withTiming :: MonadIO m => Logger -> DynFlags -> SDoc -> (a -> ()) -> m a -> m a

-- | Same as <a>withTiming</a>, but doesn't print timings in the console
--   (when given <tt>-vN</tt>, <tt>N &gt;= 2</tt> or
--   <tt>-ddump-timings</tt>).
--   
--   See Note [withTiming] for more.
withTimingSilent :: MonadIO m => Logger -> DynFlags -> SDoc -> (a -> ()) -> m a -> m a
debugTraceMsg :: Logger -> DynFlags -> Int -> SDoc -> IO ()
ghcExit :: Logger -> DynFlags -> Int -> IO ()
prettyPrintGhcErrors :: ExceptionMonad m => DynFlags -> m a -> m a
traceCmd :: Logger -> DynFlags -> String -> String -> IO a -> IO a
sortMsgBag :: Maybe DynFlags -> Bag (MsgEnvelope e) -> [MsgEnvelope e]
instance GHC.Show.Show GHC.Utils.Error.PrintTimings
instance GHC.Classes.Eq GHC.Utils.Error.PrintTimings

module GHC.Types.Name.Set
type NameSet = UniqSet Name
emptyNameSet :: NameSet
unitNameSet :: Name -> NameSet
mkNameSet :: [Name] -> NameSet
unionNameSet :: NameSet -> NameSet -> NameSet
unionNameSets :: [NameSet] -> NameSet
minusNameSet :: NameSet -> NameSet -> NameSet
elemNameSet :: Name -> NameSet -> Bool
extendNameSet :: NameSet -> Name -> NameSet
extendNameSetList :: NameSet -> [Name] -> NameSet
delFromNameSet :: NameSet -> Name -> NameSet
delListFromNameSet :: NameSet -> [Name] -> NameSet
isEmptyNameSet :: NameSet -> Bool
filterNameSet :: (Name -> Bool) -> NameSet -> NameSet
intersectsNameSet :: NameSet -> NameSet -> Bool

-- | True if there is a non-empty intersection. <tt>s1
--   <a>intersectsNameSet</a> s2</tt> doesn't compute <tt>s2</tt> if
--   <tt>s1</tt> is empty
disjointNameSet :: NameSet -> NameSet -> Bool
intersectNameSet :: NameSet -> NameSet -> NameSet
nameSetAny :: (Name -> Bool) -> NameSet -> Bool
nameSetAll :: (Name -> Bool) -> NameSet -> Bool

-- | Get the elements of a NameSet with some stable ordering. This only
--   works for Names that originate in the source code or have been tidied.
--   See Note [Deterministic UniqFM] to learn about nondeterminism
nameSetElemsStable :: NameSet -> [Name]
type FreeVars = NameSet
isEmptyFVs :: NameSet -> Bool
emptyFVs :: FreeVars
plusFVs :: [FreeVars] -> FreeVars
plusFV :: FreeVars -> FreeVars -> FreeVars
mkFVs :: [Name] -> FreeVars
addOneFV :: FreeVars -> Name -> FreeVars
unitFV :: Name -> FreeVars
delFV :: Name -> FreeVars -> FreeVars
delFVs :: [Name] -> FreeVars -> FreeVars
intersectFVs :: FreeVars -> FreeVars -> FreeVars

-- | A set of names that are defined somewhere
type Defs = NameSet

-- | A set of names that are used somewhere
type Uses = NameSet

-- | <tt>(Just ds, us) =&gt;</tt> The use of any member of the <tt>ds</tt>
--   implies that all the <tt>us</tt> are used too. Also, <tt>us</tt> may
--   mention <tt>ds</tt>.
--   
--   <tt>Nothing =&gt;</tt> Nothing is defined in this group, but
--   nevertheless all the uses are essential. Used for instance
--   declarations, for example
type DefUse = (Maybe Defs, Uses)

-- | A number of <a>DefUse</a>s in dependency order: earlier <a>Defs</a>
--   scope over later <a>Uses</a> In a single (def, use) pair, the defs
--   also scope over the uses
type DefUses = OrdList DefUse
emptyDUs :: DefUses
usesOnly :: Uses -> DefUses
mkDUs :: [(Defs, Uses)] -> DefUses
plusDU :: DefUses -> DefUses -> DefUses

-- | Given some <a>DefUses</a> and some <a>Uses</a>, find all the uses,
--   transitively. The result is a superset of the input <a>Uses</a>; and
--   includes things defined in the input <a>DefUses</a> (but only if they
--   are used)
findUses :: DefUses -> Uses -> Uses
duDefs :: DefUses -> Defs

-- | Collect all <a>Uses</a>, regardless of whether the group is itself
--   used, but remove <a>Defs</a> on the way
duUses :: DefUses -> Uses

-- | Just like <a>duUses</a>, but <a>Defs</a> are not eliminated from the
--   <a>Uses</a> returned
allUses :: DefUses -> Uses

-- | <tt>Id</tt>s which have no CAF references. This is a result of
--   analysis of C--. It is always safe to use an empty <a>NonCaffySet</a>.
--   TODO Refer to Note.
newtype NonCaffySet
NonCaffySet :: NameSet -> NonCaffySet
instance GHC.Base.Monoid GHC.Types.Name.Set.NonCaffySet
instance GHC.Base.Semigroup GHC.Types.Name.Set.NonCaffySet


-- | Provide trees (of instructions), so that lists of instructions can be
--   appended in linear time.
module GHC.Data.OrdList
data OrdList a
pattern NilOL :: OrdList a
pattern ConsOL :: a -> OrdList a -> OrdList a
pattern SnocOL :: OrdList a -> a -> OrdList a
nilOL :: OrdList a
isNilOL :: OrdList a -> Bool
unitOL :: a -> OrdList a
appOL :: OrdList a -> OrdList a -> OrdList a
infixl 5 `appOL`
consOL :: a -> OrdList a -> OrdList a
infixr 5 `consOL`
snocOL :: OrdList a -> a -> OrdList a
infixl 5 `snocOL`
concatOL :: [OrdList a] -> OrdList a
lastOL :: OrdList a -> a
headOL :: OrdList a -> a
mapOL :: (a -> b) -> OrdList a -> OrdList b
mapOL' :: (a -> b) -> OrdList a -> OrdList b
fromOL :: OrdList a -> [a]
toOL :: [a] -> OrdList a
foldrOL :: (a -> b -> b) -> b -> OrdList a -> b

-- | Strict left fold.
foldlOL :: (b -> a -> b) -> b -> OrdList a -> b
reverseOL :: OrdList a -> OrdList a
fromOLReverse :: OrdList a -> [a]

-- | Compare not only the values but also the structure of two lists
strictlyEqOL :: Eq a => OrdList a -> OrdList a -> Bool

-- | Compare not only the values but also the structure of two lists
strictlyOrdOL :: Ord a => OrdList a -> OrdList a -> Ordering
instance GHC.Base.Functor GHC.Data.OrdList.OrdList
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Data.OrdList.OrdList a)
instance GHC.Base.Semigroup (GHC.Data.OrdList.OrdList a)
instance GHC.Base.Monoid (GHC.Data.OrdList.OrdList a)
instance Data.Foldable.Foldable GHC.Data.OrdList.OrdList
instance Data.Traversable.Traversable GHC.Data.OrdList.OrdList


-- | Substitution into types and coercions.
module GHC.Core.TyCo.Subst

-- | Type &amp; coercion substitution
--   
--   The following invariants must hold of a <a>TCvSubst</a>:
--   
--   <ol>
--   <li>The in-scope set is needed <i>only</i> to guide the generation of
--   fresh uniques</li>
--   <li>In particular, the <i>kind</i> of the type variables in the
--   in-scope set is not relevant</li>
--   <li>The substitution is only applied ONCE! This is because in general
--   such application will not reach a fixed point.</li>
--   </ol>
data TCvSubst
TCvSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> TCvSubst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | A substitution of <a>Coercion</a>s for <a>CoVar</a>s
type CvSubstEnv = CoVarEnv Coercion
emptyTvSubstEnv :: TvSubstEnv
emptyCvSubstEnv :: CvSubstEnv

-- | <tt>(compose env1 env2)(x)</tt> is <tt>env1(env2(x))</tt>; i.e. apply
--   <tt>env2</tt> then <tt>env1</tt>. It assumes that both are idempotent.
--   Typically, <tt>env1</tt> is the refinement to a base substitution
--   <tt>env2</tt>
composeTCvSubstEnv :: InScopeSet -> (TvSubstEnv, CvSubstEnv) -> (TvSubstEnv, CvSubstEnv) -> (TvSubstEnv, CvSubstEnv)

-- | Composes two substitutions, applying the second one provided first,
--   like in function composition.
composeTCvSubst :: TCvSubst -> TCvSubst -> TCvSubst
emptyTCvSubst :: TCvSubst
mkEmptyTCvSubst :: InScopeSet -> TCvSubst
isEmptyTCvSubst :: TCvSubst -> Bool
mkTCvSubst :: InScopeSet -> (TvSubstEnv, CvSubstEnv) -> TCvSubst

-- | Make a TCvSubst with specified tyvar subst and empty covar subst
mkTvSubst :: InScopeSet -> TvSubstEnv -> TCvSubst

-- | Make a TCvSubst with specified covar subst and empty tyvar subst
mkCvSubst :: InScopeSet -> CvSubstEnv -> TCvSubst
getTvSubstEnv :: TCvSubst -> TvSubstEnv
getCvSubstEnv :: TCvSubst -> CvSubstEnv
getTCvInScope :: TCvSubst -> InScopeSet

-- | Returns the free variables of the types in the range of a substitution
--   as a non-deterministic set.
getTCvSubstRangeFVs :: TCvSubst -> VarSet
isInScope :: Var -> TCvSubst -> Bool
elemTCvSubst :: Var -> TCvSubst -> Bool
notElemTCvSubst :: Var -> TCvSubst -> Bool
setTvSubstEnv :: TCvSubst -> TvSubstEnv -> TCvSubst
setCvSubstEnv :: TCvSubst -> CvSubstEnv -> TCvSubst
zapTCvSubst :: TCvSubst -> TCvSubst
extendTCvInScope :: TCvSubst -> Var -> TCvSubst
extendTCvInScopeList :: TCvSubst -> [Var] -> TCvSubst
extendTCvInScopeSet :: TCvSubst -> VarSet -> TCvSubst
extendTCvSubst :: TCvSubst -> TyCoVar -> Type -> TCvSubst
extendTCvSubstWithClone :: TCvSubst -> TyCoVar -> TyCoVar -> TCvSubst
extendCvSubst :: TCvSubst -> CoVar -> Coercion -> TCvSubst
extendCvSubstWithClone :: TCvSubst -> CoVar -> CoVar -> TCvSubst
extendTvSubst :: TCvSubst -> TyVar -> Type -> TCvSubst
extendTvSubstBinderAndInScope :: TCvSubst -> TyCoBinder -> Type -> TCvSubst
extendTvSubstWithClone :: TCvSubst -> TyVar -> TyVar -> TCvSubst
extendTvSubstList :: TCvSubst -> [Var] -> [Type] -> TCvSubst
extendTvSubstAndInScope :: TCvSubst -> TyVar -> Type -> TCvSubst
extendTCvSubstList :: TCvSubst -> [Var] -> [Type] -> TCvSubst
unionTCvSubst :: TCvSubst -> TCvSubst -> TCvSubst
zipTyEnv :: HasDebugCallStack => [TyVar] -> [Type] -> TvSubstEnv
zipCoEnv :: HasDebugCallStack => [CoVar] -> [Coercion] -> CvSubstEnv

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
zipTvSubst :: HasDebugCallStack => [TyVar] -> [Type] -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No TyVars, please!
zipCvSubst :: HasDebugCallStack => [CoVar] -> [Coercion] -> TCvSubst
zipTCvSubst :: HasDebugCallStack => [TyCoVar] -> [Type] -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
mkTvSubstPrs :: [(TyVar, Type)] -> TCvSubst

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Substitute covars within a type
substTyWithCoVars :: [CoVar] -> [Coercion] -> Type -> Type

-- | Type substitution, see <a>zipTvSubst</a>
substTysWith :: [TyVar] -> [Type] -> [Type] -> [Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTysWithCoVars :: [CoVar] -> [Coercion] -> [Type] -> [Type]

-- | Coercion substitution, see <a>zipTvSubst</a>
substCoWith :: HasCallStack => [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute within a <a>Type</a> The substitution has to satisfy the
--   invariants described in Note [The substitution invariant].
substTy :: HasCallStack => TCvSubst -> Type -> Type

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: TCvSubst -> Type -> Type
substScaledTy :: HasCallStack => TCvSubst -> Scaled Type -> Scaled Type

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: TCvSubst -> Type -> Type

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: TCvSubst -> [Type] -> [Type]
substScaledTysUnchecked :: TCvSubst -> [Scaled Type] -> [Scaled Type]

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: TCvSubst -> ThetaType -> ThetaType

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type
substScaledTyUnchecked :: HasCallStack => TCvSubst -> Scaled Type -> Scaled Type

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: TCvSubst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute tyvars within a type using a known <a>InScopeSet</a>.
--   Pre-condition: the <tt>in_scope</tt> set should satisfy Note [The
--   substitution invariant]; specifically it should include the free vars
--   of <tt>tys</tt>, and of <tt>ty</tt> minus the domain of the subst.
substTyWithInScope :: InScopeSet -> [TyVar] -> [Type] -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasCallStack => TCvSubst -> [Type] -> [Type]
substScaledTys :: HasCallStack => TCvSubst -> [Scaled Type] -> [Scaled Type]

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasCallStack => TCvSubst -> ThetaType -> ThetaType
lookupTyVar :: TCvSubst -> TyVar -> Maybe Type

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasCallStack => TCvSubst -> Coercion -> Coercion

-- | Substitute within several <a>Coercion</a>s The substitution has to
--   satisfy the invariants described in Note [The substitution invariant].
substCos :: HasCallStack => TCvSubst -> [Coercion] -> [Coercion]
substCoVar :: TCvSubst -> CoVar -> Coercion
substCoVars :: TCvSubst -> [CoVar] -> [Coercion]
lookupCoVar :: TCvSubst -> Var -> Maybe Coercion
cloneTyVarBndr :: TCvSubst -> TyVar -> Unique -> (TCvSubst, TyVar)
cloneTyVarBndrs :: TCvSubst -> [TyVar] -> UniqSupply -> (TCvSubst, [TyVar])
substVarBndr :: HasCallStack => TCvSubst -> TyCoVar -> (TCvSubst, TyCoVar)
substVarBndrs :: HasCallStack => TCvSubst -> [TyCoVar] -> (TCvSubst, [TyCoVar])
substTyVarBndr :: HasCallStack => TCvSubst -> TyVar -> (TCvSubst, TyVar)
substTyVarBndrs :: HasCallStack => TCvSubst -> [TyVar] -> (TCvSubst, [TyVar])
substCoVarBndr :: HasCallStack => TCvSubst -> CoVar -> (TCvSubst, CoVar)
substTyVar :: TCvSubst -> TyVar -> Type
substTyVars :: TCvSubst -> [TyVar] -> [Type]
substTyCoVars :: TCvSubst -> [TyCoVar] -> [Type]
substTyCoBndr :: TCvSubst -> TyCoBinder -> (TCvSubst, TyCoBinder)
substForAllCoBndr :: TCvSubst -> TyCoVar -> KindCoercion -> (TCvSubst, TyCoVar, Coercion)
substVarBndrUsing :: (TCvSubst -> Type -> Type) -> TCvSubst -> TyCoVar -> (TCvSubst, TyCoVar)
substForAllCoBndrUsing :: Bool -> (Coercion -> Coercion) -> TCvSubst -> TyCoVar -> KindCoercion -> (TCvSubst, TyCoVar, KindCoercion)

-- | This checks if the substitution satisfies the invariant from Note [The
--   substitution invariant].
checkValidSubst :: HasCallStack => TCvSubst -> [Type] -> [Coercion] -> a -> a

-- | When calling <a>substTy</a> it should be the case that the in-scope
--   set in the substitution is a superset of the free vars of the range of
--   the substitution. See also Note [The substitution invariant].
isValidTCvSubst :: TCvSubst -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Subst.TCvSubst


-- | Pretty-printing types and coercions.
module GHC.Core.TyCo.Ppr

-- | A general-purpose pretty-printing precedence type.
newtype PprPrec
PprPrec :: Int -> PprPrec
topPrec :: PprPrec
sigPrec :: PprPrec
opPrec :: PprPrec
funPrec :: PprPrec
appPrec :: PprPrec
maybeParen :: PprPrec -> PprPrec -> SDoc -> SDoc
pprType :: Type -> SDoc
pprParendType :: Type -> SDoc
pprTidiedType :: Type -> SDoc
pprPrecType :: PprPrec -> Type -> SDoc
pprPrecTypeX :: TidyEnv -> PprPrec -> Type -> SDoc
pprTypeApp :: TyCon -> [Type] -> SDoc
pprTCvBndr :: TyCoVarBinder -> SDoc
pprTCvBndrs :: [TyCoVarBinder] -> SDoc
pprSigmaType :: Type -> SDoc
pprTheta :: ThetaType -> SDoc
pprParendTheta :: ThetaType -> SDoc
pprForAll :: [TyCoVarBinder] -> SDoc

-- | Print a user-level forall; see <tt>Note [When to print foralls]</tt>
--   in <a>GHC.Iface.Type</a>.
pprUserForAll :: [TyCoVarBinder] -> SDoc
pprTyVar :: TyVar -> SDoc
pprTyVars :: [TyVar] -> SDoc
pprThetaArrowTy :: ThetaType -> SDoc
pprClassPred :: Class -> [Type] -> SDoc
pprKind :: Kind -> SDoc
pprParendKind :: Kind -> SDoc
pprTyLit :: TyLit -> SDoc
pprDataCons :: TyCon -> SDoc

-- | Display all kind information (with <tt>-fprint-explicit-kinds</tt>)
--   when the provided <a>Bool</a> argument is <a>True</a>. See <tt>Note
--   [Kind arguments in error messages]</tt> in <a>GHC.Tc.Errors</a>.
pprWithExplicitKindsWhen :: Bool -> SDoc -> SDoc

-- | This variant preserves any use of TYPE in a type, effectively locally
--   setting -fprint-explicit-runtime-reps.
pprWithTYPE :: Type -> SDoc

-- | Pretty prints a <a>TyCon</a>, using the family instance in case of a
--   representation tycon. For example:
--   
--   <pre>
--   data T [a] = ...
--   </pre>
--   
--   In that case we want to print <tt>T [a]</tt>, where <tt>T</tt> is the
--   family <a>TyCon</a>
pprSourceTyCon :: TyCon -> SDoc
pprCo :: Coercion -> SDoc
pprParendCo :: Coercion -> SDoc

-- | debugPprType is a simple pretty printer that prints a type without
--   going through IfaceType. It does not format as prettily as the normal
--   route, but it's much more direct, and that can be useful for
--   debugging. E.g. with -dppr-debug it prints the kind on type-variable
--   <i>occurrences</i> which the normal route fundamentally cannot do.
debugPprType :: Type -> SDoc


-- | Functions for converting Core things to interface file things.
module GHC.CoreToIface
toIfaceTvBndr :: TyVar -> IfaceTvBndr
toIfaceTvBndrs :: [TyVar] -> [IfaceTvBndr]
toIfaceIdBndr :: Id -> IfaceIdBndr
toIfaceBndr :: Var -> IfaceBndr
toIfaceForAllBndr :: VarBndr TyCoVar flag -> VarBndr IfaceBndr flag
toIfaceTyCoVarBinders :: [VarBndr Var vis] -> [VarBndr IfaceBndr vis]
toIfaceTyVar :: TyVar -> FastString
toIfaceType :: Type -> IfaceType
toIfaceTypeX :: VarSet -> Type -> IfaceType
toIfaceKind :: Type -> IfaceType
toIfaceTcArgs :: TyCon -> [Type] -> IfaceAppArgs
toIfaceTyCon :: TyCon -> IfaceTyCon
toIfaceTyCon_name :: Name -> IfaceTyCon
toIfaceTyLit :: TyLit -> IfaceTyLit
tidyToIfaceType :: TidyEnv -> Type -> IfaceType
tidyToIfaceContext :: TidyEnv -> ThetaType -> IfaceContext
tidyToIfaceTcArgs :: TidyEnv -> TyCon -> [Type] -> IfaceAppArgs
toIfaceCoercion :: Coercion -> IfaceCoercion
toIfaceCoercionX :: VarSet -> Coercion -> IfaceCoercion
patSynToIfaceDecl :: PatSyn -> IfaceDecl
toIfaceExpr :: CoreExpr -> IfaceExpr
toIfaceBang :: TidyEnv -> HsImplBang -> IfaceBang
toIfaceSrcBang :: HsSrcBang -> IfaceSrcBang
toIfaceLetBndr :: Id -> IfaceLetBndr
toIfaceIdDetails :: IdDetails -> IfaceIdDetails
toIfaceIdInfo :: IdInfo -> IfaceIdInfo
toIfUnfolding :: Bool -> Unfolding -> Maybe IfaceInfoItem
toIfaceTickish :: CoreTickish -> Maybe IfaceTickish
toIfaceBind :: Bind Id -> IfaceBinding
toIfaceAlt :: CoreAlt -> IfaceAlt
toIfaceCon :: AltCon -> IfaceConAlt
toIfaceApp :: Expr CoreBndr -> [Arg CoreBndr] -> IfaceExpr
toIfaceVar :: Id -> IfaceExpr
toIfaceLFInfo :: Name -> LambdaFormInfo -> IfaceLFInfo

module GHC.Types.Id.Make
mkDictFunId :: Name -> [TyVar] -> ThetaType -> Class -> [Type] -> Id
mkDictFunTy :: [TyVar] -> ThetaType -> Class -> [Type] -> Type
mkDictSelId :: Name -> Class -> Id
mkDictSelRhs :: Class -> Int -> CoreExpr
mkPrimOpId :: PrimOp -> Id
mkFCallId :: DynFlags -> Unique -> ForeignCall -> Type -> Id
unwrapNewTypeBody :: TyCon -> [Type] -> CoreExpr -> CoreExpr
wrapFamInstBody :: TyCon -> [Type] -> CoreExpr -> CoreExpr

-- | Data Constructor Boxer
newtype DataConBoxer
DCB :: ([Type] -> [Var] -> UniqSM ([Var], [CoreBind])) -> DataConBoxer
vanillaDataConBoxer :: DataConBoxer
mkDataConRep :: DynFlags -> FamInstEnvs -> Name -> Maybe [HsImplBang] -> DataCon -> UniqSM DataConRep
mkDataConWorkId :: Name -> DataCon -> Id
wiredInIds :: [Id]
ghcPrimIds :: [Id]
realWorldPrimId :: Id
voidPrimId :: Id
voidArgId :: Id
nullAddrId :: Id
seqId :: Id
lazyId :: Id
lazyIdKey :: Unique
coercionTokenId :: Id
magicDictId :: Id
coerceId :: Id
proxyHashId :: Id
noinlineId :: Id
noinlineIdName :: Name
coerceName :: Name
leftSectionName :: Name
rightSectionName :: Name


-- | Types for the Constructed Product Result lattice.
--   <a>GHC.Core.Opt.CprAnal</a> and <a>GHC.Core.Opt.WorkWrap.Utils</a> are
--   its primary customers via <a>idCprInfo</a>.
module GHC.Types.Cpr
data Cpr
pattern ConCpr :: ConTag -> [Cpr] -> Cpr
topCpr :: Cpr
botCpr :: Cpr
flatConCpr :: ConTag -> Cpr
asConCpr :: Cpr -> Maybe (ConTag, [Cpr])

-- | The abstract domain &lt;math&gt; from the original 'CPR for Haskell'
--   paper.
data CprType
CprType :: !Arity -> !Cpr -> CprType

-- | Number of value arguments the denoted expression eats before returning
--   the <a>ct_cpr</a>
[ct_arty] :: CprType -> !Arity

-- | <a>Cpr</a> eventually unleashed when applied to <a>ct_arty</a>
--   arguments
[ct_cpr] :: CprType -> !Cpr
topCprType :: CprType
botCprType :: CprType
flatConCprType :: ConTag -> CprType
lubCprType :: CprType -> CprType -> CprType
applyCprTy :: CprType -> Arity -> CprType
abstractCprTy :: CprType -> CprType
trimCprTy :: CprType -> CprType

-- | The result of <a>unpackConFieldsCpr</a>.
data UnpackConFieldsResult
AllFieldsSame :: !Cpr -> UnpackConFieldsResult
ForeachField :: ![Cpr] -> UnpackConFieldsResult

-- | Unpacks a <a>ConCpr</a>-shaped <a>Cpr</a> and returns the field
--   <a>Cpr</a>s wrapped in a <a>ForeachField</a>. Otherwise, it returns
--   <a>AllFieldsSame</a> with the appropriate <a>Cpr</a> to assume for
--   each field.
--   
--   The use of <a>UnpackConFieldsResult</a> allows O(1) space for the
--   common, non-<a>ConCpr</a> case.
unpackConFieldsCpr :: DataCon -> Cpr -> UnpackConFieldsResult

-- | The arity of the wrapped <a>CprType</a> is the arity at which it is
--   safe to unleash. See Note [Understanding DmdType and StrictSig] in
--   <a>GHC.Types.Demand</a>
newtype CprSig
CprSig :: CprType -> CprSig
[getCprSig] :: CprSig -> CprType
topCprSig :: CprSig
isTopCprSig :: CprSig -> Bool

-- | Turns a <a>CprType</a> computed for the particular <a>Arity</a> into a
--   <a>CprSig</a> unleashable at that arity. See Note [Understanding
--   DmdType and StrictSig] in <a>GHC.Types.Demand</a>
mkCprSigForArity :: Arity -> CprType -> CprSig
mkCprSig :: Arity -> Cpr -> CprSig
seqCprSig :: CprSig -> ()
instance GHC.Classes.Eq GHC.Types.Cpr.Cpr
instance GHC.Utils.Binary.Binary GHC.Types.Cpr.CprSig
instance GHC.Classes.Eq GHC.Types.Cpr.CprSig
instance GHC.Utils.Outputable.Outputable GHC.Types.Cpr.CprSig
instance GHC.Classes.Eq GHC.Types.Cpr.CprType
instance GHC.Utils.Outputable.Outputable GHC.Types.Cpr.CprType
instance GHC.Utils.Binary.Binary GHC.Types.Cpr.CprType
instance GHC.Utils.Outputable.Outputable GHC.Types.Cpr.Cpr
instance GHC.Utils.Binary.Binary GHC.Types.Cpr.Cpr

module GHC.Core.DataCon

-- | A data constructor
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnClose</a>,<a>AnnComma</a></li>
--   </ul>
data DataCon

-- | Data Constructor Representation See Note [Data constructor workers and
--   wrappers]
data DataConRep
NoDataConRep :: DataConRep
DCR :: Id -> DataConBoxer -> [Scaled Type] -> [StrictnessMark] -> [HsImplBang] -> DataConRep
[dcr_wrap_id] :: DataConRep -> Id
[dcr_boxer] :: DataConRep -> DataConBoxer
[dcr_arg_tys] :: DataConRep -> [Scaled Type]
[dcr_stricts] :: DataConRep -> [StrictnessMark]
[dcr_bangs] :: DataConRep -> [HsImplBang]

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie <tt>~</tt>
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {-# UNPACK #-} specified
SrcUnpack :: SrcUnpackedness

-- | {-# NOUNPACK #-} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness

-- | Haskell Source Bang
--   
--   Bangs on data constructor arguments as the user wrote them in the
--   source code.
--   
--   <tt>(HsSrcBang _ SrcUnpack SrcLazy)</tt> and <tt>(HsSrcBang _
--   SrcUnpack NoSrcStrict)</tt> (without StrictData) makes no sense, we
--   emit a warning (in checkValidDataCon) and treat it like <tt>(HsSrcBang
--   _ NoSrcUnpack SrcLazy)</tt>
data HsSrcBang
HsSrcBang :: SourceText -> SrcUnpackedness -> SrcStrictness -> HsSrcBang

-- | Haskell Implementation Bang
--   
--   Bangs of data constructor arguments as generated by the compiler after
--   consulting HsSrcBang, flags, etc.
data HsImplBang

-- | Lazy field, or one with an unlifted type
HsLazy :: HsImplBang

-- | Strict but not unpacked field
HsStrict :: HsImplBang

-- | Strict and unpacked field co :: arg-ty ~ product-ty HsBang
HsUnpack :: Maybe Coercion -> HsImplBang
data StrictnessMark
MarkedStrict :: StrictnessMark
NotMarkedStrict :: StrictnessMark

-- | A *one-index* constructor tag
--   
--   Type of the tags associated with each constructor possibility or
--   superclass selector
type ConTag = Int

-- | An <a>EqSpec</a> is a tyvar/type pair representing an equality made in
--   rejigging a GADT constructor
data EqSpec

-- | Make a non-dependent <a>EqSpec</a>
mkEqSpec :: TyVar -> Type -> EqSpec
eqSpecTyVar :: EqSpec -> TyVar
eqSpecType :: EqSpec -> Type
eqSpecPair :: EqSpec -> (TyVar, Type)
eqSpecPreds :: [EqSpec] -> ThetaType

-- | Substitute in an <a>EqSpec</a>. Precondition: if the LHS of the EqSpec
--   is mapped in the substitution, it is mapped to a type variable, not a
--   full type.
substEqSpec :: TCvSubst -> EqSpec -> EqSpec

-- | Filter out any <a>TyVar</a>s mentioned in an <a>EqSpec</a>.
filterEqSpec :: [EqSpec] -> [TyVar] -> [TyVar]

-- | Fields in an algebraic record type; see Note [FieldLabel].
data FieldLabel
FieldLabel :: FieldLabelString -> DuplicateRecordFields -> FieldSelectors -> Name -> FieldLabel

-- | User-visible label of the field
[flLabel] :: FieldLabel -> FieldLabelString

-- | Was <tt>DuplicateRecordFields</tt> on in the defining module for this
--   datatype?
[flHasDuplicateRecordFields] :: FieldLabel -> DuplicateRecordFields

-- | Was <tt>FieldSelectors</tt> enabled in the defining module for this
--   datatype? See Note [NoFieldSelectors] in GHC.Rename.Env
[flHasFieldSelector] :: FieldLabel -> FieldSelectors

-- | Record selector function
[flSelector] :: FieldLabel -> Name

-- | Field labels are just represented as strings; they are not necessarily
--   unique (even within a module)
type FieldLabelString = FastString

-- | Build a new data constructor
mkDataCon :: Name -> Bool -> TyConRepName -> [HsSrcBang] -> [FieldLabel] -> [TyVar] -> [TyCoVar] -> [InvisTVBinder] -> [EqSpec] -> KnotTied ThetaType -> [KnotTied (Scaled Type)] -> KnotTied Type -> RuntimeRepInfo -> KnotTied TyCon -> ConTag -> ThetaType -> Id -> DataConRep -> DataCon

-- | Tags are allocated from here for real constructors or for superclass
--   selectors
fIRST_TAG :: ConTag

-- | The representation type of the data constructor, i.e. the sort type
--   that will represent values of this type at runtime
dataConRepType :: DataCon -> Type

-- | Instantiate the universal tyvars of a data con, returning (
--   instantiated existentials , instantiated constraints including
--   dependent GADT equalities which are *also* listed in the instantiated
--   existentials , instantiated args)
dataConInstSig :: DataCon -> [Type] -> ([TyCoVar], ThetaType, [Type])

-- | The "full signature" of the <a>DataCon</a> returns, in order:
--   
--   1) The result of <a>dataConUnivTyVars</a>
--   
--   2) The result of <a>dataConExTyCoVars</a>
--   
--   3) The non-dependent GADT equalities. Dependent GADT equalities are
--   implied by coercion variables in return value (2).
--   
--   4) The other constraints of the data constructor type, excluding GADT
--   equalities
--   
--   5) The original argument types to the <a>DataCon</a> (i.e. before any
--   change of the representation of the type) with linearity annotations
--   
--   6) The original result type of the <a>DataCon</a>
dataConFullSig :: DataCon -> ([TyVar], [TyCoVar], [EqSpec], ThetaType, [Scaled Type], Type)

-- | The <a>Name</a> of the <a>DataCon</a>, giving it a unique, rooted
--   identification
dataConName :: DataCon -> Name

-- | The string <tt>package:module.name</tt> identifying a constructor,
--   which is attached to its info table and used by the GHCi debugger and
--   the heap profiler
dataConIdentity :: DataCon -> ByteString

-- | The tag used for ordering <a>DataCon</a>s
dataConTag :: DataCon -> ConTag
dataConTagZ :: DataCon -> ConTagZ

-- | The type constructor that we are building via this data constructor
dataConTyCon :: DataCon -> TyCon

-- | The original type constructor used in the definition of this data
--   constructor. In case of a data family instance, that will be the
--   family type constructor.
dataConOrigTyCon :: DataCon -> TyCon

-- | The user-declared type of the data constructor in the nice-to-read
--   form:
--   
--   <pre>
--   T :: forall a b. a -&gt; b -&gt; T [a]
--   </pre>
--   
--   rather than:
--   
--   <pre>
--   T :: forall a c. forall b. (c~[a]) =&gt; a -&gt; b -&gt; T c
--   </pre>
--   
--   The type variables are quantified in the order that the user wrote
--   them. See <tt>Note [DataCon user type variable binders]</tt>.
--   
--   NB: If the constructor is part of a data instance, the result type
--   mentions the family tycon, not the internal one.
dataConWrapperType :: DataCon -> Type
dataConNonlinearType :: DataCon -> Type
dataConDisplayType :: Bool -> DataCon -> Type

-- | The universally-quantified type variables of the constructor
dataConUnivTyVars :: DataCon -> [TyVar]

-- | The existentially-quantified type/coercion variables of the
--   constructor including dependent (kind-) GADT equalities
dataConExTyCoVars :: DataCon -> [TyCoVar]

-- | Both the universal and existential type/coercion variables of the
--   constructor
dataConUnivAndExTyCoVars :: DataCon -> [TyCoVar]

-- | The type variables of the constructor, in the order the user wrote
--   them
dataConUserTyVars :: DataCon -> [TyVar]

-- | <a>InvisTVBinder</a>s for the type variables of the constructor, in
--   the order the user wrote them
dataConUserTyVarBinders :: DataCon -> [InvisTVBinder]

-- | Equalities derived from the result type of the data constructor, as
--   written by the programmer in any GADT declaration. This includes *all*
--   GADT-like equalities, including those written in by hand by the
--   programmer.
dataConEqSpec :: DataCon -> [EqSpec]

-- | The *full* constraints on the constructor type, including dependent
--   GADT equalities.
dataConTheta :: DataCon -> ThetaType

-- | The "stupid theta" of the <a>DataCon</a>, such as <tt>data Eq a</tt>
--   in:
--   
--   <pre>
--   data Eq a =&gt; T a = ...
--   </pre>
dataConStupidTheta :: DataCon -> ThetaType

-- | Returns constraints in the wrapper type, other than those in the
--   dataConEqSpec
dataConOtherTheta :: DataCon -> ThetaType

-- | Finds the instantiated types of the arguments required to construct a
--   <a>DataCon</a> representation NB: these INCLUDE any dictionary args
--   but EXCLUDE the data-declaration context, which is discarded It's all
--   post-flattening etc; this is a representation type
dataConInstArgTys :: DataCon -> [Type] -> [Scaled Type]

-- | Returns the argument types of the wrapper, excluding all dictionary
--   arguments and without substituting for any type variables
dataConOrigArgTys :: DataCon -> [Scaled Type]
dataConOrigResTy :: DataCon -> Type

-- | Returns just the instantiated <i>value</i> argument types of a
--   <a>DataCon</a>, (excluding dictionary args)
dataConInstOrigArgTys :: DataCon -> [Type] -> [Scaled Type]

-- | Returns the arg types of the worker, including *all* non-dependent
--   evidence, after any flattening has been done and without substituting
--   for any type variables
dataConRepArgTys :: DataCon -> [Scaled Type]

-- | The labels for the fields of this particular <a>DataCon</a>
dataConFieldLabels :: DataCon -> [FieldLabel]

-- | Extract the type for any given labelled field of the <a>DataCon</a>
dataConFieldType :: DataCon -> FieldLabelString -> Type

-- | Extract the label and type for any given labelled field of the
--   <a>DataCon</a>, or return <a>Nothing</a> if the field does not belong
--   to it
dataConFieldType_maybe :: DataCon -> FieldLabelString -> Maybe (FieldLabel, Type)

-- | Strictness/unpack annotations, from user; or, for imported DataCons,
--   from the interface file The list is in one-to-one correspondence with
--   the arity of the <a>DataCon</a>
dataConSrcBangs :: DataCon -> [HsSrcBang]

-- | Source-level arity of the data constructor
dataConSourceArity :: DataCon -> Arity

-- | Gives the number of actual fields in the <i>representation</i> of the
--   data constructor. This may be more than appear in the source code; the
--   extra ones are the existentially quantified dictionaries
dataConRepArity :: DataCon -> Arity

-- | Should the <a>DataCon</a> be presented infix?
dataConIsInfix :: DataCon -> Bool

-- | Get the Id of the <a>DataCon</a> worker: a function that is the
--   "actual" constructor and has no top level binding in the program. The
--   type may be different from the obvious one written in the source
--   program. Panics if there is no such <a>Id</a> for this <a>DataCon</a>
dataConWorkId :: DataCon -> Id

-- | Returns an Id which looks like the Haskell-source constructor by using
--   the wrapper if it exists (see <a>dataConWrapId_maybe</a>) and failing
--   over to the worker (see <a>dataConWorkId</a>)
dataConWrapId :: DataCon -> Id

-- | Get the Id of the <a>DataCon</a> wrapper: a function that wraps the
--   "actual" constructor so it has the type visible in the source program:
--   c.f. <a>dataConWorkId</a>. Returns Nothing if there is no wrapper,
--   which occurs for an algebraic data constructor and also for a newtype
--   (whose constructor is inlined compulsorily)
dataConWrapId_maybe :: DataCon -> Maybe Id

-- | Find all the <a>Id</a>s implicitly brought into scope by the data
--   constructor. Currently, the union of the <a>dataConWorkId</a> and the
--   <a>dataConWrapId</a>
dataConImplicitTyThings :: DataCon -> [TyThing]

-- | Give the demands on the arguments of a Core constructor application
--   (Con dc args)
dataConRepStrictness :: DataCon -> [StrictnessMark]
dataConImplBangs :: DataCon -> [HsImplBang]
dataConBoxer :: DataCon -> Maybe DataConBoxer

-- | Extract the type constructor, type argument, data constructor and it's
--   <i>representation</i> argument types from a type if it is a product
--   type.
--   
--   Precisely, we return <tt>Just</tt> for any data type that is all of:
--   
--   <ul>
--   <li>Concrete (i.e. constructors visible)</li>
--   <li>Single-constructor</li>
--   <li>... which has no existentials</li>
--   </ul>
--   
--   Whether the type is a <tt>data</tt> type or a <tt>newtype</tt>.
splitDataProductType_maybe :: Type -> Maybe (TyCon, [Type], DataCon, [Scaled Type])

-- | Return whether there are any argument types for this <a>DataCon</a>s
--   original source type See Note [DataCon arities]
isNullarySrcDataCon :: DataCon -> Bool

-- | Return whether there are any argument types for this <a>DataCon</a>s
--   runtime representation type See Note [DataCon arities]
isNullaryRepDataCon :: DataCon -> Bool
isTupleDataCon :: DataCon -> Bool
isBoxedTupleDataCon :: DataCon -> Bool
isUnboxedTupleDataCon :: DataCon -> Bool
isUnboxedSumDataCon :: DataCon -> Bool

-- | Vanilla <a>DataCon</a>s are those that are nice boring Haskell 98
--   constructors
isVanillaDataCon :: DataCon -> Bool

-- | Is this the <a>DataCon</a> of a newtype?
isNewDataCon :: DataCon -> Bool
classDataCon :: Class -> DataCon
dataConCannotMatch :: [Type] -> DataCon -> Bool

-- | Were the type variables of the data con written in a different order
--   than the regular order (universal tyvars followed by existential
--   tyvars)?
--   
--   This is not a cheap test, so we minimize its use in GHC as much as
--   possible. Currently, its only call site in the GHC codebase is in
--   <tt>mkDataConRep</tt> in <a>MkId</a>, and so
--   <a>dataConUserTyVarsArePermuted</a> is only called at most once during
--   a data constructor's lifetime.
dataConUserTyVarsArePermuted :: DataCon -> Bool
isBanged :: HsImplBang -> Bool
isMarkedStrict :: StrictnessMark -> Bool

-- | Compare strictness annotations
eqHsBang :: HsImplBang -> HsImplBang -> Bool
isSrcStrict :: SrcStrictness -> Bool
isSrcUnpacked :: SrcUnpackedness -> Bool

-- | Should this DataCon be allowed in a type even without -XDataKinds?
--   Currently, only Lifted &amp; Unlifted
specialPromotedDc :: DataCon -> Bool
promoteDataCon :: DataCon -> TyCon
instance Data.Data.Data GHC.Core.DataCon.HsImplBang
instance Data.Data.Data GHC.Core.DataCon.SrcStrictness
instance GHC.Classes.Eq GHC.Core.DataCon.SrcStrictness
instance Data.Data.Data GHC.Core.DataCon.SrcUnpackedness
instance GHC.Classes.Eq GHC.Core.DataCon.SrcUnpackedness
instance Data.Data.Data GHC.Core.DataCon.HsSrcBang
instance GHC.Classes.Eq GHC.Core.DataCon.DataCon
instance GHC.Types.Unique.Uniquable GHC.Core.DataCon.DataCon
instance GHC.Types.Name.NamedThing GHC.Core.DataCon.DataCon
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.DataCon
instance GHC.Utils.Outputable.OutputableBndr GHC.Core.DataCon.DataCon
instance Data.Data.Data GHC.Core.DataCon.DataCon
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.EqSpec
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.StrictnessMark
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.HsSrcBang
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.SrcUnpackedness
instance GHC.Utils.Binary.Binary GHC.Core.DataCon.SrcUnpackedness
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.SrcStrictness
instance GHC.Utils.Binary.Binary GHC.Core.DataCon.SrcStrictness
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.HsImplBang

module GHC.Core.Unify

-- | <tt>tcMatchTy t1 t2</tt> produces a substitution (over fvs(t1))
--   <tt>s</tt> such that <tt>s(t1)</tt> equals <tt>t2</tt>. The returned
--   substitution might bind coercion variables, if the variable is an
--   argument to a GADT constructor.
--   
--   Precondition: typeKind ty1 <a>eqType</a> typeKind ty2
--   
--   We don't pass in a set of "template variables" to be bound by the
--   match, because tcMatchTy (and similar functions) are always used on
--   top-level types, so we can bind any of the free variables of the LHS.
--   See also Note [tcMatchTy vs tcMatchTyKi]
tcMatchTy :: Type -> Type -> Maybe TCvSubst

-- | Like <a>tcMatchTy</a>, but allows the kinds of the types to differ,
--   and thus matches them as well. See also Note [tcMatchTy vs
--   tcMatchTyKi]
tcMatchTyKi :: Type -> Type -> Maybe TCvSubst

-- | Like <a>tcMatchTy</a> but over a list of types. See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTys :: [Type] -> [Type] -> Maybe TCvSubst

-- | Like <a>tcMatchTyKi</a> but over a list of types. See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTyKis :: [Type] -> [Type] -> Maybe TCvSubst

-- | This is similar to <a>tcMatchTy</a>, but extends a substitution See
--   also Note [tcMatchTy vs tcMatchTyKi]
tcMatchTyX :: TCvSubst -> Type -> Type -> Maybe TCvSubst

-- | Like <a>tcMatchTys</a>, but extending a substitution See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTysX :: TCvSubst -> [Type] -> [Type] -> Maybe TCvSubst

-- | Like <a>tcMatchTyKis</a>, but extending a substitution See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTyKisX :: TCvSubst -> [Type] -> [Type] -> Maybe TCvSubst
tcMatchTyX_BM :: BindFun -> TCvSubst -> Type -> Type -> Maybe TCvSubst

-- | This one is called from the expression matcher, which already has a
--   MatchEnv in hand
ruleMatchTyKiX :: TyCoVarSet -> RnEnv2 -> TvSubstEnv -> Type -> Type -> Maybe TvSubstEnv
data RoughMatchTc
KnownTc :: Name -> RoughMatchTc
OtherTc :: RoughMatchTc
roughMatchTcs :: [Type] -> [RoughMatchTc]
instanceCantMatch :: [RoughMatchTc] -> [RoughMatchTc] -> Bool

-- | Given a list of pairs of types, are any two members of a pair surely
--   apart, even after arbitrary type function evaluation and substitution?
typesCantMatch :: [(Type, Type)] -> Bool
isRoughOtherTc :: RoughMatchTc -> Bool

-- | Simple unification of two types; all type variables are bindable
--   Precondition: the kinds are already equal
tcUnifyTy :: Type -> Type -> Maybe TCvSubst

-- | Like <a>tcUnifyTy</a>, but also unifies the kinds
tcUnifyTyKi :: Type -> Type -> Maybe TCvSubst
tcUnifyTys :: BindFun -> [Type] -> [Type] -> Maybe TCvSubst

-- | Like <a>tcUnifyTys</a> but also unifies the kinds
tcUnifyTyKis :: BindFun -> [Type] -> [Type] -> Maybe TCvSubst

-- | <tt>tcUnifyTysFG bind_tv tys1 tys2</tt> attempts to find a
--   substitution <tt>s</tt> (whose domain elements all respond
--   <a>BindMe</a> to <tt>bind_tv</tt>) such that <tt>s(tys1)</tt> and that
--   of <tt>s(tys2)</tt> are equal, as witnessed by the returned Coercions.
--   This version requires that the kinds of the types are the same, if you
--   unify left-to-right.
tcUnifyTysFG :: BindFun -> [Type] -> [Type] -> UnifyResult

-- | Unify two types, treating type family applications as possibly
--   unifying with anything and looking through injective type family
--   applications. Precondition: kinds are the same
tcUnifyTyWithTFs :: Bool -> Type -> Type -> Maybe TCvSubst

-- | Some unification functions are parameterised by a <a>BindFun</a>,
--   which says whether or not to allow a certain unification to take
--   place. A <a>BindFun</a> takes the <a>TyVar</a> involved along with the
--   <a>Type</a> it will potentially be bound to.
--   
--   It is possible for the variable to actually be a coercion variable
--   (Note [Matching coercion variables]), but only when one-way matching.
--   In this case, the <a>Type</a> will be a <a>CoercionTy</a>.
type BindFun = TyCoVar -> Type -> BindFlag
data BindFlag

-- | A regular type variable
BindMe :: BindFlag

-- | Declare that this type variable is <i>apart</i> from the type
--   provided. That is, the type variable will never be instantiated to
--   that type. See also Note [Binding when looking up instances] in
--   GHC.Core.InstEnv.
Apart :: BindFlag

-- | Allow binding only for any variable in the set. Variables may be bound
--   to any type. Used when doing simple matching; e.g. can we find a
--   substitution
--   
--   <pre>
--   S = [a :-&gt; t1, b :-&gt; t2] such that
--       S( Maybe (a, b-&gt;Int )  =   Maybe (Bool, Char -&gt; Int)
--   </pre>
matchBindFun :: TyCoVarSet -> BindFun

-- | Allow the binding of any variable to any type
alwaysBindFun :: BindFun
type UnifyResult = UnifyResultM TCvSubst

-- | See Note [Unificiation result]
data UnifyResultM a
Unifiable :: a -> UnifyResultM a
MaybeApart :: MaybeApartReason -> a -> UnifyResultM a
SurelyApart :: UnifyResultM a

-- | Why are two types <a>MaybeApart</a>? <a>MARTypeFamily</a> takes
--   precedence: This is used (only) in Note [Infinitary substitution in
--   lookup] in GHC.Core.InstEnv
data MaybeApartReason

-- | matching e.g. F Int ~? Bool
MARTypeFamily :: MaybeApartReason

-- | matching e.g. a ~? Maybe a
MARInfinite :: MaybeApartReason

-- | <a>liftCoMatch</a> is sort of inverse to <a>liftCoSubst</a>. In
--   particular, if <tt>liftCoMatch vars ty co == Just s</tt>, then
--   <tt>liftCoSubst s ty == co</tt>, where <tt>==</tt> there means that
--   the result of <a>liftCoSubst</a> has the same type as the original co;
--   but may be different under the hood. That is, it matches a type
--   against a coercion of the same "shape", and returns a lifting
--   substitution which could have been used to produce the given coercion
--   from the given type. Note that this function is incomplete -- it might
--   return Nothing when there does indeed exist a possible lifting
--   context.
--   
--   This function is incomplete in that it doesn't respect the equality in
--   <a>eqType</a>. That is, it's possible that this will succeed for t1
--   and fail for t2, even when t1 <a>eqType</a> t2. That's because it
--   depends on there being a very similar structure between the type and
--   the coercion. This incompleteness shouldn't be all that surprising,
--   especially because it depends on the structure of the coercion, which
--   is a silly thing to do.
--   
--   The lifting context produced doesn't have to be exacting in the roles
--   of the mappings. This is because any use of the lifting context will
--   also require a desired role. Thus, this algorithm prefers mapping to
--   nominal coercions where it can do so.
liftCoMatch :: TyCoVarSet -> Type -> Coercion -> Maybe LiftingContext
flattenTys :: InScopeSet -> [Type] -> [Type]
flattenTysX :: InScopeSet -> [Type] -> ([Type], TyVarEnv (TyCon, [Type]))
instance Data.Data.Data GHC.Core.Unify.RoughMatchTc
instance GHC.Base.Functor GHC.Core.Unify.UnifyResultM
instance GHC.Classes.Eq GHC.Core.Unify.BindFlag
instance GHC.Base.Functor GHC.Core.Unify.UM
instance GHC.Base.Applicative GHC.Core.Unify.UM
instance GHC.Base.Monad GHC.Core.Unify.UM
instance Control.Monad.Fail.MonadFail GHC.Core.Unify.UM
instance GHC.Base.Applicative GHC.Core.Unify.UnifyResultM
instance GHC.Base.Monad GHC.Core.Unify.UnifyResultM
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.Unify.UnifyResultM a)
instance GHC.Utils.Outputable.Outputable GHC.Core.Unify.MaybeApartReason
instance GHC.Base.Semigroup GHC.Core.Unify.MaybeApartReason

module GHC.Core.TyCo.FVs
shallowTyCoVarsOfType :: Type -> TyCoVarSet
shallowTyCoVarsOfTypes :: [Type] -> TyCoVarSet
tyCoVarsOfType :: Type -> TyCoVarSet
tyCoVarsOfTypes :: [Type] -> TyCoVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet

-- | Returns free variables of types, including kind variables as a
--   deterministic set. For type synonyms it does <i>not</i> expand the
--   synonym.
tyCoVarsOfTypesDSet :: [Type] -> DTyCoVarSet
tyCoFVsBndr :: TyCoVarBinder -> FV -> FV
tyCoFVsVarBndr :: Var -> FV -> FV
tyCoFVsVarBndrs :: [Var] -> FV -> FV

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in <a>GHC.Utils.FV</a>.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in <a>GHC.Utils.FV</a> for explanation.
tyCoFVsOfType :: Type -> FV

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in
--   deterministic order. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeList :: Type -> [TyCoVar]
tyCoFVsOfTypes :: [Type] -> FV

-- | Returns free variables of types, including kind variables as a
--   deterministically ordered list. For type synonyms it does <i>not</i>
--   expand the synonym.
tyCoVarsOfTypesList :: [Type] -> [TyCoVar]
deepTcvFolder :: TyCoFolder TyCoVarSet (Endo TyCoVarSet)

-- | Returns free variables of types, including kind variables as a
--   non-deterministic set. For type synonyms it does <i>not</i> expand the
--   synonym.
shallowTyCoVarsOfTyVarEnv :: TyVarEnv Type -> TyCoVarSet
shallowTyCoVarsOfCoVarEnv :: CoVarEnv Coercion -> TyCoVarSet
shallowTyCoVarsOfCo :: Coercion -> TyCoVarSet
shallowTyCoVarsOfCos :: [Coercion] -> TyCoVarSet
tyCoVarsOfCo :: Coercion -> TyCoVarSet
tyCoVarsOfCos :: [Coercion] -> TyCoVarSet
tyCoVarsOfMCo :: MCoercion -> TyCoVarSet
coVarsOfType :: Type -> CoVarSet
coVarsOfTypes :: [Type] -> CoVarSet
coVarsOfCo :: Coercion -> CoVarSet
coVarsOfCos :: [Coercion] -> CoVarSet

-- | Get a deterministic set of the vars free in a coercion
tyCoVarsOfCoDSet :: Coercion -> DTyCoVarSet
tyCoFVsOfCo :: Coercion -> FV
tyCoFVsOfCos :: [Coercion] -> FV
tyCoVarsOfCoList :: Coercion -> [TyCoVar]

-- | Given a covar and a coercion, returns True if covar is almost devoid
--   in the coercion. That is, covar can only appear in Refl and GRefl. See
--   last wrinkle in Note [Unused coercion variable in ForAllCo] in
--   <a>GHC.Core.Coercion</a>
almostDevoidCoVarOfCo :: CoVar -> Coercion -> Bool

-- | Returns the free variables of a <a>Type</a> that are in injective
--   positions. Specifically, it finds the free variables while:
--   
--   <ul>
--   <li>Expanding type synonyms</li>
--   <li>Ignoring the coercion in <tt>(ty |&gt; co)</tt></li>
--   <li>Ignoring the non-injective fields of a <a>TyConApp</a></li>
--   </ul>
--   
--   For example, if <tt>F</tt> is a non-injective type family, then:
--   
--   <pre>
--   injectiveTyVarsOf( Either c (Maybe (a, F b c)) ) = {a,c}
--   </pre>
--   
--   If <tt><a>injectiveVarsOfType</a> ty = itvs</tt>, then knowing
--   <tt>ty</tt> fixes <tt>itvs</tt>. More formally, if <tt>a</tt> is in
--   <tt><a>injectiveVarsOfType</a> ty</tt> and <tt>S1(ty) ~ S2(ty)</tt>,
--   then <tt>S1(a) ~ S2(a)</tt>, where <tt>S1</tt> and <tt>S2</tt> are
--   arbitrary substitutions.
--   
--   See <tt>Note [When does a tycon application need an explicit kind
--   signature?]</tt>.
injectiveVarsOfType :: Bool -> Type -> FV

-- | Returns the free variables of a <a>Type</a> that are in injective
--   positions. Specifically, it finds the free variables while:
--   
--   <ul>
--   <li>Expanding type synonyms</li>
--   <li>Ignoring the coercion in <tt>(ty |&gt; co)</tt></li>
--   <li>Ignoring the non-injective fields of a <a>TyConApp</a></li>
--   </ul>
--   
--   See <tt>Note [When does a tycon application need an explicit kind
--   signature?]</tt>.
injectiveVarsOfTypes :: Bool -> [Type] -> FV

-- | Returns the set of variables that are used invisibly anywhere within
--   the given type. A variable will be included even if it is used both
--   visibly and invisibly. An invisible use site includes: * In the kind
--   of a variable * In the kind of a bound variable in a forall * In a
--   coercion * In a Specified or Inferred argument to a function See Note
--   [VarBndrs, TyCoVarBinders, TyConBinders, and visibility] in
--   <a>GHC.Core.TyCo.Rep</a>
invisibleVarsOfType :: Type -> FV

-- | Like <a>invisibleVarsOfType</a>, but for many types.
invisibleVarsOfTypes :: [Type] -> FV
anyFreeVarsOfType :: (TyCoVar -> Bool) -> Type -> Bool
anyFreeVarsOfTypes :: (TyCoVar -> Bool) -> [Type] -> Bool
anyFreeVarsOfCo :: (TyCoVar -> Bool) -> Coercion -> Bool
noFreeVarsOfType :: Type -> Bool
noFreeVarsOfTypes :: [Type] -> Bool
noFreeVarsOfCo :: Coercion -> Bool

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in <a>GHC.Rename.HsType</a>
scopedSort :: [TyCoVar] -> [TyCoVar]

-- | Get the free vars of a type in scoped order
tyCoVarsOfTypeWellScoped :: Type -> [TyVar]

-- | Get the free vars of types in scoped order
tyCoVarsOfTypesWellScoped :: [Type] -> [TyVar]

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministically ordered list.
closeOverKindsList :: [TyVar] -> [TyVar]
closeOverKinds :: TyCoVarSet -> TyCoVarSet

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a
runTyCoVars :: Endo TyCoVarSet -> TyCoVarSet

module GHC.Core.Map.Type
class TrieMap m where {
    type Key m :: Type;
}
emptyTM :: TrieMap m => m a
lookupTM :: forall b. TrieMap m => Key m -> m b -> Maybe b
alterTM :: forall b. TrieMap m => Key m -> XT b -> m b -> m b
mapTM :: TrieMap m => (a -> b) -> m a -> m b
filterTM :: TrieMap m => (a -> Bool) -> m a -> m a
foldTM :: TrieMap m => (a -> b -> b) -> m a -> b -> b
type XT a = Maybe a -> Maybe a

-- | <tt>TypeMap a</tt> is a map from <a>Type</a> to <tt>a</tt>. If you are
--   a client, this is the type you want. The keys in this map may have
--   different kinds.
data TypeMap a
emptyTypeMap :: TypeMap a
extendTypeMap :: TypeMap a -> Type -> a -> TypeMap a
lookupTypeMap :: TypeMap a -> Type -> Maybe a
foldTypeMap :: (a -> b -> b) -> b -> TypeMap a -> b

-- | A <a>LooseTypeMap</a> doesn't do a kind-check. Thus, when lookup up (t
--   |&gt; g), you'll find entries inserted under (t), even if (g) is
--   non-reflexive.
data LooseTypeMap a
data CmEnv
lookupCME :: CmEnv -> Var -> Maybe BoundVar

-- | Extend a <a>TypeMap</a> with a type in the given context.
--   <tt>extendTypeMapWithScope m (mkDeBruijnContext [a,b,c]) t v</tt> is
--   equivalent to <tt>extendTypeMap m (forall a b c. t) v</tt>, but allows
--   reuse of the context over multiple insertions.
extendTypeMapWithScope :: TypeMap a -> CmEnv -> Type -> a -> TypeMap a
lookupTypeMapWithScope :: TypeMap a -> CmEnv -> Type -> Maybe a

-- | Construct a deBruijn environment with the given variables in scope.
--   e.g. <tt>mkDeBruijnEnv [a,b,c]</tt> constructs a context <tt>forall a
--   b c.</tt>
mkDeBruijnContext :: [Var] -> CmEnv
extendCME :: CmEnv -> Var -> CmEnv
extendCMEs :: CmEnv -> [Var] -> CmEnv
emptyCME :: CmEnv

-- | <tt>TypeMapG a</tt> is a map from <tt>DeBruijn Type</tt> to
--   <tt>a</tt>. The extended key makes it suitable for recursive
--   traversal, since it can track binders, but it is strictly internal to
--   this module. If you are including a <a>TypeMap</a> inside another
--   <a>TrieMap</a>, this is the type you want. Note that this lookup does
--   not do a kind-check. Thus, all keys in this map must have the same
--   kind. Also note that this map respects the distinction between
--   <tt>Type</tt> and <tt>Constraint</tt>, despite the fact that they are
--   equivalent type synonyms in Core.
type TypeMapG = GenMap TypeMapX
type CoercionMapG = GenMap CoercionMapX

-- | <tt>DeBruijn a</tt> represents <tt>a</tt> modulo alpha-renaming. This
--   is achieved by equipping the value with a <a>CmEnv</a>, which tracks
--   an on-the-fly deBruijn numbering. This allows us to define an
--   <a>Eq</a> instance for <tt>DeBruijn a</tt>, even if this was not
--   (easily) possible for <tt>a</tt>. Note: we purposely don't export the
--   constructor. Make a helper function if you find yourself needing it.
data DeBruijn a
D :: CmEnv -> a -> DeBruijn a

-- | Synthesizes a <tt>DeBruijn a</tt> from an <tt>a</tt>, by assuming that
--   there are no bound binders (an empty <a>CmEnv</a>). This is usually
--   what you want if there isn't already a <a>CmEnv</a> in scope.
deBruijnize :: a -> DeBruijn a

-- | A <a>BndrMap</a> is a <a>TypeMapG</a> which allows us to distinguish
--   between binding forms whose binders have different types. For example,
--   if we are doing a <a>TrieMap</a> lookup on <tt>(x :: Int) -&gt;
--   ()</tt>, we should not pick up an entry in the <a>TrieMap</a> for
--   <tt>(x :: Bool) -&gt; ()</tt>: we can disambiguate this by matching on
--   the type (or kind, if this a binder in a type) of the binder.
--   
--   We also need to do the same for multiplicity! Which, since
--   multiplicities are encoded simply as a <a>Type</a>, amounts to have a
--   Trie for a pair of types. Tries of pairs are composition.
data BndrMap a
xtBndr :: forall a. CmEnv -> Var -> XT a -> BndrMap a -> BndrMap a
lkBndr :: CmEnv -> Var -> BndrMap a -> Maybe a
data VarMap a
xtVar :: CmEnv -> Var -> XT a -> VarMap a -> VarMap a
lkVar :: CmEnv -> Var -> VarMap a -> Maybe a
lkDFreeVar :: Var -> DVarEnv a -> Maybe a
xtDFreeVar :: Var -> XT a -> DVarEnv a -> DVarEnv a
xtDNamed :: NamedThing n => n -> XT a -> DNameEnv a -> DNameEnv a
lkDNamed :: NamedThing n => n -> DNameEnv a -> Maybe a
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.CoercionMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.CoercionMapX
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.TypeMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.LooseTypeMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.TypeMapX
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.Map.Type.TypeMapG a)
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.BndrMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.VarMap
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Core.TyCo.Rep.Coercion)
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Core.TyCo.Rep.Type)
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn a) => GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn [a])
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn a) => GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn (GHC.Maybe.Maybe a))
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.TyLitMap

module GHC.Data.TrieMap
data MaybeMap m a
data ListMap m a
type LiteralMap a = Map Literal a
class TrieMap m where {
    type Key m :: Type;
}
emptyTM :: TrieMap m => m a
lookupTM :: forall b. TrieMap m => Key m -> m b -> Maybe b
alterTM :: forall b. TrieMap m => Key m -> XT b -> m b -> m b
mapTM :: TrieMap m => (a -> b) -> m a -> m b
filterTM :: TrieMap m => (a -> Bool) -> m a -> m a
foldTM :: TrieMap m => (a -> b -> b) -> m a -> b -> b
insertTM :: TrieMap m => Key m -> a -> m a -> m a
deleteTM :: TrieMap m => Key m -> m a -> m a
foldMapTM :: (TrieMap m, Monoid r) => (a -> r) -> m a -> r
isEmptyTM :: TrieMap m => m a -> Bool
(>.>) :: (a -> b) -> (b -> c) -> a -> c
infixr 1 >.>
(|>) :: a -> (a -> b) -> b
infixr 1 |>
(|>>) :: TrieMap m2 => (XT (m2 a) -> m1 (m2 a) -> m1 (m2 a)) -> (m2 a -> m2 a) -> m1 (m2 a) -> m1 (m2 a)
infixr 1 |>>
type XT a = Maybe a -> Maybe a
foldMaybe :: (a -> b -> b) -> Maybe a -> b -> b
filterMaybe :: (a -> Bool) -> Maybe a -> Maybe a
data GenMap m a
lkG :: (Eq (Key m), TrieMap m) => Key m -> GenMap m a -> Maybe a
xtG :: (Eq (Key m), TrieMap m) => Key m -> XT a -> GenMap m a -> GenMap m a
mapG :: TrieMap m => (a -> b) -> GenMap m a -> GenMap m b
fdG :: TrieMap m => (a -> b -> b) -> GenMap m a -> b -> b
xtList :: TrieMap m => (forall b. k -> XT b -> m b -> m b) -> [k] -> XT a -> ListMap m a -> ListMap m a
lkList :: TrieMap m => (forall b. k -> m b -> Maybe b) -> [k] -> ListMap m a -> Maybe a
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable (m a)) => GHC.Utils.Outputable.Outputable (GHC.Data.TrieMap.GenMap m a)
instance (GHC.Classes.Eq (GHC.Data.TrieMap.Key m), GHC.Data.TrieMap.TrieMap m) => GHC.Data.TrieMap.TrieMap (GHC.Data.TrieMap.GenMap m)
instance (GHC.Classes.Eq (GHC.Data.TrieMap.Key m), GHC.Data.TrieMap.TrieMap m) => Data.Foldable.Foldable (GHC.Data.TrieMap.GenMap m)
instance GHC.Data.TrieMap.TrieMap m => GHC.Data.TrieMap.TrieMap (GHC.Data.TrieMap.ListMap m)
instance GHC.Data.TrieMap.TrieMap m => Data.Foldable.Foldable (GHC.Data.TrieMap.ListMap m)
instance (GHC.Data.TrieMap.TrieMap m, GHC.Utils.Outputable.Outputable a) => GHC.Utils.Outputable.Outputable (GHC.Data.TrieMap.ListMap m a)
instance GHC.Data.TrieMap.TrieMap m => GHC.Data.TrieMap.TrieMap (GHC.Data.TrieMap.MaybeMap m)
instance GHC.Data.TrieMap.TrieMap m => Data.Foldable.Foldable (GHC.Data.TrieMap.MaybeMap m)
instance GHC.Data.TrieMap.TrieMap Data.IntMap.Internal.IntMap
instance GHC.Classes.Ord k => GHC.Data.TrieMap.TrieMap (Data.Map.Internal.Map k)
instance GHC.Types.Unique.Uniquable key => GHC.Data.TrieMap.TrieMap (GHC.Types.Unique.DFM.UniqDFM key)


-- | Module for (a) type kinds and (b) type coercions, as used in System
--   FC. See <a>Expr</a> for more on System FC and how coercions fit into
--   it.
module GHC.Core.Coercion

-- | A <a>Coercion</a> is concrete evidence of the equality/convertibility
--   of two types.
data Coercion
type CoercionN = Coercion
type CoercionR = Coercion
type CoercionP = Coercion

-- | A semantically more meaningful type to represent what may or may not
--   be a useful <a>Coercion</a>.
data MCoercion
MRefl :: MCoercion
MCo :: Coercion -> MCoercion
type MCoercionN = MCoercion
type MCoercionR = MCoercion

-- | For simplicity, we have just one UnivCo that represents a coercion
--   from some type to some other type, with (in general) no restrictions
--   on the type. The UnivCoProvenance specifies more exactly what the
--   coercion really is and why a program should (or shouldn't!) trust the
--   coercion. It is reasonable to consider each constructor of
--   <a>UnivCoProvenance</a> as a totally independent coercion form; their
--   only commonality is that they don't tell you what types they coercion
--   between. (That info is in the <a>UnivCo</a> constructor of
--   <a>Coercion</a>.
data UnivCoProvenance

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
CoercionHole :: CoVar -> IORef (Maybe Coercion) -> CoercionHole
[ch_co_var] :: CoercionHole -> CoVar
[ch_ref] :: CoercionHole -> IORef (Maybe Coercion)
coHoleCoVar :: CoercionHole -> CoVar
setCoHoleCoVar :: CoercionHole -> CoVar -> CoercionHole
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Coercion Variable
type CoVar = Id

-- | Type or Coercion Variable
type TyCoVar = Id
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
ltRole :: Role -> Role -> Bool
coVarTypes :: HasDebugCallStack => CoVar -> Pair Type
coVarKind :: CoVar -> Type
coVarKindsTypesRole :: HasDebugCallStack => CoVar -> (Kind, Kind, Type, Type, Role)
coVarRole :: CoVar -> Role
coercionType :: Coercion -> Type

-- | Makes a coercion type from two types: the types whose equality is
--   proven by the relevant <a>Coercion</a>
mkCoercionType :: Role -> Type -> Type -> Type

-- | If it is the case that
--   
--   <pre>
--   c :: (t1 ~ t2)
--   </pre>
--   
--   i.e. the kind of <tt>c</tt> relates <tt>t1</tt> and <tt>t2</tt>, then
--   <tt>coercionKind c = Pair t1 t2</tt>.
coercionKind :: Coercion -> Pair Type
coercionLKind :: Coercion -> Type
coercionRKind :: Coercion -> Type

-- | Apply <a>coercionKind</a> to multiple <a>Coercion</a>s
coercionKinds :: [Coercion] -> Pair [Type]

-- | Retrieve the role from a coercion.
coercionRole :: Coercion -> Role

-- | Get a coercion's kind and role.
coercionKindRole :: Coercion -> (Pair Type, Role)

-- | Make a generalized reflexive coercion
mkGReflCo :: Role -> Type -> MCoercionN -> Coercion

-- | Make a reflexive coercion
mkReflCo :: Role -> Type -> Coercion

-- | Make a representational reflexive coercion
mkRepReflCo :: Type -> Coercion

-- | Make a nominal reflexive coercion
mkNomReflCo :: Type -> Coercion
mkCoVarCo :: CoVar -> Coercion
mkCoVarCos :: [CoVar] -> [Coercion]
mkAxInstCo :: Role -> CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Coercion
mkUnbranchedAxInstCo :: Role -> CoAxiom Unbranched -> [Type] -> [Coercion] -> Coercion
mkAxInstRHS :: CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type
mkUnbranchedAxInstRHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type

-- | Return the left-hand type of the axiom, when the axiom is instantiated
--   at the types given.
mkAxInstLHS :: CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type

-- | Instantiate the left-hand side of an unbranched axiom
mkUnbranchedAxInstLHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type

-- | Make a forall <a>Coercion</a>, where both types related by the
--   coercion are quantified over the same variable.
mkPiCo :: Role -> Var -> Coercion -> Coercion
mkPiCos :: Role -> [Var] -> Coercion -> Coercion
mkCoCast :: Coercion -> CoercionR -> Coercion

-- | Create a symmetric version of the given <a>Coercion</a> that asserts
--   equality between the same types but in the other "direction", so a
--   kind of <tt>t1 ~ t2</tt> becomes the kind <tt>t2 ~ t1</tt>.
mkSymCo :: Coercion -> Coercion

-- | Create a new <a>Coercion</a> by composing the two given
--   <a>Coercion</a>s transitively. (co1 ; co2)
mkTransCo :: Coercion -> Coercion -> Coercion
mkNthCo :: HasDebugCallStack => Role -> Int -> Coercion -> Coercion

-- | Extract the nth field of a FunCo
mkNthCoFunCo :: Int -> CoercionN -> Coercion -> Coercion -> Coercion

-- | If you're about to call <tt>mkNthCo r n co</tt>, then <tt>r</tt>
--   should be whatever <tt>nthCoRole n co</tt> returns.
nthCoRole :: Int -> Coercion -> Role
mkLRCo :: LeftOrRight -> Coercion -> Coercion

-- | Instantiates a <a>Coercion</a>.
mkInstCo :: Coercion -> Coercion -> Coercion

-- | Apply a <a>Coercion</a> to another <a>Coercion</a>. The second
--   coercion must be Nominal, unless the first is Phantom. If the first is
--   Phantom, then the second can be either Phantom or Nominal.
mkAppCo :: Coercion -> Coercion -> Coercion

-- | Applies multiple <a>Coercion</a>s to another <a>Coercion</a>, from
--   left to right. See also <a>mkAppCo</a>.
mkAppCos :: Coercion -> [Coercion] -> Coercion

-- | Apply a type constructor to a list of coercions. It is the caller's
--   responsibility to get the roles correct on argument coercions.
mkTyConAppCo :: HasDebugCallStack => Role -> TyCon -> [Coercion] -> Coercion

-- | Build a function <a>Coercion</a> from two other <a>Coercion</a>s. That
--   is, given <tt>co1 :: a ~ b</tt> and <tt>co2 :: x ~ y</tt> produce
--   <tt>co :: (a -&gt; x) ~ (b -&gt; y)</tt>.
mkFunCo :: Role -> CoercionN -> Coercion -> Coercion -> Coercion
mkFunResCo :: Role -> Scaled Type -> Coercion -> Coercion

-- | Make a Coercion from a tycovar, a kind coercion, and a body coercion.
--   The kind of the tycovar should be the left-hand kind of the kind
--   coercion. See Note [Unused coercion variable in ForAllCo]
mkForAllCo :: TyCoVar -> CoercionN -> Coercion -> Coercion

-- | Make nested ForAllCos
mkForAllCos :: [(TyCoVar, CoercionN)] -> Coercion -> Coercion

-- | Make a Coercion quantified over a type/coercion variable; the variable
--   has the same type in both sides of the coercion
mkHomoForAllCos :: [TyCoVar] -> Coercion -> Coercion

-- | Make a phantom coercion between two types. The coercion passed in must
--   be a nominal coercion between the kinds of the types.
mkPhantomCo :: Coercion -> Type -> Type -> Coercion

-- | Make a coercion from a coercion hole
mkHoleCo :: CoercionHole -> Coercion

-- | Make a universal coercion between two arbitrary types.
mkUnivCo :: UnivCoProvenance -> Role -> Type -> Type -> Coercion
mkSubCo :: HasDebugCallStack => Coercion -> Coercion
mkAxiomInstCo :: CoAxiom Branched -> BranchIndex -> [Coercion] -> Coercion

-- | Make a "coercion between coercions".
mkProofIrrelCo :: Role -> Coercion -> Coercion -> Coercion -> Coercion

-- | Like <a>downgradeRole_maybe</a>, but panics if the change isn't a
--   downgrade. See Note [Role twiddling functions]
downgradeRole :: Role -> Role -> Coercion -> Coercion
mkAxiomRuleCo :: CoAxiomRule -> [Coercion] -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, produces <tt>co' ::
--   ty ~r (ty |&gt; co)</tt>
mkGReflRightCo :: Role -> Type -> CoercionN -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, produces <tt>co' ::
--   (ty |&gt; co) ~r ty</tt>
mkGReflLeftCo :: Role -> Type -> CoercionN -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty ~r
--   ty'</tt>, produces @co' :: (ty |&gt; co) ~r ty' It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceLeftCo :: Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty' ~r
--   ty</tt>, produces @co' :: ty' ~r (ty |&gt; co) It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceRightCo :: Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Given <tt>co :: (a :: k) ~ (b :: k')</tt> produce <tt>co' :: k ~
--   k'</tt>.
mkKindCo :: Coercion -> Coercion

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind g h1 h2</tt>, where <tt>g :: t1 ~r t2</tt>,
--   has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt> and
--   <tt>h2</tt> must be nominal. It calls <tt>coercionKindRole</tt>, so
--   it's quite inefficient (which <tt>I</tt> stands for) Use
--   <tt>castCoercionKind2</tt> instead if <tt>t1</tt>, <tt>t2</tt>, and
--   <tt>r</tt> are known beforehand.
castCoercionKind :: Coercion -> CoercionN -> CoercionN -> Coercion

-- | <tt>castCoercionKind1 g r t1 t2 h</tt> = <tt>coercionKind g r t1 t2 h
--   h</tt> That is, it's a specialised form of castCoercionKind, where the
--   two kind coercions are identical <tt>castCoercionKind1 g r t1 t2
--   h</tt>, where <tt>g :: t1 ~r t2</tt>, has type <tt>(t1 |&gt; h) ~r (t2
--   |&gt; h)</tt>. <tt>h</tt> must be nominal. See Note
--   [castCoercionKind1]
castCoercionKind1 :: Coercion -> Role -> Type -> Type -> CoercionN -> Coercion

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind2 g r t1 t2 h1 h2</tt>, where <tt>g :: t1 ~r
--   t2</tt>, has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt>
--   and <tt>h2</tt> must be nominal.
castCoercionKind2 :: Coercion -> Role -> Type -> Type -> CoercionN -> CoercionN -> Coercion

-- | Given a family instance <a>TyCon</a> and its arg <a>Coercion</a>s,
--   return the corresponding family <a>Coercion</a>. E.g:
--   
--   <pre>
--   data family T a
--   data instance T (Maybe b) = MkT b
--   </pre>
--   
--   Where the instance <a>TyCon</a> is :RTL, so:
--   
--   <pre>
--   mkFamilyTyConAppCo :RTL (co :: a ~# Int) = T (Maybe a) ~# T (Maybe Int)
--   </pre>
--   
--   cf. <a>mkFamilyTyConApp</a>
mkFamilyTyConAppCo :: TyCon -> [CoercionN] -> CoercionN
mkHeteroCoercionType :: Role -> Kind -> Kind -> Type -> Type -> Type

-- | Creates a primitive type equality predicate. Invariant: the types are
--   not Coercions
mkPrimEqPred :: Type -> Type -> Type
mkReprPrimEqPred :: Type -> Type -> Type

-- | Makes a lifted equality predicate at the given role
mkPrimEqPredRole :: Role -> Type -> Type -> PredType

-- | Creates a primitive type equality predicate with explicit kinds
mkHeteroPrimEqPred :: Kind -> Kind -> Type -> Type -> Type

-- | Creates a primitive representational type equality predicate with
--   explicit kinds
mkHeteroReprPrimEqPred :: Kind -> Kind -> Type -> Type -> Type

-- | If <tt>co :: T ts ~ rep_ty</tt> then:
--   
--   <pre>
--   instNewTyCon_maybe T ts = Just (rep_ty, co)
--   </pre>
--   
--   Checks for a newtype, and for being saturated
instNewTyCon_maybe :: TyCon -> [Type] -> Maybe (Type, Coercion)

-- | A function to check if we can reduce a type by one step. Used with
--   <a>topNormaliseTypeX</a>.
type NormaliseStepper ev = RecTcChecker -> TyCon -> [Type] -> NormaliseStepResult ev

-- | The result of stepping in a normalisation function. See
--   <a>topNormaliseTypeX</a>.
data NormaliseStepResult ev

-- | Nothing more to do
NS_Done :: NormaliseStepResult ev

-- | Utter failure. The outer function should fail too.
NS_Abort :: NormaliseStepResult ev

-- | We stepped, yielding new bits; ^ ev is evidence; Usually a co :: old
--   type ~ new type
NS_Step :: RecTcChecker -> Type -> ev -> NormaliseStepResult ev

-- | Try one stepper and then try the next, if the first doesn't make
--   progress. So if it returns NS_Done, it means that both steppers are
--   satisfied
composeSteppers :: NormaliseStepper ev -> NormaliseStepper ev -> NormaliseStepper ev
mapStepResult :: (ev1 -> ev2) -> NormaliseStepResult ev1 -> NormaliseStepResult ev2

-- | A <a>NormaliseStepper</a> that unwraps newtypes, careful not to fall
--   into a loop. If it would fall into a loop, it produces
--   <a>NS_Abort</a>.
unwrapNewTypeStepper :: NormaliseStepper Coercion

-- | Sometimes we want to look through a <tt>newtype</tt> and get its
--   associated coercion. This function strips off <tt>newtype</tt> layers
--   enough to reveal something that isn't a <tt>newtype</tt>.
--   Specifically, here's the invariant:
--   
--   <pre>
--   topNormaliseNewType_maybe rec_nts ty = Just (co, ty')
--   </pre>
--   
--   then (a) <tt>co : ty ~ ty'</tt>. (b) ty' is not a newtype.
--   
--   The function returns <tt>Nothing</tt> for non-<tt>newtypes</tt>, or
--   unsaturated applications
--   
--   This function does *not* look through type families, because it has no
--   access to the type family environment. If you do have that at hand,
--   consider to use topNormaliseType_maybe, which should be a drop-in
--   replacement for topNormaliseNewType_maybe If topNormliseNewType_maybe
--   ty = Just (co, ty'), then co : ty ~R ty'
topNormaliseNewType_maybe :: Type -> Maybe (Coercion, Type)

-- | A general function for normalising the top-level of a type. It
--   continues to use the provided <a>NormaliseStepper</a> until that
--   function fails, and then this function returns. The roles of the
--   coercions produced by the <a>NormaliseStepper</a> must all be the
--   same, which is the role returned from the call to
--   <a>topNormaliseTypeX</a>.
--   
--   Typically ev is Coercion.
--   
--   If topNormaliseTypeX step plus ty = Just (ev, ty') then ty ~ev1~ t1
--   ~ev2~ t2 ... ~evn~ ty' and ev = ev1 <tt>plus</tt> ev2 <tt>plus</tt>
--   ... <tt>plus</tt> evn If it returns Nothing then no newtype unwrapping
--   could happen
topNormaliseTypeX :: NormaliseStepper ev -> (ev -> ev -> ev) -> Type -> Maybe (ev, Type)

-- | This breaks a <a>Coercion</a> with type <tt>T A B C ~ T D E F</tt>
--   into a list of <a>Coercion</a>s of kinds <tt>A ~ D</tt>, <tt>B ~
--   E</tt> and <tt>E ~ F</tt>. Hence:
--   
--   <pre>
--   decomposeCo 3 c [r1, r2, r3] = [nth r1 0 c, nth r2 1 c, nth r3 2 c]
--   </pre>
decomposeCo :: Arity -> Coercion -> [Role] -> [Coercion]
decomposeFunCo :: HasDebugCallStack => Role -> Coercion -> (CoercionN, Coercion, Coercion)
decomposePiCos :: HasDebugCallStack => CoercionN -> Pair Type -> [Type] -> ([CoercionN], CoercionN)

-- | Attempts to obtain the type variable underlying a <a>Coercion</a>
getCoVar_maybe :: Coercion -> Maybe CoVar

-- | Attempts to tease a coercion apart into a type constructor and the
--   application of a number of coercion arguments to that constructor
splitTyConAppCo_maybe :: Coercion -> Maybe (TyCon, [Coercion])

-- | Attempt to take a coercion application apart.
splitAppCo_maybe :: Coercion -> Maybe (Coercion, Coercion)
splitFunCo_maybe :: Coercion -> Maybe (Coercion, Coercion)
splitForAllCo_maybe :: Coercion -> Maybe (TyCoVar, Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for tyvar
--   binder
splitForAllCo_ty_maybe :: Coercion -> Maybe (TyVar, Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for covar
--   binder
splitForAllCo_co_maybe :: Coercion -> Maybe (CoVar, Coercion, Coercion)
nthRole :: Role -> TyCon -> Int -> Role
tyConRolesX :: Role -> TyCon -> [Role]
tyConRolesRepresentational :: TyCon -> [Role]

-- | Converts a coercion to be nominal, if possible. See Note [Role
--   twiddling functions]
setNominalRole_maybe :: Role -> Coercion -> Maybe Coercion
pickLR :: LeftOrRight -> (a, a) -> a

-- | Tests if this coercion is obviously a generalized reflexive coercion.
--   Guaranteed to work very quickly.
isGReflCo :: Coercion -> Bool

-- | Tests if this coercion is obviously reflexive. Guaranteed to work very
--   quickly. Sometimes a coercion can be reflexive, but not obviously so.
--   c.f. <a>isReflexiveCo</a>
isReflCo :: Coercion -> Bool

-- | Returns the type coerced if this coercion is reflexive. Guaranteed to
--   work very quickly. Sometimes a coercion can be reflexive, but not
--   obviously so. c.f. <a>isReflexiveCo_maybe</a>
isReflCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Returns the type coerced if this coercion is a generalized reflexive
--   coercion. Guaranteed to work very quickly.
isGReflCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Slowly checks if the coercion is reflexive. Don't call this in a loop,
--   as it walks over the entire coercion.
isReflexiveCo :: Coercion -> Bool

-- | Extracts the coerced type from a reflexive coercion. This potentially
--   walks over the entire coercion, so avoid doing this in a loop.
isReflexiveCo_maybe :: Coercion -> Maybe (Type, Role)
isReflCoVar_maybe :: Var -> Maybe Coercion

-- | Tests if this MCoercion is obviously generalized reflexive Guaranteed
--   to work very quickly.
isGReflMCo :: MCoercion -> Bool
mkGReflLeftMCo :: Role -> Type -> MCoercionN -> Coercion
mkGReflRightMCo :: Role -> Type -> MCoercionN -> Coercion

-- | Like <a>mkCoherenceRightCo</a>, but with an <a>MCoercion</a>
mkCoherenceRightMCo :: Role -> Type -> MCoercionN -> Coercion -> Coercion
coToMCo :: Coercion -> MCoercion

-- | Compose two MCoercions via transitivity
mkTransMCo :: MCoercion -> MCoercion -> MCoercion
mkTransMCoL :: MCoercion -> Coercion -> MCoercion
mkTransMCoR :: Coercion -> MCoercion -> MCoercion

-- | Cast a type by an <a>MCoercion</a>
mkCastTyMCo :: Type -> MCoercion -> Type

-- | Get the reverse of an <a>MCoercion</a>
mkSymMCo :: MCoercion -> MCoercion
mkHomoForAllMCo :: TyCoVar -> MCoercion -> MCoercion
mkFunResMCo :: Scaled Type -> MCoercionR -> MCoercionR
mkPiMCos :: [Var] -> MCoercion -> MCoercion
checkReflexiveMCo :: MCoercion -> MCoercion
isReflMCo :: MCoercion -> Bool
mkCoVar :: Name -> Type -> CoVar

-- | Is this a coercion variable? Satisfies <tt><a>isId</a> v ==&gt;
--   <a>isCoVar</a> v == not (<a>isNonCoVarId</a> v)</tt>.
isCoVar :: Var -> Bool
coVarName :: CoVar -> Name
setCoVarName :: CoVar -> Name -> CoVar
setCoVarUnique :: CoVar -> Unique -> CoVar

-- | Extract a covar, if possible. This check is dirty. Be ashamed of
--   yourself. (It's dirty because it cares about the structure of a
--   coercion, which is morally reprehensible.)
isCoVar_maybe :: Coercion -> Maybe CoVar
tyCoVarsOfCo :: Coercion -> TyCoVarSet
tyCoVarsOfCos :: [Coercion] -> TyCoVarSet
coVarsOfCo :: Coercion -> CoVarSet
tyCoFVsOfCo :: Coercion -> FV
tyCoFVsOfCos :: [Coercion] -> FV

-- | Get a deterministic set of the vars free in a coercion
tyCoVarsOfCoDSet :: Coercion -> DTyCoVarSet
coercionSize :: Coercion -> Int
anyFreeVarsOfCo :: (TyCoVar -> Bool) -> Coercion -> Bool

-- | A substitution of <a>Coercion</a>s for <a>CoVar</a>s
type CvSubstEnv = CoVarEnv Coercion
emptyCvSubstEnv :: CvSubstEnv
lookupCoVar :: TCvSubst -> Var -> Maybe Coercion

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasCallStack => TCvSubst -> Coercion -> Coercion

-- | Substitute within several <a>Coercion</a>s The substitution has to
--   satisfy the invariants described in Note [The substitution invariant].
substCos :: HasCallStack => TCvSubst -> [Coercion] -> [Coercion]
substCoVar :: TCvSubst -> CoVar -> Coercion
substCoVars :: TCvSubst -> [CoVar] -> [Coercion]

-- | Coercion substitution, see <a>zipTvSubst</a>
substCoWith :: HasCallStack => [TyVar] -> [Type] -> Coercion -> Coercion
substCoVarBndr :: HasCallStack => TCvSubst -> CoVar -> (TCvSubst, CoVar)
extendTvSubstAndInScope :: TCvSubst -> TyVar -> Type -> TCvSubst
getCvSubstEnv :: TCvSubst -> CvSubstEnv

-- | <tt>liftCoSubst role lc ty</tt> produces a coercion (at role
--   <tt>role</tt>) that coerces between <tt>lc_left(ty)</tt> and
--   <tt>lc_right(ty)</tt>, where <tt>lc_left</tt> is a substitution
--   mapping type variables to the left-hand types of the mapped coercions
--   in <tt>lc</tt>, and similar for <tt>lc_right</tt>.
liftCoSubst :: HasDebugCallStack => Role -> LiftingContext -> Type -> Coercion
liftCoSubstTyVar :: LiftingContext -> Role -> TyVar -> Maybe Coercion
liftCoSubstWith :: Role -> [TyCoVar] -> [Coercion] -> Type -> Coercion
liftCoSubstWithEx :: Role -> [TyVar] -> [Coercion] -> [TyCoVar] -> [Type] -> (Type -> Coercion, [Type])
emptyLiftingContext :: InScopeSet -> LiftingContext

-- | Extend a lifting context with a new mapping.
extendLiftingContext :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext

-- | Extend a lifting context with a new mapping, and extend the in-scope
--   set
extendLiftingContextAndInScope :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext
liftCoSubstVarBndrUsing :: (LiftingContext -> Type -> (CoercionN, a)) -> LiftingContext -> TyCoVar -> (LiftingContext, TyCoVar, CoercionN, a)

-- | Is a var in the domain of a lifting context?
isMappedByLC :: TyCoVar -> LiftingContext -> Bool
mkSubstLiftingContext :: TCvSubst -> LiftingContext

-- | Erase the environments in a lifting context
zapLiftingContext :: LiftingContext -> LiftingContext

-- | Like <a>substForAllCoBndr</a>, but works on a lifting context
substForAllCoBndrUsingLC :: Bool -> (Coercion -> Coercion) -> LiftingContext -> TyCoVar -> Coercion -> (LiftingContext, TyCoVar, Coercion)

-- | Extract the underlying substitution from the LiftingContext
lcTCvSubst :: LiftingContext -> TCvSubst

-- | Get the <a>InScopeSet</a> from a <a>LiftingContext</a>
lcInScopeSet :: LiftingContext -> InScopeSet
type LiftCoEnv = VarEnv Coercion
data LiftingContext
LC :: TCvSubst -> LiftCoEnv -> LiftingContext
liftEnvSubstLeft :: TCvSubst -> LiftCoEnv -> TCvSubst
liftEnvSubstRight :: TCvSubst -> LiftCoEnv -> TCvSubst
substRightCo :: LiftingContext -> Coercion -> Coercion
substLeftCo :: LiftingContext -> Coercion -> Coercion

-- | Apply "sym" to all coercions in a <a>LiftCoEnv</a>
swapLiftCoEnv :: LiftCoEnv -> LiftCoEnv
lcSubstLeft :: LiftingContext -> TCvSubst
lcSubstRight :: LiftingContext -> TCvSubst

-- | Syntactic equality of coercions
eqCoercion :: Coercion -> Coercion -> Bool

-- | Compare two <a>Coercion</a>s, with respect to an RnEnv2
eqCoercionX :: RnEnv2 -> Coercion -> Coercion -> Bool
seqCo :: Coercion -> ()
pprCo :: Coercion -> SDoc
pprParendCo :: Coercion -> SDoc
pprCoAxiom :: CoAxiom br -> SDoc
pprCoAxBranch :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchLHS :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchUser :: TyCon -> CoAxBranch -> SDoc
tidyCoAxBndrsForUser :: TidyEnv -> [Var] -> (TidyEnv, [Var])
etaExpandCoAxBranch :: CoAxBranch -> ([TyVar], [Type], Type)

-- | Tidy a Coercion
--   
--   See Note [Strictness in tidyType and friends]
tidyCo :: TidyEnv -> Coercion -> Coercion
tidyCos :: TidyEnv -> [Coercion] -> [Coercion]

-- | like mkKindCo, but aggressively &amp; recursively optimizes to avoid
--   using a KindCo constructor. The output role is nominal.
promoteCoercion :: Coercion -> CoercionN

-- | Assuming that two types are the same, ignoring coercions, find a
--   nominal coercion between the types. This is useful when optimizing
--   transitivity over coercion applications, where splitting two AppCos
--   might yield different kinds. See Note [EtaAppCo] in
--   <a>GHC.Core.Coercion.Opt</a>.
buildCoercion :: Type -> Type -> CoercionN
multToCo :: Mult -> Coercion
simplifyArgsWorker :: [TyCoBinder] -> Kind -> TyCoVarSet -> [Role] -> [(Type, Coercion)] -> ([Type], [Coercion], MCoercionN)

-- | Is there a coercion hole in this type?
hasCoercionHoleTy :: Type -> Bool

-- | Is there a coercion hole in this coercion?
hasCoercionHoleCo :: Coercion -> Bool

-- | A set of <a>CoercionHole</a>s
type HoleSet = UniqSet CoercionHole

-- | Extract out all the coercion holes from a given type
coercionHolesOfType :: Type -> UniqSet CoercionHole
coercionHolesOfCo :: Coercion -> UniqSet CoercionHole
instance GHC.Utils.Outputable.Outputable GHC.Core.Coercion.LiftingContext
instance GHC.Utils.Outputable.Outputable ev => GHC.Utils.Outputable.Outputable (GHC.Core.Coercion.NormaliseStepResult ev)


-- | Commonly useful utilities for manipulating the Core language
module GHC.Core.Utils

-- | Wrap the given expression in the coercion safely, dropping identity
--   coercions and coalescing nested coercions
mkCast :: CoreExpr -> CoercionR -> CoreExpr
mkCastMCo :: CoreExpr -> MCoercionR -> CoreExpr
mkPiMCo :: Var -> MCoercionR -> MCoercionR

-- | Wraps the given expression in the source annotation, dropping the
--   annotation if possible.
mkTick :: CoreTickish -> CoreExpr -> CoreExpr
mkTicks :: [CoreTickish] -> CoreExpr -> CoreExpr
mkTickNoHNF :: CoreTickish -> CoreExpr -> CoreExpr
tickHNFArgs :: CoreTickish -> CoreExpr -> CoreExpr

-- | <tt>bindNonRec x r b</tt> produces either:
--   
--   <pre>
--   let x = r in b
--   </pre>
--   
--   or:
--   
--   <pre>
--   case r of x { _DEFAULT_ -&gt; b }
--   </pre>
--   
--   depending on whether we have to use a <tt>case</tt> or <tt>let</tt>
--   binding for the expression (see <a>needsCaseBinding</a>). It's used by
--   the desugarer to avoid building bindings that give Core Lint a heart
--   attack, although actually the simplifier deals with them perfectly
--   well. See also <a>mkCoreLet</a>
bindNonRec :: Id -> CoreExpr -> CoreExpr -> CoreExpr

-- | Tests whether we have to use a <tt>case</tt> rather than <tt>let</tt>
--   binding for this expression as per the invariants of <a>CoreExpr</a>:
--   see <a>GHC.Core#let_app_invariant</a>
needsCaseBinding :: Type -> CoreExpr -> Bool

-- | This guy constructs the value that the scrutinee must have given that
--   you are in one particular branch of a case
mkAltExpr :: AltCon -> [CoreBndr] -> [Type] -> CoreExpr
mkDefaultCase :: CoreExpr -> Id -> CoreExpr -> CoreExpr
mkSingleAltCase :: CoreExpr -> Id -> AltCon -> [Var] -> CoreExpr -> CoreExpr

-- | Extract the default case alternative
findDefault :: [Alt b] -> ([Alt b], Maybe (Expr b))
addDefault :: [Alt b] -> Maybe (Expr b) -> [Alt b]

-- | Find the case alternative corresponding to a particular constructor:
--   panics if no such constructor exists
findAlt :: AltCon -> [Alt b] -> Maybe (Alt b)
isDefaultAlt :: Alt b -> Bool

-- | Merge alternatives preserving order; alternatives in the first
--   argument shadow ones in the second
mergeAlts :: [Alt a] -> [Alt a] -> [Alt a]

-- | Given:
--   
--   <pre>
--   case (C a b x y) of
--          C b x y -&gt; ...
--   </pre>
--   
--   We want to drop the leading type argument of the scrutinee leaving the
--   arguments to match against the pattern
trimConArgs :: AltCon -> [CoreArg] -> [CoreArg]
filterAlts :: TyCon -> [Type] -> [AltCon] -> [Alt b] -> ([AltCon], [Alt b])
combineIdenticalAlts :: [AltCon] -> [CoreAlt] -> (Bool, [AltCon], [CoreAlt])

-- | Refine the default alternative to a <a>DataAlt</a>, if there is a
--   unique way to do so. See Note [Refine DEFAULT case alternatives]
refineDefaultAlt :: [Unique] -> Mult -> TyCon -> [Type] -> [AltCon] -> [CoreAlt] -> (Bool, [CoreAlt])
scaleAltsBy :: Mult -> [CoreAlt] -> [CoreAlt]

-- | Recover the type of a well-typed Core expression. Fails when applied
--   to the actual <a>Type</a> expression as it cannot really be said to
--   have a type
exprType :: CoreExpr -> Type

-- | Returns the type of the alternatives right hand side
coreAltType :: CoreAlt -> Type

-- | Returns the type of the first alternative, which should be the same as
--   for all alternatives
coreAltsType :: [CoreAlt] -> Type

-- | Makes a <tt>(-&gt;)</tt> type or an implicit forall type, depending on
--   whether it is given a type variable or a term variable. This is used,
--   for example, when producing the type of a lambda. Always uses Inferred
--   binders.
mkLamType :: Var -> Type -> Type

-- | <a>mkLamType</a> for multiple type or value arguments
mkLamTypes :: [Var] -> Type -> Type
mkFunctionType :: Mult -> Type -> Type -> Type

-- | Is this expression levity polymorphic? This should be the same as
--   saying (isKindLevPoly . typeKind . exprType) but much faster.
isExprLevPoly :: CoreExpr -> Bool
exprIsDupable :: Platform -> CoreExpr -> Bool
exprIsTrivial :: CoreExpr -> Bool
getIdFromTrivialExpr :: HasDebugCallStack => CoreExpr -> Id
exprIsDeadEnd :: CoreExpr -> Bool
getIdFromTrivialExpr_maybe :: CoreExpr -> Maybe Id
exprIsCheap :: CoreExpr -> Bool
exprIsExpandable :: CoreExpr -> Bool
exprIsCheapX :: CheapAppFun -> CoreExpr -> Bool
type CheapAppFun = Id -> Arity -> Bool

-- | exprIsHNF returns true for expressions that are certainly
--   <i>already</i> evaluated to <i>head</i> normal form. This is used to
--   decide whether it's ok to change:
--   
--   <pre>
--   case x of _ -&gt; e
--   </pre>
--   
--   into:
--   
--   <pre>
--   e
--   </pre>
--   
--   and to decide whether it's safe to discard a <a>seq</a>.
--   
--   So, it does <i>not</i> treat variables as evaluated, unless they say
--   they are. However, it <i>does</i> treat partial applications and
--   constructor applications as values, even if their arguments are
--   non-trivial, provided the argument type is lifted. For example, both
--   of these are values:
--   
--   <pre>
--   (:) (f x) (map f xs)
--   map (...redex...)
--   </pre>
--   
--   because <a>seq</a> on such things completes immediately.
--   
--   For unlifted argument types, we have to be careful:
--   
--   <pre>
--   C (f x :: Int#)
--   </pre>
--   
--   Suppose <tt>f x</tt> diverges; then <tt>C (f x)</tt> is not a value.
--   However this can't happen: see <a>GHC.Core#let_app_invariant</a>. This
--   invariant states that arguments of unboxed type must be
--   ok-for-speculation (or trivial).
exprIsHNF :: CoreExpr -> Bool

-- | <a>exprOkForSpeculation</a> returns True of an expression that is:
--   
--   <ul>
--   <li>Safe to evaluate even if normal order eval might not evaluate the
--   expression at all, or</li>
--   <li>Safe <i>not</i> to evaluate even if normal order would do so</li>
--   </ul>
--   
--   It is usually called on arguments of unlifted type, but not always In
--   particular, Simplify.rebuildCase calls it on lifted types when a
--   'case' is a plain <a>seq</a>. See the example in Note
--   [exprOkForSpeculation: case expressions] below
--   
--   Precisely, it returns <tt>True</tt> iff: a) The expression guarantees
--   to terminate, b) soon, c) without causing a write side effect (e.g.
--   writing a mutable variable) d) without throwing a Haskell exception e)
--   without risking an unchecked runtime exception (array out of bounds,
--   divide by zero)
--   
--   For <tt>exprOkForSideEffects</tt> the list is the same, but omitting
--   (e).
--   
--   Note that exprIsHNF implies exprOkForSpeculation exprOkForSpeculation
--   implies exprOkForSideEffects
--   
--   See Note [PrimOp can_fail and has_side_effects] in
--   <a>GHC.Builtin.PrimOps</a> and Note [Transformations affected by
--   can_fail and has_side_effects]
--   
--   As an example of the considerations in this test, consider:
--   
--   <pre>
--   let x = case y# +# 1# of { r# -&gt; I# r# }
--   in E
--   </pre>
--   
--   being translated to:
--   
--   <pre>
--   case y# +# 1# of { r# -&gt;
--      let x = I# r#
--      in E
--   }
--   </pre>
--   
--   We can only do this if the <tt>y + 1</tt> is ok for speculation: it
--   has no side effects, and can't diverge or raise an exception.
exprOkForSpeculation :: CoreExpr -> Bool

-- | <a>exprOkForSpeculation</a> returns True of an expression that is:
--   
--   <ul>
--   <li>Safe to evaluate even if normal order eval might not evaluate the
--   expression at all, or</li>
--   <li>Safe <i>not</i> to evaluate even if normal order would do so</li>
--   </ul>
--   
--   It is usually called on arguments of unlifted type, but not always In
--   particular, Simplify.rebuildCase calls it on lifted types when a
--   'case' is a plain <a>seq</a>. See the example in Note
--   [exprOkForSpeculation: case expressions] below
--   
--   Precisely, it returns <tt>True</tt> iff: a) The expression guarantees
--   to terminate, b) soon, c) without causing a write side effect (e.g.
--   writing a mutable variable) d) without throwing a Haskell exception e)
--   without risking an unchecked runtime exception (array out of bounds,
--   divide by zero)
--   
--   For <tt>exprOkForSideEffects</tt> the list is the same, but omitting
--   (e).
--   
--   Note that exprIsHNF implies exprOkForSpeculation exprOkForSpeculation
--   implies exprOkForSideEffects
--   
--   See Note [PrimOp can_fail and has_side_effects] in
--   <a>GHC.Builtin.PrimOps</a> and Note [Transformations affected by
--   can_fail and has_side_effects]
--   
--   As an example of the considerations in this test, consider:
--   
--   <pre>
--   let x = case y# +# 1# of { r# -&gt; I# r# }
--   in E
--   </pre>
--   
--   being translated to:
--   
--   <pre>
--   case y# +# 1# of { r# -&gt;
--      let x = I# r#
--      in E
--   }
--   </pre>
--   
--   We can only do this if the <tt>y + 1</tt> is ok for speculation: it
--   has no side effects, and can't diverge or raise an exception.
exprOkForSideEffects :: CoreExpr -> Bool
exprIsWorkFree :: CoreExpr -> Bool

-- | Similar to <a>exprIsHNF</a> but includes CONLIKE functions as well as
--   data constructors. Conlike arguments are considered interesting by the
--   inliner.
exprIsConLike :: CoreExpr -> Bool
isCheapApp :: CheapAppFun
isExpandableApp :: CheapAppFun

-- | Check if the expression is zero or more Ticks wrapped around a literal
--   string.
exprIsTickedString :: CoreExpr -> Bool

-- | Extract a literal string from an expression that is zero or more Ticks
--   wrapped around a literal string. Returns Nothing if the expression has
--   a different shape. Used to "look through" Ticks in places that need to
--   handle literal strings.
exprIsTickedString_maybe :: CoreExpr -> Maybe ByteString

-- | Can we bind this <a>CoreExpr</a> at the top level?
exprIsTopLevelBindable :: CoreExpr -> Type -> Bool
altsAreExhaustive :: [Alt b] -> Bool

-- | A cheap equality test which bales out fast! If it returns
--   <tt>True</tt> the arguments are definitely equal, otherwise, they may
--   or may not be equal.
cheapEqExpr :: Expr b -> Expr b -> Bool

-- | Cheap expression equality test, can ignore ticks by type.
cheapEqExpr' :: (CoreTickish -> Bool) -> Expr b -> Expr b -> Bool
eqExpr :: InScopeSet -> CoreExpr -> CoreExpr -> Bool

-- | Finds differences between core expressions, modulo alpha and renaming.
--   Setting <tt>top</tt> means that the <tt>IdInfo</tt> of bindings will
--   be checked for differences as well.
diffExpr :: Bool -> RnEnv2 -> CoreExpr -> CoreExpr -> [SDoc]

-- | Finds differences between core bindings, see <tt>diffExpr</tt>.
--   
--   The main problem here is that while we expect the binds to have the
--   same order in both lists, this is not guaranteed. To do this properly
--   we'd either have to do some sort of unification or check all possible
--   mappings, which would be seriously expensive. So instead we simply
--   match single bindings as far as we can. This leaves us just with
--   mutually recursive and/or mismatching bindings, which we then
--   speculatively match by ordering them. It's by no means perfect, but
--   gets the job done well enough.
diffBinds :: Bool -> RnEnv2 -> [(Var, CoreExpr)] -> [(Var, CoreExpr)] -> ([SDoc], RnEnv2)
tryEtaReduce :: [Var] -> CoreExpr -> Maybe CoreExpr
zapLamBndrs :: FullArgCount -> [Var] -> [Var]

-- | If the expression is a <a>Expr</a>, converts. Otherwise, panics. NB:
--   This does <i>not</i> convert <a>Expr</a> to <tt>CoercionTy</tt>.
exprToType :: CoreExpr -> Type

-- | If the expression is a <a>Expr</a>, converts.
exprToCoercion_maybe :: CoreExpr -> Maybe Coercion

-- | A more efficient version of <a>applyTypeToArg</a> when we have several
--   arguments. The first argument is just for debugging, and gives some
--   context
applyTypeToArgs :: SDoc -> Type -> [CoreExpr] -> Type

-- | Determines the type resulting from applying an expression with given
--   type to a given argument expression
applyTypeToArg :: Type -> CoreExpr -> Type
dataConRepInstPat :: [Unique] -> Mult -> DataCon -> [Type] -> ([TyCoVar], [Id])
dataConRepFSInstPat :: [FastString] -> [Unique] -> Mult -> DataCon -> [Type] -> ([TyCoVar], [Id])

-- | True if the type has no non-bottom elements, e.g. when it is an empty
--   datatype, or a GADT with non-satisfiable type parameters, e.g. Int :~:
--   Bool. See Note [Bottoming expressions]
--   
--   See Note [No alternatives lint check] for another use of this
--   function.
isEmptyTy :: Type -> Bool

-- | Strip ticks satisfying a predicate from top of an expression
stripTicksTop :: (CoreTickish -> Bool) -> Expr b -> ([CoreTickish], Expr b)

-- | Strip ticks satisfying a predicate from top of an expression,
--   returning the remaining expression
stripTicksTopE :: (CoreTickish -> Bool) -> Expr b -> Expr b

-- | Strip ticks satisfying a predicate from top of an expression,
--   returning the ticks
stripTicksTopT :: (CoreTickish -> Bool) -> Expr b -> [CoreTickish]

-- | Completely strip ticks satisfying a predicate from an expression. Note
--   this is O(n) in the size of the expression!
stripTicksE :: (CoreTickish -> Bool) -> Expr b -> Expr b
stripTicksT :: (CoreTickish -> Bool) -> Expr b -> [CoreTickish]

-- | <tt>collectMakeStaticArgs (makeStatic t srcLoc e)</tt> yields <tt>Just
--   (makeStatic, t, srcLoc, e)</tt>.
--   
--   Returns <tt>Nothing</tt> for every other expression.
collectMakeStaticArgs :: CoreExpr -> Maybe (CoreExpr, Type, CoreExpr, CoreExpr)

-- | Does this binding bind a join point (or a recursive group of join
--   points)?
isJoinBind :: CoreBind -> Bool
isUnsafeEqualityProof :: CoreExpr -> Bool
dumpIdInfoOfProgram :: (IdInfo -> SDoc) -> CoreProgram -> SDoc

module GHC.Core.Predicate

-- | A predicate in the solver. The solver tries to prove Wanted predicates
--   from Given ones.
data Pred
ClassPred :: Class -> [Type] -> Pred
EqPred :: EqRel -> Type -> Type -> Pred
IrredPred :: PredType -> Pred
ForAllPred :: [TyVar] -> [PredType] -> PredType -> Pred
classifyPredType :: PredType -> Pred
isPredTy :: HasDebugCallStack => Type -> Bool
isEvVarType :: Type -> Bool

-- | A choice of equality relation. This is separate from the type
--   <a>Role</a> because <a>Phantom</a> does not define a (non-trivial)
--   equality relation.
data EqRel
NomEq :: EqRel
ReprEq :: EqRel
eqRelRole :: EqRel -> Role
isEqPrimPred :: PredType -> Bool
isEqPred :: PredType -> Bool
getEqPredTys :: PredType -> (Type, Type)
getEqPredTys_maybe :: PredType -> Maybe (Role, Type, Type)
getEqPredRole :: PredType -> Role

-- | Get the equality relation relevant for a pred type.
predTypeEqRel :: PredType -> EqRel

-- | Creates a primitive type equality predicate. Invariant: the types are
--   not Coercions
mkPrimEqPred :: Type -> Type -> Type
mkReprPrimEqPred :: Type -> Type -> Type

-- | Makes a lifted equality predicate at the given role
mkPrimEqPredRole :: Role -> Type -> Type -> PredType

-- | Creates a primitive type equality predicate with explicit kinds
mkHeteroPrimEqPred :: Kind -> Kind -> Type -> Type -> Type

-- | Creates a primitive representational type equality predicate with
--   explicit kinds
mkHeteroReprPrimEqPred :: Kind -> Kind -> Type -> Type -> Type
mkClassPred :: Class -> [Type] -> PredType
isDictTy :: Type -> Bool
isClassPred :: PredType -> Bool
isEqPredClass :: Class -> Bool
isCTupleClass :: Class -> Bool
getClassPredTys :: HasDebugCallStack => PredType -> (Class, [Type])
getClassPredTys_maybe :: PredType -> Maybe (Class, [Type])
classMethodTy :: Id -> Type
classMethodInstTy :: Id -> [Type] -> Type
isIPLikePred :: Type -> Bool
hasIPSuperClasses :: Class -> [Type] -> Bool
isIPTyCon :: TyCon -> Bool
isIPClass :: Class -> Bool

-- | Dictionary Identifier
type DictId = EvId
isEvVar :: Var -> Bool
isDictId :: Id -> Bool
instance GHC.Classes.Ord GHC.Core.Predicate.EqRel
instance GHC.Classes.Eq GHC.Core.Predicate.EqRel
instance GHC.Utils.Outputable.Outputable GHC.Core.Predicate.EqRel

module GHC.Core.TyCon.RecWalk
data RecTcChecker

-- | Initialise a <a>RecTcChecker</a> with <a>defaultRecTcMaxBound</a>.
initRecTc :: RecTcChecker

-- | The default upper bound (100) for the number of times a
--   <a>RecTcChecker</a> is allowed to encounter each <a>TyCon</a>.
defaultRecTcMaxBound :: Int

-- | Change the upper bound for the number of times a <a>RecTcChecker</a>
--   is allowed to encounter each <a>TyCon</a>.
setRecTcMaxBound :: Int -> RecTcChecker -> RecTcChecker
checkRecTc :: RecTcChecker -> TyCon -> Maybe RecTcChecker
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.RecWalk.RecTcChecker

module GHC.Core.TyCon.Env

-- | TyCon Environment
type TyConEnv a = UniqFM TyCon a
mkTyConEnv :: [(TyCon, a)] -> TyConEnv a
mkTyConEnvWith :: (a -> TyCon) -> [a] -> TyConEnv a
emptyTyConEnv :: TyConEnv a
isEmptyTyConEnv :: TyConEnv a -> Bool
unitTyConEnv :: TyCon -> a -> TyConEnv a
nameEnvElts :: TyConEnv a -> [a]
extendTyConEnv_C :: (a -> a -> a) -> TyConEnv a -> TyCon -> a -> TyConEnv a
extendTyConEnv_Acc :: (a -> b -> b) -> (a -> b) -> TyConEnv b -> TyCon -> a -> TyConEnv b
extendTyConEnv :: TyConEnv a -> TyCon -> a -> TyConEnv a
extendTyConEnvList :: TyConEnv a -> [(TyCon, a)] -> TyConEnv a
extendTyConEnvList_C :: (a -> a -> a) -> TyConEnv a -> [(TyCon, a)] -> TyConEnv a
filterTyConEnv :: (elt -> Bool) -> TyConEnv elt -> TyConEnv elt
anyTyConEnv :: (elt -> Bool) -> TyConEnv elt -> Bool
plusTyConEnv :: TyConEnv a -> TyConEnv a -> TyConEnv a
plusTyConEnv_C :: (a -> a -> a) -> TyConEnv a -> TyConEnv a -> TyConEnv a
plusTyConEnv_CD :: (a -> a -> a) -> TyConEnv a -> a -> TyConEnv a -> a -> TyConEnv a
plusTyConEnv_CD2 :: (Maybe a -> Maybe a -> a) -> TyConEnv a -> TyConEnv a -> TyConEnv a
alterTyConEnv :: (Maybe a -> Maybe a) -> TyConEnv a -> TyCon -> TyConEnv a
lookupTyConEnv :: TyConEnv a -> TyCon -> Maybe a
lookupTyConEnv_NF :: TyConEnv a -> TyCon -> a
delFromTyConEnv :: TyConEnv a -> TyCon -> TyConEnv a
delListFromTyConEnv :: TyConEnv a -> [TyCon] -> TyConEnv a
elemTyConEnv :: TyCon -> TyConEnv a -> Bool
mapTyConEnv :: (elt1 -> elt2) -> TyConEnv elt1 -> TyConEnv elt2
disjointTyConEnv :: TyConEnv a -> TyConEnv a -> Bool

-- | Deterministic TyCon Environment
--   
--   See Note [Deterministic UniqFM] in <a>GHC.Types.Unique.DFM</a> for
--   explanation why we need DTyConEnv.
type DTyConEnv a = UniqDFM TyCon a
emptyDTyConEnv :: DTyConEnv a
isEmptyDTyConEnv :: DTyConEnv a -> Bool
lookupDTyConEnv :: DTyConEnv a -> TyCon -> Maybe a
delFromDTyConEnv :: DTyConEnv a -> TyCon -> DTyConEnv a
filterDTyConEnv :: (a -> Bool) -> DTyConEnv a -> DTyConEnv a
mapDTyConEnv :: (a -> b) -> DTyConEnv a -> DTyConEnv b
mapMaybeDTyConEnv :: (a -> Maybe b) -> DTyConEnv a -> DTyConEnv b
adjustDTyConEnv :: (a -> a) -> DTyConEnv a -> TyCon -> DTyConEnv a
alterDTyConEnv :: (Maybe a -> Maybe a) -> DTyConEnv a -> TyCon -> DTyConEnv a
extendDTyConEnv :: DTyConEnv a -> TyCon -> a -> DTyConEnv a
foldDTyConEnv :: (elt -> a -> a) -> a -> DTyConEnv elt -> a


-- | This module defines the semi-ring of multiplicities, and associated
--   functions. Multiplicities annotate arrow types to indicate the
--   linearity of the arrow (in the sense of linear types).
--   
--   Mult is a type synonym for Type, used only when its kind is
--   Multiplicity. To simplify dealing with multiplicities, functions such
--   as mkMultMul perform simplifications such as Many * x = Many on the
--   fly.
module GHC.Core.Multiplicity

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type
pattern One :: Mult
pattern Many :: Mult
isMultMul :: Mult -> Maybe (Mult, Mult)
mkMultAdd :: Mult -> Mult -> Mult
mkMultMul :: Mult -> Mult -> Mult

-- | <tt>mkMultSup w1 w2</tt> returns a multiplicity such that
--   <tt>mkMultSup w1 w2 &gt;= w1</tt> and <tt>mkMultSup w1 w2 &gt;=
--   w2</tt>. See Note [Overapproximating multiplicities].
mkMultSup :: Mult -> Mult -> Mult

-- | A shorthand for data with an attached <a>Mult</a> element (the
--   multiplicity).
data Scaled a
Scaled :: !Mult -> a -> Scaled a
scaledMult :: Scaled a -> Mult
scaledThing :: Scaled a -> a

-- | Scale a payload by Many
unrestricted :: a -> Scaled a

-- | Scale a payload by One
linear :: a -> Scaled a

-- | Scale a payload by Many; used for type arguments in core
tymult :: a -> Scaled a
irrelevantMult :: Scaled a -> a
mkScaled :: Mult -> a -> Scaled a
scaledSet :: Scaled a -> b -> Scaled b
scaleScaled :: Mult -> Scaled a -> Scaled a
data IsSubmult
Submult :: IsSubmult
Unknown :: IsSubmult

-- | <tt>submult w1 w2</tt> check whether a value of multiplicity
--   <tt>w1</tt> is allowed where a value of multiplicity <tt>w2</tt> is
--   expected. This is a partial order.
submult :: Mult -> Mult -> IsSubmult

-- | Apply a function to both the Mult and the Type in a 'Scaled Type'
mapScaledType :: (Type -> Type) -> Scaled Type -> Scaled Type
instance GHC.Classes.Eq GHC.Core.Multiplicity.IsSubmult
instance GHC.Show.Show GHC.Core.Multiplicity.IsSubmult
instance GHC.Utils.Outputable.Outputable GHC.Core.Multiplicity.IsSubmult


-- | This module is about types that can be defined in Haskell, but which
--   must be wired into the compiler nonetheless. C.f module
--   <a>GHC.Builtin.Types.Prim</a>
module GHC.Builtin.Types
mkWiredInTyConName :: BuiltInSyntax -> Module -> FastString -> Unique -> TyCon -> Name
mkWiredInIdName :: Module -> FastString -> Unique -> Id -> Name
wiredInTyCons :: [TyCon]

-- | Built-in syntax isn't "in scope" so these OccNames map to wired-in
--   Names with BuiltInSyntax. However, this should only be necessary while
--   resolving names produced by Template Haskell splices since we take
--   care to encode built-in syntax names specially in interface files. See
--   Note [Symbol table representation of names].
--   
--   Moreover, there is no need to include names of things that the user
--   can't write (e.g. type representation bindings like $tc(,,,)).
isBuiltInOcc_maybe :: OccName -> Maybe Name
boolTy :: Type
boolTyCon :: TyCon
boolTyCon_RDR :: RdrName
boolTyConName :: Name
trueDataCon :: DataCon
trueDataConId :: Id
true_RDR :: RdrName
falseDataCon :: DataCon
falseDataConId :: Id
false_RDR :: RdrName
promotedFalseDataCon :: TyCon
promotedTrueDataCon :: TyCon
orderingTyCon :: TyCon
ordLTDataCon :: DataCon
ordLTDataConId :: Id
ordEQDataCon :: DataCon
ordEQDataConId :: Id
ordGTDataCon :: DataCon
ordGTDataConId :: Id
promotedLTDataCon :: TyCon
promotedEQDataCon :: TyCon
promotedGTDataCon :: TyCon
boxingDataCon_maybe :: TyCon -> Maybe DataCon
charTyCon :: TyCon
charDataCon :: DataCon
charTyCon_RDR :: RdrName
charTy :: Type
stringTy :: Type
charTyConName :: Name
stringTyCon_RDR :: RdrName
doubleTyCon :: TyCon
doubleDataCon :: DataCon
doubleTy :: Type
doubleTyConName :: Name
floatTyCon :: TyCon
floatDataCon :: DataCon
floatTy :: Type
floatTyConName :: Name
intTyCon :: TyCon
intDataCon :: DataCon
intTyCon_RDR :: RdrName
intDataCon_RDR :: RdrName
intTyConName :: Name
intTy :: Type
wordTyCon :: TyCon
wordDataCon :: DataCon
wordTyConName :: Name
wordTy :: Type
word8TyCon :: TyCon
word8DataCon :: DataCon
word8Ty :: Type
listTyCon :: TyCon
listTyCon_RDR :: RdrName
listTyConName :: Name
listTyConKey :: Unique
nilDataCon :: DataCon
nilDataConName :: Name
nilDataConKey :: Unique
consDataCon_RDR :: RdrName
consDataCon :: DataCon
consDataConName :: Name
promotedNilDataCon :: TyCon
promotedConsDataCon :: TyCon
mkListTy :: Type -> Type

-- | Make a *promoted* list.
mkPromotedListTy :: Kind -> [Type] -> Type
nonEmptyTyCon :: TyCon
nonEmptyTyConName :: Name
nonEmptyDataCon :: DataCon
nonEmptyDataConName :: Name
maybeTyCon :: TyCon
maybeTyConName :: Name
nothingDataCon :: DataCon
nothingDataConName :: Name
promotedNothingDataCon :: TyCon
justDataCon :: DataCon
justDataConName :: Name
promotedJustDataCon :: TyCon
mkPromotedMaybeTy :: Kind -> Maybe Type -> Type
mkMaybeTy :: Type -> Kind
isPromotedMaybeTy :: Type -> Maybe (Maybe Type)

-- | Make a tuple type. The list of types should <i>not</i> include any
--   RuntimeRep specifications. Boxed 1-tuples are flattened. See Note
--   [One-tuples]
mkTupleTy :: Boxity -> [Type] -> Type

-- | Make a tuple type. The list of types should <i>not</i> include any
--   RuntimeRep specifications. Boxed 1-tuples are *not* flattened. See
--   Note [One-tuples] and Note [Don't flatten tuples from HsSyn] in
--   <a>GHC.Core.Make</a>
mkTupleTy1 :: Boxity -> [Type] -> Type

-- | Build the type of a small tuple that holds the specified type of thing
--   Flattens 1-tuples. See Note [One-tuples].
mkBoxedTupleTy :: [Type] -> Type
mkTupleStr :: Boxity -> Arity -> String
tupleTyCon :: Boxity -> Arity -> TyCon
tupleDataCon :: Boxity -> Arity -> DataCon
tupleTyConName :: TupleSort -> Arity -> Name
tupleDataConName :: Boxity -> Arity -> Name
promotedTupleDataCon :: Boxity -> Arity -> TyCon
unitTyCon :: TyCon
unitDataCon :: DataCon
unitDataConId :: Id
unitTy :: Type
unitTyConKey :: Unique
soloTyCon :: TyCon
pairTyCon :: TyCon
mkPromotedPairTy :: Kind -> Kind -> Type -> Type -> Type
isPromotedPairType :: Type -> Maybe (Type, Type)
unboxedUnitTy :: Type
unboxedUnitTyCon :: TyCon
unboxedUnitDataCon :: DataCon

-- | Specialization of <a>unboxedTupleSumKind</a> for tuples
unboxedTupleKind :: [Type] -> Kind

-- | Specialization of <a>unboxedTupleSumKind</a> for sums
unboxedSumKind :: [Type] -> Kind

-- | Replaces constraint tuple names with corresponding boxed ones.
filterCTuple :: RdrName -> RdrName
cTupleTyCon :: Arity -> TyCon
cTupleTyConName :: Arity -> Name
cTupleTyConNames :: [Name]
isCTupleTyConName :: Name -> Bool

-- | If the given name is that of a constraint tuple, return its arity.
cTupleTyConNameArity_maybe :: Name -> Maybe Arity
cTupleDataCon :: Arity -> DataCon
cTupleDataConName :: Arity -> Name
cTupleDataConNames :: [Name]
cTupleSelId :: ConTag -> Arity -> Id
cTupleSelIdName :: ConTag -> Arity -> Name
anyTyCon :: TyCon
anyTy :: Type
anyTypeOfKind :: Kind -> Type

-- | Make a fake, recovery <a>TyCon</a> from an existing one. Used when
--   recovering from errors in type declarations
makeRecoveryTyCon :: TyCon -> TyCon
mkSumTy :: [Type] -> Type

-- | Type constructor for n-ary unboxed sum.
sumTyCon :: Arity -> TyCon

-- | Data constructor for i-th alternative of a n-ary unboxed sum.
sumDataCon :: ConTag -> Arity -> DataCon
typeSymbolKindCon :: TyCon
typeSymbolKind :: Kind
isLiftedTypeKindTyConName :: Name -> Bool
typeToTypeKind :: Kind

-- | <pre>
--   type LiftedRep = 'BoxedRep 'Lifted
--   </pre>
liftedRepTyCon :: TyCon

-- | <pre>
--   type UnliftedRep = 'BoxedRep 'Unlifted
--   </pre>
unliftedRepTyCon :: TyCon
constraintKind :: Kind
liftedTypeKind :: Kind
unliftedTypeKind :: Kind
constraintKindTyCon :: TyCon
liftedTypeKindTyCon :: TyCon

-- | <pre>
--   type UnliftedType = TYPE ('BoxedRep 'Unlifted)
--   </pre>
unliftedTypeKindTyCon :: TyCon
constraintKindTyConName :: Name
liftedTypeKindTyConName :: Name
unliftedTypeKindTyConName :: Name
liftedRepTyConName :: Name
unliftedRepTyConName :: Name
heqTyCon :: TyCon
heqTyConName :: Name
heqClass :: Class
heqDataCon :: DataCon
eqTyCon :: TyCon
eqTyConName :: Name
eqClass :: Class
eqDataCon :: DataCon
eqTyCon_RDR :: RdrName
coercibleTyCon :: TyCon
coercibleTyConName :: Name
coercibleDataCon :: DataCon
coercibleClass :: Class
runtimeRepTyCon :: TyCon
levityTyCon :: TyCon
vecCountTyCon :: TyCon
vecElemTyCon :: TyCon
boxedRepDataConTyCon :: TyCon
runtimeRepTy :: Type
liftedRepTy :: Type
unliftedRepTy :: Type
vecRepDataConTyCon :: TyCon
tupleRepDataConTyCon :: TyCon
sumRepDataConTyCon :: TyCon
liftedDataConTyCon :: TyCon
unliftedDataConTyCon :: TyCon
liftedDataConTy :: Type
unliftedDataConTy :: Type
intRepDataConTy :: Type
int8RepDataConTy :: Type
int16RepDataConTy :: Type
int32RepDataConTy :: Type
int64RepDataConTy :: Type
wordRepDataConTy :: Type
word8RepDataConTy :: Type
word16RepDataConTy :: Type
word32RepDataConTy :: Type
word64RepDataConTy :: Type
addrRepDataConTy :: Type
floatRepDataConTy :: Type
doubleRepDataConTy :: Type
vec2DataConTy :: Type
vec4DataConTy :: Type
vec8DataConTy :: Type
vec16DataConTy :: Type
vec32DataConTy :: Type
vec64DataConTy :: Type
int8ElemRepDataConTy :: Type
int16ElemRepDataConTy :: Type
int32ElemRepDataConTy :: Type
int64ElemRepDataConTy :: Type
word8ElemRepDataConTy :: Type
word16ElemRepDataConTy :: Type
word32ElemRepDataConTy :: Type
word64ElemRepDataConTy :: Type
floatElemRepDataConTy :: Type
doubleElemRepDataConTy :: Type
multiplicityTyConName :: Name
oneDataConName :: Name
manyDataConName :: Name
multiplicityTy :: Type
multiplicityTyCon :: TyCon
oneDataCon :: DataCon
manyDataCon :: DataCon
oneDataConTy :: Type
manyDataConTy :: Type
oneDataConTyCon :: TyCon
manyDataConTyCon :: TyCon
multMulTyCon :: TyCon
unrestrictedFunTyCon :: TyCon
unrestrictedFunTyConName :: Name
integerTy :: Type
integerTyCon :: TyCon
integerTyConName :: Name
integerISDataCon :: DataCon
integerISDataConName :: Name
integerIPDataCon :: DataCon
integerIPDataConName :: Name
integerINDataCon :: DataCon
integerINDataConName :: Name
naturalTy :: Type
naturalTyCon :: TyCon
naturalTyConName :: Name
naturalNSDataCon :: DataCon
naturalNSDataConName :: Name
naturalNBDataCon :: DataCon
naturalNBDataConName :: Name


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see
--   <a>GHC.Types.Name.Occurrence#name_types</a></li>
--   <li><a>RdrName</a> is the type of names that come directly from the
--   parser. They have not yet had their scoping and binding resolved by
--   the renamer and can be thought of to a first approximation as an
--   <a>OccName</a> with an optional module qualifier</li>
--   <li><a>Name</a>: see <a>GHC.Types.Name#name_types</a></li>
--   <li><a>Id</a>: see <a>GHC.Types.Id#name_types</a></li>
--   <li><a>Var</a>: see <a>GHC.Types.Var#name_types</a></li>
--   </ul>
module GHC.Types.Name.Reader

-- | Reader Name
--   
--   Do not use the data constructors of RdrName directly: prefer the
--   family of functions that creates them, such as <a>mkRdrUnqual</a>
--   
--   <ul>
--   <li>Note: A Located RdrName will only have API Annotations if it is a
--   compound one, e.g.</li>
--   </ul>
--   
--   <pre>
--   `bar`
--   ( ~ )
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnOpen</a> <tt>'('</tt>
--   or <tt>'['</tt> or <tt>'[:'</tt>, <a>AnnClose</a> <tt>')'</tt> or
--   <tt>']'</tt> or <tt>':]'</tt>,, <a>AnnBackquote</a> <tt>'`'</tt>,
--   <a>AnnVal</a> <a>AnnTilde</a>,</li>
--   </ul>
data RdrName

-- | Unqualified name
--   
--   Used for ordinary, unqualified occurrences, e.g. <tt>x</tt>,
--   <tt>y</tt> or <tt>Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrUnqual</a>
Unqual :: OccName -> RdrName

-- | Qualified name
--   
--   A qualified name written by the user in <i>source</i> code. The module
--   isn't necessarily the module where the thing is defined; just the one
--   from which it is imported. Examples are <tt>Bar.x</tt>, <tt>Bar.y</tt>
--   or <tt>Bar.Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrQual</a>
Qual :: ModuleName -> OccName -> RdrName

-- | Original name
--   
--   An original name; the module is the <i>defining</i> module. This is
--   used when GHC generates code that will be fed into the renamer (e.g.
--   from deriving clauses), but where we want to say "Use Prelude.map
--   dammit". One of these can be created with <a>mkOrig</a>
Orig :: Module -> OccName -> RdrName

-- | Exact name
--   
--   We know exactly the <a>Name</a>. This is used:
--   
--   <ol>
--   <li>When the parser parses built-in syntax like <tt>[]</tt> and
--   <tt>(,)</tt>, but wants a <a>RdrName</a> from it</li>
--   <li>By Template Haskell, when TH has generated a unique name</li>
--   </ol>
--   
--   Such a <a>RdrName</a> can be created by using <a>getRdrName</a> on a
--   <a>Name</a>
Exact :: Name -> RdrName
mkRdrUnqual :: OccName -> RdrName
mkRdrQual :: ModuleName -> OccName -> RdrName
mkUnqual :: NameSpace -> FastString -> RdrName
mkVarUnqual :: FastString -> RdrName

-- | Make a qualified <a>RdrName</a> in the given namespace and where the
--   <a>ModuleName</a> and the <a>OccName</a> are taken from the first and
--   second elements of the tuple respectively
mkQual :: NameSpace -> (FastString, FastString) -> RdrName
mkOrig :: Module -> OccName -> RdrName
nameRdrName :: Name -> RdrName
getRdrName :: NamedThing thing => thing -> RdrName
rdrNameOcc :: RdrName -> OccName
rdrNameSpace :: RdrName -> NameSpace
demoteRdrName :: RdrName -> Maybe RdrName
promoteRdrName :: RdrName -> Maybe RdrName
isRdrDataCon :: RdrName -> Bool
isRdrTyVar :: RdrName -> Bool
isRdrTc :: RdrName -> Bool
isQual :: RdrName -> Bool
isQual_maybe :: RdrName -> Maybe (ModuleName, OccName)
isUnqual :: RdrName -> Bool
isOrig :: RdrName -> Bool
isOrig_maybe :: RdrName -> Maybe (Module, OccName)
isExact :: RdrName -> Bool
isExact_maybe :: RdrName -> Maybe Name
isSrcRdrName :: RdrName -> Bool

-- | Local Reader Environment See Note [LocalRdrEnv]
data LocalRdrEnv
emptyLocalRdrEnv :: LocalRdrEnv
extendLocalRdrEnv :: LocalRdrEnv -> Name -> LocalRdrEnv
extendLocalRdrEnvList :: LocalRdrEnv -> [Name] -> LocalRdrEnv
lookupLocalRdrEnv :: LocalRdrEnv -> RdrName -> Maybe Name
lookupLocalRdrOcc :: LocalRdrEnv -> OccName -> Maybe Name
elemLocalRdrEnv :: RdrName -> LocalRdrEnv -> Bool
inLocalRdrEnvScope :: Name -> LocalRdrEnv -> Bool
localRdrEnvElts :: LocalRdrEnv -> [Name]
delLocalRdrEnvList :: LocalRdrEnv -> [OccName] -> LocalRdrEnv

-- | Global Reader Environment
--   
--   Keyed by <a>OccName</a>; when looking up a qualified name we look up
--   the <a>OccName</a> part, and then check the <tt>Provenance</tt> to see
--   if the appropriate qualification is valid. This saves routinely
--   doubling the size of the env by adding both qualified and unqualified
--   names to the domain.
--   
--   The list in the codomain is required because there may be name clashes
--   These only get reported on lookup, not on construction
--   
--   INVARIANT 1: All the members of the list have distinct <a>gre_name</a>
--   fields; that is, no duplicate Names
--   
--   INVARIANT 2: Imported provenance =&gt; Name is an ExternalName However
--   LocalDefs can have an InternalName. This happens only when
--   type-checking a [d| ... |] Template Haskell quotation; see this note
--   in GHC.Rename.Names Note [Top-level Names in Template Haskell decl
--   quotes]
--   
--   INVARIANT 3: If the GlobalRdrEnv maps [occ -&gt; gre], then greOccName
--   gre = occ
--   
--   NB: greOccName gre is usually the same as nameOccName (greMangledName
--   gre), but not always in the case of record selectors; see Note
--   [GreNames]
type GlobalRdrEnv = OccEnv [GlobalRdrElt]
emptyGlobalRdrEnv :: GlobalRdrEnv
mkGlobalRdrEnv :: [GlobalRdrElt] -> GlobalRdrEnv
plusGlobalRdrEnv :: GlobalRdrEnv -> GlobalRdrEnv -> GlobalRdrEnv
lookupGlobalRdrEnv :: GlobalRdrEnv -> OccName -> [GlobalRdrElt]
extendGlobalRdrEnv :: GlobalRdrEnv -> GlobalRdrElt -> GlobalRdrEnv

-- | See Note [GreNames]
greOccName :: GlobalRdrElt -> OccName
shadowNames :: GlobalRdrEnv -> [GreName] -> GlobalRdrEnv
pprGlobalRdrEnv :: Bool -> GlobalRdrEnv -> SDoc
globalRdrEnvElts :: GlobalRdrEnv -> [GlobalRdrElt]

-- | Look for this <a>RdrName</a> in the global environment. Omits record
--   fields without selector functions (see Note [NoFieldSelectors] in
--   GHC.Rename.Env).
lookupGRE_RdrName :: RdrName -> GlobalRdrEnv -> [GlobalRdrElt]

-- | Look for this <a>RdrName</a> in the global environment. Includes
--   record fields without selector functions (see Note [NoFieldSelectors]
--   in GHC.Rename.Env).
lookupGRE_RdrName' :: RdrName -> GlobalRdrEnv -> [GlobalRdrElt]

-- | Look for precisely this <a>Name</a> in the environment. This tests
--   whether it is in scope, ignoring anything else that might be in scope
--   with the same <a>OccName</a>.
lookupGRE_Name :: GlobalRdrEnv -> Name -> Maybe GlobalRdrElt

-- | Look for precisely this <a>GreName</a> in the environment. This tests
--   whether it is in scope, ignoring anything else that might be in scope
--   with the same <a>OccName</a>.
lookupGRE_GreName :: GlobalRdrEnv -> GreName -> Maybe GlobalRdrElt

-- | Look for a particular record field selector in the environment, where
--   the selector name and field label may be different: the GlobalRdrEnv
--   is keyed on the label. See Note [GreNames] for why this happens.
lookupGRE_FieldLabel :: GlobalRdrEnv -> FieldLabel -> Maybe GlobalRdrElt

-- | Look for precisely this <a>Name</a> in the environment, but with an
--   <a>OccName</a> that might differ from that of the <a>Name</a>. See
--   <a>lookupGRE_FieldLabel</a> and Note [GreNames].
lookupGRE_Name_OccName :: GlobalRdrEnv -> Name -> OccName -> Maybe GlobalRdrElt
getGRE_NameQualifier_maybes :: GlobalRdrEnv -> Name -> [Maybe [ModuleName]]

-- | Apply a transformation function to the GREs for these OccNames
transformGREs :: (GlobalRdrElt -> GlobalRdrElt) -> [OccName] -> GlobalRdrEnv -> GlobalRdrEnv

-- | Takes a list of GREs which have the right OccName <tt>x</tt> Pick
--   those GREs that are in scope * Qualified, as <a>x</a> if want_qual is
--   Qual M _ * Unqualified, as <tt>x</tt> if want_unqual is Unqual _
--   
--   Return each such GRE, with its ImportSpecs filtered, to reflect how it
--   is in scope qualified or unqualified respectively. See Note [GRE
--   filtering]
pickGREs :: RdrName -> [GlobalRdrElt] -> [GlobalRdrElt]

-- | Pick GREs that are in scope *both* qualified *and* unqualified Return
--   each GRE that is, as a pair (qual_gre, unqual_gre) These two GREs are
--   the original GRE with imports filtered to express how it is in scope
--   qualified an unqualified respectively
--   
--   Used only for the 'module M' item in export list; see
--   <a>exports_from_avail</a>
pickGREsModExp :: ModuleName -> [GlobalRdrElt] -> [(GlobalRdrElt, GlobalRdrElt)]

-- | make a <a>GlobalRdrEnv</a> where all the elements point to the same
--   Provenance (useful for "hiding" imports, or imports with no details).
gresFromAvails :: Maybe ImportSpec -> [AvailInfo] -> [GlobalRdrElt]
gresFromAvail :: (Name -> Maybe ImportSpec) -> AvailInfo -> [GlobalRdrElt]
localGREsFromAvail :: AvailInfo -> [GlobalRdrElt]
availFromGRE :: GlobalRdrElt -> AvailInfo
greRdrNames :: GlobalRdrElt -> [RdrName]
greSrcSpan :: GlobalRdrElt -> SrcSpan
greQualModName :: GlobalRdrElt -> ModuleName

-- | Takes a list of distinct GREs and folds them into AvailInfos. This is
--   more efficient than mapping each individual GRE to an AvailInfo and
--   the folding using <a>plusAvail</a> but needs the uniqueness
--   assumption.
gresToAvailInfo :: [GlobalRdrElt] -> [AvailInfo]

-- | The module in which the name pointed to by the GRE is defined.
greDefinitionModule :: GlobalRdrElt -> Maybe Module

-- | The SrcSpan of the name pointed to by the GRE.
greDefinitionSrcSpan :: GlobalRdrElt -> SrcSpan

-- | A <a>Name</a> for the GRE for internal use. Careful: the
--   <a>OccName</a> of this <a>Name</a> is not necessarily the same as the
--   <a>greOccName</a> (see Note [GreNames]).
greMangledName :: GlobalRdrElt -> Name

-- | A <a>Name</a> for the GRE suitable for output to the user. Its
--   <a>OccName</a> will be the <a>greOccName</a> (see Note [GreNames]).
grePrintableName :: GlobalRdrElt -> Name

-- | Returns the field label of this GRE, if it has one
greFieldLabel :: GlobalRdrElt -> Maybe FieldLabel

-- | Global Reader Element
--   
--   An element of the <a>GlobalRdrEnv</a>
data GlobalRdrElt
GRE :: !GreName -> !Parent -> !Bool -> ![ImportSpec] -> GlobalRdrElt

-- | See Note [GreNames]
[gre_name] :: GlobalRdrElt -> !GreName

-- | See Note [Parents]
[gre_par] :: GlobalRdrElt -> !Parent

-- | True <a>=</a> the thing was defined locally
[gre_lcl] :: GlobalRdrElt -> !Bool

-- | In scope through these imports
[gre_imp] :: GlobalRdrElt -> ![ImportSpec]
isLocalGRE :: GlobalRdrElt -> Bool
isRecFldGRE :: GlobalRdrElt -> Bool

-- | Is this a record field defined with DuplicateRecordFields? (See Note
--   [GreNames])
isDuplicateRecFldGRE :: GlobalRdrElt -> Bool

-- | Is this a record field defined with NoFieldSelectors? (See Note
--   [NoFieldSelectors] in GHC.Rename.Env)
isNoFieldSelectorGRE :: GlobalRdrElt -> Bool

-- | Is this a record field defined with FieldSelectors? (See Note
--   [NoFieldSelectors] in GHC.Rename.Env)
isFieldSelectorGRE :: GlobalRdrElt -> Bool

-- | Test if an unqualified version of this thing would be in scope
unQualOK :: GlobalRdrElt -> Bool

-- | Is in scope qualified with the given module?
qualSpecOK :: ModuleName -> ImportSpec -> Bool

-- | Is in scope unqualified?
unQualSpecOK :: ImportSpec -> Bool

-- | Print out one place where the name was define/imported (With
--   -dppr-debug, print them all)
pprNameProvenance :: GlobalRdrElt -> SDoc

-- | Used where we may have an ordinary name or a record field label. See
--   Note [GreNames] in GHC.Types.Name.Reader.
data GreName
NormalGreName :: Name -> GreName
FieldGreName :: FieldLabel -> GreName
greNameSrcSpan :: GreName -> SrcSpan

-- | See Note [Parents]
data Parent
NoParent :: Parent
ParentIs :: Name -> Parent
[par_is] :: Parent -> Name
greParent_maybe :: GlobalRdrElt -> Maybe Name

-- | Import Specification
--   
--   The <a>ImportSpec</a> of something says how it came to be imported
--   It's quite elaborate so that we can give accurate unused-name
--   warnings.
data ImportSpec
ImpSpec :: ImpDeclSpec -> ImpItemSpec -> ImportSpec
[is_decl] :: ImportSpec -> ImpDeclSpec
[is_item] :: ImportSpec -> ImpItemSpec

-- | Import Declaration Specification
--   
--   Describes a particular import declaration and is shared among all the
--   <tt>Provenance</tt>s for that decl
data ImpDeclSpec
ImpDeclSpec :: ModuleName -> ModuleName -> Bool -> SrcSpan -> ImpDeclSpec

-- | Module imported, e.g. <tt>import Muggle</tt> Note the <tt>Muggle</tt>
--   may well not be the defining module for this thing!
[is_mod] :: ImpDeclSpec -> ModuleName

-- | Import alias, e.g. from <tt>as M</tt> (or <tt>Muggle</tt> if there is
--   no <tt>as</tt> clause)
[is_as] :: ImpDeclSpec -> ModuleName

-- | Was this import qualified?
[is_qual] :: ImpDeclSpec -> Bool

-- | The location of the entire import declaration
[is_dloc] :: ImpDeclSpec -> SrcSpan

-- | Import Item Specification
--   
--   Describes import info a particular Name
data ImpItemSpec

-- | The import had no import list, or had a hiding list
ImpAll :: ImpItemSpec

-- | The import had an import list. The <a>is_explicit</a> field is
--   <tt>True</tt> iff the thing was named <i>explicitly</i> in the import
--   specs rather than being imported as part of a "..." group. Consider:
--   
--   <pre>
--   import C( T(..) )
--   </pre>
--   
--   Here the constructors of <tt>T</tt> are not named explicitly; only
--   <tt>T</tt> is named explicitly.
ImpSome :: Bool -> SrcSpan -> ImpItemSpec
[is_explicit] :: ImpItemSpec -> Bool
[is_iloc] :: ImpItemSpec -> SrcSpan
importSpecLoc :: ImportSpec -> SrcSpan
importSpecModule :: ImportSpec -> ModuleName
isExplicitItem :: ImpItemSpec -> Bool
bestImport :: [ImportSpec] -> ImportSpec

-- | Display info about the treatment of <a>*</a> under NoStarIsType.
--   
--   With StarIsType, three properties of <a>*</a> hold:
--   
--   (a) it is not an infix operator (b) it is always in scope (c) it is a
--   synonym for Data.Kind.Type
--   
--   However, the user might not know that they are working on a module
--   with NoStarIsType and write code that still assumes (a), (b), and (c),
--   which actually do not hold in that module.
--   
--   Violation of (a) shows up in the parser. For instance, in the
--   following examples, we have <a>*</a> not applied to enough arguments:
--   
--   data A :: * data F :: * -&gt; *
--   
--   Violation of (b) or (c) show up in the renamer and the typechecker
--   respectively. For instance:
--   
--   type K = Either * Bool
--   
--   This will parse differently depending on whether StarIsType is
--   enabled, but it will parse nonetheless. With NoStarIsType it is parsed
--   as a type operator, thus we have ((*) Either Bool). Now there are two
--   cases to consider:
--   
--   <ol>
--   <li>There is no definition of (*) in scope. In this case the renamer
--   will fail to look it up. This is a violation of assumption (b).</li>
--   <li>There is a definition of the (*) type operator in scope (for
--   example coming from GHC.TypeNats). In this case the user will get a
--   kind mismatch error. This is a violation of assumption (c).</li>
--   </ol>
--   
--   The user might unknowingly be working on a module with NoStarIsType or
--   use <a>*</a> as <a>Type</a> out of habit. So it is important to give a
--   hint whenever an assumption about <a>*</a> is violated. Unfortunately,
--   it is somewhat difficult to deal with (c), so we limit ourselves to
--   (a) and (b).
--   
--   <a>starInfo</a> generates an appropriate hint to the user depending on
--   the extensions enabled in the module and the name that triggered the
--   error. That is, if we have NoStarIsType and the error is related to
--   <a>*</a> or its Unicode variant, the resulting SDoc will contain a
--   helpful suggestion. Otherwise it is empty.
starInfo :: Bool -> RdrName -> SDoc

-- | Indicate if the given name is the "@" operator
opIsAt :: RdrName -> Bool
instance Data.Data.Data GHC.Types.Name.Reader.RdrName
instance Data.Data.Data GHC.Types.Name.Reader.Parent
instance GHC.Classes.Eq GHC.Types.Name.Reader.Parent
instance Data.Data.Data GHC.Types.Name.Reader.ImpDeclSpec
instance GHC.Classes.Eq GHC.Types.Name.Reader.ImpDeclSpec
instance Data.Data.Data GHC.Types.Name.Reader.ImpItemSpec
instance GHC.Classes.Eq GHC.Types.Name.Reader.ImpItemSpec
instance Data.Data.Data GHC.Types.Name.Reader.ImportSpec
instance GHC.Classes.Eq GHC.Types.Name.Reader.ImportSpec
instance GHC.Classes.Eq GHC.Types.Name.Reader.GlobalRdrElt
instance Data.Data.Data GHC.Types.Name.Reader.GlobalRdrElt
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Name.Reader.GlobalRdrElt
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.GlobalRdrElt
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.ImportSpec
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.Parent
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.LocalRdrEnv
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Name.Reader.RdrName
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.RdrName
instance GHC.Utils.Outputable.OutputableBndr GHC.Types.Name.Reader.RdrName
instance GHC.Classes.Eq GHC.Types.Name.Reader.RdrName
instance GHC.Classes.Ord GHC.Types.Name.Reader.RdrName

module GHC.Types.Avail

-- | A collection of <a>AvailInfo</a> - several things that are "available"
type Avails = [AvailInfo]

-- | Records what things are "available", i.e. in scope
data AvailInfo

-- | An ordinary identifier in scope, or a field label without a parent
--   type (see Note [Representing pattern synonym fields in AvailInfo]).
Avail :: GreName -> AvailInfo

-- | A type or class in scope
--   
--   The <b>AvailTC Invariant</b>: If the type or class is itself to be in
--   scope, it must be <i>first</i> in this list. Thus, typically:
--   
--   <pre>
--   AvailTC Eq [Eq, ==, \/=]
--   </pre>
AvailTC :: Name -> [GreName] -> AvailInfo
avail :: Name -> AvailInfo
availField :: FieldLabel -> AvailInfo
availTC :: Name -> [Name] -> [FieldLabel] -> AvailInfo
availsToNameSet :: [AvailInfo] -> NameSet
availsToNameSetWithSelectors :: [AvailInfo] -> NameSet
availsToNameEnv :: [AvailInfo] -> NameEnv AvailInfo

-- | Does this <a>AvailInfo</a> export the parent decl? This depends on the
--   invariant that the parent is first if it appears at all.
availExportsDecl :: AvailInfo -> Bool

-- | Just the main name made available, i.e. not the available pieces of
--   type or class brought into scope by the <a>AvailInfo</a>
availName :: AvailInfo -> Name
availGreName :: AvailInfo -> GreName

-- | All names made available by the availability information (excluding
--   overloaded selectors)
availNames :: AvailInfo -> [Name]

-- | Names for non-fields made available by the availability information
availNonFldNames :: AvailInfo -> [Name]

-- | All names made available by the availability information (including
--   overloaded selectors)
availNamesWithSelectors :: AvailInfo -> [Name]

-- | Fields made available by the availability information
availFlds :: AvailInfo -> [FieldLabel]

-- | Names and fields made available by the availability information.
availGreNames :: AvailInfo -> [GreName]

-- | Names and fields made available by the availability information, other
--   than the main decl itself.
availSubordinateGreNames :: AvailInfo -> [GreName]

-- | Compare lexicographically
stableAvailCmp :: AvailInfo -> AvailInfo -> Ordering
plusAvail :: AvailInfo -> AvailInfo -> AvailInfo

-- | trims an <a>AvailInfo</a> to keep only a single name
trimAvail :: AvailInfo -> Name -> AvailInfo

-- | filters an <a>AvailInfo</a> by the given predicate
filterAvail :: (Name -> Bool) -> AvailInfo -> [AvailInfo] -> [AvailInfo]

-- | filters <a>AvailInfo</a>s by the given predicate
filterAvails :: (Name -> Bool) -> [AvailInfo] -> [AvailInfo]

-- | Combines <a>AvailInfo</a>s from the same family <tt>avails</tt> may
--   have several items with the same availName E.g import Ix( Ix(..),
--   index ) will give Ix(Ix,index,range) and Ix(index) We want to combine
--   these; addAvail does that
nubAvails :: [AvailInfo] -> [AvailInfo]

-- | Used where we may have an ordinary name or a record field label. See
--   Note [GreNames] in GHC.Types.Name.Reader.
data GreName
NormalGreName :: Name -> GreName
FieldGreName :: FieldLabel -> GreName

-- | A <a>Name</a> for internal use, but not for output to the user. For
--   fields, the <a>OccName</a> will be the selector. See Note [GreNames]
--   in GHC.Types.Name.Reader.
greNameMangledName :: GreName -> Name

-- | A <a>Name</a> suitable for output to the user. For fields, the
--   <a>OccName</a> will be the field label. See Note [GreNames] in
--   GHC.Types.Name.Reader.
greNamePrintableName :: GreName -> Name
greNameSrcSpan :: GreName -> SrcSpan
greNameFieldLabel :: GreName -> Maybe FieldLabel
partitionGreNames :: [GreName] -> ([Name], [FieldLabel])
stableGreNameCmp :: GreName -> GreName -> Ordering
instance GHC.Classes.Eq GHC.Types.Avail.GreName
instance Data.Data.Data GHC.Types.Avail.GreName
instance Data.Data.Data GHC.Types.Avail.AvailInfo
instance GHC.Classes.Eq GHC.Types.Avail.AvailInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Avail.AvailInfo
instance GHC.Utils.Binary.Binary GHC.Types.Avail.AvailInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Avail.GreName
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Avail.GreName
instance GHC.Utils.Binary.Binary GHC.Types.Avail.GreName


-- | Boolean formulas without quantifiers and without negation. Such a
--   formula consists of variables, conjunctions (and), and disjunctions
--   (or).
--   
--   This module is used to represent minimal complete definitions for
--   classes.
module GHC.Data.BooleanFormula
data BooleanFormula a
Var :: a -> BooleanFormula a
And :: [LBooleanFormula a] -> BooleanFormula a
Or :: [LBooleanFormula a] -> BooleanFormula a
Parens :: LBooleanFormula a -> BooleanFormula a
type LBooleanFormula a = LocatedL (BooleanFormula a)
mkFalse :: BooleanFormula a
mkTrue :: BooleanFormula a
mkAnd :: Eq a => [LBooleanFormula a] -> BooleanFormula a
mkOr :: Eq a => [LBooleanFormula a] -> BooleanFormula a
mkVar :: a -> BooleanFormula a
isFalse :: BooleanFormula a -> Bool
isTrue :: BooleanFormula a -> Bool
eval :: (a -> Bool) -> BooleanFormula a -> Bool
simplify :: Eq a => (a -> Maybe Bool) -> BooleanFormula a -> BooleanFormula a
isUnsatisfied :: Eq a => (a -> Bool) -> BooleanFormula a -> Maybe (BooleanFormula a)
implies :: Uniquable a => BooleanFormula a -> BooleanFormula a -> Bool
impliesAtom :: Eq a => BooleanFormula a -> a -> Bool
pprBooleanFormula :: (Rational -> a -> SDoc) -> Rational -> BooleanFormula a -> SDoc
pprBooleanFormulaNice :: Outputable a => BooleanFormula a -> SDoc
instance Data.Traversable.Traversable GHC.Data.BooleanFormula.BooleanFormula
instance Data.Foldable.Foldable GHC.Data.BooleanFormula.BooleanFormula
instance GHC.Base.Functor GHC.Data.BooleanFormula.BooleanFormula
instance Data.Data.Data a => Data.Data.Data (GHC.Data.BooleanFormula.BooleanFormula a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Data.BooleanFormula.BooleanFormula a)
instance GHC.Utils.Outputable.OutputableBndr a => GHC.Utils.Outputable.Outputable (GHC.Data.BooleanFormula.BooleanFormula a)
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Data.BooleanFormula.BooleanFormula a)

module GHC.Parser.Annotation

-- | Exact print annotations exist so that tools can perform source to
--   source conversions of Haskell code. They are used to keep track of the
--   various syntactic keywords that are not otherwise captured in the AST.
--   
--   The wiki page describing this feature is
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/api-annotations</a>
--   <a>https://gitlab.haskell.org/ghc/ghc/-/wikis/implementing-trees-that-grow/in-tree-api-annotations</a>
--   
--   Note: in general the names of these are taken from the corresponding
--   token, unless otherwise noted See note [exact print annotations] above
--   for details of the usage
data AnnKeywordId
AnnAnyclass :: AnnKeywordId
AnnAs :: AnnKeywordId
AnnAt :: AnnKeywordId

-- | <tt>!</tt>
AnnBang :: AnnKeywordId

-- | '`'
AnnBackquote :: AnnKeywordId
AnnBy :: AnnKeywordId

-- | case or lambda case
AnnCase :: AnnKeywordId
AnnClass :: AnnKeywordId

-- | '#)' or '#-}' etc
AnnClose :: AnnKeywordId

-- | '|)'
AnnCloseB :: AnnKeywordId

-- | '|)', unicode variant
AnnCloseBU :: AnnKeywordId

-- | '}'
AnnCloseC :: AnnKeywordId

-- | '|]'
AnnCloseQ :: AnnKeywordId

-- | '|]', unicode variant
AnnCloseQU :: AnnKeywordId

-- | ')'
AnnCloseP :: AnnKeywordId

-- | '#)'
AnnClosePH :: AnnKeywordId

-- | ']'
AnnCloseS :: AnnKeywordId
AnnColon :: AnnKeywordId

-- | as a list separator
AnnComma :: AnnKeywordId

-- | in a RdrName for a tuple
AnnCommaTuple :: AnnKeywordId

-- | '=&gt;'
AnnDarrow :: AnnKeywordId

-- | '=&gt;', unicode variant
AnnDarrowU :: AnnKeywordId
AnnData :: AnnKeywordId

-- | '::'
AnnDcolon :: AnnKeywordId

-- | '::', unicode variant
AnnDcolonU :: AnnKeywordId
AnnDefault :: AnnKeywordId
AnnDeriving :: AnnKeywordId
AnnDo :: AnnKeywordId

-- | <a>.</a>
AnnDot :: AnnKeywordId

-- | '..'
AnnDotdot :: AnnKeywordId
AnnElse :: AnnKeywordId
AnnEqual :: AnnKeywordId
AnnExport :: AnnKeywordId
AnnFamily :: AnnKeywordId
AnnForall :: AnnKeywordId

-- | Unicode variant
AnnForallU :: AnnKeywordId
AnnForeign :: AnnKeywordId

-- | for function name in matches where there are multiple equations for
--   the function.
AnnFunId :: AnnKeywordId
AnnGroup :: AnnKeywordId

-- | for CType
AnnHeader :: AnnKeywordId
AnnHiding :: AnnKeywordId
AnnIf :: AnnKeywordId
AnnImport :: AnnKeywordId
AnnIn :: AnnKeywordId

-- | 'infix' or 'infixl' or 'infixr'
AnnInfix :: AnnKeywordId
AnnInstance :: AnnKeywordId
AnnLam :: AnnKeywordId

-- | '&lt;-'
AnnLarrow :: AnnKeywordId

-- | '&lt;-', unicode variant
AnnLarrowU :: AnnKeywordId
AnnLet :: AnnKeywordId

-- | The <tt>â¸</tt> unicode arrow
AnnLollyU :: AnnKeywordId
AnnMdo :: AnnKeywordId

-- | <a>-</a>
AnnMinus :: AnnKeywordId
AnnModule :: AnnKeywordId
AnnNewtype :: AnnKeywordId

-- | where a name loses its location in the AST, this carries it
AnnName :: AnnKeywordId
AnnOf :: AnnKeywordId

-- | '{-# DEPRECATED' etc. Opening of pragmas where the capitalisation of
--   the string can be changed by the user. The actual text used is stored
--   in a <tt>SourceText</tt> on the relevant pragma item.
AnnOpen :: AnnKeywordId

-- | '(|'
AnnOpenB :: AnnKeywordId

-- | '(|', unicode variant
AnnOpenBU :: AnnKeywordId

-- | '{'
AnnOpenC :: AnnKeywordId

-- | '[e|' or '[e||'
AnnOpenE :: AnnKeywordId

-- | '[|'
AnnOpenEQ :: AnnKeywordId

-- | '[|', unicode variant
AnnOpenEQU :: AnnKeywordId

-- | '('
AnnOpenP :: AnnKeywordId

-- | '['
AnnOpenS :: AnnKeywordId

-- | '(#'
AnnOpenPH :: AnnKeywordId

-- | prefix <a>$</a> -- TemplateHaskell
AnnDollar :: AnnKeywordId

-- | prefix <a>$$</a> -- TemplateHaskell
AnnDollarDollar :: AnnKeywordId
AnnPackageName :: AnnKeywordId
AnnPattern :: AnnKeywordId

-- | <tt>%</tt> -- for HsExplicitMult
AnnPercent :: AnnKeywordId

-- | '%1' -- for HsLinearArrow
AnnPercentOne :: AnnKeywordId
AnnProc :: AnnKeywordId
AnnQualified :: AnnKeywordId

-- | <tt>-&gt;</tt>
AnnRarrow :: AnnKeywordId

-- | <tt>-&gt;</tt>, unicode variant
AnnRarrowU :: AnnKeywordId
AnnRec :: AnnKeywordId
AnnRole :: AnnKeywordId
AnnSafe :: AnnKeywordId

-- | ';'
AnnSemi :: AnnKeywordId

-- | '''
AnnSimpleQuote :: AnnKeywordId
AnnSignature :: AnnKeywordId

-- | <tt>static</tt>
AnnStatic :: AnnKeywordId
AnnStock :: AnnKeywordId
AnnThen :: AnnKeywordId

-- | double '''
AnnThTyQuote :: AnnKeywordId

-- | <tt>~</tt>
AnnTilde :: AnnKeywordId
AnnType :: AnnKeywordId

-- | <tt>()</tt> for types
AnnUnit :: AnnKeywordId
AnnUsing :: AnnKeywordId

-- | e.g. INTEGER
AnnVal :: AnnKeywordId

-- | String value, will need quotes when output
AnnValStr :: AnnKeywordId

-- | '|'
AnnVbar :: AnnKeywordId

-- | <tt>via</tt>
AnnVia :: AnnKeywordId
AnnWhere :: AnnKeywordId

-- | <tt>-&lt;</tt>
Annlarrowtail :: AnnKeywordId

-- | <tt>-&lt;</tt>, unicode variant
AnnlarrowtailU :: AnnKeywordId

-- | <tt>-&gt;</tt>
Annrarrowtail :: AnnKeywordId

-- | <tt>-&gt;</tt>, unicode variant
AnnrarrowtailU :: AnnKeywordId

-- | <tt>-&lt;&lt;</tt>
AnnLarrowtail :: AnnKeywordId

-- | <tt>-&lt;&lt;</tt>, unicode variant
AnnLarrowtailU :: AnnKeywordId

-- | <tt>&gt;&gt;-</tt>
AnnRarrowtail :: AnnKeywordId

-- | <tt>&gt;&gt;-</tt>, unicode variant
AnnRarrowtailU :: AnnKeywordId
data EpaComment
EpaComment :: EpaCommentTok -> RealSrcSpan -> EpaComment
[ac_tok] :: EpaComment -> EpaCommentTok

-- | The location of the prior token, used in exact printing. The
--   <a>EpaComment</a> appears as an <a>LEpaComment</a> containing its
--   location. The difference between the end of the prior token and the
--   start of this location is used for the spacing when exact printing the
--   comment.
[ac_prior_tok] :: EpaComment -> RealSrcSpan
data EpaCommentTok

-- | something beginning '-- |'
EpaDocCommentNext :: String -> EpaCommentTok

-- | something beginning '-- ^'
EpaDocCommentPrev :: String -> EpaCommentTok

-- | something beginning '-- $'
EpaDocCommentNamed :: String -> EpaCommentTok

-- | a section heading
EpaDocSection :: Int -> String -> EpaCommentTok

-- | doc options (prune, ignore-exports, etc)
EpaDocOptions :: String -> EpaCommentTok

-- | comment starting by "--"
EpaLineComment :: String -> EpaCommentTok

-- | comment in {- -}
EpaBlockComment :: String -> EpaCommentTok

-- | empty comment, capturing location of EOF
EpaEofComment :: EpaCommentTok

-- | Certain tokens can have alternate representations when unicode syntax
--   is enabled. This flag is attached to those tokens in the lexer so that
--   the original source representation can be reproduced in the
--   corresponding <tt>EpAnnotation</tt>
data IsUnicodeSyntax
UnicodeSyntax :: IsUnicodeSyntax
NormalSyntax :: IsUnicodeSyntax

-- | Convert a normal annotation into its unicode equivalent one
unicodeAnn :: AnnKeywordId -> AnnKeywordId

-- | Some template haskell tokens have two variants, one with an <tt>e</tt>
--   the other not:
--   
--   <pre>
--   [| or [e|
--   [|| or [e||
--   </pre>
--   
--   This type indicates whether the <tt>e</tt> is present or not.
data HasE
HasE :: HasE
NoE :: HasE

-- | Captures an annotation, storing the <tt><a>AnnKeywordId</a></tt> and
--   its location. The parser only ever inserts <tt><a>EpaLocation</a></tt>
--   fields with a RealSrcSpan being the original location of the
--   annotation in the source file. The <tt><a>EpaLocation</a></tt> can
--   also store a delta position if the AST has been modified and needs to
--   be pretty printed again. The usual way an <a>AddEpAnn</a> is created
--   is using the <tt>mj</tt> ("make jump") function, and then it can be
--   inserted into the appropriate annotation.
data AddEpAnn
AddEpAnn :: AnnKeywordId -> EpaLocation -> AddEpAnn

-- | The anchor for an <tt><a>AnnKeywordId</a></tt>. The Parser inserts the
--   <tt><a>EpaSpan</a></tt> variant, giving the exact location of the
--   original item in the parsed source. This can be replaced by the
--   <tt><a>EpaDelta</a></tt> version, to provide a position for the item
--   relative to the end of the previous item in the source. This is useful
--   when editing an AST prior to exact printing the changed one. The list
--   of comments in the <tt><a>EpaDelta</a></tt> variant captures any
--   comments between the prior output and the thing being marked here,
--   since we cannot otherwise sort the relative order.
data EpaLocation
EpaSpan :: !RealSrcSpan -> EpaLocation
EpaDelta :: !DeltaPos -> ![LEpaComment] -> EpaLocation

-- | Used in the parser only, extract the <a>SrcSpan</a> from an
--   <a>EpaLocation</a>. The parser will never insert a <a>DeltaPos</a>, so
--   the partial function is safe.
epaLocationRealSrcSpan :: EpaLocation -> RealSrcSpan
epaLocationFromSrcAnn :: SrcAnn ann -> EpaLocation

-- | Spacing between output items when exact printing. It captures the
--   spacing from the current print position on the page to the position
--   required for the thing about to be printed. This is either on the same
--   line in which case is is simply the number of spaces to emit, or it is
--   some number of lines down, with a given column offset. The exact
--   printing algorithm keeps track of the column offset pertaining to the
--   current anchor position, so the <a>deltaColumn</a> is the additional
--   spaces to add in this case. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/api-annotations</a> for
--   details.
data DeltaPos
SameLine :: !Int -> DeltaPos
[deltaColumn] :: DeltaPos -> !Int
DifferentLine :: !Int -> !Int -> DeltaPos

-- | deltaLine should always be &gt; 0
[deltaLine] :: DeltaPos -> !Int
[deltaColumn] :: DeltaPos -> !Int

-- | Smart constructor for a <a>DeltaPos</a>. It preserves the invariant
--   that for the <a>DifferentLine</a> constructor <a>deltaLine</a> is
--   always &gt; 0.
deltaPos :: Int -> Int -> DeltaPos
getDeltaLine :: DeltaPos -> Int

-- | The exact print annotations (EPAs) are kept in the HsSyn AST for the
--   GhcPs phase. We do not always have EPAs though, only for code that has
--   been parsed as they do not exist for generated code. This type
--   captures that they may be missing.
--   
--   A goal of the annotations is that an AST can be edited, including
--   moving subtrees from one place to another, duplicating them, and so
--   on. This means that each fragment must be self-contained. To this end,
--   each annotated fragment keeps track of the anchor position it was
--   originally captured at, being simply the start span of the topmost
--   element of the ast fragment. This gives us a way to later re-calculate
--   all Located items in this layer of the AST, as well as any annotations
--   captured. The comments associated with the AST fragment are also
--   captured here.
--   
--   The <a>ann</a> type parameter allows this general structure to be
--   specialised to the specific set of locations of original exact print
--   annotation elements. So for <tt>HsLet</tt> we have
--   
--   type instance XLet GhcPs = EpAnn AnnsLet data AnnsLet = AnnsLet {
--   alLet :: EpaLocation, alIn :: EpaLocation } deriving Data
--   
--   The spacing between the items under the scope of a given EpAnn is
--   normally derived from the original <a>Anchor</a>. But if a sub-element
--   is not in its original position, the required spacing can be directly
--   captured in the <a>anchor_op</a> field of the <a>entry</a> Anchor.
--   This allows us to freely move elements around, and stitch together new
--   AST fragments out of old ones, and have them still printed out in a
--   precise way.
data EpAnn ann
EpAnn :: !Anchor -> !ann -> !EpAnnComments -> EpAnn ann

-- | Base location for the start of the syntactic element holding the
--   annotations.
[entry] :: EpAnn ann -> !Anchor

-- | Annotations added by the Parser
[anns] :: EpAnn ann -> !ann

-- | Comments enclosed in the SrcSpan of the element this <a>EpAnn</a> is
--   attached to
[comments] :: EpAnn ann -> !EpAnnComments

-- | No Annotation for generated code, e.g. from TH, deriving, etc.
EpAnnNotUsed :: EpAnn ann

-- | An <a>Anchor</a> records the base location for the start of the
--   syntactic element holding the annotations, and is used as the point of
--   reference for calculating delta positions for contained annotations.
--   It is also normally used as the reference point for the spacing of the
--   element relative to its container. If it is moved, that relationship
--   is tracked in the <a>anchor_op</a> instead.
data Anchor
Anchor :: RealSrcSpan -> AnchorOperation -> Anchor

-- | Base location for the start of the syntactic element holding the
--   annotations.
[anchor] :: Anchor -> RealSrcSpan
[anchor_op] :: Anchor -> AnchorOperation

-- | If tools modify the parsed source, the <a>MovedAnchor</a> variant can
--   directly provide the spacing for this item relative to the previous
--   one when printing. This allows AST fragments with a particular anchor
--   to be freely moved, without worrying about recalculating the
--   appropriate anchor span.
data AnchorOperation
UnchangedAnchor :: AnchorOperation
MovedAnchor :: DeltaPos -> AnchorOperation
spanAsAnchor :: SrcSpan -> Anchor
realSpanAsAnchor :: RealSrcSpan -> Anchor

-- | Short form for <a>EpAnnNotUsed</a>
noAnn :: EpAnn a

-- | When we are parsing we add comments that belong a particular AST
--   element, and print them together with the element, interleaving them
--   into the output stream. But when editing the AST to move fragments
--   around it is useful to be able to first separate the comments into
--   those occuring before the AST element and those following it. The
--   <a>EpaCommentsBalanced</a> constructor is used to do this. The GHC
--   parser will only insert the <a>EpaComments</a> form.
data EpAnnComments
EpaComments :: ![LEpaComment] -> EpAnnComments
[priorComments] :: EpAnnComments -> ![LEpaComment]
EpaCommentsBalanced :: ![LEpaComment] -> ![LEpaComment] -> EpAnnComments
[priorComments] :: EpAnnComments -> ![LEpaComment]
[followingComments] :: EpAnnComments -> ![LEpaComment]
type LEpaComment = GenLocated Anchor EpaComment
emptyComments :: EpAnnComments
getFollowingComments :: EpAnnComments -> [LEpaComment]
setFollowingComments :: EpAnnComments -> [LEpaComment] -> EpAnnComments
setPriorComments :: EpAnnComments -> [LEpaComment] -> EpAnnComments
type EpAnnCO = EpAnn NoEpAnns " Api Annotations for comments only"
type LocatedA = GenLocated SrcSpanAnnA
type LocatedL = GenLocated SrcSpanAnnL
type LocatedC = GenLocated SrcSpanAnnC
type LocatedN = GenLocated SrcSpanAnnN

-- | General representation of a <a>GenLocated</a> type carrying a
--   parameterised annotation type.
type LocatedAn an = GenLocated (SrcAnn an)
type LocatedP = GenLocated SrcSpanAnnP
type SrcSpanAnnA = SrcAnn AnnListItem
type SrcSpanAnnL = SrcAnn AnnList
type SrcSpanAnnP = SrcAnn AnnPragma
type SrcSpanAnnC = SrcAnn AnnContext
type SrcSpanAnnN = SrcAnn NameAnn

-- | The 'SrcSpanAnn'' type wraps a normal <a>SrcSpan</a>, together with an
--   extra annotation type. This is mapped to a specific <a>GenLocated</a>
--   usage in the AST through the <tt>XRec</tt> and <tt>Anno</tt> type
--   families.
data SrcSpanAnn' a
SrcSpanAnn :: !a -> !SrcSpan -> SrcSpanAnn' a
[ann] :: SrcSpanAnn' a -> !a
[locA] :: SrcSpanAnn' a -> !SrcSpan

-- | We mostly use 'SrcSpanAnn'' with an 'EpAnn''
type SrcAnn ann = SrcSpanAnn' (EpAnn ann)

-- | Annotation for items appearing in a list. They can have one or more
--   trailing punctuations items, such as commas or semicolons.
data AnnListItem
AnnListItem :: [TrailingAnn] -> AnnListItem
[lann_trailing] :: AnnListItem -> [TrailingAnn]

-- | Annotation for the "container" of a list. This captures surrounding
--   items such as braces if present, and introductory keywords such as
--   'where'.
data AnnList
AnnList :: Maybe Anchor -> Maybe AddEpAnn -> Maybe AddEpAnn -> [AddEpAnn] -> [TrailingAnn] -> AnnList

-- | start point of a list having layout
[al_anchor] :: AnnList -> Maybe Anchor
[al_open] :: AnnList -> Maybe AddEpAnn
[al_close] :: AnnList -> Maybe AddEpAnn

-- | context, such as 'where' keyword
[al_rest] :: AnnList -> [AddEpAnn]

-- | items appearing after the list, such as '=&gt;' for a context
[al_trailing] :: AnnList -> [TrailingAnn]

-- | exact print annotation for an item having surrounding "brackets", such
--   as tuples or lists
data AnnParen
AnnParen :: ParenType -> EpaLocation -> EpaLocation -> AnnParen
[ap_adornment] :: AnnParen -> ParenType
[ap_open] :: AnnParen -> EpaLocation
[ap_close] :: AnnParen -> EpaLocation

-- | Detail of the "brackets" used in an <a>AnnParen</a> exact print
--   annotation.
data ParenType

-- | '(', ')'
AnnParens :: ParenType

-- | '(#', '#)'
AnnParensHash :: ParenType

-- | '[', ']'
AnnParensSquare :: ParenType

-- | Maps the <a>ParenType</a> to the related opening and closing
--   AnnKeywordId. Used when actually printing the item.
parenTypeKws :: ParenType -> (AnnKeywordId, AnnKeywordId)

-- | exact print annotation used for capturing the locations of annotations
--   in pragmas.
data AnnPragma
AnnPragma :: AddEpAnn -> AddEpAnn -> [AddEpAnn] -> AnnPragma
[apr_open] :: AnnPragma -> AddEpAnn
[apr_close] :: AnnPragma -> AddEpAnn
[apr_rest] :: AnnPragma -> [AddEpAnn]

-- | Exact print annotation for the <tt>Context</tt> data type.
data AnnContext
AnnContext :: Maybe (IsUnicodeSyntax, EpaLocation) -> [EpaLocation] -> [EpaLocation] -> AnnContext

-- | location and encoding of the '=&gt;', if present.
[ac_darrow] :: AnnContext -> Maybe (IsUnicodeSyntax, EpaLocation)

-- | zero or more opening parentheses.
[ac_open] :: AnnContext -> [EpaLocation]

-- | zero or more closing parentheses.
[ac_close] :: AnnContext -> [EpaLocation]

-- | exact print annotations for a <tt>RdrName</tt>. There are many kinds
--   of adornment that can be attached to a given <tt>RdrName</tt>. This
--   type captures them, as detailed on the individual constructors.
data NameAnn

-- | Used for a name with an adornment, so <tt>`foo`</tt>, <tt>(bar)</tt>
NameAnn :: NameAdornment -> EpaLocation -> EpaLocation -> EpaLocation -> [TrailingAnn] -> NameAnn
[nann_adornment] :: NameAnn -> NameAdornment
[nann_open] :: NameAnn -> EpaLocation
[nann_name] :: NameAnn -> EpaLocation
[nann_close] :: NameAnn -> EpaLocation
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for <tt>(,,,)</tt>, or @()#
NameAnnCommas :: NameAdornment -> EpaLocation -> [EpaLocation] -> EpaLocation -> [TrailingAnn] -> NameAnn
[nann_adornment] :: NameAnn -> NameAdornment
[nann_open] :: NameAnn -> EpaLocation
[nann_commas] :: NameAnn -> [EpaLocation]
[nann_close] :: NameAnn -> EpaLocation
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for <tt>()</tt>, <tt>(##)</tt>, <tt>[]</tt>
NameAnnOnly :: NameAdornment -> EpaLocation -> EpaLocation -> [TrailingAnn] -> NameAnn
[nann_adornment] :: NameAnn -> NameAdornment
[nann_open] :: NameAnn -> EpaLocation
[nann_close] :: NameAnn -> EpaLocation
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for <tt>-&gt;</tt>, as an identifier
NameAnnRArrow :: EpaLocation -> [TrailingAnn] -> NameAnn
[nann_name] :: NameAnn -> EpaLocation
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for an item with a leading <tt>'</tt>. The annotation for
--   unquoted item is stored in <a>nann_quoted</a>.
NameAnnQuote :: EpaLocation -> SrcSpanAnnN -> [TrailingAnn] -> NameAnn
[nann_quote] :: NameAnn -> EpaLocation
[nann_quoted] :: NameAnn -> SrcSpanAnnN
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used when adding a <a>TrailingAnn</a> to an existing <a>LocatedN</a>
--   which has no Api Annotation (via the <a>EpAnnNotUsed</a> constructor.
NameAnnTrailing :: [TrailingAnn] -> NameAnn
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | A <a>NameAnn</a> can capture the locations of surrounding adornments,
--   such as parens or backquotes. This data type identifies what
--   particular pair are being used.
data NameAdornment

-- | '(' ')'
NameParens :: NameAdornment

-- | '(#' '#)'
NameParensHash :: NameAdornment

-- | '`'
NameBackquotes :: NameAdornment

-- | '[' ']'
NameSquare :: NameAdornment
data NoEpAnns
NoEpAnns :: NoEpAnns

-- | Captures the sort order of sub elements. This is needed when the
--   sub-elements have been split (as in a HsLocalBind which holds separate
--   binds and sigs) or for infix patterns where the order has been
--   re-arranged. It is captured explicitly so that after the Delta phase a
--   SrcSpan is used purely as an index into the annotations, allowing
--   transformations of the AST including the introduction of new Located
--   items or re-arranging existing ones.
data AnnSortKey
NoAnnSortKey :: AnnSortKey
AnnSortKey :: [RealSrcSpan] -> AnnSortKey

-- | Captures the location of punctuation occuring between items, normally
--   in a list. It is captured as a trailing annotation.
data TrailingAnn

-- | Trailing ';'
AddSemiAnn :: EpaLocation -> TrailingAnn

-- | Trailing ','
AddCommaAnn :: EpaLocation -> TrailingAnn

-- | Trailing '|'
AddVbarAnn :: EpaLocation -> TrailingAnn

-- | Trailing <tt>-&gt;</tt>
AddRarrowAnn :: EpaLocation -> TrailingAnn

-- | Trailing <tt>-&gt;</tt>, unicode variant
AddRarrowAnnU :: EpaLocation -> TrailingAnn

-- | Trailing <tt>â¸</tt>
AddLollyAnnU :: EpaLocation -> TrailingAnn

-- | Helper function used in the parser to add a <a>TrailingAnn</a> items
--   to an existing annotation.
addTrailingAnnToA :: SrcSpan -> TrailingAnn -> EpAnnComments -> EpAnn AnnListItem -> EpAnn AnnListItem

-- | Helper function used in the parser to add a <a>TrailingAnn</a> items
--   to an existing annotation.
addTrailingAnnToL :: SrcSpan -> TrailingAnn -> EpAnnComments -> EpAnn AnnList -> EpAnn AnnList

-- | Helper function used in the parser to add a comma location to an
--   existing annotation.
addTrailingCommaToN :: SrcSpan -> EpAnn NameAnn -> EpaLocation -> EpAnn NameAnn

-- | Helper function (temporary) during transition of names Discards any
--   annotations
la2na :: SrcSpanAnn' a -> SrcSpanAnnN

-- | Helper function (temporary) during transition of names Discards any
--   annotations
na2la :: SrcSpanAnn' a -> SrcAnn ann
n2l :: LocatedN a -> LocatedA a

-- | Helper function (temporary) during transition of names Discards any
--   annotations
l2n :: LocatedAn a1 a2 -> LocatedN a2
l2l :: SrcSpanAnn' a -> SrcAnn ann

-- | Helper function (temporary) during transition of names Discards any
--   annotations
la2la :: LocatedAn ann1 a2 -> LocatedAn ann2 a2
reLoc :: LocatedAn a e -> Located e
reLocA :: Located e -> LocatedAn ann e
reLocL :: LocatedN e -> LocatedA e
reLocC :: LocatedN e -> LocatedC e
reLocN :: LocatedN a -> Located a
la2r :: SrcSpanAnn' a -> RealSrcSpan
realSrcSpan :: SrcSpan -> RealSrcSpan
extraToAnnList :: AnnList -> [AddEpAnn] -> AnnList
reAnn :: [TrailingAnn] -> EpAnnComments -> Located a -> LocatedA a
reAnnL :: ann -> EpAnnComments -> Located e -> GenLocated (SrcAnn ann) e
reAnnC :: AnnContext -> EpAnnComments -> Located a -> LocatedC a
addAnns :: EpAnn [AddEpAnn] -> [AddEpAnn] -> EpAnnComments -> EpAnn [AddEpAnn]
addAnnsA :: SrcSpanAnnA -> [TrailingAnn] -> EpAnnComments -> SrcSpanAnnA

-- | The annotations need to all come after the anchor. Make sure this is
--   the case.
widenSpan :: SrcSpan -> [AddEpAnn] -> SrcSpan
widenAnchor :: Anchor -> [AddEpAnn] -> Anchor
widenAnchorR :: Anchor -> RealSrcSpan -> Anchor
widenLocatedAn :: SrcSpanAnn' an -> [AddEpAnn] -> SrcSpanAnn' an
getLocAnn :: Located a -> SrcSpanAnnA
epAnnAnns :: EpAnn [AddEpAnn] -> [AddEpAnn]
epAnnAnnsL :: EpAnn a -> [a]
annParen2AddEpAnn :: EpAnn AnnParen -> [AddEpAnn]
epAnnComments :: EpAnn an -> EpAnnComments
sortLocatedA :: [GenLocated (SrcSpanAnn' a) e] -> [GenLocated (SrcSpanAnn' a) e]
mapLocA :: (a -> b) -> GenLocated SrcSpan a -> GenLocated (SrcAnn ann) b
combineLocsA :: Semigroup a => GenLocated (SrcAnn a) e1 -> GenLocated (SrcAnn a) e2 -> SrcAnn a
combineSrcSpansA :: Semigroup a => SrcAnn a -> SrcAnn a -> SrcAnn a

-- | Combine locations from two <a>Located</a> things and add them to a
--   third thing
addCLocA :: GenLocated (SrcSpanAnn' a) e1 -> GenLocated SrcSpan e2 -> e3 -> GenLocated (SrcAnn ann) e3
addCLocAA :: GenLocated (SrcSpanAnn' a1) e1 -> GenLocated (SrcSpanAnn' a2) e2 -> e3 -> GenLocated (SrcAnn ann) e3
noLocA :: a -> LocatedAn an a
getLocA :: GenLocated (SrcSpanAnn' a) e -> SrcSpan
noSrcSpanA :: SrcAnn ann
noAnnSrcSpan :: SrcSpan -> SrcAnn ann
noComments :: EpAnnCO
comment :: RealSrcSpan -> EpAnnComments -> EpAnnCO

-- | Add additional comments to a <a>SrcAnn</a>, used for manipulating the
--   AST prior to exact printing the changed one.
addCommentsToSrcAnn :: Monoid ann => SrcAnn ann -> EpAnnComments -> SrcAnn ann

-- | Replace any existing comments on a <a>SrcAnn</a>, used for
--   manipulating the AST prior to exact printing the changed one.
setCommentsSrcAnn :: Monoid ann => SrcAnn ann -> EpAnnComments -> SrcAnn ann

-- | Add additional comments, used for manipulating the AST prior to exact
--   printing the changed one.
addCommentsToEpAnn :: Monoid a => SrcSpan -> EpAnn a -> EpAnnComments -> EpAnn a

-- | Replace any existing comments, used for manipulating the AST prior to
--   exact printing the changed one.
setCommentsEpAnn :: Monoid a => SrcSpan -> EpAnn a -> EpAnnComments -> EpAnn a

-- | Transfer comments and trailing items from the annotations in the first
--   <a>SrcSpanAnnA</a> argument to those in the second.
transferAnnsA :: SrcSpanAnnA -> SrcSpanAnnA -> (SrcSpanAnnA, SrcSpanAnnA)

-- | Remove the exact print annotations payload, leaving only the anchor
--   and comments.
commentsOnlyA :: Monoid ann => SrcAnn ann -> SrcAnn ann

-- | Remove the comments, leaving the exact print annotations payload
removeCommentsA :: SrcAnn ann -> SrcAnn ann
placeholderRealSpan :: RealSrcSpan
instance GHC.Show.Show GHC.Parser.Annotation.AnnKeywordId
instance Data.Data.Data GHC.Parser.Annotation.AnnKeywordId
instance GHC.Classes.Ord GHC.Parser.Annotation.AnnKeywordId
instance GHC.Classes.Eq GHC.Parser.Annotation.AnnKeywordId
instance GHC.Show.Show GHC.Parser.Annotation.IsUnicodeSyntax
instance Data.Data.Data GHC.Parser.Annotation.IsUnicodeSyntax
instance GHC.Classes.Ord GHC.Parser.Annotation.IsUnicodeSyntax
instance GHC.Classes.Eq GHC.Parser.Annotation.IsUnicodeSyntax
instance GHC.Show.Show GHC.Parser.Annotation.HasE
instance Data.Data.Data GHC.Parser.Annotation.HasE
instance GHC.Classes.Ord GHC.Parser.Annotation.HasE
instance GHC.Classes.Eq GHC.Parser.Annotation.HasE
instance GHC.Show.Show GHC.Parser.Annotation.EpaCommentTok
instance Data.Data.Data GHC.Parser.Annotation.EpaCommentTok
instance GHC.Classes.Ord GHC.Parser.Annotation.EpaCommentTok
instance GHC.Classes.Eq GHC.Parser.Annotation.EpaCommentTok
instance GHC.Show.Show GHC.Parser.Annotation.EpaComment
instance Data.Data.Data GHC.Parser.Annotation.EpaComment
instance GHC.Classes.Ord GHC.Parser.Annotation.EpaComment
instance GHC.Classes.Eq GHC.Parser.Annotation.EpaComment
instance Data.Data.Data GHC.Parser.Annotation.DeltaPos
instance GHC.Classes.Ord GHC.Parser.Annotation.DeltaPos
instance GHC.Classes.Eq GHC.Parser.Annotation.DeltaPos
instance GHC.Show.Show GHC.Parser.Annotation.DeltaPos
instance GHC.Show.Show GHC.Parser.Annotation.AnchorOperation
instance GHC.Classes.Eq GHC.Parser.Annotation.AnchorOperation
instance Data.Data.Data GHC.Parser.Annotation.AnchorOperation
instance GHC.Show.Show GHC.Parser.Annotation.Anchor
instance GHC.Classes.Eq GHC.Parser.Annotation.Anchor
instance Data.Data.Data GHC.Parser.Annotation.Anchor
instance GHC.Classes.Eq GHC.Parser.Annotation.EpAnnComments
instance Data.Data.Data GHC.Parser.Annotation.EpAnnComments
instance GHC.Base.Functor GHC.Parser.Annotation.EpAnn
instance GHC.Classes.Eq ann => GHC.Classes.Eq (GHC.Parser.Annotation.EpAnn ann)
instance Data.Data.Data ann => Data.Data.Data (GHC.Parser.Annotation.EpAnn ann)
instance GHC.Classes.Ord GHC.Parser.Annotation.EpaLocation
instance GHC.Classes.Eq GHC.Parser.Annotation.EpaLocation
instance Data.Data.Data GHC.Parser.Annotation.EpaLocation
instance GHC.Classes.Eq GHC.Parser.Annotation.AddEpAnn
instance Data.Data.Data GHC.Parser.Annotation.AddEpAnn
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Parser.Annotation.SrcSpanAnn' a)
instance Data.Data.Data a => Data.Data.Data (GHC.Parser.Annotation.SrcSpanAnn' a)
instance GHC.Classes.Ord GHC.Parser.Annotation.TrailingAnn
instance GHC.Classes.Eq GHC.Parser.Annotation.TrailingAnn
instance Data.Data.Data GHC.Parser.Annotation.TrailingAnn
instance GHC.Classes.Eq GHC.Parser.Annotation.AnnListItem
instance Data.Data.Data GHC.Parser.Annotation.AnnListItem
instance GHC.Classes.Eq GHC.Parser.Annotation.AnnList
instance Data.Data.Data GHC.Parser.Annotation.AnnList
instance Data.Data.Data GHC.Parser.Annotation.ParenType
instance GHC.Classes.Ord GHC.Parser.Annotation.ParenType
instance GHC.Classes.Eq GHC.Parser.Annotation.ParenType
instance Data.Data.Data GHC.Parser.Annotation.AnnParen
instance Data.Data.Data GHC.Parser.Annotation.AnnContext
instance Data.Data.Data GHC.Parser.Annotation.NameAdornment
instance GHC.Classes.Ord GHC.Parser.Annotation.NameAdornment
instance GHC.Classes.Eq GHC.Parser.Annotation.NameAdornment
instance GHC.Classes.Eq GHC.Parser.Annotation.NameAnn
instance Data.Data.Data GHC.Parser.Annotation.NameAnn
instance GHC.Classes.Eq GHC.Parser.Annotation.AnnPragma
instance Data.Data.Data GHC.Parser.Annotation.AnnPragma
instance GHC.Classes.Eq GHC.Parser.Annotation.AnnSortKey
instance Data.Data.Data GHC.Parser.Annotation.AnnSortKey
instance GHC.Classes.Ord GHC.Parser.Annotation.NoEpAnns
instance GHC.Classes.Eq GHC.Parser.Annotation.NoEpAnns
instance Data.Data.Data GHC.Parser.Annotation.NoEpAnns
instance GHC.Base.Semigroup GHC.Parser.Annotation.AnnSortKey
instance GHC.Base.Monoid GHC.Parser.Annotation.AnnSortKey
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnSortKey
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnPragma
instance GHC.Base.Semigroup GHC.Parser.Annotation.NameAnn
instance GHC.Base.Monoid GHC.Parser.Annotation.NameAnn
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.NameAnn
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.NameAdornment
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnContext
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Parser.Annotation.LocatedL a)
instance GHC.Base.Semigroup GHC.Parser.Annotation.AnnList
instance GHC.Base.Monoid GHC.Parser.Annotation.AnnList
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnList
instance GHC.Base.Semigroup GHC.Parser.Annotation.AnnListItem
instance GHC.Base.Monoid GHC.Parser.Annotation.AnnListItem
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnListItem
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.TrailingAnn
instance GHC.Types.Name.NamedThing (GHC.Types.SrcLoc.Located a) => GHC.Types.Name.NamedThing (GHC.Parser.Annotation.LocatedAn an a)
instance GHC.Base.Semigroup an => GHC.Base.Semigroup (GHC.Parser.Annotation.SrcSpanAnn' an)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Parser.Annotation.SrcSpanAnn' a)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable e) => GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.GenLocated (GHC.Parser.Annotation.SrcSpanAnn' a) e)
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AddEpAnn
instance GHC.Classes.Ord GHC.Parser.Annotation.AddEpAnn
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.EpaLocation
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Parser.Annotation.EpAnn a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (GHC.Parser.Annotation.EpAnn a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Parser.Annotation.EpAnn a)
instance GHC.Base.Semigroup GHC.Parser.Annotation.EpAnnComments
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.EpAnnComments
instance GHC.Classes.Ord GHC.Parser.Annotation.Anchor
instance GHC.Base.Semigroup GHC.Parser.Annotation.Anchor
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.Anchor
instance GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.GenLocated GHC.Parser.Annotation.Anchor GHC.Parser.Annotation.EpaComment)
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnchorOperation
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.DeltaPos
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.EpaComment
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.IsUnicodeSyntax
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnKeywordId

module GHC.Core.ConLike

-- | A constructor-like thing
data ConLike
RealDataCon :: DataCon -> ConLike
PatSynCon :: PatSyn -> ConLike

-- | Is this a 'vanilla' constructor-like thing (no existentials, no
--   provided constraints)?
isVanillaConLike :: ConLike -> Bool

-- | Number of arguments
conLikeArity :: ConLike -> Arity

-- | Names of fields used for selectors
conLikeFieldLabels :: ConLike -> [FieldLabel]

-- | Returns just the instantiated <i>value</i> argument types of a
--   <a>ConLike</a>, (excluding dictionary args)
conLikeInstOrigArgTys :: ConLike -> [Type] -> [Scaled Type]

-- | <a>TyVarBinder</a>s for the type variables of the <a>ConLike</a>. For
--   pattern synonyms, this will always consist of the universally
--   quantified variables followed by the existentially quantified type
--   variables. For data constructors, the situation is slightly more
--   complicatedâsee <tt>Note [DataCon user type variable binders]</tt> in
--   <a>GHC.Core.DataCon</a>.
conLikeUserTyVarBinders :: ConLike -> [InvisTVBinder]

-- | Existentially quantified type/coercion variables
conLikeExTyCoVars :: ConLike -> [TyCoVar]
conLikeName :: ConLike -> Name

-- | The "stupid theta" of the <a>ConLike</a>, such as <tt>data Eq a</tt>
--   in:
--   
--   <pre>
--   data Eq a =&gt; T a = ...
--   </pre>
--   
--   It is empty for <a>PatSynCon</a> as they do not allow such contexts.
conLikeStupidTheta :: ConLike -> ThetaType

-- | Returns the strictness information for each constructor
conLikeImplBangs :: ConLike -> [HsImplBang]

-- | The "full signature" of the <a>ConLike</a> returns, in order:
--   
--   1) The universally quantified type variables
--   
--   2) The existentially quantified type/coercion variables
--   
--   3) The equality specification
--   
--   4) The provided theta (the constraints provided by a match)
--   
--   5) The required theta (the constraints required for a match)
--   
--   6) The original argument types (i.e. before any change of the
--   representation of the type)
--   
--   7) The original result type
conLikeFullSig :: ConLike -> ([TyVar], [TyCoVar], [EqSpec], ThetaType, ThetaType, [Scaled Type], Type)

-- | Returns the type of the whole pattern
conLikeResTy :: ConLike -> [Type] -> Type

-- | Extract the type for any given labelled field of the <a>ConLike</a>
conLikeFieldType :: ConLike -> FieldLabelString -> Type

-- | The ConLikes that have *all* the given fields
conLikesWithFields :: [ConLike] -> [FieldLabelString] -> [ConLike]
conLikeIsInfix :: ConLike -> Bool

-- | <a>conLikeHasBuilder</a> returns True except for uni-directional
--   pattern synonyms, which have no builder
conLikeHasBuilder :: ConLike -> Bool
instance GHC.Classes.Eq GHC.Core.ConLike.ConLike
instance GHC.Types.Unique.Uniquable GHC.Core.ConLike.ConLike
instance GHC.Types.Name.NamedThing GHC.Core.ConLike.ConLike
instance GHC.Utils.Outputable.Outputable GHC.Core.ConLike.ConLike
instance GHC.Utils.Outputable.OutputableBndr GHC.Core.ConLike.ConLike
instance Data.Data.Data GHC.Core.ConLike.ConLike

module GHC.Core.PatSyn

-- | Pattern Synonym
--   
--   See Note [Pattern synonym representation] See Note [Pattern synonym
--   signature contexts]
data PatSyn
type PatSynMatcher = (Name, Type, Bool)
type PatSynBuilder = Maybe (Name, Type, Bool)

-- | Build a new pattern synonym
mkPatSyn :: Name -> Bool -> ([InvisTVBinder], ThetaType) -> ([InvisTVBinder], ThetaType) -> [Type] -> Type -> PatSynMatcher -> PatSynBuilder -> [FieldLabel] -> PatSyn

-- | The <a>Name</a> of the <a>PatSyn</a>, giving it a unique, rooted
--   identification
patSynName :: PatSyn -> Name

-- | Arity of the pattern synonym
patSynArity :: PatSyn -> Arity

-- | Should the <a>PatSyn</a> be presented infix?
patSynIsInfix :: PatSyn -> Bool
patSynResultType :: PatSyn -> Type

-- | Is this a 'vanilla' pattern synonym (no existentials, no provided
--   constraints)?
isVanillaPatSyn :: PatSyn -> Bool
patSynArgs :: PatSyn -> [Type]
patSynMatcher :: PatSyn -> PatSynMatcher
patSynBuilder :: PatSyn -> PatSynBuilder
patSynUnivTyVarBinders :: PatSyn -> [InvisTVBinder]
patSynExTyVars :: PatSyn -> [TyVar]
patSynExTyVarBinders :: PatSyn -> [InvisTVBinder]
patSynSig :: PatSyn -> ([TyVar], ThetaType, [TyVar], ThetaType, [Scaled Type], Type)
patSynSigBndr :: PatSyn -> ([InvisTVBinder], ThetaType, [InvisTVBinder], ThetaType, [Scaled Type], Type)
patSynInstArgTys :: PatSyn -> [Type] -> [Type]
patSynInstResTy :: PatSyn -> [Type] -> Type
patSynFieldLabels :: PatSyn -> [FieldLabel]

-- | Extract the type for any given labelled field of the <tt>DataCon</tt>
patSynFieldType :: PatSyn -> FieldLabelString -> Type

-- | Print the type of a pattern synonym. The foralls are printed
--   explicitly
pprPatSynType :: PatSyn -> SDoc
instance GHC.Classes.Eq GHC.Core.PatSyn.PatSyn
instance GHC.Types.Unique.Uniquable GHC.Core.PatSyn.PatSyn
instance GHC.Types.Name.NamedThing GHC.Core.PatSyn.PatSyn
instance GHC.Utils.Outputable.Outputable GHC.Core.PatSyn.PatSyn
instance GHC.Utils.Outputable.OutputableBndr GHC.Core.PatSyn.PatSyn
instance Data.Data.Data GHC.Core.PatSyn.PatSyn


-- | Module for coercion axioms, used to represent type family instances
--   and newtypes
module GHC.Core.Coercion.Axiom
data BranchFlag
type Branched = 'Branched
type Unbranched = 'Unbranched
type BranchIndex = Int
newtype Branches (br :: BranchFlag)
MkBranches :: Array BranchIndex CoAxBranch -> Branches (br :: BranchFlag)
[unMkBranches] :: Branches (br :: BranchFlag) -> Array BranchIndex CoAxBranch
manyBranches :: [CoAxBranch] -> Branches Branched
unbranched :: CoAxBranch -> Branches Unbranched
fromBranches :: Branches br -> [CoAxBranch]
numBranches :: Branches br -> Int

-- | The <tt>[CoAxBranch]</tt> passed into the mapping function is a list
--   of all previous branches, reversed
mapAccumBranches :: ([CoAxBranch] -> CoAxBranch -> CoAxBranch) -> Branches br -> Branches br

-- | A <a>CoAxiom</a> is a "coercion constructor", i.e. a named equality
--   axiom.
data CoAxiom br
CoAxiom :: Unique -> Name -> Role -> TyCon -> Branches br -> Bool -> CoAxiom br
[co_ax_unique] :: CoAxiom br -> Unique
[co_ax_name] :: CoAxiom br -> Name
[co_ax_role] :: CoAxiom br -> Role
[co_ax_tc] :: CoAxiom br -> TyCon
[co_ax_branches] :: CoAxiom br -> Branches br
[co_ax_implicit] :: CoAxiom br -> Bool
data CoAxBranch
CoAxBranch :: SrcSpan -> [TyVar] -> [TyVar] -> [CoVar] -> [Role] -> [Type] -> Type -> [CoAxBranch] -> CoAxBranch
[cab_loc] :: CoAxBranch -> SrcSpan
[cab_tvs] :: CoAxBranch -> [TyVar]
[cab_eta_tvs] :: CoAxBranch -> [TyVar]
[cab_cvs] :: CoAxBranch -> [CoVar]
[cab_roles] :: CoAxBranch -> [Role]
[cab_lhs] :: CoAxBranch -> [Type]
[cab_rhs] :: CoAxBranch -> Type
[cab_incomps] :: CoAxBranch -> [CoAxBranch]
toBranchedAxiom :: CoAxiom br -> CoAxiom Branched
toUnbranchedAxiom :: CoAxiom br -> CoAxiom Unbranched
coAxiomName :: CoAxiom br -> Name
coAxiomArity :: CoAxiom br -> BranchIndex -> Arity
coAxiomBranches :: CoAxiom br -> Branches br
coAxiomTyCon :: CoAxiom br -> TyCon
isImplicitCoAxiom :: CoAxiom br -> Bool
coAxiomNumPats :: CoAxiom br -> Int
coAxiomNthBranch :: CoAxiom br -> BranchIndex -> CoAxBranch
coAxiomSingleBranch_maybe :: CoAxiom br -> Maybe CoAxBranch
coAxiomRole :: CoAxiom br -> Role
coAxiomSingleBranch :: CoAxiom Unbranched -> CoAxBranch
coAxBranchTyVars :: CoAxBranch -> [TyVar]
coAxBranchCoVars :: CoAxBranch -> [CoVar]
coAxBranchRoles :: CoAxBranch -> [Role]
coAxBranchLHS :: CoAxBranch -> [Type]
coAxBranchRHS :: CoAxBranch -> Type
coAxBranchSpan :: CoAxBranch -> SrcSpan
coAxBranchIncomps :: CoAxBranch -> [CoAxBranch]
placeHolderIncomps :: [CoAxBranch]
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
fsFromRole :: Role -> FastString

-- | For now, we work only with nominal equality.
data CoAxiomRule
CoAxiomRule :: FastString -> [Role] -> Role -> ([TypeEqn] -> Maybe TypeEqn) -> CoAxiomRule
[coaxrName] :: CoAxiomRule -> FastString
[coaxrAsmpRoles] :: CoAxiomRule -> [Role]
[coaxrRole] :: CoAxiomRule -> Role

-- | coaxrProves returns <tt>Nothing</tt> when it doesn't like the supplied
--   arguments. When this happens in a coercion that means that the
--   coercion is ill-formed, and Core Lint checks for that.
[coaxrProves] :: CoAxiomRule -> [TypeEqn] -> Maybe TypeEqn

-- | A more explicit representation for `t1 ~ t2`.
type TypeEqn = Pair Type
data BuiltInSynFamily
BuiltInSynFamily :: ([Type] -> Maybe (CoAxiomRule, [Type], Type)) -> ([Type] -> Type -> [TypeEqn]) -> ([Type] -> Type -> [Type] -> Type -> [TypeEqn]) -> BuiltInSynFamily
[sfMatchFam] :: BuiltInSynFamily -> [Type] -> Maybe (CoAxiomRule, [Type], Type)
[sfInteractTop] :: BuiltInSynFamily -> [Type] -> Type -> [TypeEqn]
[sfInteractInert] :: BuiltInSynFamily -> [Type] -> Type -> [Type] -> Type -> [TypeEqn]
trivialBuiltInFamily :: BuiltInSynFamily
instance Data.Data.Data GHC.Core.Coercion.Axiom.Role
instance GHC.Classes.Ord GHC.Core.Coercion.Axiom.Role
instance GHC.Classes.Eq GHC.Core.Coercion.Axiom.Role
instance Data.Data.Data GHC.Core.Coercion.Axiom.CoAxBranch
instance Data.Data.Data GHC.Core.Coercion.Axiom.CoAxiomRule
instance GHC.Types.Unique.Uniquable GHC.Core.Coercion.Axiom.CoAxiomRule
instance GHC.Classes.Eq GHC.Core.Coercion.Axiom.CoAxiomRule
instance GHC.Classes.Ord GHC.Core.Coercion.Axiom.CoAxiomRule
instance GHC.Utils.Outputable.Outputable GHC.Core.Coercion.Axiom.CoAxiomRule
instance GHC.Classes.Eq (GHC.Core.Coercion.Axiom.CoAxiom br)
instance GHC.Types.Unique.Uniquable (GHC.Core.Coercion.Axiom.CoAxiom br)
instance GHC.Utils.Outputable.Outputable (GHC.Core.Coercion.Axiom.CoAxiom br)
instance GHC.Types.Name.NamedThing (GHC.Core.Coercion.Axiom.CoAxiom br)
instance Data.Typeable.Internal.Typeable br => Data.Data.Data (GHC.Core.Coercion.Axiom.CoAxiom br)
instance GHC.Utils.Outputable.Outputable GHC.Core.Coercion.Axiom.CoAxBranch
instance GHC.Utils.Outputable.Outputable GHC.Core.Coercion.Axiom.Role
instance GHC.Utils.Binary.Binary GHC.Core.Coercion.Axiom.Role

module GHC.Core.Class
data Class
type ClassOpItem = (Id, DefMethInfo)
data ClassATItem
ATI :: TyCon -> Maybe (Type, ATValidityInfo) -> ClassATItem

-- | Information about an associated type family default implementation.
--   This is used solely for validity checking. See <tt>Note [Type-checking
--   default assoc decls]</tt> in <a>GHC.Tc.TyCl</a>.
data ATValidityInfo
NoATVI :: ATValidityInfo
ATVI :: SrcSpan -> [Type] -> ATValidityInfo
type ClassMinimalDef = BooleanFormula Name
type DefMethInfo = Maybe (Name, DefMethSpec Type)
pprDefMethInfo :: DefMethInfo -> SDoc
type FunDep a = ([a], [a])
pprFundeps :: Outputable a => [FunDep a] -> SDoc
pprFunDep :: Outputable a => FunDep a -> SDoc
mkClass :: Name -> [TyVar] -> [FunDep TyVar] -> [PredType] -> [Id] -> [ClassATItem] -> [ClassOpItem] -> ClassMinimalDef -> TyCon -> Class
mkAbstractClass :: Name -> [TyVar] -> [FunDep TyVar] -> TyCon -> Class
classTyVars :: Class -> [TyVar]
classArity :: Class -> Arity
classKey :: Class -> Unique
className :: Class -> Name
classATs :: Class -> [TyCon]
classATItems :: Class -> [ClassATItem]
classTyCon :: Class -> TyCon
classMethods :: Class -> [Id]
classOpItems :: Class -> [ClassOpItem]
classBigSig :: Class -> ([TyVar], [PredType], [Id], [ClassOpItem])
classExtraBigSig :: Class -> ([TyVar], [FunDep TyVar], [PredType], [Id], [ClassATItem], [ClassOpItem])
classTvsFds :: Class -> ([TyVar], [FunDep TyVar])
classSCTheta :: Class -> [PredType]
classAllSelIds :: Class -> [Id]
classSCSelId :: Class -> Int -> Id
classSCSelIds :: Class -> [Id]
classMinimalDef :: Class -> ClassMinimalDef
classHasFds :: Class -> Bool
isAbstractClass :: Class -> Bool
instance GHC.Classes.Eq GHC.Core.Class.Class
instance GHC.Types.Unique.Uniquable GHC.Core.Class.Class
instance GHC.Types.Name.NamedThing GHC.Core.Class.Class
instance GHC.Utils.Outputable.Outputable GHC.Core.Class.Class
instance Data.Data.Data GHC.Core.Class.Class


-- | This module defines TyCons that can't be expressed in Haskell. They
--   are all, therefore, wired-in TyCons. C.f module
--   <a>GHC.Builtin.Types</a>
module GHC.Builtin.Types.Prim
mkPrimTyConName :: FastString -> Unique -> TyCon -> Name
mkTemplateKindVars :: [Kind] -> [TyVar]
mkTemplateTyVars :: [Kind] -> [TyVar]
mkTemplateTyVarsFrom :: Int -> [Kind] -> [TyVar]
mkTemplateKiTyVars :: [Kind] -> ([Kind] -> [Kind]) -> [TyVar]
mkTemplateKiTyVar :: Kind -> (Kind -> [Kind]) -> [TyVar]
mkTemplateTyConBinders :: [Kind] -> ([Kind] -> [Kind]) -> [TyConBinder]
mkTemplateKindTyConBinders :: [Kind] -> [TyConBinder]
mkTemplateAnonTyConBinders :: [Kind] -> [TyConBinder]
alphaTyVars :: [TyVar]
alphaTyVar :: TyVar
betaTyVar :: TyVar
gammaTyVar :: TyVar
deltaTyVar :: TyVar
alphaTys :: [Type]
alphaTy :: Type
betaTy :: Type
gammaTy :: Type
deltaTy :: Type
alphaTyVarsUnliftedRep :: [TyVar]
alphaTyVarUnliftedRep :: TyVar
alphaTysUnliftedRep :: [Type]
alphaTyUnliftedRep :: Type
runtimeRep1TyVar :: TyVar
runtimeRep2TyVar :: TyVar
runtimeRep3TyVar :: TyVar
runtimeRep1Ty :: Type
runtimeRep2Ty :: Type
runtimeRep3Ty :: Type
openAlphaTyVar :: TyVar
openBetaTyVar :: TyVar
openGammaTyVar :: TyVar
openAlphaTy :: Type
openBetaTy :: Type
openGammaTy :: Type
multiplicityTyVar1 :: TyVar
multiplicityTyVar2 :: TyVar
tYPETyCon :: TyCon
tYPETyConName :: Name
tYPE :: Type -> Type

-- | Convert a <a>PrimRep</a> to a <a>Type</a> of kind RuntimeRep Defined
--   here to avoid (more) module loops
primRepToRuntimeRep :: PrimRep -> Type
functionWithMultiplicity :: Type -> Type

-- | The <tt>FUN</tt> type constructor.
--   
--   <pre>
--   FUN :: forall (m :: Multiplicity) -&gt;
--          forall {rep1 :: RuntimeRep} {rep2 :: RuntimeRep}.
--          TYPE rep1 -&gt; TYPE rep2 -&gt; *
--   </pre>
--   
--   The runtime representations quantification is left inferred. This
--   means they cannot be specified with <tt>-XTypeApplications</tt>.
--   
--   This is a deliberate choice to allow future extensions to the function
--   arrow. To allow visible application a type synonym can be defined:
--   
--   <pre>
--   type Arr :: forall (rep1 :: RuntimeRep) (rep2 :: RuntimeRep).
--               TYPE rep1 -&gt; TYPE rep2 -&gt; Type
--   type Arr = FUN 'Many
--   </pre>
funTyCon :: TyCon
funTyConName :: Name

-- | Primitive <a>TyCon</a>s that are defined in GHC.Prim but not exposed.
--   It's important to keep these separate as we don't want users to be
--   able to write them (see #15209) or see them in GHCi's <tt>:browse</tt>
--   output (see #12023).
unexposedPrimTyCons :: [TyCon]

-- | Primitive <a>TyCon</a>s that are defined in, and exported from,
--   GHC.Prim.
exposedPrimTyCons :: [TyCon]
primTyCons :: [TyCon]
charPrimTyCon :: TyCon
charPrimTy :: Type
charPrimTyConName :: Name
intPrimTyCon :: TyCon
intPrimTy :: Type
intPrimTyConName :: Name
wordPrimTyCon :: TyCon
wordPrimTy :: Type
wordPrimTyConName :: Name
addrPrimTyCon :: TyCon
addrPrimTy :: Type
addrPrimTyConName :: Name
floatPrimTyCon :: TyCon
floatPrimTy :: Type
floatPrimTyConName :: Name
doublePrimTyCon :: TyCon
doublePrimTy :: Type
doublePrimTyConName :: Name
statePrimTyCon :: TyCon
mkStatePrimTy :: Type -> Type
realWorldTyCon :: TyCon
realWorldTy :: Type
realWorldStatePrimTy :: Type
proxyPrimTyCon :: TyCon
mkProxyPrimTy :: Type -> Type -> Type
arrayPrimTyCon :: TyCon
mkArrayPrimTy :: Type -> Type
byteArrayPrimTyCon :: TyCon
byteArrayPrimTy :: Type
arrayArrayPrimTyCon :: TyCon
mkArrayArrayPrimTy :: Type
smallArrayPrimTyCon :: TyCon
mkSmallArrayPrimTy :: Type -> Type
mutableArrayPrimTyCon :: TyCon
mkMutableArrayPrimTy :: Type -> Type -> Type
mutableByteArrayPrimTyCon :: TyCon
mkMutableByteArrayPrimTy :: Type -> Type
mutableArrayArrayPrimTyCon :: TyCon
mkMutableArrayArrayPrimTy :: Type -> Type
smallMutableArrayPrimTyCon :: TyCon
mkSmallMutableArrayPrimTy :: Type -> Type -> Type
mutVarPrimTyCon :: TyCon
mkMutVarPrimTy :: Type -> Type -> Type
mVarPrimTyCon :: TyCon
mkMVarPrimTy :: Type -> Type -> Type
ioPortPrimTyCon :: TyCon
mkIOPortPrimTy :: Type -> Type -> Type
tVarPrimTyCon :: TyCon
mkTVarPrimTy :: Type -> Type -> Type
stablePtrPrimTyCon :: TyCon
mkStablePtrPrimTy :: Type -> Type
stableNamePrimTyCon :: TyCon
mkStableNamePrimTy :: Type -> Type
compactPrimTyCon :: TyCon
compactPrimTy :: Type
bcoPrimTyCon :: TyCon
bcoPrimTy :: Type
weakPrimTyCon :: TyCon
mkWeakPrimTy :: Type -> Type
threadIdPrimTyCon :: TyCon
threadIdPrimTy :: Type
int8PrimTyCon :: TyCon
int8PrimTy :: Type
int8PrimTyConName :: Name
word8PrimTyCon :: TyCon
word8PrimTy :: Type
word8PrimTyConName :: Name
int16PrimTyCon :: TyCon
int16PrimTy :: Type
int16PrimTyConName :: Name
word16PrimTyCon :: TyCon
word16PrimTy :: Type
word16PrimTyConName :: Name
int32PrimTyCon :: TyCon
int32PrimTy :: Type
int32PrimTyConName :: Name
word32PrimTyCon :: TyCon
word32PrimTy :: Type
word32PrimTyConName :: Name
int64PrimTyCon :: TyCon
int64PrimTy :: Type
int64PrimTyConName :: Name
word64PrimTyCon :: TyCon
word64PrimTy :: Type
word64PrimTyConName :: Name
eqPrimTyCon :: TyCon
eqReprPrimTyCon :: TyCon
eqPhantPrimTyCon :: TyCon

-- | Given a Role, what TyCon is the type of equality predicates at that
--   role?
equalityTyCon :: Role -> TyCon
int8X16PrimTy :: Type
int8X16PrimTyCon :: TyCon
int16X8PrimTy :: Type
int16X8PrimTyCon :: TyCon
int32X4PrimTy :: Type
int32X4PrimTyCon :: TyCon
int64X2PrimTy :: Type
int64X2PrimTyCon :: TyCon
int8X32PrimTy :: Type
int8X32PrimTyCon :: TyCon
int16X16PrimTy :: Type
int16X16PrimTyCon :: TyCon
int32X8PrimTy :: Type
int32X8PrimTyCon :: TyCon
int64X4PrimTy :: Type
int64X4PrimTyCon :: TyCon
int8X64PrimTy :: Type
int8X64PrimTyCon :: TyCon
int16X32PrimTy :: Type
int16X32PrimTyCon :: TyCon
int32X16PrimTy :: Type
int32X16PrimTyCon :: TyCon
int64X8PrimTy :: Type
int64X8PrimTyCon :: TyCon
word8X16PrimTy :: Type
word8X16PrimTyCon :: TyCon
word16X8PrimTy :: Type
word16X8PrimTyCon :: TyCon
word32X4PrimTy :: Type
word32X4PrimTyCon :: TyCon
word64X2PrimTy :: Type
word64X2PrimTyCon :: TyCon
word8X32PrimTy :: Type
word8X32PrimTyCon :: TyCon
word16X16PrimTy :: Type
word16X16PrimTyCon :: TyCon
word32X8PrimTy :: Type
word32X8PrimTyCon :: TyCon
word64X4PrimTy :: Type
word64X4PrimTyCon :: TyCon
word8X64PrimTy :: Type
word8X64PrimTyCon :: TyCon
word16X32PrimTy :: Type
word16X32PrimTyCon :: TyCon
word32X16PrimTy :: Type
word32X16PrimTyCon :: TyCon
word64X8PrimTy :: Type
word64X8PrimTyCon :: TyCon
floatX4PrimTy :: Type
floatX4PrimTyCon :: TyCon
doubleX2PrimTy :: Type
doubleX2PrimTyCon :: TyCon
floatX8PrimTy :: Type
floatX8PrimTyCon :: TyCon
doubleX4PrimTy :: Type
doubleX4PrimTyCon :: TyCon
floatX16PrimTy :: Type
floatX16PrimTyCon :: TyCon
doubleX8PrimTy :: Type
doubleX8PrimTyCon :: TyCon

module GHC.Builtin.Names

-- | Unique identifier.
--   
--   The type of unique identifiers that are used in many places in GHC for
--   fast ordering and equality tests. You should generate these with the
--   functions from the <tt>UniqSupply</tt> module
--   
--   These are sometimes also referred to as "keys" in comments in GHC.
data Unique

-- | Class of things that we can obtain a <a>Unique</a> from
class Uniquable a
getUnique :: Uniquable a => a -> Unique
hasKey :: Uniquable a => a -> Unique -> Bool
aRROW :: Module
absentErrorIdKey :: Unique
absentSumFieldErrorIdKey :: Unique
addrPrimTyConKey :: Unique
allNameStrings :: [String]
all_RDR :: RdrName
alt_RDR :: RdrName
alternativeClassKey :: Unique
alternativeClassName :: Name
and_RDR :: RdrName
anyBoxConKey :: Unique
anyTyConKey :: Unique
apAClassOpKey :: Unique
apAName :: Name
ap_RDR :: RdrName
appAIdKey :: Unique
appAName :: Name
appendIdKey :: Unique
appendName :: Name
append_RDR :: RdrName
applicativeClassKey :: Unique
applicativeClassName :: Name
arrAIdKey :: Unique
arrAName :: Name
arrayArrayPrimTyConKey :: Unique
arrayPrimTyConKey :: Unique
assertErrorIdKey :: Unique
assertErrorName :: Name
assertIdKey :: Unique
assertName :: Name
augmentIdKey :: Unique
augmentName :: Name
basicKnownKeyNames :: [Name]
bcoPrimTyConKey :: Unique
bignatFromWordListIdKey :: Unique
bignatFromWordListName :: Name
bindIOIdKey :: Unique
bindIOName :: Name
bindIO_RDR :: RdrName
bindMClassOpKey :: Unique
bindMName :: Name
bindM_RDR :: RdrName
bitIntegerIdKey :: Unique
bnbVarQual :: String -> Unique -> Name
bniVarQual :: String -> Unique -> Name
bnnVarQual :: String -> Unique -> Name
boolTyConKey :: Unique
boundedClassKey :: Unique
boundedClassName :: Name
boxedRepDataConKey :: Unique
boxityConKey :: Unique
breakpointCondIdKey :: Unique
breakpointCondName :: Name
breakpointIdKey :: Unique
breakpointName :: Name
buildIdKey :: Unique
buildName :: Name
build_RDR :: RdrName
byteArrayPrimTyConKey :: Unique
c1TyConKey :: Unique
c1TyConName :: Name
cONTROL_APPLICATIVE :: Module
cONTROL_EXCEPTION_BASE :: Module
cTyConKey :: Unique
cTyConName :: Name
callStackTyConKey :: Unique
callStackTyConName :: Name
charDataConKey :: Unique
charPrimTyConKey :: Unique
charTyConKey :: Unique
choiceAIdKey :: Unique
choiceAName :: Name
choose_RDR :: RdrName
clsQual :: Module -> FastString -> Unique -> Name
clsQual_RDR :: Module -> FastString -> RdrName
coerceKey :: Unique
coercibleDataConKey :: Unique
coercibleSCSelIdKey :: Unique
coercibleTyConKey :: Unique
coercionTokenIdKey :: Unique
comp1DataCon_RDR :: RdrName
compTyConKey :: Unique
compTyConName :: Name
compactPrimTyConKey :: Unique
compare_RDR :: RdrName
composeAIdKey :: Unique
composeAName :: Name
compose_RDR :: RdrName
conFixity_RDR :: RdrName
conIsRecord_RDR :: RdrName
conName_RDR :: RdrName
concatIdKey :: Unique
concatName :: Name
consDataConKey :: Unique
considerAccessibleIdKey :: Unique
considerAccessibleName :: Name
constraintKindTyConKey :: Unique
constructorClassKey :: Unique
constructorClassName :: Name
crossDataConKey :: Unique
cstringLengthIdKey :: Unique
cstringLengthName :: Name
d1TyConKey :: Unique
d1TyConName :: Name
dATA_ARRAY_PARALLEL_NAME :: ModuleName
dATA_ARRAY_PARALLEL_PRIM_NAME :: ModuleName
dATA_COERCE :: Module
dATA_EITHER :: Module
dATA_FOLDABLE :: Module
dATA_LIST :: Module
dATA_STRING :: Module
dATA_TRAVERSABLE :: Module
dATA_TUPLE :: Module
dATA_TYPE_EQUALITY :: Module
dEBUG_TRACE :: Module
dTyConKey :: Unique
dTyConName :: Name
dYNAMIC :: Module
dataClassKey :: Unique
dataClassName :: Name
dataQual_RDR :: Module -> FastString -> RdrName
dataToTag_RDR :: RdrName
datatypeClassKey :: Unique
datatypeClassName :: Name
datatypeName_RDR :: RdrName
dcQual :: Module -> FastString -> Unique -> Name
decidedLazyDataConKey :: Unique
decidedLazyDataConName :: Name
decidedStrictDataConKey :: Unique
decidedStrictDataConName :: Name
decidedUnpackDataConKey :: Unique
decidedUnpackDataConName :: Name
derivableClassKeys :: [Unique]
divIntIdKey :: Unique
divIntName :: Name
dollarIdKey :: Unique
dollarName :: Name
doubleDataConKey :: Unique
doublePrimTyConKey :: Unique
doubleTyConKey :: Unique
doubleX2PrimTyConKey :: Unique
doubleX4PrimTyConKey :: Unique
doubleX8PrimTyConKey :: Unique
eitherTyConKey :: Unique
eitherTyConName :: Name
emptyCallStackKey :: Unique
emptyCallStackName :: Name
enumClassKey :: Unique
enumClassName :: Name
enumClass_RDR :: RdrName
enumFromClassOpKey :: Unique
enumFromName :: Name
enumFromThenClassOpKey :: Unique
enumFromThenName :: Name
enumFromThenToClassOpKey :: Unique
enumFromThenToName :: Name
enumFromThenTo_RDR :: RdrName
enumFromThen_RDR :: RdrName
enumFromToClassOpKey :: Unique
enumFromToName :: Name
enumFromTo_RDR :: RdrName
enumFrom_RDR :: RdrName
eqClassKey :: Unique
eqClassName :: Name
eqClassOpKey :: Unique
eqClass_RDR :: RdrName
eqDataConKey :: Unique
eqName :: Name
eqPhantPrimTyConKey :: Unique
eqPrimTyConKey :: Unique
eqReprPrimTyConKey :: Unique
eqSCSelIdKey :: Unique
eqStringIdKey :: Unique
eqStringName :: Name
eqString_RDR :: RdrName
eqTag_RDR :: RdrName
eqTyConKey :: Unique
eq_RDR :: RdrName
errorIdKey :: Unique
errorMessageTypeErrorFamKey :: Unique
errorMessageTypeErrorFamName :: Name
error_RDR :: RdrName
expectP_RDR :: RdrName
failIOIdKey :: Unique
failIOName :: Name
failMClassOpKey :: Unique
failMName :: Name
failM_RDR :: RdrName
falseDataConKey :: Unique
filterIdKey :: Unique
filterName :: Name
fingerprintDataConKey :: Unique
fingerprintDataConName :: Name
firstAIdKey :: Unique
firstAName :: Name
floatDataConKey :: Unique
floatPrimTyConKey :: Unique
floatTyConKey :: Unique
floatX16PrimTyConKey :: Unique
floatX4PrimTyConKey :: Unique
floatX8PrimTyConKey :: Unique
floatingClassKey :: Unique
floatingClassName :: Name
fmapClassOpKey :: Unique
fmapName :: Name
fmap_RDR :: RdrName
foldMap_RDR :: RdrName
foldableClassKey :: Unique
foldableClassName :: Name
foldable_foldr_RDR :: RdrName
foldrIdKey :: Unique
foldrName :: Name
foldr_RDR :: RdrName
foreignObjPrimTyConKey :: Unique
fractionalClassKey :: Unique
fractionalClassKeys :: [Unique]
fractionalClassName :: Name
from1_RDR :: RdrName
fromEnum_RDR :: RdrName
fromIntegerClassOpKey :: Unique
fromIntegerName :: Name
fromInteger_RDR :: RdrName
fromIntegralIdKey :: Unique
fromIntegralName :: Name
fromIntegral_RDR :: RdrName
fromLabelClassOpKey :: Unique
fromLabelClassOpName :: Name
fromListClassOpKey :: Unique
fromListNClassOpKey :: Unique
fromListNName :: Name
fromListN_RDR :: RdrName
fromListName :: Name
fromList_RDR :: RdrName
fromRationalClassOpKey :: Unique
fromRationalName :: Name
fromRational_RDR :: RdrName
fromStaticPtrClassOpKey :: Unique
fromStaticPtrName :: Name
fromStringClassOpKey :: Unique
fromStringName :: Name
fromString_RDR :: RdrName
from_RDR :: RdrName
frontendPluginTyConKey :: Unique
frontendPluginTyConName :: Name
fstIdKey :: Unique
fstName :: Name
funPtrTyConKey :: Unique
funPtrTyConName :: Name
funTyConKey :: Unique
functorClassKey :: Unique
functorClassName :: Name
gENERICS :: Module
gHC_BASE :: Module
gHC_CLASSES :: Module
gHC_CONC :: Module
gHC_CSTRING :: Module
gHC_DESUGAR :: Module
gHC_ENUM :: Module
gHC_ERR :: Module
gHC_EXTS :: Module
gHC_FINGERPRINT_TYPE :: Module
gHC_FLOAT :: Module
gHC_GENERICS :: Module
gHC_GHCI :: Module
gHC_GHCI_HELPERS :: Module
gHC_INT :: Module
gHC_IO :: Module
gHC_IO_Exception :: Module
gHC_IX :: Module
gHC_LIST :: Module
gHC_MAGIC :: Module
gHC_MAYBE :: Module
gHC_NUM :: Module
gHC_NUM_BIGNAT :: Module
gHC_NUM_INTEGER :: Module
gHC_NUM_NATURAL :: Module
gHC_OVER_LABELS :: Module
gHC_PRIM :: Module
gHC_PRIMOPWRAPPERS :: Module
gHC_PRIM_EXCEPTION :: Module
gHC_PRIM_PANIC :: Module
gHC_PTR :: Module
gHC_READ :: Module
gHC_REAL :: Module
gHC_RECORDS :: Module
gHC_SHOW :: Module
gHC_SRCLOC :: Module
gHC_ST :: Module
gHC_STABLE :: Module
gHC_STACK :: Module
gHC_STACK_TYPES :: Module
gHC_STATICPTR :: Module
gHC_STATICPTR_INTERNAL :: Module
gHC_TOP_HANDLER :: Module
gHC_TUPLE :: Module
gHC_TYPELITS :: Module
gHC_TYPELITS_INTERNAL :: Module
gHC_TYPENATS :: Module
gHC_TYPENATS_INTERNAL :: Module
gHC_TYPES :: Module
gHC_WORD :: Module
geClassOpKey :: Unique
geName :: Name
ge_RDR :: RdrName
gen1ClassKey :: Unique
gen1ClassName :: Name
genClassKey :: Unique
genClassName :: Name
genUnitDataConKey :: Unique
genericClassNames :: [Name]
genericTyConNames :: [Name]
getFieldClassOpKey :: Unique
getFieldName :: Name
getTag_RDR :: RdrName
ghciIoClassKey :: Unique
ghciIoClassName :: Name
ghciStepIoMClassOpKey :: Unique
ghciStepIoMName :: Name
groupWithIdKey :: Unique
groupWithName :: Name
gtTag_RDR :: RdrName
gt_RDR :: RdrName
guardMIdKey :: Unique
guardMName :: Name
hasFieldClassName :: Name
hasFieldClassNameKey :: Unique
heqDataConKey :: Unique
heqSCSelIdKey :: Unique
heqTyConKey :: Unique
ident_RDR :: RdrName
inRange_RDR :: RdrName
index_RDR :: RdrName
infixDataCon_RDR :: RdrName
infixIDataConKey :: Unique
infixIDataConName :: Name
inlDataConKey :: Unique
inlineIdKey :: Unique
inlineIdName :: Name
inrDataConKey :: Unique
int16PrimTyConKey :: Unique
int16TyConKey :: Unique
int16TyConName :: Name
int16X16PrimTyConKey :: Unique
int16X32PrimTyConKey :: Unique
int16X8PrimTyConKey :: Unique
int32PrimTyConKey :: Unique
int32TyConKey :: Unique
int32TyConName :: Name
int32X16PrimTyConKey :: Unique
int32X4PrimTyConKey :: Unique
int32X8PrimTyConKey :: Unique
int64PrimTyConKey :: Unique
int64TyConKey :: Unique
int64TyConName :: Name
int64X2PrimTyConKey :: Unique
int64X4PrimTyConKey :: Unique
int64X8PrimTyConKey :: Unique
int8PrimTyConKey :: Unique
int8TyConKey :: Unique
int8TyConName :: Name
int8X16PrimTyConKey :: Unique
int8X32PrimTyConKey :: Unique
int8X64PrimTyConKey :: Unique
intDataConKey :: Unique
intPrimTyConKey :: Unique
intTyConKey :: Unique
integerAbsIdKey :: Unique
integerAbsName :: Name
integerAddIdKey :: Unique
integerAddName :: Name
integerAdd_RDR :: RdrName
integerAndIdKey :: Unique
integerAndName :: Name
integerBitIdKey :: Unique
integerBitName :: Name
integerCompareIdKey :: Unique
integerCompareName :: Name
integerComplementIdKey :: Unique
integerComplementName :: Name
integerDivIdKey :: Unique
integerDivModIdKey :: Unique
integerDivModName :: Name
integerDivName :: Name
integerEncodeDoubleIdKey :: Unique
integerEncodeDoubleName :: Name
integerEncodeFloatIdKey :: Unique
integerEncodeFloatName :: Name
integerEqIdKey :: Unique
integerEqName :: Name
integerFromInt64IdKey :: Unique
integerFromInt64Name :: Name
integerFromNaturalIdKey :: Unique
integerFromNaturalName :: Name
integerFromWord64IdKey :: Unique
integerFromWord64Name :: Name
integerFromWordIdKey :: Unique
integerFromWordName :: Name
integerGcdIdKey :: Unique
integerGcdName :: Name
integerGeIdKey :: Unique
integerGeName :: Name
integerGtIdKey :: Unique
integerGtName :: Name
integerINDataConKey :: Unique
integerIPDataConKey :: Unique
integerISDataConKey :: Unique
integerLcmIdKey :: Unique
integerLcmName :: Name
integerLeIdKey :: Unique
integerLeName :: Name
integerLtIdKey :: Unique
integerLtName :: Name
integerModIdKey :: Unique
integerModName :: Name
integerMulIdKey :: Unique
integerMulName :: Name
integerMul_RDR :: RdrName
integerNeIdKey :: Unique
integerNeName :: Name
integerNegateIdKey :: Unique
integerNegateName :: Name
integerOrIdKey :: Unique
integerOrName :: Name
integerPopCountIdKey :: Unique
integerPopCountName :: Name
integerQuotIdKey :: Unique
integerQuotName :: Name
integerQuotRemIdKey :: Unique
integerQuotRemName :: Name
integerRemIdKey :: Unique
integerRemName :: Name
integerShiftLIdKey :: Unique
integerShiftLName :: Name
integerShiftRIdKey :: Unique
integerShiftRName :: Name
integerSignumIdKey :: Unique
integerSignumName :: Name
integerSubIdKey :: Unique
integerSubName :: Name
integerTestBitIdKey :: Unique
integerTestBitName :: Name
integerToDoubleIdKey :: Unique
integerToDoubleName :: Name
integerToFloatIdKey :: Unique
integerToFloatName :: Name
integerToInt64IdKey :: Unique
integerToInt64Name :: Name
integerToIntIdKey :: Unique
integerToIntName :: Name
integerToNaturalClampIdKey :: Unique
integerToNaturalClampName :: Name
integerToNaturalIdKey :: Unique
integerToNaturalName :: Name
integerToNaturalThrowIdKey :: Unique
integerToNaturalThrowName :: Name
integerToWord64IdKey :: Unique
integerToWord64Name :: Name
integerToWordIdKey :: Unique
integerToWordName :: Name
integerTyConKey :: Unique
integerXorIdKey :: Unique
integerXorName :: Name
integralClassKey :: Unique
integralClassName :: Name
interactiveClassKeys :: [Unique]
interactiveClassNames :: [Name]
ioDataConKey :: Unique
ioDataConName :: Name
ioDataCon_RDR :: RdrName
ioPortPrimTyConKey :: Unique
ioTyConKey :: Unique
ioTyConName :: Name
ipClassKey :: Unique
ipClassName :: Name
isListClassKey :: Unique
isListClassName :: Name
isNewtypeName_RDR :: RdrName
isStringClassKey :: Unique
isStringClassName :: Name
isUnboundName :: Name -> Bool
itName :: Unique -> SrcSpan -> Name
ixClassKey :: Unique
ixClassName :: Name
joinMIdKey :: Unique
joinMName :: Name
justDataConKey :: Unique
k1DataCon_RDR :: RdrName
k1TyConKey :: Unique
k1TyConName :: Name
kindConKey :: Unique
kindRepAppDataConKey :: Unique
kindRepAppDataConName :: Name
kindRepFunDataConKey :: Unique
kindRepFunDataConName :: Name
kindRepTYPEDataConKey :: Unique
kindRepTYPEDataConName :: Name
kindRepTyConAppDataConKey :: Unique
kindRepTyConAppDataConName :: Name
kindRepTyConKey :: Unique
kindRepTyConName :: Name
kindRepTypeLitDDataConKey :: Unique
kindRepTypeLitDDataConName :: Name
kindRepTypeLitSDataConKey :: Unique
kindRepTypeLitSDataConName :: Name
kindRepVarDataConKey :: Unique
kindRepVarDataConName :: Name
knownCharClassName :: Name
knownCharClassNameKey :: Unique
knownNatClassName :: Name
knownNatClassNameKey :: Unique
knownSymbolClassName :: Name
knownSymbolClassNameKey :: Unique
l1DataCon_RDR :: RdrName
lEX :: Module
lazyIdKey :: Unique
le_RDR :: RdrName
leftAssocDataCon_RDR :: RdrName
leftAssociativeDataConKey :: Unique
leftAssociativeDataConName :: Name
leftDataConKey :: Unique
leftDataConName :: Name
leftSectionKey :: Unique
left_RDR :: RdrName
levityTyConKey :: Unique
lexP_RDR :: RdrName
liftA2_RDR :: RdrName
liftMIdKey :: Unique
liftMName :: Name
liftedDataConKey :: Unique
liftedRepTyConKey :: Unique
liftedTypeKindTyConKey :: Unique
listTyConKey :: Unique
loopAIdKey :: Unique
loopAName :: Name
ltTag_RDR :: RdrName
lt_RDR :: RdrName
m1DataCon_RDR :: RdrName
m1TyConKey :: Unique
m1TyConName :: Name
mAIN_NAME :: ModuleName
mONAD :: Module
mONAD_FAIL :: Module
mONAD_FIX :: Module
mONAD_ZIP :: Module
mVarPrimTyConKey :: Unique
magicDictKey :: Unique
main_RDR_Unqual :: RdrName
makeStaticKey :: Unique
makeStaticName :: Name
manyDataConKey :: Unique
mapIdKey :: Unique
mapName :: Name
map_RDR :: RdrName
mappendClassOpKey :: Unique
mappendName :: Name
mappend_RDR :: RdrName
maxBound_RDR :: RdrName
maybeTyConKey :: Unique
mconcatClassOpKey :: Unique
mconcatName :: Name
memptyClassOpKey :: Unique
memptyName :: Name
mempty_RDR :: RdrName
metaConsDataConKey :: Unique
metaConsDataConName :: Name
metaDataDataConKey :: Unique
metaDataDataConName :: Name
metaSelDataConKey :: Unique
metaSelDataConName :: Name
mfixIdKey :: Unique
mfixName :: Name
minBound_RDR :: RdrName
minusClassOpKey :: Unique
minusName :: Name
minus_RDR :: RdrName
mkBaseModule :: FastString -> Module
mkBaseModule_ :: ModuleName -> Module
mkBignumModule :: FastString -> Module
mkInteractiveModule :: Int -> Module
mkMainModule :: FastString -> Module
mkMainModule_ :: ModuleName -> Module
mkPrimModule :: FastString -> Module
mkRationalBase10IdKey :: Unique
mkRationalBase10Name :: Name
mkRationalBase2IdKey :: Unique
mkRationalBase2Name :: Name
mkThisGhcModule :: FastString -> Module
mkThisGhcModule_ :: ModuleName -> Module
mkTrAppKey :: Unique
mkTrAppName :: Name
mkTrConKey :: Unique
mkTrConName :: Name
mkTrFunKey :: Unique
mkTrFunName :: Name
mkTrTypeKey :: Unique
mkTrTypeName :: Name
mkTyConKey :: Unique
mkUnboundName :: OccName -> Name
mk_known_key_name :: NameSpace -> Module -> FastString -> Unique -> Name
modIntIdKey :: Unique
modIntName :: Name
moduleName_RDR :: RdrName
monadClassKey :: Unique
monadClassName :: Name
monadClass_RDR :: RdrName
monadFailClassKey :: Unique
monadFailClassName :: Name
monadFixClassKey :: Unique
monadFixClassName :: Name
monadPlusClassKey :: Unique
monadPlusClassName :: Name
monoidClassKey :: Unique
monoidClassName :: Name
multMulTyConKey :: Unique
multiplicityTyConKey :: Unique
mutVarPrimTyConKey :: Unique
mutableArrayArrayPrimTyConKey :: Unique
mutableArrayPrimTyConKey :: Unique
mutableByteArrayPrimTyConKey :: Unique
mzipIdKey :: Unique
mzipName :: Name
naturalAddIdKey :: Unique
naturalAddName :: Name
naturalAndIdKey :: Unique
naturalAndName :: Name
naturalAndNotIdKey :: Unique
naturalAndNotName :: Name
naturalBitIdKey :: Unique
naturalBitName :: Name
naturalCompareIdKey :: Unique
naturalCompareName :: Name
naturalEqIdKey :: Unique
naturalEqName :: Name
naturalGcdIdKey :: Unique
naturalGcdName :: Name
naturalGeIdKey :: Unique
naturalGeName :: Name
naturalGtIdKey :: Unique
naturalGtName :: Name
naturalLcmIdKey :: Unique
naturalLcmName :: Name
naturalLeIdKey :: Unique
naturalLeName :: Name
naturalLog2IdKey :: Unique
naturalLog2Name :: Name
naturalLogBaseIdKey :: Unique
naturalLogBaseName :: Name
naturalLogBaseWordIdKey :: Unique
naturalLogBaseWordName :: Name
naturalLtIdKey :: Unique
naturalLtName :: Name
naturalMulIdKey :: Unique
naturalMulName :: Name
naturalNBDataConKey :: Unique
naturalNSDataConKey :: Unique
naturalNeIdKey :: Unique
naturalNeName :: Name
naturalNegateIdKey :: Unique
naturalNegateName :: Name
naturalOrIdKey :: Unique
naturalOrName :: Name
naturalPopCountIdKey :: Unique
naturalPopCountName :: Name
naturalPowModIdKey :: Unique
naturalPowModName :: Name
naturalQuotIdKey :: Unique
naturalQuotName :: Name
naturalQuotRemIdKey :: Unique
naturalQuotRemName :: Name
naturalRemIdKey :: Unique
naturalRemName :: Name
naturalShiftLIdKey :: Unique
naturalShiftLName :: Name
naturalShiftRIdKey :: Unique
naturalShiftRName :: Name
naturalSignumIdKey :: Unique
naturalSignumName :: Name
naturalSizeInBaseIdKey :: Unique
naturalSizeInBaseName :: Name
naturalSubIdKey :: Unique
naturalSubName :: Name
naturalSubThrowIdKey :: Unique
naturalSubThrowName :: Name
naturalSubUnsafeIdKey :: Unique
naturalSubUnsafeName :: Name
naturalTestBitIdKey :: Unique
naturalTestBitName :: Name
naturalToDoubleIdKey :: Unique
naturalToDoubleName :: Name
naturalToFloatIdKey :: Unique
naturalToFloatName :: Name
naturalToWordClampIdKey :: Unique
naturalToWordClampName :: Name
naturalToWordIdKey :: Unique
naturalToWordName :: Name
naturalTyConKey :: Unique
naturalXorIdKey :: Unique
naturalXorName :: Name
negateClassOpKey :: Unique
negateName :: Name
newStablePtrIdKey :: Unique
newStablePtrName :: Name
newStablePtr_RDR :: RdrName
nilDataConKey :: Unique
noMethodBindingErrorIdKey :: Unique
noSelTyConKey :: Unique
noSelTyConName :: Name
noSourceStrictnessDataConKey :: Unique
noSourceStrictnessDataConName :: Name
noSourceUnpackednessDataConKey :: Unique
noSourceUnpackednessDataConName :: Name
noinlineIdKey :: Unique
nonEmptyDataConKey :: Unique
nonEmptyTyConKey :: Unique
nonExhaustiveGuardsErrorIdKey :: Unique
notAssocDataCon_RDR :: RdrName
notAssociativeDataConKey :: Unique
notAssociativeDataConName :: Name
not_RDR :: RdrName
nothingDataConKey :: Unique
nullAddrIdKey :: Unique
null_RDR :: RdrName
numClassKey :: Unique
numClassName :: Name
numClass_RDR :: RdrName
numericClassKeys :: [Unique]
oneDataConKey :: Unique
oneShotKey :: Unique
opaqueTyConKey :: Unique
opaqueTyConName :: Name
ordClassKey :: Unique
ordClassName :: Name
ordClass_RDR :: RdrName
ordEQDataConKey :: Unique
ordEQDataConName :: Name
ordGTDataConKey :: Unique
ordGTDataConName :: Name
ordLTDataConKey :: Unique
ordLTDataConName :: Name
orderingTyConKey :: Unique
orderingTyConName :: Name
otherwiseIdKey :: Unique
otherwiseIdName :: Name
pLUGINS :: Module
pRELUDE :: Module
pRELUDE_NAME :: ModuleName
packageName_RDR :: RdrName
par1DataCon_RDR :: RdrName
par1TyConKey :: Unique
par1TyConName :: Name
parens_RDR :: RdrName
patErrorIdKey :: Unique
pfail_RDR :: RdrName
pluginTyConKey :: Unique
pluginTyConName :: Name
plus_RDR :: RdrName
prec_RDR :: RdrName
pred_RDR :: RdrName
prefixDataCon_RDR :: RdrName
prefixIDataConKey :: Unique
prefixIDataConName :: Name
pretendNameIsInScope :: Name -> Bool
printIdKey :: Unique
printName :: Name
prodDataCon_RDR :: RdrName
prodTyConKey :: Unique
prodTyConName :: Name
proxyHashKey :: Unique
proxyPrimTyConKey :: Unique
ptrTyConKey :: Unique
ptrTyConName :: Name
punc_RDR :: RdrName
pureAClassOpKey :: Unique
pureAName :: Name
pure_RDR :: RdrName
pushCallStackKey :: Unique
pushCallStackName :: Name
r1DataCon_RDR :: RdrName
rANDOM :: Module
rEAD_PREC :: Module
rOOT_MAIN :: Module
rTyConKey :: Unique
rTyConName :: Name
raiseDivZeroIdKey :: Unique
raiseOverflowIdKey :: Unique
raiseUnderflowIdKey :: Unique
randomClassKey :: Unique
randomClassName :: Name
randomGenClassKey :: Unique
randomGenClassName :: Name
range_RDR :: RdrName
ratioDataConKey :: Unique
ratioDataConName :: Name
ratioDataCon_RDR :: RdrName
ratioTyConKey :: Unique
ratioTyConName :: Name
rationalToDoubleIdKey :: Unique
rationalToDoubleName :: Name
rationalToFloatIdKey :: Unique
rationalToFloatName :: Name
rationalTyConKey :: Unique
rationalTyConName :: Name
readClassKey :: Unique
readClassName :: Name
readFieldHash_RDR :: RdrName
readField_RDR :: RdrName
readListDefault_RDR :: RdrName
readListPrecDefault_RDR :: RdrName
readListPrec_RDR :: RdrName
readList_RDR :: RdrName
readPrec_RDR :: RdrName
readSymField_RDR :: RdrName
realClassKey :: Unique
realClassName :: Name
realFloatClassKey :: Unique
realFloatClassName :: Name
realFracClassKey :: Unique
realFracClassName :: Name
realToFracIdKey :: Unique
realToFracName :: Name
realWorldPrimIdKey :: Unique
realWorldTyConKey :: Unique
rec0TyConKey :: Unique
rec0TyConName :: Name
rec1DataCon_RDR :: RdrName
rec1TyConKey :: Unique
rec1TyConName :: Name
recConErrorIdKey :: Unique
recSelErrorIdKey :: Unique
rep1TyConKey :: Unique
rep1TyConName :: Name
repTyConKey :: Unique
repTyConName :: Name
replace_RDR :: RdrName
reset_RDR :: RdrName
returnIOIdKey :: Unique
returnIOName :: Name
returnIO_RDR :: RdrName
returnMClassOpKey :: Unique
returnMName :: Name
returnM_RDR :: RdrName
rightAssocDataCon_RDR :: RdrName
rightAssociativeDataConKey :: Unique
rightAssociativeDataConName :: Name
rightDataConKey :: Unique
rightDataConName :: Name
rightSectionKey :: Unique
right_RDR :: RdrName
rootMainKey :: Unique
runMainIOName :: Name
runMainKey :: Unique
runRWKey :: Unique
runRWName :: Name
runtimeErrorIdKey :: Unique
runtimeRepSimpleDataConKeys :: [Unique]
runtimeRepTyConKey :: Unique
s1TyConKey :: Unique
s1TyConName :: Name
sTyConKey :: Unique
sTyConName :: Name
sYSTEM_IO :: Module
sappendClassOpKey :: Unique
sappendName :: Name
selName_RDR :: RdrName
selectorClassKey :: Unique
selectorClassName :: Name
semigroupClassKey :: Unique
semigroupClassName :: Name
seqIdKey :: Unique
setFieldClassOpKey :: Unique
setFieldName :: Name
showClassKey :: Unique
showClassName :: Name
showCommaSpace_RDR :: RdrName
showParen_RDR :: RdrName
showSpace_RDR :: RdrName
showString_RDR :: RdrName
showsPrec_RDR :: RdrName
shows_RDR :: RdrName
smallArrayPrimTyConKey :: Unique
smallMutableArrayPrimTyConKey :: Unique
sndIdKey :: Unique
sndName :: Name
someTypeRepDataConKey :: Unique
someTypeRepDataConName :: Name
someTypeRepTyConKey :: Unique
someTypeRepTyConName :: Name
sourceLazyDataConKey :: Unique
sourceLazyDataConName :: Name
sourceNoUnpackDataConKey :: Unique
sourceNoUnpackDataConName :: Name
sourceStrictDataConKey :: Unique
sourceStrictDataConName :: Name
sourceUnpackDataConKey :: Unique
sourceUnpackDataConName :: Name
specTyConKey :: Unique
specTyConName :: Name
srcLocDataConKey :: Unique
srcLocDataConName :: Name
stableNameDataConKey :: Unique
stableNamePrimTyConKey :: Unique
stableNameTyConKey :: Unique
stablePtrPrimTyConKey :: Unique
stablePtrTyConKey :: Unique
stablePtrTyConName :: Name
standardClassKeys :: [Unique]
starArrStarArrStarKindRepKey :: Unique
starArrStarArrStarKindRepName :: Name
starArrStarKindRepKey :: Unique
starArrStarKindRepName :: Name
starKindRepKey :: Unique
starKindRepName :: Name
statePrimTyConKey :: Unique
staticPtrDataConKey :: Unique
staticPtrDataConName :: Name
staticPtrInfoDataConKey :: Unique
staticPtrInfoDataConName :: Name
staticPtrInfoTyConKey :: Unique
staticPtrInfoTyConName :: Name
staticPtrTyConKey :: Unique
staticPtrTyConName :: Name
step_RDR :: RdrName
stringTyConKey :: Unique
succ_RDR :: RdrName
sumRepDataConKey :: Unique
sumTyConKey :: Unique
sumTyConName :: Name
symbol_RDR :: RdrName
tVarPrimTyConKey :: Unique
tYPEABLE :: Module
tYPEABLE_INTERNAL :: Module
tYPETyConKey :: Unique
tcQual :: Module -> FastString -> Unique -> Name
tcQual_RDR :: Module -> FastString -> RdrName
thenAClassOpKey :: Unique
thenAName :: Name
thenIOIdKey :: Unique
thenIOName :: Name
thenMClassOpKey :: Unique
thenMName :: Name
threadIdPrimTyConKey :: Unique
times_RDR :: RdrName
to1_RDR :: RdrName
toAnnotationWrapperIdKey :: Unique
toAnnotationWrapperName :: Name
toDynIdKey :: Unique
toDynName :: Name
toEnum_RDR :: RdrName
toIntegerClassOpKey :: Unique
toIntegerName :: Name
toInteger_RDR :: RdrName
toListClassOpKey :: Unique
toListName :: Name
toList_RDR :: RdrName
toRationalClassOpKey :: Unique
toRationalName :: Name
toRational_RDR :: RdrName
to_RDR :: RdrName
tr'PtrRepLiftedKey :: Unique
trGhcPrimModuleKey :: Unique
trGhcPrimModuleName :: Name
trLiftedRepKey :: Unique
trModuleDataConKey :: Unique
trModuleDataConName :: Name
trModuleTyConKey :: Unique
trModuleTyConName :: Name
trNameDDataConKey :: Unique
trNameDDataConName :: Name
trNameSDataConKey :: Unique
trNameSDataConName :: Name
trNameTyConKey :: Unique
trNameTyConName :: Name
trRuntimeRepKey :: Unique
trTYPE'PtrRepLiftedKey :: Unique
trTYPEKey :: Unique
trTyConDataConKey :: Unique
trTyConDataConName :: Name
trTyConTyConKey :: Unique
trTyConTyConName :: Name
traceKey :: Unique
traceName :: Name
traversableClassKey :: Unique
traversableClassName :: Name
traverse_RDR :: RdrName
trueDataConKey :: Unique
tupleRepDataConKey :: Unique
typeCharCmpTyFamNameKey :: Unique
typeCharKindConNameKey :: Unique
typeCharToNatTyFamNameKey :: Unique
typeCharTypeRepKey :: Unique
typeCharTypeRepName :: Name
typeConKey :: Unique
typeConsSymbolTyFamNameKey :: Unique
typeErrorAppendDataConKey :: Unique
typeErrorAppendDataConName :: Name
typeErrorIdKey :: Unique
typeErrorShowTypeDataConKey :: Unique
typeErrorShowTypeDataConName :: Name
typeErrorTextDataConKey :: Unique
typeErrorTextDataConName :: Name
typeErrorVAppendDataConKey :: Unique
typeErrorVAppendDataConName :: Name
typeLeqCharTyFamNameKey :: Unique
typeLitCharDataConKey :: Unique
typeLitCharDataConName :: Name
typeLitNatDataConKey :: Unique
typeLitNatDataConName :: Name
typeLitSortTyConKey :: Unique
typeLitSortTyConName :: Name
typeLitSymbolDataConKey :: Unique
typeLitSymbolDataConName :: Name
typeNatAddTyFamNameKey :: Unique
typeNatCmpTyFamNameKey :: Unique
typeNatDivTyFamNameKey :: Unique
typeNatExpTyFamNameKey :: Unique
typeNatLogTyFamNameKey :: Unique
typeNatModTyFamNameKey :: Unique
typeNatMulTyFamNameKey :: Unique
typeNatSubTyFamNameKey :: Unique
typeNatToCharTyFamNameKey :: Unique
typeNatTypeRepKey :: Unique
typeNatTypeRepName :: Name
typeRepIdKey :: Unique
typeRepIdName :: Name
typeRepTyConKey :: Unique
typeRepTyConName :: Name
typeSymbolAppendFamNameKey :: Unique
typeSymbolCmpTyFamNameKey :: Unique
typeSymbolKindConNameKey :: Unique
typeSymbolTypeRepKey :: Unique
typeSymbolTypeRepName :: Name
typeUnconsSymbolTyFamNameKey :: Unique
typeableClassKey :: Unique
typeableClassName :: Name
u1DataCon_RDR :: RdrName
u1TyConKey :: Unique
u1TyConName :: Name
uAddrDataCon_RDR :: RdrName
uAddrHash_RDR :: RdrName
uAddrTyConKey :: Unique
uAddrTyConName :: Name
uCharDataCon_RDR :: RdrName
uCharHash_RDR :: RdrName
uCharTyConKey :: Unique
uCharTyConName :: Name
uDoubleDataCon_RDR :: RdrName
uDoubleHash_RDR :: RdrName
uDoubleTyConKey :: Unique
uDoubleTyConName :: Name
uFloatDataCon_RDR :: RdrName
uFloatHash_RDR :: RdrName
uFloatTyConKey :: Unique
uFloatTyConName :: Name
uIntDataCon_RDR :: RdrName
uIntHash_RDR :: RdrName
uIntTyConKey :: Unique
uIntTyConName :: Name
uNSAFE_COERCE :: Module
uRecTyConKey :: Unique
uRecTyConName :: Name
uWordDataCon_RDR :: RdrName
uWordHash_RDR :: RdrName
uWordTyConKey :: Unique
uWordTyConName :: Name
unComp1_RDR :: RdrName
unK1_RDR :: RdrName
unPar1_RDR :: RdrName
unRec1_RDR :: RdrName
unboundKey :: Unique
unknown1TyConKey :: Unique
unknown2TyConKey :: Unique
unknown3TyConKey :: Unique
unknownTyConKey :: Unique
unliftedDataConKey :: Unique
unliftedRepTyConKey :: Unique
unliftedTypeKindTyConKey :: Unique
unpackCStringAppendIdKey :: Unique
unpackCStringFoldrIdKey :: Unique
unpackCStringFoldrName :: Name
unpackCStringFoldrUtf8IdKey :: Unique
unpackCStringFoldrUtf8Name :: Name
unpackCStringFoldrUtf8_RDR :: RdrName
unpackCStringFoldr_RDR :: RdrName
unpackCStringIdKey :: Unique
unpackCStringName :: Name
unpackCStringUtf8IdKey :: Unique
unpackCStringUtf8Name :: Name
unpackCStringUtf8_RDR :: RdrName
unpackCString_RDR :: RdrName
unrestrictedFunTyConKey :: Unique
unsafeCoercePrimIdKey :: Unique
unsafeCoercePrimName :: Name
unsafeEqualityProofIdKey :: Unique
unsafeEqualityProofName :: Name
unsafeEqualityTyConKey :: Unique
unsafeEqualityTyConName :: Name
unsafeIndex_RDR :: RdrName
unsafeRangeSize_RDR :: RdrName
unsafeReflDataConKey :: Unique
unsafeReflDataConName :: Name
v1TyConKey :: Unique
v1TyConName :: Name
varQual :: Module -> FastString -> Unique -> Name
varQual_RDR :: Module -> FastString -> RdrName
vecCountDataConKeys :: [Unique]
vecCountTyConKey :: Unique
vecElemDataConKeys :: [Unique]
vecElemTyConKey :: Unique
vecRepDataConKey :: Unique
voidArgIdKey :: Unique
voidPrimIdKey :: Unique
weakPrimTyConKey :: Unique
wildCardKey :: Unique
wildCardName :: Name
word16PrimTyConKey :: Unique
word16TyConKey :: Unique
word16TyConName :: Name
word16X16PrimTyConKey :: Unique
word16X32PrimTyConKey :: Unique
word16X8PrimTyConKey :: Unique
word32PrimTyConKey :: Unique
word32TyConKey :: Unique
word32TyConName :: Name
word32X16PrimTyConKey :: Unique
word32X4PrimTyConKey :: Unique
word32X8PrimTyConKey :: Unique
word64PrimTyConKey :: Unique
word64TyConKey :: Unique
word64TyConName :: Name
word64X2PrimTyConKey :: Unique
word64X4PrimTyConKey :: Unique
word64X8PrimTyConKey :: Unique
word8DataConKey :: Unique
word8PrimTyConKey :: Unique
word8TyConKey :: Unique
word8TyConName :: Name
word8X16PrimTyConKey :: Unique
word8X32PrimTyConKey :: Unique
word8X64PrimTyConKey :: Unique
wordDataConKey :: Unique
wordPrimTyConKey :: Unique
wordTyConKey :: Unique
zipIdKey :: Unique
zipName :: Name

module GHC.Core.Ppr
pprCoreExpr :: OutputableBndr b => Expr b -> SDoc
pprParendExpr :: OutputableBndr b => Expr b -> SDoc
pprCoreBinding :: OutputableBndr b => Bind b -> SDoc
pprCoreBindings :: OutputableBndr b => [Bind b] -> SDoc
pprCoreAlt :: OutputableBndr a => Alt a -> SDoc
pprCoreBindingWithSize :: CoreBind -> SDoc
pprCoreBindingsWithSize :: [CoreBind] -> SDoc
pprCoreBinder :: BindingSite -> Var -> SDoc
pprCoreBinders :: [Var] -> SDoc
pprRules :: [CoreRule] -> SDoc
pprOptCo :: Coercion -> SDoc
instance GHC.Utils.Outputable.OutputableBndr b => GHC.Utils.Outputable.Outputable (GHC.Core.Bind b)
instance GHC.Utils.Outputable.OutputableBndr b => GHC.Utils.Outputable.Outputable (GHC.Core.Expr b)
instance GHC.Utils.Outputable.OutputableBndr b => GHC.Utils.Outputable.Outputable (GHC.Core.Alt b)
instance GHC.Utils.Outputable.OutputableBndr GHC.Types.Var.Var
instance GHC.Utils.Outputable.Outputable b => GHC.Utils.Outputable.OutputableBndr (GHC.Core.TaggedBndr b)
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.IdInfo
instance GHC.Utils.Outputable.Outputable GHC.Core.UnfoldingGuidance
instance GHC.Utils.Outputable.Outputable GHC.Core.UnfoldingSource
instance GHC.Utils.Outputable.Outputable GHC.Core.Unfolding
instance GHC.Utils.Outputable.Outputable GHC.Core.CoreRule
instance GHC.Utils.Outputable.Outputable (GHC.Types.Tickish.XTickishId pass) => GHC.Utils.Outputable.Outputable (GHC.Types.Tickish.GenTickish pass)


-- | Functions to computing the statistics reflective of the "size" of a
--   Core expression
module GHC.Core.Stats
coreBindsSize :: [CoreBind] -> Int

-- | A measure of the size of the expressions, strictly greater than 0
--   Counts *leaves*, not internal nodes. Types and coercions are not
--   counted.
exprSize :: CoreExpr -> Int
data CoreStats
CS :: !Int -> !Int -> !Int -> !Int -> !Int -> CoreStats
[cs_tm] :: CoreStats -> !Int
[cs_ty] :: CoreStats -> !Int
[cs_co] :: CoreStats -> !Int
[cs_vb] :: CoreStats -> !Int
[cs_jb] :: CoreStats -> !Int
coreBindsStats :: [CoreBind] -> CoreStats
exprStats :: CoreExpr -> CoreStats
instance GHC.Utils.Outputable.Outputable GHC.Core.Stats.CoreStats


-- | GHC.Core holds all the main data types for use by for the Glasgow
--   Haskell Compiler midsection
module GHC.Core

-- | This is the data type that represents GHCs core intermediate language.
--   Currently GHC uses System FC
--   <a>https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions/</a>
--   for this purpose, which is closely related to the simpler and better
--   known System F <a>http://en.wikipedia.org/wiki/System_F</a>.
--   
--   We get from Haskell source to this Core language in a number of
--   stages:
--   
--   <ol>
--   <li>The source code is parsed into an abstract syntax tree, which is
--   represented by the data type <a>HsExpr</a> with the names being
--   <a>RdrNames</a></li>
--   <li>This syntax tree is <i>renamed</i>, which attaches a <a>Unique</a>
--   to every <a>RdrName</a> (yielding a <a>Name</a>) to disambiguate
--   identifiers which are lexically identical. For example, this
--   program:</li>
--   </ol>
--   
--   <pre>
--   f x = let f x = x + 1
--         in f (x - 2)
--   </pre>
--   
--   Would be renamed by having <tt>Unique</tt>s attached so it looked
--   something like this:
--   
--   <pre>
--   f_1 x_2 = let f_3 x_4 = x_4 + 1
--             in f_3 (x_2 - 2)
--   </pre>
--   
--   But see Note [Shadowing] below.
--   
--   <ol>
--   <li>The resulting syntax tree undergoes type checking (which also
--   deals with instantiating type class arguments) to yield a
--   <a>HsExpr</a> type that has <a>Id</a> as it's names.</li>
--   <li>Finally the syntax tree is <i>desugared</i> from the expressive
--   <a>HsExpr</a> type into this <a>Expr</a> type, which has far fewer
--   constructors and hence is easier to perform optimization, analysis and
--   code generation on.</li>
--   </ol>
--   
--   The type parameter <tt>b</tt> is for the type of binders in the
--   expression tree.
--   
--   The language consists of the following elements:
--   
--   <ul>
--   <li>Variables See Note [Variable occurrences in Core]</li>
--   <li>Primitive literals</li>
--   <li>Applications: note that the argument may be a <a>Expr</a>. See
--   Note [Core let/app invariant] See Note [Levity polymorphism
--   invariants]</li>
--   <li>Lambda abstraction See Note [Levity polymorphism invariants]</li>
--   <li>Recursive and non recursive <tt>let</tt>s. Operationally this
--   corresponds to allocating a thunk for the things bound and then
--   executing the sub-expression.</li>
--   </ul>
--   
--   See Note [Core letrec invariant] See Note [Core let/app invariant] See
--   Note [Levity polymorphism invariants] See Note [Core type and coercion
--   invariant]
--   
--   <ul>
--   <li>Case expression. Operationally this corresponds to evaluating the
--   scrutinee (expression examined) to weak head normal form and then
--   examining at most one level of resulting constructor (i.e. you cannot
--   do nested pattern matching directly with this).</li>
--   </ul>
--   
--   The binder gets bound to the value of the scrutinee, and the
--   <a>Expr</a> must be that of all the case alternatives
--   
--   IMPORTANT: see Note [Case expression invariants]
--   
--   <ul>
--   <li>Cast an expression to a particular type. This is used to implement
--   <tt>newtype</tt>s (a <tt>newtype</tt> constructor or destructor just
--   becomes a <a>Cast</a> in Core) and GADTs.</li>
--   <li>Ticks. These are used to represent all the source annotation we
--   support: profiling SCCs, HPC ticks, and GHCi breakpoints.</li>
--   <li>A type: this should only show up at the top level of an Arg</li>
--   <li>A coercion</li>
--   </ul>
data Expr b
Var :: Id -> Expr b
Lit :: Literal -> Expr b
App :: Expr b -> Arg b -> Expr b
Lam :: b -> Expr b -> Expr b
Let :: Bind b -> Expr b -> Expr b
Case :: Expr b -> b -> Type -> [Alt b] -> Expr b
Cast :: Expr b -> CoercionR -> Expr b
Tick :: CoreTickish -> Expr b -> Expr b
Type :: Type -> Expr b
Coercion :: Coercion -> Expr b
infixl 4 `App`

-- | A case split alternative. Consists of the constructor leading to the
--   alternative, the variables bound from the constructor, and the
--   expression to be executed given that binding. The default alternative
--   is <tt>(DEFAULT, [], rhs)</tt>
data Alt b
Alt :: AltCon -> [b] -> Expr b -> Alt b

-- | Binding, used for top level bindings in a module and local bindings in
--   a <tt>let</tt>.
data Bind b
NonRec :: b -> Expr b -> Bind b
Rec :: [(b, Expr b)] -> Bind b

-- | A case alternative constructor (i.e. pattern match)
data AltCon
DataAlt :: DataCon -> AltCon

-- | A literal: <tt>case e of { 1 -&gt; ... }</tt> Invariant: always an
--   *unlifted* literal See Note [Literal alternatives]
LitAlt :: Literal -> AltCon

-- | Trivial alternative: <tt>case e of { _ -&gt; ... }</tt>
DEFAULT :: AltCon

-- | Type synonym for expressions that occur in function argument
--   positions. Only <a>Arg</a> should contain a <a>Expr</a> at top level,
--   general <a>Expr</a> should not
type Arg b = Expr b
type CoreProgram = [CoreBind]

-- | Expressions where binders are <a>CoreBndr</a>s
type CoreExpr = Expr CoreBndr

-- | Case alternatives where binders are <a>CoreBndr</a>s
type CoreAlt = Alt CoreBndr

-- | Binding groups where binders are <a>CoreBndr</a>s
type CoreBind = Bind CoreBndr

-- | Argument expressions where binders are <a>CoreBndr</a>s
type CoreArg = Arg CoreBndr

-- | The common case for the type of binders and variables when we are
--   manipulating the Core language within GHC
type CoreBndr = Var
type TaggedExpr t = Expr (TaggedBndr t)
type TaggedAlt t = Alt (TaggedBndr t)
type TaggedBind t = Bind (TaggedBndr t)
type TaggedArg t = Arg (TaggedBndr t)

-- | Binders are <i>tagged</i> with a t
data TaggedBndr t
TB :: CoreBndr -> t -> TaggedBndr t
deTagExpr :: TaggedExpr t -> CoreExpr
type InId = Id
type InBind = CoreBind
type InExpr = CoreExpr
type InAlt = CoreAlt
type InArg = CoreArg
type InType = Type
type InKind = Kind
type InBndr = CoreBndr
type InVar = Var
type InCoercion = Coercion
type InTyVar = TyVar
type InCoVar = CoVar
type OutId = Id
type OutBind = CoreBind
type OutExpr = CoreExpr
type OutAlt = CoreAlt
type OutArg = CoreArg
type OutType = Type
type OutKind = Kind
type OutBndr = CoreBndr
type OutVar = Var
type OutCoercion = Coercion
type OutTyVar = TyVar
type OutCoVar = CoVar
type MOutCoercion = MCoercion
mkLet :: Bind b -> Expr b -> Expr b

-- | Bind all supplied binding groups over an expression in a nested let
--   expression. Assumes that the rhs satisfies the let/app invariant.
--   Prefer to use <a>mkCoreLets</a> if possible, which does guarantee the
--   invariant
mkLets :: [Bind b] -> Expr b -> Expr b

-- | <tt>mkLetNonRec bndr rhs body</tt> wraps <tt>body</tt> in a
--   <tt>let</tt> binding <tt>bndr</tt>.
mkLetNonRec :: b -> Expr b -> Expr b -> Expr b

-- | <tt>mkLetRec binds body</tt> wraps <tt>body</tt> in a <tt>let rec</tt>
--   with the given set of <tt>binds</tt> if binds is non-empty.
mkLetRec :: [(b, Expr b)] -> Expr b -> Expr b

-- | Bind all supplied binders over an expression in a nested lambda
--   expression. Prefer to use <a>mkCoreLams</a> if possible
mkLams :: [b] -> Expr b -> Expr b

-- | Apply a list of argument expressions to a function expression in a
--   nested fashion. Prefer to use <a>mkCoreApps</a> if possible
mkApps :: Expr b -> [Arg b] -> Expr b
infixl 4 `mkApps`

-- | Apply a list of type argument expressions to a function expression in
--   a nested fashion
mkTyApps :: Expr b -> [Type] -> Expr b
infixl 4 `mkTyApps`

-- | Apply a list of coercion argument expressions to a function expression
--   in a nested fashion
mkCoApps :: Expr b -> [Coercion] -> Expr b
infixl 4 `mkCoApps`

-- | Apply a list of type or value variables to a function expression in a
--   nested fashion
mkVarApps :: Expr b -> [Var] -> Expr b
infixl 4 `mkVarApps`
mkTyArg :: Type -> Expr b

-- | Create a machine integer literal expression of type <tt>Int#</tt> from
--   an <tt>Integer</tt>. If you want an expression of type <tt>Int</tt>
--   use <a>mkIntExpr</a>
mkIntLit :: Platform -> Integer -> Expr b

-- | Create a machine integer literal expression of type <tt>Int#</tt> from
--   an <tt>Integer</tt>, wrapping if necessary. If you want an expression
--   of type <tt>Int</tt> use <a>mkIntExpr</a>
mkIntLitWrap :: Platform -> Integer -> Expr b

-- | Create a machine word literal expression of type <tt>Word#</tt> from
--   an <tt>Integer</tt>. If you want an expression of type <tt>Word</tt>
--   use <a>mkWordExpr</a>
mkWordLit :: Platform -> Integer -> Expr b

-- | Create a machine word literal expression of type <tt>Word#</tt> from
--   an <tt>Integer</tt>, wrapping if necessary. If you want an expression
--   of type <tt>Word</tt> use <a>mkWordExpr</a>
mkWordLitWrap :: Platform -> Integer -> Expr b
mkWord8Lit :: Integer -> Expr b
mkWord64LitWord64 :: Word64 -> Expr b
mkInt64LitInt64 :: Int64 -> Expr b

-- | Create a machine character literal expression of type <tt>Char#</tt>.
--   If you want an expression of type <tt>Char</tt> use <a>mkCharExpr</a>
mkCharLit :: Char -> Expr b

-- | Create a machine string literal expression of type <tt>Addr#</tt>. If
--   you want an expression of type <tt>String</tt> use <a>mkStringExpr</a>
mkStringLit :: String -> Expr b

-- | Create a machine single precision literal expression of type
--   <tt>Float#</tt> from a <tt>Rational</tt>. If you want an expression of
--   type <tt>Float</tt> use <a>mkFloatExpr</a>
mkFloatLit :: Rational -> Expr b

-- | Create a machine single precision literal expression of type
--   <tt>Float#</tt> from a <tt>Float</tt>. If you want an expression of
--   type <tt>Float</tt> use <a>mkFloatExpr</a>
mkFloatLitFloat :: Float -> Expr b

-- | Create a machine double precision literal expression of type
--   <tt>Double#</tt> from a <tt>Rational</tt>. If you want an expression
--   of type <tt>Double</tt> use <a>mkDoubleExpr</a>
mkDoubleLit :: Rational -> Expr b

-- | Create a machine double precision literal expression of type
--   <tt>Double#</tt> from a <tt>Double</tt>. If you want an expression of
--   type <tt>Double</tt> use <a>mkDoubleExpr</a>
mkDoubleLitDouble :: Double -> Expr b

-- | Apply a list of argument expressions to a data constructor in a nested
--   fashion. Prefer to use <a>mkCoreConApps</a> if possible
mkConApp :: DataCon -> [Arg b] -> Expr b
mkConApp2 :: DataCon -> [Type] -> [Var] -> Expr b

-- | Create a binding group where a type variable is bound to a type. Per
--   Note [Core type and coercion invariant], this can only be used to bind
--   something in a non-recursive <tt>let</tt> expression
mkTyBind :: TyVar -> Type -> CoreBind

-- | Create a binding group where a type variable is bound to a type. Per
--   Note [Core type and coercion invariant], this can only be used to bind
--   something in a non-recursive <tt>let</tt> expression
mkCoBind :: CoVar -> Coercion -> CoreBind

-- | Convert a binder into either a <a>Expr</a> or <a>Expr</a> <a>Expr</a>
--   appropriately
varToCoreExpr :: CoreBndr -> Expr b
varsToCoreExprs :: [CoreBndr] -> [Expr b]

-- | Is this a value-level (i.e., computationally relevant)
--   <a>Var</a>entifier? Satisfies <tt>isId = not . isTyVar</tt>.
isId :: Var -> Bool

-- | Compares <a>AltCon</a>s within a single list of alternatives DEFAULT
--   comes out smallest, so that sorting by AltCon puts alternatives in the
--   order required: see Note [Case expression invariants]
cmpAltCon :: AltCon -> AltCon -> Ordering
cmpAlt :: Alt a -> Alt a -> Ordering
ltAlt :: Alt a -> Alt a -> Bool

-- | Extract every variable by this group
bindersOf :: Bind b -> [b]

-- | <a>bindersOf</a> applied to a list of binding groups
bindersOfBinds :: [Bind b] -> [b]
rhssOfBind :: Bind b -> [Expr b]
rhssOfAlts :: [Alt b] -> [Expr b]

-- | We often want to strip off leading lambdas before getting down to
--   business. Variants are <a>collectTyBinders</a>,
--   <a>collectValBinders</a>, and <a>collectTyAndValBinders</a>
collectBinders :: Expr b -> ([b], Expr b)
collectTyBinders :: CoreExpr -> ([TyVar], CoreExpr)
collectTyAndValBinders :: CoreExpr -> ([TyVar], [Id], CoreExpr)

-- | Strip off exactly N leading lambdas (type or value). Good for use with
--   join points.
collectNBinders :: Int -> Expr b -> ([b], Expr b)

-- | Takes a nested application expression and returns the function being
--   applied and the arguments to which it is applied
collectArgs :: Expr b -> (Expr b, [Arg b])

-- | Attempt to remove the last N arguments of a function call. Strip off
--   any ticks or coercions encountered along the way and any at the end.
stripNArgs :: Word -> Expr a -> Maybe (Expr a)

-- | Like <tt>collectArgs</tt>, but also collects looks through floatable
--   ticks if it means that we can find more arguments.
collectArgsTicks :: (CoreTickish -> Bool) -> Expr b -> (Expr b, [Arg b], [CoreTickish])

-- | Collapse all the bindings in the supplied groups into a single list of
--   lhs/rhs pairs suitable for binding in a <a>Rec</a> binding group
flattenBinds :: [Bind b] -> [(b, Expr b)]

-- | If the expression is a <a>Expr</a>, converts. Otherwise, panics. NB:
--   This does <i>not</i> convert <a>Expr</a> to <tt>CoercionTy</tt>.
exprToType :: CoreExpr -> Type

-- | If the expression is a <a>Expr</a>, converts.
exprToCoercion_maybe :: CoreExpr -> Maybe Coercion

-- | Determines the type resulting from applying an expression with given
--   type to a given argument expression
applyTypeToArg :: Type -> CoreExpr -> Type

-- | Returns <tt>True</tt> for value arguments, false for type args NB:
--   coercions are value arguments (zero width, to be sure, like State#,
--   but still value args).
isValArg :: Expr b -> Bool

-- | Returns <tt>True</tt> iff the expression is a <a>Expr</a> expression
--   at its top level. Note this does NOT include <a>Expr</a>s.
isTypeArg :: Expr b -> Bool

-- | Returns <tt>True</tt> iff the expression is a <a>Expr</a> expression
--   at its top level
isCoArg :: Expr b -> Bool

-- | Returns <tt>True</tt> iff the expression is a <a>Expr</a> or
--   <a>Expr</a> expression at its top level
isTyCoArg :: Expr b -> Bool

-- | The number of argument expressions that are values rather than types
--   at their top level
valArgCount :: [Arg b] -> Int

-- | The number of binders that bind values rather than types
valBndrCount :: [CoreBndr] -> Int

-- | Will this argument expression exist at runtime?
isRuntimeArg :: CoreExpr -> Bool

-- | Will this variable exist at runtime?
isRuntimeVar :: Var -> Bool

-- | Records the <i>unfolding</i> of an identifier, which is approximately
--   the form the identifier would have if we substituted its definition in
--   for the identifier. This type should be treated as abstract everywhere
--   except in <a>GHC.Core.Unfold</a>
data Unfolding

-- | We have no information about the unfolding.
NoUnfolding :: Unfolding

-- | We have no information about the unfolding, because this <a>Id</a>
--   came from an <tt>hi-boot</tt> file. See Note [Inlining and hs-boot
--   files] in <a>GHC.CoreToIface</a> for what this is used for.
BootUnfolding :: Unfolding

-- | It ain't one of these constructors. <tt>OtherCon xs</tt> also
--   indicates that something has been evaluated and hence there's no point
--   in re-evaluating it. <tt>OtherCon []</tt> is used even for
--   non-data-type values to indicated evaluated-ness. Notably:
--   
--   <pre>
--   data C = C !(Int -&gt; Int)
--   case x of { C f -&gt; ... }
--   </pre>
--   
--   Here, <tt>f</tt> gets an <tt>OtherCon []</tt> unfolding.
OtherCon :: [AltCon] -> Unfolding
DFunUnfolding :: [Var] -> DataCon -> [CoreExpr] -> Unfolding
[df_bndrs] :: Unfolding -> [Var]
[df_con] :: Unfolding -> DataCon
[df_args] :: Unfolding -> [CoreExpr]

-- | An unfolding with redundant cached information. Parameters:
--   
--   uf_tmpl: Template used to perform unfolding; NB: Occurrence info is
--   guaranteed correct: see Note [OccInfo in unfoldings and rules]
--   
--   uf_is_top: Is this a top level binding?
--   
--   uf_is_value: <tt>exprIsHNF</tt> template (cached); it is ok to discard
--   a <a>seq</a> on this variable
--   
--   uf_is_work_free: Does this waste only a little work if we expand it
--   inside an inlining? Basically this is a cached version of
--   <tt>exprIsWorkFree</tt>
--   
--   uf_guidance: Tells us about the <i>size</i> of the unfolding template
CoreUnfolding :: CoreExpr -> UnfoldingSource -> Bool -> Bool -> Bool -> Bool -> Bool -> UnfoldingGuidance -> Unfolding
[uf_tmpl] :: Unfolding -> CoreExpr
[uf_src] :: Unfolding -> UnfoldingSource
[uf_is_top] :: Unfolding -> Bool
[uf_is_value] :: Unfolding -> Bool
[uf_is_conlike] :: Unfolding -> Bool
[uf_is_work_free] :: Unfolding -> Bool
[uf_expandable] :: Unfolding -> Bool
[uf_guidance] :: Unfolding -> UnfoldingGuidance

-- | <a>UnfoldingGuidance</a> says when unfolding should take place
data UnfoldingGuidance
UnfWhen :: Arity -> Bool -> Bool -> UnfoldingGuidance
[ug_arity] :: UnfoldingGuidance -> Arity
[ug_unsat_ok] :: UnfoldingGuidance -> Bool
[ug_boring_ok] :: UnfoldingGuidance -> Bool
UnfIfGoodArgs :: [Int] -> Int -> Int -> UnfoldingGuidance
[ug_args] :: UnfoldingGuidance -> [Int]
[ug_size] :: UnfoldingGuidance -> Int
[ug_res] :: UnfoldingGuidance -> Int
UnfNever :: UnfoldingGuidance
data UnfoldingSource
InlineRhs :: UnfoldingSource
InlineStable :: UnfoldingSource
InlineCompulsory :: UnfoldingSource

-- | There is no known <a>Unfolding</a>
noUnfolding :: Unfolding

-- | There is no known <a>Unfolding</a>, because this came from an hi-boot
--   file.
bootUnfolding :: Unfolding

-- | This unfolding marks the associated thing as being evaluated
evaldUnfolding :: Unfolding
mkOtherCon :: [AltCon] -> Unfolding
unSaturatedOk :: Bool
needSaturated :: Bool
boringCxtOk :: Bool
boringCxtNotOk :: Bool

-- | Retrieves the template of an unfolding: panics if none is known
unfoldingTemplate :: Unfolding -> CoreExpr
expandUnfolding_maybe :: Unfolding -> Maybe CoreExpr

-- | Retrieves the template of an unfolding if possible
--   maybeUnfoldingTemplate is used mainly wnen specialising, and we do
--   want to specialise DFuns, so it's important to return a template for
--   DFunUnfoldings
maybeUnfoldingTemplate :: Unfolding -> Maybe CoreExpr

-- | The constructors that the unfolding could never be: returns
--   <tt>[]</tt> if no information is available
otherCons :: Unfolding -> [AltCon]

-- | Determines if it is certainly the case that the unfolding will yield a
--   value (something in HNF): returns <tt>False</tt> if unsure
isValueUnfolding :: Unfolding -> Bool

-- | Determines if it possibly the case that the unfolding will yield a
--   value. Unlike <a>isValueUnfolding</a> it returns <tt>True</tt> for
--   <a>OtherCon</a>
isEvaldUnfolding :: Unfolding -> Bool

-- | Is the thing we will unfold into certainly cheap?
isCheapUnfolding :: Unfolding -> Bool
isExpandableUnfolding :: Unfolding -> Bool

-- | <tt>True</tt> if the unfolding is a constructor application, the
--   application of a CONLIKE function or <a>OtherCon</a>
isConLikeUnfolding :: Unfolding -> Bool
isCompulsoryUnfolding :: Unfolding -> Bool
isStableUnfolding :: Unfolding -> Bool
hasCoreUnfolding :: Unfolding -> Bool

-- | Only returns False if there is no unfolding information available at
--   all
hasSomeUnfolding :: Unfolding -> Bool
isBootUnfolding :: Unfolding -> Bool
canUnfold :: Unfolding -> Bool
neverUnfoldGuidance :: UnfoldingGuidance -> Bool
isStableSource :: UnfoldingSource -> Bool

-- | Annotated core: allows annotation at every node in the tree
type AnnExpr bndr annot = (annot, AnnExpr' bndr annot)

-- | A clone of the <a>Expr</a> type but allowing annotation at every tree
--   node
data AnnExpr' bndr annot
AnnVar :: Id -> AnnExpr' bndr annot
AnnLit :: Literal -> AnnExpr' bndr annot
AnnLam :: bndr -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnApp :: AnnExpr bndr annot -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnCase :: AnnExpr bndr annot -> bndr -> Type -> [AnnAlt bndr annot] -> AnnExpr' bndr annot
AnnLet :: AnnBind bndr annot -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnCast :: AnnExpr bndr annot -> (annot, Coercion) -> AnnExpr' bndr annot
AnnTick :: CoreTickish -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnType :: Type -> AnnExpr' bndr annot
AnnCoercion :: Coercion -> AnnExpr' bndr annot

-- | A clone of the <a>Bind</a> type but allowing annotation at every tree
--   node
data AnnBind bndr annot
AnnNonRec :: bndr -> AnnExpr bndr annot -> AnnBind bndr annot
AnnRec :: [(bndr, AnnExpr bndr annot)] -> AnnBind bndr annot

-- | A clone of the <a>Alt</a> type but allowing annotation at every tree
--   node
data AnnAlt bndr annot
AnnAlt :: AltCon -> [bndr] -> AnnExpr bndr annot -> AnnAlt bndr annot

-- | Takes a nested application expression and returns the function being
--   applied and the arguments to which it is applied
collectAnnArgs :: AnnExpr b a -> (AnnExpr b a, [AnnExpr b a])
collectAnnArgsTicks :: (CoreTickish -> Bool) -> AnnExpr b a -> (AnnExpr b a, [AnnExpr b a], [CoreTickish])
deAnnotate :: AnnExpr bndr annot -> Expr bndr
deAnnotate' :: AnnExpr' bndr annot -> Expr bndr
deAnnAlt :: AnnAlt bndr annot -> Alt bndr
deAnnBind :: AnnBind b annot -> Bind b

-- | As <a>collectBinders</a> but for <a>AnnExpr</a> rather than
--   <a>Expr</a>
collectAnnBndrs :: AnnExpr bndr annot -> ([bndr], AnnExpr bndr annot)

-- | As <a>collectNBinders</a> but for <a>AnnExpr</a> rather than
--   <a>Expr</a>
collectNAnnBndrs :: Int -> AnnExpr bndr annot -> ([bndr], AnnExpr bndr annot)

-- | Is this instance an orphan? If it is not an orphan, contains an
--   <a>OccName</a> witnessing the instance's non-orphanhood. See Note
--   [Orphans]
data IsOrphan
IsOrphan :: IsOrphan
NotOrphan :: OccName -> IsOrphan

-- | Returns true if <a>IsOrphan</a> is orphan.
isOrphan :: IsOrphan -> Bool

-- | Returns true if <a>IsOrphan</a> is not an orphan.
notOrphan :: IsOrphan -> Bool
chooseOrphanAnchor :: NameSet -> IsOrphan

-- | A <a>CoreRule</a> is:
--   
--   <ul>
--   <li>"Local" if the function it is a rule for is defined in the same
--   module as the rule itself.</li>
--   <li>"Orphan" if nothing on the LHS is defined in the same module as
--   the rule itself</li>
--   </ul>
data CoreRule
Rule :: RuleName -> Activation -> Name -> [Maybe Name] -> [CoreBndr] -> [CoreExpr] -> CoreExpr -> Bool -> !Module -> !IsOrphan -> Bool -> CoreRule

-- | Name of the rule, for communication with the user
[ru_name] :: CoreRule -> RuleName

-- | When the rule is active
[ru_act] :: CoreRule -> Activation

-- | Name of the <a>Id</a> at the head of this rule
[ru_fn] :: CoreRule -> Name

-- | Name at the head of each argument to the left hand side
[ru_rough] :: CoreRule -> [Maybe Name]

-- | Variables quantified over
[ru_bndrs] :: CoreRule -> [CoreBndr]

-- | Left hand side arguments
[ru_args] :: CoreRule -> [CoreExpr]

-- | Right hand side of the rule Occurrence info is guaranteed correct See
--   Note [OccInfo in unfoldings and rules]
[ru_rhs] :: CoreRule -> CoreExpr

-- | <tt>True</tt> <a>=</a> this rule is auto-generated (notably by
--   Specialise or SpecConstr) <tt>False</tt> <a>=</a> generated at the
--   user's behest See Note [Trimming auto-rules] in <a>GHC.Iface.Tidy</a>
--   for the sole purpose of this field.
[ru_auto] :: CoreRule -> Bool

-- | <a>Module</a> the rule was defined in, used to test if we should see
--   an orphan rule.
[ru_origin] :: CoreRule -> !Module

-- | Whether or not the rule is an orphan.
[ru_orphan] :: CoreRule -> !IsOrphan

-- | <tt>True</tt> iff the fn at the head of the rule is defined in the
--   same module as the rule and is not an implicit <a>Id</a> (like a
--   record selector, class operation, or data constructor). This is
--   different from <a>ru_orphan</a>, where a rule can avoid being an
--   orphan if *any* Name in LHS of the rule was defined in the same module
--   as the rule.
[ru_local] :: CoreRule -> Bool

-- | Built-in rules are used for constant folding and suchlike. They have
--   no free variables. A built-in rule is always visible (there is no such
--   thing as an orphan built-in rule.)
BuiltinRule :: RuleName -> Name -> Int -> RuleFun -> CoreRule

-- | Name of the rule, for communication with the user
[ru_name] :: CoreRule -> RuleName

-- | Name of the <a>Id</a> at the head of this rule
[ru_fn] :: CoreRule -> Name

-- | Number of arguments that <a>ru_try</a> consumes, if it fires,
--   including type arguments
[ru_nargs] :: CoreRule -> Int

-- | This function does the rewrite. It given too many arguments, it simply
--   discards them; the returned <a>CoreExpr</a> is just the rewrite of
--   <a>ru_fn</a> applied to the first <a>ru_nargs</a> args
[ru_try] :: CoreRule -> RuleFun

-- | Gathers a collection of <a>CoreRule</a>s. Maps (the name of) an
--   <a>Id</a> to its rules
type RuleBase = NameEnv [CoreRule]
type RuleName = FastString
type RuleFun = RuleOpts -> InScopeEnv -> Id -> [CoreExpr] -> Maybe CoreExpr
type IdUnfoldingFun = Id -> Unfolding
type InScopeEnv = (InScopeSet, IdUnfoldingFun)

-- | A full rule environment which we can apply rules from. Like a
--   <a>RuleBase</a>, but it also includes the set of visible orphans we
--   use to filter out orphan rules which are not visible (even though we
--   can see them...)
data RuleEnv
RuleEnv :: RuleBase -> ModuleSet -> RuleEnv
[re_base] :: RuleEnv -> RuleBase
[re_visible_orphs] :: RuleEnv -> ModuleSet

-- | Rule options
data RuleOpts
RuleOpts :: !Platform -> !Bool -> !Bool -> !Bool -> RuleOpts

-- | Target platform
[roPlatform] :: RuleOpts -> !Platform

-- | Enable more advanced numeric constant folding
[roNumConstantFolding] :: RuleOpts -> !Bool

-- | Cut down precision of Rational values to that of Float/Double if
--   disabled
[roExcessRationalPrecision] :: RuleOpts -> !Bool

-- | Enable rules for bignums
[roBignumRules] :: RuleOpts -> !Bool
mkRuleEnv :: RuleBase -> [Module] -> RuleEnv
emptyRuleEnv :: RuleEnv

-- | The number of arguments the <a>ru_fn</a> must be applied to before the
--   rule can match on it
ruleArity :: CoreRule -> Int
ruleName :: CoreRule -> RuleName

-- | The <a>Name</a> of the <a>Id</a> at the head of the rule left hand
--   side
ruleIdName :: CoreRule -> Name
ruleActivation :: CoreRule -> Activation

-- | Set the <a>Name</a> of the <a>Id</a> at the head of the rule left hand
--   side
setRuleIdName :: Name -> CoreRule -> CoreRule
ruleModule :: CoreRule -> Maybe Module
isBuiltinRule :: CoreRule -> Bool
isLocalRule :: CoreRule -> Bool
isAutoRule :: CoreRule -> Bool
instance Data.Data.Data GHC.Core.AltCon
instance GHC.Classes.Eq GHC.Core.AltCon
instance Data.Data.Data b => Data.Data.Data (GHC.Core.Alt b)
instance Data.Data.Data b => Data.Data.Data (GHC.Core.Expr b)
instance Data.Data.Data b => Data.Data.Data (GHC.Core.Bind b)
instance Data.Data.Data GHC.Core.IsOrphan
instance GHC.Classes.Eq GHC.Core.UnfoldingGuidance
instance GHC.Utils.Outputable.Outputable b => GHC.Utils.Outputable.Outputable (GHC.Core.TaggedBndr b)
instance GHC.Utils.Binary.Binary GHC.Core.IsOrphan
instance GHC.Classes.Ord GHC.Core.AltCon
instance GHC.Utils.Outputable.Outputable GHC.Core.AltCon


-- | A module concerned with finding the free variables of an expression.
module GHC.Core.FVs

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a non-deterministic set.
exprFreeVars :: CoreExpr -> VarSet

-- | Find all locally-defined free Ids or type variables in several
--   expressions returning a non-deterministic set.
exprsFreeVars :: [CoreExpr] -> VarSet

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a deterministic set.
exprFreeVarsDSet :: CoreExpr -> DVarSet

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a deterministically ordered list.
exprFreeVarsList :: CoreExpr -> [Var]

-- | Find all locally-defined free Ids or type variables in several
--   expressions returning a deterministically ordered list.
exprsFreeVarsList :: [CoreExpr] -> [Var]

-- | Find all locally-defined free Ids in an expression
exprFreeIds :: CoreExpr -> IdSet
exprsFreeIds :: [CoreExpr] -> IdSet

-- | Find all locally-defined free Ids in an expression returning a
--   deterministic set.
exprFreeIdsDSet :: CoreExpr -> DIdSet

-- | Find all locally-defined free Ids in several expressions returning a
--   deterministic set.
exprsFreeIdsDSet :: [CoreExpr] -> DIdSet

-- | Find all locally-defined free Ids in an expression returning a
--   deterministically ordered list.
exprFreeIdsList :: CoreExpr -> [Id]

-- | Find all locally-defined free Ids in several expressions returning a
--   deterministically ordered list.
exprsFreeIdsList :: [CoreExpr] -> [Id]

-- | Find all locally defined free Ids in a binding group
bindFreeVars :: CoreBind -> VarSet

-- | Predicate on possible free variables: returns <tt>True</tt> iff the
--   variable is interesting
type InterestingVarFun = Var -> Bool

-- | Finds free variables in an expression selected by a predicate
exprSomeFreeVars :: InterestingVarFun -> CoreExpr -> VarSet

-- | Finds free variables in several expressions selected by a predicate
exprsSomeFreeVars :: InterestingVarFun -> [CoreExpr] -> VarSet

-- | Finds free variables in an expression selected by a predicate
--   returning a deterministically ordered list.
exprSomeFreeVarsList :: InterestingVarFun -> CoreExpr -> [Var]

-- | Finds free variables in several expressions selected by a predicate
--   returning a deterministically ordered list.
exprsSomeFreeVarsList :: InterestingVarFun -> [CoreExpr] -> [Var]
varTypeTyCoVars :: Var -> TyCoVarSet
varTypeTyCoFVs :: Var -> FV
idUnfoldingVars :: Id -> VarSet
idFreeVars :: Id -> VarSet
dIdFreeVars :: Id -> DVarSet
bndrRuleAndUnfoldingVarsDSet :: Id -> DVarSet
bndrRuleAndUnfoldingIds :: Id -> IdSet
idFVs :: Id -> FV
idRuleVars :: Id -> VarSet
stableUnfoldingVars :: Unfolding -> Maybe VarSet

-- | Those variables free in the both the left right hand sides of a rule
--   returned as a non-deterministic set
ruleFreeVars :: CoreRule -> VarSet

-- | Those variables free in both the left right hand sides of several
--   rules
rulesFreeVars :: [CoreRule] -> VarSet

-- | Those variables free in the both the left right hand sides of rules
--   returned as a deterministic set
rulesFreeVarsDSet :: [CoreRule] -> DVarSet

-- | Make a <a>RuleInfo</a> containing a number of <a>CoreRule</a>s,
--   suitable for putting into an <a>IdInfo</a>
mkRuleInfo :: [CoreRule] -> RuleInfo

-- | This finds all locally-defined free Ids on the left hand side of a
--   rule and returns them as a non-deterministic set
ruleLhsFreeIds :: CoreRule -> VarSet

-- | This finds all locally-defined free Ids on the left hand side of a
--   rule and returns them as a deterministically ordered list
ruleLhsFreeIdsList :: CoreRule -> [Var]

-- | Those variables free in the right hand side of a rule returned as a
--   non-deterministic set
ruleRhsFreeVars :: CoreRule -> VarSet

-- | Those locally-defined free <a>Id</a>s in the right hand side of
--   several rules returned as a non-deterministic set
rulesRhsFreeIds :: [CoreRule] -> VarSet
expr_fvs :: CoreExpr -> FV
orphNamesOfType :: Type -> NameSet
orphNamesOfCo :: Coercion -> NameSet
orphNamesOfAxiom :: CoAxiom br -> NameSet
orphNamesOfTypes :: [Type] -> NameSet
orphNamesOfCoCon :: CoAxiom br -> NameSet

-- | Finds the free <i>external</i> names of several expressions: see
--   <a>exprOrphNames</a> for details
exprsOrphNames :: [CoreExpr] -> NameSet

-- | orphNamesOfAxiom collects the names of the concrete types and type
--   constructors that make up the LHS of a type family instance, including
--   the family name itself.
--   
--   For instance, given `type family Foo a b`: `type instance Foo (F (G (H
--   a))) b = ...` would yield [Foo,F,G,H]
--   
--   Used in the implementation of ":info" in GHCi.
orphNamesOfFamInst :: FamInst -> NameSet
type FVAnn = DVarSet

-- | Every node in an expression annotated with its (non-global) free
--   variables, both Ids and TyVars, and type. NB: see Note [The FVAnn
--   invariant]
type CoreExprWithFVs = AnnExpr Id FVAnn
type CoreExprWithFVs' = AnnExpr' Id FVAnn

-- | Every node in a binding group annotated with its (non-global) free
--   variables, both Ids and TyVars, and type.
type CoreBindWithFVs = AnnBind Id FVAnn

-- | Every node in an expression annotated with its (non-global) free
--   variables, both Ids and TyVars, and type.
type CoreAltWithFVs = AnnAlt Id FVAnn

-- | Annotate a <a>CoreExpr</a> with its (non-global) free type and value
--   variables at every tree node.
freeVars :: CoreExpr -> CoreExprWithFVs
freeVarsBind :: CoreBind -> DVarSet -> (CoreBindWithFVs, DVarSet)

-- | Inverse function to <a>freeVars</a>
freeVarsOf :: CoreExprWithFVs -> DIdSet

-- | Extract the vars reported in a FVAnn
freeVarsOfAnn :: FVAnn -> DIdSet

module GHC.Core.FamInstEnv
data FamInst
FamInst :: CoAxiom Unbranched -> FamFlavor -> Name -> [RoughMatchTc] -> [TyVar] -> [CoVar] -> [Type] -> Type -> FamInst
[fi_axiom] :: FamInst -> CoAxiom Unbranched
[fi_flavor] :: FamInst -> FamFlavor
[fi_fam] :: FamInst -> Name
[fi_tcs] :: FamInst -> [RoughMatchTc]
[fi_tvs] :: FamInst -> [TyVar]
[fi_cvs] :: FamInst -> [CoVar]
[fi_tys] :: FamInst -> [Type]
[fi_rhs] :: FamInst -> Type
data FamFlavor
SynFamilyInst :: FamFlavor
DataFamilyInst :: TyCon -> FamFlavor
famInstAxiom :: FamInst -> CoAxiom Unbranched
famInstTyCon :: FamInst -> TyCon
famInstRHS :: FamInst -> Type
famInstsRepTyCons :: [FamInst] -> [TyCon]
famInstRepTyCon_maybe :: FamInst -> Maybe TyCon
dataFamInstRepTyCon :: FamInst -> TyCon
pprFamInst :: FamInst -> SDoc
pprFamInsts :: [FamInst] -> SDoc
mkImportedFamInst :: Name -> [RoughMatchTc] -> CoAxiom Unbranched -> FamInst
type FamInstEnvs = (FamInstEnv, FamInstEnv)
type FamInstEnv = UniqDFM TyCon FamilyInstEnv
emptyFamInstEnv :: FamInstEnv
emptyFamInstEnvs :: (FamInstEnv, FamInstEnv)
extendFamInstEnv :: FamInstEnv -> FamInst -> FamInstEnv
extendFamInstEnvList :: FamInstEnv -> [FamInst] -> FamInstEnv
famInstEnvElts :: FamInstEnv -> [FamInst]
famInstEnvSize :: FamInstEnv -> Int
familyInstances :: (FamInstEnv, FamInstEnv) -> TyCon -> [FamInst]
mkCoAxBranch :: [TyVar] -> [TyVar] -> [CoVar] -> [Type] -> Type -> [Role] -> SrcSpan -> CoAxBranch
mkBranchedCoAxiom :: Name -> TyCon -> [CoAxBranch] -> CoAxiom Branched
mkUnbranchedCoAxiom :: Name -> TyCon -> CoAxBranch -> CoAxiom Unbranched
mkSingleCoAxiom :: Role -> Name -> [TyVar] -> [TyVar] -> [CoVar] -> TyCon -> [Type] -> Type -> CoAxiom Unbranched

-- | Create a coercion constructor (axiom) suitable for the given newtype
--   <a>TyCon</a>. The <a>Name</a> should be that of a new coercion
--   <a>CoAxiom</a>, the <a>TyVar</a>s the arguments expected by the
--   <tt>newtype</tt> and the type the appropriate right hand side of the
--   <tt>newtype</tt>, with the free variables a subset of those
--   <a>TyVar</a>s.
mkNewTypeCoAxiom :: Name -> TyCon -> [TyVar] -> [Role] -> Type -> CoAxiom Unbranched
data FamInstMatch
FamInstMatch :: FamInst -> [Type] -> [Coercion] -> FamInstMatch
[fim_instance] :: FamInstMatch -> FamInst
[fim_tys] :: FamInstMatch -> [Type]
[fim_cos] :: FamInstMatch -> [Coercion]
lookupFamInstEnv :: FamInstEnvs -> TyCon -> [Type] -> [FamInstMatch]
lookupFamInstEnvConflicts :: FamInstEnvs -> FamInst -> [FamInstMatch]
lookupFamInstEnvByTyCon :: FamInstEnvs -> TyCon -> [FamInst]
isDominatedBy :: CoAxBranch -> [CoAxBranch] -> Bool

-- | Do an apartness check, as described in the "Closed Type Families"
--   paper (POPL '14). This should be used when determining if an equation
--   (<a>CoAxBranch</a>) of a closed type family can be used to reduce a
--   certain target type family application.
apartnessCheck :: [Type] -> CoAxBranch -> Bool

-- | Result of testing two type family equations for injectiviy.
data InjectivityCheckResult

-- | Either RHSs are distinct or unification of RHSs leads to unification
--   of LHSs
InjectivityAccepted :: InjectivityCheckResult

-- | RHSs unify but LHSs don't unify under that substitution. Relevant for
--   closed type families where equation after unification might be
--   overlpapped (in which case it is OK if they don't unify). Constructor
--   stores axioms after unification.
InjectivityUnified :: CoAxBranch -> CoAxBranch -> InjectivityCheckResult

-- | Check whether an open type family equation can be added to already
--   existing instance environment without causing conflicts with supplied
--   injectivity annotations. Returns list of conflicting axioms (type
--   instance declarations).
lookupFamInstEnvInjectivityConflicts :: [Bool] -> FamInstEnvs -> FamInst -> [CoAxBranch]

-- | Check whether two type family axioms don't violate injectivity
--   annotation.
injectiveBranches :: [Bool] -> CoAxBranch -> CoAxBranch -> InjectivityCheckResult
topNormaliseType :: FamInstEnvs -> Type -> Type

-- | Get rid of *outermost* (or toplevel) * type function redex * data
--   family redex * newtypes returning an appropriate Representational
--   coercion. Specifically, if topNormaliseType_maybe env ty = Just (co,
--   ty') then (a) co :: ty ~R ty' (b) ty' is not a newtype, and is not a
--   type-family or data-family redex
--   
--   However, ty' can be something like (Maybe (F ty)), where (F ty) is a
--   redex.
--   
--   Always operates homogeneously: the returned type has the same kind as
--   the original type, and the returned coercion is always homogeneous.
topNormaliseType_maybe :: FamInstEnvs -> Type -> Maybe (Coercion, Type)
normaliseType :: FamInstEnvs -> Role -> Type -> (Coercion, Type)
normaliseTcApp :: FamInstEnvs -> Role -> TyCon -> [Type] -> (Coercion, Type)

-- | Try to simplify a type-family application, by *one* step If
--   topReduceTyFamApp_maybe env r F tys = Just (co, rhs, res_co) then co
--   :: F tys ~R# rhs res_co :: typeKind(F tys) ~ typeKind(rhs) Type
--   families and data families; always Representational role
topReduceTyFamApp_maybe :: FamInstEnvs -> TyCon -> [Type] -> Maybe (Coercion, Type, MCoercion)
reduceTyFamApp_maybe :: FamInstEnvs -> Role -> TyCon -> [Type] -> Maybe (Coercion, Type)
instance GHC.Base.Functor GHC.Core.FamInstEnv.NormM
instance GHC.Base.Monad GHC.Core.FamInstEnv.NormM
instance GHC.Base.Applicative GHC.Core.FamInstEnv.NormM
instance GHC.Utils.Outputable.Outputable GHC.Core.FamInstEnv.FamInstMatch
instance GHC.Utils.Outputable.Outputable GHC.Core.FamInstEnv.FamilyInstEnv
instance GHC.Types.Name.NamedThing GHC.Core.FamInstEnv.FamInst
instance GHC.Utils.Outputable.Outputable GHC.Core.FamInstEnv.FamInst

module GHC.Builtin.PrimOps
data PrimOp
CharGtOp :: PrimOp
CharGeOp :: PrimOp
CharEqOp :: PrimOp
CharNeOp :: PrimOp
CharLtOp :: PrimOp
CharLeOp :: PrimOp
OrdOp :: PrimOp
Int8ToIntOp :: PrimOp
IntToInt8Op :: PrimOp
Int8NegOp :: PrimOp
Int8AddOp :: PrimOp
Int8SubOp :: PrimOp
Int8MulOp :: PrimOp
Int8QuotOp :: PrimOp
Int8RemOp :: PrimOp
Int8QuotRemOp :: PrimOp
Int8SllOp :: PrimOp
Int8SraOp :: PrimOp
Int8SrlOp :: PrimOp
Int8ToWord8Op :: PrimOp
Int8EqOp :: PrimOp
Int8GeOp :: PrimOp
Int8GtOp :: PrimOp
Int8LeOp :: PrimOp
Int8LtOp :: PrimOp
Int8NeOp :: PrimOp
Word8ToWordOp :: PrimOp
WordToWord8Op :: PrimOp
Word8AddOp :: PrimOp
Word8SubOp :: PrimOp
Word8MulOp :: PrimOp
Word8QuotOp :: PrimOp
Word8RemOp :: PrimOp
Word8QuotRemOp :: PrimOp
Word8AndOp :: PrimOp
Word8OrOp :: PrimOp
Word8XorOp :: PrimOp
Word8NotOp :: PrimOp
Word8SllOp :: PrimOp
Word8SrlOp :: PrimOp
Word8ToInt8Op :: PrimOp
Word8EqOp :: PrimOp
Word8GeOp :: PrimOp
Word8GtOp :: PrimOp
Word8LeOp :: PrimOp
Word8LtOp :: PrimOp
Word8NeOp :: PrimOp
Int16ToIntOp :: PrimOp
IntToInt16Op :: PrimOp
Int16NegOp :: PrimOp
Int16AddOp :: PrimOp
Int16SubOp :: PrimOp
Int16MulOp :: PrimOp
Int16QuotOp :: PrimOp
Int16RemOp :: PrimOp
Int16QuotRemOp :: PrimOp
Int16SllOp :: PrimOp
Int16SraOp :: PrimOp
Int16SrlOp :: PrimOp
Int16ToWord16Op :: PrimOp
Int16EqOp :: PrimOp
Int16GeOp :: PrimOp
Int16GtOp :: PrimOp
Int16LeOp :: PrimOp
Int16LtOp :: PrimOp
Int16NeOp :: PrimOp
Word16ToWordOp :: PrimOp
WordToWord16Op :: PrimOp
Word16AddOp :: PrimOp
Word16SubOp :: PrimOp
Word16MulOp :: PrimOp
Word16QuotOp :: PrimOp
Word16RemOp :: PrimOp
Word16QuotRemOp :: PrimOp
Word16AndOp :: PrimOp
Word16OrOp :: PrimOp
Word16XorOp :: PrimOp
Word16NotOp :: PrimOp
Word16SllOp :: PrimOp
Word16SrlOp :: PrimOp
Word16ToInt16Op :: PrimOp
Word16EqOp :: PrimOp
Word16GeOp :: PrimOp
Word16GtOp :: PrimOp
Word16LeOp :: PrimOp
Word16LtOp :: PrimOp
Word16NeOp :: PrimOp
Int32ToIntOp :: PrimOp
IntToInt32Op :: PrimOp
Int32NegOp :: PrimOp
Int32AddOp :: PrimOp
Int32SubOp :: PrimOp
Int32MulOp :: PrimOp
Int32QuotOp :: PrimOp
Int32RemOp :: PrimOp
Int32QuotRemOp :: PrimOp
Int32SllOp :: PrimOp
Int32SraOp :: PrimOp
Int32SrlOp :: PrimOp
Int32ToWord32Op :: PrimOp
Int32EqOp :: PrimOp
Int32GeOp :: PrimOp
Int32GtOp :: PrimOp
Int32LeOp :: PrimOp
Int32LtOp :: PrimOp
Int32NeOp :: PrimOp
Word32ToWordOp :: PrimOp
WordToWord32Op :: PrimOp
Word32AddOp :: PrimOp
Word32SubOp :: PrimOp
Word32MulOp :: PrimOp
Word32QuotOp :: PrimOp
Word32RemOp :: PrimOp
Word32QuotRemOp :: PrimOp
Word32AndOp :: PrimOp
Word32OrOp :: PrimOp
Word32XorOp :: PrimOp
Word32NotOp :: PrimOp
Word32SllOp :: PrimOp
Word32SrlOp :: PrimOp
Word32ToInt32Op :: PrimOp
Word32EqOp :: PrimOp
Word32GeOp :: PrimOp
Word32GtOp :: PrimOp
Word32LeOp :: PrimOp
Word32LtOp :: PrimOp
Word32NeOp :: PrimOp
IntAddOp :: PrimOp
IntSubOp :: PrimOp
IntMulOp :: PrimOp
IntMul2Op :: PrimOp
IntMulMayOfloOp :: PrimOp
IntQuotOp :: PrimOp
IntRemOp :: PrimOp
IntQuotRemOp :: PrimOp
IntAndOp :: PrimOp
IntOrOp :: PrimOp
IntXorOp :: PrimOp
IntNotOp :: PrimOp
IntNegOp :: PrimOp
IntAddCOp :: PrimOp
IntSubCOp :: PrimOp
IntGtOp :: PrimOp
IntGeOp :: PrimOp
IntEqOp :: PrimOp
IntNeOp :: PrimOp
IntLtOp :: PrimOp
IntLeOp :: PrimOp
ChrOp :: PrimOp
IntToWordOp :: PrimOp
IntToFloatOp :: PrimOp
IntToDoubleOp :: PrimOp
WordToFloatOp :: PrimOp
WordToDoubleOp :: PrimOp
IntSllOp :: PrimOp
IntSraOp :: PrimOp
IntSrlOp :: PrimOp
WordAddOp :: PrimOp
WordAddCOp :: PrimOp
WordSubCOp :: PrimOp
WordAdd2Op :: PrimOp
WordSubOp :: PrimOp
WordMulOp :: PrimOp
WordMul2Op :: PrimOp
WordQuotOp :: PrimOp
WordRemOp :: PrimOp
WordQuotRemOp :: PrimOp
WordQuotRem2Op :: PrimOp
WordAndOp :: PrimOp
WordOrOp :: PrimOp
WordXorOp :: PrimOp
WordNotOp :: PrimOp
WordSllOp :: PrimOp
WordSrlOp :: PrimOp
WordToIntOp :: PrimOp
WordGtOp :: PrimOp
WordGeOp :: PrimOp
WordEqOp :: PrimOp
WordNeOp :: PrimOp
WordLtOp :: PrimOp
WordLeOp :: PrimOp
PopCnt8Op :: PrimOp
PopCnt16Op :: PrimOp
PopCnt32Op :: PrimOp
PopCnt64Op :: PrimOp
PopCntOp :: PrimOp
Pdep8Op :: PrimOp
Pdep16Op :: PrimOp
Pdep32Op :: PrimOp
Pdep64Op :: PrimOp
PdepOp :: PrimOp
Pext8Op :: PrimOp
Pext16Op :: PrimOp
Pext32Op :: PrimOp
Pext64Op :: PrimOp
PextOp :: PrimOp
Clz8Op :: PrimOp
Clz16Op :: PrimOp
Clz32Op :: PrimOp
Clz64Op :: PrimOp
ClzOp :: PrimOp
Ctz8Op :: PrimOp
Ctz16Op :: PrimOp
Ctz32Op :: PrimOp
Ctz64Op :: PrimOp
CtzOp :: PrimOp
BSwap16Op :: PrimOp
BSwap32Op :: PrimOp
BSwap64Op :: PrimOp
BSwapOp :: PrimOp
BRev8Op :: PrimOp
BRev16Op :: PrimOp
BRev32Op :: PrimOp
BRev64Op :: PrimOp
BRevOp :: PrimOp
Narrow8IntOp :: PrimOp
Narrow16IntOp :: PrimOp
Narrow32IntOp :: PrimOp
Narrow8WordOp :: PrimOp
Narrow16WordOp :: PrimOp
Narrow32WordOp :: PrimOp
DoubleGtOp :: PrimOp
DoubleGeOp :: PrimOp
DoubleEqOp :: PrimOp
DoubleNeOp :: PrimOp
DoubleLtOp :: PrimOp
DoubleLeOp :: PrimOp
DoubleAddOp :: PrimOp
DoubleSubOp :: PrimOp
DoubleMulOp :: PrimOp
DoubleDivOp :: PrimOp
DoubleNegOp :: PrimOp
DoubleFabsOp :: PrimOp
DoubleToIntOp :: PrimOp
DoubleToFloatOp :: PrimOp
DoubleExpOp :: PrimOp
DoubleExpM1Op :: PrimOp
DoubleLogOp :: PrimOp
DoubleLog1POp :: PrimOp
DoubleSqrtOp :: PrimOp
DoubleSinOp :: PrimOp
DoubleCosOp :: PrimOp
DoubleTanOp :: PrimOp
DoubleAsinOp :: PrimOp
DoubleAcosOp :: PrimOp
DoubleAtanOp :: PrimOp
DoubleSinhOp :: PrimOp
DoubleCoshOp :: PrimOp
DoubleTanhOp :: PrimOp
DoubleAsinhOp :: PrimOp
DoubleAcoshOp :: PrimOp
DoubleAtanhOp :: PrimOp
DoublePowerOp :: PrimOp
DoubleDecode_2IntOp :: PrimOp
DoubleDecode_Int64Op :: PrimOp
FloatGtOp :: PrimOp
FloatGeOp :: PrimOp
FloatEqOp :: PrimOp
FloatNeOp :: PrimOp
FloatLtOp :: PrimOp
FloatLeOp :: PrimOp
FloatAddOp :: PrimOp
FloatSubOp :: PrimOp
FloatMulOp :: PrimOp
FloatDivOp :: PrimOp
FloatNegOp :: PrimOp
FloatFabsOp :: PrimOp
FloatToIntOp :: PrimOp
FloatExpOp :: PrimOp
FloatExpM1Op :: PrimOp
FloatLogOp :: PrimOp
FloatLog1POp :: PrimOp
FloatSqrtOp :: PrimOp
FloatSinOp :: PrimOp
FloatCosOp :: PrimOp
FloatTanOp :: PrimOp
FloatAsinOp :: PrimOp
FloatAcosOp :: PrimOp
FloatAtanOp :: PrimOp
FloatSinhOp :: PrimOp
FloatCoshOp :: PrimOp
FloatTanhOp :: PrimOp
FloatAsinhOp :: PrimOp
FloatAcoshOp :: PrimOp
FloatAtanhOp :: PrimOp
FloatPowerOp :: PrimOp
FloatToDoubleOp :: PrimOp
FloatDecode_IntOp :: PrimOp
NewArrayOp :: PrimOp
SameMutableArrayOp :: PrimOp
ReadArrayOp :: PrimOp
WriteArrayOp :: PrimOp
SizeofArrayOp :: PrimOp
SizeofMutableArrayOp :: PrimOp
IndexArrayOp :: PrimOp
UnsafeFreezeArrayOp :: PrimOp
UnsafeThawArrayOp :: PrimOp
CopyArrayOp :: PrimOp
CopyMutableArrayOp :: PrimOp
CloneArrayOp :: PrimOp
CloneMutableArrayOp :: PrimOp
FreezeArrayOp :: PrimOp
ThawArrayOp :: PrimOp
CasArrayOp :: PrimOp
NewSmallArrayOp :: PrimOp
SameSmallMutableArrayOp :: PrimOp
ShrinkSmallMutableArrayOp_Char :: PrimOp
ReadSmallArrayOp :: PrimOp
WriteSmallArrayOp :: PrimOp
SizeofSmallArrayOp :: PrimOp
SizeofSmallMutableArrayOp :: PrimOp
GetSizeofSmallMutableArrayOp :: PrimOp
IndexSmallArrayOp :: PrimOp
UnsafeFreezeSmallArrayOp :: PrimOp
UnsafeThawSmallArrayOp :: PrimOp
CopySmallArrayOp :: PrimOp
CopySmallMutableArrayOp :: PrimOp
CloneSmallArrayOp :: PrimOp
CloneSmallMutableArrayOp :: PrimOp
FreezeSmallArrayOp :: PrimOp
ThawSmallArrayOp :: PrimOp
CasSmallArrayOp :: PrimOp
NewByteArrayOp_Char :: PrimOp
NewPinnedByteArrayOp_Char :: PrimOp
NewAlignedPinnedByteArrayOp_Char :: PrimOp
MutableByteArrayIsPinnedOp :: PrimOp
ByteArrayIsPinnedOp :: PrimOp
ByteArrayContents_Char :: PrimOp
MutableByteArrayContents_Char :: PrimOp
SameMutableByteArrayOp :: PrimOp
ShrinkMutableByteArrayOp_Char :: PrimOp
ResizeMutableByteArrayOp_Char :: PrimOp
UnsafeFreezeByteArrayOp :: PrimOp
SizeofByteArrayOp :: PrimOp
SizeofMutableByteArrayOp :: PrimOp
GetSizeofMutableByteArrayOp :: PrimOp
IndexByteArrayOp_Char :: PrimOp
IndexByteArrayOp_WideChar :: PrimOp
IndexByteArrayOp_Int :: PrimOp
IndexByteArrayOp_Word :: PrimOp
IndexByteArrayOp_Addr :: PrimOp
IndexByteArrayOp_Float :: PrimOp
IndexByteArrayOp_Double :: PrimOp
IndexByteArrayOp_StablePtr :: PrimOp
IndexByteArrayOp_Int8 :: PrimOp
IndexByteArrayOp_Int16 :: PrimOp
IndexByteArrayOp_Int32 :: PrimOp
IndexByteArrayOp_Int64 :: PrimOp
IndexByteArrayOp_Word8 :: PrimOp
IndexByteArrayOp_Word16 :: PrimOp
IndexByteArrayOp_Word32 :: PrimOp
IndexByteArrayOp_Word64 :: PrimOp
IndexByteArrayOp_Word8AsChar :: PrimOp
IndexByteArrayOp_Word8AsWideChar :: PrimOp
IndexByteArrayOp_Word8AsInt :: PrimOp
IndexByteArrayOp_Word8AsWord :: PrimOp
IndexByteArrayOp_Word8AsAddr :: PrimOp
IndexByteArrayOp_Word8AsFloat :: PrimOp
IndexByteArrayOp_Word8AsDouble :: PrimOp
IndexByteArrayOp_Word8AsStablePtr :: PrimOp
IndexByteArrayOp_Word8AsInt16 :: PrimOp
IndexByteArrayOp_Word8AsInt32 :: PrimOp
IndexByteArrayOp_Word8AsInt64 :: PrimOp
IndexByteArrayOp_Word8AsWord16 :: PrimOp
IndexByteArrayOp_Word8AsWord32 :: PrimOp
IndexByteArrayOp_Word8AsWord64 :: PrimOp
ReadByteArrayOp_Char :: PrimOp
ReadByteArrayOp_WideChar :: PrimOp
ReadByteArrayOp_Int :: PrimOp
ReadByteArrayOp_Word :: PrimOp
ReadByteArrayOp_Addr :: PrimOp
ReadByteArrayOp_Float :: PrimOp
ReadByteArrayOp_Double :: PrimOp
ReadByteArrayOp_StablePtr :: PrimOp
ReadByteArrayOp_Int8 :: PrimOp
ReadByteArrayOp_Int16 :: PrimOp
ReadByteArrayOp_Int32 :: PrimOp
ReadByteArrayOp_Int64 :: PrimOp
ReadByteArrayOp_Word8 :: PrimOp
ReadByteArrayOp_Word16 :: PrimOp
ReadByteArrayOp_Word32 :: PrimOp
ReadByteArrayOp_Word64 :: PrimOp
ReadByteArrayOp_Word8AsChar :: PrimOp
ReadByteArrayOp_Word8AsWideChar :: PrimOp
ReadByteArrayOp_Word8AsInt :: PrimOp
ReadByteArrayOp_Word8AsWord :: PrimOp
ReadByteArrayOp_Word8AsAddr :: PrimOp
ReadByteArrayOp_Word8AsFloat :: PrimOp
ReadByteArrayOp_Word8AsDouble :: PrimOp
ReadByteArrayOp_Word8AsStablePtr :: PrimOp
ReadByteArrayOp_Word8AsInt16 :: PrimOp
ReadByteArrayOp_Word8AsInt32 :: PrimOp
ReadByteArrayOp_Word8AsInt64 :: PrimOp
ReadByteArrayOp_Word8AsWord16 :: PrimOp
ReadByteArrayOp_Word8AsWord32 :: PrimOp
ReadByteArrayOp_Word8AsWord64 :: PrimOp
WriteByteArrayOp_Char :: PrimOp
WriteByteArrayOp_WideChar :: PrimOp
WriteByteArrayOp_Int :: PrimOp
WriteByteArrayOp_Word :: PrimOp
WriteByteArrayOp_Addr :: PrimOp
WriteByteArrayOp_Float :: PrimOp
WriteByteArrayOp_Double :: PrimOp
WriteByteArrayOp_StablePtr :: PrimOp
WriteByteArrayOp_Int8 :: PrimOp
WriteByteArrayOp_Int16 :: PrimOp
WriteByteArrayOp_Int32 :: PrimOp
WriteByteArrayOp_Int64 :: PrimOp
WriteByteArrayOp_Word8 :: PrimOp
WriteByteArrayOp_Word16 :: PrimOp
WriteByteArrayOp_Word32 :: PrimOp
WriteByteArrayOp_Word64 :: PrimOp
WriteByteArrayOp_Word8AsChar :: PrimOp
WriteByteArrayOp_Word8AsWideChar :: PrimOp
WriteByteArrayOp_Word8AsInt :: PrimOp
WriteByteArrayOp_Word8AsWord :: PrimOp
WriteByteArrayOp_Word8AsAddr :: PrimOp
WriteByteArrayOp_Word8AsFloat :: PrimOp
WriteByteArrayOp_Word8AsDouble :: PrimOp
WriteByteArrayOp_Word8AsStablePtr :: PrimOp
WriteByteArrayOp_Word8AsInt16 :: PrimOp
WriteByteArrayOp_Word8AsInt32 :: PrimOp
WriteByteArrayOp_Word8AsInt64 :: PrimOp
WriteByteArrayOp_Word8AsWord16 :: PrimOp
WriteByteArrayOp_Word8AsWord32 :: PrimOp
WriteByteArrayOp_Word8AsWord64 :: PrimOp
CompareByteArraysOp :: PrimOp
CopyByteArrayOp :: PrimOp
CopyMutableByteArrayOp :: PrimOp
CopyByteArrayToAddrOp :: PrimOp
CopyMutableByteArrayToAddrOp :: PrimOp
CopyAddrToByteArrayOp :: PrimOp
SetByteArrayOp :: PrimOp
AtomicReadByteArrayOp_Int :: PrimOp
AtomicWriteByteArrayOp_Int :: PrimOp
CasByteArrayOp_Int :: PrimOp
FetchAddByteArrayOp_Int :: PrimOp
FetchSubByteArrayOp_Int :: PrimOp
FetchAndByteArrayOp_Int :: PrimOp
FetchNandByteArrayOp_Int :: PrimOp
FetchOrByteArrayOp_Int :: PrimOp
FetchXorByteArrayOp_Int :: PrimOp
NewArrayArrayOp :: PrimOp
SameMutableArrayArrayOp :: PrimOp
UnsafeFreezeArrayArrayOp :: PrimOp
SizeofArrayArrayOp :: PrimOp
SizeofMutableArrayArrayOp :: PrimOp
IndexArrayArrayOp_ByteArray :: PrimOp
IndexArrayArrayOp_ArrayArray :: PrimOp
ReadArrayArrayOp_ByteArray :: PrimOp
ReadArrayArrayOp_MutableByteArray :: PrimOp
ReadArrayArrayOp_ArrayArray :: PrimOp
ReadArrayArrayOp_MutableArrayArray :: PrimOp
WriteArrayArrayOp_ByteArray :: PrimOp
WriteArrayArrayOp_MutableByteArray :: PrimOp
WriteArrayArrayOp_ArrayArray :: PrimOp
WriteArrayArrayOp_MutableArrayArray :: PrimOp
CopyArrayArrayOp :: PrimOp
CopyMutableArrayArrayOp :: PrimOp
AddrAddOp :: PrimOp
AddrSubOp :: PrimOp
AddrRemOp :: PrimOp
AddrToIntOp :: PrimOp
IntToAddrOp :: PrimOp
AddrGtOp :: PrimOp
AddrGeOp :: PrimOp
AddrEqOp :: PrimOp
AddrNeOp :: PrimOp
AddrLtOp :: PrimOp
AddrLeOp :: PrimOp
IndexOffAddrOp_Char :: PrimOp
IndexOffAddrOp_WideChar :: PrimOp
IndexOffAddrOp_Int :: PrimOp
IndexOffAddrOp_Word :: PrimOp
IndexOffAddrOp_Addr :: PrimOp
IndexOffAddrOp_Float :: PrimOp
IndexOffAddrOp_Double :: PrimOp
IndexOffAddrOp_StablePtr :: PrimOp
IndexOffAddrOp_Int8 :: PrimOp
IndexOffAddrOp_Int16 :: PrimOp
IndexOffAddrOp_Int32 :: PrimOp
IndexOffAddrOp_Int64 :: PrimOp
IndexOffAddrOp_Word8 :: PrimOp
IndexOffAddrOp_Word16 :: PrimOp
IndexOffAddrOp_Word32 :: PrimOp
IndexOffAddrOp_Word64 :: PrimOp
ReadOffAddrOp_Char :: PrimOp
ReadOffAddrOp_WideChar :: PrimOp
ReadOffAddrOp_Int :: PrimOp
ReadOffAddrOp_Word :: PrimOp
ReadOffAddrOp_Addr :: PrimOp
ReadOffAddrOp_Float :: PrimOp
ReadOffAddrOp_Double :: PrimOp
ReadOffAddrOp_StablePtr :: PrimOp
ReadOffAddrOp_Int8 :: PrimOp
ReadOffAddrOp_Int16 :: PrimOp
ReadOffAddrOp_Int32 :: PrimOp
ReadOffAddrOp_Int64 :: PrimOp
ReadOffAddrOp_Word8 :: PrimOp
ReadOffAddrOp_Word16 :: PrimOp
ReadOffAddrOp_Word32 :: PrimOp
ReadOffAddrOp_Word64 :: PrimOp
WriteOffAddrOp_Char :: PrimOp
WriteOffAddrOp_WideChar :: PrimOp
WriteOffAddrOp_Int :: PrimOp
WriteOffAddrOp_Word :: PrimOp
WriteOffAddrOp_Addr :: PrimOp
WriteOffAddrOp_Float :: PrimOp
WriteOffAddrOp_Double :: PrimOp
WriteOffAddrOp_StablePtr :: PrimOp
WriteOffAddrOp_Int8 :: PrimOp
WriteOffAddrOp_Int16 :: PrimOp
WriteOffAddrOp_Int32 :: PrimOp
WriteOffAddrOp_Int64 :: PrimOp
WriteOffAddrOp_Word8 :: PrimOp
WriteOffAddrOp_Word16 :: PrimOp
WriteOffAddrOp_Word32 :: PrimOp
WriteOffAddrOp_Word64 :: PrimOp
InterlockedExchange_Addr :: PrimOp
InterlockedExchange_Word :: PrimOp
CasAddrOp_Addr :: PrimOp
CasAddrOp_Word :: PrimOp
FetchAddAddrOp_Word :: PrimOp
FetchSubAddrOp_Word :: PrimOp
FetchAndAddrOp_Word :: PrimOp
FetchNandAddrOp_Word :: PrimOp
FetchOrAddrOp_Word :: PrimOp
FetchXorAddrOp_Word :: PrimOp
AtomicReadAddrOp_Word :: PrimOp
AtomicWriteAddrOp_Word :: PrimOp
NewMutVarOp :: PrimOp
ReadMutVarOp :: PrimOp
WriteMutVarOp :: PrimOp
SameMutVarOp :: PrimOp
AtomicModifyMutVar2Op :: PrimOp
AtomicModifyMutVar_Op :: PrimOp
CasMutVarOp :: PrimOp
CatchOp :: PrimOp
RaiseOp :: PrimOp
RaiseIOOp :: PrimOp
MaskAsyncExceptionsOp :: PrimOp
MaskUninterruptibleOp :: PrimOp
UnmaskAsyncExceptionsOp :: PrimOp
MaskStatus :: PrimOp
AtomicallyOp :: PrimOp
RetryOp :: PrimOp
CatchRetryOp :: PrimOp
CatchSTMOp :: PrimOp
NewTVarOp :: PrimOp
ReadTVarOp :: PrimOp
ReadTVarIOOp :: PrimOp
WriteTVarOp :: PrimOp
SameTVarOp :: PrimOp
NewMVarOp :: PrimOp
TakeMVarOp :: PrimOp
TryTakeMVarOp :: PrimOp
PutMVarOp :: PrimOp
TryPutMVarOp :: PrimOp
ReadMVarOp :: PrimOp
TryReadMVarOp :: PrimOp
SameMVarOp :: PrimOp
IsEmptyMVarOp :: PrimOp
NewIOPortrOp :: PrimOp
ReadIOPortOp :: PrimOp
WriteIOPortOp :: PrimOp
SameIOPortOp :: PrimOp
DelayOp :: PrimOp
WaitReadOp :: PrimOp
WaitWriteOp :: PrimOp
ForkOp :: PrimOp
ForkOnOp :: PrimOp
KillThreadOp :: PrimOp
YieldOp :: PrimOp
MyThreadIdOp :: PrimOp
LabelThreadOp :: PrimOp
IsCurrentThreadBoundOp :: PrimOp
NoDuplicateOp :: PrimOp
ThreadStatusOp :: PrimOp
MkWeakOp :: PrimOp
MkWeakNoFinalizerOp :: PrimOp
AddCFinalizerToWeakOp :: PrimOp
DeRefWeakOp :: PrimOp
FinalizeWeakOp :: PrimOp
TouchOp :: PrimOp
MakeStablePtrOp :: PrimOp
DeRefStablePtrOp :: PrimOp
EqStablePtrOp :: PrimOp
MakeStableNameOp :: PrimOp
EqStableNameOp :: PrimOp
StableNameToIntOp :: PrimOp
CompactNewOp :: PrimOp
CompactResizeOp :: PrimOp
CompactContainsOp :: PrimOp
CompactContainsAnyOp :: PrimOp
CompactGetFirstBlockOp :: PrimOp
CompactGetNextBlockOp :: PrimOp
CompactAllocateBlockOp :: PrimOp
CompactFixupPointersOp :: PrimOp
CompactAdd :: PrimOp
CompactAddWithSharing :: PrimOp
CompactSize :: PrimOp
ReallyUnsafePtrEqualityOp :: PrimOp
ParOp :: PrimOp
SparkOp :: PrimOp
SeqOp :: PrimOp
GetSparkOp :: PrimOp
NumSparks :: PrimOp
KeepAliveOp :: PrimOp
DataToTagOp :: PrimOp
TagToEnumOp :: PrimOp
AddrToAnyOp :: PrimOp
AnyToAddrOp :: PrimOp
MkApUpd0_Op :: PrimOp
NewBCOOp :: PrimOp
UnpackClosureOp :: PrimOp
ClosureSizeOp :: PrimOp
GetApStackValOp :: PrimOp
GetCCSOfOp :: PrimOp
GetCurrentCCSOp :: PrimOp
ClearCCSOp :: PrimOp
WhereFromOp :: PrimOp
TraceEventOp :: PrimOp
TraceEventBinaryOp :: PrimOp
TraceMarkerOp :: PrimOp
SetThreadAllocationCounter :: PrimOp
VecBroadcastOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecPackOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecUnpackOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecInsertOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecAddOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecSubOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecMulOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecDivOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecQuotOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecRemOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecNegOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexScalarByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadScalarByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteScalarByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexScalarOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadScalarOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteScalarOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
PrefetchByteArrayOp3 :: PrimOp
PrefetchMutableByteArrayOp3 :: PrimOp
PrefetchAddrOp3 :: PrimOp
PrefetchValueOp3 :: PrimOp
PrefetchByteArrayOp2 :: PrimOp
PrefetchMutableByteArrayOp2 :: PrimOp
PrefetchAddrOp2 :: PrimOp
PrefetchValueOp2 :: PrimOp
PrefetchByteArrayOp1 :: PrimOp
PrefetchMutableByteArrayOp1 :: PrimOp
PrefetchAddrOp1 :: PrimOp
PrefetchValueOp1 :: PrimOp
PrefetchByteArrayOp0 :: PrimOp
PrefetchMutableByteArrayOp0 :: PrimOp
PrefetchAddrOp0 :: PrimOp
PrefetchValueOp0 :: PrimOp
data PrimOpVecCat
IntVec :: PrimOpVecCat
WordVec :: PrimOpVecCat
FloatVec :: PrimOpVecCat
allThePrimOps :: [PrimOp]
primOpType :: PrimOp -> Type
primOpSig :: PrimOp -> ([TyVar], [Type], Type, Arity, StrictSig)
primOpResultType :: PrimOp -> Type
primOpTag :: PrimOp -> Int
maxPrimOpTag :: Int
primOpOcc :: PrimOp -> OccName

-- | Returns the <a>Id</a> of the wrapper associated with the given
--   <a>PrimOp</a>. See Note [Primop wrappers].
primOpWrapperId :: PrimOp -> Id
tagToEnumKey :: Unique
primOpOutOfLine :: PrimOp -> Bool
primOpCodeSize :: PrimOp -> Int
primOpOkForSpeculation :: PrimOp -> Bool
primOpOkForSideEffects :: PrimOp -> Bool
primOpIsCheap :: PrimOp -> Bool
primOpFixity :: PrimOp -> Maybe Fixity
primOpDocs :: [(String, String)]

-- | True of dyadic operators that can fail only if the second arg is zero!
--   
--   This function probably belongs in an automagically generated file..
--   but it's such a special case I thought I'd leave it here for now.
primOpIsDiv :: PrimOp -> Bool
getPrimOpResultInfo :: PrimOp -> PrimOpResultInfo
isComparisonPrimOp :: PrimOp -> Bool
data PrimOpResultInfo
ReturnsPrim :: PrimRep -> PrimOpResultInfo
ReturnsAlg :: TyCon -> PrimOpResultInfo
data PrimCall
PrimCall :: CLabelString -> Unit -> PrimCall
instance GHC.Utils.Outputable.Outputable GHC.Builtin.PrimOps.PrimCall
instance GHC.Classes.Eq GHC.Builtin.PrimOps.PrimOp
instance GHC.Classes.Ord GHC.Builtin.PrimOps.PrimOp
instance GHC.Utils.Outputable.Outputable GHC.Builtin.PrimOps.PrimOp


-- | Fixity
module GHC.Types.Fixity
data Fixity
Fixity :: SourceText -> Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection

-- | Captures the fixity of declarations as they are parsed. This is not
--   necessarily the same as the fixity declaration, as the normal fixity
--   may be overridden using parens or backticks.
data LexicalFixity
Prefix :: LexicalFixity
Infix :: LexicalFixity
maxPrecedence :: Int
minPrecedence :: Int
defaultFixity :: Fixity
negateFixity :: Fixity
funTyFixity :: Fixity
compareFixity :: Fixity -> Fixity -> (Bool, Bool)
instance Data.Data.Data GHC.Types.Fixity.FixityDirection
instance GHC.Classes.Eq GHC.Types.Fixity.FixityDirection
instance Data.Data.Data GHC.Types.Fixity.Fixity
instance GHC.Classes.Eq GHC.Types.Fixity.LexicalFixity
instance Data.Data.Data GHC.Types.Fixity.LexicalFixity
instance GHC.Utils.Outputable.Outputable GHC.Types.Fixity.LexicalFixity
instance GHC.Utils.Outputable.Outputable GHC.Types.Fixity.Fixity
instance GHC.Classes.Eq GHC.Types.Fixity.Fixity
instance GHC.Utils.Binary.Binary GHC.Types.Fixity.Fixity
instance GHC.Utils.Outputable.Outputable GHC.Types.Fixity.FixityDirection
instance GHC.Utils.Binary.Binary GHC.Types.Fixity.FixityDirection

module GHC.Cmm.Type
data CmmType
b8 :: CmmType
b16 :: CmmType
b32 :: CmmType
b64 :: CmmType
b128 :: CmmType
b256 :: CmmType
b512 :: CmmType
f32 :: CmmType
f64 :: CmmType
bWord :: Platform -> CmmType
bHalfWord :: Platform -> CmmType
gcWord :: Platform -> CmmType
cInt :: Platform -> CmmType
cmmBits :: Width -> CmmType
cmmFloat :: Width -> CmmType
typeWidth :: CmmType -> Width
cmmEqType :: CmmType -> CmmType -> Bool
cmmEqType_ignoring_ptrhood :: CmmType -> CmmType -> Bool
isFloatType :: CmmType -> Bool
isGcPtrType :: CmmType -> Bool
isBitsType :: CmmType -> Bool
isWord32 :: CmmType -> Bool
isWord64 :: CmmType -> Bool
isFloat64 :: CmmType -> Bool
isFloat32 :: CmmType -> Bool
data Width
W8 :: Width
W16 :: Width
W32 :: Width
W64 :: Width
W128 :: Width
W256 :: Width
W512 :: Width

-- | A width in bits.
widthInBits :: Width -> Int

-- | A width in bytes.
--   
--   <pre>
--   widthFromBytes (widthInBytes w) === w
--   </pre>
widthInBytes :: Width -> Int

-- | log_2 of the width in bytes, useful for generating shifts.
widthInLog :: Width -> Int

-- | <ul>
--   <li>Partial* A width from the number of bytes.</li>
--   </ul>
widthFromBytes :: Int -> Width

-- | The width of the current platform's word size.
wordWidth :: Platform -> Width

-- | The width of the current platform's half-word size.
halfWordWidth :: Platform -> Width
cIntWidth :: Platform -> Width

-- | A bit-mask for the lower half-word of current platform.
halfWordMask :: Platform -> Integer

-- | Narrow a signed or unsigned value to the given width. The result will
--   reside in <tt>[0, +2^width)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; narrowU W8 256    == 256
--   
--   &gt;&gt;&gt; narrowU W8 255    == 255
--   
--   &gt;&gt;&gt; narrowU W8 128    == 128
--   
--   &gt;&gt;&gt; narrowU W8 127    == 127
--   
--   &gt;&gt;&gt; narrowU W8 0      == 0
--   
--   &gt;&gt;&gt; narrowU W8 (-127) == 129
--   
--   &gt;&gt;&gt; narrowU W8 (-128) == 128
--   
--   &gt;&gt;&gt; narrowU W8 (-129) == 127
--   
--   &gt;&gt;&gt; narrowU W8 (-255) == 1
--   
--   &gt;&gt;&gt; narrowU W8 (-256) == 0
--   </pre>
narrowU :: Width -> Integer -> Integer

-- | Narrow a signed value to the given width. The result will reside in
--   <tt>[-2^(width-1), +2^(width-1))</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; narrowS W8 256    == 0
--   
--   &gt;&gt;&gt; narrowS W8 255    == -1
--   
--   &gt;&gt;&gt; narrowS W8 128    == -128
--   
--   &gt;&gt;&gt; narrowS W8 127    == 127
--   
--   &gt;&gt;&gt; narrowS W8 0      == 0
--   
--   &gt;&gt;&gt; narrowS W8 (-127) == -127
--   
--   &gt;&gt;&gt; narrowS W8 (-128) == -128
--   
--   &gt;&gt;&gt; narrowS W8 (-129) == 127
--   
--   &gt;&gt;&gt; narrowS W8 (-255) == 1
--   
--   &gt;&gt;&gt; narrowS W8 (-256) == 0
--   </pre>
narrowS :: Width -> Integer -> Integer
rEP_CostCentreStack_mem_alloc :: Platform -> CmmType
rEP_CostCentreStack_scc_count :: Platform -> CmmType
rEP_StgEntCounter_allocs :: Platform -> CmmType
rEP_StgEntCounter_allocd :: Platform -> CmmType
data ForeignHint
NoHint :: ForeignHint
AddrHint :: ForeignHint
SignedHint :: ForeignHint
type Length = Int
vec :: Length -> CmmType -> CmmType
vec2 :: CmmType -> CmmType
vec4 :: CmmType -> CmmType
vec8 :: CmmType -> CmmType
vec16 :: CmmType -> CmmType
vec2f64 :: CmmType
vec2b64 :: CmmType
vec4f32 :: CmmType
vec4b32 :: CmmType
vec8b16 :: CmmType
vec16b8 :: CmmType
cmmVec :: Int -> CmmType -> CmmType
vecLength :: CmmType -> Length
vecElemType :: CmmType -> CmmType
isVecType :: CmmType -> Bool
instance GHC.Show.Show GHC.Cmm.Type.Width
instance GHC.Classes.Ord GHC.Cmm.Type.Width
instance GHC.Classes.Eq GHC.Cmm.Type.Width
instance GHC.Show.Show GHC.Cmm.Type.CmmCat
instance GHC.Classes.Eq GHC.Cmm.Type.CmmCat
instance GHC.Show.Show GHC.Cmm.Type.CmmType
instance GHC.Classes.Eq GHC.Cmm.Type.ForeignHint
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Type.CmmType
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Type.CmmCat
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Type.Width


-- | Tidying types and coercions for printing in error messages.
module GHC.Core.TyCo.Tidy

-- | Tidy a Type
--   
--   See Note [Strictness in tidyType and friends]
tidyType :: TidyEnv -> Type -> Type

-- | Tidy a list of Types
--   
--   See Note [Strictness in tidyType and friends]
tidyTypes :: TidyEnv -> [Type] -> [Type]
tidyOpenType :: TidyEnv -> Type -> (TidyEnv, Type)

-- | Grabs the free type variables, tidies them and then uses
--   <a>tidyType</a> to work over the type itself
tidyOpenTypes :: TidyEnv -> [Type] -> (TidyEnv, [Type])
tidyOpenKind :: TidyEnv -> Kind -> (TidyEnv, Kind)
tidyVarBndr :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)

-- | This tidies up a type for printing in an error message, or in an
--   interface file.
--   
--   It doesn't change the uniques at all, just the print names.
tidyVarBndrs :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])

-- | Add the free <a>TyVar</a>s to the env in tidy form, so that we can
--   tidy the type they are free in
tidyFreeTyCoVars :: TidyEnv -> [TyCoVar] -> TidyEnv
avoidNameClashes :: [TyCoVar] -> TidyEnv -> TidyEnv

-- | Treat a new <a>TyCoVar</a> as a binder, and give it a fresh tidy name
--   using the environment if one has not already been allocated. See also
--   <a>tidyVarBndr</a>
tidyOpenTyCoVar :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)
tidyOpenTyCoVars :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])
tidyTyCoVarOcc :: TidyEnv -> TyCoVar -> TyCoVar

-- | Calls <a>tidyType</a> on a top-level type (i.e. with an empty tidying
--   environment)
tidyTopType :: Type -> Type
tidyKind :: TidyEnv -> Kind -> Kind

-- | Tidy a Coercion
--   
--   See Note [Strictness in tidyType and friends]
tidyCo :: TidyEnv -> Coercion -> Coercion
tidyCos :: TidyEnv -> [Coercion] -> [Coercion]
tidyTyCoVarBinder :: TidyEnv -> VarBndr TyCoVar vis -> (TidyEnv, VarBndr TyCoVar vis)
tidyTyCoVarBinders :: TidyEnv -> [VarBndr TyCoVar vis] -> (TidyEnv, [VarBndr TyCoVar vis])


-- | Unfolding creation
module GHC.Core.Unfold.Make

-- | There is no known <a>Unfolding</a>
noUnfolding :: Unfolding
mkUnfolding :: UnfoldingOpts -> UnfoldingSource -> Bool -> Bool -> CoreExpr -> Unfolding
mkCoreUnfolding :: UnfoldingSource -> Bool -> CoreExpr -> UnfoldingGuidance -> Unfolding
mkFinalUnfolding :: UnfoldingOpts -> UnfoldingSource -> StrictSig -> CoreExpr -> Unfolding
mkSimpleUnfolding :: UnfoldingOpts -> CoreExpr -> Unfolding
mkWorkerUnfolding :: SimpleOpts -> (CoreExpr -> CoreExpr) -> Unfolding -> Unfolding

-- | Make an unfolding that may be used unsaturated (ug_unsat_ok =
--   unSaturatedOk) and that is reported as having its manifest arity (the
--   number of outer lambdas applications will resolve before doing any
--   work).
mkInlineUnfolding :: SimpleOpts -> CoreExpr -> Unfolding

-- | Make an unfolding that will be used once the RHS has been saturated to
--   the given arity.
mkInlineUnfoldingWithArity :: Arity -> SimpleOpts -> CoreExpr -> Unfolding
mkInlinableUnfolding :: SimpleOpts -> CoreExpr -> Unfolding
mkWwInlineRule :: SimpleOpts -> CoreExpr -> Arity -> Unfolding

-- | Used for things that absolutely must be unfolded
mkCompulsoryUnfolding :: SimpleOpts -> CoreExpr -> Unfolding

-- | Same as <a>mkCompulsoryUnfolding</a> but no simple optimiser pass is
--   performed on the unfolding.
mkCompulsoryUnfolding' :: CoreExpr -> Unfolding
mkDFunUnfolding :: [Var] -> DataCon -> [CoreExpr] -> Unfolding
specUnfolding :: SimpleOpts -> [Var] -> (CoreExpr -> CoreExpr) -> [CoreArg] -> Unfolding -> Unfolding

module GHC.Core.SimpleOpt

-- | Simple optimiser options
data SimpleOpts
SimpleOpts :: !UnfoldingOpts -> !OptCoercionOpts -> SimpleOpts

-- | Unfolding options
[so_uf_opts] :: SimpleOpts -> !UnfoldingOpts

-- | Coercion optimiser options
[so_co_opts] :: SimpleOpts -> !OptCoercionOpts

-- | Default options for the Simple optimiser.
defaultSimpleOpts :: SimpleOpts
simpleOptPgm :: SimpleOpts -> Module -> CoreProgram -> [CoreRule] -> (CoreProgram, [CoreRule], CoreProgram)
simpleOptExpr :: HasDebugCallStack => SimpleOpts -> CoreExpr -> CoreExpr
simpleOptExprWith :: HasDebugCallStack => SimpleOpts -> Subst -> InExpr -> OutExpr

-- | Returns Just (bndr,rhs) if the binding is a join point: If it's a
--   JoinId, just return it If it's not yet a JoinId but is always
--   tail-called, make it into a JoinId and return it. In the latter case,
--   eta-expand the RHS if necessary, to make the lambdas explicit, as is
--   required for join points
--   
--   Precondition: the InBndr has been occurrence-analysed, so its OccInfo
--   is valid
joinPointBinding_maybe :: InBndr -> InExpr -> Maybe (InBndr, InExpr)
joinPointBindings_maybe :: [(InBndr, InExpr)] -> Maybe [(InBndr, InExpr)]

-- | Returns <tt>Just ([b1..bp], dc, [t1..tk], [x1..xn])</tt> if the
--   argument expression is a *saturated* constructor application of the
--   form <tt>let b1 in .. let bp in dc t1..tk x1 .. xn</tt>, where t1..tk
--   are the *universally-quantified* type args of <tt>dc</tt>. Floats can
--   also be (and most likely are) single-alternative case expressions. Why
--   does <a>exprIsConApp_maybe</a> return floats? We may have to look
--   through lets and cases to detect that we are in the presence of a data
--   constructor wrapper. In this case, we need to return the lets and
--   cases that we traversed. See Note [exprIsConApp_maybe on data
--   constructors with wrappers]. Data constructor wrappers are unfolded
--   late, but we really want to trigger case-of-known-constructor as early
--   as possible. See also Note [Activation for data constructor wrappers]
--   in <a>GHC.Types.Id.Make</a>.
--   
--   We also return the incoming InScopeSet, augmented with the binders
--   from any [FloatBind] that we return
exprIsConApp_maybe :: HasDebugCallStack => InScopeEnv -> CoreExpr -> Maybe (InScopeSet, [FloatBind], DataCon, [Type], [CoreExpr])
exprIsLiteral_maybe :: InScopeEnv -> CoreExpr -> Maybe Literal
exprIsLambda_maybe :: HasDebugCallStack => InScopeEnv -> CoreExpr -> Maybe (Var, CoreExpr, [CoreTickish])
instance GHC.Utils.Outputable.Outputable GHC.Core.SimpleOpt.SimpleOptEnv

module GHC.Core.Subst

-- | A substitution environment, containing <a>Id</a>, <a>TyVar</a>, and
--   <a>CoVar</a> substitutions.
--   
--   Some invariants apply to how you use the substitution:
--   
--   <ol>
--   <li>Note [The substitution invariant] in
--   <a>GHC.Core.TyCo.Subst</a></li>
--   <li>Note [Substitutions apply only once] in
--   <a>GHC.Core.TyCo.Subst</a></li>
--   </ol>
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | An environment for substituting for <a>Id</a>s
type IdSubstEnv = IdEnv CoreExpr

-- | A set of variables that are in scope at some point "Secrets of the
--   Glasgow Haskell Compiler inliner" Section 3.2 provides the motivation
--   for this abstraction.
data InScopeSet

-- | De-shadowing the program is sometimes a useful pre-pass. It can be
--   done simply by running over the bindings with an empty substitution,
--   because substitution returns a result that has no-shadowing
--   guaranteed.
--   
--   (Actually, within a single <i>type</i> there might still be shadowing,
--   because <a>substTy</a> is a no-op for the empty substitution, but
--   that's probably OK.)
--   
--   <ul>
--   <li><i>Aug 09</i> This function is not used in GHC at the moment, but
--   seems so short and simple that I'm going to leave it here</li>
--   </ul>
deShadowBinds :: CoreProgram -> CoreProgram

-- | Substitutes for the <a>Id</a>s within the <a>RuleInfo</a> given the
--   new function <a>Id</a>
substRuleInfo :: Subst -> Id -> RuleInfo -> RuleInfo
substRulesForImportedIds :: Subst -> [CoreRule] -> [CoreRule]

-- | See <a>substTy</a>.
substTy :: Subst -> Type -> Type

-- | See <a>substCo</a>
substCo :: HasCallStack => Subst -> Coercion -> Coercion

-- | substExpr applies a substitution to an entire <a>CoreExpr</a>.
--   Remember, you may only apply the substitution <i>once</i>: See Note
--   [Substitutions apply only once] in <a>GHC.Core.TyCo.Subst</a>
--   
--   Do *not* attempt to short-cut in the case of an empty substitution!
--   See Note [Extending the Subst]
substExpr :: HasDebugCallStack => Subst -> CoreExpr -> CoreExpr
substExprSC :: HasDebugCallStack => Subst -> CoreExpr -> CoreExpr

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBind :: HasDebugCallStack => Subst -> CoreBind -> (Subst, CoreBind)

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBindSC :: HasDebugCallStack => Subst -> CoreBind -> (Subst, CoreBind)

-- | Substitutes for the <a>Id</a>s within an unfolding NB: substUnfolding
--   <i>discards</i> any unfolding without without a Stable source. This is
--   usually what we want, but it may be a bit unexpected
substUnfolding :: Subst -> Unfolding -> Unfolding

-- | Substitutes for the <a>Id</a>s within an unfolding NB: substUnfolding
--   <i>discards</i> any unfolding without without a Stable source. This is
--   usually what we want, but it may be a bit unexpected
substUnfoldingSC :: Subst -> Unfolding -> Unfolding

-- | Find the substitution for an <a>Id</a> in the <a>Subst</a>
lookupIdSubst :: HasDebugCallStack => Subst -> Id -> CoreExpr

-- | Find the substitution for a <a>TyVar</a> in the <a>Subst</a>
lookupTCvSubst :: Subst -> TyVar -> Type
substIdType :: Subst -> Id -> Id
substIdOcc :: Subst -> Id -> Id
substTickish :: Subst -> CoreTickish -> CoreTickish
substDVarSet :: Subst -> DVarSet -> DVarSet

-- | Substitute into some <a>IdInfo</a> with regard to the supplied new
--   <a>Id</a>.
substIdInfo :: Subst -> Id -> IdInfo -> Maybe IdInfo
emptySubst :: Subst
mkEmptySubst :: InScopeSet -> Subst
mkSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> IdSubstEnv -> Subst

-- | Simultaneously substitute for a bunch of variables No left-right
--   shadowing ie the substitution for (x y. e) a1 a2 so neither x nor y
--   scope over a1 a2
mkOpenSubst :: InScopeSet -> [(Var, CoreArg)] -> Subst

-- | Find the in-scope set: see <a>GHC.Core.TyCo.Subst</a> Note [The
--   substitution invariant]
substInScope :: Subst -> InScopeSet
isEmptySubst :: Subst -> Bool

-- | Add a substitution for an <a>Id</a> to the <a>Subst</a>: you must
--   ensure that the in-scope set is such that TyCoSubst Note [The
--   substitution invariant] holds after extending the substitution like
--   this
extendIdSubst :: Subst -> Id -> CoreExpr -> Subst

-- | Adds multiple <a>Id</a> substitutions to the <a>Subst</a>: see also
--   <a>extendIdSubst</a>
extendIdSubstList :: Subst -> [(Id, CoreExpr)] -> Subst
extendTCvSubst :: TCvSubst -> TyCoVar -> Type -> TCvSubst

-- | Adds multiple <a>TyVar</a> substitutions to the <a>Subst</a>: see also
--   <a>extendTvSubst</a>
extendTvSubstList :: Subst -> [(TyVar, Type)] -> Subst

-- | Add a substitution appropriate to the thing being substituted (whether
--   an expression, type, or coercion). See also <a>extendIdSubst</a>,
--   <a>extendTvSubst</a>, <a>extendCvSubst</a>
extendSubst :: Subst -> Var -> CoreArg -> Subst

-- | Add a substitution as appropriate to each of the terms being
--   substituted (whether expressions, types, or coercions). See also
--   <a>extendSubst</a>.
extendSubstList :: Subst -> [(Var, CoreArg)] -> Subst
extendSubstWithVar :: Subst -> Var -> Var -> Subst

-- | Remove all substitutions for <a>Id</a>s and <a>Expr</a>s that might
--   have been built up while preserving the in-scope set
zapSubstEnv :: Subst -> Subst

-- | Add the <a>Expr</a> to the in-scope set: as a side effect, and remove
--   any existing substitutions for it
extendInScope :: Subst -> Var -> Subst

-- | Add the <a>Expr</a>s to the in-scope set: see also
--   <a>extendInScope</a>
extendInScopeList :: Subst -> [Var] -> Subst

-- | Optimized version of <a>extendInScopeList</a> that can be used if you
--   are certain all the things being added are <a>Id</a>s and hence none
--   are <a>TyVar</a>s or <a>CoVar</a>s
extendInScopeIds :: Subst -> [Id] -> Subst
isInScope :: Var -> Subst -> Bool
setInScope :: Subst -> InScopeSet -> Subst
getTCvSubst :: Subst -> TCvSubst

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a> The
--   <a>TyVar</a> *must* be a real TyVar, and not a CoVar You must ensure
--   that the in-scope set is such that <a>GHC.Core.TyCo.Subst</a> Note
--   [The substitution invariant] holds after extending the substitution
--   like this.
extendTvSubst :: Subst -> TyVar -> Type -> Subst

-- | Add a substitution from a <a>CoVar</a> to a <a>Expr</a> to the
--   <a>Subst</a>: you must ensure that the in-scope set satisfies
--   <a>GHC.Core.TyCo.Subst</a> Note [The substitution invariant] after
--   extending the substitution like this
extendCvSubst :: Subst -> CoVar -> Coercion -> Subst
delBndr :: Subst -> Var -> Subst
delBndrs :: Subst -> [Var] -> Subst

-- | Substitutes a <a>Expr</a> for another one according to the
--   <a>Subst</a> given, returning the result and an updated <a>Subst</a>
--   that should be used by subsequent substitutions. <a>IdInfo</a> is
--   preserved by this process, although it is substituted into
--   appropriately.
substBndr :: Subst -> Var -> (Subst, Var)

-- | Applies <a>substBndr</a> to a number of <a>Expr</a>s, accumulating a
--   new <a>Subst</a> left-to-right
substBndrs :: Subst -> [Var] -> (Subst, [Var])

-- | Substitute in a mutually recursive group of <a>Id</a>s
substRecBndrs :: Subst -> [Id] -> (Subst, [Id])
substTyVarBndr :: Subst -> TyVar -> (Subst, TyVar)
substCoVarBndr :: Subst -> CoVar -> (Subst, CoVar)
cloneBndr :: Subst -> Unique -> Var -> (Subst, Var)
cloneBndrs :: Subst -> UniqSupply -> [Var] -> (Subst, [Var])

-- | Very similar to <a>substBndr</a>, but it always allocates a new
--   <a>Unique</a> for each variable in its output. It substitutes the
--   IdInfo though.
cloneIdBndr :: Subst -> UniqSupply -> Id -> (Subst, Id)

-- | Applies <a>cloneIdBndr</a> to a number of <a>Id</a>s, accumulating a
--   final substitution from left to right
cloneIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])

-- | Clone a mutually recursive group of <a>Id</a>s
cloneRecIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])
instance GHC.Utils.Outputable.Outputable GHC.Core.Subst.Subst


-- | Various utilities for forcing Core structures
--   
--   It can often be useful to force various parts of the AST. This module
--   provides a number of <tt>seq</tt>-like functions to accomplish this.
module GHC.Core.Seq
seqExpr :: CoreExpr -> ()
seqExprs :: [CoreExpr] -> ()
seqUnfolding :: Unfolding -> ()
seqRules :: [CoreRule] -> ()

-- | Evaluate all the fields of the <a>IdInfo</a> that are generally
--   demanded by the compiler
megaSeqIdInfo :: IdInfo -> ()
seqRuleInfo :: RuleInfo -> ()
seqBinds :: [Bind CoreBndr] -> ()

module GHC.Core.Opt.OccurAnal
occurAnalysePgm :: Module -> (Id -> Bool) -> (Activation -> Bool) -> [CoreRule] -> CoreProgram -> CoreProgram
occurAnalyseExpr :: CoreExpr -> CoreExpr
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.OccurAnal.Details
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.OccurAnal.UsageDetails
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.OccurAnal.OccEncl


-- | Arity and eta expansion
module GHC.Core.Opt.Arity

-- | manifestArity sees how many leading value lambdas there are, after
--   looking through casts
manifestArity :: CoreExpr -> Arity
joinRhsArity :: CoreExpr -> JoinArity

-- | An approximate, fast, version of <a>exprEtaExpandArity</a>
exprArity :: CoreExpr -> Arity
typeArity :: Type -> [OneShotInfo]

-- | The Arity returned is the number of value args the expression can be
--   applied to without doing much work
exprEtaExpandArity :: DynFlags -> CoreExpr -> ArityType
findRhsArity :: DynFlags -> Id -> CoreExpr -> Arity -> ArityType

-- | <tt>etaExpand n e</tt> returns an expression with the same meaning as
--   <tt>e</tt>, but with arity <tt>n</tt>.
--   
--   Given:
--   
--   <pre>
--   e' = etaExpand n e
--   </pre>
--   
--   We should have that:
--   
--   <pre>
--   ty = exprType e = exprType e'
--   </pre>
etaExpand :: Arity -> CoreExpr -> CoreExpr
etaExpandAT :: ArityType -> CoreExpr -> CoreExpr
exprBotStrictness_maybe :: CoreExpr -> Maybe (Arity, StrictSig)

-- | The analysis lattice of arity analysis. It is isomorphic to
--   
--   <pre>
--   data ArityType'
--     = AEnd Divergence
--     | ALam OneShotInfo ArityType'
--   </pre>
--   
--   Which is easier to display the Hasse diagram for:
--   
--   <pre>
--   ALam OneShotLam at
--           |
--       AEnd topDiv
--           |
--   ALam NoOneShotInfo at
--           |
--       AEnd exnDiv
--           |
--       AEnd botDiv
--   </pre>
--   
--   where the <tt>at</tt> fields of <tt>ALam</tt> are inductively subject
--   to the same order. That is, <tt>ALam os at1 &lt; ALam os at2</tt> iff
--   <tt>at1 &lt; at2</tt>.
--   
--   Why the strange Top element? See Note [Combining case branches].
--   
--   We rely on this lattice structure for fixed-point iteration in
--   <a>findRhsArity</a>. For the semantics of <a>ArityType</a>, see Note
--   [ArityType].
data ArityType

-- | <tt>AT oss div</tt> means this value can safely be eta-expanded
--   <tt>length oss</tt> times, provided use sites respect the
--   <a>OneShotInfo</a>s in <tt>oss</tt>. A <a>OneShotLam</a> annotation
--   can come from two sources: * The user annotated a lambda as one-shot
--   with <a>oneShot</a> * It's from a lambda binder of a type affected by
--   `-fstate-hack`. See <a>idStateHackOneShotInfo</a>. In both cases,
--   <a>OneShotLam</a> should win over <a>NoOneShotInfo</a>, see Note
--   [Combining case branches].
--   
--   If <tt>div</tt> is dead-ending (<a>isDeadEndDiv</a>), then application
--   to <tt>length os</tt> arguments will surely diverge, similar to the
--   situation with <a>DmdType</a>.
AT :: ![OneShotInfo] -> !Divergence -> ArityType
mkBotArityType :: [OneShotInfo] -> ArityType
mkTopArityType :: [OneShotInfo] -> ArityType

-- | True <a>=</a> eta-expansion will add at least one lambda
expandableArityType :: ArityType -> Bool

-- | The number of value args for the arity type
arityTypeArity :: ArityType -> Arity

-- | Expand a non-bottoming arity type so that it has at least the given
--   arity.
maxWithArity :: ArityType -> Arity -> ArityType
idArityType :: Id -> ArityType

-- | Split an expression into the given number of binders and a body,
--   eta-expanding if necessary. Counts value *and* type binders.
etaExpandToJoinPoint :: JoinArity -> CoreExpr -> ([CoreBndr], CoreExpr)
etaExpandToJoinPointRule :: JoinArity -> CoreRule -> CoreRule
pushCoArg :: CoercionR -> CoreArg -> Maybe (CoreArg, MCoercion)
pushCoArgs :: CoercionR -> [CoreArg] -> Maybe ([CoreArg], MCoercion)
pushCoValArg :: CoercionR -> Maybe (MCoercionR, MCoercionR)
pushCoTyArg :: CoercionR -> Type -> Maybe (Type, MCoercionR)
pushCoercionIntoLambda :: HasDebugCallStack => InScopeSet -> Var -> CoreExpr -> CoercionR -> Maybe (Var, CoreExpr)
pushCoDataCon :: DataCon -> [CoreExpr] -> Coercion -> Maybe (DataCon, [Type], [CoreExpr])
collectBindersPushingCo :: CoreExpr -> ([Var], CoreExpr)
instance GHC.Classes.Eq GHC.Core.Opt.Arity.ArityType
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Arity.ArityType


-- | Handy functions for creating much Core syntax
module GHC.Core.Make

-- | Bind a binding group over an expression, using a <tt>let</tt> or
--   <tt>case</tt> as appropriate (see <a>GHC.Core#let_app_invariant</a>)
mkCoreLet :: CoreBind -> CoreExpr -> CoreExpr

-- | Bind a list of binding groups over an expression. The leftmost binding
--   group becomes the outermost group in the resulting expression
mkCoreLets :: [CoreBind] -> CoreExpr -> CoreExpr

-- | Construct an expression which represents the application of one
--   expression to the other Respects the let/app invariant by building a
--   case expression where necessary See Note [Core let/app invariant] in
--   <a>GHC.Core</a>
mkCoreApp :: SDoc -> CoreExpr -> CoreExpr -> CoreExpr
infixl 4 `mkCoreApp`

-- | Construct an expression which represents the application of a number
--   of expressions to another. The leftmost expression in the list is
--   applied first Respects the let/app invariant by building a case
--   expression where necessary See Note [Core let/app invariant] in
--   <a>GHC.Core</a>
mkCoreApps :: CoreExpr -> [CoreExpr] -> CoreExpr
infixl 4 `mkCoreApps`

-- | Construct an expression which represents the application of a number
--   of expressions to that of a data constructor expression. The leftmost
--   expression in the list is applied first
mkCoreConApps :: DataCon -> [CoreExpr] -> CoreExpr

-- | Create a lambda where the given expression has a number of variables
--   bound over it. The leftmost binder is that bound by the outermost
--   lambda in the result
mkCoreLams :: [CoreBndr] -> CoreExpr -> CoreExpr
mkWildCase :: CoreExpr -> Scaled Type -> Type -> [CoreAlt] -> CoreExpr
mkIfThenElse :: CoreExpr -> CoreExpr -> CoreExpr -> CoreExpr

-- | Make a <i>wildcard binder</i>. This is typically used when you need a
--   binder that you expect to use only at a *binding* site. Do not use it
--   at occurrence sites because it has a single, fixed unique, and it's
--   very easy to get into difficulties with shadowing. That's why it is
--   used so little. See Note [WildCard binders] in
--   <a>GHC.Core.Opt.Simplify.Env</a>
mkWildValBinder :: Mult -> Type -> Id
mkWildEvBinder :: PredType -> EvVar
mkSingleAltCase :: CoreExpr -> Id -> AltCon -> [Var] -> CoreExpr -> CoreExpr
sortQuantVars :: [Var] -> [Var]
castBottomExpr :: CoreExpr -> Type -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the a <tt>Word</tt>
--   with the given value
mkWordExpr :: Platform -> Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given <tt>Int</tt>
mkIntExpr :: Platform -> Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given <tt>Int</tt>
mkIntExprInt :: Platform -> Int -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Int</tt>. Don't check that the number is in the range of the
--   target platform <tt>Int</tt>
mkUncheckedIntExpr :: Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Integer</tt>
mkIntegerExpr :: Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Natural</tt>
mkNaturalExpr :: Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Float</tt>
mkFloatExpr :: Float -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Double</tt>
mkDoubleExpr :: Double -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Char</tt>
mkCharExpr :: Char -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>String</tt>
mkStringExpr :: MonadThings m => String -> m CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to a string morally
--   equivalent to the given <tt>FastString</tt>
mkStringExprFS :: MonadThings m => FastString -> m CoreExpr
mkStringExprFSWith :: Monad m => (Name -> m Id) -> FastString -> m CoreExpr
data FloatBind
FloatLet :: CoreBind -> FloatBind
FloatCase :: CoreExpr -> Id -> AltCon -> [Var] -> FloatBind
wrapFloat :: FloatBind -> CoreExpr -> CoreExpr

-- | Applies the floats from right to left. That is <tt>wrapFloats [b1, b2,
--   â¦, bn] u = let b1 in let b2 in â¦ in let bn in u</tt>
wrapFloats :: [FloatBind] -> CoreExpr -> CoreExpr
floatBindings :: FloatBind -> [Var]

-- | Build the type of a small tuple that holds the specified variables
--   One-tuples are flattened; see Note [Flattening one-tuples]
mkCoreVarTupTy :: [Id] -> Type

-- | Build a small tuple holding the specified expressions One-tuples are
--   flattened; see Note [Flattening one-tuples]
mkCoreTup :: [CoreExpr] -> CoreExpr

-- | Build a small unboxed tuple holding the specified expressions, with
--   the given types. The types must be the types of the expressions. Do
--   not include the RuntimeRep specifiers; this function calculates them
--   for you. Does <i>not</i> flatten one-tuples; see Note [Flattening
--   one-tuples]
mkCoreUbxTup :: [Type] -> [CoreExpr] -> CoreExpr

-- | Build an unboxed sum.
--   
--   Alternative number ("alt") starts from 1.
mkCoreUbxSum :: Int -> Int -> [Type] -> CoreExpr -> CoreExpr

-- | Make a core tuple of the given boxity; don't flatten 1-tuples
mkCoreTupBoxity :: Boxity -> [CoreExpr] -> CoreExpr

-- | The unit expression
unitExpr :: CoreExpr

-- | Build a big tuple holding the specified variables One-tuples are
--   flattened; see Note [Flattening one-tuples]
mkBigCoreVarTup :: [Id] -> CoreExpr
mkBigCoreVarTup1 :: [Id] -> CoreExpr

-- | Build the type of a big tuple that holds the specified variables
--   One-tuples are flattened; see Note [Flattening one-tuples]
mkBigCoreVarTupTy :: [Id] -> Type

-- | Build the type of a big tuple that holds the specified type of thing
--   One-tuples are flattened; see Note [Flattening one-tuples]
mkBigCoreTupTy :: [Type] -> Type

-- | Build a big tuple holding the specified expressions One-tuples are
--   flattened; see Note [Flattening one-tuples]
mkBigCoreTup :: [CoreExpr] -> CoreExpr

-- | <a>mkSmallTupleSelector1</a> is like <a>mkSmallTupleSelector</a> but
--   one-tuples are NOT flattened (see Note [Flattening one-tuples])
--   
--   Like <a>mkTupleSelector</a> but for tuples that are guaranteed never
--   to be "big".
--   
--   <pre>
--   mkSmallTupleSelector [x] x v e = [| e |]
--   mkSmallTupleSelector [x,y,z] x v e = [| case e of v { (x,y,z) -&gt; x } |]
--   </pre>
mkSmallTupleSelector :: [Id] -> Id -> Id -> CoreExpr -> CoreExpr

-- | As <a>mkTupleCase</a>, but for a tuple that is small enough to be
--   guaranteed not to need nesting.
mkSmallTupleCase :: [Id] -> CoreExpr -> Id -> CoreExpr -> CoreExpr

-- | <a>mkTupleSelector1</a> is like <a>mkTupleSelector</a> but one-tuples
--   are NOT flattened (see Note [Flattening one-tuples])
--   
--   Builds a selector which scrutises the given expression and extracts
--   the one name from the list given. If you want the no-shadowing rule to
--   apply, the caller is responsible for making sure that none of these
--   names are in scope.
--   
--   If there is just one <a>Id</a> in the tuple, then the selector is just
--   the identity.
--   
--   If necessary, we pattern match on a "big" tuple.
--   
--   A tuple selector is not linear in its argument. Consequently, the case
--   expression built by <a>mkTupleSelector</a> must consume its scrutinee
--   <a>Many</a> times. And all the argument variables must have
--   multiplicity <a>Many</a>.
mkTupleSelector :: [Id] -> Id -> Id -> CoreExpr -> CoreExpr

-- | Builds a selector which scrutises the given expression and extracts
--   the one name from the list given. If you want the no-shadowing rule to
--   apply, the caller is responsible for making sure that none of these
--   names are in scope.
--   
--   If there is just one <a>Id</a> in the tuple, then the selector is just
--   the identity.
--   
--   If necessary, we pattern match on a "big" tuple.
--   
--   A tuple selector is not linear in its argument. Consequently, the case
--   expression built by <a>mkTupleSelector</a> must consume its scrutinee
--   <a>Many</a> times. And all the argument variables must have
--   multiplicity <a>Many</a>.
mkTupleSelector1 :: [Id] -> Id -> Id -> CoreExpr -> CoreExpr

-- | A generalization of <a>mkTupleSelector</a>, allowing the body of the
--   case to be an arbitrary expression.
--   
--   To avoid shadowing, we use uniques to invent new variables.
--   
--   If necessary we pattern match on a "big" tuple.
mkTupleCase :: UniqSupply -> [Id] -> CoreExpr -> Id -> CoreExpr -> CoreExpr

-- | Makes a list <tt>[]</tt> for lists of the specified type
mkNilExpr :: Type -> CoreExpr

-- | Makes a list <tt>(:)</tt> for lists of the specified type
mkConsExpr :: Type -> CoreExpr -> CoreExpr -> CoreExpr

-- | Make a list containing the given expressions, where the list has the
--   given type
mkListExpr :: Type -> [CoreExpr] -> CoreExpr

-- | Make a fully applied <a>foldr</a> expression
mkFoldrExpr :: MonadThings m => Type -> Type -> CoreExpr -> CoreExpr -> CoreExpr -> m CoreExpr

-- | Make a <tt>build</tt> expression applied to a locally-bound worker
--   function
mkBuildExpr :: (MonadFail m, MonadThings m, MonadUnique m) => Type -> ((Id, Type) -> (Id, Type) -> m CoreExpr) -> m CoreExpr
mkNonEmptyListExpr :: Type -> CoreExpr -> [CoreExpr] -> CoreExpr

-- | Makes a Nothing for the specified type
mkNothingExpr :: Type -> CoreExpr

-- | Makes a Just from a value of the specified type
mkJustExpr :: Type -> CoreExpr -> CoreExpr
mkRuntimeErrorApp :: Id -> Type -> String -> CoreExpr
mkImpossibleExpr :: Type -> CoreExpr
mkAbsentErrorApp :: Type -> String -> CoreExpr
errorIds :: [Id]
rEC_CON_ERROR_ID :: Id
rUNTIME_ERROR_ID :: Id
nON_EXHAUSTIVE_GUARDS_ERROR_ID :: Id
nO_METHOD_BINDING_ERROR_ID :: Id
pAT_ERROR_ID :: Id
rEC_SEL_ERROR_ID :: Id
aBSENT_ERROR_ID :: Id
tYPE_ERROR_ID :: Id
aBSENT_SUM_FIELD_ERROR_ID :: Id
instance GHC.Utils.Outputable.Outputable GHC.Core.Make.FloatBind


-- | Here we collect a variety of helper functions that construct or
--   analyse HsSyn. All these functions deal with generic HsSyn; functions
--   which deal with the instantiated versions are located elsewhere:
--   
--   Parameterised by Module ---------------- ------------- GhcPs/RdrName
--   GHC.Parser.PostProcess GhcRn/Name GHC.Rename.* GhcTc/Id
--   GHC.Tc.Utils.Zonk
--   
--   The <tt>mk*</tt> functions attempt to construct a
--   not-completely-useless SrcSpan from their components, compared with
--   the <tt>nl*</tt> functions which just attach noSrcSpan to everything.
module GHC.Hs.Utils

-- | <pre>
--   e =&gt; (e)
--   </pre>
mkHsPar :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsApp :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsAppWith :: (LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> HsExpr (GhcPass id) -> LHsExpr (GhcPass id)) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsApps :: LHsExpr (GhcPass id) -> [LHsExpr (GhcPass id)] -> LHsExpr (GhcPass id)
mkHsAppsWith :: (LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> HsExpr (GhcPass id) -> LHsExpr (GhcPass id)) -> LHsExpr (GhcPass id) -> [LHsExpr (GhcPass id)] -> LHsExpr (GhcPass id)
mkHsAppType :: LHsExpr GhcRn -> LHsWcType GhcRn -> LHsExpr GhcRn
mkHsAppTypes :: LHsExpr GhcRn -> [LHsWcType GhcRn] -> LHsExpr GhcRn

-- | A simple case alternative with a single pattern, no binds, no guards;
--   pre-typechecking
mkHsCaseAlt :: (Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpan, Anno (Match (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpanAnnA) => LPat (GhcPass p) -> LocatedA (body (GhcPass p)) -> LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
mkSimpleMatch :: (Anno (Match (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpanAnnA, Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpan) => HsMatchContext (NoGhcTc (GhcPass p)) -> [LPat (GhcPass p)] -> LocatedA (body (GhcPass p)) -> LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
unguardedGRHSs :: Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpan => SrcSpan -> LocatedA (body (GhcPass p)) -> EpAnn GrhsAnn -> GRHSs (GhcPass p) (LocatedA (body (GhcPass p)))
unguardedRHS :: Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpan => EpAnn GrhsAnn -> SrcSpan -> LocatedA (body (GhcPass p)) -> [LGRHS (GhcPass p) (LocatedA (body (GhcPass p)))]
mkMatchGroup :: AnnoBody p body => Origin -> LocatedL [LocatedA (Match (GhcPass p) (LocatedA (body (GhcPass p))))] -> MatchGroup (GhcPass p) (LocatedA (body (GhcPass p)))
mkMatch :: forall p. IsPass p => HsMatchContext (NoGhcTc (GhcPass p)) -> [LPat (GhcPass p)] -> LHsExpr (GhcPass p) -> HsLocalBinds (GhcPass p) -> LMatch (GhcPass p) (LHsExpr (GhcPass p))

-- | Make a prefix, non-strict function <a>HsMatchContext</a>
mkPrefixFunRhs :: LIdP p -> HsMatchContext p
mkHsLam :: (IsPass p, XMG (GhcPass p) (LHsExpr (GhcPass p)) ~ NoExtField) => [LPat (GhcPass p)] -> LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
mkHsIf :: LHsExpr GhcPs -> LHsExpr GhcPs -> LHsExpr GhcPs -> EpAnn AnnsIf -> HsExpr GhcPs

-- | Avoid <tt><a>HsWrap</a> co1 (<a>HsWrap</a> co2 _)</tt> and
--   <tt><a>HsWrap</a> co1 (<a>HsPar</a> _ _)</tt> See Note [Detecting
--   forced eta expansion] in <a>GHC.HsToCore.Expr</a>
mkHsWrap :: HsWrapper -> HsExpr GhcTc -> HsExpr GhcTc
mkLHsWrap :: HsWrapper -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsWrapCo :: TcCoercionN -> HsExpr GhcTc -> HsExpr GhcTc
mkHsWrapCoR :: TcCoercionR -> HsExpr GhcTc -> HsExpr GhcTc
mkLHsWrapCo :: TcCoercionN -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsDictLet :: TcEvBinds -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsLams :: [TyVar] -> [EvVar] -> LHsExpr GhcTc -> LHsExpr GhcTc

-- | A useful function for building <tt>OpApps</tt>. The operator is always
--   a variable, and we don't know the fixity yet.
mkHsOpApp :: LHsExpr GhcPs -> IdP GhcPs -> LHsExpr GhcPs -> HsExpr GhcPs
mkHsDo :: HsStmtContext GhcRn -> LocatedL [ExprLStmt GhcPs] -> HsExpr GhcPs
mkHsDoAnns :: HsStmtContext GhcRn -> LocatedL [ExprLStmt GhcPs] -> EpAnn AnnList -> HsExpr GhcPs
mkHsComp :: HsStmtContext GhcRn -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> HsExpr GhcPs
mkHsCompAnns :: HsStmtContext GhcRn -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> EpAnn AnnList -> HsExpr GhcPs
mkHsWrapPat :: HsWrapper -> Pat GhcTc -> Type -> Pat GhcTc
mkHsWrapPatCo :: TcCoercionN -> Pat GhcTc -> Type -> Pat GhcTc

-- | Wrap in parens if <tt><a>hsExprNeedsParens</a> appPrec</tt> says it
--   needs them So <tt>f x</tt> becomes <tt>(f x)</tt>, but <tt>3</tt>
--   stays as <tt>3</tt>.
mkLHsPar :: IsPass id => LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsCmdWrap :: HsWrapper -> HsCmd GhcTc -> HsCmd GhcTc
mkLHsCmdWrap :: HsWrapper -> LHsCmd GhcTc -> LHsCmd GhcTc
mkHsCmdIf :: LHsExpr GhcPs -> LHsCmd GhcPs -> LHsCmd GhcPs -> EpAnn AnnsIf -> HsCmd GhcPs
nlHsTyApp :: Id -> [Type] -> LHsExpr GhcTc
nlHsTyApps :: Id -> [Type] -> [LHsExpr GhcTc] -> LHsExpr GhcTc
nlHsVar :: IsSrcSpanAnn p a => IdP (GhcPass p) -> LHsExpr (GhcPass p)
nl_HsVar :: IsSrcSpanAnn p a => IdP (GhcPass p) -> HsExpr (GhcPass p)

-- | NB: Only for <a>LHsExpr</a> <a>Id</a>.
nlHsDataCon :: DataCon -> LHsExpr GhcTc
nlHsLit :: HsLit (GhcPass p) -> LHsExpr (GhcPass p)
nlHsApp :: IsPass id => LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
nlHsApps :: IsSrcSpanAnn p a => IdP (GhcPass p) -> [LHsExpr (GhcPass p)] -> LHsExpr (GhcPass p)
nlHsSyntaxApps :: SyntaxExprTc -> [LHsExpr GhcTc] -> LHsExpr GhcTc
nlHsIntLit :: Integer -> LHsExpr (GhcPass p)
nlHsVarApps :: IsSrcSpanAnn p a => IdP (GhcPass p) -> [IdP (GhcPass p)] -> LHsExpr (GhcPass p)
nlHsDo :: HsStmtContext GhcRn -> [LStmt GhcPs (LHsExpr GhcPs)] -> LHsExpr GhcPs
nlHsOpApp :: LHsExpr GhcPs -> IdP GhcPs -> LHsExpr GhcPs -> LHsExpr GhcPs
nlHsLam :: LMatch GhcPs (LHsExpr GhcPs) -> LHsExpr GhcPs
nlHsPar :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
nlHsIf :: LHsExpr GhcPs -> LHsExpr GhcPs -> LHsExpr GhcPs -> LHsExpr GhcPs
nlHsCase :: LHsExpr GhcPs -> [LMatch GhcPs (LHsExpr GhcPs)] -> LHsExpr GhcPs
nlList :: [LHsExpr GhcPs] -> LHsExpr GhcPs
mkLHsTupleExpr :: [LHsExpr (GhcPass p)] -> XExplicitTuple (GhcPass p) -> LHsExpr (GhcPass p)
mkLHsVarTuple :: IsSrcSpanAnn p a => [IdP (GhcPass p)] -> XExplicitTuple (GhcPass p) -> LHsExpr (GhcPass p)
missingTupArg :: EpAnn EpaLocation -> HsTupArg GhcPs
mkLocatedList :: Semigroup a => [GenLocated (SrcAnn a) e2] -> LocatedAn an [GenLocated (SrcAnn a) e2]

-- | Lifts a "small" constructor into a "big" constructor by recursive
--   decomposition
mkChunkified :: ([a] -> a) -> [a] -> a

-- | Split a list into lists that are small enough to have a corresponding
--   tuple arity. The sub-lists of the result all have length &lt;=
--   <a>mAX_TUPLE_SIZE</a> But there may be more than <a>mAX_TUPLE_SIZE</a>
--   sub-lists
chunkify :: [a] -> [[a]]

-- | Not infix, with place holders for coercion and free vars
mkFunBind :: Origin -> LocatedN RdrName -> [LMatch GhcPs (LHsExpr GhcPs)] -> HsBind GhcPs
mkVarBind :: IdP (GhcPass p) -> LHsExpr (GhcPass p) -> LHsBind (GhcPass p)
mkHsVarBind :: SrcSpan -> RdrName -> LHsExpr GhcPs -> LHsBind GhcPs

-- | Convenience function using <a>mkFunBind</a>. This is for generated
--   bindings only, do not use for user-written code.
mkSimpleGeneratedFunBind :: SrcSpan -> RdrName -> [LPat GhcPs] -> LHsExpr GhcPs -> LHsBind GhcPs

-- | In Name-land, with empty bind_fvs
mkTopFunBind :: Origin -> LocatedN Name -> [LMatch GhcRn (LHsExpr GhcRn)] -> HsBind GhcRn
mkPatSynBind :: LocatedN RdrName -> HsPatSynDetails GhcPs -> LPat GhcPs -> HsPatSynDir GhcPs -> EpAnn [AddEpAnn] -> HsBind GhcPs

-- | If any of the matches in the <a>FunBind</a> are infix, the
--   <a>FunBind</a> is considered infix.
isInfixFunBind :: forall id1 id2. UnXRec id2 => HsBindLR id1 id2 -> Bool

-- | Return the <a>SrcSpan</a> encompassing the contents of any enclosed
--   binds
spanHsLocaLBinds :: Data (HsLocalBinds (GhcPass p)) => HsLocalBinds (GhcPass p) -> SrcSpan
mkHsIntegral :: IntegralLit -> HsOverLit GhcPs
mkHsFractional :: FractionalLit -> HsOverLit GhcPs
mkHsIsString :: SourceText -> FastString -> HsOverLit GhcPs
mkHsString :: String -> HsLit (GhcPass p)
mkHsStringPrimLit :: FastString -> HsLit (GhcPass p)
mkHsCharPrimLit :: Char -> HsLit (GhcPass p)
mkNPat :: Located (HsOverLit GhcPs) -> Maybe (SyntaxExpr GhcPs) -> EpAnn [AddEpAnn] -> Pat GhcPs
mkNPlusKPat :: LocatedN RdrName -> Located (HsOverLit GhcPs) -> EpAnn EpaLocation -> Pat GhcPs
nlVarPat :: IsSrcSpanAnn p a => IdP (GhcPass p) -> LPat (GhcPass p)
nlLitPat :: HsLit GhcPs -> LPat GhcPs
nlConVarPat :: RdrName -> [RdrName] -> LPat GhcPs
nlConVarPatName :: Name -> [Name] -> LPat GhcRn
nlConPat :: RdrName -> [LPat GhcPs] -> LPat GhcPs
nlConPatName :: Name -> [LPat GhcRn] -> LPat GhcRn
nlInfixConPat :: RdrName -> LPat GhcPs -> LPat GhcPs -> LPat GhcPs
nlNullaryConPat :: RdrName -> LPat GhcPs
nlWildConPat :: DataCon -> LPat GhcPs

-- | Wildcard pattern - after parsing
nlWildPat :: LPat GhcPs

-- | Wildcard pattern - after renaming
nlWildPatName :: LPat GhcRn
nlTuplePat :: [LPat GhcPs] -> Boxity -> LPat GhcPs
mkParPat :: IsPass p => LPat (GhcPass p) -> LPat (GhcPass p)
nlParPat :: LPat (GhcPass name) -> LPat (GhcPass name)

-- | The Big equivalents for the source tuple expressions
mkBigLHsVarTup :: IsSrcSpanAnn p a => [IdP (GhcPass p)] -> XExplicitTuple (GhcPass p) -> LHsExpr (GhcPass p)
mkBigLHsTup :: [LHsExpr (GhcPass id)] -> XExplicitTuple (GhcPass id) -> LHsExpr (GhcPass id)

-- | The Big equivalents for the source tuple patterns
mkBigLHsVarPatTup :: [IdP GhcRn] -> LPat GhcRn
mkBigLHsPatTup :: [LPat GhcRn] -> LPat GhcRn
mkHsAppTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
mkHsAppKindTy :: XAppKindTy (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)

-- | Convert an <a>LHsType</a> to an <a>LHsSigType</a>.
hsTypeToHsSigType :: LHsType GhcPs -> LHsSigType GhcPs

-- | Convert an <a>LHsType</a> to an <a>LHsSigWcType</a>.
hsTypeToHsSigWcType :: LHsType GhcPs -> LHsSigWcType GhcPs

-- | Convert <a>TypeSig</a> to <a>ClassOpSig</a>. The former is what is
--   parsed, but the latter is what we need in class/instance declarations
mkClassOpSigs :: [LSig GhcPs] -> [LSig GhcPs]
mkHsSigEnv :: forall a. (LSig GhcRn -> Maybe ([LocatedN Name], a)) -> [LSig GhcRn] -> NameEnv a
nlHsAppTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
nlHsAppKindTy :: LHsType (GhcPass p) -> LHsKind (GhcPass p) -> LHsType (GhcPass p)
nlHsTyVar :: IsSrcSpanAnn p a => IdP (GhcPass p) -> LHsType (GhcPass p)
nlHsFunTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
nlHsParTy :: LHsType (GhcPass p) -> LHsType (GhcPass p)
nlHsTyConApp :: IsSrcSpanAnn p a => LexicalFixity -> IdP (GhcPass p) -> [LHsTypeArg (GhcPass p)] -> LHsType (GhcPass p)
mkTransformStmt :: EpAnn [AddEpAnn] -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkTransformByStmt :: EpAnn [AddEpAnn] -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkBodyStmt :: LocatedA (bodyR GhcPs) -> StmtLR (GhcPass idL) GhcPs (LocatedA (bodyR GhcPs))
mkPsBindStmt :: EpAnn [AddEpAnn] -> LPat GhcPs -> LocatedA (bodyR GhcPs) -> StmtLR GhcPs GhcPs (LocatedA (bodyR GhcPs))
mkRnBindStmt :: LPat GhcRn -> LocatedA (bodyR GhcRn) -> StmtLR GhcRn GhcRn (LocatedA (bodyR GhcRn))
mkTcBindStmt :: LPat GhcTc -> LocatedA (bodyR GhcTc) -> StmtLR GhcTc GhcTc (LocatedA (bodyR GhcTc))
mkLastStmt :: IsPass idR => LocatedA (bodyR (GhcPass idR)) -> StmtLR (GhcPass idL) (GhcPass idR) (LocatedA (bodyR (GhcPass idR)))
emptyTransStmt :: EpAnn [AddEpAnn] -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkGroupUsingStmt :: EpAnn [AddEpAnn] -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkGroupByUsingStmt :: EpAnn [AddEpAnn] -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
emptyRecStmt :: Anno [GenLocated (Anno (StmtLR (GhcPass idL) GhcPs bodyR)) (StmtLR (GhcPass idL) GhcPs bodyR)] ~ SrcSpanAnnL => StmtLR (GhcPass idL) GhcPs bodyR
emptyRecStmtName :: Anno [GenLocated (Anno (StmtLR GhcRn GhcRn bodyR)) (StmtLR GhcRn GhcRn bodyR)] ~ SrcSpanAnnL => StmtLR GhcRn GhcRn bodyR
emptyRecStmtId :: Stmt GhcTc (LocatedA (HsCmd GhcTc))
mkRecStmt :: Anno [GenLocated (Anno (StmtLR (GhcPass idL) GhcPs bodyR)) (StmtLR (GhcPass idL) GhcPs bodyR)] ~ SrcSpanAnnL => EpAnn AnnList -> LocatedL [LStmtLR (GhcPass idL) GhcPs bodyR] -> StmtLR (GhcPass idL) GhcPs bodyR
unitRecStmtTc :: RecStmtTc
mkLetStmt :: EpAnn [AddEpAnn] -> HsLocalBinds GhcPs -> StmtLR GhcPs GhcPs (LocatedA b)
mkUntypedSplice :: EpAnn [AddEpAnn] -> SpliceDecoration -> LHsExpr GhcPs -> HsSplice GhcPs
mkTypedSplice :: EpAnn [AddEpAnn] -> SpliceDecoration -> LHsExpr GhcPs -> HsSplice GhcPs
mkHsQuasiQuote :: RdrName -> SrcSpan -> FastString -> HsSplice GhcPs

-- | Should we treat this as an unlifted bind? This will be true for any
--   bind that binds an unlifted variable, but we must be careful around
--   AbsBinds. See Note [Unlifted id check in isUnliftedHsBind]. For usage
--   information, see Note [Strict binds checks] is GHC.HsToCore.Binds.
isUnliftedHsBind :: HsBind GhcTc -> Bool

-- | Is a binding a strict variable or pattern bind (e.g. <tt>!x =
--   ...</tt>)?
isBangedHsBind :: HsBind GhcTc -> Bool
collectLocalBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> HsLocalBindsLR (GhcPass idL) (GhcPass idR) -> [IdP (GhcPass idL)]
collectHsValBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> HsValBindsLR (GhcPass idL) (GhcPass idR) -> [IdP (GhcPass idL)]

-- | Same as <a>collectHsBindsBinders</a>, but works over a list of
--   bindings
collectHsBindListBinders :: forall p idR. CollectPass p => CollectFlag p -> [LHsBindLR p idR] -> [IdP p]

-- | Collect <a>Id</a> binders only, or <a>Id</a>s + pattern synonyms,
--   respectively
collectHsIdBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> HsValBindsLR (GhcPass idL) (GhcPass idR) -> [IdP (GhcPass idL)]
collectHsBindsBinders :: CollectPass p => CollectFlag p -> LHsBindsLR p idR -> [IdP p]

-- | Collect both <a>Id</a>s and pattern-synonym binders
collectHsBindBinders :: CollectPass p => CollectFlag p -> HsBindLR p idR -> [IdP p]

-- | Used exclusively for the bindings of an instance decl which are all
--   <tt>FunBinds</tt>
collectMethodBinders :: forall idL idR. UnXRec idL => LHsBindsLR idL idR -> [LIdP idL]
collectPatBinders :: CollectPass p => CollectFlag p -> LPat p -> [IdP p]
collectPatsBinders :: CollectPass p => CollectFlag p -> [LPat p] -> [IdP p]
collectLStmtsBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> [LStmtLR (GhcPass idL) (GhcPass idR) body] -> [IdP (GhcPass idL)]
collectStmtsBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> [StmtLR (GhcPass idL) (GhcPass idR) body] -> [IdP (GhcPass idL)]
collectLStmtBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> LStmtLR (GhcPass idL) (GhcPass idR) body -> [IdP (GhcPass idL)]
collectStmtBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> StmtLR (GhcPass idL) (GhcPass idR) body -> [IdP (GhcPass idL)]

-- | This class specifies how to collect variable identifiers from
--   extension patterns in the given pass. Consumers of the GHC API that
--   define their own passes should feel free to implement instances in
--   order to make use of functions which depend on it.
--   
--   In particular, Haddock already makes use of this, with an instance for
--   its <tt>DocNameI</tt> pass so that it can reuse the code in GHC for
--   collecting binders.
class UnXRec p => CollectPass p
collectXXPat :: CollectPass p => Proxy p -> CollectFlag p -> XXPat p -> [IdP p] -> [IdP p]

-- | Indicate if evidence binders have to be collected.
--   
--   This type is used as a boolean (should we collect evidence binders or
--   not?) but also to pass an evidence that the AST has been typechecked
--   when we do want to collect evidence binders, otherwise these binders
--   are not available.
--   
--   See Note [Dictionary binders in ConPatOut]
data CollectFlag p

-- | Don't collect evidence binders
[CollNoDictBinders] :: CollectFlag p

-- | Collect evidence binders
[CollWithDictBinders] :: CollectFlag GhcTc

-- | Returns all the <i>binding</i> names of the decl. The first one is
--   guaranteed to be the name of the decl. The first component represents
--   all binding names except record fields; the second represents field
--   occurrences. For record fields mentioned in multiple constructors, the
--   SrcLoc will be from the first occurrence.
--   
--   Each returned (Located name) has a SrcSpan for the <i>whole</i>
--   declaration. See Note [SrcSpan for binders]
hsLTyClDeclBinders :: IsPass p => LocatedA (TyClDecl (GhcPass p)) -> ([LocatedA (IdP (GhcPass p))], [LFieldOcc (GhcPass p)])
hsTyClForeignBinders :: [TyClGroup GhcRn] -> [LForeignDecl GhcRn] -> [Name]

-- | Collects record pattern-synonym selectors only; the pattern synonym
--   names are collected by <a>collectHsValBinders</a>.
hsPatSynSelectors :: IsPass p => HsValBinds (GhcPass p) -> [FieldOcc (GhcPass p)]
getPatSynBinds :: forall id. UnXRec id => [(RecFlag, LHsBinds id)] -> [PatSynBind id id]

-- | See Note [SrcSpan for binders]
hsForeignDeclsBinders :: forall p a. (UnXRec (GhcPass p), IsSrcSpanAnn p a) => [LForeignDecl (GhcPass p)] -> [LIdP (GhcPass p)]
hsGroupBinders :: HsGroup GhcRn -> [Name]

-- | the <a>SrcLoc</a> returned are for the whole declarations, not just
--   the names
hsDataFamInstBinders :: IsPass p => DataFamInstDecl (GhcPass p) -> ([LocatedA (IdP (GhcPass p))], [LFieldOcc (GhcPass p)])
lStmtsImplicits :: [LStmtLR GhcRn (GhcPass idR) (LocatedA (body (GhcPass idR)))] -> [(SrcSpan, [Name])]
hsValBindsImplicits :: HsValBindsLR GhcRn (GhcPass idR) -> [(SrcSpan, [Name])]
lPatImplicits :: LPat GhcRn -> [(SrcSpan, [Name])]
instance GHC.Hs.Extension.IsPass p => GHC.Hs.Utils.CollectPass (GHC.Hs.Extension.GhcPass p)

module GHC.Tc.Types.Evidence
data HsWrapper
WpHole :: HsWrapper
WpCompose :: HsWrapper -> HsWrapper -> HsWrapper
WpFun :: HsWrapper -> HsWrapper -> Scaled TcType -> SDoc -> HsWrapper
WpCast :: TcCoercionR -> HsWrapper
WpEvLam :: EvVar -> HsWrapper
WpEvApp :: EvTerm -> HsWrapper
WpTyLam :: TyVar -> HsWrapper
WpTyApp :: KindOrType -> HsWrapper
WpLet :: TcEvBinds -> HsWrapper
WpMultCoercion :: Coercion -> HsWrapper
(<.>) :: HsWrapper -> HsWrapper -> HsWrapper
mkWpTyApps :: [Type] -> HsWrapper
mkWpEvApps :: [EvTerm] -> HsWrapper
mkWpEvVarApps :: [EvVar] -> HsWrapper
mkWpTyLams :: [TyVar] -> HsWrapper
mkWpLams :: [Var] -> HsWrapper
mkWpLet :: TcEvBinds -> HsWrapper
mkWpCastN :: TcCoercionN -> HsWrapper
mkWpCastR :: TcCoercionR -> HsWrapper
collectHsWrapBinders :: HsWrapper -> ([Var], HsWrapper)
mkWpFun :: HsWrapper -> HsWrapper -> Scaled TcType -> TcType -> SDoc -> HsWrapper
idHsWrapper :: HsWrapper
isIdHsWrapper :: HsWrapper -> Bool
pprHsWrapper :: HsWrapper -> (Bool -> SDoc) -> SDoc

-- | Identifies the <i>lambda-bound</i> dictionaries of an
--   <a>HsWrapper</a>. This is used (only) to allow the pattern-match
--   overlap checker to know what Given dictionaries are in scope.
--   
--   We specifically do not collect dictionaries bound in a <a>WpLet</a>.
--   These are either superclasses of lambda-bound ones, or (extremely
--   numerous) results of binding Wanted dictionaries. We definitely don't
--   want all those cluttering up the Given dictionaries for pattern-match
--   overlap checking!
hsWrapDictBinders :: HsWrapper -> Bag DictId
data TcEvBinds
TcEvBinds :: EvBindsVar -> TcEvBinds
EvBinds :: Bag EvBind -> TcEvBinds
data EvBindsVar
EvBindsVar :: Unique -> IORef EvBindMap -> IORef CoVarSet -> EvBindsVar
[ebv_uniq] :: EvBindsVar -> Unique
[ebv_binds] :: EvBindsVar -> IORef EvBindMap
[ebv_tcvs] :: EvBindsVar -> IORef CoVarSet
CoEvBindsVar :: Unique -> IORef CoVarSet -> EvBindsVar
[ebv_uniq] :: EvBindsVar -> Unique
[ebv_tcvs] :: EvBindsVar -> IORef CoVarSet
newtype EvBindMap
EvBindMap :: DVarEnv EvBind -> EvBindMap
[ev_bind_varenv] :: EvBindMap -> DVarEnv EvBind
emptyEvBindMap :: EvBindMap
extendEvBinds :: EvBindMap -> EvBind -> EvBindMap
lookupEvBind :: EvBindMap -> EvVar -> Maybe EvBind
evBindMapBinds :: EvBindMap -> Bag EvBind
foldEvBindMap :: (EvBind -> a -> a) -> a -> EvBindMap -> a
nonDetStrictFoldEvBindMap :: (EvBind -> a -> a) -> a -> EvBindMap -> a
filterEvBindMap :: (EvBind -> Bool) -> EvBindMap -> EvBindMap
isEmptyEvBindMap :: EvBindMap -> Bool
evBindMapToVarSet :: EvBindMap -> VarSet
varSetMinusEvBindMap :: VarSet -> EvBindMap -> VarSet
data EvBind
EvBind :: EvVar -> EvTerm -> Bool -> EvBind
[eb_lhs] :: EvBind -> EvVar
[eb_rhs] :: EvBind -> EvTerm
[eb_is_given] :: EvBind -> Bool
emptyTcEvBinds :: TcEvBinds
isEmptyTcEvBinds :: TcEvBinds -> Bool
mkGivenEvBind :: EvVar -> EvTerm -> EvBind
mkWantedEvBind :: EvVar -> EvTerm -> EvBind
evBindVar :: EvBind -> EvVar
isCoEvBindsVar :: EvBindsVar -> Bool
data EvTerm
EvExpr :: EvExpr -> EvTerm
EvTypeable :: Type -> EvTypeable -> EvTerm
EvFun :: [TyVar] -> [EvVar] -> TcEvBinds -> EvVar -> EvTerm
[et_tvs] :: EvTerm -> [TyVar]
[et_given] :: EvTerm -> [EvVar]
[et_binds] :: EvTerm -> TcEvBinds
[et_body] :: EvTerm -> EvVar
type EvExpr = CoreExpr

-- | Any sort of evidence Id, including coercions
evId :: EvId -> EvExpr
evCoercion :: TcCoercion -> EvTerm

-- | d |&gt; co
evCast :: EvExpr -> TcCoercion -> EvTerm
evDFunApp :: DFunId -> [Type] -> [EvExpr] -> EvTerm
evDataConApp :: DataCon -> [Type] -> [EvExpr] -> EvTerm
evSelector :: Id -> [Type] -> [EvExpr] -> EvExpr
mkEvCast :: EvExpr -> TcCoercion -> EvTerm
evVarsOfTerm :: EvTerm -> VarSet
mkEvScSelectors :: Class -> [TcType] -> [(TcPredType, EvExpr)]
evTypeable :: Type -> EvTypeable -> EvTerm
findNeededEvVars :: EvBindMap -> VarSet -> VarSet
evTermCoercion :: EvTerm -> TcCoercion
evTermCoercion_maybe :: EvTerm -> Maybe TcCoercion

-- | Evidence for <tt>CallStack</tt> implicit parameters.
data EvCallStack
EvCsEmpty :: EvCallStack

-- | <tt>EvCsPushCall name loc stk</tt> represents a call to <tt>name</tt>,
--   occurring at <tt>loc</tt>, in a calling context <tt>stk</tt>.
EvCsPushCall :: Name -> RealSrcSpan -> EvExpr -> EvCallStack

-- | Instructions on how to make a <tt>Typeable</tt> dictionary. See Note
--   [Typeable evidence terms]
data EvTypeable

-- | Dictionary for <tt>Typeable T</tt> where <tt>T</tt> is a type
--   constructor with all of its kind variables saturated. The
--   <tt>[EvTerm]</tt> is <tt>Typeable</tt> evidence for the applied
--   kinds..
EvTypeableTyCon :: TyCon -> [EvTerm] -> EvTypeable

-- | Dictionary for <tt>Typeable (s t)</tt>, given a dictionaries for
--   <tt>s</tt> and <tt>t</tt>.
EvTypeableTyApp :: EvTerm -> EvTerm -> EvTypeable

-- | Dictionary for <tt>Typeable (s # w -&gt; t)</tt>, given a dictionaries
--   for <tt>w</tt>, <tt>s</tt>, and <tt>t</tt>.
EvTypeableTrFun :: EvTerm -> EvTerm -> EvTerm -> EvTypeable

-- | Dictionary for a type literal, e.g. <tt>Typeable "foo"</tt> or
--   <tt>Typeable 3</tt> The <a>EvTerm</a> is evidence of, e.g.,
--   <tt>KnownNat 3</tt> (see #10348)
EvTypeableTyLit :: EvTerm -> EvTypeable

-- | Where to store evidence for expression holes See Note [Holes] in
--   GHC.Tc.Types.Constraint
data HoleExprRef
HER :: IORef EvTerm -> TcType -> Unique -> HoleExprRef
type TcCoercion = Coercion
type TcCoercionR = CoercionR
type TcCoercionN = CoercionN
type TcCoercionP = CoercionP

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
type TcMCoercion = MCoercion
type TcMCoercionN = MCoercionN
type TcMCoercionR = MCoercionR
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight
pickLR :: LeftOrRight -> (a, a) -> a
mkTcReflCo :: Role -> TcType -> TcCoercion
mkTcNomReflCo :: TcType -> TcCoercionN
mkTcRepReflCo :: TcType -> TcCoercionR
mkTcTyConAppCo :: Role -> TyCon -> [TcCoercion] -> TcCoercion
mkTcAppCo :: TcCoercion -> TcCoercionN -> TcCoercion
mkTcFunCo :: Role -> TcCoercion -> TcCoercion -> TcCoercion -> TcCoercion
mkTcAxInstCo :: Role -> CoAxiom br -> BranchIndex -> [TcType] -> [TcCoercion] -> TcCoercion
mkTcUnbranchedAxInstCo :: CoAxiom Unbranched -> [TcType] -> [TcCoercion] -> TcCoercionR
mkTcForAllCo :: TyVar -> TcCoercionN -> TcCoercion -> TcCoercion
mkTcForAllCos :: [(TyVar, TcCoercionN)] -> TcCoercion -> TcCoercion
mkTcSymCo :: TcCoercion -> TcCoercion
mkTcSymMCo :: TcMCoercion -> TcMCoercion
mkTcTransCo :: TcCoercion -> TcCoercion -> TcCoercion
mkTcNthCo :: Role -> Int -> TcCoercion -> TcCoercion
mkTcLRCo :: LeftOrRight -> TcCoercion -> TcCoercion
mkTcSubCo :: HasDebugCallStack => TcCoercionN -> TcCoercionR

-- | If a <a>SwapFlag</a> is <a>IsSwapped</a>, flip the orientation of a
--   coercion
maybeTcSymCo :: SwapFlag -> TcCoercion -> TcCoercion

-- | If the EqRel is ReprEq, makes a SubCo; otherwise, does nothing. Note
--   that the input coercion should always be nominal.
maybeTcSubCo :: HasDebugCallStack => EqRel -> TcCoercionN -> TcCoercion
tcDowngradeRole :: Role -> Role -> TcCoercion -> TcCoercion
mkTcAxiomRuleCo :: CoAxiomRule -> [TcCoercion] -> TcCoercionR
mkTcGReflRightCo :: Role -> TcType -> TcCoercionN -> TcCoercion
mkTcGReflRightMCo :: Role -> TcType -> TcMCoercionN -> TcCoercion
mkTcGReflLeftCo :: Role -> TcType -> TcCoercionN -> TcCoercion
mkTcGReflLeftMCo :: Role -> TcType -> TcMCoercionN -> TcCoercion
mkTcPhantomCo :: TcCoercionN -> TcType -> TcType -> TcCoercionP
mkTcCoherenceLeftCo :: Role -> TcType -> TcCoercionN -> TcCoercion -> TcCoercion
mkTcCoherenceRightCo :: Role -> TcType -> TcCoercionN -> TcCoercion -> TcCoercion
mkTcKindCo :: TcCoercion -> TcCoercionN
tcCoercionKind :: TcCoercion -> Pair TcType
mkTcCoVarCo :: CoVar -> TcCoercion
mkTcFamilyTyConAppCo :: TyCon -> [TcCoercionN] -> TcCoercionN
isTcReflCo :: TcCoercion -> Bool

-- | This version does a slow check, calculating the related types and
--   seeing if they are equal.
isTcReflexiveCo :: TcCoercion -> Bool
tcCoercionRole :: TcCoercion -> Role

-- | Create a <a>Expr</a> that unwraps an implicit-parameter or
--   overloaded-label dictionary to expose the underlying value. We expect
--   the <a>Expr</a> to have the form `IP sym ty` or `IsLabel sym ty`, and
--   return a <a>Expr</a> `co :: IP sym ty ~ ty` or `co :: IsLabel sym ty ~
--   ty`. See also Note [Type-checking overloaded labels] in
--   <a>GHC.Tc.Gen.Expr</a>.
unwrapIP :: Type -> CoercionR

-- | Create a <a>Expr</a> that wraps a value in an implicit-parameter
--   dictionary. See <a>unwrapIP</a>.
wrapIP :: Type -> CoercionR
data QuoteWrapper
QuoteWrapper :: EvVar -> Type -> QuoteWrapper

-- | Convert the QuoteWrapper into a normal HsWrapper which can be used to
--   apply its contents.
applyQuoteWrapper :: QuoteWrapper -> HsWrapper
quoteWrapperTyVarTy :: QuoteWrapper -> Type
instance Data.Data.Data GHC.Tc.Types.Evidence.EvTerm
instance Data.Data.Data GHC.Tc.Types.Evidence.EvTypeable
instance Data.Data.Data GHC.Tc.Types.Evidence.EvCallStack
instance Data.Data.Data GHC.Tc.Types.Evidence.QuoteWrapper
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.HoleExprRef
instance Data.Data.Data GHC.Tc.Types.Evidence.HoleExprRef
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvCallStack
instance Data.Data.Data GHC.Tc.Types.Evidence.HsWrapper
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.HsWrapper
instance Data.Data.Data GHC.Tc.Types.Evidence.TcEvBinds
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvBindMap
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.TcEvBinds
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvBindsVar
instance GHC.Types.Unique.Uniquable GHC.Tc.Types.Evidence.EvBindsVar
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvBind
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvTerm
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvTypeable

module GHC.Hs.Type

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type

-- | This is used in the syntax. In constructor declaration. It must keep
--   the arrow representation.
data HsScaled pass a
HsScaled :: HsArrow pass -> a -> HsScaled pass a
hsMult :: HsScaled pass a -> HsArrow pass
hsScaledThing :: HsScaled pass a -> a

-- | Denotes the type of arrows in the surface language
data HsArrow pass

-- | a -&gt; b or a â b
HsUnrestrictedArrow :: IsUnicodeSyntax -> HsArrow pass

-- | a %1 -&gt; b or a %1 â b, or a â¸ b
HsLinearArrow :: IsUnicodeSyntax -> Maybe AddEpAnn -> HsArrow pass

-- | a %m -&gt; b or a %m â b (very much including `a %Many -&gt; b`! This
--   is how the programmer wrote it). It is stored as an <a>HsType</a> so
--   as to preserve the syntax as written in the program.
HsExplicitMult :: IsUnicodeSyntax -> Maybe AddEpAnn -> LHsType pass -> HsArrow pass

-- | Convert an arrow into its corresponding multiplicity. In essence this
--   erases the information of whether the programmer wrote an explicit
--   multiplicity or a shorthand.
arrowToHsType :: HsArrow GhcRn -> LHsType GhcRn

-- | When creating syntax we use the shorthands. It's better for printing,
--   also, the shorthands work trivially at each pass.
hsLinear :: a -> HsScaled pass a

-- | When creating syntax we use the shorthands. It's better for printing,
--   also, the shorthands work trivially at each pass.
hsUnrestricted :: a -> HsScaled pass a
isUnrestricted :: HsArrow GhcRn -> Bool

-- | Haskell Type
data HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnForall</a>,
--   <a>AnnDot</a>,<a>AnnDarrow</a> For details on above see note [exact
--   print annotations] in <a>GHC.Parser.Annotation</a></li>
--   </ul>
HsForAllTy :: XForAllTy pass -> HsForAllTelescope pass -> LHsType pass -> HsType pass
[hst_xforall] :: HsType pass -> XForAllTy pass
[hst_tele] :: HsType pass -> HsForAllTelescope pass
[hst_body] :: HsType pass -> LHsType pass
HsQualTy :: XQualTy pass -> Maybe (LHsContext pass) -> LHsType pass -> HsType pass
[hst_xqual] :: HsType pass -> XQualTy pass
[hst_ctxt] :: HsType pass -> Maybe (LHsContext pass)
[hst_body] :: HsType pass -> LHsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsTyVar :: XTyVar pass -> PromotionFlag -> LIdP pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsAppTy :: XAppTy pass -> LHsType pass -> LHsType pass -> HsType pass
HsAppKindTy :: XAppKindTy pass -> LHsType pass -> LHsKind pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a>,</li>
--   </ul>
HsFunTy :: XFunTy pass -> HsArrow pass -> LHsType pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>, <a>AnnClose</a>
--   <tt>']'</tt></li>
--   </ul>
HsListTy :: XListTy pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(' or '(#'</tt>,
--   <a>AnnClose</a> <tt>')' or '#)'</tt></li>
--   </ul>
HsTupleTy :: XTupleTy pass -> HsTupleSort -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(#'</tt>,
--   <a>AnnClose</a> '#)'@</li>
--   </ul>
HsSumTy :: XSumTy pass -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsOpTy :: XOpTy pass -> LHsType pass -> LIdP pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>, <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
HsParTy :: XParTy pass -> LHsType pass -> HsType pass

-- | <pre>
--   (?x :: ty)
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
HsIParamTy :: XIParamTy pass -> XRec pass HsIPName -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsStarTy :: XStarTy pass -> Bool -> HsType pass

-- | <pre>
--   (ty :: kind)
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>,
--   <a>AnnDcolon</a>,<a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsKindSig :: XKindSig pass -> LHsType pass -> LHsKind pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'$('</tt>,
--   <a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsSpliceTy :: XSpliceTy pass -> HsSplice pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsDocTy :: XDocTy pass -> LHsType pass -> LHsDocString -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# UNPACK' or '{-#
--   NOUNPACK'</tt>, <a>AnnClose</a> <tt>'#-}'</tt> <a>AnnBang</a>
--   <tt>'!'</tt></li>
--   </ul>
HsBangTy :: XBangTy pass -> HsSrcBang -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{'</tt>, <a>AnnClose</a>
--   <tt>'}'</tt></li>
--   </ul>
HsRecTy :: XRecTy pass -> [LConDeclField pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>"'["</tt>,
--   <a>AnnClose</a> <tt>']'</tt></li>
--   </ul>
HsExplicitListTy :: XExplicitListTy pass -> PromotionFlag -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>"'("</tt>,
--   <a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsExplicitTupleTy :: XExplicitTupleTy pass -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsTyLit :: XTyLit pass -> HsTyLit -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsWildCardTy :: XWildCardTy pass -> HsType pass
XHsType :: !XXType pass -> HsType pass
type HsCoreTy = Type

-- | Located Haskell Type
type LHsType pass = XRec pass (HsType pass) " May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when in a list"

-- | Haskell Kind
type HsKind pass = HsType pass

-- | Located Haskell Kind
type LHsKind pass = XRec pass (HsKind pass) " 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon'"

-- | The type variable binders in an <a>HsForAllTy</a>. See also <tt>Note
--   [Variable Specificity and Forall Visibility]</tt> in
--   <a>GHC.Tc.Gen.HsType</a>.
data HsForAllTelescope pass

-- | A visible <tt>forall</tt> (e.g., <tt>forall a -&gt; {...}</tt>). These
--   do not have any notion of specificity, so we use <tt>()</tt> as a
--   placeholder value.
HsForAllVis :: XHsForAllVis pass -> [LHsTyVarBndr () pass] -> HsForAllTelescope pass
[hsf_xvis] :: HsForAllTelescope pass -> XHsForAllVis pass
[hsf_vis_bndrs] :: HsForAllTelescope pass -> [LHsTyVarBndr () pass]

-- | An invisible <tt>forall</tt> (e.g., <tt>forall a {b} c. {...}</tt>),
--   where each binder has a <a>Specificity</a>.
HsForAllInvis :: XHsForAllInvis pass -> [LHsTyVarBndr Specificity pass] -> HsForAllTelescope pass
[hsf_xinvis] :: HsForAllTelescope pass -> XHsForAllInvis pass
[hsf_invis_bndrs] :: HsForAllTelescope pass -> [LHsTyVarBndr Specificity pass]
XHsForAllTelescope :: !XXHsForAllTelescope pass -> HsForAllTelescope pass
type EpAnnForallTy = EpAnn (AddEpAnn, AddEpAnn) " Location of 'forall' and '->' for HsForAllVis Location of 'forall' and '.' for HsForAllInvis"

-- | Haskell Type Variable Binder The flag annotates the binder. It is
--   <a>Specificity</a> in places where explicit specificity is allowed
--   (e.g. x :: forall {a} b. ...) or <tt>()</tt> in other places.
data HsTyVarBndr flag pass
UserTyVar :: XUserTyVar pass -> flag -> LIdP pass -> HsTyVarBndr flag pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnDcolon</a>,
--   <a>AnnClose</a></li>
--   </ul>
KindedTyVar :: XKindedTyVar pass -> flag -> LIdP pass -> LHsKind pass -> HsTyVarBndr flag pass
XTyVarBndr :: !XXTyVarBndr pass -> HsTyVarBndr flag pass

-- | Located Haskell Type Variable Binder
type LHsTyVarBndr flag pass = XRec pass (HsTyVarBndr flag pass)

-- | Located Haskell Quantified Type Variables
data LHsQTyVars pass
HsQTvs :: XHsQTvs pass -> [LHsTyVarBndr () pass] -> LHsQTyVars pass
[hsq_ext] :: LHsQTyVars pass -> XHsQTvs pass
[hsq_explicit] :: LHsQTyVars pass -> [LHsTyVarBndr () pass]
XLHsQTyVars :: !XXLHsQTyVars pass -> LHsQTyVars pass

-- | The outermost type variables in a type that obeys the
--   <tt>forall</tt>-or-nothing rule. See <tt>Note [forall-or-nothing
--   rule]</tt>.
data HsOuterTyVarBndrs flag pass

-- | Implicit forall, e.g., <tt>f :: a -&gt; b -&gt; b</tt>
HsOuterImplicit :: XHsOuterImplicit pass -> HsOuterTyVarBndrs flag pass
[hso_ximplicit] :: HsOuterTyVarBndrs flag pass -> XHsOuterImplicit pass

-- | Explicit forall, e.g., <tt>f :: forall a b. a -&gt; b -&gt; b</tt>
HsOuterExplicit :: XHsOuterExplicit pass flag -> [LHsTyVarBndr flag (NoGhcTc pass)] -> HsOuterTyVarBndrs flag pass
[hso_xexplicit] :: HsOuterTyVarBndrs flag pass -> XHsOuterExplicit pass flag
[hso_bndrs] :: HsOuterTyVarBndrs flag pass -> [LHsTyVarBndr flag (NoGhcTc pass)]
XHsOuterTyVarBndrs :: !XXHsOuterTyVarBndrs pass -> HsOuterTyVarBndrs flag pass

-- | Used for type-family instance equations, e.g.,
--   
--   <pre>
--   type instance forall a. F [a] = Tree a
--   </pre>
--   
--   The notion of specificity is irrelevant in type family equations, so
--   we use <tt>()</tt> for the <a>HsOuterTyVarBndrs</a> <tt>flag</tt>.
type HsOuterFamEqnTyVarBndrs = HsOuterTyVarBndrs ()

-- | Used for signatures, e.g.,
--   
--   <pre>
--   f :: forall a {b}. blah
--   </pre>
--   
--   We use <a>Specificity</a> for the <a>HsOuterTyVarBndrs</a>
--   <tt>flag</tt> to allow distinguishing between specified and inferred
--   type variables.
type HsOuterSigTyVarBndrs = HsOuterTyVarBndrs Specificity

-- | Haskell Wildcard Binders
data HsWildCardBndrs pass thing
HsWC :: XHsWC pass thing -> thing -> HsWildCardBndrs pass thing
[hswc_ext] :: HsWildCardBndrs pass thing -> XHsWC pass thing
[hswc_body] :: HsWildCardBndrs pass thing -> thing
XHsWildCardBndrs :: !XXHsWildCardBndrs pass thing -> HsWildCardBndrs pass thing

-- | Types that can appear in pattern signatures, as well as the signatures
--   for term-level binders in RULES. See <tt>Note [Pattern signature
--   binders and scoping]</tt>.
--   
--   This is very similar to <tt>HsSigWcType</tt>, but with slightly
--   different semantics: see <tt>Note [HsType binders]</tt>. See also
--   <tt>Note [The wildcard story for types]</tt>.
data HsPatSigType pass
HsPS :: XHsPS pass -> LHsType pass -> HsPatSigType pass

-- | After renamer: <a>HsPSRn</a>
[hsps_ext] :: HsPatSigType pass -> XHsPS pass

-- | Main payload (the type itself)
[hsps_body] :: HsPatSigType pass -> LHsType pass
XHsPatSigType :: !XXHsPatSigType pass -> HsPatSigType pass

-- | The extension field for <a>HsPatSigType</a>, which is only used in the
--   renamer onwards. See <tt>Note [Pattern signature binders and
--   scoping]</tt>.
data HsPSRn
HsPSRn :: [Name] -> [Name] -> HsPSRn

-- | Wildcard names
[hsps_nwcs] :: HsPSRn -> [Name]

-- | Implicitly bound variable names
[hsps_imp_tvs] :: HsPSRn -> [Name]

-- | A type signature that obeys the <tt>forall</tt>-or-nothing rule. In
--   other words, an <a>LHsType</a> that uses an
--   <a>HsOuterSigTyVarBndrs</a> to represent its outermost type variable
--   quantification. See <tt>Note [Representing type signatures]</tt>.
data HsSigType pass
HsSig :: XHsSig pass -> HsOuterSigTyVarBndrs pass -> LHsType pass -> HsSigType pass
[sig_ext] :: HsSigType pass -> XHsSig pass
[sig_bndrs] :: HsSigType pass -> HsOuterSigTyVarBndrs pass
[sig_body] :: HsSigType pass -> LHsType pass
XHsSigType :: !XXHsSigType pass -> HsSigType pass

-- | Located Haskell Signature Type
type LHsSigType pass = XRec pass (HsSigType pass)

-- | Located Haskell Signature Wildcard Type
type LHsSigWcType pass = HsWildCardBndrs pass (LHsSigType pass)

-- | Located Haskell Wildcard Type
type LHsWcType pass = HsWildCardBndrs pass (LHsType pass)

-- | Haskell Tuple Sort
data HsTupleSort
HsUnboxedTuple :: HsTupleSort
HsBoxedOrConstraintTuple :: HsTupleSort

-- | Haskell Context
type HsContext pass = [LHsType pass]

-- | Located Haskell Context
type LHsContext pass = XRec pass (HsContext pass) " 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnUnit' For details on above see note [exact print annotations] in GHC.Parser.Annotation"
fromMaybeContext :: Maybe (LHsContext (GhcPass p)) -> HsContext (GhcPass p)

-- | Haskell Type Literal
data HsTyLit
HsNumTy :: SourceText -> Integer -> HsTyLit
HsStrTy :: SourceText -> FastString -> HsTyLit
HsCharTy :: SourceText -> Char -> HsTyLit

-- | These names are used early on to store the names of implicit
--   parameters. They completely disappear after type-checking.
newtype HsIPName
HsIPName :: FastString -> HsIPName
hsIPNameFS :: HsIPName -> FastString
data HsArg tm ty
HsValArg :: tm -> HsArg tm ty
HsTypeArg :: SrcSpan -> ty -> HsArg tm ty
HsArgPar :: SrcSpan -> HsArg tm ty
numVisibleArgs :: [HsArg tm ty] -> Arity
type LHsTypeArg p = HsArg (LHsType p) (LHsKind p)

-- | Compute the <a>SrcSpan</a> associated with an <a>LHsTypeArg</a>.
lhsTypeArgSrcSpan :: LHsTypeArg (GhcPass pass) -> SrcSpan
class OutputableBndrFlag flag p

-- | Located Bang Type
type LBangType pass = XRec pass (BangType pass)

-- | Bang Type
--   
--   In the parser, strictness and packedness annotations bind more tightly
--   than docstrings. This means that when consuming a <a>BangType</a> (and
--   looking for <a>HsBangTy</a>) we must be ready to peer behind a
--   potential layer of <a>HsDocTy</a>. See #15206 for motivation and
--   <tt>getBangType</tt> for an example.
type BangType pass = HsType pass

-- | Haskell Source Bang
--   
--   Bangs on data constructor arguments as the user wrote them in the
--   source code.
--   
--   <tt>(HsSrcBang _ SrcUnpack SrcLazy)</tt> and <tt>(HsSrcBang _
--   SrcUnpack NoSrcStrict)</tt> (without StrictData) makes no sense, we
--   emit a warning (in checkValidDataCon) and treat it like <tt>(HsSrcBang
--   _ NoSrcUnpack SrcLazy)</tt>
data HsSrcBang
HsSrcBang :: SourceText -> SrcUnpackedness -> SrcStrictness -> HsSrcBang

-- | Haskell Implementation Bang
--   
--   Bangs of data constructor arguments as generated by the compiler after
--   consulting HsSrcBang, flags, etc.
data HsImplBang

-- | Lazy field, or one with an unlifted type
HsLazy :: HsImplBang

-- | Strict but not unpacked field
HsStrict :: HsImplBang

-- | Strict and unpacked field co :: arg-ty ~ product-ty HsBang
HsUnpack :: Maybe Coercion -> HsImplBang

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie <tt>~</tt>
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {-# UNPACK #-} specified
SrcUnpack :: SrcUnpackedness

-- | {-# NOUNPACK #-} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness
getBangType :: LHsType (GhcPass p) -> LHsType (GhcPass p)
getBangStrictness :: LHsType (GhcPass p) -> HsSrcBang

-- | Constructor Declaration Field
data ConDeclField pass
ConDeclField :: XConDeclField pass -> [LFieldOcc pass] -> LBangType pass -> Maybe LHsDocString -> ConDeclField pass
[cd_fld_ext] :: ConDeclField pass -> XConDeclField pass

-- | See Note [ConDeclField passs]
[cd_fld_names] :: ConDeclField pass -> [LFieldOcc pass]
[cd_fld_type] :: ConDeclField pass -> LBangType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
[cd_fld_doc] :: ConDeclField pass -> Maybe LHsDocString
XConDeclField :: !XXConDeclField pass -> ConDeclField pass

-- | Located Constructor Declaration Field
type LConDeclField pass = XRec pass (ConDeclField pass) " May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when in a list"
pprConDeclFields :: OutputableBndrId p => [LConDeclField (GhcPass p)] -> SDoc

-- | Describes the arguments to a data constructor. This is a common
--   representation for several constructor-related concepts, including:
--   
--   <ul>
--   <li>The arguments in a Haskell98-style constructor declaration (see
--   <tt>HsConDeclH98Details</tt> in <a>GHC.Hs.Decls</a>).</li>
--   <li>The arguments in constructor patterns in <tt>case</tt>/function
--   definitions (see <tt>HsConPatDetails</tt> in <a>GHC.Hs.Pat</a>).</li>
--   <li>The left-hand side arguments in a pattern synonym binding (see
--   <tt>HsPatSynDetails</tt> in <a>GHC.Hs.Binds</a>).</li>
--   </ul>
--   
--   One notable exception is the arguments in a GADT constructor, which
--   uses a separate data type entirely (see <tt>HsConDeclGADTDetails</tt>
--   in <a>GHC.Hs.Decls</a>). This is because GADT constructors cannot be
--   declared with infix syntax, unlike the concepts above (#18844).
data HsConDetails tyarg arg rec
PrefixCon :: [tyarg] -> [arg] -> HsConDetails tyarg arg rec
RecCon :: rec -> HsConDetails tyarg arg rec
InfixCon :: arg -> arg -> HsConDetails tyarg arg rec

-- | An empty list that can be used to indicate that there are no type
--   arguments allowed in cases where HsConDetails is applied to Void.
noTypeArgs :: [Void]

-- | Field Occurrence
--   
--   Represents an *occurrence* of an unambiguous field. This may or may
--   not be a binding occurrence (e.g. this type is used in
--   <a>ConDeclField</a> and <tt>RecordPatSynField</tt> which bind their
--   fields, but also in <tt>HsRecField</tt> for record construction and
--   patterns, which do not).
--   
--   We store both the <a>RdrName</a> the user originally wrote, and after
--   the renamer, the selector function.
data FieldOcc pass
FieldOcc :: XCFieldOcc pass -> LocatedN RdrName -> FieldOcc pass
[extFieldOcc] :: FieldOcc pass -> XCFieldOcc pass

-- | See Note [Located RdrNames] in <a>GHC.Hs.Expr</a>
[rdrNameFieldOcc] :: FieldOcc pass -> LocatedN RdrName
XFieldOcc :: !XXFieldOcc pass -> FieldOcc pass

-- | Located Field Occurrence
type LFieldOcc pass = XRec pass (FieldOcc pass)
mkFieldOcc :: LocatedN RdrName -> FieldOcc GhcPs

-- | Ambiguous Field Occurrence
--   
--   Represents an *occurrence* of a field that is potentially ambiguous
--   after the renamer, with the ambiguity resolved by the typechecker. We
--   always store the <a>RdrName</a> that the user originally wrote, and
--   store the selector function after the renamer (for unambiguous
--   occurrences) or the typechecker (for ambiguous occurrences).
--   
--   See Note [HsRecField and HsRecUpdField] in <a>GHC.Hs.Pat</a> and Note
--   [Disambiguating record fields] in <a>GHC.Tc.Gen.Head</a>. See Note
--   [Located RdrNames] in <a>GHC.Hs.Expr</a>
data AmbiguousFieldOcc pass
Unambiguous :: XUnambiguous pass -> LocatedN RdrName -> AmbiguousFieldOcc pass
Ambiguous :: XAmbiguous pass -> LocatedN RdrName -> AmbiguousFieldOcc pass
XAmbiguousFieldOcc :: !XXAmbiguousFieldOcc pass -> AmbiguousFieldOcc pass
mkAmbiguousFieldOcc :: LocatedN RdrName -> AmbiguousFieldOcc GhcPs
rdrNameAmbiguousFieldOcc :: AmbiguousFieldOcc (GhcPass p) -> RdrName
selectorAmbiguousFieldOcc :: AmbiguousFieldOcc GhcTc -> Id
unambiguousFieldOcc :: AmbiguousFieldOcc GhcTc -> FieldOcc GhcTc
ambiguousFieldOcc :: FieldOcc GhcTc -> AmbiguousFieldOcc GhcTc
mkAnonWildCardTy :: HsType GhcPs
pprAnonWildCard :: SDoc
hsOuterTyVarNames :: HsOuterTyVarBndrs flag GhcRn -> [Name]
hsOuterExplicitBndrs :: HsOuterTyVarBndrs flag (GhcPass p) -> [LHsTyVarBndr flag (NoGhcTc (GhcPass p))]
mapHsOuterImplicit :: (XHsOuterImplicit pass -> XHsOuterImplicit pass) -> HsOuterTyVarBndrs flag pass -> HsOuterTyVarBndrs flag pass
mkHsOuterImplicit :: HsOuterTyVarBndrs flag GhcPs
mkHsOuterExplicit :: EpAnnForallTy -> [LHsTyVarBndr flag GhcPs] -> HsOuterTyVarBndrs flag GhcPs
mkHsImplicitSigType :: LHsType GhcPs -> HsSigType GhcPs
mkHsExplicitSigType :: EpAnnForallTy -> [LHsTyVarBndr Specificity GhcPs] -> LHsType GhcPs -> HsSigType GhcPs
mkHsWildCardBndrs :: thing -> HsWildCardBndrs GhcPs thing
mkHsPatSigType :: EpAnn EpaLocation -> LHsType GhcPs -> HsPatSigType GhcPs
mkEmptyWildCardBndrs :: thing -> HsWildCardBndrs GhcRn thing
mkHsForAllVisTele :: EpAnnForallTy -> [LHsTyVarBndr () (GhcPass p)] -> HsForAllTelescope (GhcPass p)
mkHsForAllInvisTele :: EpAnnForallTy -> [LHsTyVarBndr Specificity (GhcPass p)] -> HsForAllTelescope (GhcPass p)
mkHsQTvs :: [LHsTyVarBndr () GhcPs] -> LHsQTyVars GhcPs
hsQTvExplicit :: LHsQTyVars pass -> [LHsTyVarBndr () pass]
emptyLHsQTvs :: LHsQTyVars GhcRn

-- | Does this <a>HsTyVarBndr</a> come with an explicit kind annotation?
isHsKindedTyVar :: HsTyVarBndr flag pass -> Bool

-- | Do all type variables in this <a>LHsQTyVars</a> come with kind
--   annotations?
hsTvbAllKinded :: LHsQTyVars (GhcPass p) -> Bool
hsScopedTvs :: LHsSigType GhcRn -> [Name]
hsWcScopedTvs :: LHsSigWcType GhcRn -> [Name]
dropWildCards :: LHsSigWcType pass -> LHsSigType pass
hsTyVarName :: HsTyVarBndr flag (GhcPass p) -> IdP (GhcPass p)
hsAllLTyVarNames :: LHsQTyVars GhcRn -> [Name]
hsLTyVarLocNames :: LHsQTyVars (GhcPass p) -> [LocatedN (IdP (GhcPass p))]
hsLTyVarName :: LHsTyVarBndr flag (GhcPass p) -> IdP (GhcPass p)
hsLTyVarNames :: [LHsTyVarBndr flag (GhcPass p)] -> [IdP (GhcPass p)]
hsLTyVarLocName :: LHsTyVarBndr flag (GhcPass p) -> LocatedN (IdP (GhcPass p))
hsExplicitLTyVarNames :: LHsQTyVars (GhcPass p) -> [IdP (GhcPass p)]

-- | Decompose a type class instance type (of the form <tt>forall
--   <a>tvs</a>. context =&gt; instance_head</tt>) into its constituent
--   parts. Note that the <tt>[Name]</tt>s returned correspond to either:
--   
--   <ul>
--   <li>The implicitly bound type variables (if the type lacks an
--   outermost <tt>forall</tt>), or</li>
--   <li>The explicitly bound type variables (if the type has an outermost
--   <tt>forall</tt>).</li>
--   </ul>
--   
--   This function is careful not to look through parentheses. See <tt>Note
--   [No nested foralls or contexts in instance types]</tt> for why this is
--   important.
splitLHsInstDeclTy :: LHsSigType GhcRn -> ([Name], Maybe (LHsContext GhcRn), LHsType GhcRn)

-- | Decompose a type class instance type (of the form <tt>forall
--   <a>tvs</a>. context =&gt; instance_head</tt>) into the
--   <tt>instance_head</tt>.
getLHsInstDeclHead :: LHsSigType (GhcPass p) -> LHsType (GhcPass p)

-- | Decompose a type class instance type (of the form <tt>forall
--   <a>tvs</a>. context =&gt; instance_head</tt>) into the
--   <tt>instance_head</tt> and retrieve the underlying class type
--   constructor (if it exists).
getLHsInstDeclClass_maybe :: Anno (IdGhcP p) ~ SrcSpanAnnN => LHsSigType (GhcPass p) -> Maybe (LocatedN (IdP (GhcPass p)))

-- | Decompose a pattern synonym type signature into its constituent parts.
--   
--   Note that this function looks through parentheses, so it will work on
--   types such as <tt>(forall a. <a>...</a>)</tt>. The downside to this is
--   that it is not generally possible to take the returned types and
--   reconstruct the original type (parentheses and all) from them.
splitLHsPatSynTy :: LHsSigType (GhcPass p) -> ([LHsTyVarBndr Specificity (GhcPass (NoGhcTcPass p))], Maybe (LHsContext (GhcPass p)), [LHsTyVarBndr Specificity (GhcPass p)], Maybe (LHsContext (GhcPass p)), LHsType (GhcPass p))

-- | Decompose a type of the form <tt>forall <a>tvs</a>. body</tt> into its
--   constituent parts. Only splits type variable binders that were
--   quantified invisibly (e.g., <tt>forall a.</tt>, with a dot).
--   
--   This function is used to split apart certain types, such as instance
--   declaration types, which disallow visible <tt>forall</tt>s. For
--   instance, if GHC split apart the <tt>forall</tt> in <tt>instance
--   forall a -&gt; Show (Blah a)</tt>, then that declaration would
--   mistakenly be accepted!
--   
--   Note that this function looks through parentheses, so it will work on
--   types such as <tt>(forall a. <a>...</a>)</tt>. The downside to this is
--   that it is not generally possible to take the returned types and
--   reconstruct the original type (parentheses and all) from them. Unlike
--   <a>splitLHsSigmaTyInvis</a>, this function does not look through
--   parentheses, hence the suffix <tt>_KP</tt> (short for "Keep
--   Parentheses").
splitLHsForAllTyInvis :: LHsType (GhcPass pass) -> ((EpAnnForallTy, [LHsTyVarBndr Specificity (GhcPass pass)]), LHsType (GhcPass pass))

-- | Decompose a type of the form <tt>forall <a>tvs</a>. body</tt> into its
--   constituent parts. Only splits type variable binders that were
--   quantified invisibly (e.g., <tt>forall a.</tt>, with a dot).
--   
--   This function is used to split apart certain types, such as instance
--   declaration types, which disallow visible <tt>forall</tt>s. For
--   instance, if GHC split apart the <tt>forall</tt> in <tt>instance
--   forall a -&gt; Show (Blah a)</tt>, then that declaration would
--   mistakenly be accepted!
--   
--   Unlike <a>splitLHsForAllTyInvis</a>, this function does not look
--   through parentheses, hence the suffix <tt>_KP</tt> (short for "Keep
--   Parentheses").
splitLHsForAllTyInvis_KP :: LHsType (GhcPass pass) -> (Maybe (EpAnnForallTy, [LHsTyVarBndr Specificity (GhcPass pass)]), LHsType (GhcPass pass))

-- | Decompose a type of the form <tt>context =&gt; body</tt> into its
--   constituent parts.
--   
--   Note that this function looks through parentheses, so it will work on
--   types such as <tt>(context =&gt; <a>...</a>)</tt>. The downside to
--   this is that it is not generally possible to take the returned types
--   and reconstruct the original type (parentheses and all) from them.
splitLHsQualTy :: LHsType (GhcPass pass) -> (Maybe (LHsContext (GhcPass pass)), LHsType (GhcPass pass))

-- | Decompose a sigma type (of the form <tt>forall <a>tvs</a>. context
--   =&gt; body</tt>) into its constituent parts. Only splits type variable
--   binders that were quantified invisibly (e.g., <tt>forall a.</tt>, with
--   a dot).
--   
--   This function is used to split apart certain types, such as instance
--   declaration types, which disallow visible <tt>forall</tt>s. For
--   instance, if GHC split apart the <tt>forall</tt> in <tt>instance
--   forall a -&gt; Show (Blah a)</tt>, then that declaration would
--   mistakenly be accepted!
--   
--   Note that this function looks through parentheses, so it will work on
--   types such as <tt>(forall a. <a>...</a>)</tt>. The downside to this is
--   that it is not generally possible to take the returned types and
--   reconstruct the original type (parentheses and all) from them.
splitLHsSigmaTyInvis :: LHsType (GhcPass p) -> ([LHsTyVarBndr Specificity (GhcPass p)], Maybe (LHsContext (GhcPass p)), LHsType (GhcPass p))

-- | Decompose a GADT type into its constituent parts. Returns
--   <tt>(outer_bndrs, mb_ctxt, body)</tt>, where:
--   
--   <ul>
--   <li><tt>outer_bndrs</tt> are <a>HsOuterExplicit</a> if the type has
--   explicit, outermost type variable binders. Otherwise, they are
--   <a>HsOuterImplicit</a>.</li>
--   <li><tt>mb_ctxt</tt> is <tt>Just</tt> the context, if it is provided.
--   Otherwise, it is <tt>Nothing</tt>.</li>
--   <li><tt>body</tt> is the body of the type after the optional
--   <tt>forall</tt>s and context.</li>
--   </ul>
--   
--   This function is careful not to look through parentheses. See <tt>Note
--   [GADT abstract syntax] (Wrinkle: No nested foralls or contexts)</tt>
--   <a>GHC.Hs.Decls</a> for why this is important.
splitLHsGadtTy :: LHsSigType GhcPs -> (HsOuterSigTyVarBndrs GhcPs, Maybe (LHsContext GhcPs), LHsType GhcPs)
splitHsFunType :: LHsType (GhcPass p) -> ([AddEpAnn], EpAnnComments, [HsScaled (GhcPass p) (LHsType (GhcPass p))], LHsType (GhcPass p))

-- | Retrieve the name of the "head" of a nested type application. This is
--   somewhat like <tt>GHC.Tc.Gen.HsType.splitHsAppTys</tt>, but a little
--   more thorough. The purpose of this function is to examine instance
--   heads, so it doesn't handle *all* cases (like lists, tuples,
--   <tt>(~)</tt>, etc.).
hsTyGetAppHead_maybe :: Anno (IdGhcP p) ~ SrcSpanAnnN => LHsType (GhcPass p) -> Maybe (LocatedN (IdP (GhcPass p)))
mkHsOpTy :: Anno (IdGhcP p) ~ SrcSpanAnnN => LHsType (GhcPass p) -> LocatedN (IdP (GhcPass p)) -> LHsType (GhcPass p) -> HsType (GhcPass p)
mkHsAppTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
mkHsAppTys :: LHsType (GhcPass p) -> [LHsType (GhcPass p)] -> LHsType (GhcPass p)
mkHsAppKindTy :: XAppKindTy (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
ignoreParens :: LHsType (GhcPass p) -> LHsType (GhcPass p)
hsSigWcType :: forall p. UnXRec p => LHsSigWcType p -> LHsType p
hsPatSigType :: HsPatSigType pass -> LHsType pass

-- | Get the kind signature of a type, ignoring parentheses:
--   
--   hsTyKindSig `Maybe ` = Nothing hsTyKindSig `Maybe :: Type -&gt; Type `
--   = Just `Type -&gt; Type` hsTyKindSig `Maybe :: ((Type -&gt; Type))` =
--   Just `Type -&gt; Type`
--   
--   This is used to extract the result kind of type synonyms with a CUSK:
--   
--   type S = (F :: res_kind) ^^^^^^^^
hsTyKindSig :: LHsType (GhcPass p) -> Maybe (LHsKind (GhcPass p))

-- | Set the attached flag
setHsTyVarBndrFlag :: flag -> HsTyVarBndr flag' (GhcPass pass) -> HsTyVarBndr flag (GhcPass pass)

-- | Return the attached flag
hsTyVarBndrFlag :: HsTyVarBndr flag (GhcPass pass) -> flag
pprHsType :: OutputableBndrId p => HsType (GhcPass p) -> SDoc

-- | Prints a forall; When passed an empty list, prints <tt>forall
--   .</tt>/<tt>forall -&gt;</tt> only when <tt>-dppr-debug</tt> is
--   enabled.
pprHsForAll :: forall p. OutputableBndrId p => HsForAllTelescope (GhcPass p) -> Maybe (LHsContext (GhcPass p)) -> SDoc

-- | Prints the explicit <tt>forall</tt> in a type family equation if one
--   is written. If there is no explicit <tt>forall</tt>, nothing is
--   printed.
pprHsOuterFamEqnTyVarBndrs :: OutputableBndrId p => HsOuterFamEqnTyVarBndrs (GhcPass p) -> SDoc

-- | Prints the outermost <tt>forall</tt> in a type signature if one is
--   written. If there is no outermost <tt>forall</tt>, nothing is printed.
pprHsOuterSigTyVarBndrs :: OutputableBndrId p => HsOuterSigTyVarBndrs (GhcPass p) -> SDoc
pprLHsContext :: OutputableBndrId p => Maybe (LHsContext (GhcPass p)) -> SDoc

-- | <tt><a>hsTypeNeedsParens</a> p t</tt> returns <a>True</a> if the type
--   <tt>t</tt> needs parentheses under precedence <tt>p</tt>.
hsTypeNeedsParens :: PprPrec -> HsType (GhcPass p) -> Bool

-- | <tt><a>parenthesizeHsType</a> p ty</tt> checks if
--   <tt><a>hsTypeNeedsParens</a> p ty</tt> is true, and if so, surrounds
--   <tt>ty</tt> with an <a>HsParTy</a>. Otherwise, it simply returns
--   <tt>ty</tt>.
parenthesizeHsType :: PprPrec -> LHsType (GhcPass p) -> LHsType (GhcPass p)

-- | <tt><a>parenthesizeHsContext</a> p ctxt</tt> checks if <tt>ctxt</tt>
--   is a single constraint <tt>c</tt> such that
--   <tt><a>hsTypeNeedsParens</a> p c</tt> is true, and if so, surrounds
--   <tt>c</tt> with an <a>HsParTy</a> to form a parenthesized
--   <tt>ctxt</tt>. Otherwise, it simply returns <tt>ctxt</tt> unchanged.
parenthesizeHsContext :: PprPrec -> LHsContext (GhcPass p) -> LHsContext (GhcPass p)
instance GHC.Hs.Type.OutputableBndrFlag () p
instance GHC.Hs.Type.OutputableBndrFlag GHC.Types.Var.Specificity p
instance (GHC.Hs.Type.OutputableBndrFlag flag p, GHC.Hs.Type.OutputableBndrFlag flag (GHC.Hs.Extension.NoGhcTcPass p), GHC.Hs.Extension.OutputableBndrId p) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag (GHC.Hs.Extension.GhcPass p))
instance (GHC.Hs.Extension.OutputableBndrId p, GHC.Hs.Type.OutputableBndrFlag flag p) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsTyVarBndr flag (GHC.Hs.Extension.GhcPass p))
instance GHC.Types.Name.NamedThing (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcRn)
instance GHC.Hs.Extension.OutputableBndrId pass => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsArrow (GHC.Hs.Extension.GhcPass pass))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.ConDeclField (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.AmbiguousFieldOcc (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.Type.AmbiguousFieldOcc (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsSigType (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsType (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.LHsQTyVars (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsForAllTelescope (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable thing => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsWildCardBndrs (GHC.Hs.Extension.GhcPass p) thing)
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsPatSigType (GHC.Hs.Extension.GhcPass p))

module GHC.Hs.Extension
type IsSrcSpanAnn p a = (Anno (IdGhcP p) ~ SrcSpanAnn' (EpAnn a), IsPass p)

-- | Used as a data type index for the hsSyn AST; also serves as a
--   singleton type for Pass
data GhcPass (c :: Pass)
[GhcPs] :: GhcPass 'Parsed
[GhcRn] :: GhcPass 'Renamed
[GhcTc] :: GhcPass 'Typechecked
data Pass
Parsed :: Pass
Renamed :: Pass
Typechecked :: Pass
type GhcPs = GhcPass 'Parsed
type GhcRn = GhcPass 'Renamed
type GhcTc = GhcPass 'Typechecked

-- | Allows us to check what phase we're in at GHC's runtime. For example,
--   this class allows us to write &gt; f :: forall p. IsPass p =&gt;
--   HsExpr (GhcPass p) -&gt; blah &gt; f e = case ghcPass @p of &gt; GhcPs
--   -&gt; ... in this RHS we have HsExpr GhcPs... &gt; GhcRn -&gt; ... in
--   this RHS we have HsExpr GhcRn... &gt; GhcTc -&gt; ... in this RHS we
--   have HsExpr GhcTc... which is very useful, for example, when
--   pretty-printing. See Note [IsPass].
class (NoGhcTcPass (NoGhcTcPass p) ~ NoGhcTcPass p, IsPass (NoGhcTcPass p)) => IsPass p
ghcPass :: IsPass p => GhcPass p

-- | Maps the "normal" id type for a given GHC pass
type family IdGhcP pass
type family NoGhcTcPass (p :: Pass) :: Pass

-- | Constraint type to bundle up the requirement for <a>OutputableBndr</a>
--   on both the <tt>id</tt> and the <a>NoGhcTc</a> of it. See Note
--   [NoGhcTc].
type OutputableBndrId pass = (OutputableBndr (IdGhcP pass), OutputableBndr (IdGhcP (NoGhcTcPass pass)), Outputable (GenLocated (Anno (IdGhcP pass)) (IdGhcP pass)), Outputable (GenLocated (Anno (IdGhcP (NoGhcTcPass pass))) (IdGhcP (NoGhcTcPass pass))), IsPass pass)
pprIfPs :: forall p. IsPass p => (p ~ 'Parsed => SDoc) -> SDoc
pprIfRn :: forall p. IsPass p => (p ~ 'Renamed => SDoc) -> SDoc
pprIfTc :: forall p. IsPass p => (p ~ 'Typechecked => SDoc) -> SDoc
instance Data.Data.Data GHC.Hs.Extension.Pass
instance GHC.Hs.Extension.IsPass 'GHC.Hs.Extension.Parsed
instance GHC.Hs.Extension.IsPass 'GHC.Hs.Extension.Renamed
instance GHC.Hs.Extension.IsPass 'GHC.Hs.Extension.Typechecked
instance Language.Haskell.Syntax.Extension.UnXRec (GHC.Hs.Extension.GhcPass p)
instance Language.Haskell.Syntax.Extension.MapXRec (GHC.Hs.Extension.GhcPass p)
instance Data.Typeable.Internal.Typeable p => Data.Data.Data (GHC.Hs.Extension.GhcPass p)


-- | Abstract Haskell syntax for expressions.
module GHC.Hs.Expr
pprExpr :: OutputableBndrId p => HsExpr (GhcPass p) -> SDoc
pprFunBind :: OutputableBndrId idR => MatchGroup (GhcPass idR) (LHsExpr (GhcPass idR)) -> SDoc
pprLExpr :: OutputableBndrId p => LHsExpr (GhcPass p) -> SDoc
pprPatBind :: forall bndr p. (OutputableBndrId bndr, OutputableBndrId p) => LPat (GhcPass bndr) -> GRHSs (GhcPass p) (LHsExpr (GhcPass p)) -> SDoc
pprSplice :: forall p. OutputableBndrId p => HsSplice (GhcPass p) -> SDoc
pprSpliceDecl :: OutputableBndrId p => HsSplice (GhcPass p) -> SpliceExplicitFlag -> SDoc

-- | <tt><a>hsExprNeedsParens</a> p e</tt> returns <a>True</a> if the
--   expression <tt>e</tt> needs parentheses under precedence <tt>p</tt>.
hsExprNeedsParens :: forall p. IsPass p => PprPrec -> HsExpr (GhcPass p) -> Bool
hsLMatchPats :: LMatch (GhcPass id) body -> [LPat (GhcPass id)]
isAtomicHsExpr :: forall p. IsPass p => HsExpr (GhcPass p) -> Bool
isEmptyMatchGroup :: MatchGroup (GhcPass p) body -> Bool
isQuietHsCmd :: HsCmd id -> Bool
isQuietHsExpr :: HsExpr id -> Bool

-- | Is there only one RHS in this list of matches?
isSingletonMatchGroup :: [LMatch (GhcPass p) body] -> Bool
matchArrowContextErrString :: HsArrowMatchContext -> SDoc
matchContextErrString :: OutputableBndrId p => HsMatchContext (GhcPass p) -> SDoc
matchGroupArity :: MatchGroup (GhcPass id) body -> Arity

-- | Make a <a>SyntaxExpr</a> from a <a>Name</a> (the "rn" is because this
--   is used in the renamer).
mkRnSyntaxExpr :: Name -> SyntaxExprRn

-- | Make a 'SyntaxExpr GhcRn' from an expression Used only in
--   getMonadFailOp. See Note [Monad fail : Rebindable syntax, overloaded
--   strings] in <a>GHC.Rename.Expr</a>
mkSyntaxExpr :: HsExpr GhcRn -> SyntaxExprRn

-- | This is used for rebindable-syntax pieces that are too polymorphic for
--   tcSyntaxOp (trS_fmap and the mzip in ParStmt)
noExpr :: HsExpr (GhcPass p)
noSyntaxExpr :: forall p. IsPass p => SyntaxExpr (GhcPass p)

-- | <tt><a>parenthesizeHsExpr</a> p e</tt> checks if
--   <tt><a>hsExprNeedsParens</a> p e</tt> is true, and if so, surrounds
--   <tt>e</tt> with an <a>HsPar</a>. Otherwise, it simply returns
--   <tt>e</tt>.
parenthesizeHsExpr :: IsPass p => PprPrec -> LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
pp_dotdot :: SDoc
pp_rhs :: Outputable body => HsMatchContext passL -> body -> SDoc
pprArg :: forall idL. OutputableBndrId idL => ApplicativeArg (GhcPass idL) -> SDoc
pprBindStmt :: (Outputable pat, Outputable expr) => pat -> expr -> SDoc
pprBinds :: (OutputableBndrId idL, OutputableBndrId idR) => HsLocalBindsLR (GhcPass idL) (GhcPass idR) -> SDoc
pprBy :: Outputable body => Maybe body -> SDoc
pprCmd :: OutputableBndrId p => HsCmd (GhcPass p) -> SDoc
pprCmdArg :: OutputableBndrId p => HsCmdTop (GhcPass p) -> SDoc
pprComp :: (OutputableBndrId p, Outputable body, Anno (StmtLR (GhcPass p) (GhcPass p) body) ~ SrcSpanAnnA) => [LStmt (GhcPass p) body] -> SDoc
pprDebugParendExpr :: OutputableBndrId p => PprPrec -> LHsExpr (GhcPass p) -> SDoc
pprDo :: (OutputableBndrId p, Outputable body, Anno (StmtLR (GhcPass p) (GhcPass p) body) ~ SrcSpanAnnA) => HsStmtContext any -> [LStmt (GhcPass p) body] -> SDoc
pprGRHS :: (OutputableBndrId idR, Outputable body) => HsMatchContext passL -> GRHS (GhcPass idR) body -> SDoc
pprGRHSs :: (OutputableBndrId idR, Outputable body) => HsMatchContext passL -> GRHSs (GhcPass idR) body -> SDoc
pprHsBracket :: OutputableBndrId p => HsBracket (GhcPass p) -> SDoc
pprLCmd :: OutputableBndrId p => LHsCmd (GhcPass p) -> SDoc
pprMatch :: (OutputableBndrId idR, Outputable body) => Match (GhcPass idR) body -> SDoc
pprMatchInCtxt :: (OutputableBndrId idR, Outputable body) => Match (GhcPass idR) body -> SDoc
pprMatches :: (OutputableBndrId idR, Outputable body) => MatchGroup (GhcPass idR) body -> SDoc
pprParendExpr :: OutputableBndrId p => PprPrec -> HsExpr (GhcPass p) -> SDoc
pprParendLExpr :: OutputableBndrId p => PprPrec -> LHsExpr (GhcPass p) -> SDoc
pprPendingSplice :: OutputableBndrId p => SplicePointName -> LHsExpr (GhcPass p) -> SDoc
pprQuals :: (OutputableBndrId p, Outputable body, Anno (StmtLR (GhcPass p) (GhcPass p) body) ~ SrcSpanAnnA) => [LStmt (GhcPass p) body] -> SDoc
pprStmt :: forall idL idR body. (OutputableBndrId idL, OutputableBndrId idR, Anno (StmtLR (GhcPass idL) (GhcPass idR) body) ~ SrcSpanAnnA, Outputable body) => StmtLR (GhcPass idL) (GhcPass idR) body -> SDoc
pprStmtInCtxt :: (OutputableBndrId idL, OutputableBndrId idR, Outputable body, Anno (StmtLR (GhcPass idL) (GhcPass idR) body) ~ SrcSpanAnnA) => HsStmtContext (GhcPass idL) -> StmtLR (GhcPass idL) (GhcPass idR) body -> SDoc
pprTransStmt :: Outputable body => Maybe body -> body -> TransForm -> SDoc
pprTransformStmt :: OutputableBndrId p => [IdP (GhcPass p)] -> LHsExpr (GhcPass p) -> Maybe (LHsExpr (GhcPass p)) -> SDoc
ppr_apps :: OutputableBndrId p => HsExpr (GhcPass p) -> [Either (LHsExpr (GhcPass p)) (LHsWcType (NoGhcTc (GhcPass p)))] -> SDoc
ppr_cmd :: forall p. OutputableBndrId p => HsCmd (GhcPass p) -> SDoc
ppr_do_stmts :: (OutputableBndrId idL, OutputableBndrId idR, Anno (StmtLR (GhcPass idL) (GhcPass idR) body) ~ SrcSpanAnnA, Outputable body) => [LStmtLR (GhcPass idL) (GhcPass idR) body] -> SDoc
ppr_expr :: forall p. OutputableBndrId p => HsExpr (GhcPass p) -> SDoc
ppr_infix_expr :: forall p. OutputableBndrId p => HsExpr (GhcPass p) -> Maybe SDoc
ppr_lcmd :: OutputableBndrId p => LHsCmd (GhcPass p) -> SDoc
ppr_lexpr :: OutputableBndrId p => LHsExpr (GhcPass p) -> SDoc
ppr_module_name_prefix :: Maybe ModuleName -> SDoc
ppr_quasi :: OutputableBndr p => p -> p -> FastString -> SDoc
ppr_splice :: OutputableBndrId p => SDoc -> IdP (GhcPass p) -> LHsExpr (GhcPass p) -> SDoc -> SDoc
ppr_splice_decl :: OutputableBndrId p => HsSplice (GhcPass p) -> SDoc
stripParensHsExpr :: HsExpr (GhcPass p) -> HsExpr (GhcPass p)
stripParensLHsExpr :: LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
thBrackets :: SDoc -> SDoc -> SDoc
thTyBrackets :: SDoc -> SDoc
tupArgPresent :: HsTupArg (GhcPass p) -> Bool
data AnnExplicitSum
AnnExplicitSum :: EpaLocation -> [EpaLocation] -> [EpaLocation] -> EpaLocation -> AnnExplicitSum
[aesOpen] :: AnnExplicitSum -> EpaLocation
[aesBarsBefore] :: AnnExplicitSum -> [EpaLocation]
[aesBarsAfter] :: AnnExplicitSum -> [EpaLocation]
[aesClose] :: AnnExplicitSum -> EpaLocation
data AnnFieldLabel
AnnFieldLabel :: Maybe EpaLocation -> AnnFieldLabel
[afDot] :: AnnFieldLabel -> Maybe EpaLocation
data AnnProjection
AnnProjection :: EpaLocation -> EpaLocation -> AnnProjection

-- | '('
[apOpen] :: AnnProjection -> EpaLocation

-- | ')'
[apClose] :: AnnProjection -> EpaLocation
data AnnsIf
AnnsIf :: EpaLocation -> EpaLocation -> EpaLocation -> Maybe EpaLocation -> Maybe EpaLocation -> AnnsIf
[aiIf] :: AnnsIf -> EpaLocation
[aiThen] :: AnnsIf -> EpaLocation
[aiElse] :: AnnsIf -> EpaLocation
[aiThenSemi] :: AnnsIf -> Maybe EpaLocation
[aiElseSemi] :: AnnsIf -> Maybe EpaLocation
data AnnsLet
AnnsLet :: EpaLocation -> EpaLocation -> AnnsLet
[alLet] :: AnnsLet -> EpaLocation
[alIn] :: AnnsLet -> EpaLocation
data CmdTopTc
CmdTopTc :: Type -> Type -> CmdSyntaxTable GhcTc -> CmdTopTc
data DelayedSplice
DelayedSplice :: TcLclEnv -> LHsExpr GhcRn -> TcType -> LHsExpr GhcTc -> DelayedSplice
data EpAnnHsCase
EpAnnHsCase :: EpaLocation -> EpaLocation -> [AddEpAnn] -> EpAnnHsCase
[hsCaseAnnCase] :: EpAnnHsCase -> EpaLocation
[hsCaseAnnOf] :: EpAnnHsCase -> EpaLocation
[hsCaseAnnsRest] :: EpAnnHsCase -> [AddEpAnn]
data EpAnnUnboundVar
EpAnnUnboundVar :: (EpaLocation, EpaLocation) -> EpaLocation -> EpAnnUnboundVar
[hsUnboundBackquotes] :: EpAnnUnboundVar -> (EpaLocation, EpaLocation)
[hsUnboundHole] :: EpAnnUnboundVar -> EpaLocation
data GrhsAnn
GrhsAnn :: Maybe EpaLocation -> AddEpAnn -> GrhsAnn
[ga_vbar] :: GrhsAnn -> Maybe EpaLocation

-- | Match separator location
[ga_sep] :: GrhsAnn -> AddEpAnn
data HsExpansion a b
HsExpanded :: a -> b -> HsExpansion a b
newtype HsSplicedT
HsSplicedT :: DelayedSplice -> HsSplicedT

-- | HsWrap appears only in typechecker output Invariant: The contained
--   Expr is *NOT* itself an HsWrap. See Note [Detecting forced eta
--   expansion] in <a>GHC.HsToCore.Expr</a>. This invariant is maintained
--   by <a>mkHsWrap</a>. hs_syn is something like HsExpr or HsCmd
data HsWrap hs_syn
HsWrap :: HsWrapper -> hs_syn GhcTc -> HsWrap hs_syn

-- | Pending Renamer Splice
data PendingRnSplice
PendingRnSplice :: UntypedSpliceFlavour -> SplicePointName -> LHsExpr GhcRn -> PendingRnSplice

-- | Pending Type-checker Splice
data PendingTcSplice
PendingTcSplice :: SplicePointName -> LHsExpr GhcTc -> PendingTcSplice

-- | Post-Type checking Expression
--   
--   PostTcExpr is an evidence expression attached to the syntax tree by
--   the type checker (c.f. postTcType).
type PostTcExpr = HsExpr GhcTc

-- | Post-Type checking Table
--   
--   We use a PostTcTable where there are a bunch of pieces of evidence,
--   more than is convenient to keep individually.
type PostTcTable = [(Name, PostTcExpr)]
data RecStmtTc
RecStmtTc :: Type -> [PostTcExpr] -> [PostTcExpr] -> Type -> RecStmtTc
[recS_bind_ty] :: RecStmtTc -> Type
[recS_later_rets] :: RecStmtTc -> [PostTcExpr]
[recS_rec_rets] :: RecStmtTc -> [PostTcExpr]
[recS_ret_ty] :: RecStmtTc -> Type

-- | Extra data fields for a <a>RecordUpd</a>, added by the type checker
data RecordUpdTc
RecordUpdTc :: [ConLike] -> [Type] -> [Type] -> HsWrapper -> RecordUpdTc
[rupd_cons] :: RecordUpdTc -> [ConLike]
[rupd_in_tys] :: RecordUpdTc -> [Type]
[rupd_out_tys] :: RecordUpdTc -> [Type]
[rupd_wrap] :: RecordUpdTc -> HsWrapper
type family SyntaxExprGhc (p :: Pass) = (r :: Type) | r -> p

-- | The function to use in rebindable syntax. See Note [NoSyntaxExpr].
data SyntaxExprRn
SyntaxExprRn :: HsExpr GhcRn -> SyntaxExprRn
NoSyntaxExprRn :: SyntaxExprRn

-- | An expression with wrappers, used for rebindable syntax
--   
--   This should desugar to
--   
--   <pre>
--   syn_res_wrap $ syn_expr (syn_arg_wraps[0] arg0)
--                           (syn_arg_wraps[1] arg1) ...
--   </pre>
--   
--   where the actual arguments come from elsewhere in the AST.
data SyntaxExprTc
SyntaxExprTc :: HsExpr GhcTc -> [HsWrapper] -> HsWrapper -> SyntaxExprTc
[syn_expr] :: SyntaxExprTc -> HsExpr GhcTc
[syn_arg_wraps] :: SyntaxExprTc -> [HsWrapper]
[syn_res_wrap] :: SyntaxExprTc -> HsWrapper
NoSyntaxExprTc :: SyntaxExprTc
data XBindStmtRn
XBindStmtRn :: SyntaxExpr GhcRn -> FailOperator GhcRn -> XBindStmtRn
[xbsrn_bindOp] :: XBindStmtRn -> SyntaxExpr GhcRn
[xbsrn_failOp] :: XBindStmtRn -> FailOperator GhcRn
data XBindStmtTc
XBindStmtTc :: SyntaxExpr GhcTc -> Type -> Mult -> FailOperator GhcTc -> XBindStmtTc
[xbstc_bindOp] :: XBindStmtTc -> SyntaxExpr GhcTc
[xbstc_boundResultType] :: XBindStmtTc -> Type
[xbstc_boundResultMult] :: XBindStmtTc -> Mult
[xbstc_failOp] :: XBindStmtTc -> FailOperator GhcTc
data XXExprGhcTc
WrapExpr :: {-# UNPACK #-} !HsWrap HsExpr -> XXExprGhcTc
ExpansionExpr :: {-# UNPACK #-} !HsExpansion (HsExpr GhcRn) (HsExpr GhcTc) -> XXExprGhcTc
instance Data.Data.Data GHC.Hs.Expr.EpAnnHsCase
instance Data.Data.Data GHC.Hs.Expr.EpAnnUnboundVar
instance Data.Data.Data GHC.Hs.Expr.AnnExplicitSum
instance Data.Data.Data GHC.Hs.Expr.AnnsLet
instance Data.Data.Data GHC.Hs.Expr.AnnFieldLabel
instance Data.Data.Data GHC.Hs.Expr.AnnProjection
instance Data.Data.Data GHC.Hs.Expr.AnnsIf
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (GHC.Hs.Expr.HsExpansion a b)
instance Data.Data.Data GHC.Hs.Expr.GrhsAnn
instance Data.Data.Data GHC.Hs.Expr.HsSplicedT
instance (Data.Data.Data (hs_syn GHC.Hs.Extension.GhcTc), Data.Typeable.Internal.Typeable hs_syn) => Data.Data.Data (GHC.Hs.Expr.HsWrap hs_syn)
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.PendingTcSplice
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.PendingRnSplice
instance Data.Data.Data GHC.Hs.Expr.DelayedSplice
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.GrhsAnn
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (GHC.Hs.Expr.HsExpansion a b)
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.SyntaxExprTc
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.SyntaxExprRn
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsExpr (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsPragE (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsCmd (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsCmdTop (GHC.Hs.Extension.GhcPass p))
instance (GHC.Hs.Extension.OutputableBndrId pr, GHC.Utils.Outputable.Outputable body) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.Match (GHC.Hs.Extension.GhcPass pr) body)
instance (GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.StmtLR (GHC.Hs.Extension.GhcPass idL) (GHC.Hs.Extension.GhcPass idL) (Language.Haskell.Syntax.Expr.LHsExpr (GHC.Hs.Extension.GhcPass idL))), GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XXParStmtBlock (GHC.Hs.Extension.GhcPass idL) (GHC.Hs.Extension.GhcPass idR))) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.ParStmtBlock (GHC.Hs.Extension.GhcPass idL) (GHC.Hs.Extension.GhcPass idR))
instance (GHC.Hs.Extension.OutputableBndrId pl, GHC.Hs.Extension.OutputableBndrId pr, Language.Haskell.Syntax.Extension.Anno (Language.Haskell.Syntax.Expr.StmtLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr) body) GHC.Types.~ GHC.Parser.Annotation.SrcSpanAnnA, GHC.Utils.Outputable.Outputable body) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.StmtLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr) body)
instance GHC.Hs.Extension.OutputableBndrId idL => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.ApplicativeArg (GHC.Hs.Extension.GhcPass idL))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsSplicedThing (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsSplice (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsBracket (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.ArithSeqInfo (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsMatchContext (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Expr.HsArrowMatchContext
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsStmtContext (GHC.Hs.Extension.GhcPass p))
instance (Language.Haskell.Syntax.Extension.Anno a GHC.Types.~ GHC.Parser.Annotation.SrcSpanAnn' (GHC.Parser.Annotation.EpAnn an)) => Language.Haskell.Syntax.Extension.WrapXRec (GHC.Hs.Extension.GhcPass p) a


-- | Abstract Haskell syntax for expressions.
module Language.Haskell.Syntax.Expr

-- | RecordDotSyntax field updates
newtype FieldLabelStrings p
FieldLabelStrings :: [Located (HsFieldLabel p)] -> FieldLabelStrings p
pprFieldLabelStrings :: FieldLabelStrings p -> SDoc
type RecProj p arg = HsRecField' (FieldLabelStrings p) arg
type LHsRecProj p arg = XRec p (RecProj p arg)
type RecUpdProj p = RecProj p (LHsExpr p)
type LHsRecUpdProj p = XRec p (RecUpdProj p)

-- | Located Haskell Expression
type LHsExpr p = XRec p (HsExpr p) " May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when in a list"

-- | Syntax Expression
--   
--   SyntaxExpr is represents the function used in interpreting rebindable
--   syntax. In the parser, we have no information to supply; in the
--   renamer, we have the name of the function (but see Note [Monad fail :
--   Rebindable syntax, overloaded strings] for a wrinkle) and in the
--   type-checker we have a more elaborate structure <tt>SyntaxExprTc</tt>.
--   
--   In some contexts, rebindable syntax is not implemented, and so we have
--   constructors to represent that possibility in both the renamer and
--   typechecker instantiations.
--   
--   E.g. <tt>(&gt;&gt;=)</tt> is filled in before the renamer by the
--   appropriate <a>Name</a> for <tt>(&gt;&gt;=)</tt>, and then
--   instantiated by the type checker with its type args etc
type family SyntaxExpr p

-- | Command Syntax Table (for Arrow syntax)
type CmdSyntaxTable p = [(Name, HsExpr p)]

-- | A Haskell expression.
data HsExpr p

-- | Variable See Note [Located RdrNames]
HsVar :: XVar p -> LIdP p -> HsExpr p

-- | Unbound variable; also used for "holes" (_ or _x). Turned from HsVar
--   to HsUnboundVar by the renamer, when it finds an out-of-scope variable
--   or hole. The (XUnboundVar p) field becomes an HoleExprRef after
--   typechecking; this is where the erroring expression will be written
--   after solving. See Note [Holes] in GHC.Tc.Types.Constraint.
HsUnboundVar :: XUnboundVar p -> OccName -> HsExpr p

-- | After typechecker only; must be different HsVar for pretty printing
HsConLikeOut :: XConLikeOut p -> ConLike -> HsExpr p

-- | Variable pointing to record selector The parser produces HsVars The
--   renamer renames record-field selectors to HsRecFld The typechecker
--   preserves HsRecFld
HsRecFld :: XRecFld p -> AmbiguousFieldOcc p -> HsExpr p

-- | Overloaded label (Note [Overloaded labels] in GHC.OverloadedLabels)
HsOverLabel :: XOverLabel p -> FastString -> HsExpr p

-- | Implicit parameter (not in use after typechecking)
HsIPVar :: XIPVar p -> HsIPName -> HsExpr p

-- | Overloaded literals
HsOverLit :: XOverLitE p -> HsOverLit p -> HsExpr p

-- | Simple (non-overloaded) literals
HsLit :: XLitE p -> HsLit p -> HsExpr p

-- | Lambda abstraction. Currently always a single match
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLam</a>, <a>AnnRarrow</a>,</li>
--   </ul>
HsLam :: XLam p -> MatchGroup p (LHsExpr p) -> HsExpr p

-- | Lambda-case
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLam</a>,
--   <a>AnnCase</a>,<a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
HsLamCase :: XLamCase p -> MatchGroup p (LHsExpr p) -> HsExpr p

-- | Application
HsApp :: XApp p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Visible type application
--   
--   Explicit type argument; e.g f @Int x y NB: Has wildcards, but no
--   implicit quantification
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnAt</a>,</li>
--   </ul>
HsAppType :: XAppTypeE p -> LHsExpr p -> LHsWcType (NoGhcTc p) -> HsExpr p

-- | Operator applications: NB Bracketed ops such as (+) come out as Vars.
OpApp :: XOpApp p -> LHsExpr p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Negation operator. Contains the negated expression and the name of
--   <a>negate</a>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnMinus</a></li>
--   </ul>
NegApp :: XNegApp p -> LHsExpr p -> SyntaxExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>, <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
HsPar :: XPar p -> LHsExpr p -> HsExpr p
SectionL :: XSectionL p -> LHsExpr p -> LHsExpr p -> HsExpr p
SectionR :: XSectionR p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Used for explicit tuples and sections thereof
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
ExplicitTuple :: XExplicitTuple p -> [HsTupArg p] -> Boxity -> HsExpr p

-- | Used for unboxed sum types
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(#'</tt>,
--   <a>AnnVbar</a>, <a>AnnClose</a> <tt>'#)'</tt>,</li>
--   </ul>
--   
--   There will be multiple <a>AnnVbar</a>, (1 - alternative) before the
--   expression, (arity - alternative) after it
ExplicitSum :: XExplicitSum p -> ConTag -> Arity -> LHsExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnCase</a>, <a>AnnOf</a>,<a>AnnOpen</a>
--   <tt>'{'</tt>, <a>AnnClose</a> <tt>'}'</tt></li>
--   </ul>
HsCase :: XCase p -> LHsExpr p -> MatchGroup p (LHsExpr p) -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnIf</a>, <a>AnnSemi</a>,
--   <a>AnnThen</a>,<a>AnnSemi</a>, <a>AnnElse</a>,</li>
--   </ul>
HsIf :: XIf p -> LHsExpr p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Multi-way if
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnIf</a>
--   <a>AnnOpen</a>,<a>AnnClose</a>,</li>
--   </ul>
HsMultiIf :: XMultiIf p -> [LGRHS p (LHsExpr p)] -> HsExpr p

-- | let(rec)
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLet</a>, <a>AnnOpen</a> <tt>'{'</tt>,
--   <a>AnnClose</a> <tt>'}'</tt>,<a>AnnIn</a></li>
--   </ul>
HsLet :: XLet p -> HsLocalBinds p -> LHsExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDo</a>, <a>AnnOpen</a>,
--   <a>AnnSemi</a>, <a>AnnVbar</a>, <a>AnnClose</a></li>
--   </ul>
HsDo :: XDo p -> HsStmtContext (HsDoRn p) -> XRec p [ExprLStmt p] -> HsExpr p

-- | Syntactic list: [a,b,c,...]
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>, <a>AnnClose</a>
--   <tt>']'</tt></li>
--   </ul>
ExplicitList :: XExplicitList p -> [LHsExpr p] -> HsExpr p

-- | Record construction
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{'</tt>,
--   <a>AnnDotdot</a>,<a>AnnClose</a> <tt>'}'</tt></li>
--   </ul>
RecordCon :: XRecordCon p -> XRec p (ConLikeP p) -> HsRecordBinds p -> HsExpr p
[rcon_ext] :: HsExpr p -> XRecordCon p
[rcon_con] :: HsExpr p -> XRec p (ConLikeP p)
[rcon_flds] :: HsExpr p -> HsRecordBinds p

-- | Record update
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{'</tt>,
--   <a>AnnDotdot</a>,<a>AnnClose</a> <tt>'}'</tt>
--   'GHC.Parser.Annotation.AnnComma, <a>AnnDot</a>, <a>AnnClose</a>
--   <tt>'}'</tt></li>
--   </ul>
RecordUpd :: XRecordUpd p -> LHsExpr p -> Either [LHsRecUpdField p] [LHsRecUpdProj p] -> HsExpr p
[rupd_ext] :: HsExpr p -> XRecordUpd p
[rupd_expr] :: HsExpr p -> LHsExpr p
[rupd_flds] :: HsExpr p -> Either [LHsRecUpdField p] [LHsRecUpdProj p]

-- | Record field selection e.g <tt>z.x</tt>.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDot</a></li>
--   </ul>
--   
--   This case only arises when the OverloadedRecordDot langauge extension
--   is enabled.
HsGetField :: XGetField p -> LHsExpr p -> Located (HsFieldLabel p) -> HsExpr p
[gf_ext] :: HsExpr p -> XGetField p
[gf_expr] :: HsExpr p -> LHsExpr p
[gf_field] :: HsExpr p -> Located (HsFieldLabel p)

-- | Record field selector. e.g. <tt>(.x)</tt> or <tt>(.x.y)</tt>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenP</a> <a>AnnDot</a>,
--   <a>AnnCloseP</a></li>
--   </ul>
--   
--   This case only arises when the OverloadedRecordDot langauge extensions
--   is enabled.
HsProjection :: XProjection p -> NonEmpty (Located (HsFieldLabel p)) -> HsExpr p
[proj_ext] :: HsExpr p -> XProjection p
[proj_flds] :: HsExpr p -> NonEmpty (Located (HsFieldLabel p))

-- | Expression with an explicit type signature. <tt>e :: type</tt>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
ExprWithTySig :: XExprWithTySig p -> LHsExpr p -> LHsSigWcType (NoGhcTc p) -> HsExpr p

-- | Arithmetic sequence
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>,
--   <a>AnnComma</a>,<a>AnnDotdot</a>, <a>AnnClose</a> <tt>']'</tt></li>
--   </ul>
ArithSeq :: XArithSeq p -> Maybe (SyntaxExpr p) -> ArithSeqInfo p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnOpenE</a>,<a>AnnOpenEQ</a>,
--   <a>AnnClose</a>,<a>AnnCloseQ</a></li>
--   </ul>
HsBracket :: XBracket p -> HsBracket p -> HsExpr p
HsRnBracketOut :: XRnBracketOut p -> HsBracket (HsBracketRn p) -> [PendingRnSplice' p] -> HsExpr p
HsTcBracketOut :: XTcBracketOut p -> Maybe QuoteWrapper -> HsBracket (HsBracketRn p) -> [PendingTcSplice' p] -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
HsSpliceE :: XSpliceE p -> HsSplice p -> HsExpr p

-- | <tt>proc</tt> notation for Arrows
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnProc</a>, <a>AnnRarrow</a></li>
--   </ul>
HsProc :: XProc p -> LPat p -> LHsCmdTop p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnStatic</a>,</li>
--   </ul>
HsStatic :: XStatic p -> LHsExpr p -> HsExpr p
HsTick :: XTick p -> CoreTickish -> LHsExpr p -> HsExpr p
HsBinTick :: XBinTick p -> Int -> Int -> LHsExpr p -> HsExpr p
HsPragE :: XPragE p -> HsPragE p -> LHsExpr p -> HsExpr p
XExpr :: !XXExpr p -> HsExpr p

-- | The AST used to hard-refer to GhcPass, which was a layer violation.
--   For now, we paper it over with this new extension point.
type family HsDoRn p
type family HsBracketRn p
type family PendingRnSplice' p
type family PendingTcSplice' p
data HsFieldLabel p
HsFieldLabel :: XCHsFieldLabel p -> Located FieldLabelString -> HsFieldLabel p
[hflExt] :: HsFieldLabel p -> XCHsFieldLabel p
[hflLabel] :: HsFieldLabel p -> Located FieldLabelString
XHsFieldLabel :: !XXHsFieldLabel p -> HsFieldLabel p

-- | A pragma, written as {-# ... #-}, that may appear within an
--   expression.
data HsPragE p
HsPragSCC :: XSCC p -> SourceText -> StringLiteral -> HsPragE p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnOpen</a> <tt>'{-#
--   GENERATED'</tt>, <a>AnnVal</a>,<a>AnnVal</a>,
--   <a>AnnColon</a>,<a>AnnVal</a>, <a>AnnMinus</a>,
--   <a>AnnVal</a>,<a>AnnColon</a>, <a>AnnVal</a>, <a>AnnClose</a>
--   <tt>'#-}'</tt></li>
--   </ul>
XHsPragE :: !XXPragE p -> HsPragE p

-- | Located Haskell Tuple Argument
--   
--   <a>HsTupArg</a> is used for tuple sections <tt>(,a,)</tt> is
--   represented by <tt>ExplicitTuple [Missing ty1, Present a, Missing
--   ty3]</tt> Which in turn stands for <tt>(x:ty1 y:ty2. (x,a,y))</tt>
type LHsTupArg id = XRec id (HsTupArg id)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnComma</a></li>
--   </ul>
--   
--   Haskell Tuple Argument
data HsTupArg id

-- | The argument
Present :: XPresent id -> LHsExpr id -> HsTupArg id

-- | The argument is missing, but this is its type
Missing :: XMissing id -> HsTupArg id

-- | Note [Trees that Grow] extension point
XTupArg :: !XXTupArg id -> HsTupArg id
pprExternalSrcLoc :: (StringLiteral, (Int, Int), (Int, Int)) -> SDoc

-- | Located Haskell Command (for arrow syntax)
type LHsCmd id = XRec id (HsCmd id)

-- | Haskell Command (e.g. a "statement" in an Arrow proc block)
data HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>Annlarrowtail</a>,
--   <a>Annrarrowtail</a>,<a>AnnLarrowtail</a>, <a>AnnRarrowtail</a></li>
--   </ul>
HsCmdArrApp :: XCmdArrApp id -> LHsExpr id -> LHsExpr id -> HsArrAppType -> Bool -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenB</a> <tt>'(|'</tt>,
--   <a>AnnCloseB</a> <tt>'|)'</tt></li>
--   </ul>
HsCmdArrForm :: XCmdArrForm id -> LHsExpr id -> LexicalFixity -> Maybe Fixity -> [LHsCmdTop id] -> HsCmd id
HsCmdApp :: XCmdApp id -> LHsCmd id -> LHsExpr id -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLam</a>, <a>AnnRarrow</a>,</li>
--   </ul>
HsCmdLam :: XCmdLam id -> MatchGroup id (LHsCmd id) -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>, <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
HsCmdPar :: XCmdPar id -> LHsCmd id -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnCase</a>, <a>AnnOf</a>,<a>AnnOpen</a>
--   <tt>'{'</tt>, <a>AnnClose</a> <tt>'}'</tt></li>
--   </ul>
HsCmdCase :: XCmdCase id -> LHsExpr id -> MatchGroup id (LHsCmd id) -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLam</a>, <a>AnnCase</a>,<a>AnnOpen</a>
--   <tt>'{'</tt>, <a>AnnClose</a> <tt>'}'</tt></li>
--   </ul>
HsCmdLamCase :: XCmdLamCase id -> MatchGroup id (LHsCmd id) -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnIf</a>, <a>AnnSemi</a>,
--   <a>AnnThen</a>,<a>AnnSemi</a>, <a>AnnElse</a>,</li>
--   </ul>
HsCmdIf :: XCmdIf id -> SyntaxExpr id -> LHsExpr id -> LHsCmd id -> LHsCmd id -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLet</a>, <a>AnnOpen</a> <tt>'{'</tt>,
--   <a>AnnClose</a> <tt>'}'</tt>,<a>AnnIn</a></li>
--   </ul>
HsCmdLet :: XCmdLet id -> HsLocalBinds id -> LHsCmd id -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDo</a>, <a>AnnOpen</a>,
--   <a>AnnSemi</a>, <a>AnnVbar</a>, <a>AnnClose</a></li>
--   </ul>
HsCmdDo :: XCmdDo id -> XRec id [CmdLStmt id] -> HsCmd id
XCmd :: !XXCmd id -> HsCmd id

-- | Haskell Array Application Type
data HsArrAppType
HsHigherOrderApp :: HsArrAppType
HsFirstOrderApp :: HsArrAppType

-- | Top-level command, introducing a new arrow. This may occur inside a
--   proc (where the stack is empty) or as an argument of a command-forming
--   operator.
--   
--   Located Haskell Top-level Command
type LHsCmdTop p = XRec p (HsCmdTop p)

-- | Haskell Top-level Command
data HsCmdTop p
HsCmdTop :: XCmdTop p -> LHsCmd p -> HsCmdTop p
XCmdTop :: !XXCmdTop p -> HsCmdTop p

-- | Haskell Record Bindings
type HsRecordBinds p = HsRecFields p (LHsExpr p)
data MatchGroup p body
MG :: XMG p body -> XRec p [LMatch p body] -> Origin -> MatchGroup p body
[mg_ext] :: MatchGroup p body -> XMG p body
[mg_alts] :: MatchGroup p body -> XRec p [LMatch p body]
[mg_origin] :: MatchGroup p body -> Origin
XMatchGroup :: !XXMatchGroup p body -> MatchGroup p body
data MatchGroupTc
MatchGroupTc :: [Scaled Type] -> Type -> MatchGroupTc
[mg_arg_tys] :: MatchGroupTc -> [Scaled Type]
[mg_res_ty] :: MatchGroupTc -> Type

-- | Located Match
--   
--   May have <a>AnnKeywordId</a> : <a>AnnSemi</a> when in a list
type LMatch id body = XRec id (Match id body)
data Match p body
Match :: XCMatch p body -> HsMatchContext (NoGhcTc p) -> [LPat p] -> GRHSs p body -> Match p body
[m_ext] :: Match p body -> XCMatch p body
[m_ctxt] :: Match p body -> HsMatchContext (NoGhcTc p)
[m_pats] :: Match p body -> [LPat p]
[m_grhss] :: Match p body -> GRHSs p body
XMatch :: !XXMatch p body -> Match p body
isInfixMatch :: Match id body -> Bool

-- | Guarded Right-Hand Sides
--   
--   GRHSs are used both for pattern bindings and for Matches
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnVbar</a>,
--   <a>AnnEqual</a>,<a>AnnWhere</a>, <a>AnnOpen</a>,<a>AnnClose</a>
--   <a>AnnRarrow</a>,<a>AnnSemi</a></li>
--   </ul>
data GRHSs p body
GRHSs :: XCGRHSs p body -> [LGRHS p body] -> HsLocalBinds p -> GRHSs p body
[grhssExt] :: GRHSs p body -> XCGRHSs p body

-- | Guarded RHSs
[grhssGRHSs] :: GRHSs p body -> [LGRHS p body]

-- | The where clause
[grhssLocalBinds] :: GRHSs p body -> HsLocalBinds p
XGRHSs :: !XXGRHSs p body -> GRHSs p body

-- | Located Guarded Right-Hand Side
type LGRHS id body = XRec id (GRHS id body)

-- | Guarded Right Hand Side.
data GRHS p body
GRHS :: XCGRHS p body -> [GuardLStmt p] -> body -> GRHS p body
XGRHS :: !XXGRHS p body -> GRHS p body

-- | Located <tt>do</tt> block Statement
type LStmt id body = XRec id (StmtLR id id body)

-- | Located Statement with separate Left and Right id's
type LStmtLR idL idR body = XRec idL (StmtLR idL idR body)

-- | <tt>do</tt> block Statement
type Stmt id body = StmtLR id id body

-- | Command Located Statement
type CmdLStmt id = LStmt id (LHsCmd id)

-- | Command Statement
type CmdStmt id = Stmt id (LHsCmd id)

-- | Expression Located Statement
type ExprLStmt id = LStmt id (LHsExpr id)

-- | Expression Statement
type ExprStmt id = Stmt id (LHsExpr id)

-- | Guard Located Statement
type GuardLStmt id = LStmt id (LHsExpr id)

-- | Guard Statement
type GuardStmt id = Stmt id (LHsExpr id)

-- | Ghci Located Statement
type GhciLStmt id = LStmt id (LHsExpr id)

-- | Ghci Statement
type GhciStmt id = Stmt id (LHsExpr id)

-- | Exact print annotations when in qualifier lists or guards -
--   <a>AnnKeywordId</a> : <a>AnnVbar</a>, <a>AnnComma</a>,<a>AnnThen</a>,
--   <a>AnnBy</a>,<a>AnnBy</a>, <a>AnnGroup</a>,<a>AnnUsing</a>
data StmtLR idL idR body
LastStmt :: XLastStmt idL idR body -> body -> Maybe Bool -> SyntaxExpr idR -> StmtLR idL idR body
BindStmt :: XBindStmt idL idR body -> LPat idL -> body -> StmtLR idL idR body

-- | <a>ApplicativeStmt</a> represents an applicative expression built with
--   <a>&lt;$&gt;</a> and <a>&lt;*&gt;</a>. It is generated by the renamer,
--   and is desugared into the appropriate applicative expression by the
--   desugarer, but it is intended to be invisible in error messages.
--   
--   For full details, see Note [ApplicativeDo] in <a>GHC.Rename.Expr</a>
ApplicativeStmt :: XApplicativeStmt idL idR body -> [(SyntaxExpr idR, ApplicativeArg idL)] -> Maybe (SyntaxExpr idR) -> StmtLR idL idR body
BodyStmt :: XBodyStmt idL idR body -> body -> SyntaxExpr idR -> SyntaxExpr idR -> StmtLR idL idR body

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLet</a> <a>AnnOpen</a>
--   <tt>'{'</tt>,<a>AnnClose</a> <tt>'}'</tt>,</li>
--   </ul>
LetStmt :: XLetStmt idL idR body -> HsLocalBindsLR idL idR -> StmtLR idL idR body
ParStmt :: XParStmt idL idR body -> [ParStmtBlock idL idR] -> HsExpr idR -> SyntaxExpr idR -> StmtLR idL idR body
TransStmt :: XTransStmt idL idR body -> TransForm -> [ExprLStmt idL] -> [(IdP idR, IdP idR)] -> LHsExpr idR -> Maybe (LHsExpr idR) -> SyntaxExpr idR -> SyntaxExpr idR -> HsExpr idR -> StmtLR idL idR body
[trS_ext] :: StmtLR idL idR body -> XTransStmt idL idR body
[trS_form] :: StmtLR idL idR body -> TransForm
[trS_stmts] :: StmtLR idL idR body -> [ExprLStmt idL]
[trS_bndrs] :: StmtLR idL idR body -> [(IdP idR, IdP idR)]
[trS_using] :: StmtLR idL idR body -> LHsExpr idR
[trS_by] :: StmtLR idL idR body -> Maybe (LHsExpr idR)
[trS_ret] :: StmtLR idL idR body -> SyntaxExpr idR
[trS_bind] :: StmtLR idL idR body -> SyntaxExpr idR
[trS_fmap] :: StmtLR idL idR body -> HsExpr idR

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRec</a></li>
--   </ul>
RecStmt :: XRecStmt idL idR body -> XRec idR [LStmtLR idL idR body] -> [IdP idR] -> [IdP idR] -> SyntaxExpr idR -> SyntaxExpr idR -> SyntaxExpr idR -> StmtLR idL idR body
[recS_ext] :: StmtLR idL idR body -> XRecStmt idL idR body
[recS_stmts] :: StmtLR idL idR body -> XRec idR [LStmtLR idL idR body]
[recS_later_ids] :: StmtLR idL idR body -> [IdP idR]
[recS_rec_ids] :: StmtLR idL idR body -> [IdP idR]
[recS_bind_fn] :: StmtLR idL idR body -> SyntaxExpr idR
[recS_ret_fn] :: StmtLR idL idR body -> SyntaxExpr idR
[recS_mfix_fn] :: StmtLR idL idR body -> SyntaxExpr idR
XStmtLR :: !XXStmtLR idL idR body -> StmtLR idL idR body
data TransForm
ThenForm :: TransForm
GroupForm :: TransForm

-- | Parenthesised Statement Block
data ParStmtBlock idL idR
ParStmtBlock :: XParStmtBlock idL idR -> [ExprLStmt idL] -> [IdP idR] -> SyntaxExpr idR -> ParStmtBlock idL idR
XParStmtBlock :: !XXParStmtBlock idL idR -> ParStmtBlock idL idR

-- | The fail operator
--   
--   This is used for `.. &lt;-` "bind statements" in do notation,
--   including non-monadic "binds" in applicative.
--   
--   The fail operator is 'Just expr' if it potentially fail monadically.
--   if the pattern match cannot fail, or shouldn't fail monadically
--   (regular incomplete pattern exception), it is <a>Nothing</a>.
--   
--   See Note [Monad fail : Rebindable syntax, overloaded strings] for the
--   type of expression in the <a>Just</a> case, and why it is so.
--   
--   See Note [Failing pattern matches in Stmts] for which contexts for
--   '<tt>BindStmt</tt>'s should use the monadic fail and which shouldn't.
type FailOperator id = Maybe (SyntaxExpr id)

-- | Applicative Argument
data ApplicativeArg idL
ApplicativeArgOne :: XApplicativeArgOne idL -> LPat idL -> LHsExpr idL -> Bool -> ApplicativeArg idL

-- | The fail operator, after renaming
--   
--   The fail operator is needed if this is a BindStmt where the pattern
--   can fail. E.g.: (Just a) &lt;- stmt The fail operator will be invoked
--   if the pattern match fails. It is also used for guards in
--   MonadComprehensions. The fail operator is Nothing if the pattern match
--   can't fail
[xarg_app_arg_one] :: ApplicativeArg idL -> XApplicativeArgOne idL
[app_arg_pattern] :: ApplicativeArg idL -> LPat idL
[arg_expr] :: ApplicativeArg idL -> LHsExpr idL

-- | True <a>=</a> was a BodyStmt, False <a>=</a> was a BindStmt. See Note
--   [Applicative BodyStmt]
[is_body_stmt] :: ApplicativeArg idL -> Bool
ApplicativeArgMany :: XApplicativeArgMany idL -> [ExprLStmt idL] -> HsExpr idL -> LPat idL -> HsStmtContext (ApplicativeArgStmCtxPass idL) -> ApplicativeArg idL
[xarg_app_arg_many] :: ApplicativeArg idL -> XApplicativeArgMany idL
[app_stmts] :: ApplicativeArg idL -> [ExprLStmt idL]
[final_expr] :: ApplicativeArg idL -> HsExpr idL
[bv_pattern] :: ApplicativeArg idL -> LPat idL

-- | context of the do expression, used in pprArg
[stmt_context] :: ApplicativeArg idL -> HsStmtContext (ApplicativeArgStmCtxPass idL)
XApplicativeArg :: !XXApplicativeArg idL -> ApplicativeArg idL
type family ApplicativeArgStmCtxPass idL

-- | Haskell Splice
data HsSplice id
HsTypedSplice :: XTypedSplice id -> SpliceDecoration -> IdP id -> LHsExpr id -> HsSplice id
HsUntypedSplice :: XUntypedSplice id -> SpliceDecoration -> IdP id -> LHsExpr id -> HsSplice id
HsQuasiQuote :: XQuasiQuote id -> IdP id -> IdP id -> SrcSpan -> FastString -> HsSplice id
HsSpliced :: XSpliced id -> ThModFinalizers -> HsSplicedThing id -> HsSplice id
XSplice :: !XXSplice id -> HsSplice id

-- | A splice can appear with various decorations wrapped around it. This
--   data type captures explicitly how it was originally written, for use
--   in the pretty printer.
data SpliceDecoration

-- | $splice or $$splice
DollarSplice :: SpliceDecoration

-- | bare splice
BareSplice :: SpliceDecoration
isTypedSplice :: HsSplice id -> Bool

-- | Finalizers produced by a splice with <a>addModFinalizer</a>
--   
--   See Note [Delaying modFinalizers in untyped splices] in
--   GHC.Rename.Splice. For how this is used.
newtype ThModFinalizers
ThModFinalizers :: [ForeignRef (Q ())] -> ThModFinalizers

-- | Haskell Spliced Thing
--   
--   Values that can result from running a splice.
data HsSplicedThing id

-- | Haskell Spliced Expression
HsSplicedExpr :: HsExpr id -> HsSplicedThing id

-- | Haskell Spliced Type
HsSplicedTy :: HsType id -> HsSplicedThing id

-- | Haskell Spliced Pattern
HsSplicedPat :: Pat id -> HsSplicedThing id
type SplicePointName = Name
data UntypedSpliceFlavour
UntypedExpSplice :: UntypedSpliceFlavour
UntypedPatSplice :: UntypedSpliceFlavour
UntypedTypeSplice :: UntypedSpliceFlavour
UntypedDeclSplice :: UntypedSpliceFlavour

-- | Haskell Bracket
data HsBracket p
ExpBr :: XExpBr p -> LHsExpr p -> HsBracket p
PatBr :: XPatBr p -> LPat p -> HsBracket p
DecBrL :: XDecBrL p -> [LHsDecl p] -> HsBracket p
DecBrG :: XDecBrG p -> HsGroup p -> HsBracket p
TypBr :: XTypBr p -> LHsType p -> HsBracket p
VarBr :: XVarBr p -> Bool -> LIdP p -> HsBracket p
TExpBr :: XTExpBr p -> LHsExpr p -> HsBracket p
XBracket :: !XXBracket p -> HsBracket p
isTypedBracket :: HsBracket id -> Bool

-- | Arithmetic Sequence Information
data ArithSeqInfo id
From :: LHsExpr id -> ArithSeqInfo id
FromThen :: LHsExpr id -> LHsExpr id -> ArithSeqInfo id
FromTo :: LHsExpr id -> LHsExpr id -> ArithSeqInfo id
FromThenTo :: LHsExpr id -> LHsExpr id -> LHsExpr id -> ArithSeqInfo id

-- | Haskell Match Context
--   
--   Context of a pattern match. This is more subtle than it would seem.
--   See Note [Varieties of pattern matches].
data HsMatchContext p
FunRhs :: LIdP p -> LexicalFixity -> SrcStrictness -> HsMatchContext p

-- | function binder of <tt>f</tt>
[mc_fun] :: HsMatchContext p -> LIdP p

-- | fixing of <tt>f</tt>
[mc_fixity] :: HsMatchContext p -> LexicalFixity

-- | was <tt>f</tt> banged? See Note [FunBind vs PatBind]
[mc_strictness] :: HsMatchContext p -> SrcStrictness

-- | Patterns of a lambda
LambdaExpr :: HsMatchContext p

-- | Patterns and guards on a case alternative
CaseAlt :: HsMatchContext p

-- | Guards of a multi-way if alternative
IfAlt :: HsMatchContext p

-- | A pattern match inside arrow notation
ArrowMatchCtxt :: HsArrowMatchContext -> HsMatchContext p

-- | A pattern binding eg [y] &lt;- e = e
PatBindRhs :: HsMatchContext p

-- | Guards of pattern bindings, e.g., (Just b) | Just _ &lt;- x = e |
--   otherwise = e'
PatBindGuards :: HsMatchContext p

-- | Record update [used only in GHC.HsToCore.Expr to tell matchWrapper
--   what sort of runtime error message to generate]
RecUpd :: HsMatchContext p

-- | Pattern of a do-stmt, list comprehension, pattern guard, etc
StmtCtxt :: HsStmtContext p -> HsMatchContext p

-- | A Template Haskell pattern splice
ThPatSplice :: HsMatchContext p

-- | A Template Haskell pattern quotation [p| (a,b) |]
ThPatQuote :: HsMatchContext p

-- | A pattern synonym declaration
PatSyn :: HsMatchContext p
isPatSynCtxt :: HsMatchContext p -> Bool

-- | Haskell Statement Context.
data HsStmtContext p
ListComp :: HsStmtContext p
MonadComp :: HsStmtContext p

-- | <ul>
--   <li><i>ModuleName.</i> do { ... }</li>
--   </ul>
DoExpr :: Maybe ModuleName -> HsStmtContext p

-- | <ul>
--   <li><i>ModuleName.</i> mdo { ... } ie recursive do-expression</li>
--   </ul>
MDoExpr :: Maybe ModuleName -> HsStmtContext p

-- | do-notation in an arrow-command context
ArrowExpr :: HsStmtContext p

-- | A command-line Stmt in GHCi pat &lt;- rhs
GhciStmtCtxt :: HsStmtContext p

-- | Pattern guard for specified thing
PatGuard :: HsMatchContext p -> HsStmtContext p

-- | A branch of a parallel stmt
ParStmtCtxt :: HsStmtContext p -> HsStmtContext p

-- | A branch of a transform stmt
TransStmtCtxt :: HsStmtContext p -> HsStmtContext p

-- | Haskell arrow match context.
data HsArrowMatchContext

-- | A proc expression
ProcExpr :: HsArrowMatchContext

-- | A case alternative inside arrow notation
ArrowCaseAlt :: HsArrowMatchContext

-- | An arrow kappa abstraction
KappaExpr :: HsArrowMatchContext
qualifiedDoModuleName_maybe :: HsStmtContext p -> Maybe ModuleName
isComprehensionContext :: HsStmtContext id -> Bool

-- | Is this a monadic context?
isMonadStmtContext :: HsStmtContext id -> Bool
isMonadCompContext :: HsStmtContext id -> Bool
matchSeparator :: HsMatchContext p -> SDoc
pprMatchContext :: (Outputable (IdP p), UnXRec p) => HsMatchContext p -> SDoc
pprMatchContextNoun :: forall p. (Outputable (IdP p), UnXRec p) => HsMatchContext p -> SDoc
pprArrowMatchContextNoun :: HsArrowMatchContext -> SDoc
pprAStmtContext :: (Outputable (IdP p), UnXRec p) => HsStmtContext p -> SDoc
pprStmtContext :: (Outputable (IdP p), UnXRec p) => HsStmtContext p -> SDoc
prependQualified :: Maybe ModuleName -> SDoc -> SDoc
instance Data.Data.Data Language.Haskell.Syntax.Expr.HsArrAppType
instance Data.Data.Data Language.Haskell.Syntax.Expr.MatchGroupTc
instance Data.Data.Data Language.Haskell.Syntax.Expr.TransForm
instance GHC.Show.Show Language.Haskell.Syntax.Expr.SpliceDecoration
instance GHC.Classes.Eq Language.Haskell.Syntax.Expr.SpliceDecoration
instance Data.Data.Data Language.Haskell.Syntax.Expr.SpliceDecoration
instance Data.Data.Data Language.Haskell.Syntax.Expr.UntypedSpliceFlavour
instance Data.Data.Data Language.Haskell.Syntax.Expr.ThModFinalizers
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Expr.SpliceDecoration
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.FieldLabelStrings p)
instance GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.Expr.FieldLabelStrings p)
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsFieldLabel p)

module Language.Haskell.Syntax.Pat

-- | Pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnBang</a></li>
--   </ul>
data Pat p

-- | Wildcard Pattern The sole reason for a type on a WildPat is to support
--   hsPatType :: Pat Id -&gt; Type
WildPat :: XWildPat p -> Pat p

-- | Variable Pattern
VarPat :: XVarPat p -> LIdP p -> Pat p

-- | Lazy Pattern ^ - <a>AnnKeywordId</a> : <a>AnnTilde</a>
LazyPat :: XLazyPat p -> LPat p -> Pat p

-- | As pattern ^ - <a>AnnKeywordId</a> : <a>AnnAt</a>
AsPat :: XAsPat p -> LIdP p -> LPat p -> Pat p

-- | Parenthesised pattern See Note [Parens in HsSyn] in GHC.Hs.Expr ^ -
--   <a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>, <a>AnnClose</a>
--   <tt>')'</tt>
ParPat :: XParPat p -> LPat p -> Pat p

-- | Bang pattern ^ - <a>AnnKeywordId</a> : <a>AnnBang</a>
BangPat :: XBangPat p -> LPat p -> Pat p

-- | Syntactic List
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>, <a>AnnClose</a>
--   <tt>']'</tt></li>
--   </ul>
ListPat :: XListPat p -> [LPat p] -> Pat p

-- | Tuple sub-patterns
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt> or
--   <tt>'(#'</tt>, <a>AnnClose</a> <tt>')'</tt> or <tt>'#)'</tt></li>
--   </ul>
TuplePat :: XTuplePat p -> [LPat p] -> Boxity -> Pat p

-- | Anonymous sum pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(#'</tt>,
--   <a>AnnClose</a> <tt>'#)'</tt></li>
--   </ul>
SumPat :: XSumPat p -> LPat p -> ConTag -> Arity -> Pat p

-- | Constructor Pattern
ConPat :: XConPat p -> XRec p (ConLikeP p) -> HsConPatDetails p -> Pat p
[pat_con_ext] :: Pat p -> XConPat p
[pat_con] :: Pat p -> XRec p (ConLikeP p)
[pat_args] :: Pat p -> HsConPatDetails p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a></li>
--   </ul>
ViewPat :: XViewPat p -> LHsExpr p -> LPat p -> Pat p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'$('</tt> <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
SplicePat :: XSplicePat p -> HsSplice p -> Pat p

-- | Literal Pattern Used for *non-overloaded* literal patterns: Int#,
--   Char#, Int, Char, String, etc.
LitPat :: XLitPat p -> HsLit p -> Pat p

-- | Natural Pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnVal</a> <tt><a>+</a></tt></li>
--   </ul>
NPat :: XNPat p -> XRec p (HsOverLit p) -> Maybe (SyntaxExpr p) -> SyntaxExpr p -> Pat p

-- | n+k pattern
NPlusKPat :: XNPlusKPat p -> LIdP p -> XRec p (HsOverLit p) -> HsOverLit p -> SyntaxExpr p -> SyntaxExpr p -> Pat p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
SigPat :: XSigPat p -> LPat p -> HsPatSigType (NoGhcTc p) -> Pat p

-- | Trees that Grow extension point for new constructors
XPat :: !XXPat p -> Pat p
type LPat p = XRec p (Pat p)
type family ConLikeP x

-- | Haskell Constructor Pattern Details
type HsConPatDetails p = HsConDetails (HsPatSigType (NoGhcTc p)) (LPat p) (HsRecFields p (LPat p))
hsConPatArgs :: forall p. UnXRec p => HsConPatDetails p -> [LPat p]

-- | Haskell Record Fields
--   
--   HsRecFields is used only for patterns and expressions (not data type
--   declarations)
data HsRecFields p arg
HsRecFields :: [LHsRecField p arg] -> Maybe (Located Int) -> HsRecFields p arg
[rec_flds] :: HsRecFields p arg -> [LHsRecField p arg]
[rec_dotdot] :: HsRecFields p arg -> Maybe (Located Int)

-- | Haskell Record Field
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnEqual</a>,</li>
--   </ul>
--   
--   For details on above see note [exact print annotations] in
--   GHC.Parser.Annotation
data HsRecField' id arg
HsRecField :: XHsRecField id -> Located id -> arg -> Bool -> HsRecField' id arg
[hsRecFieldAnn] :: HsRecField' id arg -> XHsRecField id
[hsRecFieldLbl] :: HsRecField' id arg -> Located id

-- | Filled in by renamer when punning
[hsRecFieldArg] :: HsRecField' id arg -> arg

-- | Note [Punning]
[hsRecPun] :: HsRecField' id arg -> Bool

-- | Located Haskell Record Field
type LHsRecField' p id arg = XRec p (HsRecField' id arg)

-- | Haskell Record Field
type HsRecField p arg = HsRecField' (FieldOcc p) arg

-- | Located Haskell Record Field
type LHsRecField p arg = XRec p (HsRecField p arg)

-- | Haskell Record Update Field
type HsRecUpdField p = HsRecField' (AmbiguousFieldOcc p) (LHsExpr p)

-- | Located Haskell Record Update Field
type LHsRecUpdField p = XRec p (HsRecUpdField p)
hsRecFields :: forall p arg. UnXRec p => HsRecFields p arg -> [XCFieldOcc p]
hsRecFieldSel :: HsRecField pass arg -> Located (XCFieldOcc pass)
hsRecFieldsArgs :: forall p arg. UnXRec p => HsRecFields p arg -> [arg]
instance Data.Traversable.Traversable (Language.Haskell.Syntax.Pat.HsRecField' id)
instance Data.Foldable.Foldable (Language.Haskell.Syntax.Pat.HsRecField' id)
instance GHC.Base.Functor (Language.Haskell.Syntax.Pat.HsRecField' id)
instance (GHC.Utils.Outputable.Outputable arg, GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XRec p (Language.Haskell.Syntax.Pat.HsRecField p arg))) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Pat.HsRecFields p arg)
instance (GHC.Utils.Outputable.Outputable p, GHC.Utils.Outputable.OutputableBndr p, GHC.Utils.Outputable.Outputable arg) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Pat.HsRecField' p arg)


-- | Source-language literals
module Language.Haskell.Syntax.Lit

-- | Haskell Literal
data HsLit x

-- | Character
HsChar :: XHsChar x -> Char -> HsLit x

-- | Unboxed character
HsCharPrim :: XHsCharPrim x -> Char -> HsLit x

-- | String
HsString :: XHsString x -> FastString -> HsLit x

-- | Packed bytes
HsStringPrim :: XHsStringPrim x -> !ByteString -> HsLit x

-- | Genuinely an Int; arises from <a>GHC.Tc.Deriv.Generate</a>, and from
--   TRANSLATION
HsInt :: XHsInt x -> IntegralLit -> HsLit x

-- | literal <tt>Int#</tt>
HsIntPrim :: XHsIntPrim x -> Integer -> HsLit x

-- | literal <tt>Word#</tt>
HsWordPrim :: XHsWordPrim x -> Integer -> HsLit x

-- | literal <tt>Int64#</tt>
HsInt64Prim :: XHsInt64Prim x -> Integer -> HsLit x

-- | literal <tt>Word64#</tt>
HsWord64Prim :: XHsWord64Prim x -> Integer -> HsLit x

-- | Genuinely an integer; arises only from TRANSLATION (overloaded
--   literals are done with HsOverLit)
HsInteger :: XHsInteger x -> Integer -> Type -> HsLit x

-- | Genuinely a rational; arises only from TRANSLATION (overloaded
--   literals are done with HsOverLit)
HsRat :: XHsRat x -> FractionalLit -> Type -> HsLit x

-- | Unboxed Float
HsFloatPrim :: XHsFloatPrim x -> FractionalLit -> HsLit x

-- | Unboxed Double
HsDoublePrim :: XHsDoublePrim x -> FractionalLit -> HsLit x
XLit :: !XXLit x -> HsLit x

-- | Haskell Overloaded Literal
data HsOverLit p
OverLit :: XOverLit p -> OverLitVal -> HsExpr p -> HsOverLit p
[ol_ext] :: HsOverLit p -> XOverLit p
[ol_val] :: HsOverLit p -> OverLitVal
[ol_witness] :: HsOverLit p -> HsExpr p
XOverLit :: !XXOverLit p -> HsOverLit p

-- | Overloaded Literal Value
data OverLitVal

-- | Integer-looking literals;
HsIntegral :: !IntegralLit -> OverLitVal

-- | Frac-looking literals
HsFractional :: !FractionalLit -> OverLitVal

-- | String-looking literals
HsIsString :: !SourceText -> !FastString -> OverLitVal
negateOverLitVal :: OverLitVal -> OverLitVal

-- | <tt><a>hsLitNeedsParens</a> p l</tt> returns <a>True</a> if a literal
--   <tt>l</tt> needs to be parenthesized under precedence <tt>p</tt>.
hsLitNeedsParens :: PprPrec -> HsLit x -> Bool

-- | <tt><a>hsOverLitNeedsParens</a> p ol</tt> returns <a>True</a> if an
--   overloaded literal <tt>ol</tt> needs to be parenthesized under
--   precedence <tt>p</tt>.
hsOverLitNeedsParens :: PprPrec -> HsOverLit x -> Bool
instance Data.Data.Data Language.Haskell.Syntax.Lit.OverLitVal
instance GHC.Classes.Eq (Language.Haskell.Syntax.Extension.XXOverLit p) => GHC.Classes.Eq (Language.Haskell.Syntax.Lit.HsOverLit p)
instance GHC.Classes.Ord (Language.Haskell.Syntax.Extension.XXOverLit p) => GHC.Classes.Ord (Language.Haskell.Syntax.Lit.HsOverLit p)
instance GHC.Classes.Eq Language.Haskell.Syntax.Lit.OverLitVal
instance GHC.Classes.Ord Language.Haskell.Syntax.Lit.OverLitVal
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Lit.OverLitVal
instance GHC.Classes.Eq (Language.Haskell.Syntax.Lit.HsLit x)


-- | Abstract syntax of global declarations.
--   
--   Definitions for: <tt>SynDecl</tt> and <tt>ConDecl</tt>,
--   <tt>ClassDecl</tt>, <tt>InstDecl</tt>, <tt>DefaultDecl</tt> and
--   <tt>ForeignDecl</tt>.
module Language.Haskell.Syntax.Decls

-- | A Haskell Declaration
data HsDecl p

-- | Type or Class Declaration
TyClD :: XTyClD p -> TyClDecl p -> HsDecl p

-- | Instance declaration
InstD :: XInstD p -> InstDecl p -> HsDecl p

-- | Deriving declaration
DerivD :: XDerivD p -> DerivDecl p -> HsDecl p

-- | Value declaration
ValD :: XValD p -> HsBind p -> HsDecl p

-- | Signature declaration
SigD :: XSigD p -> Sig p -> HsDecl p

-- | Standalone kind signature
KindSigD :: XKindSigD p -> StandaloneKindSig p -> HsDecl p

-- | 'default' declaration
DefD :: XDefD p -> DefaultDecl p -> HsDecl p

-- | Foreign declaration
ForD :: XForD p -> ForeignDecl p -> HsDecl p

-- | Warning declaration
WarningD :: XWarningD p -> WarnDecls p -> HsDecl p

-- | Annotation declaration
AnnD :: XAnnD p -> AnnDecl p -> HsDecl p

-- | Rule declaration
RuleD :: XRuleD p -> RuleDecls p -> HsDecl p

-- | Splice declaration (Includes quasi-quotes)
SpliceD :: XSpliceD p -> SpliceDecl p -> HsDecl p

-- | Documentation comment declaration
DocD :: XDocD p -> DocDecl -> HsDecl p

-- | Role annotation declaration
RoleAnnotD :: XRoleAnnotD p -> RoleAnnotDecl p -> HsDecl p
XHsDecl :: !XXHsDecl p -> HsDecl p
type LHsDecl p = XRec p (HsDecl p) " When in a list this may have  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' "

-- | Haskell Data type Definition
data HsDataDefn pass

-- | Declares a data type or newtype, giving its constructors <tt>
--   data/newtype T a = <a>constrs</a> data/newtype instance T [a] =
--   <a>constrs</a> </tt>
HsDataDefn :: XCHsDataDefn pass -> NewOrData -> Maybe (LHsContext pass) -> Maybe (XRec pass CType) -> Maybe (LHsKind pass) -> [LConDecl pass] -> HsDeriving pass -> HsDataDefn pass
[dd_ext] :: HsDataDefn pass -> XCHsDataDefn pass
[dd_ND] :: HsDataDefn pass -> NewOrData

-- | Context
[dd_ctxt] :: HsDataDefn pass -> Maybe (LHsContext pass)
[dd_cType] :: HsDataDefn pass -> Maybe (XRec pass CType)

-- | Optional kind signature.
--   
--   <tt>(Just k)</tt> for a GADT-style <tt>data</tt>, or <tt>data
--   instance</tt> decl, with explicit kind sig
--   
--   Always <tt>Nothing</tt> for H98-syntax decls
[dd_kindSig] :: HsDataDefn pass -> Maybe (LHsKind pass)

-- | Data constructors
--   
--   For <tt>data T a = T1 | T2 a</tt> the <a>LConDecl</a>s all have
--   <a>ConDeclH98</a>. For <tt>data T a where { T1 :: T a }</tt> the
--   <tt>LConDecls</tt> all have <a>ConDeclGADT</a>.
[dd_cons] :: HsDataDefn pass -> [LConDecl pass]

-- | Optional 'deriving' clause
[dd_derivs] :: HsDataDefn pass -> HsDeriving pass
XHsDataDefn :: !XXHsDataDefn pass -> HsDataDefn pass

-- | Haskell Deriving clause
type HsDeriving pass = [LHsDerivingClause pass] " The optional @deriving@ clauses of a data declaration. "Clauses" is plural because one can specify multiple deriving clauses using the @-XDerivingStrategies@ language extension.  The list of 'LHsDerivingClause's corresponds to exactly what the user requested to derive, in order. If no deriving clauses were specified, the list is empty."
type LHsFunDep pass = XRec pass (FunDep pass)
data FunDep pass
FunDep :: XCFunDep pass -> [LIdP pass] -> [LIdP pass] -> FunDep pass
XFunDep :: !XXFunDep pass -> FunDep pass

-- | A single <tt>deriving</tt> clause of a data declaration.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDeriving</a>, <a>AnnStock</a>,
--   <a>AnnAnyClass</a>, <a>AnnNewtype</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
data HsDerivingClause pass
HsDerivingClause :: XCHsDerivingClause pass -> Maybe (LDerivStrategy pass) -> LDerivClauseTys pass -> HsDerivingClause pass
[deriv_clause_ext] :: HsDerivingClause pass -> XCHsDerivingClause pass

-- | The user-specified strategy (if any) to use when deriving
--   <a>deriv_clause_tys</a>.
[deriv_clause_strategy] :: HsDerivingClause pass -> Maybe (LDerivStrategy pass)

-- | The types to derive.
[deriv_clause_tys] :: HsDerivingClause pass -> LDerivClauseTys pass
XHsDerivingClause :: !XXHsDerivingClause pass -> HsDerivingClause pass
type LHsDerivingClause pass = XRec pass (HsDerivingClause pass)

-- | The types mentioned in a single <tt>deriving</tt> clause. This can
--   come in two forms, <a>DctSingle</a> or <a>DctMulti</a>, depending on
--   whether the types are surrounded by enclosing parentheses or not.
--   These parentheses are semantically different than <a>HsParTy</a>. For
--   example, <tt>deriving ()</tt> means "derive zero classes" rather than
--   "derive an instance of the 0-tuple".
--   
--   <a>DerivClauseTys</a> use <a>LHsSigType</a> because <tt>deriving</tt>
--   clauses can mention type variables that aren't bound by the datatype,
--   e.g.
--   
--   <pre>
--   data T b = ... deriving (C [a])
--   </pre>
--   
--   should produce a derived instance for <tt>C [a] (T b)</tt>.
data DerivClauseTys pass

-- | A <tt>deriving</tt> clause with a single type. Moreover, that type can
--   only be a type constructor without any arguments.
--   
--   Example: <tt>deriving Eq</tt>
DctSingle :: XDctSingle pass -> LHsSigType pass -> DerivClauseTys pass

-- | A <tt>deriving</tt> clause with a comma-separated list of types,
--   surrounded by enclosing parentheses.
--   
--   Example: <tt>deriving (Eq, C a)</tt>
DctMulti :: XDctMulti pass -> [LHsSigType pass] -> DerivClauseTys pass
XDerivClauseTys :: !XXDerivClauseTys pass -> DerivClauseTys pass
type LDerivClauseTys pass = XRec pass (DerivClauseTys pass)
data NewOrData

-- | <pre>
--   newtype Blah ...
--   </pre>
NewType :: NewOrData

-- | <pre>
--   data Blah ...
--   </pre>
DataType :: NewOrData

-- | Convert a <a>NewOrData</a> to a <a>TyConFlavour</a>
newOrDataToFlavour :: NewOrData -> TyConFlavour
data StandaloneKindSig pass
StandaloneKindSig :: XStandaloneKindSig pass -> LIdP pass -> LHsSigType pass -> StandaloneKindSig pass
XStandaloneKindSig :: !XXStandaloneKindSig pass -> StandaloneKindSig pass

-- | Located Standalone Kind Signature
type LStandaloneKindSig pass = XRec pass (StandaloneKindSig pass)

-- | A type or class declaration.
data TyClDecl pass

-- | <pre>
--   type/data family T :: *-&gt;*
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnData</a>,
--   <a>AnnFamily</a>,<a>AnnDcolon</a>, <a>AnnWhere</a>,<a>AnnOpenP</a>,
--   <a>AnnDcolon</a>,<a>AnnCloseP</a>, <a>AnnEqual</a>,<a>AnnRarrow</a>,
--   <a>AnnVbar</a></li>
--   </ul>
FamDecl :: XFamDecl pass -> FamilyDecl pass -> TyClDecl pass
[tcdFExt] :: TyClDecl pass -> XFamDecl pass
[tcdFam] :: TyClDecl pass -> FamilyDecl pass

-- | <tt>type</tt> declaration
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnEqual</a>,</li>
--   </ul>
SynDecl :: XSynDecl pass -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> LHsType pass -> TyClDecl pass

-- | Post renameer, FVs
[tcdSExt] :: TyClDecl pass -> XSynDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity

-- | RHS of type declaration
[tcdRhs] :: TyClDecl pass -> LHsType pass

-- | <tt>data</tt> declaration
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnData</a>, <a>AnnFamily</a>,
--   <a>AnnNewType</a>, <a>AnnNewType</a>,<a>AnnDcolon</a>
--   <a>AnnWhere</a>,</li>
--   </ul>
DataDecl :: XDataDecl pass -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> HsDataDefn pass -> TyClDecl pass

-- | Post renamer, CUSK flag, FVs
[tcdDExt] :: TyClDecl pass -> XDataDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity
[tcdDataDefn] :: TyClDecl pass -> HsDataDefn pass
ClassDecl :: XClassDecl pass -> Maybe (LHsContext pass) -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> [LHsFunDep pass] -> [LSig pass] -> LHsBinds pass -> [LFamilyDecl pass] -> [LTyFamDefltDecl pass] -> [LDocDecl pass] -> TyClDecl pass

-- | Post renamer, FVs
[tcdCExt] :: TyClDecl pass -> XClassDecl pass

-- | Context...
[tcdCtxt] :: TyClDecl pass -> Maybe (LHsContext pass)

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity

-- | Functional deps
[tcdFDs] :: TyClDecl pass -> [LHsFunDep pass]

-- | Methods' signatures
[tcdSigs] :: TyClDecl pass -> [LSig pass]

-- | Default methods
[tcdMeths] :: TyClDecl pass -> LHsBinds pass

-- | Associated types;
[tcdATs] :: TyClDecl pass -> [LFamilyDecl pass]

-- | Associated type defaults
[tcdATDefs] :: TyClDecl pass -> [LTyFamDefltDecl pass]

-- | Haddock docs
[tcdDocs] :: TyClDecl pass -> [LDocDecl pass]
XTyClDecl :: !XXTyClDecl pass -> TyClDecl pass

-- | Located Declaration of a Type or Class
type LTyClDecl pass = XRec pass (TyClDecl pass)
data DataDeclRn
DataDeclRn :: Bool -> NameSet -> DataDeclRn

-- | does this have a CUSK? See Note [CUSKs: complete user-supplied kind
--   signatures]
[tcdDataCusk] :: DataDeclRn -> Bool
[tcdFVs] :: DataDeclRn -> NameSet

-- | Type or Class Group
data TyClGroup pass
TyClGroup :: XCTyClGroup pass -> [LTyClDecl pass] -> [LRoleAnnotDecl pass] -> [LStandaloneKindSig pass] -> [LInstDecl pass] -> TyClGroup pass
[group_ext] :: TyClGroup pass -> XCTyClGroup pass
[group_tyclds] :: TyClGroup pass -> [LTyClDecl pass]
[group_roles] :: TyClGroup pass -> [LRoleAnnotDecl pass]
[group_kisigs] :: TyClGroup pass -> [LStandaloneKindSig pass]
[group_instds] :: TyClGroup pass -> [LInstDecl pass]
XTyClGroup :: !XXTyClGroup pass -> TyClGroup pass
tyClGroupTyClDecls :: [TyClGroup pass] -> [LTyClDecl pass]
tyClGroupInstDecls :: [TyClGroup pass] -> [LInstDecl pass]
tyClGroupRoleDecls :: [TyClGroup pass] -> [LRoleAnnotDecl pass]
tyClGroupKindSigs :: [TyClGroup pass] -> [LStandaloneKindSig pass]

-- | type class
isClassDecl :: TyClDecl pass -> Bool

-- | <tt>True</tt> <a>=</a> argument is a <tt>data</tt>/<tt>newtype</tt>
--   declaration.
isDataDecl :: TyClDecl pass -> Bool

-- | type or type instance declaration
isSynDecl :: TyClDecl pass -> Bool

-- | type/data family declaration
isFamilyDecl :: TyClDecl pass -> Bool

-- | type family declaration
isTypeFamilyDecl :: TyClDecl pass -> Bool

-- | data family declaration
isDataFamilyDecl :: TyClDecl pass -> Bool

-- | open type family info
isOpenTypeFamilyInfo :: FamilyInfo pass -> Bool

-- | closed type family info
isClosedTypeFamilyInfo :: FamilyInfo pass -> Bool
countTyClDecls :: [TyClDecl pass] -> (Int, Int, Int, Int, Int)
tyClDeclTyVars :: TyClDecl pass -> LHsQTyVars pass

-- | type Family Declaration
data FamilyDecl pass
FamilyDecl :: XCFamilyDecl pass -> FamilyInfo pass -> TopLevelFlag -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> LFamilyResultSig pass -> Maybe (LInjectivityAnn pass) -> FamilyDecl pass
[fdExt] :: FamilyDecl pass -> XCFamilyDecl pass
[fdInfo] :: FamilyDecl pass -> FamilyInfo pass
[fdTopLevel] :: FamilyDecl pass -> TopLevelFlag
[fdLName] :: FamilyDecl pass -> LIdP pass
[fdTyVars] :: FamilyDecl pass -> LHsQTyVars pass
[fdFixity] :: FamilyDecl pass -> LexicalFixity
[fdResultSig] :: FamilyDecl pass -> LFamilyResultSig pass
[fdInjectivityAnn] :: FamilyDecl pass -> Maybe (LInjectivityAnn pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnData</a>,
--   <a>AnnFamily</a>, <a>AnnWhere</a>, <a>AnnOpenP</a>, <a>AnnDcolon</a>,
--   <a>AnnCloseP</a>, <a>AnnEqual</a>, <a>AnnRarrow</a>,
--   <a>AnnVbar</a></li>
--   </ul>
XFamilyDecl :: !XXFamilyDecl pass -> FamilyDecl pass

-- | Located type Family Declaration
type LFamilyDecl pass = XRec pass (FamilyDecl pass)

-- | Instance Declaration
data InstDecl pass
ClsInstD :: XClsInstD pass -> ClsInstDecl pass -> InstDecl pass
[cid_d_ext] :: InstDecl pass -> XClsInstD pass
[cid_inst] :: InstDecl pass -> ClsInstDecl pass
DataFamInstD :: XDataFamInstD pass -> DataFamInstDecl pass -> InstDecl pass
[dfid_ext] :: InstDecl pass -> XDataFamInstD pass
[dfid_inst] :: InstDecl pass -> DataFamInstDecl pass
TyFamInstD :: XTyFamInstD pass -> TyFamInstDecl pass -> InstDecl pass
[tfid_ext] :: InstDecl pass -> XTyFamInstD pass
[tfid_inst] :: InstDecl pass -> TyFamInstDecl pass
XInstDecl :: !XXInstDecl pass -> InstDecl pass

-- | Located Instance Declaration
type LInstDecl pass = XRec pass (InstDecl pass)
data FamilyInfo pass
DataFamily :: FamilyInfo pass
OpenTypeFamily :: FamilyInfo pass

-- | <a>Nothing</a> if we're in an hs-boot file and the user said "type
--   family Foo x where .."
ClosedTypeFamily :: Maybe [LTyFamInstEqn pass] -> FamilyInfo pass
pprFlavour :: FamilyInfo pass -> SDoc

-- | Type Family Instance Declaration
data TyFamInstDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnInstance</a>,</li>
--   </ul>
TyFamInstDecl :: XCTyFamInstDecl pass -> TyFamInstEqn pass -> TyFamInstDecl pass
[tfid_xtn] :: TyFamInstDecl pass -> XCTyFamInstDecl pass
[tfid_eqn] :: TyFamInstDecl pass -> TyFamInstEqn pass
XTyFamInstDecl :: !XXTyFamInstDecl pass -> TyFamInstDecl pass

-- | Located Type Family Instance Declaration
type LTyFamInstDecl pass = XRec pass (TyFamInstDecl pass)

-- | Type family default declarations. A convenient synonym for
--   <a>TyFamInstDecl</a>. See <tt>Note [Type family instance declarations
--   in HsSyn]</tt>.
type TyFamDefltDecl = TyFamInstDecl

-- | Located type family default declarations.
type LTyFamDefltDecl pass = XRec pass (TyFamDefltDecl pass)

-- | Data Family Instance Declaration
newtype DataFamInstDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnData</a>,
--   <a>AnnNewType</a>,<a>AnnInstance</a>, <a>AnnDcolon</a>
--   <a>AnnWhere</a>,<a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
DataFamInstDecl :: FamEqn pass (HsDataDefn pass) -> DataFamInstDecl pass
[dfid_eqn] :: DataFamInstDecl pass -> FamEqn pass (HsDataDefn pass)

-- | Located Data Family Instance Declaration
type LDataFamInstDecl pass = XRec pass (DataFamInstDecl pass)

-- | Family Equation
--   
--   One equation in a type family instance declaration, data family
--   instance declaration, or type family default. See Note [Type family
--   instance declarations in HsSyn] See Note [Family instance declaration
--   binders]
data FamEqn pass rhs
FamEqn :: XCFamEqn pass rhs -> LIdP pass -> HsOuterFamEqnTyVarBndrs pass -> HsTyPats pass -> LexicalFixity -> rhs -> FamEqn pass rhs
[feqn_ext] :: FamEqn pass rhs -> XCFamEqn pass rhs
[feqn_tycon] :: FamEqn pass rhs -> LIdP pass

-- | Optional quantified type vars
[feqn_bndrs] :: FamEqn pass rhs -> HsOuterFamEqnTyVarBndrs pass
[feqn_pats] :: FamEqn pass rhs -> HsTyPats pass

-- | Fixity used in the declaration
[feqn_fixity] :: FamEqn pass rhs -> LexicalFixity

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnEqual</a></li>
--   </ul>
[feqn_rhs] :: FamEqn pass rhs -> rhs
XFamEqn :: !XXFamEqn pass rhs -> FamEqn pass rhs

-- | Type Family Instance Equation
type TyFamInstEqn pass = FamEqn pass (LHsType pass)

-- | Located Type Family Instance Equation
type LTyFamInstEqn pass = XRec pass (TyFamInstEqn pass) " May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' when in a list"

-- | Haskell Type Patterns
type HsTyPats pass = [LHsTypeArg pass]

-- | Located Class Instance Declaration
type LClsInstDecl pass = XRec pass (ClsInstDecl pass)

-- | Class Instance Declaration
data ClsInstDecl pass
ClsInstDecl :: XCClsInstDecl pass -> LHsSigType pass -> LHsBinds pass -> [LSig pass] -> [LTyFamInstDecl pass] -> [LDataFamInstDecl pass] -> Maybe (XRec pass OverlapMode) -> ClsInstDecl pass
[cid_ext] :: ClsInstDecl pass -> XCClsInstDecl pass
[cid_poly_ty] :: ClsInstDecl pass -> LHsSigType pass
[cid_binds] :: ClsInstDecl pass -> LHsBinds pass
[cid_sigs] :: ClsInstDecl pass -> [LSig pass]
[cid_tyfam_insts] :: ClsInstDecl pass -> [LTyFamInstDecl pass]
[cid_datafam_insts] :: ClsInstDecl pass -> [LDataFamInstDecl pass]

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnClose</a>,</li>
--   </ul>
[cid_overlap_mode] :: ClsInstDecl pass -> Maybe (XRec pass OverlapMode)
XClsInstDecl :: !XXClsInstDecl pass -> ClsInstDecl pass

-- | Stand-alone 'deriving instance' declaration
data DerivDecl pass
DerivDecl :: XCDerivDecl pass -> LHsSigWcType pass -> Maybe (LDerivStrategy pass) -> Maybe (XRec pass OverlapMode) -> DerivDecl pass
[deriv_ext] :: DerivDecl pass -> XCDerivDecl pass

-- | The instance type to derive.
--   
--   It uses an <a>LHsSigWcType</a> because the context is allowed to be a
--   single wildcard:
--   
--   <pre>
--   deriving instance _ =&gt; Eq (Foo a)
--   </pre>
--   
--   Which signifies that the context should be inferred.
[deriv_type] :: DerivDecl pass -> LHsSigWcType pass
[deriv_strategy] :: DerivDecl pass -> Maybe (LDerivStrategy pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDeriving</a>, <a>AnnInstance</a>,
--   <a>AnnStock</a>, <a>AnnAnyClass</a>, <a>AnnNewtype</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
[deriv_overlap_mode] :: DerivDecl pass -> Maybe (XRec pass OverlapMode)
XDerivDecl :: !XXDerivDecl pass -> DerivDecl pass

-- | Located stand-alone 'deriving instance' declaration
type LDerivDecl pass = XRec pass (DerivDecl pass)

-- | Which technique the user explicitly requested when deriving an
--   instance.
data DerivStrategy pass

-- | GHC's "standard" strategy, which is to implement a custom instance for
--   the data type. This only works for certain types that GHC knows about
--   (e.g., <a>Eq</a>, <a>Show</a>, <a>Functor</a> when
--   <tt>-XDeriveFunctor</tt> is enabled, etc.)
StockStrategy :: XStockStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
AnyclassStrategy :: XAnyClassStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
NewtypeStrategy :: XNewtypeStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XDerivingVia
--   </pre>
ViaStrategy :: XViaStrategy pass -> DerivStrategy pass

-- | A <a>Located</a> <a>DerivStrategy</a>.
type LDerivStrategy pass = XRec pass (DerivStrategy pass)

-- | A short description of a <tt>DerivStrategy'</tt>.
derivStrategyName :: DerivStrategy a -> SDoc

-- | Located Rule Declarations
type LRuleDecls pass = XRec pass (RuleDecls pass)

-- | Rule Declarations
data RuleDecls pass
HsRules :: XCRuleDecls pass -> SourceText -> [LRuleDecl pass] -> RuleDecls pass
[rds_ext] :: RuleDecls pass -> XCRuleDecls pass
[rds_src] :: RuleDecls pass -> SourceText
[rds_rules] :: RuleDecls pass -> [LRuleDecl pass]
XRuleDecls :: !XXRuleDecls pass -> RuleDecls pass

-- | Rule Declaration
data RuleDecl pass
HsRule :: XHsRule pass -> XRec pass (SourceText, RuleName) -> Activation -> Maybe [LHsTyVarBndr () (NoGhcTc pass)] -> [LRuleBndr pass] -> XRec pass (HsExpr pass) -> XRec pass (HsExpr pass) -> RuleDecl pass

-- | After renamer, free-vars from the LHS and RHS
[rd_ext] :: RuleDecl pass -> XHsRule pass

-- | Note [Pragma source text] in <a>GHC.Types.Basic</a>
[rd_name] :: RuleDecl pass -> XRec pass (SourceText, RuleName)
[rd_act] :: RuleDecl pass -> Activation

-- | Forall'd type vars
[rd_tyvs] :: RuleDecl pass -> Maybe [LHsTyVarBndr () (NoGhcTc pass)]

-- | Forall'd term vars, before typechecking; after typechecking this
--   includes all forall'd vars
[rd_tmvs] :: RuleDecl pass -> [LRuleBndr pass]
[rd_lhs] :: RuleDecl pass -> XRec pass (HsExpr pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,<a>AnnTilde</a>,
--   <a>AnnVal</a>, <a>AnnClose</a>, <a>AnnForall</a>,<a>AnnDot</a>,
--   <a>AnnEqual</a>,</li>
--   </ul>
[rd_rhs] :: RuleDecl pass -> XRec pass (HsExpr pass)
XRuleDecl :: !XXRuleDecl pass -> RuleDecl pass

-- | Located Rule Declaration
type LRuleDecl pass = XRec pass (RuleDecl pass)
data HsRuleRn
HsRuleRn :: NameSet -> NameSet -> HsRuleRn

-- | Rule Binder
data RuleBndr pass
RuleBndr :: XCRuleBndr pass -> LIdP pass -> RuleBndr pass
RuleBndrSig :: XRuleBndrSig pass -> LIdP pass -> HsPatSigType pass -> RuleBndr pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnDcolon</a>,<a>AnnClose</a></li>
--   </ul>
XRuleBndr :: !XXRuleBndr pass -> RuleBndr pass

-- | Located Rule Binder
type LRuleBndr pass = XRec pass (RuleBndr pass)
collectRuleBndrSigTys :: [RuleBndr pass] -> [HsPatSigType pass]
pprFullRuleName :: Located (SourceText, RuleName) -> SDoc

-- | Default Declaration
data DefaultDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnDefault</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
DefaultDecl :: XCDefaultDecl pass -> [LHsType pass] -> DefaultDecl pass
XDefaultDecl :: !XXDefaultDecl pass -> DefaultDecl pass

-- | Located Default Declaration
type LDefaultDecl pass = XRec pass (DefaultDecl pass)
data SpliceExplicitFlag

-- | <a>=</a> $(f x y)
ExplicitSplice :: SpliceExplicitFlag

-- | <a>=</a> f x y, i.e. a naked top level expression
ImplicitSplice :: SpliceExplicitFlag

-- | Splice Declaration
data SpliceDecl p
SpliceDecl :: XSpliceDecl p -> XRec p (HsSplice p) -> SpliceExplicitFlag -> SpliceDecl p
XSpliceDecl :: !XXSpliceDecl p -> SpliceDecl p

-- | Located Splice Declaration
type LSpliceDecl pass = XRec pass (SpliceDecl pass)

-- | Foreign Declaration
data ForeignDecl pass
ForeignImport :: XForeignImport pass -> LIdP pass -> LHsSigType pass -> ForeignImport -> ForeignDecl pass
[fd_i_ext] :: ForeignDecl pass -> XForeignImport pass
[fd_name] :: ForeignDecl pass -> LIdP pass
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fi] :: ForeignDecl pass -> ForeignImport

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnForeign</a>,
--   <a>AnnImport</a>,<a>AnnExport</a>, <a>AnnDcolon</a></li>
--   </ul>
ForeignExport :: XForeignExport pass -> LIdP pass -> LHsSigType pass -> ForeignExport -> ForeignDecl pass
[fd_e_ext] :: ForeignDecl pass -> XForeignExport pass
[fd_name] :: ForeignDecl pass -> LIdP pass
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fe] :: ForeignDecl pass -> ForeignExport
XForeignDecl :: !XXForeignDecl pass -> ForeignDecl pass

-- | Located Foreign Declaration
type LForeignDecl pass = XRec pass (ForeignDecl pass)
data ForeignImport
CImport :: Located CCallConv -> Located Safety -> Maybe Header -> CImportSpec -> Located SourceText -> ForeignImport
data ForeignExport
CExport :: Located CExportSpec -> Located SourceText -> ForeignExport
data CImportSpec
CLabel :: CLabelString -> CImportSpec
CFunction :: CCallTarget -> CImportSpec
CWrapper :: CImportSpec

-- | <pre>
--   data T b = forall a. Eq a =&gt; MkT a b
--     MkT :: forall b a. Eq a =&gt; MkT a b
--   
--   data T b where
--        MkT1 :: Int -&gt; T Int
--   
--   data T = Int <tt>MkT</tt> Int
--          | MkT2
--   
--   data T a where
--        Int <tt>MkT</tt> Int :: T Int
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a>,
--   <a>AnnDotdot</a>,<a>AnnCLose</a>, <a>AnnEqual</a>,<a>AnnVbar</a>,
--   <a>AnnDarrow</a>,<a>AnnDarrow</a>, <a>AnnForall</a>,<a>AnnDot</a></li>
--   </ul>
--   
--   data Constructor Declaration
data ConDecl pass
ConDeclGADT :: XConDeclGADT pass -> [LIdP pass] -> XRec pass (HsOuterSigTyVarBndrs pass) -> Maybe (LHsContext pass) -> HsConDeclGADTDetails pass -> LHsType pass -> Maybe LHsDocString -> ConDecl pass
[con_g_ext] :: ConDecl pass -> XConDeclGADT pass
[con_names] :: ConDecl pass -> [LIdP pass]

-- | The outermost type variable binders, be they explicit or implicit. The
--   <a>XRec</a> is used to anchor exact print annotations, AnnForall and
--   AnnDot.
[con_bndrs] :: ConDecl pass -> XRec pass (HsOuterSigTyVarBndrs pass)

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; never infix
[con_g_args] :: ConDecl pass -> HsConDeclGADTDetails pass

-- | Result type
[con_res_ty] :: ConDecl pass -> LHsType pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe LHsDocString
ConDeclH98 :: XConDeclH98 pass -> LIdP pass -> Bool -> [LHsTyVarBndr Specificity pass] -> Maybe (LHsContext pass) -> HsConDeclH98Details pass -> Maybe LHsDocString -> ConDecl pass
[con_ext] :: ConDecl pass -> XConDeclH98 pass
[con_name] :: ConDecl pass -> LIdP pass

-- | True <a>=</a> explicit user-written forall e.g. data T a = forall b.
--   MkT b (b-&gt;a) con_ex_tvs = {b} False =&gt; con_ex_tvs is empty
[con_forall] :: ConDecl pass -> Bool

-- | Existentials only
[con_ex_tvs] :: ConDecl pass -> [LHsTyVarBndr Specificity pass]

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; can be infix
[con_args] :: ConDecl pass -> HsConDeclH98Details pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe LHsDocString
XConDecl :: !XXConDecl pass -> ConDecl pass

-- | Located data Constructor Declaration
type LConDecl pass = XRec pass (ConDecl pass) " May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' when in a GADT constructor list"

-- | The arguments in a Haskell98-style data constructor.
type HsConDeclH98Details pass = HsConDetails Void (HsScaled pass (LBangType pass)) (XRec pass [LConDeclField pass])

-- | The arguments in a GADT constructor. Unlike Haskell98-style
--   constructors, GADT constructors cannot be declared with infix syntax.
--   As a result, we do not use <a>HsConDetails</a> here, as
--   <a>InfixCon</a> would be an unrepresentable state. (There is a notion
--   of infix GADT constructors for the purposes of derived Show
--   instancesâsee Note [Infix GADT constructors] in GHC.Tc.TyClâbut that
--   is an orthogonal concern.)
data HsConDeclGADTDetails pass
PrefixConGADT :: [HsScaled pass (LBangType pass)] -> HsConDeclGADTDetails pass
RecConGADT :: XRec pass [LConDeclField pass] -> HsConDeclGADTDetails pass

-- | Documentation comment Declaration
data DocDecl
DocCommentNext :: HsDocString -> DocDecl
DocCommentPrev :: HsDocString -> DocDecl
DocCommentNamed :: String -> HsDocString -> DocDecl
DocGroup :: Int -> HsDocString -> DocDecl

-- | Located Documentation comment Declaration
type LDocDecl pass = XRec pass (DocDecl)
docDeclDoc :: DocDecl -> HsDocString

-- | Warning pragma Declaration
data WarnDecl pass
Warning :: XWarning pass -> [LIdP pass] -> WarningTxt -> WarnDecl pass
XWarnDecl :: !XXWarnDecl pass -> WarnDecl pass

-- | Located Warning pragma Declaration
type LWarnDecl pass = XRec pass (WarnDecl pass)

-- | Warning pragma Declarations
data WarnDecls pass
Warnings :: XWarnings pass -> SourceText -> [LWarnDecl pass] -> WarnDecls pass
[wd_ext] :: WarnDecls pass -> XWarnings pass
[wd_src] :: WarnDecls pass -> SourceText
[wd_warnings] :: WarnDecls pass -> [LWarnDecl pass]
XWarnDecls :: !XXWarnDecls pass -> WarnDecls pass

-- | Located Warning Declarations
type LWarnDecls pass = XRec pass (WarnDecls pass)

-- | Annotation Declaration
data AnnDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnType</a>
--   <a>AnnModule</a> <a>AnnClose</a></li>
--   </ul>
HsAnnotation :: XHsAnnotation pass -> SourceText -> AnnProvenance pass -> XRec pass (HsExpr pass) -> AnnDecl pass
XAnnDecl :: !XXAnnDecl pass -> AnnDecl pass

-- | Located Annotation Declaration
type LAnnDecl pass = XRec pass (AnnDecl pass)

-- | Annotation Provenance
data AnnProvenance pass
ValueAnnProvenance :: LIdP pass -> AnnProvenance pass
TypeAnnProvenance :: LIdP pass -> AnnProvenance pass
ModuleAnnProvenance :: AnnProvenance pass
annProvenanceName_maybe :: forall p. UnXRec p => AnnProvenance p -> Maybe (IdP p)

-- | Role Annotation Declaration
data RoleAnnotDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnRole</a></li>
--   </ul>
RoleAnnotDecl :: XCRoleAnnotDecl pass -> LIdP pass -> [XRec pass (Maybe Role)] -> RoleAnnotDecl pass
XRoleAnnotDecl :: !XXRoleAnnotDecl pass -> RoleAnnotDecl pass

-- | Located Role Annotation Declaration
type LRoleAnnotDecl pass = XRec pass (RoleAnnotDecl pass)

-- | type Family Result Signature
data FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> :</li>
--   </ul>
NoSig :: XNoSig pass -> FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenP</a>,<a>AnnDcolon</a>,
--   <a>AnnCloseP</a></li>
--   </ul>
KindSig :: XCKindSig pass -> LHsKind pass -> FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenP</a>,<a>AnnDcolon</a>,
--   <a>AnnCloseP</a>, <a>AnnEqual</a></li>
--   </ul>
TyVarSig :: XTyVarSig pass -> LHsTyVarBndr () pass -> FamilyResultSig pass
XFamilyResultSig :: !XXFamilyResultSig pass -> FamilyResultSig pass

-- | Located type Family Result Signature
type LFamilyResultSig pass = XRec pass (FamilyResultSig pass)

-- | If the user supplied an injectivity annotation it is represented using
--   InjectivityAnn. At the moment this is a single injectivity condition -
--   see Note [Injectivity annotation]. `Located name` stores the LHS of
--   injectivity condition. `[Located name]` stores the RHS of injectivity
--   condition. Example:
--   
--   type family Foo a b c = r | r -&gt; a c where ...
--   
--   This will be represented as "InjectivityAnn <tt>r</tt> [<tt>a</tt>,
--   <tt>c</tt>]"
data InjectivityAnn pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a>, <a>AnnVbar</a></li>
--   </ul>
InjectivityAnn :: XCInjectivityAnn pass -> LIdP pass -> [LIdP pass] -> InjectivityAnn pass
XInjectivityAnn :: !XXInjectivityAnn pass -> InjectivityAnn pass

-- | Located Injectivity Annotation
type LInjectivityAnn pass = XRec pass (InjectivityAnn pass)

-- | Haskell Group
--   
--   A <a>HsDecl</a> is categorised into a <a>HsGroup</a> before being fed
--   to the renamer.
data HsGroup p
HsGroup :: XCHsGroup p -> HsValBinds p -> [LSpliceDecl p] -> [TyClGroup p] -> [LDerivDecl p] -> [LFixitySig p] -> [LDefaultDecl p] -> [LForeignDecl p] -> [LWarnDecls p] -> [LAnnDecl p] -> [LRuleDecls p] -> [LDocDecl p] -> HsGroup p
[hs_ext] :: HsGroup p -> XCHsGroup p
[hs_valds] :: HsGroup p -> HsValBinds p
[hs_splcds] :: HsGroup p -> [LSpliceDecl p]
[hs_tyclds] :: HsGroup p -> [TyClGroup p]
[hs_derivds] :: HsGroup p -> [LDerivDecl p]
[hs_fixds] :: HsGroup p -> [LFixitySig p]
[hs_defds] :: HsGroup p -> [LDefaultDecl p]
[hs_fords] :: HsGroup p -> [LForeignDecl p]
[hs_warnds] :: HsGroup p -> [LWarnDecls p]
[hs_annds] :: HsGroup p -> [LAnnDecl p]
[hs_ruleds] :: HsGroup p -> [LRuleDecls p]
[hs_docs] :: HsGroup p -> [LDocDecl p]
XHsGroup :: !XXHsGroup p -> HsGroup p
hsGroupInstDecls :: HsGroup id -> [LInstDecl id]
instance Data.Data.Data Language.Haskell.Syntax.Decls.DataDeclRn
instance Data.Data.Data Language.Haskell.Syntax.Decls.NewOrData
instance GHC.Classes.Eq Language.Haskell.Syntax.Decls.NewOrData
instance Data.Data.Data Language.Haskell.Syntax.Decls.CImportSpec
instance Data.Data.Data Language.Haskell.Syntax.Decls.ForeignImport
instance Data.Data.Data Language.Haskell.Syntax.Decls.ForeignExport
instance Data.Data.Data Language.Haskell.Syntax.Decls.HsRuleRn
instance Data.Data.Data Language.Haskell.Syntax.Decls.DocDecl
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Decls.DocDecl
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Decls.ForeignExport
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Decls.ForeignImport
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.FamilyInfo pass)
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Decls.NewOrData

module Language.Haskell.Syntax.Binds

-- | Haskell Local Bindings
type HsLocalBinds id = HsLocalBindsLR id id

-- | Located Haskell local bindings
type LHsLocalBinds id = XRec id (HsLocalBinds id)

-- | Haskell Local Bindings with separate Left and Right identifier types
--   
--   Bindings in a 'let' expression or a 'where' clause
data HsLocalBindsLR idL idR

-- | Haskell Value Bindings
HsValBinds :: XHsValBinds idL idR -> HsValBindsLR idL idR -> HsLocalBindsLR idL idR

-- | Haskell Implicit Parameter Bindings
HsIPBinds :: XHsIPBinds idL idR -> HsIPBinds idR -> HsLocalBindsLR idL idR

-- | Empty Local Bindings
EmptyLocalBinds :: XEmptyLocalBinds idL idR -> HsLocalBindsLR idL idR
XHsLocalBindsLR :: !XXHsLocalBindsLR idL idR -> HsLocalBindsLR idL idR
type LHsLocalBindsLR idL idR = XRec idL (HsLocalBindsLR idL idR)

-- | Haskell Value Bindings
type HsValBinds id = HsValBindsLR id id

-- | Haskell Value bindings with separate Left and Right identifier types
--   (not implicit parameters) Used for both top level and nested bindings
--   May contain pattern synonym bindings
data HsValBindsLR idL idR

-- | Value Bindings In
--   
--   Before renaming RHS; idR is always RdrName Not dependency analysed
--   Recursive by default
ValBinds :: XValBinds idL idR -> LHsBindsLR idL idR -> [LSig idR] -> HsValBindsLR idL idR

-- | Value Bindings Out
--   
--   After renaming RHS; idR can be Name or Id Dependency analysed, later
--   bindings in the list may depend on earlier ones.
XValBindsLR :: !XXValBindsLR idL idR -> HsValBindsLR idL idR

-- | Located Haskell Binding
type LHsBind id = LHsBindLR id id

-- | Located Haskell Bindings
type LHsBinds id = LHsBindsLR id id

-- | Haskell Binding
type HsBind id = HsBindLR id id

-- | Located Haskell Bindings with separate Left and Right identifier types
type LHsBindsLR idL idR = Bag (LHsBindLR idL idR)

-- | Located Haskell Binding with separate Left and Right identifier types
type LHsBindLR idL idR = XRec idL (HsBindLR idL idR)

-- | Haskell Binding with separate Left and Right id's
data HsBindLR idL idR

-- | Function-like Binding
--   
--   FunBind is used for both functions <tt>f x = e</tt> and variables
--   <tt>f = x -&gt; e</tt> and strict variables <tt>!x = x + 1</tt>
--   
--   Reason 1: Special case for type inference: see <a>tcMonoBinds</a>.
--   
--   Reason 2: Instance decls can only have FunBinds, which is convenient.
--   If you change this, you'll need to change e.g. rnMethodBinds
--   
--   But note that the form <tt>f :: a-&gt;a = ...</tt> parses as a pattern
--   binding, just like <tt>(f :: a -&gt; a) = ... </tt>
--   
--   Strict bindings have their strictness recorded in the
--   <a>SrcStrictness</a> of their <tt>MatchContext</tt>. See Note [FunBind
--   vs PatBind] for details about the relationship between FunBind and
--   PatBind.
--   
--   <a>AnnKeywordId</a>s
--   
--   <ul>
--   <li><a>AnnFunId</a>, attached to each element of fun_matches</li>
--   <li><a>AnnEqual</a>,<a>AnnWhere</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a>,</li>
--   </ul>
FunBind :: XFunBind idL idR -> LIdP idL -> MatchGroup idR (LHsExpr idR) -> [CoreTickish] -> HsBindLR idL idR

-- | After the renamer (but before the type-checker), this contains the
--   locally-bound free variables of this defn. See Note [Bind free vars]
--   
--   After the type-checker, this contains a coercion from the type of the
--   MatchGroup to the type of the Id. Example:
--   
--   <pre>
--   f :: Int -&gt; forall a. a -&gt; a
--   f x y = y
--   </pre>
--   
--   Then the MatchGroup will have type (Int -&gt; a' -&gt; a') (with a
--   free type variable a'). The coercion will take a CoreExpr of this type
--   and convert it to a CoreExpr of type Int -&gt; forall a'. a' -&gt; a'
--   Notice that the coercion captures the free a'.
[fun_ext] :: HsBindLR idL idR -> XFunBind idL idR
[fun_id] :: HsBindLR idL idR -> LIdP idL

-- | The payload
[fun_matches] :: HsBindLR idL idR -> MatchGroup idR (LHsExpr idR)

-- | Ticks to put on the rhs, if any
[fun_tick] :: HsBindLR idL idR -> [CoreTickish]

-- | Pattern Binding
--   
--   The pattern is never a simple variable; That case is done by FunBind.
--   See Note [FunBind vs PatBind] for details about the relationship
--   between FunBind and PatBind.
PatBind :: XPatBind idL idR -> LPat idL -> GRHSs idR (LHsExpr idR) -> ([CoreTickish], [[CoreTickish]]) -> HsBindLR idL idR

-- | See Note [Bind free vars]
[pat_ext] :: HsBindLR idL idR -> XPatBind idL idR
[pat_lhs] :: HsBindLR idL idR -> LPat idL
[pat_rhs] :: HsBindLR idL idR -> GRHSs idR (LHsExpr idR)

-- | Ticks to put on the rhs, if any, and ticks to put on the bound
--   variables.
[pat_ticks] :: HsBindLR idL idR -> ([CoreTickish], [[CoreTickish]])

-- | Variable Binding
--   
--   Dictionary binding and suchlike. All VarBinds are introduced by the
--   type checker
VarBind :: XVarBind idL idR -> IdP idL -> LHsExpr idR -> HsBindLR idL idR
[var_ext] :: HsBindLR idL idR -> XVarBind idL idR
[var_id] :: HsBindLR idL idR -> IdP idL

-- | Located only for consistency
[var_rhs] :: HsBindLR idL idR -> LHsExpr idR

-- | Abstraction Bindings
AbsBinds :: XAbsBinds idL idR -> [TyVar] -> [EvVar] -> [ABExport idL] -> [TcEvBinds] -> LHsBinds idL -> Bool -> HsBindLR idL idR
[abs_ext] :: HsBindLR idL idR -> XAbsBinds idL idR
[abs_tvs] :: HsBindLR idL idR -> [TyVar]

-- | Includes equality constraints
[abs_ev_vars] :: HsBindLR idL idR -> [EvVar]

-- | AbsBinds only gets used when idL = idR after renaming, but these need
--   to be idL's for the collect... code in HsUtil to have the right type
[abs_exports] :: HsBindLR idL idR -> [ABExport idL]

-- | Evidence bindings Why a list? See <a>GHC.Tc.TyCl.Instance</a> Note
--   [Typechecking plan for instance declarations]
[abs_ev_binds] :: HsBindLR idL idR -> [TcEvBinds]

-- | Typechecked user bindings
[abs_binds] :: HsBindLR idL idR -> LHsBinds idL
[abs_sig] :: HsBindLR idL idR -> Bool

-- | Patterns Synonym Binding
PatSynBind :: XPatSynBind idL idR -> PatSynBind idL idR -> HsBindLR idL idR
XHsBindsLR :: !XXHsBindsLR idL idR -> HsBindLR idL idR

-- | Abstraction Bindings Export
data ABExport p
ABE :: XABE p -> IdP p -> IdP p -> HsWrapper -> TcSpecPrags -> ABExport p
[abe_ext] :: ABExport p -> XABE p

-- | Any INLINE pragma is attached to this Id
[abe_poly] :: ABExport p -> IdP p
[abe_mono] :: ABExport p -> IdP p

-- | See Note [ABExport wrapper] Shape: (forall abs_tvs. abs_ev_vars =&gt;
--   abe_mono) ~ abe_poly
[abe_wrap] :: ABExport p -> HsWrapper

-- | SPECIALISE pragmas
[abe_prags] :: ABExport p -> TcSpecPrags
XABExport :: !XXABExport p -> ABExport p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnPattern</a>,
--   <a>AnnEqual</a>,<a>AnnLarrow</a>, <a>AnnWhere</a>,<a>AnnOpen</a>
--   <tt>'{'</tt>, <a>AnnClose</a> <tt>'}'</tt>,</li>
--   </ul>
--   
--   Pattern Synonym binding
data PatSynBind idL idR
PSB :: XPSB idL idR -> LIdP idL -> HsPatSynDetails idR -> LPat idR -> HsPatSynDir idR -> PatSynBind idL idR

-- | Post renaming, FVs. See Note [Bind free vars]
[psb_ext] :: PatSynBind idL idR -> XPSB idL idR

-- | Name of the pattern synonym
[psb_id] :: PatSynBind idL idR -> LIdP idL

-- | Formal parameter names
[psb_args] :: PatSynBind idL idR -> HsPatSynDetails idR

-- | Right-hand side
[psb_def] :: PatSynBind idL idR -> LPat idR

-- | Directionality
[psb_dir] :: PatSynBind idL idR -> HsPatSynDir idR
XPatSynBind :: !XXPatSynBind idL idR -> PatSynBind idL idR

-- | Haskell Implicit Parameter Bindings
data HsIPBinds id
IPBinds :: XIPBinds id -> [LIPBind id] -> HsIPBinds id
XHsIPBinds :: !XXHsIPBinds id -> HsIPBinds id

-- | Located Implicit Parameter Binding
--   
--   May have <a>AnnKeywordId</a> : <a>AnnSemi</a> when in a list
type LIPBind id = XRec id (IPBind id)

-- | Implicit parameter bindings.
--   
--   These bindings start off as (Left "x") in the parser and stay that way
--   until after type-checking when they are replaced with (Right d), where
--   "d" is the name of the dictionary holding the evidence for the
--   implicit parameter.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnEqual</a></li>
--   </ul>
data IPBind id
IPBind :: XCIPBind id -> Either (XRec id HsIPName) (IdP id) -> LHsExpr id -> IPBind id
XIPBind :: !XXIPBind id -> IPBind id

-- | Located Signature
type LSig pass = XRec pass (Sig pass)

-- | Signatures and pragmas
data Sig pass

-- | An ordinary type signature
--   
--   <pre>
--   f :: Num a =&gt; a -&gt; a
--   </pre>
--   
--   After renaming, this list of Names contains the named wildcards
--   brought into scope by this signature. For a signature <tt>_ -&gt; _a
--   -&gt; Bool</tt>, the renamer will leave the unnamed wildcard
--   <tt>_</tt> untouched, and the named wildcard <tt>_a</tt> is then
--   replaced with fresh meta vars in the type. Their names are stored in
--   the type signature that brought them into scope, in this third field
--   to be more specific.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a>, <a>AnnComma</a></li>
--   </ul>
TypeSig :: XTypeSig pass -> [LIdP pass] -> LHsSigWcType pass -> Sig pass

-- | A pattern synonym type signature
--   
--   <pre>
--   pattern Single :: () =&gt; (Show a) =&gt; a -&gt; [a]
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnPattern</a>,
--   <a>AnnDcolon</a>,<a>AnnForall</a> <a>AnnDot</a>,<a>AnnDarrow</a></li>
--   </ul>
PatSynSig :: XPatSynSig pass -> [LIdP pass] -> LHsSigType pass -> Sig pass

-- | A signature for a class method False: ordinary class-method signature
--   True: generic-default class method signature e.g. class C a where op
--   :: a -&gt; a -- Ordinary default op :: Eq a =&gt; a -&gt; a -- Generic
--   default No wildcards allowed here
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDefault</a>, <a>AnnDcolon</a></li>
--   </ul>
ClassOpSig :: XClassOpSig pass -> Bool -> [LIdP pass] -> LHsSigType pass -> Sig pass

-- | A type signature in generated code, notably the code generated for
--   record selectors. We simply record the desired Id itself, replete with
--   its name, type and IdDetails. Otherwise it's just like a type
--   signature: there should be an accompanying binding
IdSig :: XIdSig pass -> Id -> Sig pass

-- | An ordinary fixity declaration
--   
--   <pre>
--   infixl 8 ***
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnInfix</a>, <a>AnnVal</a></li>
--   </ul>
FixSig :: XFixSig pass -> FixitySig pass -> Sig pass

-- | An inline pragma
--   
--   <pre>
--   {#- INLINE f #-}
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# INLINE'</tt> and
--   <tt>'['</tt>, <a>AnnClose</a>,<a>AnnOpen</a>,
--   <a>AnnVal</a>,<a>AnnTilde</a>, <a>AnnClose</a></li>
--   </ul>
InlineSig :: XInlineSig pass -> LIdP pass -> InlinePragma -> Sig pass

-- | A specialisation pragma
--   
--   <pre>
--   {-# SPECIALISE f :: Int -&gt; Int #-}
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnOpen</a> <tt>'{-#
--   SPECIALISE'</tt> and <tt>'['</tt>, <a>AnnTilde</a>, <a>AnnVal</a>,
--   <a>AnnClose</a> <tt>']'</tt> and <tt>'#-}'</tt>, <a>AnnDcolon</a></li>
--   </ul>
SpecSig :: XSpecSig pass -> LIdP pass -> [LHsSigType pass] -> InlinePragma -> Sig pass

-- | A specialisation pragma for instance declarations only
--   
--   <pre>
--   {-# SPECIALISE instance Eq [Int] #-}
--   </pre>
--   
--   (Class tys); should be a specialisation of the current instance
--   declaration
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnInstance</a>,<a>AnnClose</a></li>
--   </ul>
SpecInstSig :: XSpecInstSig pass -> SourceText -> LHsSigType pass -> Sig pass

-- | A minimal complete definition pragma
--   
--   <pre>
--   {-# MINIMAL a | (b, c | (d | e)) #-}
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnVbar</a>,<a>AnnComma</a>, <a>AnnClose</a></li>
--   </ul>
MinimalSig :: XMinimalSig pass -> SourceText -> LBooleanFormula (LIdP pass) -> Sig pass

-- | A "set cost centre" pragma for declarations
--   
--   <pre>
--   {-# SCC funName #-}
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# SCC funName "cost_centre_name" #-}
--   </pre>
SCCFunSig :: XSCCFunSig pass -> SourceText -> LIdP pass -> Maybe (XRec pass StringLiteral) -> Sig pass

-- | A complete match pragma
--   
--   <pre>
--   {-# COMPLETE C, D [:: T] #-}
--   </pre>
--   
--   Used to inform the pattern match checker about additional complete
--   matchings which, for example, arise from pattern synonym definitions.
CompleteMatchSig :: XCompleteMatchSig pass -> SourceText -> XRec pass [LIdP pass] -> Maybe (LIdP pass) -> Sig pass
XSig :: !XXSig pass -> Sig pass

-- | Located Fixity Signature
type LFixitySig pass = XRec pass (FixitySig pass)

-- | Fixity Signature
data FixitySig pass
FixitySig :: XFixitySig pass -> [LIdP pass] -> Fixity -> FixitySig pass
XFixitySig :: !XXFixitySig pass -> FixitySig pass

-- | Type checker Specialisation Pragmas
--   
--   <a>TcSpecPrags</a> conveys <tt>SPECIALISE</tt> pragmas from the type
--   checker to the desugarer
data TcSpecPrags

-- | Super-specialised: a default method should be macro-expanded at every
--   call site
IsDefaultMethod :: TcSpecPrags
SpecPrags :: [LTcSpecPrag] -> TcSpecPrags

-- | Located Type checker Specification Pragmas
type LTcSpecPrag = Located TcSpecPrag

-- | Type checker Specification Pragma
data TcSpecPrag

-- | The Id to be specialised, a wrapper that specialises the polymorphic
--   function, and inlining spec for the specialised function
SpecPrag :: Id -> HsWrapper -> InlinePragma -> TcSpecPrag
noSpecPrags :: TcSpecPrags
hasSpecPrags :: TcSpecPrags -> Bool
isDefaultMethod :: TcSpecPrags -> Bool
isFixityLSig :: forall p. UnXRec p => LSig p -> Bool
isTypeLSig :: forall p. UnXRec p => LSig p -> Bool
isSpecLSig :: forall p. UnXRec p => LSig p -> Bool
isSpecInstLSig :: forall p. UnXRec p => LSig p -> Bool
isPragLSig :: forall p. UnXRec p => LSig p -> Bool
isInlineLSig :: forall p. UnXRec p => LSig p -> Bool
isMinimalLSig :: forall p. UnXRec p => LSig p -> Bool
isSCCFunSig :: forall p. UnXRec p => LSig p -> Bool
isCompleteMatchSig :: forall p. UnXRec p => LSig p -> Bool
hsSigDoc :: Sig name -> SDoc

-- | Haskell Pattern Synonym Details
type HsPatSynDetails pass = HsConDetails Void (LIdP pass) [RecordPatSynField pass]

-- | Record Pattern Synonym Field
data RecordPatSynField pass
RecordPatSynField :: FieldOcc pass -> LIdP pass -> RecordPatSynField pass

-- | Field label visible in rest of the file
[recordPatSynField] :: RecordPatSynField pass -> FieldOcc pass

-- | Filled in by renamer, the name used internally by the pattern
[recordPatSynPatVar] :: RecordPatSynField pass -> LIdP pass

-- | Haskell Pattern Synonym Direction
data HsPatSynDir id
Unidirectional :: HsPatSynDir id
ImplicitBidirectional :: HsPatSynDir id
ExplicitBidirectional :: MatchGroup id (LHsExpr id) -> HsPatSynDir id
instance Data.Data.Data Language.Haskell.Syntax.Binds.TcSpecPrag
instance Data.Data.Data Language.Haskell.Syntax.Binds.TcSpecPrags
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.RecordPatSynField a)


-- | Warnings for a module
module GHC.Unit.Module.Warnings

-- | Warning information for a module
data Warnings

-- | Nothing deprecated
NoWarnings :: Warnings

-- | Whole module deprecated
WarnAll :: WarningTxt -> Warnings

-- | Some specific things deprecated
WarnSome :: [(OccName, WarningTxt)] -> Warnings

-- | Warning Text
--   
--   reason/explanation from a WARNING or DEPRECATED pragma
data WarningTxt
WarningTxt :: Located SourceText -> [Located StringLiteral] -> WarningTxt
DeprecatedTxt :: Located SourceText -> [Located StringLiteral] -> WarningTxt
pprWarningTxtForMsg :: WarningTxt -> SDoc

-- | Constructs the cache for the <tt>mi_warn_fn</tt> field of a
--   <tt>ModIface</tt>
mkIfaceWarnCache :: Warnings -> OccName -> Maybe WarningTxt
emptyIfaceWarnCache :: OccName -> Maybe WarningTxt
plusWarns :: Warnings -> Warnings -> Warnings
instance Data.Data.Data GHC.Unit.Module.Warnings.WarningTxt
instance GHC.Classes.Eq GHC.Unit.Module.Warnings.WarningTxt
instance GHC.Classes.Eq GHC.Unit.Module.Warnings.Warnings
instance GHC.Utils.Binary.Binary GHC.Unit.Module.Warnings.Warnings
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Warnings.WarningTxt
instance GHC.Utils.Binary.Binary GHC.Unit.Module.Warnings.WarningTxt

module GHC.Hs.Doc

-- | Haskell Documentation String
--   
--   Internally this is a UTF8-Encoded <a>ByteString</a>.
data HsDocString

-- | Located Haskell Documentation String
type LHsDocString = Located HsDocString
mkHsDocString :: String -> HsDocString

-- | Create a <a>HsDocString</a> from a UTF8-encoded <a>ByteString</a>.
mkHsDocStringUtf8ByteString :: ByteString -> HsDocString
isEmptyDocString :: HsDocString -> Bool
unpackHDS :: HsDocString -> String

-- | Return the contents of a <a>HsDocString</a> as a UTF8-encoded
--   <a>ByteString</a>.
hsDocStringToByteString :: HsDocString -> ByteString
ppr_mbDoc :: Maybe LHsDocString -> SDoc

-- | Join two docstrings.
--   
--   Non-empty docstrings are joined with two newlines in between,
--   resulting in separate paragraphs.
appendDocs :: HsDocString -> HsDocString -> HsDocString

-- | Concat docstrings with two newlines in between.
--   
--   Empty docstrings are skipped.
--   
--   If all inputs are empty, <a>Nothing</a> is returned.
concatDocs :: [HsDocString] -> Maybe HsDocString

-- | Docs for declarations: functions, data types, instances, methods etc.
newtype DeclDocMap
DeclDocMap :: Map Name HsDocString -> DeclDocMap
emptyDeclDocMap :: DeclDocMap

-- | Docs for arguments. E.g. function arguments, method arguments.
newtype ArgDocMap
ArgDocMap :: Map Name (IntMap HsDocString) -> ArgDocMap
emptyArgDocMap :: ArgDocMap

-- | Maps of docs that were added via Template Haskell's <tt>putDoc</tt>.
data ExtractedTHDocs
ExtractedTHDocs :: Maybe HsDocString -> DeclDocMap -> ArgDocMap -> DeclDocMap -> ExtractedTHDocs

-- | The added module header documentation, if it exists.
[ethd_mod_header] :: ExtractedTHDocs -> Maybe HsDocString

-- | The documentation added to declarations.
[ethd_decl_docs] :: ExtractedTHDocs -> DeclDocMap

-- | The documentation added to function arguments.
[ethd_arg_docs] :: ExtractedTHDocs -> ArgDocMap

-- | The documentation added to class and family instances.
[ethd_inst_docs] :: ExtractedTHDocs -> DeclDocMap
instance Data.Data.Data GHC.Hs.Doc.HsDocString
instance GHC.Show.Show GHC.Hs.Doc.HsDocString
instance GHC.Classes.Eq GHC.Hs.Doc.HsDocString
instance GHC.Utils.Binary.Binary GHC.Hs.Doc.ArgDocMap
instance GHC.Utils.Outputable.Outputable GHC.Hs.Doc.ArgDocMap
instance GHC.Utils.Binary.Binary GHC.Hs.Doc.DeclDocMap
instance GHC.Utils.Outputable.Outputable GHC.Hs.Doc.DeclDocMap
instance GHC.Utils.Binary.Binary GHC.Hs.Doc.HsDocString
instance GHC.Utils.Outputable.Outputable GHC.Hs.Doc.HsDocString


-- | Various types used during typechecking.
--   
--   Please see <a>GHC.Tc.Utils.Monad</a> as well for operations on these
--   types. You probably want to import it, instead of this module.
--   
--   All the monads exported here are built on top of the same IOEnv monad.
--   The monad functions like a Reader monad in the way it passes the
--   environment around. This is done to allow the environment to be
--   manipulated in a stack like fashion when entering expressions... etc.
--   
--   For state that is global and should be returned at the end (e.g not
--   part of the stack mechanism), you should use a TcRef (= IORef) to
--   store them.
module GHC.Tc.Types
type TcRnIf a b = IOEnv (Env a b)
type TcRn = TcRnIf TcGblEnv TcLclEnv

-- | Historical "type-checking monad" (now it's just <a>TcRn</a>).
type TcM = TcRn

-- | Historical "renaming monad" (now it's just <a>TcRn</a>).
type RnM = TcRn
type IfM lcl = TcRnIf IfGblEnv lcl
type IfL = IfM IfLclEnv
type IfG = IfM ()

-- | Type alias for <a>IORef</a>; the convention is we'll use this for
--   mutable bits of data in <a>TcGblEnv</a> which are updated during
--   typechecking and returned at the end.
type TcRef a = IORef a
data Env gbl lcl
Env :: !HscEnv -> !Char -> gbl -> lcl -> Env gbl lcl
[env_top] :: Env gbl lcl -> !HscEnv
[env_um] :: Env gbl lcl -> !Char
[env_gbl] :: Env gbl lcl -> gbl
[env_lcl] :: Env gbl lcl -> lcl

-- | <a>TcGblEnv</a> describes the top-level of the module at the point at
--   which the typechecker is finished work. It is this structure that is
--   handed on to the desugarer For state that needs to be updated during
--   the typechecking phase and returned at end, use a <a>TcRef</a> (=
--   <a>IORef</a>).
data TcGblEnv
TcGblEnv :: Module -> Module -> HscSource -> GlobalRdrEnv -> Maybe [Type] -> FixityEnv -> RecFieldEnv -> TypeEnv -> TcRef TypeEnv -> !InstEnv -> !FamInstEnv -> AnnEnv -> [AvailInfo] -> ImportAvails -> DefUses -> TcRef [GlobalRdrElt] -> TcRef NameSet -> TcRef Bool -> TcRef Bool -> TcRef OccSet -> [(Module, Fingerprint)] -> Maybe [(LIE GhcRn, Avails)] -> [LImportDecl GhcRn] -> Maybe (HsGroup GhcRn) -> TcRef [FilePath] -> TcRef [LHsDecl GhcPs] -> TcRef [(ForeignSrcLang, FilePath)] -> TcRef NameSet -> TcRef [(TcLclEnv, ThModFinalizers)] -> TcRef [String] -> TcRef (Map TypeRep Dynamic) -> TcRef (Maybe (ForeignRef (IORef QState))) -> TcRef THDocs -> Bag EvBind -> Maybe Id -> LHsBinds GhcTc -> NameSet -> [LTcSpecPrag] -> Warnings -> [Annotation] -> [TyCon] -> NameSet -> [ClsInst] -> [FamInst] -> [LRuleDecl GhcTc] -> [LForeignDecl GhcTc] -> [PatSyn] -> Maybe LHsDocString -> !AnyHpcUsage -> SelfBootInfo -> Maybe Name -> TcRef (Bool, WarningMessages) -> [TcPluginSolver] -> [HoleFitPlugin] -> RealSrcSpan -> TcRef WantedConstraints -> !CompleteMatches -> TcRef CostCentreState -> TcGblEnv

-- | Module being compiled
[tcg_mod] :: TcGblEnv -> Module

-- | If a signature, the backing module See also Note [Identity versus
--   semantic module]
[tcg_semantic_mod] :: TcGblEnv -> Module

-- | What kind of module (regular Haskell, hs-boot, hsig)
[tcg_src] :: TcGblEnv -> HscSource

-- | Top level envt; used during renaming
[tcg_rdr_env] :: TcGblEnv -> GlobalRdrEnv

-- | Types used for defaulting. <tt>Nothing</tt> =&gt; no <tt>default</tt>
--   decl
[tcg_default] :: TcGblEnv -> Maybe [Type]

-- | Just for things in this module
[tcg_fix_env] :: TcGblEnv -> FixityEnv

-- | Just for things in this module See Note [The interactive package] in
--   <a>GHC.Runtime.Context</a>
[tcg_field_env] :: TcGblEnv -> RecFieldEnv

-- | Global type env for the module we are compiling now. All TyCons and
--   Classes (for this module) end up in here right away, along with their
--   derived constructors, selectors.
--   
--   (Ids defined in this module start in the local envt, though they move
--   to the global envt during zonking)
--   
--   NB: for what "things in this module" means, see Note [The interactive
--   package] in <a>GHC.Runtime.Context</a>
[tcg_type_env] :: TcGblEnv -> TypeEnv
[tcg_type_env_var] :: TcGblEnv -> TcRef TypeEnv

-- | Instance envt for all <i>home-package</i> modules; Includes the dfuns
--   in tcg_insts NB. BangPattern is to fix a leak, see #15111
[tcg_inst_env] :: TcGblEnv -> !InstEnv

-- | Ditto for family instances NB. BangPattern is to fix a leak, see
--   #15111
[tcg_fam_inst_env] :: TcGblEnv -> !FamInstEnv

-- | And for annotations
[tcg_ann_env] :: TcGblEnv -> AnnEnv

-- | What is exported
[tcg_exports] :: TcGblEnv -> [AvailInfo]

-- | Information about what was imported from where, including things bound
--   in this module. Also store Safe Haskell info here about transitive
--   trusted package requirements.
--   
--   There are not many uses of this field, so you can grep for all them.
--   
--   The ImportAvails records information about the following things:
--   
--   <ol>
--   <li>All of the modules you directly imported (tcRnImports)</li>
--   <li>The orphans (only!) of all imported modules in a GHCi session
--   (runTcInteractive)</li>
--   <li>The module that instantiated a signature</li>
--   <li>Each of the signatures that merged in</li>
--   </ol>
--   
--   It is used in the following ways: - imp_orphs is used to determine
--   what orphan modules should be visible in the context
--   (tcVisibleOrphanMods) - imp_finsts is used to determine what family
--   instances should be visible (tcExtendLocalFamInstEnv) - To resolve the
--   meaning of the export list of a module (tcRnExports) - imp_mods is
--   used to compute usage info (mkIfaceTc, deSugar) - imp_trust_own_pkg is
--   used for Safe Haskell in interfaces (mkIfaceTc, as well as in
--   <a>GHC.Driver.Main</a>) - To create the Dependencies field in
--   interface (mkDependencies)
[tcg_imports] :: TcGblEnv -> ImportAvails
[tcg_dus] :: TcGblEnv -> DefUses
[tcg_used_gres] :: TcGblEnv -> TcRef [GlobalRdrElt]
[tcg_keep] :: TcGblEnv -> TcRef NameSet

-- | <tt>True</tt> &lt;=&gt; Template Haskell syntax used.
--   
--   We need this so that we can generate a dependency on the Template
--   Haskell package, because the desugarer is going to emit loads of
--   references to TH symbols. The reference is implicit rather than
--   explicit, so we have to zap a mutable variable.
[tcg_th_used] :: TcGblEnv -> TcRef Bool

-- | <tt>True</tt> &lt;=&gt; A Template Haskell splice was used.
--   
--   Splices disable recompilation avoidance (see #481)
[tcg_th_splice_used] :: TcGblEnv -> TcRef Bool

-- | Allows us to choose unique DFun names.
[tcg_dfun_n] :: TcGblEnv -> TcRef OccSet

-- | The requirements we merged with; we always have to recompile if any of
--   these changed.
[tcg_merged] :: TcGblEnv -> [(Module, Fingerprint)]
[tcg_rn_exports] :: TcGblEnv -> Maybe [(LIE GhcRn, Avails)]
[tcg_rn_imports] :: TcGblEnv -> [LImportDecl GhcRn]

-- | Renamed decls, maybe. <tt>Nothing</tt> &lt;=&gt; Don't retain renamed
--   decls.
[tcg_rn_decls] :: TcGblEnv -> Maybe (HsGroup GhcRn)

-- | dependencies from addDependentFile
[tcg_dependent_files] :: TcGblEnv -> TcRef [FilePath]

-- | Top-level declarations from addTopDecls
[tcg_th_topdecls] :: TcGblEnv -> TcRef [LHsDecl GhcPs]

-- | Foreign files emitted from TH.
[tcg_th_foreign_files] :: TcGblEnv -> TcRef [(ForeignSrcLang, FilePath)]

-- | Exact names bound in top-level declarations in tcg_th_topdecls
[tcg_th_topnames] :: TcGblEnv -> TcRef NameSet

-- | Template Haskell module finalizers.
--   
--   They can use particular local environments.
[tcg_th_modfinalizers] :: TcGblEnv -> TcRef [(TcLclEnv, ThModFinalizers)]

-- | Core plugins added by Template Haskell code.
[tcg_th_coreplugins] :: TcGblEnv -> TcRef [String]
[tcg_th_state] :: TcGblEnv -> TcRef (Map TypeRep Dynamic)

-- | Template Haskell state
[tcg_th_remote_state] :: TcGblEnv -> TcRef (Maybe (ForeignRef (IORef QState)))

-- | Docs added in Template Haskell via <tt>putDoc</tt>.
[tcg_th_docs] :: TcGblEnv -> TcRef THDocs
[tcg_ev_binds] :: TcGblEnv -> Bag EvBind
[tcg_tr_module] :: TcGblEnv -> Maybe Id
[tcg_binds] :: TcGblEnv -> LHsBinds GhcTc
[tcg_sigs] :: TcGblEnv -> NameSet
[tcg_imp_specs] :: TcGblEnv -> [LTcSpecPrag]
[tcg_warns] :: TcGblEnv -> Warnings
[tcg_anns] :: TcGblEnv -> [Annotation]
[tcg_tcs] :: TcGblEnv -> [TyCon]
[tcg_ksigs] :: TcGblEnv -> NameSet
[tcg_insts] :: TcGblEnv -> [ClsInst]
[tcg_fam_insts] :: TcGblEnv -> [FamInst]
[tcg_rules] :: TcGblEnv -> [LRuleDecl GhcTc]
[tcg_fords] :: TcGblEnv -> [LForeignDecl GhcTc]
[tcg_patsyns] :: TcGblEnv -> [PatSyn]

-- | Maybe Haddock header docs
[tcg_doc_hdr] :: TcGblEnv -> Maybe LHsDocString

-- | <tt>True</tt> if any part of the prog uses hpc instrumentation. NB.
--   BangPattern is to fix a leak, see #15111
[tcg_hpc] :: TcGblEnv -> !AnyHpcUsage

-- | Whether this module has a corresponding hi-boot file
[tcg_self_boot] :: TcGblEnv -> SelfBootInfo

-- | The Name of the main function, if this module is the main module.
[tcg_main] :: TcGblEnv -> Maybe Name

-- | Has the typechecker inferred this module as -XSafe (Safe Haskell) See
--   Note [Safe Haskell Overlapping Instances Implementation], although
--   this is used for more than just that failure case.
[tcg_safeInfer] :: TcGblEnv -> TcRef (Bool, WarningMessages)

-- | A list of user-defined plugins for the constraint solver.
[tcg_tc_plugins] :: TcGblEnv -> [TcPluginSolver]

-- | A list of user-defined plugins for hole fit suggestions.
[tcg_hf_plugins] :: TcGblEnv -> [HoleFitPlugin]

-- | The RealSrcSpan this module came from
[tcg_top_loc] :: TcGblEnv -> RealSrcSpan

-- | Wanted constraints of static forms. See Note [Constraints in static
--   forms].
[tcg_static_wc] :: TcGblEnv -> TcRef WantedConstraints

-- | Tracking indices for cost centre annotations
[tcg_complete_matches] :: TcGblEnv -> !CompleteMatches
[tcg_cc_st] :: TcGblEnv -> TcRef CostCentreState
data TcLclEnv
TcLclEnv :: RealSrcSpan -> [ErrCtxt] -> Bool -> TcLevel -> ThStage -> ThBindEnv -> ArrowCtxt -> LocalRdrEnv -> TcTypeEnv -> TcRef UsageEnv -> TcBinderStack -> TcRef WantedConstraints -> TcRef (Messages DecoratedSDoc) -> TcLclEnv
[tcl_loc] :: TcLclEnv -> RealSrcSpan
[tcl_ctxt] :: TcLclEnv -> [ErrCtxt]
[tcl_in_gen_code] :: TcLclEnv -> Bool
[tcl_tclvl] :: TcLclEnv -> TcLevel
[tcl_th_ctxt] :: TcLclEnv -> ThStage
[tcl_th_bndrs] :: TcLclEnv -> ThBindEnv
[tcl_arrow_ctxt] :: TcLclEnv -> ArrowCtxt
[tcl_rdr] :: TcLclEnv -> LocalRdrEnv
[tcl_env] :: TcLclEnv -> TcTypeEnv
[tcl_usage] :: TcLclEnv -> TcRef UsageEnv
[tcl_bndrs] :: TcLclEnv -> TcBinderStack
[tcl_lie] :: TcLclEnv -> TcRef WantedConstraints
[tcl_errs] :: TcLclEnv -> TcRef (Messages DecoratedSDoc)
setLclEnvTcLevel :: TcLclEnv -> TcLevel -> TcLclEnv
getLclEnvTcLevel :: TcLclEnv -> TcLevel
setLclEnvLoc :: TcLclEnv -> RealSrcSpan -> TcLclEnv
getLclEnvLoc :: TcLclEnv -> RealSrcSpan
data IfGblEnv
IfGblEnv :: SDoc -> Maybe (Module, IfG TypeEnv) -> IfGblEnv
[if_doc] :: IfGblEnv -> SDoc
[if_rec_types] :: IfGblEnv -> Maybe (Module, IfG TypeEnv)
data IfLclEnv
IfLclEnv :: Module -> IsBootInterface -> SDoc -> Maybe NameShape -> Maybe TypeEnv -> FastStringEnv TyVar -> FastStringEnv Id -> IfLclEnv
[if_mod] :: IfLclEnv -> Module
[if_boot] :: IfLclEnv -> IsBootInterface
[if_loc] :: IfLclEnv -> SDoc
[if_nsubst] :: IfLclEnv -> Maybe NameShape
[if_implicits_env] :: IfLclEnv -> Maybe TypeEnv
[if_tv_env] :: IfLclEnv -> FastStringEnv TyVar
[if_id_env] :: IfLclEnv -> FastStringEnv Id
tcVisibleOrphanMods :: TcGblEnv -> ModuleSet

-- | <a>FrontendResult</a> describes the result of running the frontend of
--   a Haskell module. Currently one always gets a
--   <a>FrontendTypecheck</a>, since running the frontend involves
--   typechecking a program. hs-sig merges are not handled here.
--   
--   This data type really should be in GHC.Driver.Env, but it needs to
--   have a TcGblEnv which is only defined here.
data FrontendResult
FrontendTypecheck :: TcGblEnv -> FrontendResult
type ErrCtxt = (Bool, TidyEnv -> TcM (TidyEnv, SDoc))
type RecFieldEnv = NameEnv [FieldLabel]
pushErrCtxt :: CtOrigin -> ErrCtxt -> CtLoc -> CtLoc
pushErrCtxtSameOrigin :: ErrCtxt -> CtLoc -> CtLoc

-- | <a>ImportAvails</a> summarises what was imported from where,
--   irrespective of whether the imported things are actually used or not.
--   It is used:
--   
--   <ul>
--   <li>when processing the export list,</li>
--   <li>when constructing usage info for the interface file,</li>
--   <li>to identify the list of directly imported modules for
--   initialisation purposes and for optimised overlap checking of family
--   instances,</li>
--   <li>when figuring out what things are really unused</li>
--   </ul>
data ImportAvails
ImportAvails :: ImportedMods -> ModuleNameEnv ModuleNameWithIsBoot -> Set UnitId -> Set UnitId -> Bool -> [Module] -> [Module] -> ImportAvails

-- | Domain is all directly-imported modules
--   
--   See the documentation on ImportedModsVal in
--   <a>GHC.Unit.Module.Imported</a> for the meaning of the fields.
--   
--   We need a full ModuleEnv rather than a ModuleNameEnv here, because we
--   might be importing modules of the same name from different packages.
--   (currently not the case, but might be in the future).
[imp_mods] :: ImportAvails -> ImportedMods

-- | Home-package modules needed by the module being compiled
--   
--   It doesn't matter whether any of these dependencies are actually
--   <i>used</i> when compiling the module; they are listed if they are
--   below it at all. For example, suppose M imports A which imports X.
--   Then compiling M might not need to consult X.hi, but X is still listed
--   in M's dependencies.
[imp_dep_mods] :: ImportAvails -> ModuleNameEnv ModuleNameWithIsBoot

-- | Packages needed by the module being compiled, whether directly, or via
--   other modules in this package, or via modules imported from other
--   packages.
[imp_dep_pkgs] :: ImportAvails -> Set UnitId

-- | This is strictly a subset of imp_dep_pkgs and records the packages the
--   current module needs to trust for Safe Haskell compilation to succeed.
--   A package is required to be trusted if we are dependent on a
--   trustworthy module in that package. While perhaps making imp_dep_pkgs
--   a tuple of (UnitId, Bool) where True for the bool indicates the
--   package is required to be trusted is the more logical design, doing so
--   complicates a lot of code not concerned with Safe Haskell. See Note
--   [Tracking Trust Transitively] in <a>GHC.Rename.Names</a>
[imp_trust_pkgs] :: ImportAvails -> Set UnitId

-- | Do we require that our own package is trusted? This is to handle
--   efficiently the case where a Safe module imports a Trustworthy module
--   that resides in the same package as it. See Note [Trust Own Package]
--   in <a>GHC.Rename.Names</a>
[imp_trust_own_pkg] :: ImportAvails -> Bool

-- | Orphan modules below us in the import tree (and maybe including us for
--   imported modules)
[imp_orphs] :: ImportAvails -> [Module]

-- | Family instance modules below us in the import tree (and maybe
--   including us for imported modules)
[imp_finsts] :: ImportAvails -> [Module]
emptyImportAvails :: ImportAvails

-- | Union two ImportAvails
--   
--   This function is a key part of Import handling, basically for each
--   import we create a separate ImportAvails structure and then union them
--   all together with this function.
plusImportAvails :: ImportAvails -> ImportAvails -> ImportAvails
data WhereFrom
ImportByUser :: IsBootInterface -> WhereFrom
ImportBySystem :: WhereFrom
ImportByPlugin :: WhereFrom
mkModDeps :: [ModuleNameWithIsBoot] -> ModuleNameEnv ModuleNameWithIsBoot
modDepsElts :: ModuleNameEnv ModuleNameWithIsBoot -> [ModuleNameWithIsBoot]
type TcTypeEnv = NameEnv TcTyThing
type TcBinderStack = [TcBinder]
data TcBinder
TcIdBndr :: TcId -> TopLevelFlag -> TcBinder
TcIdBndr_ExpType :: Name -> ExpType -> TopLevelFlag -> TcBinder
TcTvBndr :: Name -> TyVar -> TcBinder

-- | A typecheckable thing available in a local context. Could be
--   <a>AGlobal</a> <a>TyThing</a>, but also lexically scoped variables,
--   etc. See <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a>
--   given a <a>Name</a>.
data TcTyThing
AGlobal :: TyThing -> TcTyThing
ATcId :: TcId -> IdBindingInfo -> TcTyThing
[tct_id] :: TcTyThing -> TcId
[tct_info] :: TcTyThing -> IdBindingInfo
ATyVar :: Name -> TcTyVar -> TcTyThing
ATcTyCon :: TyCon -> TcTyThing
APromotionErr :: PromotionErr -> TcTyThing
data PromotionErr
TyConPE :: PromotionErr
ClassPE :: PromotionErr
FamDataConPE :: PromotionErr
ConstrainedDataConPE :: PredType -> PromotionErr
PatSynPE :: PromotionErr
RecDataConPE :: PromotionErr
NoDataKindsTC :: PromotionErr
NoDataKindsDC :: PromotionErr

-- | IdBindingInfo describes how an Id is bound.
--   
--   It is used for the following purposes: a) for static forms in
--   <a>checkClosedInStaticForm</a> and b) to figure out when a nested
--   binding can be generalised, in <a>decideGeneralisationPlan</a>.
data IdBindingInfo
NotLetBound :: IdBindingInfo
ClosedLet :: IdBindingInfo
NonClosedLet :: RhsNames -> ClosedTypeId -> IdBindingInfo
type ClosedTypeId = Bool
type RhsNames = NameSet

-- | IsGroupClosed describes a group of mutually-recursive bindings
data IsGroupClosed
IsGroupClosed :: NameEnv RhsNames -> ClosedTypeId -> IsGroupClosed
data SelfBootInfo
NoSelfBoot :: SelfBootInfo
SelfBoot :: ModDetails -> NameSet -> SelfBootInfo
[sb_mds] :: SelfBootInfo -> ModDetails
[sb_tcs] :: SelfBootInfo -> NameSet
tcTyThingCategory :: TcTyThing -> String
pprTcTyThingCategory :: TcTyThing -> SDoc
peCategory :: PromotionErr -> String
pprPECategory :: PromotionErr -> SDoc

-- | A list of conlikes which represents a complete pattern match. These
--   arise from <tt>COMPLETE</tt> signatures. See also Note [Implementation
--   of COMPLETE pragmas].
data CompleteMatch
type CompleteMatches = [CompleteMatch]
data ThStage
Splice :: SpliceType -> ThStage
RunSplice :: TcRef [ForeignRef (Q ())] -> ThStage
Comp :: ThStage
Brack :: ThStage -> PendingStuff -> ThStage
data SpliceType
Typed :: SpliceType
Untyped :: SpliceType
data PendingStuff
RnPendingUntyped :: TcRef [PendingRnSplice] -> PendingStuff
RnPendingTyped :: PendingStuff
TcPending :: TcRef [PendingTcSplice] -> TcRef WantedConstraints -> QuoteWrapper -> PendingStuff
topStage :: ThStage
topAnnStage :: ThStage
topSpliceStage :: ThStage
type ThLevel = Int
impLevel :: ThLevel
outerLevel :: ThLevel
thLevel :: ThStage -> ThLevel
data ForeignSrcLang
LangC :: ForeignSrcLang
LangCxx :: ForeignSrcLang
LangObjc :: ForeignSrcLang
LangObjcxx :: ForeignSrcLang
LangAsm :: ForeignSrcLang
RawObject :: ForeignSrcLang

-- | The current collection of docs that Template Haskell has built up via
--   putDoc.
type THDocs = Map DocLoc String

-- | This is a mirror of Template Haskell's DocLoc, but the TH names are
--   resolved to GHC names.
data DocLoc
DeclDoc :: Name -> DocLoc
ArgDoc :: Name -> Int -> DocLoc
InstDoc :: Name -> DocLoc
ModuleDoc :: DocLoc
data ArrowCtxt
NoArrowCtxt :: ArrowCtxt
ArrowCtxt :: LocalRdrEnv -> TcRef WantedConstraints -> ArrowCtxt
type TcSigFun = Name -> Maybe TcSigInfo
data TcSigInfo
TcIdSig :: TcIdSigInfo -> TcSigInfo
TcPatSynSig :: TcPatSynInfo -> TcSigInfo
data TcIdSigInfo
CompleteSig :: TcId -> UserTypeCtxt -> SrcSpan -> TcIdSigInfo
[sig_bndr] :: TcIdSigInfo -> TcId
[sig_ctxt] :: TcIdSigInfo -> UserTypeCtxt
[sig_loc] :: TcIdSigInfo -> SrcSpan
PartialSig :: Name -> LHsSigWcType GhcRn -> UserTypeCtxt -> SrcSpan -> TcIdSigInfo
[psig_name] :: TcIdSigInfo -> Name
[psig_hs_ty] :: TcIdSigInfo -> LHsSigWcType GhcRn
[sig_ctxt] :: TcIdSigInfo -> UserTypeCtxt
[sig_loc] :: TcIdSigInfo -> SrcSpan
data TcIdSigInst
TISI :: TcIdSigInfo -> [(Name, InvisTVBinder)] -> TcThetaType -> TcSigmaType -> [(Name, TcTyVar)] -> Maybe TcType -> TcIdSigInst
[sig_inst_sig] :: TcIdSigInst -> TcIdSigInfo
[sig_inst_skols] :: TcIdSigInst -> [(Name, InvisTVBinder)]
[sig_inst_theta] :: TcIdSigInst -> TcThetaType
[sig_inst_tau] :: TcIdSigInst -> TcSigmaType
[sig_inst_wcs] :: TcIdSigInst -> [(Name, TcTyVar)]
[sig_inst_wcx] :: TcIdSigInst -> Maybe TcType
data TcPatSynInfo
TPSI :: Name -> [InvisTVBinder] -> [InvisTVBinder] -> TcThetaType -> [InvisTVBinder] -> TcThetaType -> TcSigmaType -> TcPatSynInfo
[patsig_name] :: TcPatSynInfo -> Name
[patsig_implicit_bndrs] :: TcPatSynInfo -> [InvisTVBinder]
[patsig_univ_bndrs] :: TcPatSynInfo -> [InvisTVBinder]
[patsig_req] :: TcPatSynInfo -> TcThetaType
[patsig_ex_bndrs] :: TcPatSynInfo -> [InvisTVBinder]
[patsig_prov] :: TcPatSynInfo -> TcThetaType
[patsig_body_ty] :: TcPatSynInfo -> TcSigmaType
isPartialSig :: TcIdSigInst -> Bool

-- | No signature or a partial signature
hasCompleteSig :: TcSigFun -> Name -> Bool
type TcId = Id
type TcIdSet = IdSet

-- | A <a>NameShape</a> is a substitution on <a>Name</a>s that can be used
--   to refine the identities of a hole while we are renaming interfaces
--   (see <a>GHC.Iface.Rename</a>). Specifically, a <a>NameShape</a> for
--   <tt>ns_module_name</tt> <tt>A</tt>, defines a mapping from
--   <tt>{A.T}</tt> (for some <a>OccName</a> <tt>T</tt>) to some arbitrary
--   other <a>Name</a>.
--   
--   The most intruiging thing about a <a>NameShape</a>, however, is how
--   it's constructed. A <a>NameShape</a> is *implied* by the exported
--   <a>AvailInfo</a>s of the implementor of an interface: if an
--   implementor of signature <tt>&lt;H&gt;</tt> exports <tt>M.T</tt>, you
--   implicitly define a substitution from <tt>{H.T}</tt> to <tt>M.T</tt>.
--   So a <a>NameShape</a> is computed from the list of <a>AvailInfo</a>s
--   that are exported by the implementation of a module, or successively
--   merged together by the export lists of signatures which are joining
--   together.
--   
--   It's not the most obvious way to go about doing this, but it does seem
--   to work!
--   
--   NB: Can't boot this and put it in NameShape because then we start
--   pulling in too many DynFlags things.
data NameShape
NameShape :: ModuleName -> [AvailInfo] -> OccEnv Name -> NameShape
[ns_mod_name] :: NameShape -> ModuleName
[ns_exports] :: NameShape -> [AvailInfo]
[ns_map] :: NameShape -> OccEnv Name
removeBindingShadowing :: HasOccName a => [a] -> [a]

-- | Get target platform
getPlatform :: TcM Platform
data TcPlugin
TcPlugin :: TcPluginM s -> (s -> TcPluginSolver) -> (s -> TcPluginM ()) -> TcPlugin

-- | Initialize plugin, when entering type-checker.
[tcPluginInit] :: TcPlugin -> TcPluginM s

-- | Solve some constraints. TODO: WRITE MORE DETAILS ON HOW THIS WORKS.
[tcPluginSolve] :: TcPlugin -> s -> TcPluginSolver

-- | Clean up after the plugin, when exiting the type-checker.
[tcPluginStop] :: TcPlugin -> s -> TcPluginM ()
data TcPluginResult

-- | The plugin found a contradiction. The returned constraints are removed
--   from the inert set, and recorded as insoluble.
TcPluginContradiction :: [Ct] -> TcPluginResult

-- | The first field is for constraints that were solved. These are removed
--   from the inert set, and the evidence for them is recorded. The second
--   field contains new work, that should be processed by the constraint
--   solver.
TcPluginOk :: [(EvTerm, Ct)] -> [Ct] -> TcPluginResult
type TcPluginSolver = [Ct] -> [Ct] -> [Ct] -> TcPluginM TcPluginResult
data TcPluginM a
runTcPluginM :: TcPluginM a -> EvBindsVar -> TcM a

-- | This function provides an escape for direct access to the <a>TcM</a>
--   monad. It should not be used lightly, and the provided
--   <a>TcPluginM</a> API should be favoured instead.
unsafeTcPluginTcM :: TcM a -> TcPluginM a

-- | Access the <a>EvBindsVar</a> carried by the <a>TcPluginM</a> during
--   constraint solving. Returns <a>Nothing</a> if invoked during
--   <a>tcPluginInit</a> or <a>tcPluginStop</a>.
getEvBindsTcPluginM :: TcPluginM EvBindsVar
type RoleAnnotEnv = NameEnv (LRoleAnnotDecl GhcRn)
emptyRoleAnnotEnv :: RoleAnnotEnv
mkRoleAnnotEnv :: [LRoleAnnotDecl GhcRn] -> RoleAnnotEnv
lookupRoleAnnot :: RoleAnnotEnv -> Name -> Maybe (LRoleAnnotDecl GhcRn)
getRoleAnnots :: [Name] -> RoleAnnotEnv -> [LRoleAnnotDecl GhcRn]

-- | Check the <a>TcGblEnv</a> for consistency. Currently, only checks
--   axioms, but should check other aspects, too.
lintGblEnv :: Logger -> DynFlags -> TcGblEnv -> TcM ()
instance GHC.Classes.Ord GHC.Tc.Types.DocLoc
instance GHC.Classes.Eq GHC.Tc.Types.DocLoc
instance GHC.Base.Functor GHC.Tc.Types.TcPluginM
instance GHC.Unit.Module.ContainsModule GHC.Tc.Types.TcGblEnv
instance GHC.Base.Applicative GHC.Tc.Types.TcPluginM
instance GHC.Base.Monad GHC.Tc.Types.TcPluginM
instance Control.Monad.Fail.MonadFail GHC.Tc.Types.TcPluginM
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.TcSigInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.TcPatSynInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.TcIdSigInst
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.TcIdSigInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.WhereFrom
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.TcTyThing
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.IdBindingInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.PromotionErr
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.ThStage
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.TcBinder
instance GHC.Types.Name.Occurrence.HasOccName GHC.Tc.Types.TcBinder
instance GHC.Driver.Session.ContainsDynFlags (GHC.Tc.Types.Env gbl lcl)
instance GHC.Driver.Hooks.ContainsHooks (GHC.Tc.Types.Env gbl lcl)
instance GHC.Utils.Logger.ContainsLogger (GHC.Tc.Types.Env gbl lcl)
instance GHC.Unit.Module.ContainsModule gbl => GHC.Unit.Module.ContainsModule (GHC.Tc.Types.Env gbl lcl)

module GHC.Unit.Module.ModDetails

-- | The <a>ModDetails</a> is essentially a cache for information in the
--   <tt>ModIface</tt> for home modules only. Information relating to
--   packages will be loaded into global environments in
--   <tt>ExternalPackageState</tt>.
data ModDetails
ModDetails :: [AvailInfo] -> !TypeEnv -> ![ClsInst] -> ![FamInst] -> ![CoreRule] -> ![Annotation] -> [CompleteMatch] -> ModDetails
[md_exports] :: ModDetails -> [AvailInfo]

-- | Local type environment for this particular module Includes Ids,
--   TyCons, PatSyns
[md_types] :: ModDetails -> !TypeEnv

-- | <tt>DFunId</tt>s for the instances in this module
[md_insts] :: ModDetails -> ![ClsInst]
[md_fam_insts] :: ModDetails -> ![FamInst]

-- | Domain may include <tt>Id</tt>s from other modules
[md_rules] :: ModDetails -> ![CoreRule]

-- | Annotations present in this module: currently they only annotate
--   things also declared in this module
[md_anns] :: ModDetails -> ![Annotation]

-- | Complete match pragmas for this module
[md_complete_matches] :: ModDetails -> [CompleteMatch]

-- | Constructs an empty ModDetails
emptyModDetails :: ModDetails

module GHC.Types.TypeEnv

-- | A map from <a>Name</a>s to <a>TyThing</a>s, constructed by
--   typechecking local declarations or interface files
type TypeEnv = NameEnv TyThing
emptyTypeEnv :: TypeEnv
lookupTypeEnv :: TypeEnv -> Name -> Maybe TyThing
mkTypeEnv :: [TyThing] -> TypeEnv
typeEnvFromEntities :: [Id] -> [TyCon] -> [PatSyn] -> [FamInst] -> TypeEnv
mkTypeEnvWithImplicits :: [TyThing] -> TypeEnv
extendTypeEnv :: TypeEnv -> TyThing -> TypeEnv
extendTypeEnvList :: TypeEnv -> [TyThing] -> TypeEnv
extendTypeEnvWithIds :: TypeEnv -> [Id] -> TypeEnv
plusTypeEnv :: TypeEnv -> TypeEnv -> TypeEnv
typeEnvElts :: TypeEnv -> [TyThing]
typeEnvTyCons :: TypeEnv -> [TyCon]
typeEnvIds :: TypeEnv -> [Id]
typeEnvPatSyns :: TypeEnv -> [PatSyn]
typeEnvDataCons :: TypeEnv -> [DataCon]
typeEnvCoAxioms :: TypeEnv -> [CoAxiom Branched]
typeEnvClasses :: TypeEnv -> [Class]


-- | COMPLETE signature
module GHC.Types.CompleteMatch

-- | A list of conlikes which represents a complete pattern match. These
--   arise from <tt>COMPLETE</tt> signatures. See also Note [Implementation
--   of COMPLETE pragmas].
data CompleteMatch
CompleteMatch :: UniqDSet ConLike -> Maybe TyCon -> CompleteMatch

-- | The set of <a>ConLike</a> values
[cmConLikes] :: CompleteMatch -> UniqDSet ConLike

-- | The optional, concrete result TyCon the set applies to
[cmResultTyCon] :: CompleteMatch -> Maybe TyCon
vanillaCompleteMatch :: UniqDSet ConLike -> CompleteMatch
type CompleteMatches = [CompleteMatch]
completeMatchAppliesAtType :: Type -> CompleteMatch -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Types.CompleteMatch.CompleteMatch


-- | Support for source code annotation feature of GHC. That is the ANN
--   pragma.
--   
--   (c) The University of Glasgow 2006 (c) The GRASP/AQUA Project, Glasgow
--   University, 1992-1998
module GHC.Types.Annotations

-- | Represents an annotation after it has been sufficiently desugared from
--   it's initial form of <a>AnnDecl</a>
data Annotation
Annotation :: CoreAnnTarget -> AnnPayload -> Annotation

-- | The target of the annotation
[ann_target] :: Annotation -> CoreAnnTarget
[ann_value] :: Annotation -> AnnPayload
type AnnPayload = Serialized " The "payload" of an annotation allows recovery of its value at a given type, and can be persisted to an interface file"

-- | An annotation target
data AnnTarget name

-- | We are annotating something with a name: a type or identifier
NamedTarget :: name -> AnnTarget name

-- | We are annotating a particular module
ModuleTarget :: Module -> AnnTarget name

-- | The kind of annotation target found in the middle end of the compiler
type CoreAnnTarget = AnnTarget Name

-- | A collection of annotations
data AnnEnv

-- | Construct a new annotation environment that contains the list of
--   annotations provided.
mkAnnEnv :: [Annotation] -> AnnEnv

-- | Add the given annotation to the environment.
extendAnnEnvList :: AnnEnv -> [Annotation] -> AnnEnv

-- | Union two annotation environments.
plusAnnEnv :: AnnEnv -> AnnEnv -> AnnEnv

-- | An empty annotation environment.
emptyAnnEnv :: AnnEnv

-- | Find the annotations attached to the given target as <a>Typeable</a>
--   values of your choice. If no deserializer is specified, only transient
--   annotations will be returned.
findAnns :: Typeable a => ([Word8] -> a) -> AnnEnv -> CoreAnnTarget -> [a]

-- | Find the annotations attached to the given target as <a>Typeable</a>
--   values of your choice. If no deserializer is specified, only transient
--   annotations will be returned.
findAnnsByTypeRep :: AnnEnv -> CoreAnnTarget -> TypeRep -> [[Word8]]

-- | Deserialize all annotations of a given type. This happens lazily, that
--   is no deserialization will take place until the [a] is actually
--   demanded and the [a] can also be empty (the UniqFM is not filtered).
deserializeAnns :: Typeable a => ([Word8] -> a) -> AnnEnv -> (ModuleEnv [a], NameEnv [a])
instance GHC.Base.Functor GHC.Types.Annotations.AnnTarget
instance GHC.Utils.Outputable.Outputable GHC.Types.Annotations.Annotation
instance GHC.Utils.Outputable.Outputable name => GHC.Utils.Outputable.Outputable (GHC.Types.Annotations.AnnTarget name)
instance GHC.Utils.Binary.Binary name => GHC.Utils.Binary.Binary (GHC.Types.Annotations.AnnTarget name)

module GHC.Core.InstEnv

-- | Dictionary Function Identifier
type DFunId = Id
type InstMatch = (ClsInst, [DFunInstType])
type ClsInstLookupResult = ([InstMatch], [ClsInst], [InstMatch])

-- | The semantics allowed for overlapping instances for a particular
--   instance. See Note [Safe Haskell isSafeOverlap] (in
--   <a>GHC.Core.InstEnv</a>) for a explanation of the <a>isSafeOverlap</a>
--   field.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# OVERLAPPABLE'</tt>
--   or <tt>'{-# OVERLAPPING'</tt> or <tt>'{-# OVERLAPS'</tt> or <tt>'{-#
--   INCOHERENT'</tt>, <a>AnnClose</a> <tt>`#-}`</tt>,</li>
--   </ul>
data OverlapFlag
OverlapFlag :: OverlapMode -> Bool -> OverlapFlag
[overlapMode] :: OverlapFlag -> OverlapMode
[isSafeOverlap] :: OverlapFlag -> Bool
data OverlapMode

-- | This instance must not overlap another <a>NoOverlap</a> instance.
--   However, it may be overlapped by <a>Overlapping</a> instances, and it
--   may overlap <a>Overlappable</a> instances.
NoOverlap :: SourceText -> OverlapMode

-- | Silently ignore this instance if you find a more specific one that
--   matches the constraint you are trying to resolve
--   
--   Example: constraint (Foo [Int]) instance Foo [Int] instance {-#
--   OVERLAPPABLE #-} Foo [a]
--   
--   Since the second instance has the Overlappable flag, the first
--   instance will be chosen (otherwise its ambiguous which to choose)
Overlappable :: SourceText -> OverlapMode

-- | Silently ignore any more general instances that may be used to solve
--   the constraint.
--   
--   Example: constraint (Foo [Int]) instance {-# OVERLAPPING #-} Foo [Int]
--   instance Foo [a]
--   
--   Since the first instance has the Overlapping flag, the second---more
--   general---instance will be ignored (otherwise it is ambiguous which to
--   choose)
Overlapping :: SourceText -> OverlapMode

-- | Equivalent to having both <a>Overlapping</a> and <a>Overlappable</a>
--   flags.
Overlaps :: SourceText -> OverlapMode

-- | Behave like Overlappable and Overlapping, and in addition pick an
--   arbitrary one if there are multiple matching candidates, and don't
--   worry about later instantiation
--   
--   Example: constraint (Foo [b]) instance {-# INCOHERENT -} Foo [Int]
--   instance Foo [a] Without the Incoherent flag, we'd complain that
--   instantiating <tt>b</tt> would change which instance was chosen. See
--   also note [Incoherent instances] in <a>GHC.Core.InstEnv</a>
Incoherent :: SourceText -> OverlapMode
setOverlapModeMaybe :: OverlapFlag -> Maybe OverlapMode -> OverlapFlag

-- | A type-class instance. Note that there is some tricky laziness at work
--   here. See Note [ClsInst laziness and the rough-match fields] for more
--   details.
data ClsInst
ClsInst :: Name -> [RoughMatchTc] -> Name -> [TyVar] -> Class -> [Type] -> DFunId -> OverlapFlag -> IsOrphan -> ClsInst

-- | Class name
[is_cls_nm] :: ClsInst -> Name

-- | Top of type args
[is_tcs] :: ClsInst -> [RoughMatchTc]

-- | <tt>is_dfun_name = idName . is_dfun</tt>.
--   
--   We use <a>is_dfun_name</a> for the visibility check,
--   <a>instIsVisible</a>, which needs to know the <a>Module</a> which the
--   dictionary is defined in. However, we cannot use the <a>Module</a>
--   attached to <a>is_dfun</a> since doing so would mean we would
--   potentially pull in an entire interface file unnecessarily. This was
--   the cause of #12367.
[is_dfun_name] :: ClsInst -> Name
[is_tvs] :: ClsInst -> [TyVar]
[is_cls] :: ClsInst -> Class
[is_tys] :: ClsInst -> [Type]
[is_dfun] :: ClsInst -> DFunId
[is_flag] :: ClsInst -> OverlapFlag
[is_orphan] :: ClsInst -> IsOrphan
type DFunInstType = Maybe Type
pprInstance :: ClsInst -> SDoc
pprInstanceHdr :: ClsInst -> SDoc
pprInstances :: [ClsInst] -> SDoc
instanceHead :: ClsInst -> ([TyVar], Class, [Type])
instanceSig :: ClsInst -> ([TyVar], [Type], Class, [Type])
mkLocalInstance :: DFunId -> OverlapFlag -> [TyVar] -> Class -> [Type] -> ClsInst
mkImportedInstance :: Name -> [RoughMatchTc] -> Name -> DFunId -> OverlapFlag -> IsOrphan -> ClsInst
instanceDFunId :: ClsInst -> DFunId
updateClsInstDFun :: (DFunId -> DFunId) -> ClsInst -> ClsInst
instanceRoughTcs :: ClsInst -> [RoughMatchTc]

-- | A fuzzy comparison function for class instances, intended for sorting
--   instances before displaying them to the user.
fuzzyClsInstCmp :: ClsInst -> ClsInst -> Ordering

-- | Collects the names of concrete types and type constructors that make
--   up the head of a class instance. For instance, given `class Foo a b`:
--   
--   `instance Foo (Either (Maybe Int) a) Bool` would yield [Either, Maybe,
--   Int, Bool]
--   
--   Used in the implementation of ":info" in GHCi.
--   
--   The <a>tcSplitSigmaTy</a> is because of instance Foo a =&gt; Baz T
--   where ... The decl is an orphan if Baz and T are both not locally
--   defined, even if Foo *is* locally defined
orphNamesOfClsInst :: ClsInst -> NameSet

-- | <a>InstEnvs</a> represents the combination of the global type class
--   instance environment, the local type class instance environment, and
--   the set of transitively reachable orphan modules (according to what
--   modules have been directly imported) used to test orphan instance
--   visibility.
data InstEnvs
InstEnvs :: InstEnv -> InstEnv -> VisibleOrphanModules -> InstEnvs
[ie_global] :: InstEnvs -> InstEnv
[ie_local] :: InstEnvs -> InstEnv
[ie_visible] :: InstEnvs -> VisibleOrphanModules

-- | Set of visible orphan modules, according to what modules have been
--   directly imported. This is based off of the dep_orphs field, which
--   records transitively reachable orphan modules (modules that define
--   orphan instances).
type VisibleOrphanModules = ModuleSet
type InstEnv = UniqDFM Class ClsInstEnv
emptyInstEnv :: InstEnv
extendInstEnv :: InstEnv -> ClsInst -> InstEnv
deleteFromInstEnv :: InstEnv -> ClsInst -> InstEnv
deleteDFunFromInstEnv :: InstEnv -> DFunId -> InstEnv

-- | True when when the instance heads are the same e.g. both are Eq
--   [(a,b)] Used for overriding in GHCi Obviously should be insensitive to
--   alpha-renaming
identicalClsInstHead :: ClsInst -> ClsInst -> Bool
extendInstEnvList :: InstEnv -> [ClsInst] -> InstEnv

-- | Look up an instance in the given instance environment. The given class
--   application must match exactly one instance and the match may not
--   contain any flexi type variables. If the lookup is unsuccessful, yield
--   'Left errorMessage'.
lookupUniqueInstEnv :: InstEnvs -> Class -> [Type] -> Either SDoc (ClsInst, [Type])

-- | See Note [Rules for instance lookup] ^ See Note [Safe Haskell
--   Overlapping Instances] in <a>GHC.Tc.Solver</a> ^ See Note [Safe
--   Haskell Overlapping Instances Implementation] in <a>GHC.Tc.Solver</a>
lookupInstEnv :: Bool -> InstEnvs -> Class -> [Type] -> ClsInstLookupResult
instEnvElts :: InstEnv -> [ClsInst]
instEnvClasses :: InstEnv -> [Class]

-- | Checks for an exact match of ClsInst in the instance environment. We
--   use this when we do signature checking in <a>GHC.Tc.Module</a>
memberInstEnv :: InstEnv -> ClsInst -> Bool

-- | Test if an instance is visible, by checking that its origin module is
--   in <a>VisibleOrphanModules</a>. See Note [Instance lookup and orphan
--   instances]
instIsVisible :: VisibleOrphanModules -> ClsInst -> Bool
classInstances :: InstEnvs -> Class -> [ClsInst]
instanceBindFun :: BindFun
instanceCantMatch :: [RoughMatchTc] -> [RoughMatchTc] -> Bool
roughMatchTcs :: [Type] -> [RoughMatchTc]
isOverlappable :: ClsInst -> Bool
isOverlapping :: ClsInst -> Bool
isIncoherent :: ClsInst -> Bool
instance Data.Data.Data GHC.Core.InstEnv.ClsInst
instance GHC.Utils.Outputable.Outputable GHC.Core.InstEnv.ClsInstEnv
instance GHC.Types.Name.NamedThing GHC.Core.InstEnv.ClsInst
instance GHC.Utils.Outputable.Outputable GHC.Core.InstEnv.ClsInst

module GHC.Unit.Module.Imported

-- | Records the modules directly imported by a module for extracting e.g.
--   usage information, and also to give better error message
type ImportedMods = ModuleEnv [ImportedBy]

-- | If a module was "imported" by the user, we associate it with more
--   detailed usage information <a>ImportedModsVal</a>; a module imported
--   by the system only gets used for usage information.
data ImportedBy
ImportedByUser :: ImportedModsVal -> ImportedBy
ImportedBySystem :: ImportedBy
data ImportedModsVal
ImportedModsVal :: ModuleName -> SrcSpan -> IsSafeImport -> Bool -> !GlobalRdrEnv -> Bool -> ImportedModsVal

-- | The name the module is imported with
[imv_name] :: ImportedModsVal -> ModuleName

-- | the source span of the whole import
[imv_span] :: ImportedModsVal -> SrcSpan

-- | whether this is a safe import
[imv_is_safe] :: ImportedModsVal -> IsSafeImport

-- | whether this is an "hiding" import
[imv_is_hiding] :: ImportedModsVal -> Bool

-- | all the things the module could provide.
--   
--   NB. BangPattern here: otherwise this leaks. (#15111)
[imv_all_exports] :: ImportedModsVal -> !GlobalRdrEnv

-- | whether this is a qualified import
[imv_qualified] :: ImportedModsVal -> Bool
importedByUser :: [ImportedBy] -> [ImportedModsVal]


-- | Units are library components from Cabal packages compiled and
--   installed in a database
module GHC.Unit


-- | Info about installed units (compiled libraries)
module GHC.Unit.Info

-- | Information about an unit (a unit is an installed module library).
--   
--   This is a subset of Cabal's <tt>InstalledPackageInfo</tt>, with just
--   the bits that GHC is interested in.
--   
--   Some types are left as parameters to be instantiated differently in
--   ghc-pkg and in ghc itself.
data GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod
GenericUnitInfo :: uid -> compid -> [(modulename, mod)] -> srcpkgid -> srcpkgname -> Version -> Maybe srcpkgname -> ShortText -> [uid] -> [(uid, ShortText)] -> [FilePathST] -> [ShortText] -> [ShortText] -> [ShortText] -> [FilePathST] -> [FilePathST] -> [ShortText] -> [FilePathST] -> [ShortText] -> [ShortText] -> [ShortText] -> [FilePathST] -> [FilePathST] -> [FilePathST] -> [(modulename, Maybe mod)] -> [modulename] -> Bool -> Bool -> Bool -> GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod

-- | Unique unit identifier that is used during compilation (e.g. to
--   generate symbols).
[unitId] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> uid

-- | Identifier of an indefinite unit (i.e. with module holes) that this
--   unit is an instance of.
[unitInstanceOf] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> compid

-- | How this unit instantiates some of its module holes. Map hole module
--   names to actual module
[unitInstantiations] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [(modulename, mod)]

-- | Source package identifier.
--   
--   Cabal instantiates this with Distribution.Types.PackageId.PackageId
--   type which only contains the source package name and version. Notice
--   that it doesn't contain the Hackage revision, nor any kind of hash.
[unitPackageId] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> srcpkgid

-- | Source package name
[unitPackageName] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> srcpkgname

-- | Source package version
[unitPackageVersion] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> Version

-- | Name of the component.
--   
--   Cabal supports more than one components (libraries, executables,
--   testsuites) in the same package. Each component has a name except the
--   default one (that can only be a library component) for which we use
--   <a>Nothing</a>.
--   
--   GHC only deals with "library" components as they are the only kind of
--   components that can be registered in a database and used by other
--   modules.
[unitComponentName] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> Maybe srcpkgname

-- | ABI hash used to avoid mixing up units compiled with different
--   dependencies, compiler, options, etc.
[unitAbiHash] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> ShortText

-- | Identifiers of the units this one depends on
[unitDepends] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [uid]

-- | Like <a>unitDepends</a>, but each dependency is annotated with the ABI
--   hash we expect the dependency to respect.
[unitAbiDepends] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [(uid, ShortText)]

-- | Directories containing module interfaces
[unitImportDirs] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Names of the Haskell libraries provided by this unit
[unitLibraries] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Names of the external system libraries that this unit depends on. See
--   also <a>unitExtDepLibsGhc</a> field.
[unitExtDepLibsSys] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Because of slight differences between the GHC dynamic linker (in
--   GHC.Runtime.Linker) and the native system linker, some packages have
--   to link with a different list of libraries when using GHC's. Examples
--   include: libs that are actually gnu ld scripts, and the possibility
--   that the .a libs do not exactly match the .so/.dll equivalents.
--   
--   If this field is set, then we use that instead of the
--   <a>unitExtDepLibsSys</a> field.
[unitExtDepLibsGhc] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Directories containing libraries provided by this unit. See also
--   <a>unitLibraryDynDirs</a>.
--   
--   It seems to be used to store paths to external library dependencies
--   too.
[unitLibraryDirs] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Directories containing the dynamic libraries provided by this unit.
--   See also <a>unitLibraryDirs</a>.
--   
--   It seems to be used to store paths to external dynamic library
--   dependencies too.
[unitLibraryDynDirs] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Names of the external MacOS frameworks that this unit depends on.
[unitExtDepFrameworks] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Directories containing MacOS frameworks that this unit depends on.
[unitExtDepFrameworkDirs] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Linker (e.g. ld) command line options
[unitLinkerOptions] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | C compiler options that needs to be passed to the C compiler when we
--   compile some C code against this unit.
[unitCcOptions] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | C header files that are required by this unit (provided by this unit
--   or external)
[unitIncludes] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Directories containing C header files that this unit depends on.
[unitIncludeDirs] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Paths to Haddock interface files for this unit
[unitHaddockInterfaces] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Paths to Haddock directories containing HTML files
[unitHaddockHTMLs] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Modules exposed by the unit.
--   
--   A module can be re-exported from another package. In this case, we
--   indicate the module origin in the second parameter.
[unitExposedModules] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [(modulename, Maybe mod)]

-- | Hidden modules.
--   
--   These are useful for error reporting (e.g. if a hidden module is
--   imported)
[unitHiddenModules] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [modulename]

-- | True if this unit has some module holes that need to be instantiated
--   with real modules to make the unit usable (a.k.a. Backpack).
[unitIsIndefinite] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> Bool

-- | True if the unit is exposed. A unit could be installed in a database
--   by "disabled" by not being exposed.
[unitIsExposed] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> Bool

-- | True if the unit is trusted (cf Safe Haskell)
[unitIsTrusted] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> Bool

-- | Information about an installed unit
--   
--   We parameterize on the unit identifier: * UnitKey: identifier used in
--   the database (cf <a>UnitKeyInfo</a>) * UnitId: identifier used to
--   generate code (cf <a>UnitInfo</a>)
--   
--   These two identifiers are different for wired-in packages. See Note
--   [About Units] in <a>GHC.Unit</a>
type GenUnitInfo unit = GenericUnitInfo (Indefinite unit) PackageId PackageName unit ModuleName (GenModule (GenUnit unit))

-- | Information about an installed unit (units are identified by their
--   internal UnitId)
type UnitInfo = GenUnitInfo UnitId

-- | A unit key in the database
newtype UnitKey
UnitKey :: FastString -> UnitKey

-- | Information about an installed unit (units are identified by their
--   database UnitKey)
type UnitKeyInfo = GenUnitInfo UnitKey

-- | Convert a DbUnitInfo (read from a package database) into
--   <a>UnitKeyInfo</a>
mkUnitKeyInfo :: DbUnitInfo -> UnitKeyInfo

-- | Map over the unit parameter
mapUnitInfo :: IsUnitId v => (u -> v) -> GenUnitInfo u -> GenUnitInfo v

-- | Create a UnitPprInfo from a UnitInfo
mkUnitPprInfo :: (u -> FastString) -> GenUnitInfo u -> UnitPprInfo

-- | Make a <a>Unit</a> from a <a>UnitInfo</a>
--   
--   If the unit is definite, make a <a>RealUnit</a> from <a>unitId</a>
--   field.
--   
--   If the unit is indefinite, make a <a>VirtUnit</a> from
--   <a>unitInstanceOf</a> and <a>unitInstantiations</a> fields. Note that
--   in this case we don't keep track of <a>unitId</a>. It can be retrieved
--   later with "improvement", i.e. matching on
--   `unitInstanceOf/unitInstantiations` fields (see Note [About units] in
--   GHC.Unit).
mkUnit :: UnitInfo -> Unit
newtype PackageId
PackageId :: FastString -> PackageId
newtype PackageName
PackageName :: FastString -> PackageName
[unPackageName] :: PackageName -> FastString

-- | A <a>Version</a> represents the version of a software entity.
--   
--   An instance of <a>Eq</a> is provided, which implements exact equality
--   modulo reordering of the tags in the <a>versionTags</a> field.
--   
--   An instance of <a>Ord</a> is also provided, which gives lexicographic
--   ordering on the <a>versionBranch</a> fields (i.e. 2.1 &gt; 2.0, 1.2.3
--   &gt; 1.2.2, etc.). This is expected to be sufficient for many uses,
--   but note that you may need to use a more specific ordering for your
--   versioning scheme. For example, some versioning schemes may include
--   pre-releases which have tags <tt>"pre1"</tt>, <tt>"pre2"</tt>, and so
--   on, and these would need to be taken into account when determining
--   ordering. In some cases, date ordering may be more appropriate, so the
--   application would have to look for <tt>date</tt> tags in the
--   <a>versionTags</a> field and compare those. The bottom line is, don't
--   always assume that <a>compare</a> and other <a>Ord</a> operations are
--   the right thing for every <a>Version</a>.
--   
--   Similarly, concrete representations of versions may differ. One
--   possible concrete representation is provided (see <a>showVersion</a>
--   and <a>parseVersion</a>), but depending on the application a different
--   concrete representation may be more appropriate.
data Version
Version :: [Int] -> [String] -> Version

-- | The numeric branch for this version. This reflects the fact that most
--   software versions are tree-structured; there is a main trunk which is
--   tagged with versions at various points (1,2,3...), and the first
--   branch off the trunk after version 3 is 3.1, the second branch off the
--   trunk after version 3 is 3.2, and so on. The tree can be branched
--   arbitrarily, just by adding more digits.
--   
--   We represent the branch as a list of <a>Int</a>, so version 3.2.1
--   becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of
--   <a>Ord</a> for <tt>[Int]</tt>) gives the natural ordering of branches.
[versionBranch] :: Version -> [Int]

-- | A version can be tagged with an arbitrary list of strings. The
--   interpretation of the list of tags is entirely dependent on the entity
--   that this version applies to.
[versionTags] :: Version -> [String]
unitPackageNameString :: GenUnitInfo u -> String
unitPackageIdString :: GenUnitInfo u -> String
pprUnitInfo :: UnitInfo -> SDoc

-- | Find all the include directories in the given units
collectIncludeDirs :: [UnitInfo] -> [FilePath]

-- | Find all the C-compiler options in the given units
collectExtraCcOpts :: [UnitInfo] -> [String]

-- | Find all the library directories in the given units for the given ways
collectLibraryDirs :: Ways -> [UnitInfo] -> [FilePath]

-- | Find all the frameworks in the given units
collectFrameworks :: [UnitInfo] -> [String]

-- | Find all the package framework paths in these and the preload packages
collectFrameworksDirs :: [UnitInfo] -> [String]
unitHsLibs :: GhcNameVersion -> Ways -> UnitInfo -> [String]
instance GHC.Classes.Eq GHC.Unit.Info.PackageId
instance GHC.Classes.Eq GHC.Unit.Info.PackageName
instance GHC.Types.Unique.Uniquable GHC.Unit.Info.PackageName
instance GHC.Utils.Outputable.Outputable GHC.Unit.Info.PackageName
instance GHC.Types.Unique.Uniquable GHC.Unit.Info.PackageId
instance GHC.Utils.Outputable.Outputable GHC.Unit.Info.PackageId


-- | Unit identifier pretty-printing
module GHC.Unit.Ppr

-- | Subset of UnitInfo: just enough to pretty-print a unit-id
--   
--   Instead of printing the unit-id which may contain a hash, we print:
--   package-version:componentname
data UnitPprInfo
UnitPprInfo :: FastString -> String -> Version -> Maybe String -> UnitPprInfo

-- | Identifier
[unitPprId] :: UnitPprInfo -> FastString

-- | Source package name
[unitPprPackageName] :: UnitPprInfo -> String

-- | Source package version
[unitPprPackageVersion] :: UnitPprInfo -> Version

-- | Component name
[unitPprComponentName] :: UnitPprInfo -> Maybe String
instance GHC.Utils.Outputable.Outputable GHC.Unit.Ppr.UnitPprInfo

module GHC.Types.Fixity.Env

-- | Fixity environment mapping names to their fixities
type FixityEnv = NameEnv FixItem

-- | Fixity information for an <a>Name</a>. We keep the OccName in the
--   range so that we can generate an interface from it
data FixItem
FixItem :: OccName -> Fixity -> FixItem
emptyFixityEnv :: FixityEnv
lookupFixity :: FixityEnv -> Name -> Fixity

-- | Creates cached lookup for the <tt>mi_fix_fn</tt> field of
--   <tt>ModIface</tt>
mkIfaceFixCache :: [(OccName, Fixity)] -> OccName -> Maybe Fixity
emptyIfaceFixCache :: OccName -> Maybe Fixity
instance GHC.Utils.Outputable.Outputable GHC.Types.Fixity.Env.FixItem


-- | Describes the provenance of types as they flow through the
--   type-checker. The datatypes here are mainly used for error message
--   generation.
module GHC.Tc.Types.Origin

-- | UserTypeCtxt describes the origin of the polymorphic type in the
--   places where we need an expression to have that type
data UserTypeCtxt
FunSigCtxt :: Name -> Bool -> UserTypeCtxt
InfSigCtxt :: Name -> UserTypeCtxt
ExprSigCtxt :: UserTypeCtxt
KindSigCtxt :: UserTypeCtxt
StandaloneKindSigCtxt :: Name -> UserTypeCtxt
TypeAppCtxt :: UserTypeCtxt
ConArgCtxt :: Name -> UserTypeCtxt
TySynCtxt :: Name -> UserTypeCtxt
PatSynCtxt :: Name -> UserTypeCtxt
PatSigCtxt :: UserTypeCtxt
RuleSigCtxt :: Name -> UserTypeCtxt
ForSigCtxt :: Name -> UserTypeCtxt
DefaultDeclCtxt :: UserTypeCtxt
InstDeclCtxt :: Bool -> UserTypeCtxt
SpecInstCtxt :: UserTypeCtxt
GenSigCtxt :: UserTypeCtxt
GhciCtxt :: Bool -> UserTypeCtxt
ClassSCCtxt :: Name -> UserTypeCtxt
SigmaCtxt :: UserTypeCtxt
DataTyCtxt :: Name -> UserTypeCtxt
DerivClauseCtxt :: UserTypeCtxt
TyVarBndrKindCtxt :: Name -> UserTypeCtxt
DataKindCtxt :: Name -> UserTypeCtxt
TySynKindCtxt :: Name -> UserTypeCtxt
TyFamResKindCtxt :: Name -> UserTypeCtxt
pprUserTypeCtxt :: UserTypeCtxt -> SDoc
isSigMaybe :: UserTypeCtxt -> Maybe Name
data SkolemInfo
SigSkol :: UserTypeCtxt -> TcType -> [(Name, TcTyVar)] -> SkolemInfo
SigTypeSkol :: UserTypeCtxt -> SkolemInfo
ForAllSkol :: SDoc -> SkolemInfo
DerivSkol :: Type -> SkolemInfo
InstSkol :: SkolemInfo
FamInstSkol :: SkolemInfo
PatSkol :: ConLike -> HsMatchContext GhcRn -> SkolemInfo
ArrowSkol :: SkolemInfo
IPSkol :: [HsIPName] -> SkolemInfo
RuleSkol :: RuleName -> SkolemInfo
InferSkol :: [(Name, TcType)] -> SkolemInfo
BracketSkol :: SkolemInfo
UnifyForAllSkol :: TcType -> SkolemInfo
TyConSkol :: TyConFlavour -> Name -> SkolemInfo
DataConSkol :: Name -> SkolemInfo
ReifySkol :: SkolemInfo
QuantCtxtSkol :: SkolemInfo
RuntimeUnkSkol :: SkolemInfo
UnkSkol :: SkolemInfo
pprSigSkolInfo :: UserTypeCtxt -> TcType -> SDoc
pprSkolInfo :: SkolemInfo -> SDoc
data CtOrigin

-- | A given constraint from a user-written type signature. The
--   <a>SkolemInfo</a> inside gives more information.
GivenOrigin :: SkolemInfo -> CtOrigin

-- | <a>InstSCOrigin</a> is used for a Given constraint obtained by
--   superclass selection from the context of an instance declaration. E.g.
--   instance <tt>(Foo a, Bar a) =&gt; C [a]</tt> where ... When
--   typechecking the instance decl itself, including producing evidence
--   for the superclasses of <tt>C</tt>, the superclasses of <tt>(Foo
--   a)</tt> and <tt>(Bar a)</tt> will have <a>InstSCOrigin</a> origin.
InstSCOrigin :: ScDepth -> TypeSize -> CtOrigin

-- | <a>OtherSCOrigin</a> is used for a Given constraint obtained by
--   superclass selection from a constraint <i>other than</i> the context
--   of an instance declaration. (For the latter we use
--   <a>InstSCOrigin</a>.) E.g. f :: Foo a =&gt; blah f = e When
--   typechecking body of <tt>f</tt>, the superclasses of the Given (Foo a)
--   will have <a>OtherSCOrigin</a>. Needed for Note [Replacement vs
--   keeping] and Note [Use only the best local instance], both in
--   GHC.Tc.Solver.Interact.
OtherSCOrigin :: ScDepth -> SkolemInfo -> CtOrigin
OccurrenceOf :: Name -> CtOrigin
OccurrenceOfRecSel :: RdrName -> CtOrigin
AppOrigin :: CtOrigin
SpecPragOrigin :: UserTypeCtxt -> CtOrigin
TypeEqOrigin :: TcType -> TcType -> Maybe SDoc -> Bool -> CtOrigin
[uo_actual] :: CtOrigin -> TcType
[uo_expected] :: CtOrigin -> TcType

-- | The thing that has type "actual"
[uo_thing] :: CtOrigin -> Maybe SDoc

-- | Is at least one of the three elements above visible? (Errors from the
--   polymorphic subsumption check are considered visible.) Only used for
--   prioritizing error messages.
[uo_visible] :: CtOrigin -> Bool
KindEqOrigin :: TcType -> TcType -> CtOrigin -> Maybe TypeOrKind -> CtOrigin
IPOccOrigin :: HsIPName -> CtOrigin
OverLabelOrigin :: FastString -> CtOrigin
LiteralOrigin :: HsOverLit GhcRn -> CtOrigin
NegateOrigin :: CtOrigin
ArithSeqOrigin :: ArithSeqInfo GhcRn -> CtOrigin
AssocFamPatOrigin :: CtOrigin
SectionOrigin :: CtOrigin
HasFieldOrigin :: FastString -> CtOrigin
TupleOrigin :: CtOrigin
ExprSigOrigin :: CtOrigin
PatSigOrigin :: CtOrigin
PatOrigin :: CtOrigin
ProvCtxtOrigin :: PatSynBind GhcRn GhcRn -> CtOrigin
RecordUpdOrigin :: CtOrigin
ViewPatOrigin :: CtOrigin

-- | <a>ScOrigin</a> is used only for the Wanted constraints for the
--   superclasses of an instance declaration. If the instance head is <tt>C
--   ty1 .. tyn</tt> then <tt>TypeSize = sizeTypes [ty1, .., tyn]</tt> See
--   Note [Solving superclass constraints] in GHC.Tc.TyCl.Instance
ScOrigin :: TypeSize -> CtOrigin
DerivClauseOrigin :: CtOrigin
DerivOriginDC :: DataCon -> Int -> Bool -> CtOrigin
DerivOriginCoerce :: Id -> Type -> Type -> Bool -> CtOrigin
StandAloneDerivOrigin :: CtOrigin
DefaultOrigin :: CtOrigin
DoOrigin :: CtOrigin
DoPatOrigin :: LPat GhcRn -> CtOrigin
MCompOrigin :: CtOrigin
MCompPatOrigin :: LPat GhcRn -> CtOrigin
IfOrigin :: CtOrigin
ProcOrigin :: CtOrigin
AnnOrigin :: CtOrigin
FunDepOrigin1 :: PredType -> CtOrigin -> RealSrcSpan -> PredType -> CtOrigin -> RealSrcSpan -> CtOrigin
FunDepOrigin2 :: PredType -> CtOrigin -> PredType -> SrcSpan -> CtOrigin
ExprHoleOrigin :: Maybe OccName -> CtOrigin
TypeHoleOrigin :: OccName -> CtOrigin
PatCheckOrigin :: CtOrigin
ListOrigin :: CtOrigin
BracketOrigin :: CtOrigin
StaticOrigin :: CtOrigin
Shouldn'tHappenOrigin :: String -> CtOrigin
InstProvidedOrigin :: Module -> ClsInst -> CtOrigin
NonLinearPatternOrigin :: CtOrigin
UsageEnvironmentOf :: Name -> CtOrigin
CycleBreakerOrigin :: CtOrigin -> CtOrigin
InstanceSigOrigin :: Name -> Type -> Type -> CtOrigin
AmbiguityCheckOrigin :: UserTypeCtxt -> CtOrigin
GhcBug20076 :: CtOrigin
exprCtOrigin :: HsExpr GhcRn -> CtOrigin

-- | Extract a suitable CtOrigin from a HsExpr
lexprCtOrigin :: LHsExpr GhcRn -> CtOrigin

-- | Extract a suitable CtOrigin from a MatchGroup
matchesCtOrigin :: MatchGroup GhcRn (LHsExpr GhcRn) -> CtOrigin

-- | Extract a suitable CtOrigin from guarded RHSs
grhssCtOrigin :: GRHSs GhcRn (LHsExpr GhcRn) -> CtOrigin
isVisibleOrigin :: CtOrigin -> Bool
toInvisibleOrigin :: CtOrigin -> CtOrigin
pprCtOrigin :: CtOrigin -> SDoc
isGivenOrigin :: CtOrigin -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.CtOrigin
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.SkolemInfo

module GHC.Hs
data Fixity

-- | Haskell Module
--   
--   All we actually declare here is the top-level structure for a module.
data HsModule
HsModule :: EpAnn AnnsModule -> LayoutInfo -> Maybe (LocatedA ModuleName) -> Maybe (LocatedL [LIE GhcPs]) -> [LImportDecl GhcPs] -> [LHsDecl GhcPs] -> Maybe (LocatedP WarningTxt) -> Maybe LHsDocString -> HsModule
[hsmodAnn] :: HsModule -> EpAnn AnnsModule

-- | Layout info for the module. For incomplete modules (e.g. the output of
--   parseHeader), it is NoLayoutInfo.
[hsmodLayout] :: HsModule -> LayoutInfo

-- | <tt>Nothing</tt>: "module X where" is omitted (in which case the next
--   field is Nothing too)
[hsmodName] :: HsModule -> Maybe (LocatedA ModuleName)

-- | Export list
--   
--   <ul>
--   <li><tt>Nothing</tt>: export list omitted, so export everything</li>
--   <li><tt>Just []</tt>: export <i>nothing</i></li>
--   <li><tt>Just [...]</tt>: as you would expect...</li>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a> ,<a>AnnClose</a></li>
--   </ul>
[hsmodExports] :: HsModule -> Maybe (LocatedL [LIE GhcPs])

-- | We snaffle interesting stuff out of the imported interfaces early on,
--   adding that info to TyDecls/etc; so this list is often empty,
--   downstream.
[hsmodImports] :: HsModule -> [LImportDecl GhcPs]

-- | Type, class, value, and interface signature decls
[hsmodDecls] :: HsModule -> [LHsDecl GhcPs]

-- | reason/explanation for warning/deprecation of this module
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a> ,<a>AnnClose</a></li>
--   </ul>
[hsmodDeprecMessage] :: HsModule -> Maybe (LocatedP WarningTxt)

-- | Haddock module info and description, unparsed
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a> ,<a>AnnClose</a></li>
--   </ul>
[hsmodHaddockModHeader] :: HsModule -> Maybe LHsDocString
data AnnsModule
AnnsModule :: [AddEpAnn] -> AnnList -> AnnsModule
[am_main] :: AnnsModule -> [AddEpAnn]
[am_decls] :: AnnsModule -> AnnList
data HsParsedModule
HsParsedModule :: Located HsModule -> [FilePath] -> HsParsedModule
[hpm_module] :: HsParsedModule -> Located HsModule

-- | extra source files (e.g. from #includes). The lexer collects these
--   from '# <a>file</a> <a>line</a>' pragmas, which the C preprocessor
--   leaves behind. These files and their timestamps are stored in the .hi
--   file, so that we can force recompilation if any of them change (#3589)
[hpm_src_files] :: HsParsedModule -> [FilePath]
instance GHC.Classes.Eq GHC.Hs.AnnsModule
instance Data.Data.Data GHC.Hs.AnnsModule
instance Data.Data.Data GHC.Hs.HsModule
instance GHC.Utils.Outputable.Outputable GHC.Hs.HsModule

module Language.Haskell.Syntax

module GHC.Hs.Pat

-- | Pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnBang</a></li>
--   </ul>
data Pat p

-- | Wildcard Pattern The sole reason for a type on a WildPat is to support
--   hsPatType :: Pat Id -&gt; Type
WildPat :: XWildPat p -> Pat p

-- | Variable Pattern
VarPat :: XVarPat p -> LIdP p -> Pat p

-- | Lazy Pattern ^ - <a>AnnKeywordId</a> : <a>AnnTilde</a>
LazyPat :: XLazyPat p -> LPat p -> Pat p

-- | As pattern ^ - <a>AnnKeywordId</a> : <a>AnnAt</a>
AsPat :: XAsPat p -> LIdP p -> LPat p -> Pat p

-- | Parenthesised pattern See Note [Parens in HsSyn] in GHC.Hs.Expr ^ -
--   <a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>, <a>AnnClose</a>
--   <tt>')'</tt>
ParPat :: XParPat p -> LPat p -> Pat p

-- | Bang pattern ^ - <a>AnnKeywordId</a> : <a>AnnBang</a>
BangPat :: XBangPat p -> LPat p -> Pat p

-- | Syntactic List
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>, <a>AnnClose</a>
--   <tt>']'</tt></li>
--   </ul>
ListPat :: XListPat p -> [LPat p] -> Pat p

-- | Tuple sub-patterns
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt> or
--   <tt>'(#'</tt>, <a>AnnClose</a> <tt>')'</tt> or <tt>'#)'</tt></li>
--   </ul>
TuplePat :: XTuplePat p -> [LPat p] -> Boxity -> Pat p

-- | Anonymous sum pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(#'</tt>,
--   <a>AnnClose</a> <tt>'#)'</tt></li>
--   </ul>
SumPat :: XSumPat p -> LPat p -> ConTag -> Arity -> Pat p

-- | Constructor Pattern
ConPat :: XConPat p -> XRec p (ConLikeP p) -> HsConPatDetails p -> Pat p
[pat_con_ext] :: Pat p -> XConPat p
[pat_con] :: Pat p -> XRec p (ConLikeP p)
[pat_args] :: Pat p -> HsConPatDetails p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a></li>
--   </ul>
ViewPat :: XViewPat p -> LHsExpr p -> LPat p -> Pat p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'$('</tt> <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
SplicePat :: XSplicePat p -> HsSplice p -> Pat p

-- | Literal Pattern Used for *non-overloaded* literal patterns: Int#,
--   Char#, Int, Char, String, etc.
LitPat :: XLitPat p -> HsLit p -> Pat p

-- | Natural Pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnVal</a> <tt><a>+</a></tt></li>
--   </ul>
NPat :: XNPat p -> XRec p (HsOverLit p) -> Maybe (SyntaxExpr p) -> SyntaxExpr p -> Pat p

-- | n+k pattern
NPlusKPat :: XNPlusKPat p -> LIdP p -> XRec p (HsOverLit p) -> HsOverLit p -> SyntaxExpr p -> SyntaxExpr p -> Pat p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
SigPat :: XSigPat p -> LPat p -> HsPatSigType (NoGhcTc p) -> Pat p

-- | Trees that Grow extension point for new constructors
XPat :: !XXPat p -> Pat p
type LPat p = XRec p (Pat p)
data EpAnnSumPat
EpAnnSumPat :: [AddEpAnn] -> [EpaLocation] -> [EpaLocation] -> EpAnnSumPat
[sumPatParens] :: EpAnnSumPat -> [AddEpAnn]
[sumPatVbarsBefore] :: EpAnnSumPat -> [EpaLocation]
[sumPatVbarsAfter] :: EpAnnSumPat -> [EpaLocation]

-- | This is the extension field for ConPat, added after typechecking It
--   adds quite a few extra fields, to support elaboration of pattern
--   matching.
data ConPatTc
ConPatTc :: [Type] -> [TyVar] -> [EvVar] -> TcEvBinds -> HsWrapper -> ConPatTc

-- | The universal arg types 1-1 with the universal tyvars of the
--   constructor/pattern synonym Use (conLikeResTy pat_con cpt_arg_tys) to
--   get the type of the pattern
[cpt_arg_tys] :: ConPatTc -> [Type]

-- | Existentially bound type variables in correctly-scoped order e.g. [k:*
--   x:k]
[cpt_tvs] :: ConPatTc -> [TyVar]

-- | Ditto *coercion variables* and *dictionaries* One reason for putting
--   coercion variable here I think is to ensure their kinds are zonked
[cpt_dicts] :: ConPatTc -> [EvVar]

-- | Bindings involving those dictionaries
[cpt_binds] :: ConPatTc -> TcEvBinds
[cpt_wrap] :: ConPatTc -> HsWrapper

-- | Coercion Pattern (translation only)
--   
--   During desugaring a (CoPat co pat) turns into a cast with <tt>co</tt>
--   on the scrutinee, followed by a match on <tt>pat</tt>.
data CoPat
CoPat :: HsWrapper -> Pat GhcTc -> Type -> CoPat

-- | Coercion Pattern If co :: t1 ~ t2, p :: t2, then (CoPat co p) :: t1
[co_cpt_wrap] :: CoPat -> HsWrapper

-- | Why not LPat? Ans: existing locn will do
[co_pat_inner] :: CoPat -> Pat GhcTc

-- | Type of whole pattern, t1
[co_pat_ty] :: CoPat -> Type
data ListPatTc
ListPatTc :: Type -> Maybe (Type, SyntaxExpr GhcTc) -> ListPatTc
type family ConLikeP x

-- | Haskell Constructor Pattern Details
type HsConPatDetails p = HsConDetails (HsPatSigType (NoGhcTc p)) (LPat p) (HsRecFields p (LPat p))
hsConPatArgs :: forall p. UnXRec p => HsConPatDetails p -> [LPat p]

-- | Haskell Record Fields
--   
--   HsRecFields is used only for patterns and expressions (not data type
--   declarations)
data HsRecFields p arg
HsRecFields :: [LHsRecField p arg] -> Maybe (Located Int) -> HsRecFields p arg
[rec_flds] :: HsRecFields p arg -> [LHsRecField p arg]
[rec_dotdot] :: HsRecFields p arg -> Maybe (Located Int)

-- | Haskell Record Field
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnEqual</a>,</li>
--   </ul>
--   
--   For details on above see note [exact print annotations] in
--   GHC.Parser.Annotation
data HsRecField' id arg
HsRecField :: XHsRecField id -> Located id -> arg -> Bool -> HsRecField' id arg
[hsRecFieldAnn] :: HsRecField' id arg -> XHsRecField id
[hsRecFieldLbl] :: HsRecField' id arg -> Located id

-- | Filled in by renamer when punning
[hsRecFieldArg] :: HsRecField' id arg -> arg

-- | Note [Punning]
[hsRecPun] :: HsRecField' id arg -> Bool

-- | Located Haskell Record Field
type LHsRecField' p id arg = XRec p (HsRecField' id arg)

-- | Haskell Record Field
type HsRecField p arg = HsRecField' (FieldOcc p) arg

-- | Located Haskell Record Field
type LHsRecField p arg = XRec p (HsRecField p arg)

-- | Haskell Record Update Field
type HsRecUpdField p = HsRecField' (AmbiguousFieldOcc p) (LHsExpr p)

-- | Located Haskell Record Update Field
type LHsRecUpdField p = XRec p (HsRecUpdField p)
hsRecFields :: forall p arg. UnXRec p => HsRecFields p arg -> [XCFieldOcc p]
hsRecFieldSel :: HsRecField pass arg -> Located (XCFieldOcc pass)
hsRecFieldId :: HsRecField GhcTc arg -> Located Id
hsRecFieldsArgs :: forall p arg. UnXRec p => HsRecFields p arg -> [arg]
hsRecUpdFieldId :: HsRecField' (AmbiguousFieldOcc GhcTc) arg -> Located Id
hsRecUpdFieldOcc :: HsRecField' (AmbiguousFieldOcc GhcTc) arg -> LFieldOcc GhcTc
hsRecUpdFieldRdr :: HsRecUpdField (GhcPass p) -> Located RdrName
mkPrefixConPat :: DataCon -> [LPat GhcTc] -> [Type] -> LPat GhcTc
mkCharLitPat :: SourceText -> Char -> LPat GhcTc
mkNilPat :: Type -> LPat GhcTc

-- | Is the pattern any of combination of:
--   
--   <ul>
--   <li>(pat)</li>
--   <li>pat :: Type</li>
--   <li>~pat</li>
--   <li>!pat</li>
--   <li>x (variable)</li>
--   </ul>
isSimplePat :: LPat (GhcPass x) -> Maybe (IdP (GhcPass x))
looksLazyPatBind :: HsBind (GhcPass p) -> Bool
isBangedLPat :: LPat (GhcPass p) -> Bool

-- | <tt><a>patNeedsParens</a> p pat</tt> returns <a>True</a> if the
--   pattern <tt>pat</tt> needs parentheses under precedence <tt>p</tt>.
patNeedsParens :: forall p. IsPass p => PprPrec -> Pat (GhcPass p) -> Bool

-- | <tt><a>parenthesizePat</a> p pat</tt> checks if
--   <tt><a>patNeedsParens</a> p pat</tt> is true, and if so, surrounds
--   <tt>pat</tt> with a <a>ParPat</a>. Otherwise, it simply returns
--   <tt>pat</tt>.
parenthesizePat :: IsPass p => PprPrec -> LPat (GhcPass p) -> LPat (GhcPass p)
isIrrefutableHsPat :: forall p. OutputableBndrId p => DynFlags -> LPat (GhcPass p) -> Bool
collectEvVarsPat :: Pat GhcTc -> Bag EvVar
collectEvVarsPats :: [Pat GhcTc] -> Bag EvVar
pprParendLPat :: OutputableBndrId p => PprPrec -> LPat (GhcPass p) -> SDoc
pprConArgs :: (OutputableBndrId p, Outputable (Anno (IdGhcP p))) => HsConPatDetails (GhcPass p) -> SDoc
pprLPat :: OutputableBndrId p => LPat (GhcPass p) -> SDoc
instance Data.Data.Data GHC.Hs.Pat.EpAnnSumPat
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Pat.Pat (GHC.Hs.Extension.GhcPass p))


-- | Source-language literals
module GHC.Hs.Lit

-- | Convert a literal from one index type to another
convertLit :: HsLit (GhcPass p1) -> HsLit (GhcPass p2)
overLitType :: HsOverLit GhcTc -> Type

-- | pmPprHsLit pretty prints literals and is used when pretty printing
--   pattern match warnings. All are printed the same (i.e., without hashes
--   if they are primitive and not wrapped in constructors if they are
--   boxed). This happens mainly for too reasons: * We do not want to
--   expose their internal representation * The warnings become too messy
pmPprHsLit :: HsLit (GhcPass x) -> SDoc
pp_st_suffix :: SourceText -> SDoc -> SDoc -> SDoc
data OverLitTc
OverLitTc :: Bool -> Type -> OverLitTc
[ol_rebindable] :: OverLitTc -> Bool
[ol_type] :: OverLitTc -> Type
instance Data.Data.Data GHC.Hs.Lit.OverLitTc
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Lit.HsLit (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Lit.HsOverLit (GHC.Hs.Extension.GhcPass p))

module GHC.Hs.Binds
emptyLHsBinds :: LHsBindsLR (GhcPass idL) idR
emptyLocalBinds :: HsLocalBindsLR (GhcPass a) (GhcPass b)
emptyValBindsIn :: HsValBindsLR (GhcPass a) (GhcPass b)
emptyValBindsOut :: HsValBindsLR (GhcPass a) (GhcPass b)
eqEmptyLocalBinds :: HsLocalBindsLR a b -> Bool
isEmptyIPBindsPR :: HsIPBinds (GhcPass p) -> Bool
isEmptyIPBindsTc :: HsIPBinds GhcTc -> Bool
isEmptyLHsBinds :: LHsBindsLR (GhcPass idL) idR -> Bool
isEmptyValBinds :: HsValBindsLR (GhcPass a) (GhcPass b) -> Bool
plusHsValBinds :: HsValBinds (GhcPass a) -> HsValBinds (GhcPass a) -> HsValBinds (GhcPass a)
pprDeclList :: [SDoc] -> SDoc
pprLHsBinds :: (OutputableBndrId idL, OutputableBndrId idR) => LHsBindsLR (GhcPass idL) (GhcPass idR) -> SDoc
pprLHsBindsForUser :: (OutputableBndrId idL, OutputableBndrId idR, OutputableBndrId id2) => LHsBindsLR (GhcPass idL) (GhcPass idR) -> [LSig (GhcPass id2)] -> [SDoc]
pprMinimalSig :: OutputableBndr name => LBooleanFormula (GenLocated l name) -> SDoc
pprSpec :: OutputableBndr id => id -> SDoc -> InlinePragma -> SDoc
pprTcSpecPrags :: TcSpecPrags -> SDoc
pprTicks :: SDoc -> SDoc -> SDoc
pprVarSig :: OutputableBndr id => [id] -> SDoc -> SDoc
ppr_monobind :: forall idL idR. (OutputableBndrId idL, OutputableBndrId idR) => HsBindLR (GhcPass idL) (GhcPass idR) -> SDoc
ppr_sig :: forall p. OutputableBndrId p => Sig (GhcPass p) -> SDoc
pragBrackets :: SDoc -> SDoc

-- | Using SourceText in case the pragma was spelled differently or used
--   mixed case
pragSrcBrackets :: SourceText -> String -> SDoc -> SDoc
data AnnSig
AnnSig :: AddEpAnn -> [AddEpAnn] -> AnnSig
[asDcolon] :: AnnSig -> AddEpAnn
[asRest] :: AnnSig -> [AddEpAnn]
data NHsValBindsLR idL
NValBinds :: [(RecFlag, LHsBinds idL)] -> [LSig GhcRn] -> NHsValBindsLR idL
instance Data.Data.Data GHC.Hs.Binds.AnnSig
instance (GHC.Hs.Extension.OutputableBndrId pl, GHC.Hs.Extension.OutputableBndrId pr) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.HsValBindsLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr))
instance (GHC.Hs.Extension.OutputableBndrId pl, GHC.Hs.Extension.OutputableBndrId pr) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.HsLocalBindsLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr))
instance (GHC.Hs.Extension.OutputableBndrId pl, GHC.Hs.Extension.OutputableBndrId pr) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.HsBindLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.ABExport (GHC.Hs.Extension.GhcPass p))
instance (GHC.Hs.Extension.OutputableBndrId l, GHC.Hs.Extension.OutputableBndrId r) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.PatSynBind (GHC.Hs.Extension.GhcPass l) (GHC.Hs.Extension.GhcPass r))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.HsIPBinds (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.IPBind (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.Sig (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.FixitySig (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Binds.TcSpecPrag

module GHC.Hs.Instances
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsLocalBindsLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsLocalBindsLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsLocalBindsLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsLocalBindsLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsValBindsLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsValBindsLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsValBindsLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsValBindsLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (GHC.Hs.Binds.NHsValBindsLR GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (GHC.Hs.Binds.NHsValBindsLR GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (GHC.Hs.Binds.NHsValBindsLR GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsBindLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsBindLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsBindLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsBindLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.ABExport GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.ABExport GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.ABExport GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.RecordPatSynField GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.RecordPatSynField GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.RecordPatSynField GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.PatSynBind GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.PatSynBind GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.PatSynBind GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.PatSynBind GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsIPBinds GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsIPBinds GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsIPBinds GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.IPBind GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.IPBind GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.IPBind GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.Sig GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.Sig GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.Sig GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.FixitySig GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.FixitySig GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.FixitySig GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsPatSynDir GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsPatSynDir GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsPatSynDir GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsGroup GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsGroup GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsGroup GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.SpliceDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.SpliceDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.SpliceDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyClDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyClDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyClDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FunDep GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FunDep GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FunDep GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyClGroup GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyClGroup GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyClGroup GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyResultSig GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyResultSig GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyResultSig GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.InjectivityAnn GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.InjectivityAnn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.InjectivityAnn GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyInfo GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyInfo GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyInfo GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsConDeclGADTDetails GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsConDeclGADTDetails GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsConDeclGADTDetails GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyFamInstDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyFamInstDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyFamInstDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DataFamInstDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DataFamInstDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DataFamInstDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data rhs => Data.Data.Data (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcPs rhs)
instance Data.Data.Data rhs => Data.Data.Data (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcRn rhs)
instance Data.Data.Data rhs => Data.Data.Data (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcTc rhs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ClsInstDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ClsInstDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ClsInstDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.InstDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.InstDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.InstDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivStrategy GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivStrategy GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivStrategy GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DefaultDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DefaultDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DefaultDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecls GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecls GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecls GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleBndr GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleBndr GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleBndr GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecls GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecls GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecls GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.AnnProvenance GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.AnnProvenance GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.AnnProvenance GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.AnnDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.AnnDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.AnnDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RoleAnnotDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RoleAnnotDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RoleAnnotDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.FieldLabelStrings GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.FieldLabelStrings GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.FieldLabelStrings GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsFieldLabel GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsFieldLabel GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsFieldLabel GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsPragE GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsPragE GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsPragE GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsTupArg GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsTupArg GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsTupArg GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmdTop GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmdTop GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmdTop GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data GHC.Hs.Expr.RecStmtTc
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ParStmtBlock GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ParStmtBlock GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ParStmtBlock GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ParStmtBlock GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ApplicativeArg GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ApplicativeArg GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ApplicativeArg GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsStmtContext GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsStmtContext GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsStmtContext GHC.Hs.Extension.GhcTc)
instance Data.Data.Data Language.Haskell.Syntax.Expr.HsArrowMatchContext
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsMatchContext GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsMatchContext GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsMatchContext GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsSplice GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsSplice GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsSplice GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsSplicedThing GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsSplicedThing GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsSplicedThing GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsBracket GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsBracket GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsBracket GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ArithSeqInfo GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ArithSeqInfo GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ArithSeqInfo GHC.Hs.Extension.GhcTc)
instance Data.Data.Data GHC.Hs.Expr.RecordUpdTc
instance Data.Data.Data GHC.Hs.Expr.CmdTopTc
instance Data.Data.Data GHC.Hs.Expr.PendingRnSplice
instance Data.Data.Data GHC.Hs.Expr.PendingTcSplice
instance Data.Data.Data GHC.Hs.Expr.SyntaxExprRn
instance Data.Data.Data GHC.Hs.Expr.SyntaxExprTc
instance Data.Data.Data GHC.Hs.Expr.XBindStmtRn
instance Data.Data.Data GHC.Hs.Expr.XBindStmtTc
instance Data.Data.Data (Language.Haskell.Syntax.Lit.HsLit GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Lit.HsLit GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Lit.HsLit GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Lit.HsOverLit GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Lit.HsOverLit GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Lit.HsOverLit GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Pat.Pat GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Pat.Pat GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Pat.Pat GHC.Hs.Extension.GhcTc)
instance Data.Data.Data GHC.Hs.Pat.CoPat
instance Data.Data.Data GHC.Hs.Pat.ConPatTc
instance Data.Data.Data GHC.Hs.Pat.ListPatTc
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Language.Haskell.Syntax.Pat.HsRecField' a b)
instance Data.Data.Data body => Data.Data.Data (Language.Haskell.Syntax.Pat.HsRecFields GHC.Hs.Extension.GhcPs body)
instance Data.Data.Data body => Data.Data.Data (Language.Haskell.Syntax.Pat.HsRecFields GHC.Hs.Extension.GhcRn body)
instance Data.Data.Data body => Data.Data.Data (Language.Haskell.Syntax.Pat.HsRecFields GHC.Hs.Extension.GhcTc body)
instance Data.Data.Data (Language.Haskell.Syntax.Type.LHsQTyVars GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.LHsQTyVars GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.LHsQTyVars GHC.Hs.Extension.GhcTc)
instance Data.Data.Data flag => Data.Data.Data (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag GHC.Hs.Extension.GhcPs)
instance Data.Data.Data flag => Data.Data.Data (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag GHC.Hs.Extension.GhcRn)
instance Data.Data.Data flag => Data.Data.Data (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcTc)
instance Data.Data.Data thing => Data.Data.Data (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcPs thing)
instance Data.Data.Data thing => Data.Data.Data (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcRn thing)
instance Data.Data.Data thing => Data.Data.Data (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcTc thing)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsPatSigType GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsPatSigType GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsPatSigType GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsForAllTelescope GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsForAllTelescope GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsForAllTelescope GHC.Hs.Extension.GhcTc)
instance Data.Data.Data flag => Data.Data.Data (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcPs)
instance Data.Data.Data flag => Data.Data.Data (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcRn)
instance Data.Data.Data flag => Data.Data.Data (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsArrow GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsArrow GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsArrow GHC.Hs.Extension.GhcTc)
instance Data.Data.Data thing => Data.Data.Data (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcPs thing)
instance Data.Data.Data thing => Data.Data.Data (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcRn thing)
instance Data.Data.Data thing => Data.Data.Data (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcTc thing)
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Language.Haskell.Syntax.Type.HsArg a b)
instance Data.Data.Data (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.FieldOcc GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.FieldOcc GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.FieldOcc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.AmbiguousFieldOcc GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.AmbiguousFieldOcc GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.AmbiguousFieldOcc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (GHC.Hs.ImpExp.ImportDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (GHC.Hs.ImpExp.ImportDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (GHC.Hs.ImpExp.ImportDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (GHC.Hs.ImpExp.IE GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (GHC.Hs.ImpExp.IE GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (GHC.Hs.ImpExp.IE GHC.Hs.Extension.GhcTc)
instance GHC.Classes.Eq (GHC.Hs.ImpExp.IE GHC.Hs.Extension.GhcPs)
instance GHC.Classes.Eq (GHC.Hs.ImpExp.IE GHC.Hs.Extension.GhcRn)
instance GHC.Classes.Eq (GHC.Hs.ImpExp.IE GHC.Hs.Extension.GhcTc)
instance Data.Data.Data GHC.Hs.Expr.XXExprGhcTc
instance Data.Data.Data GHC.Hs.Decls.XViaStrategyPs

module GHC.Hs.ImpExp

-- | Located Import Declaration
type LImportDecl pass = XRec pass (ImportDecl pass) " When in a list this may have  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi'"

-- | If/how an import is <tt>qualified</tt>.
data ImportDeclQualifiedStyle

-- | <tt>qualified</tt> appears in prepositive position.
QualifiedPre :: ImportDeclQualifiedStyle

-- | <tt>qualified</tt> appears in postpositive position.
QualifiedPost :: ImportDeclQualifiedStyle

-- | Not qualified.
NotQualified :: ImportDeclQualifiedStyle

-- | Given two possible located <tt>qualified</tt> tokens, compute a style
--   (in a conforming Haskell program only one of the two can be not
--   <a>Nothing</a>). This is called from <a>GHC.Parser</a>.
importDeclQualifiedStyle :: Maybe EpaLocation -> Maybe EpaLocation -> (Maybe EpaLocation, ImportDeclQualifiedStyle)

-- | Convenience function to answer the question if an import decl. is
--   qualified.
isImportDeclQualified :: ImportDeclQualifiedStyle -> Bool

-- | Import Declaration
--   
--   A single Haskell <tt>import</tt> declaration.
data ImportDecl pass
ImportDecl :: XCImportDecl pass -> SourceText -> XRec pass ModuleName -> Maybe StringLiteral -> IsBootInterface -> Bool -> ImportDeclQualifiedStyle -> Bool -> Maybe (XRec pass ModuleName) -> Maybe (Bool, XRec pass [LIE pass]) -> ImportDecl pass
[ideclExt] :: ImportDecl pass -> XCImportDecl pass
[ideclSourceSrc] :: ImportDecl pass -> SourceText

-- | Module name.
[ideclName] :: ImportDecl pass -> XRec pass ModuleName

-- | Package qualifier.
[ideclPkgQual] :: ImportDecl pass -> Maybe StringLiteral

-- | IsBoot <a>=</a> {-# SOURCE #-} import
[ideclSource] :: ImportDecl pass -> IsBootInterface

-- | True =&gt; safe import
[ideclSafe] :: ImportDecl pass -> Bool

-- | If/how the import is qualified.
[ideclQualified] :: ImportDecl pass -> ImportDeclQualifiedStyle

-- | True =&gt; implicit import (of Prelude)
[ideclImplicit] :: ImportDecl pass -> Bool

-- | as Module
[ideclAs] :: ImportDecl pass -> Maybe (XRec pass ModuleName)

-- | (True =&gt; hiding, names)
[ideclHiding] :: ImportDecl pass -> Maybe (Bool, XRec pass [LIE pass])

-- | <a>AnnKeywordId</a>s
--   
--   <ul>
--   <li><a>AnnImport</a></li>
--   <li><a>AnnOpen</a>, <a>AnnClose</a> for ideclSource</li>
--   <li><a>AnnSafe</a>,<a>AnnQualified</a>,
--   <a>AnnPackageName</a>,<a>AnnAs</a>, <a>AnnVal</a></li>
--   <li><a>AnnHiding</a>,<a>AnnOpen</a>, <a>AnnClose</a> attached to
--   location in ideclHiding</li>
--   </ul>
XImportDecl :: !XXImportDecl pass -> ImportDecl pass
data EpAnnImportDecl
EpAnnImportDecl :: EpaLocation -> Maybe (EpaLocation, EpaLocation) -> Maybe EpaLocation -> Maybe EpaLocation -> Maybe EpaLocation -> Maybe EpaLocation -> EpAnnImportDecl
[importDeclAnnImport] :: EpAnnImportDecl -> EpaLocation
[importDeclAnnPragma] :: EpAnnImportDecl -> Maybe (EpaLocation, EpaLocation)
[importDeclAnnSafe] :: EpAnnImportDecl -> Maybe EpaLocation
[importDeclAnnQualified] :: EpAnnImportDecl -> Maybe EpaLocation
[importDeclAnnPackage] :: EpAnnImportDecl -> Maybe EpaLocation
[importDeclAnnAs] :: EpAnnImportDecl -> Maybe EpaLocation
simpleImportDecl :: ModuleName -> ImportDecl GhcPs

-- | A name in an import or export specification which may have adornments.
--   Used primarily for accurate pretty printing of ParsedSource, and API
--   Annotation placement. The <a>Annotation</a> is the location of the
--   adornment in the original source.
data IEWrappedName name

-- | no extra
IEName :: LocatedN name -> IEWrappedName name

-- | pattern X
IEPattern :: EpaLocation -> LocatedN name -> IEWrappedName name

-- | type (:+:)
IEType :: EpaLocation -> LocatedN name -> IEWrappedName name

-- | Located name with possible adornment - <a>AnnKeywordId</a>s :
--   <a>AnnType</a>, <a>AnnPattern</a>
type LIEWrappedName name = LocatedA (IEWrappedName name)

-- | Located Import or Export
type LIE pass = XRec pass (IE pass) " When in a list this may have  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma'"

-- | Imported or exported entity.
data IE pass

-- | Imported or Exported Variable
IEVar :: XIEVar pass -> LIEWrappedName (IdP pass) -> IE pass

-- | Imported or exported Thing with Absent list
--   
--   The thing is a Class/Type (can't tell) - <a>AnnKeywordId</a>s :
--   <a>AnnPattern</a>, <a>AnnType</a>,<a>AnnVal</a>
IEThingAbs :: XIEThingAbs pass -> LIEWrappedName (IdP pass) -> IE pass

-- | Imported or exported Thing with All imported or exported
--   
--   The thing is a Class<i>Type and the All refers to
--   methods</i>constructors
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a>,
--   <a>AnnDotdot</a>,<a>AnnClose</a>, <a>AnnType</a></li>
--   </ul>
IEThingAll :: XIEThingAll pass -> LIEWrappedName (IdP pass) -> IE pass

-- | Imported or exported Thing With given imported or exported
--   
--   The thing is a Class/Type and the imported or exported things are
--   methods/constructors and record fields; see Note [IEThingWith] -
--   <a>AnnKeywordId</a>s : <a>AnnOpen</a>, <a>AnnClose</a>,
--   <a>AnnComma</a>, <a>AnnType</a>
IEThingWith :: XIEThingWith pass -> LIEWrappedName (IdP pass) -> IEWildcard -> [LIEWrappedName (IdP pass)] -> IE pass

-- | Imported or exported module contents
--   
--   (Export Only)
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnModule</a></li>
--   </ul>
IEModuleContents :: XIEModuleContents pass -> XRec pass ModuleName -> IE pass

-- | Doc section heading
IEGroup :: XIEGroup pass -> Int -> HsDocString -> IE pass

-- | Some documentation
IEDoc :: XIEDoc pass -> HsDocString -> IE pass

-- | Reference to named doc
IEDocNamed :: XIEDocNamed pass -> String -> IE pass
XIE :: !XXIE pass -> IE pass

-- | Imported or Exported Wildcard
data IEWildcard
NoIEWildcard :: IEWildcard
IEWildcard :: Int -> IEWildcard
ieName :: IE (GhcPass p) -> IdP (GhcPass p)
ieNames :: IE (GhcPass p) -> [IdP (GhcPass p)]
ieWrappedLName :: IEWrappedName name -> LocatedN name
ieWrappedName :: IEWrappedName name -> name
lieWrappedName :: LIEWrappedName name -> name
ieLWrappedName :: LIEWrappedName name -> LocatedN name
replaceWrappedName :: IEWrappedName name1 -> name2 -> IEWrappedName name2
replaceLWrappedName :: LIEWrappedName name1 -> name2 -> LIEWrappedName name2
pprImpExp :: (HasOccName name, OutputableBndr name) => name -> SDoc
instance Data.Data.Data GHC.Hs.ImpExp.ImportDeclQualifiedStyle
instance GHC.Classes.Eq GHC.Hs.ImpExp.ImportDeclQualifiedStyle
instance Data.Data.Data GHC.Hs.ImpExp.EpAnnImportDecl
instance Data.Data.Data name => Data.Data.Data (GHC.Hs.ImpExp.IEWrappedName name)
instance GHC.Classes.Eq name => GHC.Classes.Eq (GHC.Hs.ImpExp.IEWrappedName name)
instance Data.Data.Data GHC.Hs.ImpExp.IEWildcard
instance GHC.Classes.Eq GHC.Hs.ImpExp.IEWildcard
instance (GHC.Hs.Extension.OutputableBndrId p, GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.Anno (GHC.Hs.ImpExp.IE (GHC.Hs.Extension.GhcPass p)))) => GHC.Utils.Outputable.Outputable (GHC.Hs.ImpExp.ImportDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (GHC.Hs.ImpExp.IE (GHC.Hs.Extension.GhcPass p))
instance GHC.Types.Name.Occurrence.HasOccName name => GHC.Types.Name.Occurrence.HasOccName (GHC.Hs.ImpExp.IEWrappedName name)
instance GHC.Utils.Outputable.OutputableBndr name => GHC.Utils.Outputable.OutputableBndr (GHC.Hs.ImpExp.IEWrappedName name)
instance GHC.Utils.Outputable.OutputableBndr name => GHC.Utils.Outputable.Outputable (GHC.Hs.ImpExp.IEWrappedName name)


-- | Abstract syntax of global declarations.
--   
--   Definitions for: <tt>SynDecl</tt> and <tt>ConDecl</tt>,
--   <tt>ClassDecl</tt>, <tt>InstDecl</tt>, <tt>DefaultDecl</tt> and
--   <tt>ForeignDecl</tt>.
module GHC.Hs.Decls

-- | A Haskell Declaration
data HsDecl p

-- | Type or Class Declaration
TyClD :: XTyClD p -> TyClDecl p -> HsDecl p

-- | Instance declaration
InstD :: XInstD p -> InstDecl p -> HsDecl p

-- | Deriving declaration
DerivD :: XDerivD p -> DerivDecl p -> HsDecl p

-- | Value declaration
ValD :: XValD p -> HsBind p -> HsDecl p

-- | Signature declaration
SigD :: XSigD p -> Sig p -> HsDecl p

-- | Standalone kind signature
KindSigD :: XKindSigD p -> StandaloneKindSig p -> HsDecl p

-- | 'default' declaration
DefD :: XDefD p -> DefaultDecl p -> HsDecl p

-- | Foreign declaration
ForD :: XForD p -> ForeignDecl p -> HsDecl p

-- | Warning declaration
WarningD :: XWarningD p -> WarnDecls p -> HsDecl p

-- | Annotation declaration
AnnD :: XAnnD p -> AnnDecl p -> HsDecl p

-- | Rule declaration
RuleD :: XRuleD p -> RuleDecls p -> HsDecl p

-- | Splice declaration (Includes quasi-quotes)
SpliceD :: XSpliceD p -> SpliceDecl p -> HsDecl p

-- | Documentation comment declaration
DocD :: XDocD p -> DocDecl -> HsDecl p

-- | Role annotation declaration
RoleAnnotD :: XRoleAnnotD p -> RoleAnnotDecl p -> HsDecl p
XHsDecl :: !XXHsDecl p -> HsDecl p
type LHsDecl p = XRec p (HsDecl p) " When in a list this may have  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' "

-- | Haskell Data type Definition
data HsDataDefn pass

-- | Declares a data type or newtype, giving its constructors <tt>
--   data/newtype T a = <a>constrs</a> data/newtype instance T [a] =
--   <a>constrs</a> </tt>
HsDataDefn :: XCHsDataDefn pass -> NewOrData -> Maybe (LHsContext pass) -> Maybe (XRec pass CType) -> Maybe (LHsKind pass) -> [LConDecl pass] -> HsDeriving pass -> HsDataDefn pass
[dd_ext] :: HsDataDefn pass -> XCHsDataDefn pass
[dd_ND] :: HsDataDefn pass -> NewOrData

-- | Context
[dd_ctxt] :: HsDataDefn pass -> Maybe (LHsContext pass)
[dd_cType] :: HsDataDefn pass -> Maybe (XRec pass CType)

-- | Optional kind signature.
--   
--   <tt>(Just k)</tt> for a GADT-style <tt>data</tt>, or <tt>data
--   instance</tt> decl, with explicit kind sig
--   
--   Always <tt>Nothing</tt> for H98-syntax decls
[dd_kindSig] :: HsDataDefn pass -> Maybe (LHsKind pass)

-- | Data constructors
--   
--   For <tt>data T a = T1 | T2 a</tt> the <a>LConDecl</a>s all have
--   <a>ConDeclH98</a>. For <tt>data T a where { T1 :: T a }</tt> the
--   <tt>LConDecls</tt> all have <a>ConDeclGADT</a>.
[dd_cons] :: HsDataDefn pass -> [LConDecl pass]

-- | Optional 'deriving' clause
[dd_derivs] :: HsDataDefn pass -> HsDeriving pass
XHsDataDefn :: !XXHsDataDefn pass -> HsDataDefn pass

-- | Haskell Deriving clause
type HsDeriving pass = [LHsDerivingClause pass] " The optional @deriving@ clauses of a data declaration. "Clauses" is plural because one can specify multiple deriving clauses using the @-XDerivingStrategies@ language extension.  The list of 'LHsDerivingClause's corresponds to exactly what the user requested to derive, in order. If no deriving clauses were specified, the list is empty."
type LHsFunDep pass = XRec pass (FunDep pass)

-- | A single <tt>deriving</tt> clause of a data declaration.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDeriving</a>, <a>AnnStock</a>,
--   <a>AnnAnyClass</a>, <a>AnnNewtype</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
data HsDerivingClause pass
HsDerivingClause :: XCHsDerivingClause pass -> Maybe (LDerivStrategy pass) -> LDerivClauseTys pass -> HsDerivingClause pass
[deriv_clause_ext] :: HsDerivingClause pass -> XCHsDerivingClause pass

-- | The user-specified strategy (if any) to use when deriving
--   <a>deriv_clause_tys</a>.
[deriv_clause_strategy] :: HsDerivingClause pass -> Maybe (LDerivStrategy pass)

-- | The types to derive.
[deriv_clause_tys] :: HsDerivingClause pass -> LDerivClauseTys pass
XHsDerivingClause :: !XXHsDerivingClause pass -> HsDerivingClause pass
type LHsDerivingClause pass = XRec pass (HsDerivingClause pass)

-- | The types mentioned in a single <tt>deriving</tt> clause. This can
--   come in two forms, <a>DctSingle</a> or <a>DctMulti</a>, depending on
--   whether the types are surrounded by enclosing parentheses or not.
--   These parentheses are semantically different than <a>HsParTy</a>. For
--   example, <tt>deriving ()</tt> means "derive zero classes" rather than
--   "derive an instance of the 0-tuple".
--   
--   <a>DerivClauseTys</a> use <a>LHsSigType</a> because <tt>deriving</tt>
--   clauses can mention type variables that aren't bound by the datatype,
--   e.g.
--   
--   <pre>
--   data T b = ... deriving (C [a])
--   </pre>
--   
--   should produce a derived instance for <tt>C [a] (T b)</tt>.
data DerivClauseTys pass

-- | A <tt>deriving</tt> clause with a single type. Moreover, that type can
--   only be a type constructor without any arguments.
--   
--   Example: <tt>deriving Eq</tt>
DctSingle :: XDctSingle pass -> LHsSigType pass -> DerivClauseTys pass

-- | A <tt>deriving</tt> clause with a comma-separated list of types,
--   surrounded by enclosing parentheses.
--   
--   Example: <tt>deriving (Eq, C a)</tt>
DctMulti :: XDctMulti pass -> [LHsSigType pass] -> DerivClauseTys pass
XDerivClauseTys :: !XXDerivClauseTys pass -> DerivClauseTys pass
type LDerivClauseTys pass = XRec pass (DerivClauseTys pass)
data NewOrData

-- | <pre>
--   newtype Blah ...
--   </pre>
NewType :: NewOrData

-- | <pre>
--   data Blah ...
--   </pre>
DataType :: NewOrData

-- | Convert a <a>NewOrData</a> to a <a>TyConFlavour</a>
newOrDataToFlavour :: NewOrData -> TyConFlavour
data StandaloneKindSig pass
StandaloneKindSig :: XStandaloneKindSig pass -> LIdP pass -> LHsSigType pass -> StandaloneKindSig pass
XStandaloneKindSig :: !XXStandaloneKindSig pass -> StandaloneKindSig pass

-- | Located Standalone Kind Signature
type LStandaloneKindSig pass = XRec pass (StandaloneKindSig pass)
standaloneKindSigName :: StandaloneKindSig (GhcPass p) -> IdP (GhcPass p)

-- | A type or class declaration.
data TyClDecl pass

-- | <pre>
--   type/data family T :: *-&gt;*
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnData</a>,
--   <a>AnnFamily</a>,<a>AnnDcolon</a>, <a>AnnWhere</a>,<a>AnnOpenP</a>,
--   <a>AnnDcolon</a>,<a>AnnCloseP</a>, <a>AnnEqual</a>,<a>AnnRarrow</a>,
--   <a>AnnVbar</a></li>
--   </ul>
FamDecl :: XFamDecl pass -> FamilyDecl pass -> TyClDecl pass
[tcdFExt] :: TyClDecl pass -> XFamDecl pass
[tcdFam] :: TyClDecl pass -> FamilyDecl pass

-- | <tt>type</tt> declaration
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnEqual</a>,</li>
--   </ul>
SynDecl :: XSynDecl pass -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> LHsType pass -> TyClDecl pass

-- | Post renameer, FVs
[tcdSExt] :: TyClDecl pass -> XSynDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity

-- | RHS of type declaration
[tcdRhs] :: TyClDecl pass -> LHsType pass

-- | <tt>data</tt> declaration
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnData</a>, <a>AnnFamily</a>,
--   <a>AnnNewType</a>, <a>AnnNewType</a>,<a>AnnDcolon</a>
--   <a>AnnWhere</a>,</li>
--   </ul>
DataDecl :: XDataDecl pass -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> HsDataDefn pass -> TyClDecl pass

-- | Post renamer, CUSK flag, FVs
[tcdDExt] :: TyClDecl pass -> XDataDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity
[tcdDataDefn] :: TyClDecl pass -> HsDataDefn pass
ClassDecl :: XClassDecl pass -> Maybe (LHsContext pass) -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> [LHsFunDep pass] -> [LSig pass] -> LHsBinds pass -> [LFamilyDecl pass] -> [LTyFamDefltDecl pass] -> [LDocDecl pass] -> TyClDecl pass

-- | Post renamer, FVs
[tcdCExt] :: TyClDecl pass -> XClassDecl pass

-- | Context...
[tcdCtxt] :: TyClDecl pass -> Maybe (LHsContext pass)

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity

-- | Functional deps
[tcdFDs] :: TyClDecl pass -> [LHsFunDep pass]

-- | Methods' signatures
[tcdSigs] :: TyClDecl pass -> [LSig pass]

-- | Default methods
[tcdMeths] :: TyClDecl pass -> LHsBinds pass

-- | Associated types;
[tcdATs] :: TyClDecl pass -> [LFamilyDecl pass]

-- | Associated type defaults
[tcdATDefs] :: TyClDecl pass -> [LTyFamDefltDecl pass]

-- | Haddock docs
[tcdDocs] :: TyClDecl pass -> [LDocDecl pass]
XTyClDecl :: !XXTyClDecl pass -> TyClDecl pass

-- | Located Declaration of a Type or Class
type LTyClDecl pass = XRec pass (TyClDecl pass)
data DataDeclRn
DataDeclRn :: Bool -> NameSet -> DataDeclRn

-- | does this have a CUSK? See Note [CUSKs: complete user-supplied kind
--   signatures]
[tcdDataCusk] :: DataDeclRn -> Bool
[tcdFVs] :: DataDeclRn -> NameSet

-- | Type or Class Group
data TyClGroup pass
TyClGroup :: XCTyClGroup pass -> [LTyClDecl pass] -> [LRoleAnnotDecl pass] -> [LStandaloneKindSig pass] -> [LInstDecl pass] -> TyClGroup pass
[group_ext] :: TyClGroup pass -> XCTyClGroup pass
[group_tyclds] :: TyClGroup pass -> [LTyClDecl pass]
[group_roles] :: TyClGroup pass -> [LRoleAnnotDecl pass]
[group_kisigs] :: TyClGroup pass -> [LStandaloneKindSig pass]
[group_instds] :: TyClGroup pass -> [LInstDecl pass]
XTyClGroup :: !XXTyClGroup pass -> TyClGroup pass
tyClGroupTyClDecls :: [TyClGroup pass] -> [LTyClDecl pass]
tyClGroupInstDecls :: [TyClGroup pass] -> [LInstDecl pass]
tyClGroupRoleDecls :: [TyClGroup pass] -> [LRoleAnnotDecl pass]
tyClGroupKindSigs :: [TyClGroup pass] -> [LStandaloneKindSig pass]

-- | type class
isClassDecl :: TyClDecl pass -> Bool

-- | <tt>True</tt> <a>=</a> argument is a <tt>data</tt>/<tt>newtype</tt>
--   declaration.
isDataDecl :: TyClDecl pass -> Bool

-- | type or type instance declaration
isSynDecl :: TyClDecl pass -> Bool
tcdName :: Anno (IdGhcP p) ~ SrcSpanAnnN => TyClDecl (GhcPass p) -> IdP (GhcPass p)

-- | type/data family declaration
isFamilyDecl :: TyClDecl pass -> Bool

-- | type family declaration
isTypeFamilyDecl :: TyClDecl pass -> Bool

-- | data family declaration
isDataFamilyDecl :: TyClDecl pass -> Bool

-- | open type family info
isOpenTypeFamilyInfo :: FamilyInfo pass -> Bool

-- | closed type family info
isClosedTypeFamilyInfo :: FamilyInfo pass -> Bool
tyFamInstDeclName :: Anno (IdGhcP p) ~ SrcSpanAnnN => TyFamInstDecl (GhcPass p) -> IdP (GhcPass p)
tyFamInstDeclLName :: Anno (IdGhcP p) ~ SrcSpanAnnN => TyFamInstDecl (GhcPass p) -> LocatedN (IdP (GhcPass p))
countTyClDecls :: [TyClDecl pass] -> (Int, Int, Int, Int, Int)
pprTyClDeclFlavour :: TyClDecl (GhcPass p) -> SDoc
tyClDeclLName :: Anno (IdGhcP p) ~ SrcSpanAnnN => TyClDecl (GhcPass p) -> LocatedN (IdP (GhcPass p))
tyClDeclTyVars :: TyClDecl pass -> LHsQTyVars pass

-- | Does this declaration have a complete, user-supplied kind signature?
--   See Note [CUSKs: complete user-supplied kind signatures]
hsDeclHasCusk :: TyClDecl GhcRn -> Bool
famResultKindSignature :: FamilyResultSig (GhcPass p) -> Maybe (LHsKind (GhcPass p))

-- | type Family Declaration
data FamilyDecl pass
FamilyDecl :: XCFamilyDecl pass -> FamilyInfo pass -> TopLevelFlag -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> LFamilyResultSig pass -> Maybe (LInjectivityAnn pass) -> FamilyDecl pass
[fdExt] :: FamilyDecl pass -> XCFamilyDecl pass
[fdInfo] :: FamilyDecl pass -> FamilyInfo pass
[fdTopLevel] :: FamilyDecl pass -> TopLevelFlag
[fdLName] :: FamilyDecl pass -> LIdP pass
[fdTyVars] :: FamilyDecl pass -> LHsQTyVars pass
[fdFixity] :: FamilyDecl pass -> LexicalFixity
[fdResultSig] :: FamilyDecl pass -> LFamilyResultSig pass
[fdInjectivityAnn] :: FamilyDecl pass -> Maybe (LInjectivityAnn pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnData</a>,
--   <a>AnnFamily</a>, <a>AnnWhere</a>, <a>AnnOpenP</a>, <a>AnnDcolon</a>,
--   <a>AnnCloseP</a>, <a>AnnEqual</a>, <a>AnnRarrow</a>,
--   <a>AnnVbar</a></li>
--   </ul>
XFamilyDecl :: !XXFamilyDecl pass -> FamilyDecl pass

-- | Located type Family Declaration
type LFamilyDecl pass = XRec pass (FamilyDecl pass)
data FunDep pass
FunDep :: XCFunDep pass -> [LIdP pass] -> [LIdP pass] -> FunDep pass
XFunDep :: !XXFunDep pass -> FunDep pass

-- | Instance Declaration
data InstDecl pass
ClsInstD :: XClsInstD pass -> ClsInstDecl pass -> InstDecl pass
[cid_d_ext] :: InstDecl pass -> XClsInstD pass
[cid_inst] :: InstDecl pass -> ClsInstDecl pass
DataFamInstD :: XDataFamInstD pass -> DataFamInstDecl pass -> InstDecl pass
[dfid_ext] :: InstDecl pass -> XDataFamInstD pass
[dfid_inst] :: InstDecl pass -> DataFamInstDecl pass
TyFamInstD :: XTyFamInstD pass -> TyFamInstDecl pass -> InstDecl pass
[tfid_ext] :: InstDecl pass -> XTyFamInstD pass
[tfid_inst] :: InstDecl pass -> TyFamInstDecl pass
XInstDecl :: !XXInstDecl pass -> InstDecl pass

-- | Located Instance Declaration
type LInstDecl pass = XRec pass (InstDecl pass)
data FamilyInfo pass
DataFamily :: FamilyInfo pass
OpenTypeFamily :: FamilyInfo pass

-- | <a>Nothing</a> if we're in an hs-boot file and the user said "type
--   family Foo x where .."
ClosedTypeFamily :: Maybe [LTyFamInstEqn pass] -> FamilyInfo pass

-- | Type Family Instance Declaration
data TyFamInstDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnInstance</a>,</li>
--   </ul>
TyFamInstDecl :: XCTyFamInstDecl pass -> TyFamInstEqn pass -> TyFamInstDecl pass
[tfid_xtn] :: TyFamInstDecl pass -> XCTyFamInstDecl pass
[tfid_eqn] :: TyFamInstDecl pass -> TyFamInstEqn pass
XTyFamInstDecl :: !XXTyFamInstDecl pass -> TyFamInstDecl pass

-- | Located Type Family Instance Declaration
type LTyFamInstDecl pass = XRec pass (TyFamInstDecl pass)
instDeclDataFamInsts :: [LInstDecl (GhcPass p)] -> [DataFamInstDecl (GhcPass p)]

-- | Type family default declarations. A convenient synonym for
--   <a>TyFamInstDecl</a>. See <tt>Note [Type family instance declarations
--   in HsSyn]</tt>.
type TyFamDefltDecl = TyFamInstDecl

-- | Located type family default declarations.
type LTyFamDefltDecl pass = XRec pass (TyFamDefltDecl pass)

-- | Data Family Instance Declaration
newtype DataFamInstDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnData</a>,
--   <a>AnnNewType</a>,<a>AnnInstance</a>, <a>AnnDcolon</a>
--   <a>AnnWhere</a>,<a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
DataFamInstDecl :: FamEqn pass (HsDataDefn pass) -> DataFamInstDecl pass
[dfid_eqn] :: DataFamInstDecl pass -> FamEqn pass (HsDataDefn pass)

-- | Located Data Family Instance Declaration
type LDataFamInstDecl pass = XRec pass (DataFamInstDecl pass)
pprDataFamInstFlavour :: DataFamInstDecl (GhcPass p) -> SDoc
pprTyFamInstDecl :: OutputableBndrId p => TopLevelFlag -> TyFamInstDecl (GhcPass p) -> SDoc
pprHsFamInstLHS :: OutputableBndrId p => IdP (GhcPass p) -> HsOuterFamEqnTyVarBndrs (GhcPass p) -> HsTyPats (GhcPass p) -> LexicalFixity -> Maybe (LHsContext (GhcPass p)) -> SDoc

-- | Family Equation
--   
--   One equation in a type family instance declaration, data family
--   instance declaration, or type family default. See Note [Type family
--   instance declarations in HsSyn] See Note [Family instance declaration
--   binders]
data FamEqn pass rhs
FamEqn :: XCFamEqn pass rhs -> LIdP pass -> HsOuterFamEqnTyVarBndrs pass -> HsTyPats pass -> LexicalFixity -> rhs -> FamEqn pass rhs
[feqn_ext] :: FamEqn pass rhs -> XCFamEqn pass rhs
[feqn_tycon] :: FamEqn pass rhs -> LIdP pass

-- | Optional quantified type vars
[feqn_bndrs] :: FamEqn pass rhs -> HsOuterFamEqnTyVarBndrs pass
[feqn_pats] :: FamEqn pass rhs -> HsTyPats pass

-- | Fixity used in the declaration
[feqn_fixity] :: FamEqn pass rhs -> LexicalFixity

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnEqual</a></li>
--   </ul>
[feqn_rhs] :: FamEqn pass rhs -> rhs
XFamEqn :: !XXFamEqn pass rhs -> FamEqn pass rhs

-- | Type Family Instance Equation
type TyFamInstEqn pass = FamEqn pass (LHsType pass)

-- | Located Type Family Instance Equation
type LTyFamInstEqn pass = XRec pass (TyFamInstEqn pass) " May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' when in a list"

-- | Haskell Type Patterns
type HsTyPats pass = [LHsTypeArg pass]

-- | Located Class Instance Declaration
type LClsInstDecl pass = XRec pass (ClsInstDecl pass)

-- | Class Instance Declaration
data ClsInstDecl pass
ClsInstDecl :: XCClsInstDecl pass -> LHsSigType pass -> LHsBinds pass -> [LSig pass] -> [LTyFamInstDecl pass] -> [LDataFamInstDecl pass] -> Maybe (XRec pass OverlapMode) -> ClsInstDecl pass
[cid_ext] :: ClsInstDecl pass -> XCClsInstDecl pass
[cid_poly_ty] :: ClsInstDecl pass -> LHsSigType pass
[cid_binds] :: ClsInstDecl pass -> LHsBinds pass
[cid_sigs] :: ClsInstDecl pass -> [LSig pass]
[cid_tyfam_insts] :: ClsInstDecl pass -> [LTyFamInstDecl pass]
[cid_datafam_insts] :: ClsInstDecl pass -> [LDataFamInstDecl pass]

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnClose</a>,</li>
--   </ul>
[cid_overlap_mode] :: ClsInstDecl pass -> Maybe (XRec pass OverlapMode)
XClsInstDecl :: !XXClsInstDecl pass -> ClsInstDecl pass

-- | Stand-alone 'deriving instance' declaration
data DerivDecl pass
DerivDecl :: XCDerivDecl pass -> LHsSigWcType pass -> Maybe (LDerivStrategy pass) -> Maybe (XRec pass OverlapMode) -> DerivDecl pass
[deriv_ext] :: DerivDecl pass -> XCDerivDecl pass

-- | The instance type to derive.
--   
--   It uses an <a>LHsSigWcType</a> because the context is allowed to be a
--   single wildcard:
--   
--   <pre>
--   deriving instance _ =&gt; Eq (Foo a)
--   </pre>
--   
--   Which signifies that the context should be inferred.
[deriv_type] :: DerivDecl pass -> LHsSigWcType pass
[deriv_strategy] :: DerivDecl pass -> Maybe (LDerivStrategy pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDeriving</a>, <a>AnnInstance</a>,
--   <a>AnnStock</a>, <a>AnnAnyClass</a>, <a>AnnNewtype</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
[deriv_overlap_mode] :: DerivDecl pass -> Maybe (XRec pass OverlapMode)
XDerivDecl :: !XXDerivDecl pass -> DerivDecl pass

-- | Located stand-alone 'deriving instance' declaration
type LDerivDecl pass = XRec pass (DerivDecl pass)

-- | Which technique the user explicitly requested when deriving an
--   instance.
data DerivStrategy pass

-- | GHC's "standard" strategy, which is to implement a custom instance for
--   the data type. This only works for certain types that GHC knows about
--   (e.g., <a>Eq</a>, <a>Show</a>, <a>Functor</a> when
--   <tt>-XDeriveFunctor</tt> is enabled, etc.)
StockStrategy :: XStockStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
AnyclassStrategy :: XAnyClassStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
NewtypeStrategy :: XNewtypeStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XDerivingVia
--   </pre>
ViaStrategy :: XViaStrategy pass -> DerivStrategy pass

-- | A <a>Located</a> <a>DerivStrategy</a>.
type LDerivStrategy pass = XRec pass (DerivStrategy pass)

-- | A short description of a <tt>DerivStrategy'</tt>.
derivStrategyName :: DerivStrategy a -> SDoc

-- | Eliminate a <a>DerivStrategy</a>.
foldDerivStrategy :: p ~ GhcPass pass => r -> (XViaStrategy p -> r) -> DerivStrategy p -> r

-- | Map over the <tt>via</tt> type if dealing with <a>ViaStrategy</a>.
--   Otherwise, return the <a>DerivStrategy</a> unchanged.
mapDerivStrategy :: p ~ GhcPass pass => (XViaStrategy p -> XViaStrategy p) -> DerivStrategy p -> DerivStrategy p
data XViaStrategyPs
XViaStrategyPs :: EpAnn [AddEpAnn] -> LHsSigType GhcPs -> XViaStrategyPs

-- | Located Rule Declarations
type LRuleDecls pass = XRec pass (RuleDecls pass)

-- | Rule Declarations
data RuleDecls pass
HsRules :: XCRuleDecls pass -> SourceText -> [LRuleDecl pass] -> RuleDecls pass
[rds_ext] :: RuleDecls pass -> XCRuleDecls pass
[rds_src] :: RuleDecls pass -> SourceText
[rds_rules] :: RuleDecls pass -> [LRuleDecl pass]
XRuleDecls :: !XXRuleDecls pass -> RuleDecls pass

-- | Rule Declaration
data RuleDecl pass
HsRule :: XHsRule pass -> XRec pass (SourceText, RuleName) -> Activation -> Maybe [LHsTyVarBndr () (NoGhcTc pass)] -> [LRuleBndr pass] -> XRec pass (HsExpr pass) -> XRec pass (HsExpr pass) -> RuleDecl pass

-- | After renamer, free-vars from the LHS and RHS
[rd_ext] :: RuleDecl pass -> XHsRule pass

-- | Note [Pragma source text] in <a>GHC.Types.Basic</a>
[rd_name] :: RuleDecl pass -> XRec pass (SourceText, RuleName)
[rd_act] :: RuleDecl pass -> Activation

-- | Forall'd type vars
[rd_tyvs] :: RuleDecl pass -> Maybe [LHsTyVarBndr () (NoGhcTc pass)]

-- | Forall'd term vars, before typechecking; after typechecking this
--   includes all forall'd vars
[rd_tmvs] :: RuleDecl pass -> [LRuleBndr pass]
[rd_lhs] :: RuleDecl pass -> XRec pass (HsExpr pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,<a>AnnTilde</a>,
--   <a>AnnVal</a>, <a>AnnClose</a>, <a>AnnForall</a>,<a>AnnDot</a>,
--   <a>AnnEqual</a>,</li>
--   </ul>
[rd_rhs] :: RuleDecl pass -> XRec pass (HsExpr pass)
XRuleDecl :: !XXRuleDecl pass -> RuleDecl pass

-- | Located Rule Declaration
type LRuleDecl pass = XRec pass (RuleDecl pass)
data HsRuleRn
HsRuleRn :: NameSet -> NameSet -> HsRuleRn
data HsRuleAnn
HsRuleAnn :: Maybe (AddEpAnn, AddEpAnn) -> Maybe (AddEpAnn, AddEpAnn) -> [AddEpAnn] -> HsRuleAnn

-- | The locations of <tt>forall</tt> and <a>.</a> for forall'd type vars
--   Using AddEpAnn to capture possible unicode variants
[ra_tyanns] :: HsRuleAnn -> Maybe (AddEpAnn, AddEpAnn)

-- | The locations of <tt>forall</tt> and <a>.</a> for forall'd term vars
--   Using AddEpAnn to capture possible unicode variants
[ra_tmanns] :: HsRuleAnn -> Maybe (AddEpAnn, AddEpAnn)
[ra_rest] :: HsRuleAnn -> [AddEpAnn]

-- | Rule Binder
data RuleBndr pass
RuleBndr :: XCRuleBndr pass -> LIdP pass -> RuleBndr pass
RuleBndrSig :: XRuleBndrSig pass -> LIdP pass -> HsPatSigType pass -> RuleBndr pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnDcolon</a>,<a>AnnClose</a></li>
--   </ul>
XRuleBndr :: !XXRuleBndr pass -> RuleBndr pass

-- | Located Rule Binder
type LRuleBndr pass = XRec pass (RuleBndr pass)
collectRuleBndrSigTys :: [RuleBndr pass] -> [HsPatSigType pass]
flattenRuleDecls :: [LRuleDecls (GhcPass p)] -> [LRuleDecl (GhcPass p)]
pprFullRuleName :: Located (SourceText, RuleName) -> SDoc

-- | Default Declaration
data DefaultDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnDefault</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
DefaultDecl :: XCDefaultDecl pass -> [LHsType pass] -> DefaultDecl pass
XDefaultDecl :: !XXDefaultDecl pass -> DefaultDecl pass

-- | Located Default Declaration
type LDefaultDecl pass = XRec pass (DefaultDecl pass)
data SpliceExplicitFlag

-- | <a>=</a> $(f x y)
ExplicitSplice :: SpliceExplicitFlag

-- | <a>=</a> f x y, i.e. a naked top level expression
ImplicitSplice :: SpliceExplicitFlag

-- | Splice Declaration
data SpliceDecl p
SpliceDecl :: XSpliceDecl p -> XRec p (HsSplice p) -> SpliceExplicitFlag -> SpliceDecl p
XSpliceDecl :: !XXSpliceDecl p -> SpliceDecl p

-- | Located Splice Declaration
type LSpliceDecl pass = XRec pass (SpliceDecl pass)

-- | Foreign Declaration
data ForeignDecl pass
ForeignImport :: XForeignImport pass -> LIdP pass -> LHsSigType pass -> ForeignImport -> ForeignDecl pass
[fd_i_ext] :: ForeignDecl pass -> XForeignImport pass
[fd_name] :: ForeignDecl pass -> LIdP pass
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fi] :: ForeignDecl pass -> ForeignImport

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnForeign</a>,
--   <a>AnnImport</a>,<a>AnnExport</a>, <a>AnnDcolon</a></li>
--   </ul>
ForeignExport :: XForeignExport pass -> LIdP pass -> LHsSigType pass -> ForeignExport -> ForeignDecl pass
[fd_e_ext] :: ForeignDecl pass -> XForeignExport pass
[fd_name] :: ForeignDecl pass -> LIdP pass
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fe] :: ForeignDecl pass -> ForeignExport
XForeignDecl :: !XXForeignDecl pass -> ForeignDecl pass

-- | Located Foreign Declaration
type LForeignDecl pass = XRec pass (ForeignDecl pass)
data ForeignImport
CImport :: Located CCallConv -> Located Safety -> Maybe Header -> CImportSpec -> Located SourceText -> ForeignImport
data ForeignExport
CExport :: Located CExportSpec -> Located SourceText -> ForeignExport
data CImportSpec
CLabel :: CLabelString -> CImportSpec
CFunction :: CCallTarget -> CImportSpec
CWrapper :: CImportSpec

-- | <pre>
--   data T b = forall a. Eq a =&gt; MkT a b
--     MkT :: forall b a. Eq a =&gt; MkT a b
--   
--   data T b where
--        MkT1 :: Int -&gt; T Int
--   
--   data T = Int <tt>MkT</tt> Int
--          | MkT2
--   
--   data T a where
--        Int <tt>MkT</tt> Int :: T Int
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a>,
--   <a>AnnDotdot</a>,<a>AnnCLose</a>, <a>AnnEqual</a>,<a>AnnVbar</a>,
--   <a>AnnDarrow</a>,<a>AnnDarrow</a>, <a>AnnForall</a>,<a>AnnDot</a></li>
--   </ul>
--   
--   data Constructor Declaration
data ConDecl pass
ConDeclGADT :: XConDeclGADT pass -> [LIdP pass] -> XRec pass (HsOuterSigTyVarBndrs pass) -> Maybe (LHsContext pass) -> HsConDeclGADTDetails pass -> LHsType pass -> Maybe LHsDocString -> ConDecl pass
[con_g_ext] :: ConDecl pass -> XConDeclGADT pass
[con_names] :: ConDecl pass -> [LIdP pass]

-- | The outermost type variable binders, be they explicit or implicit. The
--   <a>XRec</a> is used to anchor exact print annotations, AnnForall and
--   AnnDot.
[con_bndrs] :: ConDecl pass -> XRec pass (HsOuterSigTyVarBndrs pass)

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; never infix
[con_g_args] :: ConDecl pass -> HsConDeclGADTDetails pass

-- | Result type
[con_res_ty] :: ConDecl pass -> LHsType pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe LHsDocString
ConDeclH98 :: XConDeclH98 pass -> LIdP pass -> Bool -> [LHsTyVarBndr Specificity pass] -> Maybe (LHsContext pass) -> HsConDeclH98Details pass -> Maybe LHsDocString -> ConDecl pass
[con_ext] :: ConDecl pass -> XConDeclH98 pass
[con_name] :: ConDecl pass -> LIdP pass

-- | True <a>=</a> explicit user-written forall e.g. data T a = forall b.
--   MkT b (b-&gt;a) con_ex_tvs = {b} False =&gt; con_ex_tvs is empty
[con_forall] :: ConDecl pass -> Bool

-- | Existentials only
[con_ex_tvs] :: ConDecl pass -> [LHsTyVarBndr Specificity pass]

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; can be infix
[con_args] :: ConDecl pass -> HsConDeclH98Details pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe LHsDocString
XConDecl :: !XXConDecl pass -> ConDecl pass

-- | Located data Constructor Declaration
type LConDecl pass = XRec pass (ConDecl pass) " May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' when in a GADT constructor list"

-- | The arguments in a Haskell98-style data constructor.
type HsConDeclH98Details pass = HsConDetails Void (HsScaled pass (LBangType pass)) (XRec pass [LConDeclField pass])

-- | The arguments in a GADT constructor. Unlike Haskell98-style
--   constructors, GADT constructors cannot be declared with infix syntax.
--   As a result, we do not use <a>HsConDetails</a> here, as
--   <a>InfixCon</a> would be an unrepresentable state. (There is a notion
--   of infix GADT constructors for the purposes of derived Show
--   instancesâsee Note [Infix GADT constructors] in GHC.Tc.TyClâbut that
--   is an orthogonal concern.)
data HsConDeclGADTDetails pass
PrefixConGADT :: [HsScaled pass (LBangType pass)] -> HsConDeclGADTDetails pass
RecConGADT :: XRec pass [LConDeclField pass] -> HsConDeclGADTDetails pass
hsConDeclTheta :: Maybe (LHsContext (GhcPass p)) -> [LHsType (GhcPass p)]
getConNames :: ConDecl GhcRn -> [LocatedN Name]

-- | Return <tt><a>Just</a> fields</tt> if a data constructor declaration
--   uses record syntax (i.e., <a>RecCon</a>), where <tt>fields</tt> are
--   the field selectors. Otherwise, return <a>Nothing</a>.
getRecConArgs_maybe :: ConDecl GhcRn -> Maybe (LocatedL [LConDeclField GhcRn])

-- | Documentation comment Declaration
data DocDecl
DocCommentNext :: HsDocString -> DocDecl
DocCommentPrev :: HsDocString -> DocDecl
DocCommentNamed :: String -> HsDocString -> DocDecl
DocGroup :: Int -> HsDocString -> DocDecl

-- | Located Documentation comment Declaration
type LDocDecl pass = XRec pass (DocDecl)
docDeclDoc :: DocDecl -> HsDocString

-- | Warning pragma Declaration
data WarnDecl pass
Warning :: XWarning pass -> [LIdP pass] -> WarningTxt -> WarnDecl pass
XWarnDecl :: !XXWarnDecl pass -> WarnDecl pass

-- | Located Warning pragma Declaration
type LWarnDecl pass = XRec pass (WarnDecl pass)

-- | Warning pragma Declarations
data WarnDecls pass
Warnings :: XWarnings pass -> SourceText -> [LWarnDecl pass] -> WarnDecls pass
[wd_ext] :: WarnDecls pass -> XWarnings pass
[wd_src] :: WarnDecls pass -> SourceText
[wd_warnings] :: WarnDecls pass -> [LWarnDecl pass]
XWarnDecls :: !XXWarnDecls pass -> WarnDecls pass

-- | Located Warning Declarations
type LWarnDecls pass = XRec pass (WarnDecls pass)

-- | Annotation Declaration
data AnnDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnType</a>
--   <a>AnnModule</a> <a>AnnClose</a></li>
--   </ul>
HsAnnotation :: XHsAnnotation pass -> SourceText -> AnnProvenance pass -> XRec pass (HsExpr pass) -> AnnDecl pass
XAnnDecl :: !XXAnnDecl pass -> AnnDecl pass

-- | Located Annotation Declaration
type LAnnDecl pass = XRec pass (AnnDecl pass)

-- | Annotation Provenance
data AnnProvenance pass
ValueAnnProvenance :: LIdP pass -> AnnProvenance pass
TypeAnnProvenance :: LIdP pass -> AnnProvenance pass
ModuleAnnProvenance :: AnnProvenance pass
annProvenanceName_maybe :: forall p. UnXRec p => AnnProvenance p -> Maybe (IdP p)

-- | Role Annotation Declaration
data RoleAnnotDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnRole</a></li>
--   </ul>
RoleAnnotDecl :: XCRoleAnnotDecl pass -> LIdP pass -> [XRec pass (Maybe Role)] -> RoleAnnotDecl pass
XRoleAnnotDecl :: !XXRoleAnnotDecl pass -> RoleAnnotDecl pass

-- | Located Role Annotation Declaration
type LRoleAnnotDecl pass = XRec pass (RoleAnnotDecl pass)
roleAnnotDeclName :: RoleAnnotDecl (GhcPass p) -> IdP (GhcPass p)

-- | type Family Result Signature
data FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> :</li>
--   </ul>
NoSig :: XNoSig pass -> FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenP</a>,<a>AnnDcolon</a>,
--   <a>AnnCloseP</a></li>
--   </ul>
KindSig :: XCKindSig pass -> LHsKind pass -> FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenP</a>,<a>AnnDcolon</a>,
--   <a>AnnCloseP</a>, <a>AnnEqual</a></li>
--   </ul>
TyVarSig :: XTyVarSig pass -> LHsTyVarBndr () pass -> FamilyResultSig pass
XFamilyResultSig :: !XXFamilyResultSig pass -> FamilyResultSig pass

-- | Located type Family Result Signature
type LFamilyResultSig pass = XRec pass (FamilyResultSig pass)

-- | If the user supplied an injectivity annotation it is represented using
--   InjectivityAnn. At the moment this is a single injectivity condition -
--   see Note [Injectivity annotation]. `Located name` stores the LHS of
--   injectivity condition. `[Located name]` stores the RHS of injectivity
--   condition. Example:
--   
--   type family Foo a b c = r | r -&gt; a c where ...
--   
--   This will be represented as "InjectivityAnn <tt>r</tt> [<tt>a</tt>,
--   <tt>c</tt>]"
data InjectivityAnn pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a>, <a>AnnVbar</a></li>
--   </ul>
InjectivityAnn :: XCInjectivityAnn pass -> LIdP pass -> [LIdP pass] -> InjectivityAnn pass
XInjectivityAnn :: !XXInjectivityAnn pass -> InjectivityAnn pass

-- | Located Injectivity Annotation
type LInjectivityAnn pass = XRec pass (InjectivityAnn pass)

-- | Maybe return name of the result type variable
resultVariableName :: FamilyResultSig (GhcPass a) -> Maybe (IdP (GhcPass a))
familyDeclLName :: FamilyDecl (GhcPass p) -> XRec (GhcPass p) (IdP (GhcPass p))
familyDeclName :: FamilyDecl (GhcPass p) -> IdP (GhcPass p)

-- | Haskell Group
--   
--   A <a>HsDecl</a> is categorised into a <a>HsGroup</a> before being fed
--   to the renamer.
data HsGroup p
HsGroup :: XCHsGroup p -> HsValBinds p -> [LSpliceDecl p] -> [TyClGroup p] -> [LDerivDecl p] -> [LFixitySig p] -> [LDefaultDecl p] -> [LForeignDecl p] -> [LWarnDecls p] -> [LAnnDecl p] -> [LRuleDecls p] -> [LDocDecl p] -> HsGroup p
[hs_ext] :: HsGroup p -> XCHsGroup p
[hs_valds] :: HsGroup p -> HsValBinds p
[hs_splcds] :: HsGroup p -> [LSpliceDecl p]
[hs_tyclds] :: HsGroup p -> [TyClGroup p]
[hs_derivds] :: HsGroup p -> [LDerivDecl p]
[hs_fixds] :: HsGroup p -> [LFixitySig p]
[hs_defds] :: HsGroup p -> [LDefaultDecl p]
[hs_fords] :: HsGroup p -> [LForeignDecl p]
[hs_warnds] :: HsGroup p -> [LWarnDecls p]
[hs_annds] :: HsGroup p -> [LAnnDecl p]
[hs_ruleds] :: HsGroup p -> [LRuleDecls p]
[hs_docs] :: HsGroup p -> [LDocDecl p]
XHsGroup :: !XXHsGroup p -> HsGroup p
emptyRdrGroup :: HsGroup (GhcPass p)
emptyRnGroup :: HsGroup (GhcPass p)
appendGroups :: HsGroup (GhcPass p) -> HsGroup (GhcPass p) -> HsGroup (GhcPass p)
hsGroupInstDecls :: HsGroup id -> [LInstDecl id]

-- | The fixity signatures for each top-level declaration and class method
--   in an <a>HsGroup</a>. See Note [Top-level fixity signatures in an
--   HsGroup]
hsGroupTopLevelFixitySigs :: HsGroup (GhcPass p) -> [LFixitySig (GhcPass p)]

-- | Partition a list of HsDecls into function/pattern bindings,
--   signatures, type family declarations, type family instances, and
--   documentation comments.
--   
--   Panics when given a declaration that cannot be put into any of the
--   output groups.
--   
--   The primary use of this function is to implement
--   <a>cvBindsAndSigs</a>.
partitionBindsAndSigs :: [LHsDecl GhcPs] -> (LHsBinds GhcPs, [LSig GhcPs], [LFamilyDecl GhcPs], [LTyFamInstDecl GhcPs], [LDataFamInstDecl GhcPs], [LDocDecl GhcPs])
instance GHC.Classes.Eq GHC.Hs.Decls.HsRuleAnn
instance Data.Data.Data GHC.Hs.Decls.HsRuleAnn
instance GHC.Utils.Outputable.Outputable GHC.Hs.Decls.XViaStrategyPs
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.HsDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.HsGroup (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.SpliceDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.TyClDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.TyClGroup (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.FunDep (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.FamilyDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.HsDerivingClause (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DerivClauseTys (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.HsDataDefn (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.StandaloneKindSig (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.ConDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.TyFamInstDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DataFamInstDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.ClsInstDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.InstDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DerivDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DerivStrategy (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DefaultDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.ForeignDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.RuleDecls (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.RuleDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.RuleBndr (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.WarnDecls (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.WarnDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.AnnDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.Extension.IdP (GHC.Hs.Extension.GhcPass p)) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.RoleAnnotDecl (GHC.Hs.Extension.GhcPass p))


-- | This module defines types and simple operations over constraints, as
--   used in the type-checker and constraint solver.
module GHC.Tc.Types.Constraint
data QCInst
QCI :: CtEvidence -> [TcTyVar] -> TcPredType -> Bool -> QCInst
[qci_ev] :: QCInst -> CtEvidence
[qci_tvs] :: QCInst -> [TcTyVar]
[qci_pred] :: QCInst -> TcPredType
[qci_pend_sc] :: QCInst -> Bool
isPendingScInst :: QCInst -> Maybe QCInst

-- | A <a>Xi</a>-type is one that has been fully rewritten with respect to
--   the inert set; that is, it has been rewritten by the algorithm in
--   GHC.Tc.Solver.Rewrite. (Historical note: <a>Xi</a>, for years and
--   years, meant that a type was type-family-free. It does *not* mean this
--   any more.)
type Xi = TcType
data Ct
CDictCan :: CtEvidence -> Class -> [Xi] -> Bool -> Ct
[cc_ev] :: Ct -> CtEvidence
[cc_class] :: Ct -> Class
[cc_tyargs] :: Ct -> [Xi]
[cc_pend_sc] :: Ct -> Bool
CIrredCan :: CtEvidence -> CtIrredReason -> Ct
[cc_ev] :: Ct -> CtEvidence
[cc_reason] :: Ct -> CtIrredReason
CEqCan :: CtEvidence -> CanEqLHS -> Xi -> EqRel -> Ct
[cc_ev] :: Ct -> CtEvidence
[cc_lhs] :: Ct -> CanEqLHS
[cc_rhs] :: Ct -> Xi
[cc_eq_rel] :: Ct -> EqRel
CNonCanonical :: CtEvidence -> Ct
[cc_ev] :: Ct -> CtEvidence
CQuantCan :: QCInst -> Ct
type Cts = Bag Ct
emptyCts :: Cts
andCts :: Cts -> Cts -> Cts
andManyCts :: [Cts] -> Cts
pprCts :: Cts -> SDoc
singleCt :: Ct -> Cts
listToCts :: [Ct] -> Cts
ctsElts :: Cts -> [Ct]
consCts :: Ct -> Cts -> Cts
snocCts :: Cts -> Ct -> Cts
extendCtsList :: Cts -> [Ct] -> Cts
isEmptyCts :: Cts -> Bool
isPendingScDict :: Ct -> Maybe Ct

-- | True if taking superclasses of givens, or of wanteds (to perhaps
--   expose more equalities or functional dependencies) might help to solve
--   this constraint. See Note [When superclasses help]
superClassesMightHelp :: WantedConstraints -> Bool
getPendingWantedScs :: Cts -> ([Ct], Cts)
isWantedCt :: Ct -> Bool
isDerivedCt :: Ct -> Bool
isGivenCt :: Ct -> Bool
isUserTypeErrorCt :: Ct -> Bool

-- | A constraint is considered to be a custom type error, if it contains
--   custom type errors anywhere in it. See Note [Custom type errors in
--   constraints]
getUserTypeErrorMsg :: Ct -> Maybe Type
ctEvidence :: Ct -> CtEvidence
ctLoc :: Ct -> CtLoc
setCtLoc :: Ct -> CtLoc -> Ct
ctPred :: Ct -> PredType

-- | Get the flavour of the given <a>Ct</a>
ctFlavour :: Ct -> CtFlavour

-- | Get the equality relation for the given <a>Ct</a>
ctEqRel :: Ct -> EqRel
ctOrigin :: Ct -> CtOrigin
ctEvId :: Ct -> EvVar

-- | Makes a new equality predicate with the same role as the given
--   evidence.
mkTcEqPredLikeEv :: CtEvidence -> TcType -> TcType -> TcType
mkNonCanonical :: CtEvidence -> Ct
mkNonCanonicalCt :: Ct -> Ct
mkGivens :: CtLoc -> [EvId] -> [Ct]
mkIrredCt :: CtIrredReason -> CtEvidence -> Ct
ctEvPred :: CtEvidence -> TcPredType
ctEvLoc :: CtEvidence -> CtLoc
ctEvOrigin :: CtEvidence -> CtOrigin

-- | Get the equality relation relevant for a <a>CtEvidence</a>
ctEvEqRel :: CtEvidence -> EqRel
ctEvExpr :: CtEvidence -> EvExpr
ctEvTerm :: CtEvidence -> EvTerm
ctEvCoercion :: HasDebugCallStack => CtEvidence -> TcCoercion
ctEvEvId :: CtEvidence -> EvVar

-- | Returns free variables of constraints as a non-deterministic set
tyCoVarsOfCt :: Ct -> TcTyCoVarSet

-- | Returns free variables of a bag of constraints as a non-deterministic
--   set. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfCts :: Cts -> TcTyCoVarSet

-- | Returns free variables of constraints as a deterministically ordered.
--   list. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfCtList :: Ct -> [TcTyCoVar]

-- | Returns free variables of a bag of constraints as a deterministically
--   ordered list. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfCtsList :: Cts -> [TcTyCoVar]

-- | Used to indicate extra information about why a CIrredCan is
--   irreducible
data CtIrredReason

-- | this constraint has a non-canonical shape (e.g. <tt>c Int</tt>, for a
--   variable <tt>c</tt>)
IrredShapeReason :: CtIrredReason

-- | this constraint is blocked on the coercion hole(s) listed See Note
--   [Equalities with incompatible kinds] in GHC.Tc.Solver.Canonical
--   Wrinkle (4a). Why store the HoleSet? See Wrinkle (2) of that same
--   Note. INVARIANT: A HoleBlockerReason constraint is a homogeneous
--   equality whose left hand side can fit in a CanEqLHS.
HoleBlockerReason :: HoleSet -> CtIrredReason

-- | an equality where some invariant other than (TyEq:H) of <a>CEqCan</a>
--   is not satisfied; the <a>CheckTyEqResult</a> states exactly why
--   INVARIANT: the <a>CheckTyEqResult</a> has some bit set other than
--   cteHoleBlocker
NonCanonicalReason :: CheckTyEqResult -> CtIrredReason

-- | an equality that cannot be decomposed because it is representational.
--   Example: <tt>a b ~R# Int</tt>. These might still be solved later.
--   INVARIANT: The constraint is a representational equality constraint
ReprEqReason :: CtIrredReason

-- | a nominal equality that relates two wholly different types, like
--   <tt>Int ~# Bool</tt> or <tt>a b ~# 3</tt>. INVARIANT: The constraint
--   is a nominal equality constraint
ShapeMismatchReason :: CtIrredReason

-- | an equality like <tt>T a b c ~ Q d e</tt> where either <tt>T</tt> or
--   <tt>Q</tt> is an abstract type constructor. See Note [Skolem abstract
--   data] in GHC.Core.TyCon. INVARIANT: The constraint is an equality
--   constraint between two TyConApps
AbstractTyConReason :: CtIrredReason

-- | A set of <a>CoercionHole</a>s
type HoleSet = UniqSet CoercionHole

-- | Are we sure that more solving will never solve this constraint?
isInsolubleReason :: CtIrredReason -> Bool

-- | A set of problems in checking the validity of a type equality. See
--   <tt>checkTypeEq</tt>.
data CheckTyEqResult

-- | An individual problem that might be logged in a <a>CheckTyEqResult</a>
data CheckTyEqProblem
cteProblem :: CheckTyEqProblem -> CheckTyEqResult
cterClearOccursCheck :: CheckTyEqResult -> CheckTyEqResult

-- | No problems in checking the validity of a type equality.
cteOK :: CheckTyEqResult
cteImpredicative :: CheckTyEqProblem
cteTypeFamily :: CheckTyEqProblem
cteHoleBlocker :: CheckTyEqProblem
cteInsolubleOccurs :: CheckTyEqProblem
cteSolubleOccurs :: CheckTyEqProblem

-- | Mark a <a>CheckTyEqResult</a> as not having an insoluble occurs-check:
--   any occurs check under a type family or in a representation equality
--   is soluble.
cterSetOccursCheckSoluble :: CheckTyEqResult -> CheckTyEqResult

-- | Check whether a <a>CheckTyEqResult</a> is marked successful.
cterHasNoProblem :: CheckTyEqResult -> Bool

-- | Check whether a <a>CheckTyEqResult</a> has a <a>CheckTyEqProblem</a>
cterHasProblem :: CheckTyEqResult -> CheckTyEqProblem -> Bool

-- | Check whether a <a>CheckTyEqResult</a> has one <a>CheckTyEqProblem</a>
--   and no other
cterHasOnlyProblem :: CheckTyEqResult -> CheckTyEqProblem -> Bool
cterRemoveProblem :: CheckTyEqResult -> CheckTyEqProblem -> CheckTyEqResult
cterHasOccursCheck :: CheckTyEqResult -> Bool

-- | Retain only information about occurs-check failures, because only that
--   matters after recurring into a kind.
cterFromKind :: CheckTyEqResult -> CheckTyEqResult

-- | A <a>CanEqLHS</a> is a type that can appear on the left of a canonical
--   equality: a type variable or exactly-saturated type family
--   application.
data CanEqLHS
TyVarLHS :: TcTyVar -> CanEqLHS
TyFamLHS :: TyCon -> [Xi] -> CanEqLHS

-- | Is a type a canonical LHS? That is, is it a tyvar or an
--   exactly-saturated type family application? Does not look through type
--   synonyms.
canEqLHS_maybe :: Xi -> Maybe CanEqLHS

-- | Retrieve the kind of a <a>CanEqLHS</a>
canEqLHSKind :: CanEqLHS -> TcKind

-- | Convert a <a>CanEqLHS</a> back into a <a>Expr</a>
canEqLHSType :: CanEqLHS -> TcType

-- | Are two <a>CanEqLHS</a>s equal?
eqCanEqLHS :: CanEqLHS -> CanEqLHS -> Bool

-- | A hole stores the information needed to report diagnostics about holes
--   in terms (unbound identifiers or underscores) or in types (also called
--   wildcards, as used in partial type signatures). See Note [Holes].
data Hole
Hole :: HoleSort -> OccName -> TcType -> CtLoc -> Hole

-- | What flavour of hole is this?
[hole_sort] :: Hole -> HoleSort

-- | The name of this hole
[hole_occ] :: Hole -> OccName

-- | Type to be printed to the user For expression holes: type of expr For
--   type holes: the missing type
[hole_ty] :: Hole -> TcType

-- | Where hole was written
[hole_loc] :: Hole -> CtLoc

-- | Used to indicate which sort of hole we have.
data HoleSort

-- | Either an out-of-scope variable or a "true" hole in an expression
--   (TypedHoles). The HoleExprRef says where to write the the erroring
--   expression for -fdefer-type-errors.
ExprHole :: HoleExprRef -> HoleSort

-- | A hole in a type (PartialTypeSignatures)
TypeHole :: HoleSort

-- | A hole in a constraint, like @f :: (_, Eq a) =&gt; ... Differentiated
--   from TypeHole because a ConstraintHole is simplified differently. See
--   Note [Do not simplify ConstraintHoles] in GHC.Tc.Solver.
ConstraintHole :: HoleSort

-- | Does this hole represent an "out of scope" error? See Note [Insoluble
--   holes]
isOutOfScopeHole :: Hole -> Bool
data WantedConstraints
WC :: Cts -> Bag Implication -> Bag Hole -> WantedConstraints
[wc_simple] :: WantedConstraints -> Cts
[wc_impl] :: WantedConstraints -> Bag Implication
[wc_holes] :: WantedConstraints -> Bag Hole
insolubleWC :: WantedConstraints -> Bool
emptyWC :: WantedConstraints
isEmptyWC :: WantedConstraints -> Bool

-- | Checks whether a the given wanted constraints are solved, i.e. that
--   there are no simple constraints left and all the implications are
--   solved.
isSolvedWC :: WantedConstraints -> Bool
andWC :: WantedConstraints -> WantedConstraints -> WantedConstraints
unionsWC :: [WantedConstraints] -> WantedConstraints
mkSimpleWC :: [CtEvidence] -> WantedConstraints
mkImplicWC :: Bag Implication -> WantedConstraints
addInsols :: WantedConstraints -> Bag Ct -> WantedConstraints
dropMisleading :: WantedConstraints -> WantedConstraints
addSimples :: WantedConstraints -> Bag Ct -> WantedConstraints
addImplics :: WantedConstraints -> Bag Implication -> WantedConstraints
addHoles :: WantedConstraints -> Bag Hole -> WantedConstraints

-- | Returns free variables of WantedConstraints as a non-deterministic
--   set. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfWC :: WantedConstraints -> TyCoVarSet
dropDerivedWC :: WantedConstraints -> WantedConstraints
dropDerivedSimples :: Cts -> Cts

-- | Returns free variables of WantedConstraints as a deterministically
--   ordered list. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfWCList :: WantedConstraints -> [TyCoVar]
insolubleCt :: Ct -> Bool
insolubleEqCt :: Ct -> Bool
isDroppableCt :: Ct -> Bool
insolubleImplic :: Implication -> Bool
arisesFromGivens :: Ct -> Bool
data Implication
Implic :: TcLevel -> [TcTyVar] -> SkolemInfo -> [EvVar] -> HasGivenEqs -> Bool -> TcLclEnv -> WantedConstraints -> EvBindsVar -> VarSet -> VarSet -> ImplicStatus -> Implication
[ic_tclvl] :: Implication -> TcLevel
[ic_skols] :: Implication -> [TcTyVar]
[ic_info] :: Implication -> SkolemInfo
[ic_given] :: Implication -> [EvVar]
[ic_given_eqs] :: Implication -> HasGivenEqs
[ic_warn_inaccessible] :: Implication -> Bool
[ic_env] :: Implication -> TcLclEnv
[ic_wanted] :: Implication -> WantedConstraints
[ic_binds] :: Implication -> EvBindsVar
[ic_need_inner] :: Implication -> VarSet
[ic_need_outer] :: Implication -> VarSet
[ic_status] :: Implication -> ImplicStatus
implicationPrototype :: Implication
checkTelescopeSkol :: SkolemInfo -> Bool
data ImplicStatus
IC_Solved :: [EvVar] -> ImplicStatus
[ics_dead] :: ImplicStatus -> [EvVar]
IC_Insoluble :: ImplicStatus
IC_BadTelescope :: ImplicStatus
IC_Unsolved :: ImplicStatus
isInsolubleStatus :: ImplicStatus -> Bool
isSolvedStatus :: ImplicStatus -> Bool
data HasGivenEqs
NoGivenEqs :: HasGivenEqs
LocalGivenEqs :: HasGivenEqs
MaybeGivenEqs :: HasGivenEqs

-- | See Note [SubGoalDepth]
data SubGoalDepth
initialSubGoalDepth :: SubGoalDepth
maxSubGoalDepth :: SubGoalDepth -> SubGoalDepth -> SubGoalDepth
bumpSubGoalDepth :: SubGoalDepth -> SubGoalDepth
subGoalDepthExceeded :: DynFlags -> SubGoalDepth -> Bool
data CtLoc
CtLoc :: CtOrigin -> TcLclEnv -> Maybe TypeOrKind -> !SubGoalDepth -> CtLoc
[ctl_origin] :: CtLoc -> CtOrigin
[ctl_env] :: CtLoc -> TcLclEnv
[ctl_t_or_k] :: CtLoc -> Maybe TypeOrKind
[ctl_depth] :: CtLoc -> !SubGoalDepth
ctLocSpan :: CtLoc -> RealSrcSpan
ctLocEnv :: CtLoc -> TcLclEnv
ctLocLevel :: CtLoc -> TcLevel
ctLocOrigin :: CtLoc -> CtOrigin
ctLocTypeOrKind_maybe :: CtLoc -> Maybe TypeOrKind
ctLocDepth :: CtLoc -> SubGoalDepth
bumpCtLocDepth :: CtLoc -> CtLoc
isGivenLoc :: CtLoc -> Bool
setCtLocOrigin :: CtLoc -> CtOrigin -> CtLoc
updateCtLocOrigin :: CtLoc -> (CtOrigin -> CtOrigin) -> CtLoc
setCtLocEnv :: CtLoc -> TcLclEnv -> CtLoc
setCtLocSpan :: CtLoc -> RealSrcSpan -> CtLoc
pprCtLoc :: CtLoc -> SDoc
data CtEvidence
CtGiven :: TcPredType -> EvVar -> CtLoc -> CtEvidence
[ctev_pred] :: CtEvidence -> TcPredType
[ctev_evar] :: CtEvidence -> EvVar
[ctev_loc] :: CtEvidence -> CtLoc
CtWanted :: TcPredType -> TcEvDest -> ShadowInfo -> CtLoc -> CtEvidence
[ctev_pred] :: CtEvidence -> TcPredType
[ctev_dest] :: CtEvidence -> TcEvDest
[ctev_nosh] :: CtEvidence -> ShadowInfo
[ctev_loc] :: CtEvidence -> CtLoc
CtDerived :: TcPredType -> CtLoc -> CtEvidence
[ctev_pred] :: CtEvidence -> TcPredType
[ctev_loc] :: CtEvidence -> CtLoc

-- | A place for type-checking evidence to go after it is generated. Wanted
--   equalities are always HoleDest; other wanteds are always EvVarDest.
data TcEvDest

-- | bind this var to the evidence EvVarDest is always used for
--   non-type-equalities e.g. class constraints
EvVarDest :: EvVar -> TcEvDest

-- | fill in this hole with the evidence HoleDest is always used for
--   type-equalities See Note [Coercion holes] in GHC.Core.TyCo.Rep
HoleDest :: CoercionHole -> TcEvDest
mkKindLoc :: TcType -> TcType -> CtLoc -> CtLoc

-- | Take a CtLoc and moves it to the kind level
toKindLoc :: CtLoc -> CtLoc
mkGivenLoc :: TcLevel -> SkolemInfo -> TcLclEnv -> CtLoc
isWanted :: CtEvidence -> Bool
isGiven :: CtEvidence -> Bool
isDerived :: CtEvidence -> Bool

-- | Get the role relevant for a <a>CtEvidence</a>
ctEvRole :: CtEvidence -> Role
wrapType :: Type -> [TyVar] -> [PredType] -> Type
data CtFlavour
Given :: CtFlavour
Wanted :: ShadowInfo -> CtFlavour
Derived :: CtFlavour
data ShadowInfo
WDeriv :: ShadowInfo
WOnly :: ShadowInfo

-- | Does this <a>CtFlavour</a> subsumed <a>Derived</a>? True of
--   <tt>[WD]</tt> and <tt>[D]</tt>.
ctFlavourContainsDerived :: CtFlavour -> Bool
ctEvFlavour :: CtEvidence -> CtFlavour

-- | Whether or not one <a>Ct</a> can rewrite another is determined by its
--   flavour and its equality relation. See also Note [Flavours with roles]
--   in <a>GHC.Tc.Solver.Monad</a>
type CtFlavourRole = (CtFlavour, EqRel)

-- | Extract the flavour, role, and boxity from a <a>CtEvidence</a>
ctEvFlavourRole :: CtEvidence -> CtFlavourRole

-- | Extract the flavour and role from a <a>Ct</a>
ctFlavourRole :: Ct -> CtFlavourRole
eqCanRewrite :: EqRel -> EqRel -> Bool
eqCanRewriteFR :: CtFlavourRole -> CtFlavourRole -> Bool
eqMayRewriteFR :: CtFlavourRole -> CtFlavourRole -> Bool
eqCanDischargeFR :: CtFlavourRole -> CtFlavourRole -> Bool
pprEvVarTheta :: [EvVar] -> SDoc
pprEvVars :: [EvVar] -> SDoc
pprEvVarWithType :: EvVar -> SDoc
instance GHC.Classes.Eq GHC.Tc.Types.Constraint.HasGivenEqs
instance GHC.Classes.Eq GHC.Tc.Types.Constraint.ShadowInfo
instance GHC.Classes.Eq GHC.Tc.Types.Constraint.CtFlavour
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.SubGoalDepth
instance GHC.Classes.Ord GHC.Tc.Types.Constraint.SubGoalDepth
instance GHC.Classes.Eq GHC.Tc.Types.Constraint.SubGoalDepth
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.WantedConstraints
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.Implication
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.Hole
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.Ct
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.QCInst
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CtEvidence
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CtFlavour
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.TcEvDest
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.HasGivenEqs
instance GHC.Base.Semigroup GHC.Tc.Types.Constraint.HasGivenEqs
instance GHC.Base.Monoid GHC.Tc.Types.Constraint.HasGivenEqs
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.ImplicStatus
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CtIrredReason
instance GHC.Base.Semigroup GHC.Tc.Types.Constraint.CheckTyEqResult
instance GHC.Base.Monoid GHC.Tc.Types.Constraint.CheckTyEqResult
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CheckTyEqResult
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.HoleSort
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CanEqLHS

module GHC.Tc.Errors.Hole.FitTypes
data TypedHole
TypedHole :: Cts -> [Implication] -> Maybe Hole -> TypedHole

-- | Any relevant Cts to the hole
[th_relevant_cts] :: TypedHole -> Cts

-- | The nested implications of the hole with the innermost implication
--   first.
[th_implics] :: TypedHole -> [Implication]

-- | The hole itself, if available. Only for debugging.
[th_hole] :: TypedHole -> Maybe Hole

-- | HoleFit is the type we use for valid hole fits. It contains the
--   element that was checked, the Id of that element as found by
--   <tt>tcLookup</tt>, and the refinement level of the fit, which is the
--   number of extra argument holes that this fit uses (e.g. if hfRefLvl is
--   2, the fit is for `Id _ _`).
data HoleFit
HoleFit :: Id -> HoleFitCandidate -> TcType -> Int -> [TcType] -> [TcType] -> Maybe HsDocString -> HoleFit

-- | The elements id in the TcM
[hfId] :: HoleFit -> Id

-- | The candidate that was checked.
[hfCand] :: HoleFit -> HoleFitCandidate

-- | The type of the id, possibly zonked.
[hfType] :: HoleFit -> TcType

-- | The number of holes in this fit.
[hfRefLvl] :: HoleFit -> Int

-- | The wrapper for the match.
[hfWrap] :: HoleFit -> [TcType]

-- | What the refinement variables got matched with, if anything
[hfMatches] :: HoleFit -> [TcType]

-- | Documentation of this HoleFit, if available.
[hfDoc] :: HoleFit -> Maybe HsDocString

-- | A fit that is just displayed as is. Here so thatHoleFitPlugins can
--   inject any fit they want.
RawHoleFit :: SDoc -> HoleFit

-- | HoleFitCandidates are passed to hole fit plugins and then checked
--   whether they fit a given typed-hole.
data HoleFitCandidate
IdHFCand :: Id -> HoleFitCandidate
NameHFCand :: Name -> HoleFitCandidate
GreHFCand :: GlobalRdrElt -> HoleFitCandidate

-- | A plugin for modifying the candidate hole fits *before* they're
--   checked.
type CandPlugin = TypedHole -> [HoleFitCandidate] -> TcM [HoleFitCandidate]

-- | A plugin for modifying hole fits *after* they've been found.
type FitPlugin = TypedHole -> [HoleFit] -> TcM [HoleFit]

-- | A HoleFitPlugin is a pair of candidate and fit plugins.
data HoleFitPlugin
HoleFitPlugin :: CandPlugin -> FitPlugin -> HoleFitPlugin
[candPlugin] :: HoleFitPlugin -> CandPlugin
[fitPlugin] :: HoleFitPlugin -> FitPlugin

-- | HoleFitPluginR adds a TcRef to hole fit plugins so that plugins can
--   track internal state. Note the existential quantification, ensuring
--   that the state cannot be modified from outside the plugin.
data HoleFitPluginR
HoleFitPluginR :: TcM (TcRef s) -> (TcRef s -> HoleFitPlugin) -> (TcRef s -> TcM ()) -> HoleFitPluginR

-- | Initializes the TcRef to be passed to the plugin
[hfPluginInit] :: HoleFitPluginR -> TcM (TcRef s)

-- | The function defining the plugin itself
[hfPluginRun] :: HoleFitPluginR -> TcRef s -> HoleFitPlugin

-- | Cleanup of state, guaranteed to be called even on error
[hfPluginStop] :: HoleFitPluginR -> TcRef s -> TcM ()
hfIsLcl :: HoleFit -> Bool
pprHoleFitCand :: HoleFitCandidate -> SDoc
instance GHC.Classes.Eq GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Classes.Eq GHC.Tc.Errors.Hole.FitTypes.HoleFit
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Hole.FitTypes.HoleFit
instance GHC.Classes.Ord GHC.Tc.Errors.Hole.FitTypes.HoleFit
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Types.Name.NamedThing GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Types.Name.Occurrence.HasOccName GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Classes.Ord GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Hole.FitTypes.TypedHole

module GHC.Driver.Hooks
data Hooks
class HasHooks m
getHooks :: HasHooks m => m Hooks
class ContainsHooks a
extractHooks :: ContainsHooks a => a -> Hooks

-- | Hooks can be used by GHC API clients to replace parts of the compiler
--   pipeline. If a hook is not installed, GHC uses the default built-in
--   behaviour
emptyHooks :: Hooks
type family DsForeignsHook :: Type

-- | Actual type: <tt>Maybe ([LForeignDecl GhcTc] -&gt; DsM (ForeignStubs,
--   OrdList (Id, CoreExpr)))</tt>
dsForeignsHook :: Hooks -> Maybe DsForeignsHook
tcForeignImportsHook :: Hooks -> Maybe ([LForeignDecl GhcRn] -> TcM ([Id], [LForeignDecl GhcTc], Bag GlobalRdrElt))
tcForeignExportsHook :: Hooks -> Maybe ([LForeignDecl GhcRn] -> TcM (LHsBinds GhcTc, [LForeignDecl GhcTc], Bag GlobalRdrElt))
hscFrontendHook :: Hooks -> Maybe (ModSummary -> Hsc FrontendResult)
hscCompileCoreExprHook :: Hooks -> Maybe (HscEnv -> SrcSpan -> CoreExpr -> IO ForeignHValue)
ghcPrimIfaceHook :: Hooks -> Maybe ModIface
runPhaseHook :: Hooks -> Maybe (PhasePlus -> FilePath -> CompPipeline (PhasePlus, FilePath))
runMetaHook :: Hooks -> Maybe (MetaHook TcM)
linkHook :: Hooks -> Maybe (GhcLink -> DynFlags -> Bool -> HomePackageTable -> IO SuccessFlag)
runRnSpliceHook :: Hooks -> Maybe (HsSplice GhcRn -> RnM (HsSplice GhcRn))
getValueSafelyHook :: Hooks -> Maybe (HscEnv -> Name -> Type -> IO (Maybe HValue))
createIservProcessHook :: Hooks -> Maybe (CreateProcess -> IO ProcessHandle)
stgToCmmHook :: Hooks -> Maybe (DynFlags -> Module -> InfoTableProvMap -> [TyCon] -> CollectedCCs -> [CgStgTopBinding] -> HpcInfo -> Stream IO CmmGroup (CStub, ModuleLFInfos))
cmmToRawCmmHook :: Hooks -> forall a. Maybe (DynFlags -> Maybe Module -> Stream IO CmmGroupSRTs a -> IO (Stream IO RawCmmGroup a))


-- | A ModSummary is a node in the compilation manager's dependency graph
--   (ModuleGraph)
module GHC.Unit.Module.ModSummary

-- | Enrichment of <a>ModSummary</a> with backpack dependencies
data ExtendedModSummary
ExtendedModSummary :: {-# UNPACK #-} !ModSummary -> [InstantiatedUnit] -> ExtendedModSummary
[emsModSummary] :: ExtendedModSummary -> {-# UNPACK #-} !ModSummary

-- | Extra backpack deps NB: This is sometimes left empty in situations
--   where the instantiated units would not be used. See call sites of
--   <a>extendModSummaryNoDeps</a>.
[emsInstantiatedUnits] :: ExtendedModSummary -> [InstantiatedUnit]
extendModSummaryNoDeps :: ModSummary -> ExtendedModSummary

-- | Data for a module node in a <tt>ModuleGraph</tt>. Module nodes of the
--   module graph are one of:
--   
--   <ul>
--   <li>A regular Haskell source module</li>
--   <li>A hi-boot source module</li>
--   </ul>
data ModSummary
ModSummary :: Module -> HscSource -> ModLocation -> UTCTime -> Maybe UTCTime -> Maybe UTCTime -> Maybe UTCTime -> [(Maybe FastString, Located ModuleName)] -> [(Maybe FastString, Located ModuleName)] -> Maybe HsParsedModule -> FilePath -> DynFlags -> Maybe StringBuffer -> ModSummary

-- | Identity of the module
[ms_mod] :: ModSummary -> Module

-- | The module source either plain Haskell, hs-boot, or hsig
[ms_hsc_src] :: ModSummary -> HscSource

-- | Location of the various files belonging to the module
[ms_location] :: ModSummary -> ModLocation

-- | Timestamp of source file
[ms_hs_date] :: ModSummary -> UTCTime

-- | Timestamp of object, if we have one
[ms_obj_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of hi file, if we *only* are typechecking (it is
--   <a>Nothing</a> otherwise. See Note [Recompilation checking in
--   -fno-code mode] and #9243
[ms_iface_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of hie file, if we have one
[ms_hie_date] :: ModSummary -> Maybe UTCTime

-- | Source imports of the module
[ms_srcimps] :: ModSummary -> [(Maybe FastString, Located ModuleName)]

-- | Non-source imports of the module from the module *text*
[ms_textual_imps] :: ModSummary -> [(Maybe FastString, Located ModuleName)]

-- | The parsed, nonrenamed source, if we have it. This is also used to
--   support "inline module syntax" in Backpack files.
[ms_parsed_mod] :: ModSummary -> Maybe HsParsedModule

-- | Filename of preprocessed source file
[ms_hspp_file] :: ModSummary -> FilePath

-- | Cached flags from <tt>OPTIONS</tt>, <tt>INCLUDE</tt> and
--   <tt>LANGUAGE</tt> pragmas in the modules source code
[ms_hspp_opts] :: ModSummary -> DynFlags

-- | The actual preprocessed source, if we have it
[ms_hspp_buf] :: ModSummary -> Maybe StringBuffer
ms_installed_mod :: ModSummary -> InstalledModule
ms_mod_name :: ModSummary -> ModuleName
ms_imps :: ModSummary -> [(Maybe FastString, Located ModuleName)]
ms_home_allimps :: ModSummary -> [ModuleName]

-- | Like <a>ms_home_imps</a>, but for SOURCE imports.
ms_home_srcimps :: ModSummary -> [Located ModuleName]

-- | All of the (possibly) home module imports from a <a>ModSummary</a>;
--   that is to say, each of these module names could be a home import if
--   an appropriately named file existed. (This is in contrast to package
--   qualified imports, which are guaranteed not to be home imports.)
ms_home_imps :: ModSummary -> [Located ModuleName]
msHiFilePath :: ModSummary -> FilePath
msHsFilePath :: ModSummary -> FilePath
msObjFilePath :: ModSummary -> FilePath
msDynObjFilePath :: ModSummary -> DynFlags -> FilePath

-- | Did this <a>ModSummary</a> originate from a hs-boot file?
isBootSummary :: ModSummary -> IsBootInterface
findTarget :: ModSummary -> [Target] -> Maybe Target
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.ModSummary.ExtendedModSummary
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.ModSummary.ModSummary

module GHC.Types.Target

-- | A compilation target.
--   
--   A target may be supplied with the actual text of the module. If so,
--   use this instead of the file contents (this is for use in an IDE where
--   the file hasn't been saved by the user yet).
data Target
Target :: !TargetId -> !Bool -> !Maybe (InputFileBuffer, UTCTime) -> Target

-- | module or filename
[targetId] :: Target -> !TargetId

-- | object code allowed?
[targetAllowObjCode] :: Target -> !Bool

-- | Optional in-memory buffer containing the source code GHC should use
--   for this target instead of reading it from disk.
--   
--   Since GHC version 8.10 modules which require preprocessors such as
--   Literate Haskell or CPP to run are also supported.
--   
--   If a corresponding source file does not exist on disk this will result
--   in a <tt>SourceError</tt> exception if <tt>targetId = TargetModule
--   _</tt> is used. However together with <tt>targetId = TargetFile _</tt>
--   GHC will not complain about the file missing.
[targetContents] :: Target -> !Maybe (InputFileBuffer, UTCTime)
data TargetId

-- | A module name: search for the file
TargetModule :: !ModuleName -> TargetId

-- | A filename: preprocess &amp; parse it to find the module name. If
--   specified, the Phase indicates how to compile this file (which phase
--   to start from). Nothing indicates the starting phase should be
--   determined from the suffix of the filename.
TargetFile :: !FilePath -> !Maybe Phase -> TargetId
type InputFileBuffer = StringBuffer
pprTarget :: Target -> SDoc
pprTargetId :: TargetId -> SDoc
instance GHC.Classes.Eq GHC.Types.Target.TargetId
instance GHC.Utils.Outputable.Outputable GHC.Types.Target.Target
instance GHC.Utils.Outputable.Outputable GHC.Types.Target.TargetId

module GHC.Unit.Module.ModIface
type ModIface = ModIface_ 'ModIfaceFinal

-- | A <a>ModIface_</a> plus a <tt>ModDetails</tt> summarises everything we
--   know about a compiled module. The <a>ModIface_</a> is the stuff
--   *before* linking, and can be written out to an interface file. The
--   'ModDetails is after linking and can be completely recovered from just
--   the <a>ModIface_</a>.
--   
--   When we read an interface file, we also construct a <a>ModIface_</a>
--   from it, except that we explicitly make the <a>mi_decls</a> and a few
--   other fields empty; as when reading we consolidate the declarations
--   etc. into a number of indexed maps and environments in the
--   <tt>ExternalPackageState</tt>.
data ModIface_ (phase :: ModIfacePhase)
ModIface :: !Module -> !Maybe Module -> !HscSource -> Dependencies -> [Usage] -> ![IfaceExport] -> !Bool -> [(OccName, Fixity)] -> Warnings -> [IfaceAnnotation] -> [IfaceDeclExts phase] -> !Maybe GlobalRdrEnv -> [IfaceClsInst] -> [IfaceFamInst] -> [IfaceRule] -> !AnyHpcUsage -> !IfaceTrustInfo -> !Bool -> [IfaceCompleteMatch] -> Maybe HsDocString -> DeclDocMap -> ArgDocMap -> !IfaceBackendExts phase -> ExtensibleFields -> ModIface_ (phase :: ModIfacePhase)

-- | Name of the module we are for
[mi_module] :: ModIface_ (phase :: ModIfacePhase) -> !Module

-- | Are we a sig of another mod?
[mi_sig_of] :: ModIface_ (phase :: ModIfacePhase) -> !Maybe Module

-- | Boot? Signature?
[mi_hsc_src] :: ModIface_ (phase :: ModIfacePhase) -> !HscSource

-- | The dependencies of the module. This is consulted for
--   directly-imported modules, but not for anything else (hence lazy)
[mi_deps] :: ModIface_ (phase :: ModIfacePhase) -> Dependencies

-- | Usages; kept sorted so that it's easy to decide whether to write a new
--   iface file (changing usages doesn't affect the hash of this module)
--   NOT STRICT! we read this field lazily from the interface file It is
--   *only* consulted by the recompilation checker
[mi_usages] :: ModIface_ (phase :: ModIfacePhase) -> [Usage]

-- | Exports Kept sorted by (mod,occ), to make version comparisons easier
--   Records the modules that are the declaration points for things
--   exported by this module, and the <a>OccName</a>s of those things
[mi_exports] :: ModIface_ (phase :: ModIfacePhase) -> ![IfaceExport]

-- | Module required TH splices when it was compiled. This disables
--   recompilation avoidance (see #481).
[mi_used_th] :: ModIface_ (phase :: ModIfacePhase) -> !Bool

-- | Fixities NOT STRICT! we read this field lazily from the interface file
[mi_fixities] :: ModIface_ (phase :: ModIfacePhase) -> [(OccName, Fixity)]

-- | Warnings NOT STRICT! we read this field lazily from the interface file
[mi_warns] :: ModIface_ (phase :: ModIfacePhase) -> Warnings

-- | Annotations NOT STRICT! we read this field lazily from the interface
--   file
[mi_anns] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceAnnotation]

-- | Type, class and variable declarations The hash of an Id changes if its
--   fixity or deprecations change (as well as its type of course) Ditto
--   data constructors, class operations, except that the hash of the
--   parent class/tycon changes
[mi_decls] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceDeclExts phase]

-- | Binds all the things defined at the top level in the <i>original
--   source</i> code for this module. which is NOT the same as mi_exports,
--   nor mi_decls (which may contains declarations for things not actually
--   defined by the user). Used for GHCi and for inspecting the contents of
--   modules via the GHC API only.
--   
--   (We need the source file to figure out the top-level environment, if
--   we didn't compile this module from source then this field contains
--   <tt>Nothing</tt>).
--   
--   Strictly speaking this field should live in the <tt>HomeModInfo</tt>,
--   but that leads to more plumbing.
[mi_globals] :: ModIface_ (phase :: ModIfacePhase) -> !Maybe GlobalRdrEnv

-- | Sorted class instance
[mi_insts] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceClsInst]

-- | Sorted family instances
[mi_fam_insts] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceFamInst]

-- | Sorted rules
[mi_rules] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceRule]

-- | True if this program uses Hpc at any point in the program.
[mi_hpc] :: ModIface_ (phase :: ModIfacePhase) -> !AnyHpcUsage

-- | Safe Haskell Trust information for this module.
[mi_trust] :: ModIface_ (phase :: ModIfacePhase) -> !IfaceTrustInfo

-- | Do we require the package this module resides in be trusted to trust
--   this module? This is used for the situation where a module is Safe (so
--   doesn't require the package be trusted itself) but imports some
--   trustworthy modules from its own package (which does require its own
--   package be trusted). See Note [Trust Own Package] in GHC.Rename.Names
[mi_trust_pkg] :: ModIface_ (phase :: ModIfacePhase) -> !Bool
[mi_complete_matches] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceCompleteMatch]

-- | Module header.
[mi_doc_hdr] :: ModIface_ (phase :: ModIfacePhase) -> Maybe HsDocString

-- | Docs on declarations.
[mi_decl_docs] :: ModIface_ (phase :: ModIfacePhase) -> DeclDocMap

-- | Docs on arguments.
[mi_arg_docs] :: ModIface_ (phase :: ModIfacePhase) -> ArgDocMap

-- | Either <tt>()</tt> or <a>ModIfaceBackend</a> for a fully instantiated
--   interface.
[mi_final_exts] :: ModIface_ (phase :: ModIfacePhase) -> !IfaceBackendExts phase

-- | Additional optional fields, where the Map key represents the field
--   name, resulting in a (size, serialized data) pair. Because the data is
--   intended to be serialized through the internal <a>Binary</a> class
--   (increasing compatibility with types using <a>Name</a> and
--   <tt>FastString</tt>, such as HIE), this format is chosen over
--   <tt>ByteString</tt>s.
[mi_ext_fields] :: ModIface_ (phase :: ModIfacePhase) -> ExtensibleFields
type PartialModIface = ModIface_ 'ModIfaceCore

-- | Extends a PartialModIface with information which is either: * Computed
--   after codegen * Or computed just before writing the iface to disk.
--   (Hashes) In order to fully instantiate it.
data ModIfaceBackend
ModIfaceBackend :: !Fingerprint -> !Fingerprint -> !Fingerprint -> !Fingerprint -> !Fingerprint -> !Fingerprint -> !WhetherHasOrphans -> !WhetherHasFamInst -> !Fingerprint -> !Fingerprint -> !OccName -> Maybe WarningTxt -> !OccName -> Maybe Fixity -> !OccName -> Maybe (OccName, Fingerprint) -> ModIfaceBackend

-- | Hash of the whole interface
[mi_iface_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of the ABI only
[mi_mod_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of the important flags used when compiling the module, excluding
--   optimisation flags
[mi_flag_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of optimisation flags
[mi_opt_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of hpc flags
[mi_hpc_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of plugins
[mi_plugin_hash] :: ModIfaceBackend -> !Fingerprint

-- | Whether this module has orphans
[mi_orphan] :: ModIfaceBackend -> !WhetherHasOrphans

-- | Whether this module has family instances. See Note [The type family
--   instance consistency story].
[mi_finsts] :: ModIfaceBackend -> !WhetherHasFamInst

-- | Hash of export list
[mi_exp_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash for orphan rules, class and family instances combined
[mi_orphan_hash] :: ModIfaceBackend -> !Fingerprint

-- | Cached lookup for <a>mi_warns</a>
[mi_warn_fn] :: ModIfaceBackend -> !OccName -> Maybe WarningTxt

-- | Cached lookup for <a>mi_fixities</a>
[mi_fix_fn] :: ModIfaceBackend -> !OccName -> Maybe Fixity

-- | Cached lookup for <a>mi_decls</a>. The <tt>Nothing</tt> in
--   <a>mi_hash_fn</a> means that the thing isn't in decls. It's useful to
--   know that when seeing if we are up to date wrt. the old interface. The
--   <a>OccName</a> is the parent of the name, if it has one.
[mi_hash_fn] :: ModIfaceBackend -> !OccName -> Maybe (OccName, Fingerprint)

-- | Selects a IfaceDecl representation. For fully instantiated interfaces
--   we also maintain a fingerprint, which is used for recompilation
--   checks.
type family IfaceDeclExts (phase :: ModIfacePhase)
type family IfaceBackendExts (phase :: ModIfacePhase)

-- | The original names declared of a certain module that are exported
type IfaceExport = AvailInfo

-- | Records whether a module has orphans. An "orphan" is one of:
--   
--   <ul>
--   <li>An instance declaration in a module other than the definition
--   module for one of the type constructors or classes in the instance
--   head</li>
--   <li>A rewrite rule in a module other than the one defining the
--   function in the head of the rule</li>
--   </ul>
type WhetherHasOrphans = Bool

-- | Does this module define family instances?
type WhetherHasFamInst = Bool

-- | Old-style accessor for whether or not the ModIface came from an
--   hs-boot file.
mi_boot :: ModIface -> IsBootInterface

-- | Lookups up a (possibly cached) fixity from a <a>ModIface_</a>. If one
--   cannot be found, <a>defaultFixity</a> is returned instead.
mi_fix :: ModIface -> OccName -> Fixity

-- | The semantic module for this interface; e.g., if it's a interface for
--   a signature, if <a>mi_module</a> is <tt>p[A=<a>A</a>]:A</tt>,
--   <a>mi_semantic_module</a> will be <tt><a>A</a></tt>.
mi_semantic_module :: ModIface_ a -> Module

-- | The "precise" free holes, e.g., the signatures that this
--   <a>ModIface_</a> depends on.
mi_free_holes :: ModIface -> UniqDSet ModuleName

-- | Given a set of free holes, and a unit identifier, rename the free
--   holes according to the instantiation of the unit identifier. For
--   example, if we have A and B free, and our unit identity is
--   <tt>p[A=<a>C</a>,B=impl:B]</tt>, the renamed free holes are just C.
renameFreeHoles :: UniqDSet ModuleName -> [(ModuleName, Module)] -> UniqDSet ModuleName
emptyPartialModIface :: Module -> PartialModIface
emptyFullModIface :: Module -> ModIface

-- | Constructs cache for the <a>mi_hash_fn</a> field of a <a>ModIface_</a>
mkIfaceHashCache :: [(Fingerprint, IfaceDecl)] -> OccName -> Maybe (OccName, Fingerprint)
emptyIfaceHashCache :: OccName -> Maybe (OccName, Fingerprint)
instance GHC.Utils.Binary.Binary GHC.Unit.Module.ModIface.ModIface
instance (Control.DeepSeq.NFData (GHC.Unit.Module.ModIface.IfaceBackendExts phase), Control.DeepSeq.NFData (GHC.Unit.Module.ModIface.IfaceDeclExts phase)) => Control.DeepSeq.NFData (GHC.Unit.Module.ModIface.ModIface_ phase)


-- | Dependencies and Usage of a module
module GHC.Unit.Module.Deps

-- | Dependency information about ALL modules and packages below this one
--   in the import hierarchy.
--   
--   Invariant: the dependencies of a module <tt>M</tt> never includes
--   <tt>M</tt>.
--   
--   Invariant: none of the lists contain duplicates.
data Dependencies
Deps :: [ModuleNameWithIsBoot] -> [(UnitId, Bool)] -> [Module] -> [Module] -> [ModuleName] -> Dependencies

-- | All home-package modules transitively below this one I.e. modules that
--   this one imports, or that are in the dep_mods of those
--   directly-imported modules
[dep_mods] :: Dependencies -> [ModuleNameWithIsBoot]

-- | All packages transitively below this module I.e. packages to which
--   this module's direct imports belong, or that are in the dep_pkgs of
--   those modules The bool indicates if the package is required to be
--   trusted when the module is imported as a safe import (Safe Haskell).
--   See Note [Tracking Trust Transitively] in GHC.Rename.Names
[dep_pkgs] :: Dependencies -> [(UnitId, Bool)]

-- | Transitive closure of orphan modules (whether home or external pkg).
--   
--   (Possible optimization: don't include family instance orphans as they
--   are anyway included in <a>dep_finsts</a>. But then be careful about
--   code which relies on dep_orphs having the complete list!) This does
--   NOT include us, unlike <tt>imp_orphs</tt>.
[dep_orphs] :: Dependencies -> [Module]

-- | Transitive closure of depended upon modules which contain family
--   instances (whether home or external). This is used by
--   <tt>checkFamInstConsistency</tt>. This does NOT include us, unlike
--   <tt>imp_finsts</tt>. See Note [The type family instance consistency
--   story].
[dep_finsts] :: Dependencies -> [Module]

-- | All the plugins used while compiling this module.
[dep_plgins] :: Dependencies -> [ModuleName]

-- | Records modules for which changes may force recompilation of this
--   module See wiki:
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/recompilation-avoidance</a>
--   
--   This differs from Dependencies. A module X may be in the dep_mods of
--   this module (via an import chain) but if we don't use anything from X
--   it won't appear in our Usage
data Usage

-- | Module from another package
UsagePackageModule :: Module -> Fingerprint -> IsSafeImport -> Usage

-- | External package module depended on
[usg_mod] :: Usage -> Module

-- | Cached module fingerprint
[usg_mod_hash] :: Usage -> Fingerprint

-- | Was this module imported as a safe import
[usg_safe] :: Usage -> IsSafeImport

-- | Module from the current package
UsageHomeModule :: ModuleName -> Fingerprint -> [(OccName, Fingerprint)] -> Maybe Fingerprint -> IsSafeImport -> Usage

-- | Name of the module
[usg_mod_name] :: Usage -> ModuleName

-- | Cached module fingerprint
[usg_mod_hash] :: Usage -> Fingerprint

-- | Entities we depend on, sorted by occurrence name and fingerprinted.
--   NB: usages are for parent names only, e.g. type constructors but not
--   the associated data constructors.
[usg_entities] :: Usage -> [(OccName, Fingerprint)]

-- | Fingerprint for the export list of this module, if we directly
--   imported it (and hence we depend on its export list)
[usg_exports] :: Usage -> Maybe Fingerprint

-- | Was this module imported as a safe import
[usg_safe] :: Usage -> IsSafeImport
UsageFile :: FilePath -> Fingerprint -> Usage

-- | External file dependency. From a CPP #include or TH addDependentFile.
--   Should be absolute.
[usg_file_path] :: Usage -> FilePath

-- | <a>Fingerprint</a> of the file contents.
[usg_file_hash] :: Usage -> Fingerprint

-- | A requirement which was merged into this one.
UsageMergedRequirement :: Module -> Fingerprint -> Usage

-- | External package module depended on
[usg_mod] :: Usage -> Module

-- | Cached module fingerprint
[usg_mod_hash] :: Usage -> Fingerprint
noDependencies :: Dependencies
instance GHC.Classes.Eq GHC.Unit.Module.Deps.Dependencies
instance GHC.Classes.Eq GHC.Unit.Module.Deps.Usage
instance GHC.Utils.Binary.Binary GHC.Unit.Module.Deps.Usage
instance GHC.Utils.Binary.Binary GHC.Unit.Module.Deps.Dependencies

module GHC.Iface.Syntax
data IfaceDecl
IfaceId :: IfaceTopBndr -> IfaceType -> IfaceIdDetails -> IfaceIdInfo -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifType] :: IfaceDecl -> IfaceType
[ifIdDetails] :: IfaceDecl -> IfaceIdDetails
[ifIdInfo] :: IfaceDecl -> IfaceIdInfo
IfaceData :: IfaceTopBndr -> [IfaceTyConBinder] -> IfaceType -> Maybe CType -> [Role] -> IfaceContext -> IfaceConDecls -> Bool -> IfaceTyConParent -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifResKind] :: IfaceDecl -> IfaceType
[ifCType] :: IfaceDecl -> Maybe CType
[ifRoles] :: IfaceDecl -> [Role]
[ifCtxt] :: IfaceDecl -> IfaceContext
[ifCons] :: IfaceDecl -> IfaceConDecls
[ifGadtSyntax] :: IfaceDecl -> Bool
[ifParent] :: IfaceDecl -> IfaceTyConParent
IfaceSynonym :: IfaceTopBndr -> [Role] -> [IfaceTyConBinder] -> IfaceKind -> IfaceType -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifRoles] :: IfaceDecl -> [Role]
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifResKind] :: IfaceDecl -> IfaceKind
[ifSynRhs] :: IfaceDecl -> IfaceType
IfaceFamily :: IfaceTopBndr -> Maybe IfLclName -> [IfaceTyConBinder] -> IfaceKind -> IfaceFamTyConFlav -> Injectivity -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifResVar] :: IfaceDecl -> Maybe IfLclName
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifResKind] :: IfaceDecl -> IfaceKind
[ifFamFlav] :: IfaceDecl -> IfaceFamTyConFlav
[ifFamInj] :: IfaceDecl -> Injectivity
IfaceClass :: IfaceTopBndr -> [Role] -> [IfaceTyConBinder] -> [FunDep IfLclName] -> IfaceClassBody -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifRoles] :: IfaceDecl -> [Role]
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifFDs] :: IfaceDecl -> [FunDep IfLclName]
[ifBody] :: IfaceDecl -> IfaceClassBody
IfaceAxiom :: IfaceTopBndr -> IfaceTyCon -> Role -> [IfaceAxBranch] -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifTyCon] :: IfaceDecl -> IfaceTyCon
[ifRole] :: IfaceDecl -> Role
[ifAxBranches] :: IfaceDecl -> [IfaceAxBranch]
IfacePatSyn :: IfaceTopBndr -> Bool -> (IfExtName, Bool) -> Maybe (IfExtName, Bool) -> [IfaceForAllSpecBndr] -> [IfaceForAllSpecBndr] -> IfaceContext -> IfaceContext -> [IfaceType] -> IfaceType -> [FieldLabel] -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifPatIsInfix] :: IfaceDecl -> Bool
[ifPatMatcher] :: IfaceDecl -> (IfExtName, Bool)
[ifPatBuilder] :: IfaceDecl -> Maybe (IfExtName, Bool)
[ifPatUnivBndrs] :: IfaceDecl -> [IfaceForAllSpecBndr]
[ifPatExBndrs] :: IfaceDecl -> [IfaceForAllSpecBndr]
[ifPatProvCtxt] :: IfaceDecl -> IfaceContext
[ifPatReqCtxt] :: IfaceDecl -> IfaceContext
[ifPatArgs] :: IfaceDecl -> [IfaceType]
[ifPatTy] :: IfaceDecl -> IfaceType
[ifFieldLabels] :: IfaceDecl -> [FieldLabel]
data IfaceFamTyConFlav
IfaceDataFamilyTyCon :: IfaceFamTyConFlav
IfaceOpenSynFamilyTyCon :: IfaceFamTyConFlav

-- | Name of associated axiom and branches for pretty printing purposes, or
--   <a>Nothing</a> for an empty closed family without an axiom See Note
--   [Pretty printing via Iface syntax] in <a>GHC.Types.TyThing.Ppr</a>
IfaceClosedSynFamilyTyCon :: Maybe (IfExtName, [IfaceAxBranch]) -> IfaceFamTyConFlav
IfaceAbstractClosedSynFamilyTyCon :: IfaceFamTyConFlav
IfaceBuiltInSynFamTyCon :: IfaceFamTyConFlav
data IfaceClassOp
IfaceClassOp :: IfaceTopBndr -> IfaceType -> Maybe (DefMethSpec IfaceType) -> IfaceClassOp
data IfaceAT
IfaceAT :: IfaceDecl -> Maybe IfaceType -> IfaceAT
data IfaceConDecl
IfCon :: IfaceTopBndr -> Bool -> Bool -> [IfaceBndr] -> [IfaceForAllSpecBndr] -> IfaceEqSpec -> IfaceContext -> [(IfaceMult, IfaceType)] -> [FieldLabel] -> [IfaceBang] -> [IfaceSrcBang] -> IfaceConDecl
[ifConName] :: IfaceConDecl -> IfaceTopBndr
[ifConWrapper] :: IfaceConDecl -> Bool
[ifConInfix] :: IfaceConDecl -> Bool
[ifConExTCvs] :: IfaceConDecl -> [IfaceBndr]
[ifConUserTvBinders] :: IfaceConDecl -> [IfaceForAllSpecBndr]
[ifConEqSpec] :: IfaceConDecl -> IfaceEqSpec
[ifConCtxt] :: IfaceConDecl -> IfaceContext
[ifConArgTys] :: IfaceConDecl -> [(IfaceMult, IfaceType)]
[ifConFields] :: IfaceConDecl -> [FieldLabel]
[ifConStricts] :: IfaceConDecl -> [IfaceBang]
[ifConSrcStricts] :: IfaceConDecl -> [IfaceSrcBang]
data IfaceConDecls
IfAbstractTyCon :: IfaceConDecls
IfDataTyCon :: [IfaceConDecl] -> IfaceConDecls
IfNewTyCon :: IfaceConDecl -> IfaceConDecls
type IfaceEqSpec = [(IfLclName, IfaceType)]
data IfaceExpr
IfaceLcl :: IfLclName -> IfaceExpr
IfaceExt :: IfExtName -> IfaceExpr
IfaceType :: IfaceType -> IfaceExpr
IfaceCo :: IfaceCoercion -> IfaceExpr
IfaceTuple :: TupleSort -> [IfaceExpr] -> IfaceExpr
IfaceLam :: IfaceLamBndr -> IfaceExpr -> IfaceExpr
IfaceApp :: IfaceExpr -> IfaceExpr -> IfaceExpr
IfaceCase :: IfaceExpr -> IfLclName -> [IfaceAlt] -> IfaceExpr
IfaceECase :: IfaceExpr -> IfaceType -> IfaceExpr
IfaceLet :: IfaceBinding -> IfaceExpr -> IfaceExpr
IfaceCast :: IfaceExpr -> IfaceCoercion -> IfaceExpr
IfaceLit :: Literal -> IfaceExpr
IfaceFCall :: ForeignCall -> IfaceType -> IfaceExpr
IfaceTick :: IfaceTickish -> IfaceExpr -> IfaceExpr
data IfaceAlt
IfaceAlt :: IfaceConAlt -> [IfLclName] -> IfaceExpr -> IfaceAlt
data IfaceLetBndr
IfLetBndr :: IfLclName -> IfaceType -> IfaceIdInfo -> IfaceJoinInfo -> IfaceLetBndr
data IfaceJoinInfo
IfaceNotJoinPoint :: IfaceJoinInfo
IfaceJoinPoint :: JoinArity -> IfaceJoinInfo
data IfaceBinding
IfaceNonRec :: IfaceLetBndr -> IfaceExpr -> IfaceBinding
IfaceRec :: [(IfaceLetBndr, IfaceExpr)] -> IfaceBinding
data IfaceConAlt
IfaceDefault :: IfaceConAlt
IfaceDataAlt :: IfExtName -> IfaceConAlt
IfaceLitAlt :: Literal -> IfaceConAlt
type IfaceIdInfo = [IfaceInfoItem]
data IfaceIdDetails
IfVanillaId :: IfaceIdDetails
IfRecSelId :: Either IfaceTyCon IfaceDecl -> Bool -> IfaceIdDetails
IfDFunId :: IfaceIdDetails
data IfaceUnfolding
IfCoreUnfold :: Bool -> IfaceExpr -> IfaceUnfolding
IfCompulsory :: IfaceExpr -> IfaceUnfolding
IfInlineRule :: Arity -> Bool -> Bool -> IfaceExpr -> IfaceUnfolding
IfDFunUnfold :: [IfaceBndr] -> [IfaceExpr] -> IfaceUnfolding
data IfaceInfoItem
HsArity :: Arity -> IfaceInfoItem
HsStrictness :: StrictSig -> IfaceInfoItem
HsCpr :: CprSig -> IfaceInfoItem
HsInline :: InlinePragma -> IfaceInfoItem
HsUnfold :: Bool -> IfaceUnfolding -> IfaceInfoItem
HsNoCafRefs :: IfaceInfoItem
HsLevity :: IfaceInfoItem
HsLFInfo :: IfaceLFInfo -> IfaceInfoItem
data IfaceRule
IfaceRule :: RuleName -> Activation -> [IfaceBndr] -> IfExtName -> [IfaceExpr] -> IfaceExpr -> Bool -> IsOrphan -> IfaceRule
[ifRuleName] :: IfaceRule -> RuleName
[ifActivation] :: IfaceRule -> Activation
[ifRuleBndrs] :: IfaceRule -> [IfaceBndr]
[ifRuleHead] :: IfaceRule -> IfExtName
[ifRuleArgs] :: IfaceRule -> [IfaceExpr]
[ifRuleRhs] :: IfaceRule -> IfaceExpr
[ifRuleAuto] :: IfaceRule -> Bool
[ifRuleOrph] :: IfaceRule -> IsOrphan
data IfaceAnnotation
IfaceAnnotation :: IfaceAnnTarget -> AnnPayload -> IfaceAnnotation
[ifAnnotatedTarget] :: IfaceAnnotation -> IfaceAnnTarget
[ifAnnotatedValue] :: IfaceAnnotation -> AnnPayload
type IfaceAnnTarget = AnnTarget OccName
data IfaceClsInst
IfaceClsInst :: IfExtName -> [Maybe IfaceTyCon] -> IfExtName -> OverlapFlag -> IsOrphan -> IfaceClsInst
[ifInstCls] :: IfaceClsInst -> IfExtName
[ifInstTys] :: IfaceClsInst -> [Maybe IfaceTyCon]
[ifDFun] :: IfaceClsInst -> IfExtName
[ifOFlag] :: IfaceClsInst -> OverlapFlag
[ifInstOrph] :: IfaceClsInst -> IsOrphan
data IfaceFamInst
IfaceFamInst :: IfExtName -> [Maybe IfaceTyCon] -> IfExtName -> IsOrphan -> IfaceFamInst
[ifFamInstFam] :: IfaceFamInst -> IfExtName
[ifFamInstTys] :: IfaceFamInst -> [Maybe IfaceTyCon]
[ifFamInstAxiom] :: IfaceFamInst -> IfExtName
[ifFamInstOrph] :: IfaceFamInst -> IsOrphan
data IfaceTickish
IfaceHpcTick :: Module -> Int -> IfaceTickish
IfaceSCC :: CostCentre -> Bool -> Bool -> IfaceTickish
IfaceSource :: RealSrcSpan -> String -> IfaceTickish
data IfaceClassBody
IfAbstractClass :: IfaceClassBody
IfConcreteClass :: IfaceContext -> [IfaceAT] -> [IfaceClassOp] -> BooleanFormula IfLclName -> IfaceClassBody
[ifClassCtxt] :: IfaceClassBody -> IfaceContext
[ifATs] :: IfaceClassBody -> [IfaceAT]
[ifSigs] :: IfaceClassBody -> [IfaceClassOp]
[ifMinDef] :: IfaceClassBody -> BooleanFormula IfLclName

-- | This corresponds to an HsImplBang; that is, the final implementation
--   decision about the data constructor arg
data IfaceBang
IfNoBang :: IfaceBang
IfStrict :: IfaceBang
IfUnpack :: IfaceBang
IfUnpackCo :: IfaceCoercion -> IfaceBang

-- | This corresponds to HsSrcBang
data IfaceSrcBang
IfSrcBang :: SrcUnpackedness -> SrcStrictness -> IfaceSrcBang

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {-# UNPACK #-} specified
SrcUnpack :: SrcUnpackedness

-- | {-# NOUNPACK #-} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie <tt>~</tt>
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness
data IfaceAxBranch
IfaceAxBranch :: [IfaceTvBndr] -> [IfaceTvBndr] -> [IfaceIdBndr] -> IfaceAppArgs -> [Role] -> IfaceType -> [BranchIndex] -> IfaceAxBranch
[ifaxbTyVars] :: IfaceAxBranch -> [IfaceTvBndr]
[ifaxbEtaTyVars] :: IfaceAxBranch -> [IfaceTvBndr]
[ifaxbCoVars] :: IfaceAxBranch -> [IfaceIdBndr]
[ifaxbLHS] :: IfaceAxBranch -> IfaceAppArgs
[ifaxbRoles] :: IfaceAxBranch -> [Role]
[ifaxbRHS] :: IfaceAxBranch -> IfaceType
[ifaxbIncomps] :: IfaceAxBranch -> [BranchIndex]
data IfaceTyConParent
IfNoParent :: IfaceTyConParent
IfDataInstance :: IfExtName -> IfaceTyCon -> IfaceAppArgs -> IfaceTyConParent
data IfaceCompleteMatch
IfaceCompleteMatch :: [IfExtName] -> Maybe IfaceTyCon -> IfaceCompleteMatch

-- | Iface type for LambdaFormInfo. Fields not relevant for imported Ids
--   are omitted in this type.
data IfaceLFInfo
IfLFReEntrant :: !RepArity -> IfaceLFInfo
IfLFThunk :: !Bool -> !Bool -> IfaceLFInfo
IfLFCon :: !Name -> IfaceLFInfo
IfLFUnknown :: !Bool -> IfaceLFInfo
IfLFUnlifted :: IfaceLFInfo

-- | A binding top-level <a>Name</a> in an interface file (e.g. the name of
--   an <a>IfaceDecl</a>).
type IfaceTopBndr = Name
putIfaceTopBndr :: BinHandle -> IfaceTopBndr -> IO ()
getIfaceTopBndr :: BinHandle -> IO IfaceTopBndr
ifaceDeclImplicitBndrs :: IfaceDecl -> [OccName]
visibleIfConDecls :: IfaceConDecls -> [IfaceConDecl]
ifaceDeclFingerprints :: Fingerprint -> IfaceDecl -> [(OccName, Fingerprint)]
freeNamesIfDecl :: IfaceDecl -> NameSet
freeNamesIfRule :: IfaceRule -> NameSet
freeNamesIfFamInst :: IfaceFamInst -> NameSet

-- | Pretty Print an IfaceExpr
--   
--   The first argument should be a function that adds parens in context
--   that need an atomic value (e.g. function args)
pprIfaceExpr :: (SDoc -> SDoc) -> IfaceExpr -> SDoc
pprIfaceDecl :: ShowSub -> IfaceDecl -> SDoc
newtype AltPpr
AltPpr :: Maybe (OccName -> SDoc) -> AltPpr
data ShowSub
ShowSub :: ShowHowMuch -> ShowForAllFlag -> ShowSub
[ss_how_much] :: ShowSub -> ShowHowMuch
[ss_forall] :: ShowSub -> ShowForAllFlag
data ShowHowMuch

-- | Header information only, not rhs
ShowHeader :: AltPpr -> ShowHowMuch

-- | Show only some sub-components. Specifically,
--   
--   <ul>
--   <li><i><tt>[]</tt></i> Print all sub-components.</li>
--   <li><i><tt>(n:ns)</tt></i> Print sub-component <tt>n</tt> with
--   <tt>ShowSub = ns</tt>; elide other sub-components to <tt>...</tt> May
--   14: the list is max 1 element long at the moment</li>
--   </ul>
ShowSome :: [OccName] -> AltPpr -> ShowHowMuch

-- | Everything including GHC-internal information (used in --show-iface)
ShowIface :: ShowHowMuch
showToIface :: ShowSub
showToHeader :: ShowSub
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.ShowHowMuch
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceRule
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceRule
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceRule
instance GHC.Types.Name.NamedThing GHC.Iface.Syntax.IfaceDecl
instance GHC.Types.Name.Occurrence.HasOccName GHC.Iface.Syntax.IfaceDecl
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceDecl
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceAT
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceIdDetails
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceDecl
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceAT
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceIdDetails
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceDecl
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceClassBody
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceAT
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceIdDetails
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceExpr
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceInfoItem
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceUnfolding
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceInfoItem
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceUnfolding
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceAlt
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceExpr
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceBinding
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceLetBndr
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceInfoItem
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceUnfolding
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceExpr
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceAlt
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceBinding
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceLetBndr
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceJoinInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceJoinInfo
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceJoinInfo
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceConAlt
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceConAlt
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceConAlt
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceTickish
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceTickish
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceLFInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceLFInfo
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceCompleteMatch
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceCompleteMatch
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceCompleteMatch
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceAnnotation
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceAnnotation
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceAnnotation
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceFamInst
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceFamInst
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceFamInst
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceClsInst
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceClsInst
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceClsInst
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceConDecls
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceConDecls
instance GHC.Types.Name.NamedThing GHC.Iface.Syntax.IfaceConDecl
instance GHC.Types.Name.Occurrence.HasOccName GHC.Iface.Syntax.IfaceConDecl
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceConDecl
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceConDecl
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceSrcBang
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceSrcBang
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceBang
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceBang
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceFamTyConFlav
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceFamTyConFlav
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceAxBranch
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceAxBranch
instance GHC.Types.Name.NamedThing GHC.Iface.Syntax.IfaceClassOp
instance GHC.Types.Name.Occurrence.HasOccName GHC.Iface.Syntax.IfaceClassOp
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceClassOp
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceClassOp
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceClassOp
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceTyConParent
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceTyConParent
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceTyConParent


-- | Orphan Binary instances for Data.Typeable stuff
module GHC.Utils.Binary.Typeable
getSomeTypeRep :: BinHandle -> IO SomeTypeRep
instance GHC.Utils.Binary.Binary GHC.Types.TyCon
instance GHC.Utils.Binary.Binary Data.Typeable.Internal.SomeTypeRep
instance forall k (a :: k). Data.Typeable.Internal.Typeable a => GHC.Utils.Binary.Binary (Data.Typeable.Internal.TypeRep a)
instance GHC.Utils.Binary.Binary GHC.Types.VecCount
instance GHC.Utils.Binary.Binary GHC.Types.VecElem
instance GHC.Utils.Binary.Binary GHC.Types.RuntimeRep
instance GHC.Utils.Binary.Binary GHC.Types.KindRep
instance GHC.Utils.Binary.Binary GHC.Types.TypeLitSort
instance GHC.Utils.Binary.Binary GHC.Serialized.Serialized


-- | Computing fingerprints of values serializeable with GHC's "Binary"
--   module.
module GHC.Iface.Recomp.Binary
fingerprintBinMem :: BinHandle -> IO Fingerprint
computeFingerprint :: Binary a => (BinHandle -> Name -> IO ()) -> a -> IO Fingerprint

-- | Used when we want to fingerprint a structure without depending on the
--   fingerprints of external Names that it refers to.
putNameLiterally :: BinHandle -> Name -> IO ()

module GHC.Iface.Ext.Fields
newtype ExtensibleFields
ExtensibleFields :: Map FieldName BinData -> ExtensibleFields
[getExtensibleFields] :: ExtensibleFields -> Map FieldName BinData
type FieldName = String
emptyExtensibleFields :: ExtensibleFields

-- | Reading
readField :: Binary a => FieldName -> ExtensibleFields -> IO (Maybe a)
readFieldWith :: FieldName -> (BinHandle -> IO a) -> ExtensibleFields -> IO (Maybe a)

-- | Writing
writeField :: Binary a => FieldName -> a -> ExtensibleFields -> IO ExtensibleFields
writeFieldWith :: FieldName -> (BinHandle -> IO ()) -> ExtensibleFields -> IO ExtensibleFields
deleteField :: FieldName -> ExtensibleFields -> ExtensibleFields
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Fields.ExtensibleFields
instance Control.DeepSeq.NFData GHC.Iface.Ext.Fields.ExtensibleFields


-- | Info about modules in the "home" unit
module GHC.Unit.Home.ModInfo

-- | Information about modules in the package being compiled
data HomeModInfo
HomeModInfo :: !ModIface -> ModDetails -> !Maybe Linkable -> HomeModInfo

-- | The basic loaded interface file: every loaded module has one of these,
--   even if it is imported from another package
[hm_iface] :: HomeModInfo -> !ModIface

-- | Extra information that has been created from the <a>ModIface_</a> for
--   the module, typically during typechecking
[hm_details] :: HomeModInfo -> ModDetails

-- | The actual artifact we would like to link to access things in this
--   module.
--   
--   <a>hm_linkable</a> might be Nothing:
--   
--   <ol>
--   <li>If this is an .hs-boot module</li>
--   <li>Temporarily during compilation if we pruned away the old linkable
--   because it was out of date.</li>
--   </ol>
--   
--   After a complete compilation (<a>load</a>), all <a>hm_linkable</a>
--   fields in the <a>HomePackageTable</a> will be <tt>Just</tt>.
--   
--   When re-linking a module (<a>HscNoRecomp</a>), we construct the
--   <a>HomeModInfo</a> by building a new <a>ModDetails</a> from the old
--   <a>ModIface_</a> (only).
[hm_linkable] :: HomeModInfo -> !Maybe Linkable

-- | Helps us find information about modules in the home package
type HomePackageTable = DModuleNameEnv HomeModInfo

-- | Constructs an empty HomePackageTable
emptyHomePackageTable :: HomePackageTable
lookupHpt :: HomePackageTable -> ModuleName -> Maybe HomeModInfo
eltsHpt :: HomePackageTable -> [HomeModInfo]
filterHpt :: (HomeModInfo -> Bool) -> HomePackageTable -> HomePackageTable
allHpt :: (HomeModInfo -> Bool) -> HomePackageTable -> Bool
anyHpt :: (HomeModInfo -> Bool) -> HomePackageTable -> Bool
mapHpt :: (HomeModInfo -> HomeModInfo) -> HomePackageTable -> HomePackageTable
delFromHpt :: HomePackageTable -> ModuleName -> HomePackageTable
addToHpt :: HomePackageTable -> ModuleName -> HomeModInfo -> HomePackageTable
addListToHpt :: HomePackageTable -> [(ModuleName, HomeModInfo)] -> HomePackageTable
lookupHptDirectly :: HomePackageTable -> Unique -> Maybe HomeModInfo
lookupHptByModule :: HomePackageTable -> Module -> Maybe HomeModInfo
listToHpt :: [(ModuleName, HomeModInfo)] -> HomePackageTable
pprHPT :: HomePackageTable -> SDoc

module GHC.Linker.Types
newtype Loader
Loader :: MVar (Maybe LoaderState) -> Loader
[loader_state] :: Loader -> MVar (Maybe LoaderState)
data LoaderState
LoaderState :: ClosureEnv -> !ItblEnv -> ![Linkable] -> ![Linkable] -> ![UnitId] -> ![(FilePath, String)] -> LoaderState

-- | Current global mapping from Names to their true values
[closure_env] :: LoaderState -> ClosureEnv

-- | The current global mapping from RdrNames of DataCons to info table
--   addresses. When a new Unlinked is linked into the running image, or an
--   existing module in the image is replaced, the itbl_env must be updated
--   appropriately.
[itbl_env] :: LoaderState -> !ItblEnv

-- | The currently loaded interpreted modules (home package)
[bcos_loaded] :: LoaderState -> ![Linkable]

-- | And the currently-loaded compiled modules (home package)
[objs_loaded] :: LoaderState -> ![Linkable]

-- | The currently-loaded packages; always object code Held, as usual, in
--   dependency order; though I am not sure if that is really important
[pkgs_loaded] :: LoaderState -> ![UnitId]

-- | We need to remember the name of previous temporary DLL/.so libraries
--   so we can link them (see #10322)
[temp_sos] :: LoaderState -> ![(FilePath, String)]
uninitializedLoader :: IO Loader

-- | Information we can use to dynamically link modules into the compiler
data Linkable
LM :: UTCTime -> Module -> [Unlinked] -> Linkable

-- | Time at which this linkable was built (i.e. when the bytecodes were
--   produced, or the mod date on the files)
[linkableTime] :: Linkable -> UTCTime

-- | The linkable module itself
[linkableModule] :: Linkable -> Module

-- | Those files and chunks of code we have yet to link.
--   
--   INVARIANT: A valid linkable always has at least one <a>Unlinked</a>
--   item. If this list is empty, the Linkable represents a fake linkable,
--   which is generated with no backend is used to avoid recompiling
--   modules.
--   
--   ToDo: Do items get removed from this list when they get linked?
[linkableUnlinked] :: Linkable -> [Unlinked]

-- | Objects which have yet to be linked by the compiler
data Unlinked

-- | An object file (.o)
DotO :: FilePath -> Unlinked

-- | Static archive file (.a)
DotA :: FilePath -> Unlinked

-- | Dynamically linked library file (.so, .dll, .dylib)
DotDLL :: FilePath -> Unlinked

-- | A byte-code object, lives only in memory. Also carries some static
--   pointer table entries which should be loaded along with the BCOs. See
--   Note [Grant plan for static forms] in
--   <a>GHC.Iface.Tidy.StaticPtrTable</a>.
BCOs :: CompiledByteCode -> [SptEntry] -> Unlinked

-- | An entry to be inserted into a module's static pointer table. See Note
--   [Grand plan for static forms] in <a>GHC.Iface.Tidy.StaticPtrTable</a>.
data SptEntry
SptEntry :: Id -> Fingerprint -> SptEntry
isObjectLinkable :: Linkable -> Bool
linkableObjs :: Linkable -> [FilePath]

-- | Is this an actual file on disk we can link in somehow?
isObject :: Unlinked -> Bool

-- | Retrieve the filename of the linkable if possible. Panic if it is a
--   byte-code object
nameOfObject :: Unlinked -> FilePath

-- | Is this a bytecode linkable with no file on disk?
isInterpretable :: Unlinked -> Bool

-- | Retrieve the compiled byte-code if possible. Panic if it is a
--   file-based linkable
byteCodeOfObject :: Unlinked -> CompiledByteCode
instance GHC.Utils.Outputable.Outputable GHC.Linker.Types.Linkable
instance GHC.Utils.Outputable.Outputable GHC.Linker.Types.Unlinked
instance GHC.Utils.Outputable.Outputable GHC.Linker.Types.SptEntry


-- | Bytecode assembler types
module GHC.ByteCode.Types
data CompiledByteCode
CompiledByteCode :: [UnlinkedBCO] -> ItblEnv -> [FFIInfo] -> [RemotePtr ()] -> Maybe ModBreaks -> CompiledByteCode
[bc_bcos] :: CompiledByteCode -> [UnlinkedBCO]
[bc_itbls] :: CompiledByteCode -> ItblEnv
[bc_ffis] :: CompiledByteCode -> [FFIInfo]
[bc_strs] :: CompiledByteCode -> [RemotePtr ()]
[bc_breaks] :: CompiledByteCode -> Maybe ModBreaks
seqCompiledByteCode :: CompiledByteCode -> ()
newtype FFIInfo
FFIInfo :: RemotePtr C_ffi_cif -> FFIInfo
newtype RegBitmap
RegBitmap :: Word32 -> RegBitmap
[unRegBitmap] :: RegBitmap -> Word32
data TupleInfo
TupleInfo :: !WordOff -> !GlobalRegSet -> !WordOff -> TupleInfo
[tupleSize] :: TupleInfo -> !WordOff
[tupleRegs] :: TupleInfo -> !GlobalRegSet
[tupleNativeStackSize] :: TupleInfo -> !WordOff
voidTupleInfo :: TupleInfo
newtype ByteOff
ByteOff :: Int -> ByteOff
newtype WordOff
WordOff :: Int -> WordOff
data UnlinkedBCO
UnlinkedBCO :: !Name -> {-# UNPACK #-} !Int -> !UArray Int Word16 -> !UArray Int Word64 -> !SizedSeq BCONPtr -> !SizedSeq BCOPtr -> UnlinkedBCO
[unlinkedBCOName] :: UnlinkedBCO -> !Name
[unlinkedBCOArity] :: UnlinkedBCO -> {-# UNPACK #-} !Int
[unlinkedBCOInstrs] :: UnlinkedBCO -> !UArray Int Word16
[unlinkedBCOBitmap] :: UnlinkedBCO -> !UArray Int Word64
[unlinkedBCOLits] :: UnlinkedBCO -> !SizedSeq BCONPtr
[unlinkedBCOPtrs] :: UnlinkedBCO -> !SizedSeq BCOPtr
data BCOPtr
BCOPtrName :: !Name -> BCOPtr
BCOPtrPrimOp :: !PrimOp -> BCOPtr
BCOPtrBCO :: !UnlinkedBCO -> BCOPtr
BCOPtrBreakArray :: BCOPtr
data BCONPtr
BCONPtrWord :: {-# UNPACK #-} !Word -> BCONPtr
BCONPtrLbl :: !FastString -> BCONPtr
BCONPtrItbl :: !Name -> BCONPtr
BCONPtrStr :: !ByteString -> BCONPtr
type ItblEnv = NameEnv (Name, ItblPtr)
newtype ItblPtr
ItblPtr :: RemotePtr StgInfoTable -> ItblPtr

-- | Information about a breakpoint that we know at code-generation time
data CgBreakInfo
CgBreakInfo :: [Maybe (Id, Word16)] -> Type -> CgBreakInfo
[cgb_vars] :: CgBreakInfo -> [Maybe (Id, Word16)]
[cgb_resty] :: CgBreakInfo -> Type

-- | All the information about the breakpoints for a module
data ModBreaks
ModBreaks :: ForeignRef BreakArray -> !Array BreakIndex SrcSpan -> !Array BreakIndex [OccName] -> !Array BreakIndex [String] -> !Array BreakIndex (RemotePtr CostCentre) -> IntMap CgBreakInfo -> ModBreaks

-- | The array of flags, one per breakpoint, indicating which breakpoints
--   are enabled.
[modBreaks_flags] :: ModBreaks -> ForeignRef BreakArray

-- | An array giving the source span of each breakpoint.
[modBreaks_locs] :: ModBreaks -> !Array BreakIndex SrcSpan

-- | An array giving the names of the free variables at each breakpoint.
[modBreaks_vars] :: ModBreaks -> !Array BreakIndex [OccName]

-- | An array giving the names of the declarations enclosing each
--   breakpoint. See Note [Field modBreaks_decls]
[modBreaks_decls] :: ModBreaks -> !Array BreakIndex [String]

-- | Array pointing to cost centre for each breakpoint
[modBreaks_ccs] :: ModBreaks -> !Array BreakIndex (RemotePtr CostCentre)

-- | info about each breakpoint from the bytecode generator
[modBreaks_breakInfo] :: ModBreaks -> IntMap CgBreakInfo

-- | Breakpoint index
type BreakIndex = Int

-- | Construct an empty ModBreaks
emptyModBreaks :: ModBreaks

-- | C CostCentre type
data CCostCentre
instance Control.DeepSeq.NFData GHC.ByteCode.Types.FFIInfo
instance GHC.Show.Show GHC.ByteCode.Types.FFIInfo
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.ByteOff
instance GHC.Real.Real GHC.ByteCode.Types.ByteOff
instance GHC.Classes.Ord GHC.ByteCode.Types.ByteOff
instance GHC.Num.Num GHC.ByteCode.Types.ByteOff
instance GHC.Real.Integral GHC.ByteCode.Types.ByteOff
instance GHC.Show.Show GHC.ByteCode.Types.ByteOff
instance GHC.Classes.Eq GHC.ByteCode.Types.ByteOff
instance GHC.Enum.Enum GHC.ByteCode.Types.ByteOff
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.WordOff
instance GHC.Real.Real GHC.ByteCode.Types.WordOff
instance GHC.Classes.Ord GHC.ByteCode.Types.WordOff
instance GHC.Num.Num GHC.ByteCode.Types.WordOff
instance GHC.Real.Integral GHC.ByteCode.Types.WordOff
instance GHC.Show.Show GHC.ByteCode.Types.WordOff
instance GHC.Classes.Eq GHC.ByteCode.Types.WordOff
instance GHC.Enum.Enum GHC.ByteCode.Types.WordOff
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.RegBitmap
instance GHC.Bits.FiniteBits GHC.ByteCode.Types.RegBitmap
instance GHC.Bits.Bits GHC.ByteCode.Types.RegBitmap
instance GHC.Real.Real GHC.ByteCode.Types.RegBitmap
instance GHC.Classes.Ord GHC.ByteCode.Types.RegBitmap
instance GHC.Num.Num GHC.ByteCode.Types.RegBitmap
instance GHC.Real.Integral GHC.ByteCode.Types.RegBitmap
instance GHC.Show.Show GHC.ByteCode.Types.RegBitmap
instance GHC.Classes.Eq GHC.ByteCode.Types.RegBitmap
instance GHC.Enum.Enum GHC.ByteCode.Types.RegBitmap
instance GHC.Show.Show GHC.ByteCode.Types.TupleInfo
instance Control.DeepSeq.NFData GHC.ByteCode.Types.ItblPtr
instance GHC.Show.Show GHC.ByteCode.Types.ItblPtr
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.CompiledByteCode
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.CgBreakInfo
instance Control.DeepSeq.NFData GHC.ByteCode.Types.UnlinkedBCO
instance Control.DeepSeq.NFData GHC.ByteCode.Types.BCOPtr
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.UnlinkedBCO
instance Control.DeepSeq.NFData GHC.ByteCode.Types.BCONPtr
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.TupleInfo

module GHC.Cmm.Expr
data CmmExpr
CmmLit :: !CmmLit -> CmmExpr
CmmLoad :: !CmmExpr -> !CmmType -> !AlignmentSpec -> CmmExpr
CmmReg :: !CmmReg -> CmmExpr
CmmMachOp :: MachOp -> [CmmExpr] -> CmmExpr
CmmStackSlot :: Area -> {-# UNPACK #-} !Int -> CmmExpr
CmmRegOff :: !CmmReg -> !Int -> CmmExpr
cmmExprType :: Platform -> CmmExpr -> CmmType
cmmExprWidth :: Platform -> CmmExpr -> Width

-- | Returns an alignment in bytes of a CmmExpr when it's a statically
--   known integer constant, otherwise returns an alignment of 1 byte. The
--   caller is responsible for using with a sensible CmmExpr argument.
cmmExprAlignment :: CmmExpr -> Alignment
maybeInvertCmmExpr :: CmmExpr -> Maybe CmmExpr
data CmmReg
CmmLocal :: {-# UNPACK #-} !LocalReg -> CmmReg
CmmGlobal :: GlobalReg -> CmmReg
cmmRegType :: Platform -> CmmReg -> CmmType
cmmRegWidth :: Platform -> CmmReg -> Width
data CmmLit
CmmInt :: !Integer -> !Width -> CmmLit
CmmFloat :: Rational -> !Width -> CmmLit
CmmVec :: [CmmLit] -> CmmLit
CmmLabel :: CLabel -> CmmLit
CmmLabelOff :: CLabel -> !Int -> CmmLit
CmmLabelDiffOff :: CLabel -> CLabel -> !Int -> !Width -> CmmLit
CmmBlock :: {-# UNPACK #-} !BlockId -> CmmLit
CmmHighStackMark :: CmmLit
cmmLitType :: Platform -> CmmLit -> CmmType
data AlignmentSpec
NaturallyAligned :: AlignmentSpec
Unaligned :: AlignmentSpec
data LocalReg

-- | Parameters: 1. Identifier 2. Type
LocalReg :: {-# UNPACK #-} !Unique -> !CmmType -> LocalReg
localRegType :: LocalReg -> CmmType
data GlobalReg
VanillaReg :: {-# UNPACK #-} !Int -> VGcPtr -> GlobalReg
FloatReg :: {-# UNPACK #-} !Int -> GlobalReg
DoubleReg :: {-# UNPACK #-} !Int -> GlobalReg
LongReg :: {-# UNPACK #-} !Int -> GlobalReg
XmmReg :: {-# UNPACK #-} !Int -> GlobalReg
YmmReg :: {-# UNPACK #-} !Int -> GlobalReg
ZmmReg :: {-# UNPACK #-} !Int -> GlobalReg
Sp :: GlobalReg
SpLim :: GlobalReg
Hp :: GlobalReg
HpLim :: GlobalReg
CCCS :: GlobalReg
CurrentTSO :: GlobalReg
CurrentNursery :: GlobalReg
HpAlloc :: GlobalReg
EagerBlackholeInfo :: GlobalReg
GCEnter1 :: GlobalReg
GCFun :: GlobalReg
BaseReg :: GlobalReg
MachSp :: GlobalReg
UnwindReturnReg :: GlobalReg
PicBaseReg :: GlobalReg
isArgReg :: GlobalReg -> Bool
globalRegType :: Platform -> GlobalReg -> CmmType
spReg :: CmmReg
hpReg :: CmmReg
spLimReg :: CmmReg
hpLimReg :: CmmReg
nodeReg :: CmmReg
currentTSOReg :: CmmReg
currentNurseryReg :: CmmReg
hpAllocReg :: CmmReg
cccsReg :: CmmReg
node :: GlobalReg
baseReg :: CmmReg
data VGcPtr
VGcPtr :: VGcPtr
VNonGcPtr :: VGcPtr
class Ord r => DefinerOfRegs r a
class Ord r => UserOfRegs r a
foldRegsDefd :: DefinerOfRegs r a => Platform -> (b -> r -> b) -> b -> a -> b
foldRegsUsed :: UserOfRegs r a => Platform -> (b -> r -> b) -> b -> a -> b
foldLocalRegsDefd :: DefinerOfRegs LocalReg a => Platform -> (b -> LocalReg -> b) -> b -> a -> b
foldLocalRegsUsed :: UserOfRegs LocalReg a => Platform -> (b -> LocalReg -> b) -> b -> a -> b

-- | Sets of registers
type RegSet r = Set r
type LocalRegSet = RegSet LocalReg
type GlobalRegSet = RegSet GlobalReg
emptyRegSet :: RegSet r
elemRegSet :: Ord r => r -> RegSet r -> Bool
extendRegSet :: Ord r => RegSet r -> r -> RegSet r
deleteFromRegSet :: Ord r => RegSet r -> r -> RegSet r
mkRegSet :: Ord r => [r] -> RegSet r
plusRegSet :: Ord r => RegSet r -> RegSet r -> RegSet r
minusRegSet :: Ord r => RegSet r -> RegSet r -> RegSet r
timesRegSet :: Ord r => RegSet r -> RegSet r -> RegSet r
sizeRegSet :: RegSet r -> Int
nullRegSet :: RegSet r -> Bool
regSetToList :: RegSet r -> [r]

-- | A stack area is either the stack slot where a variable is spilled or
--   the stack space where function arguments and results are passed.
data Area
Old :: Area
Young :: {-# UNPACK #-} !BlockId -> Area
instance GHC.Show.Show GHC.Cmm.Expr.AlignmentSpec
instance GHC.Classes.Ord GHC.Cmm.Expr.AlignmentSpec
instance GHC.Classes.Eq GHC.Cmm.Expr.AlignmentSpec
instance GHC.Show.Show GHC.Cmm.Expr.Area
instance GHC.Classes.Ord GHC.Cmm.Expr.Area
instance GHC.Classes.Eq GHC.Cmm.Expr.Area
instance GHC.Show.Show GHC.Cmm.Expr.CmmLit
instance GHC.Classes.Eq GHC.Cmm.Expr.CmmLit
instance GHC.Show.Show GHC.Cmm.Expr.LocalReg
instance GHC.Show.Show GHC.Cmm.Expr.VGcPtr
instance GHC.Classes.Eq GHC.Cmm.Expr.VGcPtr
instance GHC.Show.Show GHC.Cmm.Expr.GlobalReg
instance GHC.Show.Show GHC.Cmm.Expr.CmmReg
instance GHC.Classes.Ord GHC.Cmm.Expr.CmmReg
instance GHC.Classes.Eq GHC.Cmm.Expr.CmmReg
instance GHC.Show.Show GHC.Cmm.Expr.CmmExpr
instance GHC.Classes.Eq GHC.Cmm.Expr.CmmExpr
instance (GHC.Classes.Ord r, GHC.Cmm.Expr.UserOfRegs r GHC.Cmm.Expr.CmmReg) => GHC.Cmm.Expr.UserOfRegs r GHC.Cmm.Expr.CmmExpr
instance GHC.Cmm.Expr.UserOfRegs GHC.Cmm.Expr.LocalReg GHC.Cmm.Expr.CmmReg
instance GHC.Cmm.Expr.DefinerOfRegs GHC.Cmm.Expr.LocalReg GHC.Cmm.Expr.CmmReg
instance GHC.Cmm.Expr.UserOfRegs GHC.Cmm.Expr.GlobalReg GHC.Cmm.Expr.CmmReg
instance GHC.Cmm.Expr.DefinerOfRegs GHC.Cmm.Expr.GlobalReg GHC.Cmm.Expr.CmmReg
instance GHC.Classes.Eq GHC.Cmm.Expr.GlobalReg
instance GHC.Classes.Ord GHC.Cmm.Expr.GlobalReg
instance GHC.Classes.Ord r => GHC.Cmm.Expr.DefinerOfRegs r r
instance GHC.Cmm.Expr.DefinerOfRegs r a => GHC.Cmm.Expr.DefinerOfRegs r [a]
instance GHC.Classes.Ord r => GHC.Cmm.Expr.UserOfRegs r r
instance GHC.Cmm.Expr.UserOfRegs r a => GHC.Cmm.Expr.UserOfRegs r [a]
instance GHC.Classes.Eq GHC.Cmm.Expr.LocalReg
instance GHC.Classes.Ord GHC.Cmm.Expr.LocalReg
instance GHC.Types.Unique.Uniquable GHC.Cmm.Expr.LocalReg
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Expr.CmmLit

module GHC.Cmm.MachOp

-- | Machine-level primops; ones which we can reasonably delegate to the
--   native code generators to handle.
--   
--   Most operations are parameterised by the <a>Width</a> that they
--   operate on. Some operations have separate signed and unsigned
--   versions, and float and integer versions.
--   
--   Note that there are variety of places in the native code generator
--   where we assume that the code produced for a MachOp does not introduce
--   new blocks.
data MachOp
MO_Add :: Width -> MachOp
MO_Sub :: Width -> MachOp
MO_Eq :: Width -> MachOp
MO_Ne :: Width -> MachOp
MO_Mul :: Width -> MachOp
MO_S_MulMayOflo :: Width -> MachOp
MO_S_Quot :: Width -> MachOp
MO_S_Rem :: Width -> MachOp
MO_S_Neg :: Width -> MachOp
MO_U_MulMayOflo :: Width -> MachOp
MO_U_Quot :: Width -> MachOp
MO_U_Rem :: Width -> MachOp
MO_S_Ge :: Width -> MachOp
MO_S_Le :: Width -> MachOp
MO_S_Gt :: Width -> MachOp
MO_S_Lt :: Width -> MachOp
MO_U_Ge :: Width -> MachOp
MO_U_Le :: Width -> MachOp
MO_U_Gt :: Width -> MachOp
MO_U_Lt :: Width -> MachOp
MO_F_Add :: Width -> MachOp
MO_F_Sub :: Width -> MachOp
MO_F_Neg :: Width -> MachOp
MO_F_Mul :: Width -> MachOp
MO_F_Quot :: Width -> MachOp
MO_F_Eq :: Width -> MachOp
MO_F_Ne :: Width -> MachOp
MO_F_Ge :: Width -> MachOp
MO_F_Le :: Width -> MachOp
MO_F_Gt :: Width -> MachOp
MO_F_Lt :: Width -> MachOp
MO_And :: Width -> MachOp
MO_Or :: Width -> MachOp
MO_Xor :: Width -> MachOp
MO_Not :: Width -> MachOp
MO_Shl :: Width -> MachOp
MO_U_Shr :: Width -> MachOp
MO_S_Shr :: Width -> MachOp
MO_SF_Conv :: Width -> Width -> MachOp
MO_FS_Conv :: Width -> Width -> MachOp
MO_SS_Conv :: Width -> Width -> MachOp
MO_UU_Conv :: Width -> Width -> MachOp
MO_XX_Conv :: Width -> Width -> MachOp
MO_FF_Conv :: Width -> Width -> MachOp
MO_V_Insert :: Length -> Width -> MachOp
MO_V_Extract :: Length -> Width -> MachOp
MO_V_Add :: Length -> Width -> MachOp
MO_V_Sub :: Length -> Width -> MachOp
MO_V_Mul :: Length -> Width -> MachOp
MO_VS_Quot :: Length -> Width -> MachOp
MO_VS_Rem :: Length -> Width -> MachOp
MO_VS_Neg :: Length -> Width -> MachOp
MO_VU_Quot :: Length -> Width -> MachOp
MO_VU_Rem :: Length -> Width -> MachOp
MO_VF_Insert :: Length -> Width -> MachOp
MO_VF_Extract :: Length -> Width -> MachOp
MO_VF_Add :: Length -> Width -> MachOp
MO_VF_Sub :: Length -> Width -> MachOp
MO_VF_Neg :: Length -> Width -> MachOp
MO_VF_Mul :: Length -> Width -> MachOp
MO_VF_Quot :: Length -> Width -> MachOp
MO_AlignmentCheck :: Int -> Width -> MachOp
pprMachOp :: MachOp -> SDoc

-- | Returns <a>True</a> if the MachOp has commutable arguments. This is
--   used in the platform-independent Cmm optimisations.
--   
--   If in doubt, return <a>False</a>. This generates worse code on the
--   native routes, but is otherwise harmless.
isCommutableMachOp :: MachOp -> Bool

-- | Returns <a>True</a> if the MachOp is associative (i.e. <tt>(x+y)+z ==
--   x+(y+z)</tt>) This is used in the platform-independent Cmm
--   optimisations.
--   
--   If in doubt, return <a>False</a>. This generates worse code on the
--   native routes, but is otherwise harmless.
isAssociativeMachOp :: MachOp -> Bool

-- | Returns <a>True</a> if the MachOp is a comparison.
--   
--   If in doubt, return False. This generates worse code on the native
--   routes, but is otherwise harmless.
isComparisonMachOp :: MachOp -> Bool

-- | Returns <tt>Just w</tt> if the operation is an integer comparison with
--   width <tt>w</tt>, or <tt>Nothing</tt> otherwise.
maybeIntComparison :: MachOp -> Maybe Width

-- | Returns the MachRep of the result of a MachOp.
machOpResultType :: Platform -> MachOp -> [CmmType] -> CmmType

-- | This function is used for debugging only: we can check whether an
--   application of a MachOp is "type-correct" by checking that the
--   MachReps of its arguments are the same as the MachOp expects. This is
--   used when linting a CmmExpr.
machOpArgReps :: Platform -> MachOp -> [Width]
maybeInvertComparison :: MachOp -> Maybe MachOp
isFloatComparison :: MachOp -> Bool
mo_wordAdd :: Platform -> MachOp
mo_wordSub :: Platform -> MachOp
mo_wordEq :: Platform -> MachOp
mo_wordNe :: Platform -> MachOp
mo_wordMul :: Platform -> MachOp
mo_wordSQuot :: Platform -> MachOp
mo_wordSRem :: Platform -> MachOp
mo_wordSNeg :: Platform -> MachOp
mo_wordUQuot :: Platform -> MachOp
mo_wordURem :: Platform -> MachOp
mo_wordSGe :: Platform -> MachOp
mo_wordSLe :: Platform -> MachOp
mo_wordSGt :: Platform -> MachOp
mo_wordSLt :: Platform -> MachOp
mo_wordUGe :: Platform -> MachOp
mo_wordULe :: Platform -> MachOp
mo_wordUGt :: Platform -> MachOp
mo_wordULt :: Platform -> MachOp
mo_wordAnd :: Platform -> MachOp
mo_wordOr :: Platform -> MachOp
mo_wordXor :: Platform -> MachOp
mo_wordNot :: Platform -> MachOp
mo_wordShl :: Platform -> MachOp
mo_wordSShr :: Platform -> MachOp
mo_wordUShr :: Platform -> MachOp
mo_u_8To32 :: MachOp
mo_s_8To32 :: MachOp
mo_u_16To32 :: MachOp
mo_s_16To32 :: MachOp
mo_u_8ToWord :: Platform -> MachOp
mo_s_8ToWord :: Platform -> MachOp
mo_u_16ToWord :: Platform -> MachOp
mo_s_16ToWord :: Platform -> MachOp
mo_u_32ToWord :: Platform -> MachOp
mo_s_32ToWord :: Platform -> MachOp
mo_32To8 :: MachOp
mo_32To16 :: MachOp
mo_WordTo8 :: Platform -> MachOp
mo_WordTo16 :: Platform -> MachOp
mo_WordTo32 :: Platform -> MachOp
mo_WordTo64 :: Platform -> MachOp
data CallishMachOp
MO_F64_Pwr :: CallishMachOp
MO_F64_Sin :: CallishMachOp
MO_F64_Cos :: CallishMachOp
MO_F64_Tan :: CallishMachOp
MO_F64_Sinh :: CallishMachOp
MO_F64_Cosh :: CallishMachOp
MO_F64_Tanh :: CallishMachOp
MO_F64_Asin :: CallishMachOp
MO_F64_Acos :: CallishMachOp
MO_F64_Atan :: CallishMachOp
MO_F64_Asinh :: CallishMachOp
MO_F64_Acosh :: CallishMachOp
MO_F64_Atanh :: CallishMachOp
MO_F64_Log :: CallishMachOp
MO_F64_Log1P :: CallishMachOp
MO_F64_Exp :: CallishMachOp
MO_F64_ExpM1 :: CallishMachOp
MO_F64_Fabs :: CallishMachOp
MO_F64_Sqrt :: CallishMachOp
MO_F32_Pwr :: CallishMachOp
MO_F32_Sin :: CallishMachOp
MO_F32_Cos :: CallishMachOp
MO_F32_Tan :: CallishMachOp
MO_F32_Sinh :: CallishMachOp
MO_F32_Cosh :: CallishMachOp
MO_F32_Tanh :: CallishMachOp
MO_F32_Asin :: CallishMachOp
MO_F32_Acos :: CallishMachOp
MO_F32_Atan :: CallishMachOp
MO_F32_Asinh :: CallishMachOp
MO_F32_Acosh :: CallishMachOp
MO_F32_Atanh :: CallishMachOp
MO_F32_Log :: CallishMachOp
MO_F32_Log1P :: CallishMachOp
MO_F32_Exp :: CallishMachOp
MO_F32_ExpM1 :: CallishMachOp
MO_F32_Fabs :: CallishMachOp
MO_F32_Sqrt :: CallishMachOp
MO_I64_ToI :: CallishMachOp
MO_I64_FromI :: CallishMachOp
MO_W64_ToW :: CallishMachOp
MO_W64_FromW :: CallishMachOp
MO_x64_Neg :: CallishMachOp
MO_x64_Add :: CallishMachOp
MO_x64_Sub :: CallishMachOp
MO_x64_Mul :: CallishMachOp
MO_I64_Quot :: CallishMachOp
MO_I64_Rem :: CallishMachOp
MO_W64_Quot :: CallishMachOp
MO_W64_Rem :: CallishMachOp
MO_x64_And :: CallishMachOp
MO_x64_Or :: CallishMachOp
MO_x64_Xor :: CallishMachOp
MO_x64_Not :: CallishMachOp
MO_x64_Shl :: CallishMachOp
MO_I64_Shr :: CallishMachOp
MO_W64_Shr :: CallishMachOp
MO_x64_Eq :: CallishMachOp
MO_x64_Ne :: CallishMachOp
MO_I64_Ge :: CallishMachOp
MO_I64_Gt :: CallishMachOp
MO_I64_Le :: CallishMachOp
MO_I64_Lt :: CallishMachOp
MO_W64_Ge :: CallishMachOp
MO_W64_Gt :: CallishMachOp
MO_W64_Le :: CallishMachOp
MO_W64_Lt :: CallishMachOp
MO_UF_Conv :: Width -> CallishMachOp
MO_S_Mul2 :: Width -> CallishMachOp
MO_S_QuotRem :: Width -> CallishMachOp
MO_U_QuotRem :: Width -> CallishMachOp
MO_U_QuotRem2 :: Width -> CallishMachOp
MO_Add2 :: Width -> CallishMachOp
MO_AddWordC :: Width -> CallishMachOp
MO_SubWordC :: Width -> CallishMachOp
MO_AddIntC :: Width -> CallishMachOp
MO_SubIntC :: Width -> CallishMachOp
MO_U_Mul2 :: Width -> CallishMachOp
MO_ReadBarrier :: CallishMachOp
MO_WriteBarrier :: CallishMachOp
MO_Touch :: CallishMachOp
MO_Prefetch_Data :: Int -> CallishMachOp
MO_Memcpy :: Int -> CallishMachOp
MO_Memset :: Int -> CallishMachOp
MO_Memmove :: Int -> CallishMachOp
MO_Memcmp :: Int -> CallishMachOp
MO_PopCnt :: Width -> CallishMachOp
MO_Pdep :: Width -> CallishMachOp
MO_Pext :: Width -> CallishMachOp
MO_Clz :: Width -> CallishMachOp
MO_Ctz :: Width -> CallishMachOp
MO_BSwap :: Width -> CallishMachOp
MO_BRev :: Width -> CallishMachOp
MO_AtomicRMW :: Width -> AtomicMachOp -> CallishMachOp
MO_AtomicRead :: Width -> CallishMachOp
MO_AtomicWrite :: Width -> CallishMachOp
MO_Cmpxchg :: Width -> CallishMachOp
MO_Xchg :: Width -> CallishMachOp
callishMachOpHints :: CallishMachOp -> ([ForeignHint], [ForeignHint])
pprCallishMachOp :: CallishMachOp -> SDoc

-- | The alignment of a <tt>memcpy</tt>-ish operation.
machOpMemcpyishAlign :: CallishMachOp -> Maybe Int

-- | The operation to perform atomically.
data AtomicMachOp
AMO_Add :: AtomicMachOp
AMO_Sub :: AtomicMachOp
AMO_And :: AtomicMachOp
AMO_Nand :: AtomicMachOp
AMO_Or :: AtomicMachOp
AMO_Xor :: AtomicMachOp
instance GHC.Show.Show GHC.Cmm.MachOp.MachOp
instance GHC.Classes.Eq GHC.Cmm.MachOp.MachOp
instance GHC.Show.Show GHC.Cmm.MachOp.AtomicMachOp
instance GHC.Classes.Eq GHC.Cmm.MachOp.AtomicMachOp
instance GHC.Show.Show GHC.Cmm.MachOp.CallishMachOp
instance GHC.Classes.Eq GHC.Cmm.MachOp.CallishMachOp

module GHC.Cmm.CLabel

-- | <a>CLabel</a> is an abstract type that supports the following
--   operations:
--   
--   <ul>
--   <li>Pretty printing</li>
--   <li>In a C file, does it need to be declared before use? (i.e. is it
--   guaranteed to be already in scope in the places we need to refer to
--   it?)</li>
--   <li>If it needs to be declared, what type (code or data) should it be
--   declared to have?</li>
--   <li>Is it visible outside this object file or not?</li>
--   <li>Is it "dynamic" (see details below)</li>
--   <li>Eq and Ord, so that we can make sets of CLabels (currently only
--   used in outputting C as far as I can tell, to avoid generating more
--   than one declaration for any given label).</li>
--   <li>Converting an info table label into an entry label.</li>
--   </ul>
--   
--   CLabel usage is a bit messy in GHC as they are used in a number of
--   different contexts:
--   
--   <ul>
--   <li>By the C-- AST to identify labels</li>
--   <li>By the unregisterised C code generator ("PprC") for naming
--   functions (hence the name <a>CLabel</a>)</li>
--   <li>By the native and LLVM code generators to identify labels</li>
--   </ul>
--   
--   For extra fun, each of these uses a slightly different subset of
--   constructors (e.g. <a>AsmTempLabel</a> and <a>AsmTempDerivedLabel</a>
--   are used only in the NCG and LLVM backends).
--   
--   In general, we use <a>IdLabel</a> to represent Haskell things early in
--   the pipeline. However, later optimization passes will often represent
--   blocks they create with <a>LocalBlockLabel</a> where there is no
--   obvious <a>Name</a> to hang off the label.
data CLabel

-- | Indicate if <a>GHC.CmmToC</a> has to generate an extern declaration
--   for the label (e.g. "extern StgWordArray(foo)"). The type is fixed to
--   StgWordArray.
--   
--   Symbols from the RTS don't need "extern" declarations because they are
--   exposed via "includes/Stg.h" with the appropriate type. See
--   <a>needsCDecl</a>.
--   
--   The fixed StgWordArray type led to "conflicting types" issues with
--   user provided Cmm files (not in the RTS) that declare data of another
--   type (#15467 and test for #17920). Hence the Cmm parser considers that
--   labels in data sections don't need the "extern" declaration (just add
--   one explicitly if you need it).
--   
--   See
--   <a>https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/backends/ppr-c#prototypes</a>
--   for why extern declaration are needed at all.
newtype NeedExternDecl
NeedExternDecl :: Bool -> NeedExternDecl

-- | Record where a foreign label is stored.
data ForeignLabelSource

-- | Label is in a named package
ForeignLabelInPackage :: UnitId -> ForeignLabelSource

-- | Label is in some external, system package that doesn't also contain
--   compiled Haskell code, and is not associated with any .hi files. We
--   don't have to worry about Haskell code being inlined from external
--   packages. It is safe to treat the RTS package as "external".
ForeignLabelInExternalPackage :: ForeignLabelSource

-- | Label is in the package currently being compiled. This is only used
--   for creating hacky tmp labels during code generation. Don't use it in
--   any code that might be inlined across a package boundary (ie, core
--   code) else the information will be wrong relative to the destination
--   module.
ForeignLabelInThisPackage :: ForeignLabelSource
data DynamicLinkerLabelInfo
CodeStub :: DynamicLinkerLabelInfo
SymbolPtr :: DynamicLinkerLabelInfo
GotSymbolPtr :: DynamicLinkerLabelInfo
GotSymbolOffset :: DynamicLinkerLabelInfo

-- | Which module is the info table from, and which number was it.
data ConInfoTableLocation
UsageSite :: Module -> Int -> ConInfoTableLocation
DefinitionSite :: ConInfoTableLocation
getConInfoTableLocation :: IdLabelInfo -> Maybe ConInfoTableLocation
mkClosureLabel :: Name -> CafInfo -> CLabel
mkSRTLabel :: Unique -> CLabel
mkInfoTableLabel :: Name -> CafInfo -> CLabel
mkEntryLabel :: Name -> CafInfo -> CLabel
mkRednCountsLabel :: Name -> CLabel
mkConInfoTableLabel :: Name -> ConInfoTableLocation -> CLabel
mkApEntryLabel :: Platform -> Bool -> Int -> CLabel
mkApInfoTableLabel :: Platform -> Bool -> Int -> CLabel
mkClosureTableLabel :: Name -> CafInfo -> CLabel
mkBytesLabel :: Name -> CLabel
mkLocalBlockLabel :: Unique -> CLabel
mkLocalClosureLabel :: Name -> CafInfo -> CLabel
mkLocalInfoTableLabel :: Name -> CafInfo -> CLabel
mkLocalClosureTableLabel :: Name -> CafInfo -> CLabel
mkBlockInfoTableLabel :: Name -> CafInfo -> CLabel
mkBitmapLabel :: Unique -> CLabel
mkStringLitLabel :: Unique -> CLabel
mkAsmTempLabel :: Uniquable a => a -> CLabel
mkAsmTempDerivedLabel :: CLabel -> FastString -> CLabel
mkAsmTempEndLabel :: CLabel -> CLabel

-- | A label indicating the end of a procedure.
mkAsmTempProcEndLabel :: CLabel -> CLabel

-- | Construct a label for a DWARF Debug Information Entity (DIE)
--   describing another symbol.
mkAsmTempDieLabel :: CLabel -> CLabel
mkDirty_MUT_VAR_Label :: CLabel
mkNonmovingWriteBarrierEnabledLabel :: CLabel
mkUpdInfoLabel :: CLabel
mkBHUpdInfoLabel :: CLabel
mkIndStaticInfoLabel :: CLabel
mkMainCapabilityLabel :: CLabel
mkMAP_FROZEN_CLEAN_infoLabel :: CLabel
mkMAP_FROZEN_DIRTY_infoLabel :: CLabel
mkMAP_DIRTY_infoLabel :: CLabel
mkSMAP_FROZEN_CLEAN_infoLabel :: CLabel
mkSMAP_FROZEN_DIRTY_infoLabel :: CLabel
mkSMAP_DIRTY_infoLabel :: CLabel
mkBadAlignmentLabel :: CLabel
mkOutOfBoundsAccessLabel :: CLabel
mkArrWords_infoLabel :: CLabel
mkSRTInfoLabel :: Int -> CLabel
mkTopTickyCtrLabel :: CLabel
mkCAFBlackHoleInfoTableLabel :: CLabel
mkRtsPrimOpLabel :: PrimOp -> CLabel
mkRtsSlowFastTickyCtrLabel :: String -> CLabel
mkSelectorInfoLabel :: Platform -> Bool -> Int -> CLabel
mkSelectorEntryLabel :: Platform -> Bool -> Int -> CLabel
mkCmmInfoLabel :: UnitId -> FastString -> CLabel
mkCmmEntryLabel :: UnitId -> FastString -> CLabel
mkCmmRetInfoLabel :: UnitId -> FastString -> CLabel
mkCmmRetLabel :: UnitId -> FastString -> CLabel
mkCmmCodeLabel :: UnitId -> FastString -> CLabel
mkCmmDataLabel :: UnitId -> NeedExternDecl -> FastString -> CLabel
mkRtsCmmDataLabel :: FastString -> CLabel
mkCmmClosureLabel :: UnitId -> FastString -> CLabel
mkRtsApFastLabel :: FastString -> CLabel
mkPrimCallLabel :: PrimCall -> CLabel

-- | Make a foreign label
mkForeignLabel :: FastString -> Maybe Int -> ForeignLabelSource -> FunctionOrData -> CLabel
mkCCLabel :: CostCentre -> CLabel
mkCCSLabel :: CostCentreStack -> CLabel
mkIPELabel :: InfoProvEnt -> CLabel

-- | Info Table Provenance Entry See Note [Mapping Info Tables to Source
--   Positions]
data InfoProvEnt
InfoProvEnt :: !CLabel -> !Int -> !String -> !Module -> !Maybe (RealSrcSpan, String) -> InfoProvEnt
[infoTablePtr] :: InfoProvEnt -> !CLabel
[infoProvEntClosureType] :: InfoProvEnt -> !Int
[infoTableType] :: InfoProvEnt -> !String
[infoProvModule] :: InfoProvEnt -> !Module
[infoTableProv] :: InfoProvEnt -> !Maybe (RealSrcSpan, String)
mkDynamicLinkerLabel :: DynamicLinkerLabelInfo -> CLabel -> CLabel
mkPicBaseLabel :: CLabel
mkDeadStripPreventer :: CLabel -> CLabel
mkHpcTicksLabel :: Module -> CLabel
hasCAF :: CLabel -> Bool
needsCDecl :: CLabel -> Bool

-- | If a label is a local block label then return just its <a>BlockId</a>,
--   otherwise <a>Nothing</a>.
maybeLocalBlockLabel :: CLabel -> Maybe BlockId

-- | Is a CLabel visible outside this object file or not? From the point of
--   view of the code generator, a name is externally visible if it has to
--   be declared as exported in the .o file's symbol table; that is, made
--   non-static.
externallyVisibleCLabel :: CLabel -> Bool

-- | Check whether a label corresponds to a C function that has a prototype
--   in a system header somewhere, or is built-in to the C compiler. For
--   these labels we avoid generating our own C prototypes.
isMathFun :: CLabel -> Bool
isCFunctionLabel :: CLabel -> Bool
isGcPtrLabel :: CLabel -> Bool

-- | Does a <a>CLabel</a> need dynamic linkage?
--   
--   When referring to data in code, we need to know whether that data
--   resides in a DLL or not. [Win32 only.] <tt>labelDynamic</tt> returns
--   <tt>True</tt> if the label is located in a DLL, be it a data reference
--   or not.
labelDynamic :: NCGConfig -> CLabel -> Bool

-- | Is a <a>CLabel</a> defined in the current module being compiled?
--   
--   Sometimes we can optimise references within a compilation unit in ways
--   that we couldn't for inter-module references. This provides a
--   conservative estimate of whether a <a>CLabel</a> lives in the current
--   module.
isLocalCLabel :: Module -> CLabel -> Bool
mayRedirectTo :: CLabel -> CLabel -> Bool

-- | Whether label is points to some kind of info table
isInfoTableLabel :: CLabel -> Bool

-- | Whether label is points to constructor info table
isConInfoTableLabel :: CLabel -> Bool
isIdLabel :: CLabel -> Bool
isTickyLabel :: CLabel -> Bool
hasHaskellName :: CLabel -> Maybe Name
hasIdLabelInfo :: CLabel -> Maybe IdLabelInfo

-- | Whether label is a top-level string literal
isBytesLabel :: CLabel -> Bool

-- | Whether label is a non-haskell label (defined in C code)
isForeignLabel :: CLabel -> Bool

-- | Whether label is a .rodata label
isSomeRODataLabel :: CLabel -> Bool

-- | Whether label is a static closure label (can come from haskell or cmm)
isStaticClosureLabel :: CLabel -> Bool
toClosureLbl :: Platform -> CLabel -> CLabel
toSlowEntryLbl :: Platform -> CLabel -> CLabel
toEntryLbl :: Platform -> CLabel -> CLabel
toInfoLbl :: Platform -> CLabel -> CLabel

-- | Style of label pretty-printing.
--   
--   When we produce C sources or headers, we have to take into account
--   that C compilers transform C labels when they convert them into
--   symbols. For example, they can add prefixes (e.g., "_" on Darwin) or
--   suffixes (size for stdcalls on Windows). So we provide two ways to
--   pretty-print CLabels: C style or Asm style.
data LabelStyle

-- | C label style (used by C and LLVM backends)
CStyle :: LabelStyle

-- | Asm label style (used by NCG backend)
AsmStyle :: LabelStyle

-- | For debugging problems with the CLabel representation. We can't make a
--   Show instance for CLabel because lots of its components don't have
--   instances. The regular Outputable instance only shows the label name,
--   and not its other info.
pprDebugCLabel :: Platform -> CLabel -> SDoc
pprCLabel :: Platform -> LabelStyle -> CLabel -> SDoc

-- | Generate a label for a procedure internal to a module (if
--   <tt>Opt_ExposeAllSymbols</tt> is enabled). See Note [Internal proc
--   labels].
ppInternalProcLabel :: Module -> CLabel -> Maybe SDoc
dynamicLinkerLabelInfo :: CLabel -> Maybe (DynamicLinkerLabelInfo, CLabel)

-- | Update the label size field in a ForeignLabel
addLabelSize :: CLabel -> Int -> CLabel

-- | Get the label size field from a ForeignLabel
foreignLabelStdcallInfo :: CLabel -> Maybe Int
instance GHC.Classes.Eq GHC.Cmm.CLabel.NeedExternDecl
instance GHC.Classes.Ord GHC.Cmm.CLabel.NeedExternDecl
instance GHC.Classes.Ord GHC.Cmm.CLabel.ForeignLabelSource
instance GHC.Classes.Eq GHC.Cmm.CLabel.ForeignLabelSource
instance GHC.Classes.Ord GHC.Cmm.CLabel.ConInfoTableLocation
instance GHC.Classes.Eq GHC.Cmm.CLabel.ConInfoTableLocation
instance GHC.Classes.Ord GHC.Cmm.CLabel.IdLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.IdLabelInfo
instance GHC.Classes.Ord GHC.Cmm.CLabel.RtsLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.RtsLabelInfo
instance GHC.Classes.Ord GHC.Cmm.CLabel.CmmLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.CmmLabelInfo
instance GHC.Classes.Ord GHC.Cmm.CLabel.DynamicLinkerLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.DynamicLinkerLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.CLabel
instance GHC.Classes.Ord GHC.Cmm.CLabel.InfoProvEnt
instance GHC.Classes.Eq GHC.Cmm.CLabel.InfoProvEnt
instance GHC.Show.Show GHC.Cmm.CLabel.CLabel
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CLabel.CLabel
instance GHC.Classes.Ord GHC.Cmm.CLabel.CLabel
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CLabel.CLabel
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CLabel.IdLabelInfo
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CLabel.ConInfoTableLocation
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CLabel.ForeignLabelSource


-- | Native code generator configuration
module GHC.CmmToAsm.Config

-- | Native code generator configuration
data NCGConfig
NCGConfig :: !Platform -> !SDocContext -> !Module -> !Maybe Int -> !Bool -> !Bool -> !Word -> !Word -> !Bool -> !Bool -> !Bool -> !Bool -> Maybe SseVersion -> Maybe BmiVersion -> !Bool -> !Bool -> !Bool -> !Weights -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> NCGConfig

-- | Target platform
[ncgPlatform] :: NCGConfig -> !Platform

-- | Context for ASM code generation
[ncgAsmContext] :: NCGConfig -> !SDocContext

-- | The name of the module we are currently compiling
[ncgThisModule] :: NCGConfig -> !Module

-- | Mandatory proc alignment
[ncgProcAlignment] :: NCGConfig -> !Maybe Int

-- | Generate code to link against dynamic libraries
[ncgExternalDynamicRefs] :: NCGConfig -> !Bool

-- | Enable Position-Independent Code
[ncgPIC] :: NCGConfig -> !Bool

-- | If inlining <tt>memcpy</tt> produces less than this threshold (in
--   pseudo-instruction unit), do it
[ncgInlineThresholdMemcpy] :: NCGConfig -> !Word

-- | Ditto for <tt>memset</tt>
[ncgInlineThresholdMemset] :: NCGConfig -> !Word

-- | Split sections
[ncgSplitSections] :: NCGConfig -> !Bool
[ncgRegsIterative] :: NCGConfig -> !Bool

-- | Perform ASM linting pass
[ncgAsmLinting] :: NCGConfig -> !Bool

-- | Perform CMM constant folding
[ncgDoConstantFolding] :: NCGConfig -> !Bool

-- | (x86) SSE instructions
[ncgSseVersion] :: NCGConfig -> Maybe SseVersion

-- | (x86) BMI instructions
[ncgBmiVersion] :: NCGConfig -> Maybe BmiVersion
[ncgDumpRegAllocStages] :: NCGConfig -> !Bool
[ncgDumpAsmStats] :: NCGConfig -> !Bool
[ncgDumpAsmConflicts] :: NCGConfig -> !Bool

-- | CFG edge weights
[ncgCfgWeights] :: NCGConfig -> !Weights

-- | Use CFG based block layout algorithm
[ncgCfgBlockLayout] :: NCGConfig -> !Bool

-- | Layout based on last instruction per block.
[ncgCfgWeightlessLayout] :: NCGConfig -> !Bool

-- | Enable Dwarf generation
[ncgDwarfEnabled] :: NCGConfig -> !Bool

-- | Enable unwindings
[ncgDwarfUnwindings] :: NCGConfig -> !Bool

-- | Strip out block information from generated Dwarf
[ncgDwarfStripBlockInfo] :: NCGConfig -> !Bool

-- | Expose symbol table entries for internal symbols
[ncgExposeInternalSymbols] :: NCGConfig -> !Bool

-- | Enable GHC-specific source note DIEs
[ncgDwarfSourceNotes] :: NCGConfig -> !Bool

-- | Return Word size
ncgWordWidth :: NCGConfig -> Width

-- | Size in bytes of the pre-allocated spill space on the C stack
ncgSpillPreallocSize :: NCGConfig -> Int

-- | Return Word size
platformWordWidth :: Platform -> Width

module GHC.CmmToAsm.CFG.Weight

-- | Edge weights to use when generating a CFG from CMM
data Weights
Weights :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Weights
[uncondWeight] :: Weights -> Int
[condBranchWeight] :: Weights -> Int
[switchWeight] :: Weights -> Int
[callWeight] :: Weights -> Int
[likelyCondWeight] :: Weights -> Int
[unlikelyCondWeight] :: Weights -> Int
[infoTablePenalty] :: Weights -> Int
[backEdgeBonus] :: Weights -> Int

-- | Default edge weights
defaultWeights :: Weights
parseWeights :: String -> Weights -> Weights

module GHC.Cmm.BlockId
type BlockId = Label
mkBlockId :: Unique -> BlockId
newBlockId :: MonadUnique m => m BlockId
blockLbl :: BlockId -> CLabel
infoTblLbl :: BlockId -> CLabel

module GHC.Cmm.Dataflow.Label
data Label
data LabelMap v
data LabelSet
type FactBase f = LabelMap f
lookupFact :: Label -> FactBase f -> Maybe f
mkHooplLabel :: Int -> Label
instance GHC.Classes.Ord GHC.Cmm.Dataflow.Label.Label
instance GHC.Classes.Eq GHC.Cmm.Dataflow.Label.Label
instance GHC.Base.Semigroup GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Base.Monoid GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Show.Show GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Classes.Ord GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Classes.Eq GHC.Cmm.Dataflow.Label.LabelSet
instance Data.Traversable.Traversable GHC.Cmm.Dataflow.Label.LabelMap
instance Data.Foldable.Foldable GHC.Cmm.Dataflow.Label.LabelMap
instance GHC.Base.Functor GHC.Cmm.Dataflow.Label.LabelMap
instance GHC.Show.Show v => GHC.Show.Show (GHC.Cmm.Dataflow.Label.LabelMap v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (GHC.Cmm.Dataflow.Label.LabelMap v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (GHC.Cmm.Dataflow.Label.LabelMap v)
instance GHC.Cmm.Dataflow.Collections.IsMap GHC.Cmm.Dataflow.Label.LabelMap
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Cmm.Dataflow.Label.LabelMap a)
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env (GHC.Cmm.Dataflow.Label.LabelMap a)
instance GHC.Data.TrieMap.TrieMap GHC.Cmm.Dataflow.Label.LabelMap
instance GHC.Cmm.Dataflow.Collections.IsSet GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Show.Show GHC.Cmm.Dataflow.Label.Label
instance GHC.Types.Unique.Uniquable GHC.Cmm.Dataflow.Label.Label
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Dataflow.Label.Label
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.Dataflow.Label.Label


-- | Metaprogramming types
module GHC.Types.Meta

-- | The supported metaprogramming result types
data MetaRequest
MetaE :: (LHsExpr GhcPs -> MetaResult) -> MetaRequest
MetaP :: (LPat GhcPs -> MetaResult) -> MetaRequest
MetaT :: (LHsType GhcPs -> MetaResult) -> MetaRequest
MetaD :: ([LHsDecl GhcPs] -> MetaResult) -> MetaRequest
MetaAW :: (Serialized -> MetaResult) -> MetaRequest
type MetaHook f = MetaRequest -> LHsExpr GhcTc -> f MetaResult

-- | data constructors not exported to ensure correct result type
data MetaResult
metaRequestE :: Functor f => MetaHook f -> LHsExpr GhcTc -> f (LHsExpr GhcPs)
metaRequestP :: Functor f => MetaHook f -> LHsExpr GhcTc -> f (LPat GhcPs)
metaRequestT :: Functor f => MetaHook f -> LHsExpr GhcTc -> f (LHsType GhcPs)
metaRequestD :: Functor f => MetaHook f -> LHsExpr GhcTc -> f [LHsDecl GhcPs]
metaRequestAW :: Functor f => MetaHook f -> LHsExpr GhcTc -> f Serialized

module GHC.Types.IPE

-- | A map storing all the different uses of a specific data constructor
--   and the approximate source position that usage arose from. The
--   <a>Int</a> is an incrementing identifier which distinguishes each
--   usage of a constructor in a module. It is paired with the source
--   position the constructor was used at, if possible and a string which
--   names the source location. This is the same information as is the
--   payload for the <a>SourceNote</a> constructor.
type DCMap = UniqMap DataCon (NonEmpty (Int, Maybe (RealSrcSpan, String)))

-- | A map from a <a>Name</a> to the best approximate source position that
--   name arose from.
type ClosureMap = UniqMap Name (Type, Maybe (RealSrcSpan, String))
data InfoTableProvMap
InfoTableProvMap :: DCMap -> ClosureMap -> InfoTableProvMap
[provDC] :: InfoTableProvMap -> DCMap
[provClosure] :: InfoTableProvMap -> ClosureMap
emptyInfoTableProvMap :: InfoTableProvMap

module GHC.Types.Unique.Map

-- | Maps indexed by <a>Uniquable</a> keys
newtype UniqMap k a
UniqMap :: UniqFM k (k, a) -> UniqMap k a
emptyUniqMap :: UniqMap k a
isNullUniqMap :: UniqMap k a -> Bool
unitUniqMap :: Uniquable k => k -> a -> UniqMap k a
listToUniqMap :: Uniquable k => [(k, a)] -> UniqMap k a
listToUniqMap_C :: Uniquable k => (a -> a -> a) -> [(k, a)] -> UniqMap k a
addToUniqMap :: Uniquable k => UniqMap k a -> k -> a -> UniqMap k a
addListToUniqMap :: Uniquable k => UniqMap k a -> [(k, a)] -> UniqMap k a
addToUniqMap_C :: Uniquable k => (a -> a -> a) -> UniqMap k a -> k -> a -> UniqMap k a
addToUniqMap_Acc :: Uniquable k => (b -> a -> a) -> (b -> a) -> UniqMap k a -> k -> b -> UniqMap k a
alterUniqMap :: Uniquable k => (Maybe a -> Maybe a) -> UniqMap k a -> k -> UniqMap k a
addListToUniqMap_C :: Uniquable k => (a -> a -> a) -> UniqMap k a -> [(k, a)] -> UniqMap k a
adjustUniqMap :: Uniquable k => (a -> a) -> UniqMap k a -> k -> UniqMap k a
delFromUniqMap :: Uniquable k => UniqMap k a -> k -> UniqMap k a
delListFromUniqMap :: Uniquable k => UniqMap k a -> [k] -> UniqMap k a
plusUniqMap :: UniqMap k a -> UniqMap k a -> UniqMap k a
plusUniqMap_C :: (a -> a -> a) -> UniqMap k a -> UniqMap k a -> UniqMap k a
plusMaybeUniqMap_C :: (a -> a -> Maybe a) -> UniqMap k a -> UniqMap k a -> UniqMap k a
plusUniqMapList :: [UniqMap k a] -> UniqMap k a
minusUniqMap :: UniqMap k a -> UniqMap k b -> UniqMap k a
intersectUniqMap :: UniqMap k a -> UniqMap k b -> UniqMap k a
disjointUniqMap :: UniqMap k a -> UniqMap k b -> Bool
mapUniqMap :: (a -> b) -> UniqMap k a -> UniqMap k b
filterUniqMap :: (a -> Bool) -> UniqMap k a -> UniqMap k a
partitionUniqMap :: (a -> Bool) -> UniqMap k a -> (UniqMap k a, UniqMap k a)
sizeUniqMap :: UniqMap k a -> Int
elemUniqMap :: Uniquable k => k -> UniqMap k a -> Bool
lookupUniqMap :: Uniquable k => UniqMap k a -> k -> Maybe a
lookupWithDefaultUniqMap :: Uniquable k => UniqMap k a -> a -> k -> a
anyUniqMap :: (a -> Bool) -> UniqMap k a -> Bool
allUniqMap :: (a -> Bool) -> UniqMap k a -> Bool
instance GHC.Base.Functor (GHC.Types.Unique.Map.UniqMap k)
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (GHC.Types.Unique.Map.UniqMap k a)
instance (Data.Data.Data k, Data.Data.Data a) => Data.Data.Data (GHC.Types.Unique.Map.UniqMap k a)
instance GHC.Base.Semigroup (GHC.Types.Unique.Map.UniqMap k a)
instance GHC.Base.Monoid (GHC.Types.Unique.Map.UniqMap k a)
instance (GHC.Utils.Outputable.Outputable k, GHC.Utils.Outputable.Outputable a) => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.Map.UniqMap k a)


-- | Foreign export stubs
module GHC.Types.ForeignStubs

-- | Foreign export stubs
data ForeignStubs

-- | We don't have any stubs
NoStubs :: ForeignStubs

-- | There are some stubs. Parameters:
--   
--   1) Header file prototypes for "foreign exported" functions
--   
--   2) C stubs to use when calling "foreign exported" functions
ForeignStubs :: CHeader -> CStub -> ForeignStubs
newtype CHeader
CHeader :: SDoc -> CHeader
[getCHeader] :: CHeader -> SDoc
newtype CStub
CStub :: SDoc -> CStub
[getCStub] :: CStub -> SDoc
appendStubC :: ForeignStubs -> CStub -> ForeignStubs
instance GHC.Base.Semigroup GHC.Types.ForeignStubs.CHeader
instance GHC.Base.Monoid GHC.Types.ForeignStubs.CHeader
instance GHC.Base.Monoid GHC.Types.ForeignStubs.CStub
instance GHC.Base.Semigroup GHC.Types.ForeignStubs.CStub

module GHC.StgToCmm.Types

-- | Codegen-generated Id infos, to be passed to downstream via interfaces.
--   
--   This stuff is for optimization purposes only, they're not compulsory.
--   
--   <ul>
--   <li>When CafInfo of an imported Id is not known it's safe to treat it
--   as CAFFY.</li>
--   <li>When LambdaFormInfo of an imported Id is not known it's safe to
--   treat it as `LFUnknown True` (which just says "it could be anything"
--   and we do slow entry).</li>
--   </ul>
--   
--   See also Note [Conveying CAF-info and LFInfo between modules] above.
data CgInfos
CgInfos :: !NonCaffySet -> !ModuleLFInfos -> !CStub -> CgInfos

-- | Exported Non-CAFFY closures in the current module. Everything else is
--   either not exported of CAFFY.
[cgNonCafs] :: CgInfos -> !NonCaffySet

-- | LambdaFormInfos of exported closures in the current module.
[cgLFInfos] :: CgInfos -> !ModuleLFInfos

-- | The C stub which is used for IPE information
[cgIPEStub] :: CgInfos -> !CStub

-- | Information about an identifier, from the code generator's point of
--   view. Every identifier is bound to a LambdaFormInfo in the
--   environment, which gives the code generator enough info to be able to
--   tail call or return that identifier.
data LambdaFormInfo
LFReEntrant :: !TopLevelFlag -> !RepArity -> !Bool -> !ArgDescr -> LambdaFormInfo
LFThunk :: !TopLevelFlag -> !Bool -> !Bool -> !StandardFormInfo -> !Bool -> LambdaFormInfo
LFCon :: !DataCon -> LambdaFormInfo
LFUnknown :: !Bool -> LambdaFormInfo
LFUnlifted :: LambdaFormInfo
LFLetNoEscape :: LambdaFormInfo

-- | Maps names in the current module to their LambdaFormInfos
type ModuleLFInfos = NameEnv LambdaFormInfo

-- | We represent liveness bitmaps as a Bitmap (whose internal
--   representation really is a bitmap). These are pinned onto case return
--   vectors to indicate the state of the stack for the garbage collector.
--   
--   In the compiled program, liveness bitmaps that fit inside a single
--   word (StgWord) are stored as a single word, while larger bitmaps are
--   stored as a pointer to an array of words.
type Liveness = [Bool]

-- | An ArgDescr describes the argument pattern of a function
data ArgDescr
ArgSpec :: !Int -> ArgDescr
ArgGen :: Liveness -> ArgDescr
ArgUnknown :: ArgDescr

-- | StandardFormInfo tells whether this thunk has one of a small number of
--   standard forms
data StandardFormInfo
NonStandardThunk :: StandardFormInfo
SelectorThunk :: !WordOff -> StandardFormInfo
ApThunk :: !RepArity -> StandardFormInfo

-- | Word offset, or word count
type WordOff = Int
instance GHC.Classes.Eq GHC.StgToCmm.Types.ArgDescr
instance GHC.Classes.Eq GHC.StgToCmm.Types.StandardFormInfo
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Types.LambdaFormInfo
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Types.StandardFormInfo
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Types.ArgDescr

module GHC.Stg.Syntax
data StgArg
StgVarArg :: Id -> StgArg
StgLitArg :: Literal -> StgArg

-- | A top-level binding.
data GenStgTopBinding pass
StgTopLifted :: GenStgBinding pass -> GenStgTopBinding pass
StgTopStringLit :: Id -> ByteString -> GenStgTopBinding pass
data GenStgBinding pass
StgNonRec :: BinderP pass -> GenStgRhs pass -> GenStgBinding pass
StgRec :: [(BinderP pass, GenStgRhs pass)] -> GenStgBinding pass
data GenStgExpr pass
StgApp :: Id -> [StgArg] -> GenStgExpr pass
StgLit :: Literal -> GenStgExpr pass
StgConApp :: DataCon -> XConApp pass -> [StgArg] -> [Type] -> GenStgExpr pass
StgOpApp :: StgOp -> [StgArg] -> Type -> GenStgExpr pass
StgCase :: GenStgExpr pass -> BinderP pass -> AltType -> [GenStgAlt pass] -> GenStgExpr pass
StgLet :: XLet pass -> GenStgBinding pass -> GenStgExpr pass -> GenStgExpr pass
StgLetNoEscape :: XLetNoEscape pass -> GenStgBinding pass -> GenStgExpr pass -> GenStgExpr pass
StgTick :: StgTickish -> GenStgExpr pass -> GenStgExpr pass
data GenStgRhs pass
StgRhsClosure :: XRhsClosure pass -> CostCentreStack -> !UpdateFlag -> [BinderP pass] -> GenStgExpr pass -> GenStgRhs pass
StgRhsCon :: CostCentreStack -> DataCon -> ConstructorNumber -> [StgTickish] -> [StgArg] -> GenStgRhs pass
type GenStgAlt pass = (AltCon, [BinderP pass], GenStgExpr pass)
data AltType
PolyAlt :: AltType
MultiValAlt :: Int -> AltType
AlgAlt :: TyCon -> AltType
PrimAlt :: PrimRep -> AltType

-- | Used as a data type index for the stgSyn AST
data StgPass
Vanilla :: StgPass
LiftLams :: StgPass
CodeGen :: StgPass
type family BinderP (pass :: StgPass)
type family XRhsClosure (pass :: StgPass)
type family XLet (pass :: StgPass)
type family XLetNoEscape (pass :: StgPass)
type family XConApp (pass :: StgPass)

-- | Like <a>NoExtField</a>, but with an <a>Outputable</a> instance that
--   returns <a>empty</a>.
data NoExtFieldSilent

-- | Used when constructing a term with an unused extension point that
--   should not appear in pretty-printed output at all.
noExtFieldSilent :: NoExtFieldSilent
type OutputablePass pass = (Outputable (XLet pass), Outputable (XConApp pass), Outputable (XLetNoEscape pass), Outputable (XRhsClosure pass), OutputableBndr (BinderP pass))
data UpdateFlag
ReEntrant :: UpdateFlag
Updatable :: UpdateFlag
SingleEntry :: UpdateFlag
isUpdatable :: UpdateFlag -> Bool

-- | When `-fdistinct-constructor-tables` is turned on then each usage of a
--   constructor is given an unique number and an info table is generated
--   for each different constructor.
data ConstructorNumber
NoNumber :: ConstructorNumber
Numbered :: Int -> ConstructorNumber
type StgTopBinding = GenStgTopBinding 'Vanilla
type StgBinding = GenStgBinding 'Vanilla
type StgExpr = GenStgExpr 'Vanilla
type StgRhs = GenStgRhs 'Vanilla
type StgAlt = GenStgAlt 'Vanilla
type CgStgTopBinding = GenStgTopBinding 'CodeGen
type CgStgBinding = GenStgBinding 'CodeGen
type CgStgExpr = GenStgExpr 'CodeGen
type CgStgRhs = GenStgRhs 'CodeGen
type CgStgAlt = GenStgAlt 'CodeGen
type LlStgTopBinding = GenStgTopBinding 'LiftLams
type LlStgBinding = GenStgBinding 'LiftLams
type LlStgExpr = GenStgExpr 'LiftLams
type LlStgRhs = GenStgRhs 'LiftLams
type LlStgAlt = GenStgAlt 'LiftLams
type InStgArg = StgArg
type InStgTopBinding = StgTopBinding
type InStgBinding = StgBinding
type InStgExpr = StgExpr
type InStgRhs = StgRhs
type InStgAlt = StgAlt
type OutStgArg = StgArg
type OutStgTopBinding = StgTopBinding
type OutStgBinding = StgBinding
type OutStgExpr = StgExpr
type OutStgRhs = StgRhs
type OutStgAlt = StgAlt
data StgOp
StgPrimOp :: PrimOp -> StgOp
StgPrimCallOp :: PrimCall -> StgOp
StgFCallOp :: ForeignCall -> Type -> StgOp
stgRhsArity :: StgRhs -> Int
freeVarsOfRhs :: XRhsClosure pass ~ DIdSet => GenStgRhs pass -> DIdSet

-- | Does this constructor application refer to anything in a different
--   *Windows* DLL? If so, we can't allocate it statically
isDllConApp :: DynFlags -> Module -> DataCon -> [StgArg] -> Bool

-- | Type of an <tt>StgArg</tt>
--   
--   Very half baked because we have lost the type arguments.
stgArgType :: StgArg -> Type

-- | Strip ticks of a given type from an STG expression.
stripStgTicksTop :: (StgTickish -> Bool) -> GenStgExpr p -> ([StgTickish], GenStgExpr p)

-- | Strip ticks of a given type from an STG expression returning only the
--   expression.
stripStgTicksTopE :: (StgTickish -> Bool) -> GenStgExpr p -> GenStgExpr p

-- | Given an alt type and whether the program is unarised, return whether
--   the case binder is in scope.
--   
--   Case binders of unboxed tuple or unboxed sum type always dead after
--   the unariser has run. See Note [Post-unarisation invariants].
stgCaseBndrInScope :: AltType -> Bool -> Bool
bindersOf :: BinderP a ~ Id => GenStgBinding a -> [Id]
bindersOfTop :: BinderP a ~ Id => GenStgTopBinding a -> [Id]
bindersOfTopBinds :: BinderP a ~ Id => [GenStgTopBinding a] -> [Id]

-- | STG pretty-printing options
data StgPprOpts
StgPprOpts :: !Bool -> StgPprOpts

-- | Enable cost-centres
[stgSccEnabled] :: StgPprOpts -> !Bool

-- | Initialize STG pretty-printing options from DynFlags
initStgPprOpts :: DynFlags -> StgPprOpts

-- | STG pretty-printing options used for panic messages
panicStgPprOpts :: StgPprOpts

-- | STG pretty-printing options used for short messages
shortStgPprOpts :: StgPprOpts
pprStgArg :: StgArg -> SDoc
pprStgExpr :: OutputablePass pass => StgPprOpts -> GenStgExpr pass -> SDoc
pprStgRhs :: OutputablePass pass => StgPprOpts -> GenStgRhs pass -> SDoc
pprStgBinding :: StgPprOpts -> StgBinding -> SDoc
pprGenStgTopBinding :: OutputablePass pass => StgPprOpts -> GenStgTopBinding pass -> SDoc
pprStgTopBinding :: StgPprOpts -> StgTopBinding -> SDoc
pprGenStgTopBindings :: OutputablePass pass => StgPprOpts -> [GenStgTopBinding pass] -> SDoc
pprStgTopBindings :: StgPprOpts -> [StgTopBinding] -> SDoc
instance GHC.Classes.Ord GHC.Stg.Syntax.NoExtFieldSilent
instance GHC.Classes.Eq GHC.Stg.Syntax.NoExtFieldSilent
instance Data.Data.Data GHC.Stg.Syntax.NoExtFieldSilent
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.UpdateFlag
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.AltType
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.ConstructorNumber
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.NoExtFieldSilent
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.StgArg


-- | The CompPipeline monad and associated ops
--   
--   Defined in separate module so that it can safely be imported from
--   Hooks
module GHC.Driver.Pipeline.Monad
newtype CompPipeline a
P :: (PipeEnv -> PipeState -> IO (PipeState, a)) -> CompPipeline a
[unP] :: CompPipeline a -> PipeEnv -> PipeState -> IO (PipeState, a)
evalP :: CompPipeline a -> PipeEnv -> PipeState -> IO (PipeState, a)
data PhasePlus
RealPhase :: Phase -> PhasePlus
HscOut :: HscSource -> ModuleName -> HscStatus -> PhasePlus
data PipeEnv
PipeEnv :: Phase -> String -> String -> String -> PipelineOutput -> PipeEnv

-- | Stop just before this phase
[stop_phase] :: PipeEnv -> Phase

-- | basename of original input source
[src_filename] :: PipeEnv -> String

-- | basename of original input source
[src_basename] :: PipeEnv -> String

-- | its extension
[src_suffix] :: PipeEnv -> String

-- | says where to put the pipeline output
[output_spec] :: PipeEnv -> PipelineOutput
data PipeState
PipeState :: HscEnv -> Maybe ModLocation -> [FilePath] -> Maybe ModIface -> PipeState

-- | only the DynFlags and the Plugins change in the HscEnv. The DynFlags
--   change at various points, for example when we read the OPTIONS_GHC
--   pragmas in the Cpp phase.
[hsc_env] :: PipeState -> HscEnv

-- | the ModLocation. This is discovered during compilation, in the Hsc
--   phase where we read the module header.
[maybe_loc] :: PipeState -> Maybe ModLocation

-- | additional object files resulting from compiling foreign code. They
--   come from two sources: foreign stubs, and add{C,Cxx,Objc,Objcxx}File
--   from template haskell
[foreign_os] :: PipeState -> [FilePath]

-- | Interface generated by HscOut phase. Only available after the phase
--   runs.
[iface] :: PipeState -> Maybe ModIface
data PipelineOutput

-- | Output should be to a temporary file: we're going to run more
--   compilation steps on this output later.
Temporary :: TempFileLifetime -> PipelineOutput

-- | We want a persistent file, i.e. a file in the current directory
--   derived from the input filename, but with the appropriate extension.
--   eg. in "ghc -c Foo.hs" the output goes into ./Foo.o.
Persistent :: PipelineOutput

-- | The output must go into the specific outputFile in DynFlags. We don't
--   store the filename in the constructor as it changes when doing
--   -dynamic-too.
SpecificFile :: PipelineOutput
getPipeEnv :: CompPipeline PipeEnv
getPipeState :: CompPipeline PipeState
getPipeSession :: CompPipeline HscEnv
setDynFlags :: DynFlags -> CompPipeline ()
setModLocation :: ModLocation -> CompPipeline ()
setForeignOs :: [FilePath] -> CompPipeline ()
setIface :: ModIface -> CompPipeline ()
pipeStateDynFlags :: PipeState -> DynFlags
pipeStateModIface :: PipeState -> Maybe ModIface
setPlugins :: [LoadedPlugin] -> [StaticPlugin] -> CompPipeline ()
instance GHC.Show.Show GHC.Driver.Pipeline.Monad.PipelineOutput
instance GHC.Base.Functor GHC.Driver.Pipeline.Monad.CompPipeline
instance GHC.Base.Applicative GHC.Driver.Pipeline.Monad.CompPipeline
instance GHC.Base.Monad GHC.Driver.Pipeline.Monad.CompPipeline
instance Control.Monad.IO.Class.MonadIO GHC.Driver.Pipeline.Monad.CompPipeline
instance GHC.Driver.Session.HasDynFlags GHC.Driver.Pipeline.Monad.CompPipeline
instance GHC.Utils.Logger.HasLogger GHC.Driver.Pipeline.Monad.CompPipeline
instance GHC.Utils.Outputable.Outputable GHC.Driver.Pipeline.Monad.PhasePlus


-- | Temporary file-system management
module GHC.Utils.TmpFs

-- | Temporary file-system
data TmpFs

-- | Initialise an empty TmpFs
initTmpFs :: IO TmpFs

-- | Initialise an empty TmpFs sharing unique numbers and per-process
--   temporary directories with the given TmpFs
forkTmpFsFrom :: TmpFs -> IO TmpFs

-- | Merge the first TmpFs into the second.
--   
--   The first TmpFs is returned emptied.
mergeTmpFsInto :: TmpFs -> TmpFs -> IO ()

-- | A collection of files that must be deleted before ghc exits.
data FilesToClean
FilesToClean :: !Set FilePath -> !Set FilePath -> FilesToClean

-- | Files that will be deleted at the end of runGhc(T)
[ftcGhcSession] :: FilesToClean -> !Set FilePath

-- | Files that will be deleted the next time
--   <a>cleanCurrentModuleTempFiles</a> is called, or otherwise at the end
--   of the session.
[ftcCurrentModule] :: FilesToClean -> !Set FilePath

-- | An empty FilesToClean
emptyFilesToClean :: FilesToClean

-- | Used when a temp file is created. This determines which component Set
--   of FilesToClean will get the temp file
data TempFileLifetime

-- | A file with lifetime TFL_CurrentModule will be cleaned up at the end
--   of upweep_mod
TFL_CurrentModule :: TempFileLifetime

-- | A file with lifetime TFL_GhcSession will be cleaned up at the end of
--   runGhc(T)
TFL_GhcSession :: TempFileLifetime
cleanTempDirs :: Logger -> TmpFs -> DynFlags -> IO ()

-- | Delete all files in <tt>tmp_files_to_clean</tt>.
cleanTempFiles :: Logger -> TmpFs -> DynFlags -> IO ()

-- | Delete all files in <tt>tmp_files_to_clean</tt>. That have lifetime
--   TFL_CurrentModule. If a file must be cleaned eventually, but must
--   survive a cleanCurrentModuleTempFiles, ensure it has lifetime
--   TFL_GhcSession.
cleanCurrentModuleTempFiles :: Logger -> TmpFs -> DynFlags -> IO ()

-- | Ensure that new_files are cleaned on the next call of
--   <a>cleanTempFiles</a> or <a>cleanCurrentModuleTempFiles</a>, depending
--   on lifetime. If any of new_files are already tracked, they will have
--   their lifetime updated.
addFilesToClean :: TmpFs -> TempFileLifetime -> [FilePath] -> IO ()

-- | Update the lifetime of files already being tracked. If any files are
--   not being tracked they will be discarded.
changeTempFilesLifetime :: TmpFs -> TempFileLifetime -> [FilePath] -> IO ()
newTempName :: Logger -> TmpFs -> DynFlags -> TempFileLifetime -> Suffix -> IO FilePath
newTempLibName :: Logger -> TmpFs -> DynFlags -> TempFileLifetime -> Suffix -> IO (FilePath, FilePath, String)
newTempDir :: Logger -> TmpFs -> DynFlags -> IO FilePath

-- | Create and use a temporary directory in the system standard temporary
--   directory.
--   
--   Behaves exactly the same as <a>withTempDirectory</a>, except that the
--   parent temporary directory will be that returned by
--   <a>getTemporaryDirectory</a>.
withSystemTempDirectory :: String -> (FilePath -> IO a) -> IO a

-- | Create and use a temporary directory.
--   
--   Creates a new temporary directory inside the given directory, making
--   use of the template. The temp directory is deleted after use. For
--   example:
--   
--   <pre>
--   withTempDirectory "src" "sdist." $ \tmpDir -&gt; do ...
--   </pre>
--   
--   The <tt>tmpDir</tt> will be a new subdirectory of the given directory,
--   e.g. <tt>src/sdist.342</tt>.
withTempDirectory :: FilePath -> String -> (FilePath -> IO a) -> IO a
instance GHC.Show.Show GHC.Utils.TmpFs.TempFileLifetime

module GHC.Unit.Module.Status

-- | Status of a module compilation to machine code
data HscStatus

-- | Nothing to do.
HscNotGeneratingCode :: ModIface -> ModDetails -> HscStatus

-- | Nothing to do because code already exists.
HscUpToDate :: ModIface -> ModDetails -> HscStatus

-- | Update boot file result.
HscUpdateBoot :: ModIface -> ModDetails -> HscStatus

-- | Generate signature file (backpack)
HscUpdateSig :: ModIface -> ModDetails -> HscStatus

-- | Recompile this module.
HscRecomp :: CgGuts -> !ModLocation -> !PartialModIface -> !Maybe Fingerprint -> HscStatus

-- | Information for the code generator.
[hscs_guts] :: HscStatus -> CgGuts

-- | Module info
[hscs_mod_location] :: HscStatus -> !ModLocation

-- | Partial interface
[hscs_partial_iface] :: HscStatus -> !PartialModIface

-- | Old interface hash for this compilation, if an old interface file
--   exists. Pass to <tt>hscMaybeWriteIface</tt> when writing the interface
--   to avoid updating the existing interface when the interface isn't
--   changed.
[hscs_old_iface_hash] :: HscStatus -> !Maybe Fingerprint

module GHC.Unit.Module.ModGuts

-- | A ModGuts is carried through the compiler, accumulating stuff as it
--   goes There is only one ModGuts at any time, the one for the module
--   being compiled right now. Once it is compiled, a <tt>ModIface</tt> and
--   <tt>ModDetails</tt> are extracted and the ModGuts is discarded.
data ModGuts
ModGuts :: !Module -> HscSource -> SrcSpan -> ![AvailInfo] -> !Dependencies -> ![Usage] -> !Bool -> !GlobalRdrEnv -> !FixityEnv -> ![TyCon] -> ![ClsInst] -> ![FamInst] -> ![PatSyn] -> ![CoreRule] -> !CoreProgram -> !ForeignStubs -> ![(ForeignSrcLang, FilePath)] -> !Warnings -> [Annotation] -> [CompleteMatch] -> !HpcInfo -> !Maybe ModBreaks -> InstEnv -> FamInstEnv -> SafeHaskellMode -> Bool -> !Maybe HsDocString -> !DeclDocMap -> !ArgDocMap -> ModGuts

-- | Module being compiled
[mg_module] :: ModGuts -> !Module

-- | Whether it's an hs-boot module
[mg_hsc_src] :: ModGuts -> HscSource

-- | For error messages from inner passes
[mg_loc] :: ModGuts -> SrcSpan

-- | What it exports
[mg_exports] :: ModGuts -> ![AvailInfo]

-- | What it depends on, directly or otherwise
[mg_deps] :: ModGuts -> !Dependencies

-- | What was used? Used for interfaces.
[mg_usages] :: ModGuts -> ![Usage]

-- | Did we run a TH splice?
[mg_used_th] :: ModGuts -> !Bool

-- | Top-level lexical environment
[mg_rdr_env] :: ModGuts -> !GlobalRdrEnv

-- | Fixities declared in this module. Used for creating interface files.
[mg_fix_env] :: ModGuts -> !FixityEnv

-- | TyCons declared in this module (includes TyCons for classes)
[mg_tcs] :: ModGuts -> ![TyCon]

-- | Class instances declared in this module
[mg_insts] :: ModGuts -> ![ClsInst]

-- | Family instances declared in this module
[mg_fam_insts] :: ModGuts -> ![FamInst]

-- | Pattern synonyms declared in this module
[mg_patsyns] :: ModGuts -> ![PatSyn]

-- | Before the core pipeline starts, contains See Note [Overall plumbing
--   for rules] in <a>GHC.Core.Rules</a>
[mg_rules] :: ModGuts -> ![CoreRule]

-- | Bindings for this module
[mg_binds] :: ModGuts -> !CoreProgram

-- | Foreign exports declared in this module
[mg_foreign] :: ModGuts -> !ForeignStubs

-- | Files to be compiled with the C compiler
[mg_foreign_files] :: ModGuts -> ![(ForeignSrcLang, FilePath)]

-- | Warnings declared in the module
[mg_warns] :: ModGuts -> !Warnings

-- | Annotations declared in this module
[mg_anns] :: ModGuts -> [Annotation]

-- | Complete Matches
[mg_complete_matches] :: ModGuts -> [CompleteMatch]

-- | Coverage tick boxes in the module
[mg_hpc_info] :: ModGuts -> !HpcInfo

-- | Breakpoints for the module
[mg_modBreaks] :: ModGuts -> !Maybe ModBreaks

-- | Class instance environment for <i>home-package</i> modules (including
--   this one); c.f. <tt>tcg_inst_env</tt>
[mg_inst_env] :: ModGuts -> InstEnv

-- | Type-family instance environment for <i>home-package</i> modules
--   (including this one); c.f. <tt>tcg_fam_inst_env</tt>
[mg_fam_inst_env] :: ModGuts -> FamInstEnv

-- | Safe Haskell mode
[mg_safe_haskell] :: ModGuts -> SafeHaskellMode

-- | Do we need to trust our own package for Safe Haskell? See Note [Trust
--   Own Package] in <a>GHC.Rename.Names</a>
[mg_trust_pkg] :: ModGuts -> Bool

-- | Module header.
[mg_doc_hdr] :: ModGuts -> !Maybe HsDocString

-- | Docs on declarations.
[mg_decl_docs] :: ModGuts -> !DeclDocMap

-- | Docs on arguments.
[mg_arg_docs] :: ModGuts -> !ArgDocMap

-- | A restricted form of <a>ModGuts</a> for code generation purposes
data CgGuts
CgGuts :: !Module -> [TyCon] -> CoreProgram -> !ForeignStubs -> ![(ForeignSrcLang, FilePath)] -> ![UnitId] -> !HpcInfo -> !Maybe ModBreaks -> [SptEntry] -> CgGuts

-- | Module being compiled
[cg_module] :: CgGuts -> !Module

-- | Algebraic data types (including ones that started life as classes);
--   generate constructors and info tables. Includes newtypes, just for the
--   benefit of External Core
[cg_tycons] :: CgGuts -> [TyCon]

-- | The tidied main bindings, including previously-implicit bindings for
--   record and class selectors, and data constructor wrappers. But *not*
--   data constructor workers; reason: we regard them as part of the
--   code-gen of tycons
[cg_binds] :: CgGuts -> CoreProgram

-- | Foreign export stubs
[cg_foreign] :: CgGuts -> !ForeignStubs
[cg_foreign_files] :: CgGuts -> ![(ForeignSrcLang, FilePath)]

-- | Dependent packages, used to generate #includes for C code gen
[cg_dep_pkgs] :: CgGuts -> ![UnitId]

-- | Program coverage tick box information
[cg_hpc_info] :: CgGuts -> !HpcInfo

-- | Module breakpoints
[cg_modBreaks] :: CgGuts -> !Maybe ModBreaks

-- | Static pointer table entries for static forms defined in the module.
--   See Note [Grand plan for static forms] in
--   <a>GHC.Iface.Tidy.StaticPtrTable</a>
[cg_spt_entries] :: CgGuts -> [SptEntry]


-- | Definitions for writing <i>plugins</i> for GHC. Plugins can hook into
--   several areas of the compiler. See the <a>Plugin</a> type. These
--   plugins include type-checker plugins, source plugins, and core-to-core
--   plugins.
module GHC.Driver.Plugins

-- | <a>Plugin</a> is the compiler plugin data type. Try to avoid
--   constructing one of these directly, and just modify some fields of
--   <a>defaultPlugin</a> instead: this is to try and preserve source-code
--   compatibility when we add fields to this.
--   
--   Nonetheless, this API is preliminary and highly likely to change in
--   the future.
data Plugin
Plugin :: CorePlugin -> TcPlugin -> HoleFitPlugin -> ([CommandLineOption] -> HscEnv -> IO HscEnv) -> ([CommandLineOption] -> IO PluginRecompile) -> ([CommandLineOption] -> ModSummary -> HsParsedModule -> Hsc HsParsedModule) -> ([CommandLineOption] -> TcGblEnv -> HsGroup GhcRn -> TcM (TcGblEnv, HsGroup GhcRn)) -> ([CommandLineOption] -> ModSummary -> TcGblEnv -> TcM TcGblEnv) -> ([CommandLineOption] -> LHsExpr GhcTc -> TcM (LHsExpr GhcTc)) -> (forall lcl. [CommandLineOption] -> ModIface -> IfM lcl ModIface) -> Plugin

-- | Modify the Core pipeline that will be used for compilation. This is
--   called as the Core pipeline is built for every module being compiled,
--   and plugins get the opportunity to modify the pipeline in a
--   nondeterministic order.
[installCoreToDos] :: Plugin -> CorePlugin

-- | An optional typechecker plugin, which may modify the behaviour of the
--   constraint solver.
[tcPlugin] :: Plugin -> TcPlugin

-- | An optional plugin to handle hole fits, which may re-order or change
--   the list of valid hole fits and refinement hole fits.
[holeFitPlugin] :: Plugin -> HoleFitPlugin

-- | An optional plugin to update <a>HscEnv</a>, right after plugin
--   loading. This can be used to register hooks or tweak any field of
--   <tt>DynFlags</tt> before doing actual work on a module.
[driverPlugin] :: Plugin -> [CommandLineOption] -> HscEnv -> IO HscEnv

-- | Specify how the plugin should affect recompilation.
[pluginRecompile] :: Plugin -> [CommandLineOption] -> IO PluginRecompile

-- | Modify the module when it is parsed. This is called by
--   <a>GHC.Driver.Main</a> when the parsing is successful.
[parsedResultAction] :: Plugin -> [CommandLineOption] -> ModSummary -> HsParsedModule -> Hsc HsParsedModule

-- | Modify each group after it is renamed. This is called after each
--   <a>HsGroup</a> has been renamed.
[renamedResultAction] :: Plugin -> [CommandLineOption] -> TcGblEnv -> HsGroup GhcRn -> TcM (TcGblEnv, HsGroup GhcRn)

-- | Modify the module when it is type checked. This is called at the very
--   end of typechecking.
[typeCheckResultAction] :: Plugin -> [CommandLineOption] -> ModSummary -> TcGblEnv -> TcM TcGblEnv

-- | Modify the TH splice or quasiqoute before it is run.
[spliceRunAction] :: Plugin -> [CommandLineOption] -> LHsExpr GhcTc -> TcM (LHsExpr GhcTc)

-- | Modify an interface that have been loaded. This is called by
--   <a>GHC.Iface.Load</a> when an interface is successfully loaded. Not
--   applied to the loading of the plugin interface. Tools that rely on
--   information from modules other than the currently compiled one should
--   implement this function.
[interfaceLoadAction] :: Plugin -> forall lcl. [CommandLineOption] -> ModIface -> IfM lcl ModIface

-- | Default plugin: does nothing at all, except for marking that safe
--   inference has failed unless <tt>-fplugin-trustworthy</tt> is passed.
--   For compatibility reason you should base all your plugin definitions
--   on this default value.
defaultPlugin :: Plugin

-- | Command line options gathered from the -PModule.Name:stuff syntax are
--   given to you as this type
type CommandLineOption = String
purePlugin :: [CommandLineOption] -> IO PluginRecompile
impurePlugin :: [CommandLineOption] -> IO PluginRecompile
flagRecompile :: [CommandLineOption] -> IO PluginRecompile
data PluginRecompile
ForceRecompile :: PluginRecompile
NoForceRecompile :: PluginRecompile
MaybeRecompile :: Fingerprint -> PluginRecompile
data FrontendPlugin
FrontendPlugin :: FrontendPluginAction -> FrontendPlugin
[frontend] :: FrontendPlugin -> FrontendPluginAction
defaultFrontendPlugin :: FrontendPlugin
type FrontendPluginAction = [String] -> [(String, Maybe Phase)] -> Ghc ()
type CorePlugin = [CommandLineOption] -> [CoreToDo] -> CoreM [CoreToDo]
type TcPlugin = [CommandLineOption] -> Maybe TcPlugin

-- | A renamer plugin which mades the renamed source available in a
--   typechecker plugin.
keepRenamedSource :: [CommandLineOption] -> TcGblEnv -> HsGroup GhcRn -> TcM (TcGblEnv, HsGroup GhcRn)

-- | HoleFitPluginR adds a TcRef to hole fit plugins so that plugins can
--   track internal state. Note the existential quantification, ensuring
--   that the state cannot be modified from outside the plugin.
data HoleFitPluginR
data PluginWithArgs
PluginWithArgs :: Plugin -> [CommandLineOption] -> PluginWithArgs

-- | the actual callable plugin
[paPlugin] :: PluginWithArgs -> Plugin

-- | command line arguments for the plugin
[paArguments] :: PluginWithArgs -> [CommandLineOption]
plugins :: HscEnv -> [PluginWithArgs]
pluginRecompile' :: PluginWithArgs -> IO PluginRecompile

-- | A plugin with its arguments. The result of loading the plugin.
data LoadedPlugin
LoadedPlugin :: PluginWithArgs -> ModIface -> LoadedPlugin

-- | the actual plugin together with its commandline arguments
[lpPlugin] :: LoadedPlugin -> PluginWithArgs

-- | the module containing the plugin
[lpModule] :: LoadedPlugin -> ModIface
lpModuleName :: LoadedPlugin -> ModuleName

-- | A static plugin with its arguments. For registering compiled-in
--   plugins through the GHC API.
data StaticPlugin
StaticPlugin :: PluginWithArgs -> StaticPlugin

-- | the actual plugin together with its commandline arguments
[spPlugin] :: StaticPlugin -> PluginWithArgs
mapPlugins :: HscEnv -> (Plugin -> [CommandLineOption] -> a) -> [a]

-- | Perform an operation by using all of the plugins in turn.
withPlugins :: Monad m => HscEnv -> PluginOperation m a -> a -> m a

-- | Perform a constant operation by using all of the plugins in turn.
withPlugins_ :: Monad m => HscEnv -> ConstPluginOperation m a -> a -> m ()
instance GHC.Utils.Outputable.Outputable GHC.Driver.Plugins.PluginRecompile
instance GHC.Base.Semigroup GHC.Driver.Plugins.PluginRecompile
instance GHC.Base.Monoid GHC.Driver.Plugins.PluginRecompile

module GHC.Driver.Monad

-- | A monad that has all the features needed by GHC API calls.
--   
--   In short, a GHC monad
--   
--   <ul>
--   <li>allows embedding of IO actions,</li>
--   <li>can log warnings,</li>
--   <li>allows handling of (extensible) exceptions, and</li>
--   <li>maintains a current session.</li>
--   </ul>
--   
--   If you do not use <a>Ghc</a> or <a>GhcT</a>, make sure to call
--   <a>initGhcMonad</a> before any call to the GHC API functions can
--   occur.
class (Functor m, ExceptionMonad m, HasDynFlags m, HasLogger m) => GhcMonad m
getSession :: GhcMonad m => m HscEnv
setSession :: GhcMonad m => HscEnv -> m ()

-- | A minimal implementation of a <a>GhcMonad</a>. If you need a custom
--   monad, e.g., to maintain additional state consider wrapping this monad
--   or using <a>GhcT</a>.
newtype Ghc a
Ghc :: (Session -> IO a) -> Ghc a
[unGhc] :: Ghc a -> Session -> IO a

-- | A monad transformer to add GHC specific features to another monad.
--   
--   Note that the wrapped monad must support IO and handling of
--   exceptions.
newtype GhcT m a
GhcT :: (Session -> m a) -> GhcT m a
[unGhcT] :: GhcT m a -> Session -> m a
liftGhcT :: m a -> GhcT m a

-- | Reflect a computation in the <a>Ghc</a> monad into the <a>IO</a>
--   monad.
--   
--   You can use this to call functions returning an action in the
--   <a>Ghc</a> monad inside an <a>IO</a> action. This is needed for some
--   (too restrictive) callback arguments of some library functions:
--   
--   <pre>
--   libFunc :: String -&gt; (Int -&gt; IO a) -&gt; IO a
--   ghcFunc :: Int -&gt; Ghc a
--   
--   ghcFuncUsingLibFunc :: String -&gt; Ghc a -&gt; Ghc a
--   ghcFuncUsingLibFunc str =
--     reifyGhc $ \s -&gt;
--       libFunc $ \i -&gt; do
--         reflectGhc (ghcFunc i) s
--   </pre>
reflectGhc :: Ghc a -> Session -> IO a
reifyGhc :: (Session -> IO a) -> Ghc a

-- | Grabs the DynFlags from the Session
getSessionDynFlags :: GhcMonad m => m DynFlags

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   â¢ Couldn't match type âIOâ with âStateT s IOâ
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a

-- | The Session is a handle to the complete state of a compilation
--   session. A compilation session consists of a set of modules
--   constituting the current program or library, the context for
--   interactive evaluation, and various caches.
data Session
Session :: !IORef HscEnv -> Session

-- | Call the argument with the current session.
withSession :: GhcMonad m => (HscEnv -> m a) -> m a

-- | Set the current session to the result of applying the current session
--   to the argument.
modifySession :: GhcMonad m => (HscEnv -> HscEnv) -> m ()

-- | Set the current session to the result of applying the current session
--   to the argument.
modifySessionM :: GhcMonad m => (HscEnv -> m HscEnv) -> m ()

-- | Call an action with a temporarily modified Session.
withTempSession :: GhcMonad m => (HscEnv -> HscEnv) -> m a -> m a

-- | Modify the logger
modifyLogger :: GhcMonad m => (Logger -> Logger) -> m ()

-- | Push a log hook on the stack
pushLogHookM :: GhcMonad m => (LogAction -> LogAction) -> m ()

-- | Pop a log hook from the stack
popLogHookM :: GhcMonad m => m ()

-- | Put a log message
putLogMsgM :: GhcMonad m => WarnReason -> Severity -> SrcSpan -> SDoc -> m ()

-- | Put a log message
putMsgM :: GhcMonad m => SDoc -> m ()

-- | Time an action
withTimingM :: GhcMonad m => SDoc -> (b -> ()) -> m b -> m b

-- | A monad that allows logging of warnings.
logWarnings :: GhcMonad m => WarningMessages -> m ()

-- | Print the error message and all warnings. Useful inside exception
--   handlers. Clears warnings after printing.
printException :: GhcMonad m => SourceError -> m ()

-- | A function called to log warnings and errors.
type WarnErrLogger = forall m. GhcMonad m => Maybe SourceError -> m ()
defaultWarnErrLogger :: WarnErrLogger
instance Control.Monad.Catch.MonadMask GHC.Driver.Monad.Ghc
instance Control.Monad.Catch.MonadCatch GHC.Driver.Monad.Ghc
instance Control.Monad.Catch.MonadThrow GHC.Driver.Monad.Ghc
instance GHC.Base.Functor GHC.Driver.Monad.Ghc
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (GHC.Driver.Monad.GhcT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (GHC.Driver.Monad.GhcT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (GHC.Driver.Monad.GhcT m)
instance GHC.Base.Functor m => GHC.Base.Functor (GHC.Driver.Monad.GhcT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (GHC.Driver.Monad.GhcT m)
instance GHC.Base.Monad m => GHC.Base.Monad (GHC.Driver.Monad.GhcT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (GHC.Driver.Monad.GhcT m)
instance Control.Monad.IO.Class.MonadIO m => GHC.Driver.Session.HasDynFlags (GHC.Driver.Monad.GhcT m)
instance Control.Monad.IO.Class.MonadIO m => GHC.Utils.Logger.HasLogger (GHC.Driver.Monad.GhcT m)
instance GHC.Utils.Exception.ExceptionMonad m => GHC.Driver.Monad.GhcMonad (GHC.Driver.Monad.GhcT m)
instance GHC.Base.Applicative GHC.Driver.Monad.Ghc
instance GHC.Base.Monad GHC.Driver.Monad.Ghc
instance Control.Monad.IO.Class.MonadIO GHC.Driver.Monad.Ghc
instance Control.Monad.Fix.MonadFix GHC.Driver.Monad.Ghc
instance GHC.Driver.Session.HasDynFlags GHC.Driver.Monad.Ghc
instance GHC.Utils.Logger.HasLogger GHC.Driver.Monad.Ghc
instance GHC.Driver.Monad.GhcMonad GHC.Driver.Monad.Ghc


-- | Source errors
module GHC.Types.SourceError

-- | A source error is an error that is caused by one or more errors in the
--   source code. A <a>SourceError</a> is thrown by many functions in the
--   compilation pipeline. Inside GHC these errors are merely printed via
--   <tt>log_action</tt>, but API clients may treat them differently, for
--   example, insert them into a list box. If you want the default
--   behaviour, use the idiom:
--   
--   <pre>
--   handleSourceError printExceptionAndWarnings $ do
--     ... api calls that may fail ...
--   </pre>
--   
--   The <a>SourceError</a>s error messages can be accessed via
--   <a>srcErrorMessages</a>. This list may be empty if the compiler failed
--   due to <tt>-Werror</tt> (<tt>Opt_WarnIsError</tt>).
--   
--   See <tt>printExceptionAndWarnings</tt> for more information on what to
--   take care of when writing a custom error handler.
newtype SourceError
SourceError :: ErrorMessages -> SourceError
mkSrcErr :: ErrorMessages -> SourceError
srcErrorMessages :: SourceError -> ErrorMessages
throwErrors :: MonadIO io => ErrorMessages -> io a
throwOneError :: MonadIO io => MsgEnvelope DecoratedSDoc -> io a

-- | Perform the given action and call the exception handler if the action
--   throws a <a>SourceError</a>. See <a>SourceError</a> for more
--   information.
handleSourceError :: MonadCatch m => (SourceError -> m a) -> m a -> m a
instance GHC.Show.Show GHC.Types.SourceError.SourceError
instance GHC.Exception.Type.Exception GHC.Types.SourceError.SourceError

module GHC.Driver.Errors

-- | Converts a list of <a>WarningMessages</a> into a tuple where the
--   second element contains only error, i.e. warnings that are considered
--   fatal by GHC based on the input <a>DynFlags</a>.
warningsToMessages :: DynFlags -> WarningMessages -> (WarningMessages, ErrorMessages)

-- | Given a bag of warnings, turn them into an exception if -Werror is
--   enabled, or print them out otherwise.
printOrThrowWarnings :: Logger -> DynFlags -> Bag WarnMsg -> IO ()
printBagOfErrors :: RenderableDiagnostic a => Logger -> DynFlags -> Bag (MsgEnvelope a) -> IO ()

-- | Checks if given <a>WarnMsg</a> is a fatal warning.
isWarnMsgFatal :: DynFlags -> WarnMsg -> Maybe (Maybe WarningFlag)
handleFlagWarnings :: Logger -> DynFlags -> [Warn] -> IO ()

module GHC.Driver.Env

-- | The Hsc monad: Passing an environment and warning state
newtype Hsc a
Hsc :: (HscEnv -> WarningMessages -> IO (a, WarningMessages)) -> Hsc a

-- | HscEnv is like <a>Session</a>, except that some of the fields are
--   immutable. An HscEnv is used to compile a single module from plain
--   Haskell source code (after preprocessing) to either C, assembly or
--   C--. It's also used to store the dynamic linker state to allow for
--   multiple linkers in the same address space. Things like the module
--   graph don't change during a single compilation.
--   
--   Historical note: "hsc" used to be the name of the compiler binary,
--   when there was a separate driver and compiler. To compile a single
--   module, the driver would invoke hsc on the source code... so nowadays
--   we think of hsc as the layer of the compiler that deals with compiling
--   a single module.
data HscEnv
HscEnv :: DynFlags -> [Target] -> ModuleGraph -> InteractiveContext -> HomePackageTable -> {-# UNPACK #-} !IORef ExternalPackageState -> {-# UNPACK #-} !IORef NameCache -> {-# UNPACK #-} !IORef FinderCache -> Maybe (Module, IORef TypeEnv) -> Maybe Interp -> ![LoadedPlugin] -> ![StaticPlugin] -> !Maybe [UnitDatabase UnitId] -> UnitEnv -> !Logger -> !Hooks -> !TmpFs -> HscEnv

-- | The dynamic flag settings
[hsc_dflags] :: HscEnv -> DynFlags

-- | The targets (or roots) of the current session
[hsc_targets] :: HscEnv -> [Target]

-- | The module graph of the current session
[hsc_mod_graph] :: HscEnv -> ModuleGraph

-- | The context for evaluating interactive statements
[hsc_IC] :: HscEnv -> InteractiveContext

-- | The home package table describes already-compiled home-package
--   modules, <i>excluding</i> the module we are compiling right now. (In
--   one-shot mode the current module is the only home-package module, so
--   hsc_HPT is empty. All other modules count as "external-package"
--   modules. However, even in GHCi mode, hi-boot interfaces are
--   demand-loaded into the external-package table.)
--   
--   <a>hsc_HPT</a> is not mutable because we only demand-load external
--   packages; the home package is eagerly loaded, module by module, by the
--   compilation manager.
--   
--   The HPT may contain modules compiled earlier by <tt>--make</tt> but
--   not actually below the current module in the dependency graph.
--   
--   (This changes a previous invariant: changed Jan 05.)
[hsc_HPT] :: HscEnv -> HomePackageTable

-- | Information about the currently loaded external packages. This is
--   mutable because packages will be demand-loaded during a compilation
--   run as required.
[hsc_EPS] :: HscEnv -> {-# UNPACK #-} !IORef ExternalPackageState

-- | As with <a>hsc_EPS</a>, this is side-effected by compiling to reflect
--   sucking in interface files. They cache the state of external interface
--   files, in effect.
[hsc_NC] :: HscEnv -> {-# UNPACK #-} !IORef NameCache

-- | The cached result of performing finding in the file system
[hsc_FC] :: HscEnv -> {-# UNPACK #-} !IORef FinderCache

-- | Used for one-shot compilation only, to initialise the
--   <tt>IfGblEnv</tt>. See <a>tcg_type_env_var</a> for <a>TcGblEnv</a>.
--   See also Note [hsc_type_env_var hack]
[hsc_type_env_var] :: HscEnv -> Maybe (Module, IORef TypeEnv)

-- | target code interpreter (if any) to use for TH and GHCi. See Note
--   [Target code interpreter]
[hsc_interp] :: HscEnv -> Maybe Interp

-- | plugins dynamically loaded after processing arguments. What will be
--   loaded here is directed by DynFlags.pluginModNames. Arguments are
--   loaded from DynFlags.pluginModNameOpts.
--   
--   The purpose of this field is to cache the plugins so they don't have
--   to be loaded each time they are needed. See <a>initializePlugins</a>.
[hsc_plugins] :: HscEnv -> ![LoadedPlugin]

-- | static plugins which do not need dynamic loading. These plugins are
--   intended to be added by GHC API users directly to this list.
--   
--   To add dynamically loaded plugins through the GHC API see
--   <tt>addPluginModuleName</tt> instead.
[hsc_static_plugins] :: HscEnv -> ![StaticPlugin]

-- | Stack of unit databases for the target platform.
--   
--   This field is populated with the result of <a>initUnits</a>.
--   
--   <a>Nothing</a> means the databases have never been read from disk.
--   
--   Usually we don't reload the databases from disk if they are cached,
--   even if the database flags changed!
[hsc_unit_dbs] :: HscEnv -> !Maybe [UnitDatabase UnitId]

-- | Unit environment (unit state, home unit, etc.).
--   
--   Initialized from the databases cached in <a>hsc_unit_dbs</a> and from
--   the DynFlags.
[hsc_unit_env] :: HscEnv -> UnitEnv

-- | Logger
[hsc_logger] :: HscEnv -> !Logger

-- | Hooks
[hsc_hooks] :: HscEnv -> !Hooks

-- | Temporary files
[hsc_tmpfs] :: HscEnv -> !TmpFs
hsc_home_unit :: HscEnv -> HomeUnit
hsc_units :: HscEnv -> UnitState
runHsc :: HscEnv -> Hsc a -> IO a

-- | Switches in the DynFlags and Plugins from the InteractiveContext
mkInteractiveHscEnv :: HscEnv -> HscEnv

-- | A variant of runHsc that switches in the DynFlags and Plugins from the
--   InteractiveContext before running the Hsc computation.
runInteractiveHsc :: HscEnv -> Hsc a -> IO a

-- | Retrieve the ExternalPackageState cache.
hscEPS :: HscEnv -> IO ExternalPackageState
hptCompleteSigs :: HscEnv -> [CompleteMatch]

-- | Find all the instance declarations (of classes and families) from the
--   Home Package Table filtered by the provided predicate function. Used
--   in <tt>tcRnImports</tt>, to select the instances that are in the
--   transitive closure of imports from the currently compiled module.
hptInstances :: HscEnv -> (ModuleName -> Bool) -> ([ClsInst], [FamInst])

-- | Get annotations from modules "below" this one (in the dependency
--   sense)
hptAnns :: HscEnv -> Maybe [ModuleNameWithIsBoot] -> [Annotation]
hptAllThings :: (HomeModInfo -> [a]) -> HscEnv -> [a]

-- | Get things from modules "below" this one (in the dependency sense) C.f
--   Inst.hptInstances
hptSomeThingsBelowUs :: (HomeModInfo -> [a]) -> Bool -> HscEnv -> [ModuleNameWithIsBoot] -> [a]

-- | Get rules from modules "below" this one (in the dependency sense)
hptRules :: HscEnv -> [ModuleNameWithIsBoot] -> [CoreRule]

-- | Deal with gathering annotations in from all possible places and
--   combining them into a single <a>AnnEnv</a>
prepareAnnotations :: HscEnv -> Maybe ModGuts -> IO AnnEnv

-- | Find the <a>TyThing</a> for the given <a>Name</a> by using all the
--   resources at our disposal: the compiled modules in the
--   <a>HomePackageTable</a> and the compiled modules in other packages
--   that live in <a>PackageTypeEnv</a>. Note that this does NOT look up
--   the <a>TyThing</a> in the module being compiled: you have to do that
--   yourself, if desired
lookupType :: HscEnv -> Name -> IO (Maybe TyThing)

-- | Find the <a>ModIface_</a> for a <a>Module</a>, searching in both the
--   loaded home and external package module information
lookupIfaceByModule :: HomePackageTable -> PackageIfaceTable -> Module -> Maybe ModIface
mainModIs :: HscEnv -> Module

module GHC.Unit.External

-- | Information about other packages that we have slurped in by reading
--   their interface files
data ExternalPackageState
EPS :: !ModuleNameEnv ModuleNameWithIsBoot -> !PackageIfaceTable -> InstalledModuleEnv (UniqDSet ModuleName) -> !PackageTypeEnv -> !PackageInstEnv -> !PackageFamInstEnv -> !PackageRuleBase -> !PackageAnnEnv -> !PackageCompleteMatches -> !ModuleEnv FamInstEnv -> !EpsStats -> ExternalPackageState

-- | In OneShot mode (only), home-package modules accumulate in the
--   external package state, and are sucked in lazily. For these home-pkg
--   modules (only) we need to record which are boot modules. We set this
--   field after loading all the explicitly-imported interfaces, but before
--   doing anything else
--   
--   The <a>ModuleName</a> part is not necessary, but it's useful for debug
--   prints, and it's convenient because this field comes direct from
--   <a>imp_dep_mods</a>
[eps_is_boot] :: ExternalPackageState -> !ModuleNameEnv ModuleNameWithIsBoot

-- | The <a>ModIface_</a>s for modules in external packages whose
--   interfaces we have opened. The declarations in these interface files
--   are held in the <tt>eps_decls</tt>, <a>eps_inst_env</a>,
--   <a>eps_fam_inst_env</a> and <tt>eps_rules</tt> fields of this record,
--   not in the <a>mi_decls</a> fields of the interface we have sucked in.
--   
--   What <i>is</i> in the PIT is:
--   
--   <ul>
--   <li>The Module</li>
--   <li>Fingerprint info</li>
--   <li>Its exports</li>
--   <li>Fixities</li>
--   <li>Deprecations and warnings</li>
--   </ul>
[eps_PIT] :: ExternalPackageState -> !PackageIfaceTable

-- | Cache for <a>mi_free_holes</a>. Ordinarily, we can rely on the
--   <a>eps_PIT</a> for this information, EXCEPT that when we do dependency
--   analysis, we need to look at the <tt>Dependencies</tt> of our imports
--   to determine what their precise free holes are
--   (<tt>moduleFreeHolesPrecise</tt>). We don't want to repeatedly reread
--   in the interface for every import, so cache it here. When the PIT gets
--   filled in we can drop these entries.
[eps_free_holes] :: ExternalPackageState -> InstalledModuleEnv (UniqDSet ModuleName)

-- | Result of typechecking all the external package interface files we
--   have sucked in. The domain of the mapping is external-package modules
[eps_PTE] :: ExternalPackageState -> !PackageTypeEnv

-- | The total <a>InstEnv</a> accumulated from all the external-package
--   modules
[eps_inst_env] :: ExternalPackageState -> !PackageInstEnv

-- | The total <a>FamInstEnv</a> accumulated from all the external-package
--   modules
[eps_fam_inst_env] :: ExternalPackageState -> !PackageFamInstEnv

-- | The total <tt>RuleEnv</tt> accumulated from all the external-package
--   modules
[eps_rule_base] :: ExternalPackageState -> !PackageRuleBase

-- | The total <a>AnnEnv</a> accumulated from all the external-package
--   modules
[eps_ann_env] :: ExternalPackageState -> !PackageAnnEnv

-- | The total <a>CompleteMatches</a> accumulated from all the
--   external-package modules
[eps_complete_matches] :: ExternalPackageState -> !PackageCompleteMatches

-- | The family instances accumulated from external packages, keyed off the
--   module that declared them
[eps_mod_fam_inst_env] :: ExternalPackageState -> !ModuleEnv FamInstEnv

-- | Stastics about what was loaded from external packages
[eps_stats] :: ExternalPackageState -> !EpsStats

-- | Accumulated statistics about what we are putting into the
--   <a>ExternalPackageState</a>. "In" means stuff that is just <i>read</i>
--   from interface files, "Out" means actually sucked in and type-checked
data EpsStats
EpsStats :: !Int -> EpsStats
[n_ifaces_in, n_decls_in, n_decls_out, n_rules_in, n_rules_out, n_insts_in, n_insts_out] :: EpsStats -> !Int

-- | Add stats for one newly-read interface
addEpsInStats :: EpsStats -> Int -> Int -> Int -> EpsStats
type PackageTypeEnv = TypeEnv

-- | Helps us find information about modules in the imported packages
type PackageIfaceTable = ModuleEnv ModIface
type PackageInstEnv = InstEnv
type PackageFamInstEnv = FamInstEnv
type PackageRuleBase = RuleBase
type PackageCompleteMatches = CompleteMatches

-- | Constructs an empty PackageIfaceTable
emptyPackageIfaceTable :: PackageIfaceTable

module GHC.Unit.Env
data UnitEnv
UnitEnv :: !UnitState -> !HomeUnit -> !Platform -> !GhcNameVersion -> UnitEnv

-- | Units
[ue_units] :: UnitEnv -> !UnitState

-- | Home unit
[ue_home_unit] :: UnitEnv -> !HomeUnit

-- | Platform
[ue_platform] :: UnitEnv -> !Platform

-- | GHC name/version (used for dynamic library suffix)
[ue_namever] :: UnitEnv -> !GhcNameVersion

-- | Lookup <a>UnitInfo</a> for every preload unit from the UnitState and
--   for every unit used to instantiate the home unit.
preloadUnitsInfo :: UnitEnv -> MaybeErr UnitErr [UnitInfo]

-- | Lookup <a>UnitInfo</a> for every preload unit from the UnitState, for
--   every unit used to instantiate the home unit, and for every unit
--   explicitly passed in the given list of UnitId.
preloadUnitsInfo' :: UnitEnv -> [UnitId] -> MaybeErr UnitErr [UnitInfo]

module GHC.Runtime.Context

-- | Interactive context, recording information about the state of the
--   context in which statements are executed in a GHCi session.
data InteractiveContext
InteractiveContext :: DynFlags -> Int -> [InteractiveImport] -> [TyThing] -> GlobalRdrEnv -> ([ClsInst], [FamInst]) -> FixityEnv -> Maybe [Type] -> [Resume] -> Name -> Name -> Maybe FilePath -> ![LoadedPlugin] -> InteractiveContext

-- | The <a>DynFlags</a> used to evaluate interactive expressions and
--   statements.
[ic_dflags] :: InteractiveContext -> DynFlags

-- | Each GHCi stmt or declaration brings some new things into scope. We
--   give them names like interactive:Ghci9.T, where the ic_index is the
--   '9'. The ic_mod_index is incremented whenever we add something to
--   ic_tythings See Note [The interactive package]
[ic_mod_index] :: InteractiveContext -> Int

-- | The GHCi top-level scope (ic_rn_gbl_env) is extended with these
--   imports
--   
--   This field is only stored here so that the client can retrieve it with
--   GHC.getContext. GHC itself doesn't use it, but does reset it to empty
--   sometimes (such as before a GHC.load). The context is set with
--   GHC.setContext.
[ic_imports] :: InteractiveContext -> [InteractiveImport]

-- | TyThings defined by the user, in reverse order of definition (ie most
--   recent at the front) See Note [ic_tythings]
[ic_tythings] :: InteractiveContext -> [TyThing]

-- | The cached <a>GlobalRdrEnv</a>, built by <a>setContext</a> and updated
--   regularly It contains everything in scope at the command line,
--   including everything in ic_tythings
[ic_rn_gbl_env] :: InteractiveContext -> GlobalRdrEnv

-- | All instances and family instances created during this session. These
--   are grabbed en masse after each update to be sure that proper
--   overlapping is retained. That is, rather than re-check the overlapping
--   each time we update the context, we just take the results from the
--   instance code that already does that.
[ic_instances] :: InteractiveContext -> ([ClsInst], [FamInst])

-- | Fixities declared in let statements
[ic_fix_env] :: InteractiveContext -> FixityEnv

-- | The current default types, set by a 'default' declaration
[ic_default] :: InteractiveContext -> Maybe [Type]

-- | The stack of breakpoint contexts
[ic_resume] :: InteractiveContext -> [Resume]

-- | The monad that GHCi is executing in
[ic_monad] :: InteractiveContext -> Name

-- | The function that is used for printing results of expressions in ghci
--   and -e mode.
[ic_int_print] :: InteractiveContext -> Name

-- | virtual CWD of the program
[ic_cwd] :: InteractiveContext -> Maybe FilePath

-- | Cache of loaded plugins. We store them here to avoid having to load
--   them everytime we switch to the interctive context.
[ic_plugins] :: InteractiveContext -> ![LoadedPlugin]
data InteractiveImport

-- | Bring the exports of a particular module (filtered by an import decl)
--   into scope
IIDecl :: ImportDecl GhcPs -> InteractiveImport

-- | Bring into scope the entire top-level envt of of this module,
--   including the things imported into it.
IIModule :: ModuleName -> InteractiveImport

-- | Constructs an empty InteractiveContext.
emptyInteractiveContext :: DynFlags -> InteractiveContext

-- | extendInteractiveContext is called with new TyThings recently defined
--   to update the InteractiveContext to include them. Ids are easily
--   removed when shadowed, but Classes and TyCons are not. Some work could
--   be done to determine whether they are entirely shadowed, but as you
--   could still have references to them (e.g. instances for classes or
--   values of the type for TyCons), it's not clear whether removing them
--   is even the appropriate behavior.
extendInteractiveContext :: InteractiveContext -> [TyThing] -> [ClsInst] -> [FamInst] -> Maybe [Type] -> FixityEnv -> InteractiveContext
extendInteractiveContextWithIds :: InteractiveContext -> [Id] -> InteractiveContext
setInteractivePrintName :: InteractiveContext -> Name -> InteractiveContext
substInteractiveContext :: InteractiveContext -> TCvSubst -> InteractiveContext

-- | Add TyThings to the GlobalRdrEnv, earlier ones in the list shadowing
--   later ones, and shadowing existing entries in the GlobalRdrEnv.
icExtendGblRdrEnv :: GlobalRdrEnv -> [TyThing] -> GlobalRdrEnv
icInteractiveModule :: InteractiveContext -> Module

-- | This function returns the list of visible TyThings (useful for e.g.
--   showBindings)
icInScopeTTs :: InteractiveContext -> [TyThing]

-- | Get the PrintUnqualified function based on the flags and this
--   InteractiveContext
icPrintUnqual :: UnitEnv -> InteractiveContext -> PrintUnqualified
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Context.InteractiveImport

module GHC.Types.Name.Ppr

-- | Creates some functions that work out the best ways to format names for
--   the user according to a set of heuristics.
mkPrintUnqualified :: UnitEnv -> GlobalRdrEnv -> PrintUnqualified

-- | Creates a function for formatting modules based on two heuristics: (1)
--   if the module is the current module, don't qualify, and (2) if there
--   is only one exposed package which exports this module, don't qualify.
mkQualModule :: UnitState -> HomeUnit -> QueryQualifyModule

-- | Creates a function for formatting packages based on two heuristics:
--   (1) don't qualify if the package in question is "main", and (2) only
--   qualify with a unit id if the package ID would be ambiguous.
mkQualPackage :: UnitState -> QueryQualifyPackage

-- | A function which only qualifies package names if necessary; but
--   qualifies all other identifiers.
pkgQual :: UnitState -> PrintUnqualified

module GHC.Runtime.Eval.Types
data Resume
Resume :: String -> ForeignRef (ResumeContext [HValueRef]) -> ([TyThing], GlobalRdrEnv) -> [Id] -> ForeignHValue -> Maybe BreakInfo -> SrcSpan -> String -> RemotePtr CostCentreStack -> [History] -> Int -> Resume
[resumeStmt] :: Resume -> String
[resumeContext] :: Resume -> ForeignRef (ResumeContext [HValueRef])
[resumeBindings] :: Resume -> ([TyThing], GlobalRdrEnv)
[resumeFinalIds] :: Resume -> [Id]
[resumeApStack] :: Resume -> ForeignHValue
[resumeBreakInfo] :: Resume -> Maybe BreakInfo
[resumeSpan] :: Resume -> SrcSpan
[resumeDecl] :: Resume -> String
[resumeCCS] :: Resume -> RemotePtr CostCentreStack
[resumeHistory] :: Resume -> [History]
[resumeHistoryIx] :: Resume -> Int
data History
History :: ForeignHValue -> BreakInfo -> [String] -> History
[historyApStack] :: History -> ForeignHValue
[historyBreakInfo] :: History -> BreakInfo
[historyEnclosingDecls] :: History -> [String]
data ExecResult
ExecComplete :: Either SomeException [Name] -> Word64 -> ExecResult
[execResult] :: ExecResult -> Either SomeException [Name]
[execAllocation] :: ExecResult -> Word64
ExecBreak :: [Name] -> Maybe BreakInfo -> ExecResult
[breakNames] :: ExecResult -> [Name]
[breakInfo] :: ExecResult -> Maybe BreakInfo
data SingleStep
RunToCompletion :: SingleStep
SingleStep :: SingleStep
RunAndLogSteps :: SingleStep
isStep :: SingleStep -> Bool
data ExecOptions
ExecOptions :: SingleStep -> String -> Int -> (ForeignHValue -> EvalExpr ForeignHValue) -> ExecOptions

-- | stepping mode
[execSingleStep] :: ExecOptions -> SingleStep

-- | filename (for errors)
[execSourceFile] :: ExecOptions -> String

-- | line number (for errors)
[execLineNumber] :: ExecOptions -> Int
[execWrap] :: ExecOptions -> ForeignHValue -> EvalExpr ForeignHValue
data BreakInfo
BreakInfo :: Module -> Int -> BreakInfo
[breakInfo_module] :: BreakInfo -> Module
[breakInfo_number] :: BreakInfo -> Int

module GHC.Driver.Env.Types

-- | The Hsc monad: Passing an environment and warning state
newtype Hsc a
Hsc :: (HscEnv -> WarningMessages -> IO (a, WarningMessages)) -> Hsc a

-- | HscEnv is like <a>Session</a>, except that some of the fields are
--   immutable. An HscEnv is used to compile a single module from plain
--   Haskell source code (after preprocessing) to either C, assembly or
--   C--. It's also used to store the dynamic linker state to allow for
--   multiple linkers in the same address space. Things like the module
--   graph don't change during a single compilation.
--   
--   Historical note: "hsc" used to be the name of the compiler binary,
--   when there was a separate driver and compiler. To compile a single
--   module, the driver would invoke hsc on the source code... so nowadays
--   we think of hsc as the layer of the compiler that deals with compiling
--   a single module.
data HscEnv
HscEnv :: DynFlags -> [Target] -> ModuleGraph -> InteractiveContext -> HomePackageTable -> {-# UNPACK #-} !IORef ExternalPackageState -> {-# UNPACK #-} !IORef NameCache -> {-# UNPACK #-} !IORef FinderCache -> Maybe (Module, IORef TypeEnv) -> Maybe Interp -> ![LoadedPlugin] -> ![StaticPlugin] -> !Maybe [UnitDatabase UnitId] -> UnitEnv -> !Logger -> !Hooks -> !TmpFs -> HscEnv

-- | The dynamic flag settings
[hsc_dflags] :: HscEnv -> DynFlags

-- | The targets (or roots) of the current session
[hsc_targets] :: HscEnv -> [Target]

-- | The module graph of the current session
[hsc_mod_graph] :: HscEnv -> ModuleGraph

-- | The context for evaluating interactive statements
[hsc_IC] :: HscEnv -> InteractiveContext

-- | The home package table describes already-compiled home-package
--   modules, <i>excluding</i> the module we are compiling right now. (In
--   one-shot mode the current module is the only home-package module, so
--   hsc_HPT is empty. All other modules count as "external-package"
--   modules. However, even in GHCi mode, hi-boot interfaces are
--   demand-loaded into the external-package table.)
--   
--   <a>hsc_HPT</a> is not mutable because we only demand-load external
--   packages; the home package is eagerly loaded, module by module, by the
--   compilation manager.
--   
--   The HPT may contain modules compiled earlier by <tt>--make</tt> but
--   not actually below the current module in the dependency graph.
--   
--   (This changes a previous invariant: changed Jan 05.)
[hsc_HPT] :: HscEnv -> HomePackageTable

-- | Information about the currently loaded external packages. This is
--   mutable because packages will be demand-loaded during a compilation
--   run as required.
[hsc_EPS] :: HscEnv -> {-# UNPACK #-} !IORef ExternalPackageState

-- | As with <a>hsc_EPS</a>, this is side-effected by compiling to reflect
--   sucking in interface files. They cache the state of external interface
--   files, in effect.
[hsc_NC] :: HscEnv -> {-# UNPACK #-} !IORef NameCache

-- | The cached result of performing finding in the file system
[hsc_FC] :: HscEnv -> {-# UNPACK #-} !IORef FinderCache

-- | Used for one-shot compilation only, to initialise the
--   <tt>IfGblEnv</tt>. See <a>tcg_type_env_var</a> for <a>TcGblEnv</a>.
--   See also Note [hsc_type_env_var hack]
[hsc_type_env_var] :: HscEnv -> Maybe (Module, IORef TypeEnv)

-- | target code interpreter (if any) to use for TH and GHCi. See Note
--   [Target code interpreter]
[hsc_interp] :: HscEnv -> Maybe Interp

-- | plugins dynamically loaded after processing arguments. What will be
--   loaded here is directed by DynFlags.pluginModNames. Arguments are
--   loaded from DynFlags.pluginModNameOpts.
--   
--   The purpose of this field is to cache the plugins so they don't have
--   to be loaded each time they are needed. See <a>initializePlugins</a>.
[hsc_plugins] :: HscEnv -> ![LoadedPlugin]

-- | static plugins which do not need dynamic loading. These plugins are
--   intended to be added by GHC API users directly to this list.
--   
--   To add dynamically loaded plugins through the GHC API see
--   <tt>addPluginModuleName</tt> instead.
[hsc_static_plugins] :: HscEnv -> ![StaticPlugin]

-- | Stack of unit databases for the target platform.
--   
--   This field is populated with the result of <a>initUnits</a>.
--   
--   <a>Nothing</a> means the databases have never been read from disk.
--   
--   Usually we don't reload the databases from disk if they are cached,
--   even if the database flags changed!
[hsc_unit_dbs] :: HscEnv -> !Maybe [UnitDatabase UnitId]

-- | Unit environment (unit state, home unit, etc.).
--   
--   Initialized from the databases cached in <a>hsc_unit_dbs</a> and from
--   the DynFlags.
[hsc_unit_env] :: HscEnv -> UnitEnv

-- | Logger
[hsc_logger] :: HscEnv -> !Logger

-- | Hooks
[hsc_hooks] :: HscEnv -> !Hooks

-- | Temporary files
[hsc_tmpfs] :: HscEnv -> !TmpFs
instance GHC.Base.Functor GHC.Driver.Env.Types.Hsc
instance GHC.Base.Applicative GHC.Driver.Env.Types.Hsc
instance GHC.Base.Monad GHC.Driver.Env.Types.Hsc
instance Control.Monad.IO.Class.MonadIO GHC.Driver.Env.Types.Hsc
instance GHC.Driver.Session.HasDynFlags GHC.Driver.Env.Types.Hsc
instance GHC.Utils.Logger.HasLogger GHC.Driver.Env.Types.Hsc

module GHC.Unit.Module.Graph

-- | A '<tt>ModuleGraph</tt>' contains all the nodes from the home package
--   (only). See '<tt>ModuleGraphNode</tt>' for information about the
--   nodes.
--   
--   Modules need to be compiled. hs-boots need to be typechecked before
--   the associated "real" module so modules with {-# SOURCE #-} imports
--   can be built. Instantiations also need to be typechecked to ensure
--   that the module fits the signature. Substantiation typechecking is
--   roughly comparable to the check that the module and its hs-boot agree.
--   
--   The graph is not necessarily stored in topologically-sorted order. Use
--   <a>topSortModuleGraph</a> and <a>flattenSCC</a> to achieve this.
data ModuleGraph

-- | A '<tt>ModuleGraphNode</tt>' is a node in the '<tt>ModuleGraph</tt>'.
--   Edges between nodes mark dependencies arising from module imports and
--   dependencies arising from backpack instantiations.
data ModuleGraphNode

-- | Instantiation nodes track the instantiation of other units (backpack
--   dependencies) with the holes (signatures) of the current package.
InstantiationNode :: InstantiatedUnit -> ModuleGraphNode

-- | There is a module summary node for each module, signature, and boot
--   module being built.
ModuleNode :: ExtendedModSummary -> ModuleGraphNode
emptyMG :: ModuleGraph
mkModuleGraph :: [ExtendedModSummary] -> ModuleGraph
mkModuleGraph' :: [ModuleGraphNode] -> ModuleGraph

-- | Add an ExtendedModSummary to ModuleGraph. Assumes that the new
--   ModSummary is not an element of the ModuleGraph.
extendMG :: ModuleGraph -> ExtendedModSummary -> ModuleGraph
extendMGInst :: ModuleGraph -> InstantiatedUnit -> ModuleGraph
extendMG' :: ModuleGraph -> ModuleGraphNode -> ModuleGraph

-- | This function filters out all the instantiation nodes from each SCC of
--   a topological sort. Use this with care, as the resulting "strongly
--   connected components" may not really be strongly connected in a direct
--   way, as instantiations have been removed. It would probably be best to
--   eliminate uses of this function where possible.
filterToposortToModules :: [SCC ModuleGraphNode] -> [SCC ModSummary]

-- | Map a function <tt>f</tt> over all the <tt>ModSummaries</tt>. To
--   preserve invariants <tt>f</tt> can't change the isBoot status.
mapMG :: (ModSummary -> ModSummary) -> ModuleGraph -> ModuleGraph
mgModSummaries :: ModuleGraph -> [ModSummary]
mgModSummaries' :: ModuleGraph -> [ModuleGraphNode]
mgExtendedModSummaries :: ModuleGraph -> [ExtendedModSummary]
mgElemModule :: ModuleGraph -> Module -> Bool

-- | Look up a ModSummary in the ModuleGraph
mgLookupModule :: ModuleGraph -> Module -> Maybe ModSummary
mgBootModules :: ModuleGraph -> ModuleSet

-- | Determines whether a set of modules requires Template Haskell or Quasi
--   Quotes
--   
--   Note that if the session's <a>DynFlags</a> enabled Template Haskell
--   when <tt>depanal</tt> was called, then each module in the returned
--   module graph will have Template Haskell enabled whether it is actually
--   needed or not.
needsTemplateHaskellOrQQ :: ModuleGraph -> Bool
isTemplateHaskellOrQQNonBoot :: ModSummary -> Bool
showModMsg :: DynFlags -> Bool -> ModuleGraphNode -> SDoc
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Graph.ModuleGraphNode

module GHC.Unit.Finder.Types

-- | The <a>FinderCache</a> maps modules to the result of searching for
--   that module. It records the results of searching for modules along the
--   search path. On <tt>:load</tt>, we flush the entire contents of this
--   cache.
type FinderCache = InstalledModuleEnv InstalledFindResult

-- | The result of searching for an imported module.
--   
--   NB: FindResult manages both user source-import lookups (which can
--   result in <a>Module</a>) as well as direct imports for interfaces
--   (which always result in <a>InstalledModule</a>).
data FindResult

-- | The module was found
Found :: ModLocation -> Module -> FindResult

-- | The requested unit was not found
NoPackage :: Unit -> FindResult

-- | _Error_: both in multiple packages
FoundMultiple :: [(Module, ModuleOrigin)] -> FindResult

-- | Not found
NotFound :: [FilePath] -> Maybe Unit -> [Unit] -> [Unit] -> [(Unit, UnusableUnitReason)] -> [ModuleSuggestion] -> FindResult

-- | Places where I looked
[fr_paths] :: FindResult -> [FilePath]

-- | Just p =&gt; module is in this unit's manifest, but couldn't find the
--   .hi file
[fr_pkg] :: FindResult -> Maybe Unit

-- | Module is in these units, but the *module* is hidden
[fr_mods_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but the *unit* is hidden
[fr_pkgs_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but it is unusable
[fr_unusables] :: FindResult -> [(Unit, UnusableUnitReason)]

-- | Possible mis-spelled modules
[fr_suggestions] :: FindResult -> [ModuleSuggestion]
data InstalledFindResult
InstalledFound :: ModLocation -> InstalledModule -> InstalledFindResult
InstalledNoPackage :: UnitId -> InstalledFindResult
InstalledNotFound :: [FilePath] -> Maybe UnitId -> InstalledFindResult


-- | The Name Cache
module GHC.Types.Name.Cache
lookupOrigNameCache :: OrigNameCache -> Module -> OccName -> Maybe Name
extendOrigNameCache :: OrigNameCache -> Name -> OrigNameCache
extendNameCache :: OrigNameCache -> Module -> OccName -> Name -> OrigNameCache

-- | Return a function to atomically update the name cache.
initNameCache :: UniqSupply -> [Name] -> NameCache

-- | The NameCache makes sure that there is just one Unique assigned for
--   each original name; i.e. (module-name, occ-name) pair and provides
--   something of a lookup mechanism for those names.
data NameCache
NameCache :: !UniqSupply -> !OrigNameCache -> NameCache

-- | Supply of uniques
[nsUniqs] :: NameCache -> !UniqSupply

-- | Ensures that one original name gets one unique
[nsNames] :: NameCache -> !OrigNameCache

-- | Per-module cache of original <a>OccName</a>s given <a>Name</a>s
type OrigNameCache = ModuleEnv (OccEnv Name)


-- | Types used by the runtime interpreter
module GHC.Runtime.Interpreter.Types

-- | Interpreter
data Interp
Interp :: !InterpInstance -> !Loader -> Interp

-- | Interpreter instance (internal, external)
[interpInstance] :: Interp -> !InterpInstance

-- | Interpreter loader
[interpLoader] :: Interp -> !Loader
data InterpInstance

-- | External interpreter
ExternalInterp :: !IServConfig -> !IServ -> InterpInstance

-- | Internal interpreter
InternalInterp :: InterpInstance

-- | External interpreter
--   
--   The external interpreter is spawned lazily (on first use) to avoid
--   slowing down sessions that don't require it. The contents of the MVar
--   reflects the state of the interpreter (running or not).
newtype IServ
IServ :: MVar IServState -> IServ

-- | External interpreter instance
data IServInstance
IServInstance :: !Pipe -> !ProcessHandle -> !UniqFM FastString (Ptr ()) -> ![HValueRef] -> IServInstance
[iservPipe] :: IServInstance -> !Pipe
[iservProcess] :: IServInstance -> !ProcessHandle
[iservLookupSymbolCache] :: IServInstance -> !UniqFM FastString (Ptr ())

-- | Values that need to be freed before the next command is sent. Threads
--   can append values to this list asynchronously (by modifying the IServ
--   state MVar).
[iservPendingFrees] :: IServInstance -> ![HValueRef]

-- | Configuration needed to spawn an external interpreter
data IServConfig
IServConfig :: !String -> ![String] -> !Bool -> !Bool -> !Maybe (CreateProcess -> IO ProcessHandle) -> IO () -> IServConfig

-- | External program to run
[iservConfProgram] :: IServConfig -> !String

-- | Command-line options
[iservConfOpts] :: IServConfig -> ![String]

-- | Use Profiling way
[iservConfProfiled] :: IServConfig -> !Bool

-- | Use Dynamic way
[iservConfDynamic] :: IServConfig -> !Bool

-- | Hook
[iservConfHook] :: IServConfig -> !Maybe (CreateProcess -> IO ProcessHandle)

-- | Trace action executed after spawn
[iservConfTrace] :: IServConfig -> IO ()

-- | State of an external interpreter
data IServState

-- | Not spawned yet
IServPending :: IServState

-- | Running
IServRunning :: !IServInstance -> IServState

module GHC.Core.Opt.Monad
data CoreToDo
CoreDoSimplify :: Int -> SimplMode -> CoreToDo
CoreDoPluginPass :: String -> CorePluginPass -> CoreToDo
CoreDoFloatInwards :: CoreToDo
CoreDoFloatOutwards :: FloatOutSwitches -> CoreToDo
CoreLiberateCase :: CoreToDo
CoreDoPrintCore :: CoreToDo
CoreDoStaticArgs :: CoreToDo
CoreDoCallArity :: CoreToDo
CoreDoExitify :: CoreToDo
CoreDoDemand :: CoreToDo
CoreDoCpr :: CoreToDo
CoreDoWorkerWrapper :: CoreToDo
CoreDoSpecialising :: CoreToDo
CoreDoSpecConstr :: CoreToDo
CoreCSE :: CoreToDo
CoreDoRuleCheck :: CompilerPhase -> String -> CoreToDo
CoreDoNothing :: CoreToDo
CoreDoPasses :: [CoreToDo] -> CoreToDo
CoreDesugar :: CoreToDo
CoreDesugarOpt :: CoreToDo
CoreTidy :: CoreToDo
CorePrep :: CoreToDo
CoreAddCallerCcs :: CoreToDo
CoreOccurAnal :: CoreToDo
runWhen :: Bool -> CoreToDo -> CoreToDo
runMaybe :: Maybe a -> (a -> CoreToDo) -> CoreToDo
data SimplMode
SimplMode :: [String] -> CompilerPhase -> !UnfoldingOpts -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Logger -> DynFlags -> SimplMode

-- | Name(s) of the phase
[sm_names] :: SimplMode -> [String]
[sm_phase] :: SimplMode -> CompilerPhase

-- | Unfolding options
[sm_uf_opts] :: SimplMode -> !UnfoldingOpts

-- | Whether RULES are enabled
[sm_rules] :: SimplMode -> !Bool

-- | Whether inlining is enabled
[sm_inline] :: SimplMode -> !Bool

-- | Whether case-of-case is enabled
[sm_case_case] :: SimplMode -> !Bool

-- | Whether eta-expansion is enabled
[sm_eta_expand] :: SimplMode -> !Bool

-- | Do we swizzle casts past lambdas?
[sm_cast_swizzle] :: SimplMode -> !Bool

-- | Whether pre-inlining is enabled
[sm_pre_inline] :: SimplMode -> !Bool
[sm_logger] :: SimplMode -> !Logger
[sm_dflags] :: SimplMode -> DynFlags
data FloatOutSwitches
FloatOutSwitches :: Maybe Int -> Bool -> Bool -> Bool -> FloatOutSwitches

-- | Just n <a>=</a> float lambdas to top level, if doing so will abstract
--   over n or fewer value variables Nothing <a>=</a> float all lambdas to
--   top level, regardless of how many free variables Just 0 is the vanilla
--   case: float a lambda iff it has no free vars
[floatOutLambdas] :: FloatOutSwitches -> Maybe Int

-- | True <a>=</a> float constants to top level, even if they do not escape
--   a lambda
[floatOutConstants] :: FloatOutSwitches -> Bool

-- | True <a>=</a> float out over-saturated applications based on arity
--   information. See Note [Floating over-saturated applications] in
--   GHC.Core.Opt.SetLevels
[floatOutOverSatApps] :: FloatOutSwitches -> Bool

-- | Allow floating to the top level only.
[floatToTopLevelOnly] :: FloatOutSwitches -> Bool
pprPassDetails :: CoreToDo -> SDoc

-- | A description of the plugin pass itself
type CorePluginPass = ModGuts -> CoreM ModGuts
bindsOnlyPass :: (CoreProgram -> CoreM CoreProgram) -> ModGuts -> CoreM ModGuts
data SimplCount
doSimplTick :: DynFlags -> Tick -> SimplCount -> SimplCount
doFreeSimplTick :: Tick -> SimplCount -> SimplCount
simplCountN :: SimplCount -> Int
pprSimplCount :: SimplCount -> SDoc
plusSimplCount :: SimplCount -> SimplCount -> SimplCount
zeroSimplCount :: DynFlags -> SimplCount
isZeroSimplCount :: SimplCount -> Bool
hasDetailedCounts :: SimplCount -> Bool
data Tick
PreInlineUnconditionally :: Id -> Tick
PostInlineUnconditionally :: Id -> Tick
UnfoldingDone :: Id -> Tick
RuleFired :: FastString -> Tick
LetFloatFromLet :: Tick
EtaExpansion :: Id -> Tick
EtaReduction :: Id -> Tick
BetaReduction :: Id -> Tick
CaseOfCase :: Id -> Tick
KnownBranch :: Id -> Tick
CaseMerge :: Id -> Tick
AltMerge :: Id -> Tick
CaseElim :: Id -> Tick
CaseIdentity :: Id -> Tick
FillInCaseDefault :: Id -> Tick
SimplifierDone :: Tick

-- | The monad used by Core-to-Core passes to register simplification
--   statistics. Also used to have common state (in the form of
--   UniqueSupply) for generating Uniques.
data CoreM a
runCoreM :: HscEnv -> RuleBase -> Char -> Module -> ModuleSet -> PrintUnqualified -> SrcSpan -> CoreM a -> IO (a, SimplCount)
getHscEnv :: CoreM HscEnv
getRuleBase :: CoreM RuleBase
getModule :: HasModule m => m Module
getDynFlags :: HasDynFlags m => m DynFlags
getPackageFamInstEnv :: CoreM PackageFamInstEnv
getVisibleOrphanMods :: CoreM ModuleSet
getUniqMask :: CoreM Char
getPrintUnqualified :: CoreM PrintUnqualified
getSrcSpanM :: CoreM SrcSpan
addSimplCount :: SimplCount -> CoreM ()

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   â¢ Couldn't match type âIOâ with âStateT s IOâ
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a

-- | Lift an <a>IO</a> operation into <a>CoreM</a> while consuming its
--   <a>SimplCount</a>
liftIOWithCount :: IO (SimplCount, a) -> CoreM a

-- | Get all annotations of a given type. This happens lazily, that is no
--   deserialization will take place until the [a] is actually demanded and
--   the [a] can also be empty (the UniqFM is not filtered).
--   
--   This should be done once at the start of a Core-to-Core pass that uses
--   annotations.
--   
--   See Note [Annotations]
getAnnotations :: Typeable a => ([Word8] -> a) -> ModGuts -> CoreM (ModuleEnv [a], NameEnv [a])

-- | Get at most one annotation of a given type per annotatable item.
getFirstAnnotations :: Typeable a => ([Word8] -> a) -> ModGuts -> CoreM (ModuleEnv a, NameEnv a)

-- | Output a message to the screen
putMsg :: SDoc -> CoreM ()

-- | Output a String message to the screen
putMsgS :: String -> CoreM ()

-- | Output an error to the screen. Does not cause the compiler to die.
errorMsg :: SDoc -> CoreM ()

-- | Output an error to the screen. Does not cause the compiler to die.
errorMsgS :: String -> CoreM ()
warnMsg :: WarnReason -> SDoc -> CoreM ()

-- | Output a fatal error to the screen. Does not cause the compiler to
--   die.
fatalErrorMsg :: SDoc -> CoreM ()

-- | Output a fatal error to the screen. Does not cause the compiler to
--   die.
fatalErrorMsgS :: String -> CoreM ()

-- | Outputs a debugging message at verbosity level of <tt>-v</tt> or
--   higher
debugTraceMsg :: SDoc -> CoreM ()

-- | Output a string debugging message at verbosity level of <tt>-v</tt> or
--   higher
debugTraceMsgS :: String -> CoreM ()

-- | Show some labelled <a>SDoc</a> if a particular flag is set or at a
--   verbosity level of <tt>-v -ddump-most</tt> or higher
dumpIfSet_dyn :: DumpFlag -> String -> DumpFormat -> SDoc -> CoreM ()
instance GHC.Base.Functor GHC.Core.Opt.Monad.CoreM
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Monad.CoreToDo
instance GHC.Base.Monad GHC.Core.Opt.Monad.CoreM
instance GHC.Base.Applicative GHC.Core.Opt.Monad.CoreM
instance GHC.Base.Alternative GHC.Core.Opt.Monad.CoreM
instance GHC.Base.MonadPlus GHC.Core.Opt.Monad.CoreM
instance GHC.Types.Unique.Supply.MonadUnique GHC.Core.Opt.Monad.CoreM
instance Control.Monad.IO.Class.MonadIO GHC.Core.Opt.Monad.CoreM
instance GHC.Driver.Session.HasDynFlags GHC.Core.Opt.Monad.CoreM
instance GHC.Utils.Logger.HasLogger GHC.Core.Opt.Monad.CoreM
instance GHC.Unit.Module.HasModule GHC.Core.Opt.Monad.CoreM
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Monad.Tick
instance GHC.Classes.Eq GHC.Core.Opt.Monad.Tick
instance GHC.Classes.Ord GHC.Core.Opt.Monad.Tick
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Monad.FloatOutSwitches
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Monad.SimplMode


-- | The IO Monad with an environment
--   
--   The environment is passed around as a Reader monad but as its in the
--   IO monad, mutable references can be used for updating state.
module GHC.Data.IOEnv
data IOEnv env a
failM :: IOEnv env a
failWithM :: String -> IOEnv env a
data IOEnvFailure
IOEnvFailure :: IOEnvFailure
getEnv :: IOEnv env env

-- | Perform a computation with a different environment
setEnv :: env' -> IOEnv env' a -> IOEnv env a

-- | Perform a computation with an altered environment
updEnv :: (env -> env') -> IOEnv env' a -> IOEnv env a
runIOEnv :: env -> IOEnv env a -> IO a
unsafeInterleaveM :: IOEnv env a -> IOEnv env a
uninterruptibleMaskM_ :: IOEnv env a -> IOEnv env a
tryM :: IOEnv env r -> IOEnv env (Either IOEnvFailure r)
tryAllM :: IOEnv env r -> IOEnv env (Either SomeException r)
tryMostM :: IOEnv env r -> IOEnv env (Either SomeException r)
fixM :: (a -> IOEnv env a) -> IOEnv env a

-- | A mutable variable in the <a>IO</a> monad
data IORef a
newMutVar :: a -> IOEnv env (IORef a)
readMutVar :: IORef a -> IOEnv env a
writeMutVar :: IORef a -> a -> IOEnv env ()
updMutVar :: IORef a -> (a -> a) -> IOEnv env ()
updMutVarM :: IORef a -> (a -> IOEnv env a) -> IOEnv env ()

-- | Atomically update the reference. Does not force the evaluation of the
--   new variable contents. For strict update, use <a>atomicUpdMutVar'</a>.
atomicUpdMutVar :: IORef a -> (a -> (a, b)) -> IOEnv env b

-- | Strict variant of <a>atomicUpdMutVar</a>.
atomicUpdMutVar' :: IORef a -> (a -> (a, b)) -> IOEnv env b
instance Control.Monad.Fix.MonadFix (GHC.Data.IOEnv.IOEnv env)
instance Control.Monad.Catch.MonadMask (GHC.Data.IOEnv.IOEnv env)
instance Control.Monad.Catch.MonadCatch (GHC.Data.IOEnv.IOEnv env)
instance Control.Monad.Catch.MonadThrow (GHC.Data.IOEnv.IOEnv env)
instance GHC.Show.Show GHC.Data.IOEnv.IOEnvFailure
instance GHC.Exception.Type.Exception GHC.Data.IOEnv.IOEnvFailure
instance GHC.Base.Functor (GHC.Data.IOEnv.IOEnv env)
instance Control.Monad.IO.Class.MonadIO (GHC.Data.IOEnv.IOEnv env)
instance GHC.Base.Monad (GHC.Data.IOEnv.IOEnv m)
instance Control.Monad.Fail.MonadFail (GHC.Data.IOEnv.IOEnv m)
instance GHC.Base.Applicative (GHC.Data.IOEnv.IOEnv m)
instance GHC.Driver.Session.ContainsDynFlags env => GHC.Driver.Session.HasDynFlags (GHC.Data.IOEnv.IOEnv env)
instance GHC.Driver.Hooks.ContainsHooks env => GHC.Driver.Hooks.HasHooks (GHC.Data.IOEnv.IOEnv env)
instance GHC.Utils.Logger.ContainsLogger env => GHC.Utils.Logger.HasLogger (GHC.Data.IOEnv.IOEnv env)
instance GHC.Unit.Module.ContainsModule env => GHC.Unit.Module.HasModule (GHC.Data.IOEnv.IOEnv env)
instance GHC.Base.Alternative (GHC.Data.IOEnv.IOEnv env)
instance GHC.Base.MonadPlus (GHC.Data.IOEnv.IOEnv env)

module GHC.Cmm
type CmmProgram = [CmmGroup]

-- | Cmm group before SRT generation
type CmmGroup = GenCmmGroup CmmStatics CmmTopInfo CmmGraph

-- | Cmm group with SRTs
type CmmGroupSRTs = GenCmmGroup RawCmmStatics CmmTopInfo CmmGraph

-- | <a>Raw</a> cmm group (TODO (osa): not sure what that means)
type RawCmmGroup = GenCmmGroup RawCmmStatics (LabelMap RawCmmStatics) CmmGraph
type GenCmmGroup d h g = [GenCmmDecl d h g]
type CmmDecl = GenCmmDecl CmmStatics CmmTopInfo CmmGraph
type CmmDeclSRTs = GenCmmDecl RawCmmStatics CmmTopInfo CmmGraph

-- | A top-level chunk, abstracted over the type of the contents of the
--   basic blocks (Cmm or instructions are the likely instantiations).
data GenCmmDecl d h g
CmmProc :: h -> CLabel -> [GlobalReg] -> g -> GenCmmDecl d h g
CmmData :: Section -> d -> GenCmmDecl d h g
type CmmGraph = GenCmmGraph CmmNode
data GenCmmGraph n
CmmGraph :: BlockId -> Graph n C C -> GenCmmGraph n
[g_entry] :: GenCmmGraph n -> BlockId
[g_graph] :: GenCmmGraph n -> Graph n C C
type CmmBlock = Block CmmNode C C
type RawCmmDecl = GenCmmDecl RawCmmStatics (LabelMap RawCmmStatics) CmmGraph
data Section
Section :: SectionType -> CLabel -> Section
data SectionType
Text :: SectionType
Data :: SectionType
ReadOnlyData :: SectionType
RelocatableReadOnlyData :: SectionType
UninitialisedData :: SectionType
ReadOnlyData16 :: SectionType
CString :: SectionType
OtherSection :: String -> SectionType
data GenCmmStatics (rawOnly :: Bool)
[CmmStatics] :: CLabel -> CmmInfoTable -> CostCentreStack -> [CmmLit] -> GenCmmStatics 'False

-- | Static data, after SRTs are generated
[CmmStaticsRaw] :: CLabel -> [CmmStatic] -> GenCmmStatics a
type CmmStatics = GenCmmStatics 'False
type RawCmmStatics = GenCmmStatics 'True
data CmmStatic

-- | a literal value, size given by cmmLitRep of the literal.
CmmStaticLit :: CmmLit -> CmmStatic

-- | uninitialised data, N bytes long
CmmUninitialised :: Int -> CmmStatic

-- | string of 8-bit values only, not zero terminated.
CmmString :: ByteString -> CmmStatic

-- | an embedded binary file
CmmFileEmbed :: FilePath -> CmmStatic
data SectionProtection
ReadWriteSection :: SectionProtection
ReadOnlySection :: SectionProtection
WriteProtectedSection :: SectionProtection

-- | Should a data in this section be considered constant at runtime
sectionProtection :: Section -> SectionProtection
data GenBasicBlock i
BasicBlock :: BlockId -> [i] -> GenBasicBlock i

-- | The branch block id is that of the first block in the branch, which is
--   that branch's entry point
blockId :: GenBasicBlock i -> BlockId
newtype ListGraph i
ListGraph :: [GenBasicBlock i] -> ListGraph i
pprBBlock :: Outputable stmt => GenBasicBlock stmt -> SDoc

-- | CmmTopInfo is attached to each CmmDecl (see defn of CmmGroup), and
--   contains the extra info (beyond the executable code) that belongs to
--   that CmmDecl.
data CmmTopInfo
TopInfo :: LabelMap CmmInfoTable -> CmmStackInfo -> CmmTopInfo
[info_tbls] :: CmmTopInfo -> LabelMap CmmInfoTable
[stack_info] :: CmmTopInfo -> CmmStackInfo
data CmmStackInfo
StackInfo :: ByteOff -> Bool -> CmmStackInfo
[arg_space] :: CmmStackInfo -> ByteOff
[do_layout] :: CmmStackInfo -> Bool

-- | Info table as a haskell data type
data CmmInfoTable
CmmInfoTable :: CLabel -> SMRep -> ProfilingInfo -> Maybe CLabel -> Maybe (Id, CostCentreStack) -> CmmInfoTable
[cit_lbl] :: CmmInfoTable -> CLabel
[cit_rep] :: CmmInfoTable -> SMRep
[cit_prof] :: CmmInfoTable -> ProfilingInfo
[cit_srt] :: CmmInfoTable -> Maybe CLabel
[cit_clo] :: CmmInfoTable -> Maybe (Id, CostCentreStack)
topInfoTable :: GenCmmDecl a CmmTopInfo (GenCmmGraph n) -> Maybe CmmInfoTable
data ClosureTypeInfo
Constr :: ConTagZ -> ConstrDescription -> ClosureTypeInfo
Fun :: FunArity -> ArgDescr -> ClosureTypeInfo
Thunk :: ClosureTypeInfo
ThunkSelector :: SelectorOffset -> ClosureTypeInfo
BlackHole :: ClosureTypeInfo
IndStatic :: ClosureTypeInfo
data ProfilingInfo
NoProfilingInfo :: ProfilingInfo
ProfilingInfo :: ByteString -> ByteString -> ProfilingInfo
type ConstrDescription = ByteString
instance GHC.Show.Show GHC.Cmm.SectionType
instance GHC.Classes.Eq GHC.Cmm.SectionProtection
instance GHC.Base.Functor (GHC.Cmm.GenCmmDecl d h)
instance GHC.Base.Functor GHC.Cmm.GenBasicBlock
instance GHC.Base.Functor GHC.Cmm.ListGraph
instance GHC.Utils.Outputable.Outputable instr => GHC.Utils.Outputable.Outputable (GHC.Cmm.ListGraph instr)
instance GHC.Utils.Outputable.OutputableP env instr => GHC.Utils.Outputable.OutputableP env (GHC.Cmm.ListGraph instr)
instance GHC.Utils.Outputable.Outputable instr => GHC.Utils.Outputable.Outputable (GHC.Cmm.GenBasicBlock instr)
instance GHC.Utils.Outputable.OutputableP env instr => GHC.Utils.Outputable.OutputableP env (GHC.Cmm.GenBasicBlock instr)
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CmmStatic

module GHC.Runtime.Heap.Layout

-- | Word offset, or word count
type WordOff = Int

-- | Byte offset, or byte count
type ByteOff = Int

-- | Convert the given number of words to a number of bytes.
--   
--   This function morally has type <tt>WordOff -&gt; ByteOff</tt>, but
--   uses <tt>Num a</tt> to allow for overloading.
wordsToBytes :: Num a => Platform -> a -> a

-- | First round the given byte count up to a multiple of the machine's
--   word size and then convert the result to words.
bytesToWordsRoundUp :: Platform -> ByteOff -> WordOff

-- | Round up the given byte count to the next byte count that's a multiple
--   of the machine's word size.
roundUpToWords :: Platform -> ByteOff -> ByteOff

-- | Round up <tt>base</tt> to a multiple of <tt>size</tt>.
roundUpTo :: ByteOff -> ByteOff -> ByteOff
data StgWord
fromStgWord :: StgWord -> Integer
toStgWord :: Platform -> Integer -> StgWord
data StgHalfWord
fromStgHalfWord :: StgHalfWord -> Integer
toStgHalfWord :: Platform -> Integer -> StgHalfWord

-- | Half word size in bytes
halfWordSize :: Platform -> ByteOff
halfWordSizeInBits :: Platform -> Int

-- | A description of the layout of a closure. Corresponds directly to the
--   closure types in includes/rts/storage/ClosureTypes.h.
data SMRep
HeapRep :: IsStatic -> !WordOff -> !WordOff -> ClosureTypeInfo -> SMRep
ArrayPtrsRep :: !WordOff -> !WordOff -> SMRep
SmallArrayPtrsRep :: !WordOff -> SMRep
ArrayWordsRep :: !WordOff -> SMRep
StackRep :: Liveness -> SMRep
RTSRep :: Int -> SMRep -> SMRep

-- | True &lt;=&gt; This is a static closure. Affects how we
--   garbage-collect it. Static closure have an extra static link field at
--   the end. Constructors do not have a static variant; see Note [static
--   constructors]
type IsStatic = Bool
data ClosureTypeInfo
Constr :: ConTagZ -> ConstrDescription -> ClosureTypeInfo
Fun :: FunArity -> ArgDescr -> ClosureTypeInfo
Thunk :: ClosureTypeInfo
ThunkSelector :: SelectorOffset -> ClosureTypeInfo
BlackHole :: ClosureTypeInfo
IndStatic :: ClosureTypeInfo

-- | An ArgDescr describes the argument pattern of a function
data ArgDescr
ArgSpec :: !Int -> ArgDescr
ArgGen :: Liveness -> ArgDescr
ArgUnknown :: ArgDescr

-- | We represent liveness bitmaps as a Bitmap (whose internal
--   representation really is a bitmap). These are pinned onto case return
--   vectors to indicate the state of the stack for the garbage collector.
--   
--   In the compiled program, liveness bitmaps that fit inside a single
--   word (StgWord) are stored as a single word, while larger bitmaps are
--   stored as a pointer to an array of words.
type Liveness = [Bool]
type ConstrDescription = ByteString
mkHeapRep :: Profile -> IsStatic -> WordOff -> WordOff -> ClosureTypeInfo -> SMRep
blackHoleRep :: SMRep
indStaticRep :: SMRep
mkStackRep :: [Bool] -> SMRep
mkRTSRep :: Int -> SMRep -> SMRep
arrPtrsRep :: Platform -> WordOff -> SMRep
smallArrPtrsRep :: WordOff -> SMRep
arrWordsRep :: Platform -> ByteOff -> SMRep
isStaticRep :: SMRep -> IsStatic
isConRep :: SMRep -> Bool
isThunkRep :: SMRep -> Bool
isFunRep :: SMRep -> Bool
isStaticNoCafCon :: SMRep -> Bool
isStackRep :: SMRep -> Bool

-- | The total size of the closure, in words.
heapClosureSizeW :: Profile -> SMRep -> WordOff

-- | Size of a closure header (StgHeader in
--   includes/rts/storage/Closures.h)
fixedHdrSizeW :: Profile -> WordOff
arrWordsHdrSize :: Profile -> ByteOff
arrWordsHdrSizeW :: Profile -> WordOff
arrPtrsHdrSize :: Profile -> ByteOff
arrPtrsHdrSizeW :: Profile -> WordOff

-- | Size of the profiling part of a closure header (StgProfHeader in
--   includes/rts/storage/Closures.h)
profHdrSize :: Profile -> WordOff
thunkHdrSize :: Profile -> WordOff
nonHdrSize :: Platform -> SMRep -> ByteOff
nonHdrSizeW :: SMRep -> WordOff
smallArrPtrsHdrSize :: Profile -> ByteOff
smallArrPtrsHdrSizeW :: Profile -> WordOff
hdrSize :: Profile -> SMRep -> ByteOff
hdrSizeW :: Profile -> SMRep -> WordOff
fixedHdrSize :: Profile -> ByteOff

-- | Derives the RTS closure type from an <a>SMRep</a>
rtsClosureType :: SMRep -> Int
rET_SMALL :: Int
rET_BIG :: Int
aRG_GEN :: Int
aRG_GEN_BIG :: Int

-- | The byte offset into the card table of the card for a given element
card :: Platform -> Int -> Int

-- | Convert a number of elements to a number of cards, rounding up
cardRoundUp :: Platform -> Int -> Int

-- | The size of a card table, in bytes
cardTableSizeB :: Platform -> Int -> ByteOff

-- | The size of a card table, in words
cardTableSizeW :: Platform -> Int -> WordOff
instance GHC.Bits.Bits GHC.Runtime.Heap.Layout.StgWord
instance GHC.Classes.Eq GHC.Runtime.Heap.Layout.StgWord
instance GHC.Classes.Eq GHC.Runtime.Heap.Layout.StgHalfWord
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.SMRep
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.ClosureTypeInfo
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.StgHalfWord
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.StgWord

module GHC.Cmm.Node
data CmmNode e x
[CmmEntry] :: {-# UNPACK #-} !Label -> CmmTickScope -> CmmNode C O
[CmmComment] :: FastString -> CmmNode O O
[CmmTick] :: !CmmTickish -> CmmNode O O
[CmmUnwind] :: [(GlobalReg, Maybe CmmExpr)] -> CmmNode O O
[CmmAssign] :: !CmmReg -> !CmmExpr -> CmmNode O O
[CmmStore] :: !CmmExpr -> !CmmExpr -> !AlignmentSpec -> CmmNode O O
[CmmUnsafeForeignCall] :: ForeignTarget -> [CmmFormal] -> [CmmActual] -> CmmNode O O
[CmmBranch] :: {-# UNPACK #-} !Label -> CmmNode O C
[CmmCondBranch] :: CmmExpr -> {-# UNPACK #-} !Label -> Maybe Bool -> CmmNode O C
[CmmSwitch] :: CmmExpr -> SwitchTargets -> CmmNode O C
[CmmCall] :: CmmExpr -> Maybe Label -> [GlobalReg] -> ByteOff -> ByteOff -> ByteOff -> CmmNode O C
[CmmForeignCall] :: ForeignTarget -> [CmmFormal] -> [CmmActual] -> {-# UNPACK #-} !Label -> ByteOff -> ByteOff -> Bool -> CmmNode O C
type CmmFormal = LocalReg
type CmmActual = CmmExpr

-- | Tickish in Cmm context (annotations only)
type CmmTickish = GenTickish 'TickishPassCmm
type UpdFrameOffset = ByteOff

-- | A convention maps a list of values (function arguments or return
--   values) to registers or stack locations.
data Convention

-- | top-level Haskell functions use <tt>NativeDirectCall</tt>, which maps
--   arguments to registers starting with R2, according to how many
--   registers are available on the platform. This convention ignores R1,
--   because for a top-level function call the function closure is
--   implicit, and doesn't need to be passed.
NativeDirectCall :: Convention

-- | non-top-level Haskell functions, which pass the address of the
--   function closure in R1 (regardless of whether R1 is a real register or
--   not), and the rest of the arguments in registers or on the stack.
NativeNodeCall :: Convention

-- | a native return. The convention for returns depends on how many values
--   are returned: for just one value returned, the appropriate register is
--   used (R1, F1, etc.). regardless of whether it is a real register or
--   not. For multiple values returned, they are mapped to registers or the
--   stack.
NativeReturn :: Convention

-- | Slow entry points: all args pushed on the stack
Slow :: Convention

-- | Entry to the garbage collector: uses the node reg! (TODO: I don't
--   think we need this --SDM)
GC :: Convention
data ForeignConvention
ForeignConvention :: CCallConv -> [ForeignHint] -> [ForeignHint] -> CmmReturnInfo -> ForeignConvention
data ForeignTarget
ForeignTarget :: CmmExpr -> ForeignConvention -> ForeignTarget
PrimTarget :: CallishMachOp -> ForeignTarget
foreignTargetHints :: ForeignTarget -> ([ForeignHint], [ForeignHint])
data CmmReturnInfo
CmmMayReturn :: CmmReturnInfo
CmmNeverReturns :: CmmReturnInfo
mapExp :: (CmmExpr -> CmmExpr) -> CmmNode e x -> CmmNode e x
mapExpDeep :: (CmmExpr -> CmmExpr) -> CmmNode e x -> CmmNode e x
wrapRecExp :: (CmmExpr -> CmmExpr) -> CmmExpr -> CmmExpr
foldExp :: (CmmExpr -> z -> z) -> CmmNode e x -> z -> z
foldExpDeep :: (CmmExpr -> z -> z) -> CmmNode e x -> z -> z
wrapRecExpf :: (CmmExpr -> z -> z) -> CmmExpr -> z -> z
mapExpM :: (CmmExpr -> Maybe CmmExpr) -> CmmNode e x -> Maybe (CmmNode e x)
mapExpDeepM :: (CmmExpr -> Maybe CmmExpr) -> CmmNode e x -> Maybe (CmmNode e x)
wrapRecExpM :: (CmmExpr -> Maybe CmmExpr) -> CmmExpr -> Maybe CmmExpr
mapSuccessors :: (Label -> Label) -> CmmNode O C -> CmmNode O C
mapCollectSuccessors :: forall a. (Label -> (Label, a)) -> CmmNode O C -> (CmmNode O C, [a])

-- | Tick scope identifier, allowing us to reason about what annotations in
--   a Cmm block should scope over. We especially take care to allow
--   optimisations to reorganise blocks without losing tick association in
--   the process.
data CmmTickScope

-- | The global scope is the "root" of the scope graph. Every scope is a
--   sub-scope of the global scope. It doesn't make sense to add ticks to
--   this scope. On the other hand, this means that setting this scope on a
--   block means no ticks apply to it.
GlobalScope :: CmmTickScope

-- | Constructs a new sub-scope to an existing scope. This allows us to
--   translate Core-style scoping rules (see <tt>tickishScoped</tt>) into
--   the Cmm world. Suppose the following code:
--   
--   tick<a>1</a> case ... of A -&gt; tick<a>2</a> ... B -&gt; tick<a>3</a>
--   ...
--   
--   We want the top-level tick annotation to apply to blocks generated for
--   the A and B alternatives. We can achieve that by generating
--   tick<a>1</a> into a block with scope a, while the code for
--   alternatives A and B gets generated into sub-scopes a/b and a/c
--   respectively.
SubScope :: !Unique -> CmmTickScope -> CmmTickScope

-- | A combined scope scopes over everything that the two given scopes
--   cover. It is therefore a sub-scope of either scope. This is required
--   for optimisations. Consider common block elimination:
--   
--   A -&gt; tick<a>2</a> case ... of C -&gt; [common] B -&gt; tick<a>3</a>
--   case ... of D -&gt; [common]
--   
--   We will generate code for the C and D alternatives, and figure out
--   afterwards that it's actually common code. Scoping rules dictate that
--   the resulting common block needs to be covered by both tick<a>2</a>
--   and tick<a>3</a>, therefore we need to construct a scope that is a
--   child to *both* scope. Now we can do that - if we assign the scopes
--   a<i>c and b</i>d to the common-ed up blocks, the new block could have
--   a combined tick scope a<i>c+b</i>d, which both tick<a>2</a> and
--   tick<a>3</a> apply to.
CombinedScope :: CmmTickScope -> CmmTickScope -> CmmTickScope

-- | Checks whether two tick scopes are sub-scopes of each other. True if
--   the two scopes are equal.
isTickSubScope :: CmmTickScope -> CmmTickScope -> Bool

-- | Combine two tick scopes. The new scope should be sub-scope of both
--   parameters. We simplify automatically if one tick scope is a sub-scope
--   of the other already.
combineTickScopes :: CmmTickScope -> CmmTickScope -> CmmTickScope
instance GHC.Classes.Eq GHC.Cmm.Node.Convention
instance GHC.Classes.Eq GHC.Cmm.Node.CmmReturnInfo
instance GHC.Classes.Eq GHC.Cmm.Node.ForeignConvention
instance GHC.Classes.Eq GHC.Cmm.Node.ForeignTarget
instance GHC.Classes.Eq (GHC.Cmm.Node.CmmNode e x)
instance GHC.Cmm.Dataflow.Graph.NonLocal GHC.Cmm.Node.CmmNode
instance GHC.Cmm.Expr.UserOfRegs GHC.Cmm.Expr.LocalReg (GHC.Cmm.Node.CmmNode e x)
instance GHC.Cmm.Expr.UserOfRegs GHC.Cmm.Expr.GlobalReg (GHC.Cmm.Node.CmmNode e x)
instance GHC.Cmm.Expr.DefinerOfRegs GHC.Cmm.Expr.LocalReg (GHC.Cmm.Node.CmmNode e x)
instance GHC.Cmm.Expr.DefinerOfRegs GHC.Cmm.Expr.GlobalReg (GHC.Cmm.Node.CmmNode e x)
instance GHC.Classes.Eq GHC.Cmm.Node.CmmTickScope
instance GHC.Classes.Ord GHC.Cmm.Node.CmmTickScope
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Node.CmmTickScope
instance (GHC.Classes.Ord r, GHC.Cmm.Expr.UserOfRegs r GHC.Cmm.Expr.CmmReg) => GHC.Cmm.Expr.UserOfRegs r GHC.Cmm.Node.ForeignTarget

module GHC.Platform.Regs

-- | Returns <a>True</a> if this global register is stored in a
--   caller-saves machine register.
callerSaves :: Platform -> GlobalReg -> Bool

-- | Here is where the STG register map is defined for each target arch.
--   The order matters (for the llvm backend anyway)! We must make sure to
--   maintain the order here with the order used in the LLVM calling
--   conventions. Note that also, this isn't all registers, just the ones
--   that are currently possibly mapped to real registers.
activeStgRegs :: Platform -> [GlobalReg]
haveRegBase :: Platform -> Bool
globalRegMaybe :: Platform -> GlobalReg -> Maybe RealReg
freeReg :: Platform -> RegNo -> Bool

module GHC.Platform.X86_64
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool
freeRegBase :: RegNo -> Bool


-- | An architecture independent description of a register. This needs to
--   stay architecture independent because it is used by NCGMonad and the
--   register allocators, which are shared by all architectures.
module GHC.Platform.Reg

-- | An identifier for a primitive real machine register.
type RegNo = Int

-- | A register, either virtual or real
data Reg
RegVirtual :: !VirtualReg -> Reg
RegReal :: !RealReg -> Reg
regPair :: RegNo -> RegNo -> Reg
regSingle :: RegNo -> Reg
realRegSingle :: RegNo -> RealReg
isRealReg :: Reg -> Bool
takeRealReg :: Reg -> Maybe RealReg
isVirtualReg :: Reg -> Bool
takeVirtualReg :: Reg -> Maybe VirtualReg
data VirtualReg
VirtualRegI :: {-# UNPACK #-} !Unique -> VirtualReg
VirtualRegHi :: {-# UNPACK #-} !Unique -> VirtualReg
VirtualRegF :: {-# UNPACK #-} !Unique -> VirtualReg
VirtualRegD :: {-# UNPACK #-} !Unique -> VirtualReg
renameVirtualReg :: Unique -> VirtualReg -> VirtualReg
classOfVirtualReg :: VirtualReg -> RegClass
getHiVirtualRegFromLo :: VirtualReg -> VirtualReg
getHiVRegFromLo :: Reg -> Reg

-- | RealRegs are machine regs which are available for allocation, in the
--   usual way. We know what class they are, because that's part of the
--   processor's architecture.
--   
--   RealRegPairs are pairs of real registers that are allocated together
--   to hold a larger value, such as with Double regs on SPARC.
data RealReg
RealRegSingle :: {-# UNPACK #-} !RegNo -> RealReg
RealRegPair :: {-# UNPACK #-} !RegNo -> {-# UNPACK #-} !RegNo -> RealReg
regNosOfRealReg :: RealReg -> [RegNo]
realRegsAlias :: RealReg -> RealReg -> Bool

-- | The patch function supplied by the allocator maps VirtualReg to
--   RealReg regs, but sometimes we want to apply it to plain old Reg.
liftPatchFnToRegReg :: (VirtualReg -> RealReg) -> Reg -> Reg
instance GHC.Show.Show GHC.Platform.Reg.VirtualReg
instance GHC.Classes.Eq GHC.Platform.Reg.VirtualReg
instance GHC.Classes.Ord GHC.Platform.Reg.RealReg
instance GHC.Show.Show GHC.Platform.Reg.RealReg
instance GHC.Classes.Eq GHC.Platform.Reg.RealReg
instance GHC.Show.Show GHC.Platform.Reg.Reg
instance GHC.Classes.Ord GHC.Platform.Reg.Reg
instance GHC.Classes.Eq GHC.Platform.Reg.Reg
instance GHC.Types.Unique.Uniquable GHC.Platform.Reg.Reg
instance GHC.Utils.Outputable.Outputable GHC.Platform.Reg.Reg
instance GHC.Types.Unique.Uniquable GHC.Platform.Reg.RealReg
instance GHC.Utils.Outputable.Outputable GHC.Platform.Reg.RealReg
instance GHC.Classes.Ord GHC.Platform.Reg.VirtualReg
instance GHC.Types.Unique.Uniquable GHC.Platform.Reg.VirtualReg
instance GHC.Utils.Outputable.Outputable GHC.Platform.Reg.VirtualReg


-- | An architecture independent description of a register's class.
module GHC.Platform.Reg.Class

-- | The class of a register. Used in the register allocator. We treat all
--   registers in a class as being interchangeable.
data RegClass
RcInteger :: RegClass
RcFloat :: RegClass
RcDouble :: RegClass
instance GHC.Classes.Eq GHC.Platform.Reg.Class.RegClass
instance GHC.Types.Unique.Uniquable GHC.Platform.Reg.Class.RegClass
instance GHC.Utils.Outputable.Outputable GHC.Platform.Reg.Class.RegClass

module GHC.Platform.X86
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool
freeRegBase :: RegNo -> Bool

module GHC.Platform.SPARC
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.S390X
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.RISCV64
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.PPC
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.NoRegs
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.ARM
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.AArch64
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Cmm.Switch

-- | A value of type SwitchTargets contains the alternatives for a
--   <tt>CmmSwitch</tt> value, and knows whether the value is signed, the
--   possible range, an optional default value and a map from values to
--   jump labels.
data SwitchTargets

-- | The smart constructor mkSwitchTargets normalises the map a bit: * No
--   entries outside the range * No entries equal to the default * No
--   default if all elements have explicit values
mkSwitchTargets :: Bool -> (Integer, Integer) -> Maybe Label -> Map Integer Label -> SwitchTargets

-- | Returns the list of non-default branches of the SwitchTargets value
switchTargetsCases :: SwitchTargets -> [(Integer, Label)]

-- | Return the default label of the SwitchTargets value
switchTargetsDefault :: SwitchTargets -> Maybe Label

-- | Return the range of the SwitchTargets value
switchTargetsRange :: SwitchTargets -> (Integer, Integer)

-- | Return whether this is used for a signed value
switchTargetsSigned :: SwitchTargets -> Bool

-- | Changes all labels mentioned in the SwitchTargets value
mapSwitchTargets :: (Label -> Label) -> SwitchTargets -> SwitchTargets

-- | switchTargetsToTable creates a dense jump table, usable for code
--   generation.
--   
--   Also returns an offset to add to the value; the list is 0-based on the
--   result of that addition.
--   
--   The conversion from Integer to Int is a bit of a wart, as the actual
--   scrutinee might be an unsigned word, but it just works, due to
--   wrap-around arithmetic (as verified by the CmmSwitchTest test case).
switchTargetsToTable :: SwitchTargets -> (Int, [Maybe Label])

-- | Groups cases with equal targets, suitable for pretty-printing to a
--   c-like switch statement with fall-through semantics.
switchTargetsFallThrough :: SwitchTargets -> ([([Integer], Label)], Maybe Label)

-- | The list of all labels occurring in the SwitchTargets value.
switchTargetsToList :: SwitchTargets -> [Label]

-- | Custom equality helper, needed for <a>GHC.Cmm.CommonBlockElim</a>
eqSwitchTargetWith :: (Label -> Label -> Bool) -> SwitchTargets -> SwitchTargets -> Bool

-- | A SwitchPlan abstractly describes how a Switch statement ought to be
--   implemented. See Note [createSwitchPlan]
data SwitchPlan
Unconditionally :: Label -> SwitchPlan
IfEqual :: Integer -> Label -> SwitchPlan -> SwitchPlan
IfLT :: Bool -> Integer -> SwitchPlan -> SwitchPlan -> SwitchPlan
JumpTable :: SwitchTargets -> SwitchPlan

-- | Does the backend support switch out of the box? Then leave this to the
--   backend!
backendSupportsSwitch :: Backend -> Bool

-- | This function creates a SwitchPlan from a SwitchTargets value,
--   breaking it down into smaller pieces suitable for code generation.
createSwitchPlan :: SwitchTargets -> SwitchPlan
instance GHC.Classes.Eq GHC.Cmm.Switch.SwitchTargets
instance GHC.Show.Show GHC.Cmm.Switch.SwitchTargets
instance GHC.Show.Show GHC.Cmm.Switch.SwitchPlan

module GHC.Cmm.Dataflow.Graph

-- | A (possibly empty) collection of closed/closed blocks
type Body n = LabelMap (Block n C C)

-- | A control-flow graph, which may take any of four shapes (O/O, O<i>C,
--   C</i>O, C/C). A graph open at the entry has a single, distinguished,
--   anonymous entry point; if a graph is closed at the entry, its entry
--   point(s) are supplied by a context.
type Graph = Graph' Block

-- | <tt>Graph'</tt> is abstracted over the block type, so that we can
--   build graphs of annotated blocks for example (Compiler.Hoopl.Dataflow
--   needs this).
data Graph' block (n :: Extensibility -> Extensibility -> Type) e x
[GNil] :: Graph' block n O O
[GUnit] :: block n O O -> Graph' block n O O
[GMany] :: MaybeO e (block n O C) -> Body' block n -> MaybeO x (block n C O) -> Graph' block n e x

-- | Gives access to the anchor points for nonlocal edges as well as the
--   edges themselves
class NonLocal thing
entryLabel :: NonLocal thing => thing C x -> Label
successors :: NonLocal thing => thing e C -> [Label]
addBlock :: (NonLocal block, HasDebugCallStack) => block C C -> LabelMap (block C C) -> LabelMap (block C C)
bodyList :: Body' block n -> [(Label, block n C C)]
emptyBody :: Body' block n
labelsDefined :: forall block n e x. NonLocal (block n) => Graph' block n e x -> LabelSet

-- | Maps over all nodes in a graph.
mapGraph :: (forall e x. n e x -> n' e x) -> Graph n e x -> Graph n' e x

-- | Function <a>mapGraphBlocks</a> enables a change of representation of
--   blocks, nodes, or both. It lifts a polymorphic block transform into a
--   polymorphic graph transform. When the block representation stabilizes,
--   a similar function should be provided for blocks.
mapGraphBlocks :: forall block n block' n' e x. (forall e x. block n e x -> block' n' e x) -> Graph' block n e x -> Graph' block' n' e x

-- | Returns a list of blocks reachable from the provided Labels in the
--   reverse postorder.
--   
--   This is the most important traversal over this data structure. It
--   drops unreachable code and puts blocks in an order that is good for
--   solving forward dataflow problems quickly. The reverse order is good
--   for solving backward dataflow problems quickly. The forward order is
--   also reasonably good for emitting instructions, except that it will
--   not usually exploit Forrest Baskett's trick of eliminating the
--   unconditional branch from a loop. For that you would need a more
--   serious analysis, probably based on dominators, to identify loop
--   headers.
--   
--   For forward analyses we want reverse postorder visitation, consider:
--   <tt> A -&gt; [B,C] B -&gt; D C -&gt; D </tt> Postorder: [D, C, B, A]
--   (or [D, B, C, A]) Reverse postorder: [A, B, C, D] (or [A, C, B, D])
--   This matters for, e.g., forward analysis, because we want to analyze
--   *both* B and C before we analyze D.
revPostorderFrom :: forall block. NonLocal block => LabelMap (block C C) -> Label -> [block C C]
instance GHC.Cmm.Dataflow.Graph.NonLocal n => GHC.Cmm.Dataflow.Graph.NonLocal (GHC.Cmm.Dataflow.Block.Block n)

module GHC.Core.UsageEnv
data Usage
Zero :: Usage
Bottom :: Usage
MUsage :: Mult -> Usage
data UsageEnv
addUE :: UsageEnv -> UsageEnv -> UsageEnv
addUsage :: Usage -> Usage -> Usage
bottomUE :: UsageEnv
deleteUE :: NamedThing n => UsageEnv -> n -> UsageEnv

-- | |lookupUE x env| returns the multiplicity assigned to |x| in |env|, if
--   |x| is not bound in |env|, then returns |Zero| or |Bottom|.
lookupUE :: NamedThing n => UsageEnv -> n -> Usage
scaleUE :: Mult -> UsageEnv -> UsageEnv
scaleUsage :: Mult -> Usage -> Usage
supUE :: UsageEnv -> UsageEnv -> UsageEnv
supUEs :: [UsageEnv] -> UsageEnv
unitUE :: NamedThing n => n -> Mult -> UsageEnv
zeroUE :: UsageEnv
instance GHC.Utils.Outputable.Outputable GHC.Core.UsageEnv.UsageEnv
instance GHC.Utils.Outputable.Outputable GHC.Core.UsageEnv.Usage

module GHC.Core.Lint

-- | Type-check a <a>CoreProgram</a>. See Note [Core Lint guarantee].
lintCoreBindings :: DynFlags -> CoreToDo -> [Var] -> CoreProgram -> WarnsAndErrs
lintUnfolding :: Bool -> DynFlags -> SrcLoc -> VarSet -> CoreExpr -> Maybe (Bag SDoc)
lintPassResult :: HscEnv -> CoreToDo -> CoreProgram -> IO ()
lintInteractiveExpr :: SDoc -> HscEnv -> CoreExpr -> IO ()
lintExpr :: DynFlags -> [Var] -> CoreExpr -> Maybe (Bag SDoc)

-- | This checks whether a pass correctly looks through debug annotations
--   (<tt>SourceNote</tt>). This works a bit different from other
--   consistency checks: We check this by running the given task twice,
--   noting all differences between the results.
lintAnnots :: SDoc -> (ModGuts -> CoreM ModGuts) -> ModGuts -> CoreM ModGuts
lintAxioms :: Logger -> DynFlags -> SDoc -> [CoAxiom Branched] -> IO ()
interactiveInScope :: InteractiveContext -> [Var]
endPass :: CoreToDo -> CoreProgram -> [CoreRule] -> CoreM ()
endPassIO :: HscEnv -> PrintUnqualified -> CoreToDo -> CoreProgram -> [CoreRule] -> IO ()
displayLintResults :: Logger -> DynFlags -> Bool -> SDoc -> SDoc -> WarnsAndErrs -> IO ()
dumpPassResult :: Logger -> DynFlags -> PrintUnqualified -> Maybe DumpFlag -> SDoc -> SDoc -> CoreProgram -> [CoreRule] -> IO ()
dumpIfSet :: Logger -> DynFlags -> Bool -> CoreToDo -> SDoc -> SDoc -> IO ()
instance GHC.Classes.Eq GHC.Core.Lint.StaticPtrCheck
instance GHC.Base.Functor GHC.Core.Lint.LintM
instance GHC.Base.Applicative GHC.Core.Lint.LintM
instance GHC.Base.Monad GHC.Core.Lint.LintM
instance Control.Monad.Fail.MonadFail GHC.Core.Lint.LintM
instance GHC.Driver.Session.HasDynFlags GHC.Core.Lint.LintM

module GHC.Core.Coercion.Opt

-- | optCoercion applies a substitution to a coercion, *and* optimises it
--   to reduce its size
optCoercion :: OptCoercionOpts -> TCvSubst -> Coercion -> NormalCo

-- | Check to make sure that an AxInstCo is internally consistent. Returns
--   the conflicting branch, if it exists See Note [Conflict checking with
--   AxiomInstCo]
checkAxInstCo :: Coercion -> Maybe CoAxBranch

-- | Coercion optimisation options
newtype OptCoercionOpts
OptCoercionOpts :: Bool -> OptCoercionOpts

-- | Enable coercion optimisation (reduce its size)
[optCoercionEnabled] :: OptCoercionOpts -> Bool


-- | Constant Folder
module GHC.Core.Opt.ConstantFold
primOpRules :: Name -> PrimOp -> Maybe CoreRule
builtinRules :: [CoreRule]

-- | Match the scrutinee of a case and potentially return a new scrutinee
--   and a function to apply to each literal alternative.
caseRules :: Platform -> CoreExpr -> Maybe (CoreExpr, AltCon -> Maybe AltCon, Id -> CoreExpr)
instance GHC.Base.Functor GHC.Core.Opt.ConstantFold.RuleM
instance GHC.Base.Applicative GHC.Core.Opt.ConstantFold.RuleM
instance GHC.Base.Monad GHC.Core.Opt.ConstantFold.RuleM
instance Control.Monad.Fail.MonadFail GHC.Core.Opt.ConstantFold.RuleM
instance GHC.Base.Alternative GHC.Core.Opt.ConstantFold.RuleM
instance GHC.Base.MonadPlus GHC.Core.Opt.ConstantFold.RuleM


-- | Adds cost-centers to call sites selected with the
--   <tt>-fprof-caller=...</tt> flag.
module GHC.Core.Opt.CallerCC
addCallerCostCentres :: ModGuts -> CoreM ModGuts
data CallerCcFilter
CallerCcFilter :: Maybe ModuleName -> NamePattern -> CallerCcFilter
[ccfModuleName] :: CallerCcFilter -> Maybe ModuleName
[ccfFuncName] :: CallerCcFilter -> NamePattern
data NamePattern
PChar :: Char -> NamePattern -> NamePattern
PWildcard :: NamePattern -> NamePattern
PEnd :: NamePattern
parseCallerCcFilter :: String -> Either String CallerCcFilter
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.CallerCC.CallerCcFilter
instance GHC.Utils.Binary.Binary GHC.Core.Opt.CallerCC.CallerCcFilter
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.CallerCC.NamePattern
instance GHC.Utils.Binary.Binary GHC.Core.Opt.CallerCC.NamePattern

module GHC.Settings.IO
data SettingsError
SettingsError_MissingData :: String -> SettingsError
SettingsError_BadData :: String -> SettingsError
initSettings :: forall m. MonadIO m => String -> ExceptT SettingsError m Settings

module GHC.Parser.CharClass
is_ident :: Char -> Bool
is_symbol :: Char -> Bool
is_any :: Char -> Bool
is_space :: Char -> Bool
is_lower :: Char -> Bool
is_upper :: Char -> Bool
is_digit :: Char -> Bool
is_alphanum :: Char -> Bool
is_decdigit :: Char -> Bool
is_hexdigit :: Char -> Bool
is_octdigit :: Char -> Bool
is_bindigit :: Char -> Bool
hexDigit :: Char -> Int
octDecDigit :: Char -> Int


-- | Bits and pieces on the bottom of the module dependency tree. Also
--   import the required constants, so we know what we're using.
--   
--   In the interests of cross-compilation, we want to free ourselves from
--   the autoconf generated modules like <a>GHC.Settings.Constants</a>
module GHC.CmmToAsm.SPARC.Base
wordLength :: Int
wordLengthInBits :: Int

-- | We need 8 bytes because our largest registers are 64 bit.
spillSlotSize :: Int

-- | We (allegedly) put the first six C-call arguments in registers; where
--   do we start putting the rest of them?
extraStackArgsHere :: Int

-- | Check whether an offset is representable with 13 bits.
fits13Bits :: Integral a => a -> Bool

-- | Check whether an integer will fit in 32 bits. A CmmInt is intended to
--   be truncated to the appropriate number of bits, so here we truncate it
--   to Int64. This is important because e.g. -1 as a CmmInt might be
--   either -1 or 18446744073709551615.
is32BitInteger :: Integer -> Bool

-- | Sadness.
largeOffsetError :: Show a => a -> b

module GHC.CmmToAsm.PPC.Cond
data Cond
ALWAYS :: Cond
EQQ :: Cond
GE :: Cond
GEU :: Cond
GTT :: Cond
GU :: Cond
LE :: Cond
LEU :: Cond
LTT :: Cond
LU :: Cond
NE :: Cond
condNegate :: Cond -> Cond
condUnsigned :: Cond -> Bool
instance GHC.Classes.Eq GHC.CmmToAsm.PPC.Cond.Cond


-- | Various utilities used in generating assembler.
--   
--   These are used not only by the native code generator, but also by the
--   <a>GHC.Driver.Pipeline</a>
module GHC.Utils.Asm

-- | Generate a section type (e.g. <tt>@progbits</tt>). See #13937.
sectionType :: Platform -> String -> SDoc


-- | Types for the general graph colorer.
module GHC.Data.Graph.Base

-- | A fn to check if a node is trivially colorable For graphs who's color
--   classes are disjoint then a node is 'trivially colorable' when it has
--   less neighbors and exclusions than available colors for that node.
--   
--   For graph's who's color classes overlap, ie some colors alias other
--   colors, then this can be a bit more tricky. There is a general way to
--   calculate this, but it's likely be too slow for use in the code. The
--   coloring algorithm takes a canned function which can be optimised by
--   the user to be specific to the specific graph being colored.
--   
--   for details, see "A Generalised Algorithm for Graph-Coloring Register
--   Allocation" Smith, Ramsey, Holloway - PLDI 2004.
type Triv k cls color = cls -> UniqSet k -> UniqSet color -> Bool

-- | The Interference graph. There used to be more fields, but they were
--   turfed out in a previous revision. maybe we'll want more later..
data Graph k cls color
Graph :: UniqFM k (Node k cls color) -> Graph k cls color

-- | All active nodes in the graph.
[graphMap] :: Graph k cls color -> UniqFM k (Node k cls color)

-- | An empty graph.
initGraph :: Graph k cls color

-- | Modify the finite map holding the nodes in the graph.
graphMapModify :: (UniqFM k (Node k cls color) -> UniqFM k (Node k cls color)) -> Graph k cls color -> Graph k cls color

-- | Graph nodes. Represents a thing that can conflict with another thing.
--   For the register allocater the nodes represent registers.
data Node k cls color
Node :: k -> cls -> Maybe color -> UniqSet k -> UniqSet color -> [color] -> UniqSet k -> Node k cls color

-- | A unique identifier for this node.
[nodeId] :: Node k cls color -> k

-- | The class of this node, determines the set of colors that can be used.
[nodeClass] :: Node k cls color -> cls

-- | The color of this node, if any.
[nodeColor] :: Node k cls color -> Maybe color

-- | Neighbors which must be colored differently to this node.
[nodeConflicts] :: Node k cls color -> UniqSet k

-- | Colors that cannot be used by this node.
[nodeExclusions] :: Node k cls color -> UniqSet color

-- | Colors that this node would prefer to be, in descending order.
[nodePreference] :: Node k cls color -> [color]

-- | Neighbors that this node would like to be colored the same as.
[nodeCoalesce] :: Node k cls color -> UniqSet k

-- | An empty node.
newNode :: k -> cls -> Node k cls color


-- | Like a <a>UniqDFM</a>, but maintains equivalence classes of keys
--   sharing the same entry. See <a>UniqSDFM</a>.
module GHC.Types.Unique.SDFM

-- | A <a>UniqDFM</a> whose domain is <i>sets</i> of <a>Unique</a>s, each
--   of which share a common value of type <tt>ele</tt>. Every such set
--   ("equivalence class") has a distinct representative <a>Unique</a>.
--   Supports merging the entries of multiple such sets in a union-find
--   like fashion.
--   
--   An accurate model is that of <tt>[(Set key, Maybe ele)]</tt>: A finite
--   mapping from sets of <tt>key</tt>s to possibly absent entries
--   <tt>ele</tt>, where the sets don't overlap. Example: <tt> m =
--   [({u1,u3}, Just ele1), ({u2}, Just ele2), ({u4,u7}, Nothing)] </tt> On
--   this model we support the following main operations:
--   
--   <ul>
--   <li><tt><a>lookupUSDFM</a> m u3 == Just ele1</tt>,
--   <tt><a>lookupUSDFM</a> m u4 == Nothing</tt>, <tt><a>lookupUSDFM</a> m
--   u5 == Nothing</tt>.</li>
--   <li><tt><a>equateUSDFM</a> m u1 u3</tt> is a no-op, but
--   <tt><a>equateUSDFM</a> m u1 u2</tt> merges <tt>{u1,u3}</tt> and
--   <tt>{u2}</tt> to point to <tt>Just ele2</tt> and returns the old entry
--   of <tt>{u1,u3}</tt>, <tt>Just ele1</tt>.</li>
--   <li><tt><a>addToUSDFM</a> m u3 ele4</tt> sets the entry of
--   <tt>{u1,u3}</tt> to <tt>Just ele4</tt>.</li>
--   </ul>
--   
--   As well as a few means for traversal/conversion to list.
data UniqSDFM key ele
emptyUSDFM :: UniqSDFM key ele

-- | <tt>lookupSUDFM env x</tt> looks up an entry for <tt>x</tt>, looking
--   through all <a>Indirect</a>s until it finds a shared <a>Entry</a>.
--   
--   Examples in terms of the model (see <a>UniqSDFM</a>): &gt;&gt;&gt;
--   lookupUSDFM [({u1,u3}, Just ele1), ({u2}, Just ele2)] u3 == Just ele1
--   &gt;&gt;&gt; lookupUSDFM [({u1,u3}, Just ele1), ({u2}, Just ele2)] u4
--   == Nothing &gt;&gt;&gt; lookupUSDFM [({u1,u3}, Just ele1), ({u2},
--   Nothing)] u2 == Nothing
lookupUSDFM :: Uniquable key => UniqSDFM key ele -> key -> Maybe ele

-- | <tt>equateUSDFM env x y</tt> makes <tt>x</tt> and <tt>y</tt> point to
--   the same entry, thereby merging <tt>x</tt>'s class with <tt>y</tt>'s.
--   If both <tt>x</tt> and <tt>y</tt> are in the domain of the map, then
--   <tt>y</tt>'s entry will be chosen as the new entry and <tt>x</tt>'s
--   old entry will be returned.
--   
--   Examples in terms of the model (see <a>UniqSDFM</a>): &gt;&gt;&gt;
--   equateUSDFM [] u1 u2 == (Nothing, [({u1,u2}, Nothing)]) &gt;&gt;&gt;
--   equateUSDFM [({u1,u3}, Just ele1)] u3 u4 == (Nothing, [({u1,u3,u4},
--   Just ele1)]) &gt;&gt;&gt; equateUSDFM [({u1,u3}, Just ele1)] u4 u3 ==
--   (Nothing, [({u1,u3,u4}, Just ele1)]) &gt;&gt;&gt; equateUSDFM
--   [({u1,u3}, Just ele1), ({u2}, Just ele2)] u3 u2 == (Just ele1,
--   [({u2,u1,u3}, Just ele2)])
equateUSDFM :: Uniquable key => UniqSDFM key ele -> key -> key -> (Maybe ele, UniqSDFM key ele)

-- | <tt>addToUSDFM env x a</tt> sets the entry <tt>x</tt> is associated
--   with to <tt>a</tt>, thereby modifying its whole equivalence class.
--   
--   Examples in terms of the model (see <a>UniqSDFM</a>): &gt;&gt;&gt;
--   addToUSDFM [] u1 ele1 == [({u1}, Just ele1)] &gt;&gt;&gt; addToUSDFM
--   [({u1,u3}, Just ele1)] u3 ele2 == [({u1,u3}, Just ele2)]
addToUSDFM :: Uniquable key => UniqSDFM key ele -> key -> ele -> UniqSDFM key ele
traverseUSDFM :: forall key a b f. Applicative f => (a -> f b) -> UniqSDFM key a -> f (UniqSDFM key b)
instance (GHC.Utils.Outputable.Outputable key, GHC.Utils.Outputable.Outputable ele) => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.SDFM.UniqSDFM key ele)
instance (GHC.Utils.Outputable.Outputable key, GHC.Utils.Outputable.Outputable ele) => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.SDFM.Shared key ele)


-- | The assignment of virtual registers to stack slots
module GHC.CmmToAsm.Reg.Linear.StackMap

-- | Identifier for a stack slot.
type StackSlot = Int
data StackMap
StackMap :: !Int -> UniqFM Unique StackSlot -> StackMap

-- | The slots that are still available to be allocated.
[stackMapNextFreeSlot] :: StackMap -> !Int

-- | Assignment of vregs to stack slots.
[stackMapAssignment] :: StackMap -> UniqFM Unique StackSlot

-- | An empty stack map, with all slots available.
emptyStackMap :: StackMap

-- | If this vreg unique already has a stack assignment then return the
--   slot number, otherwise allocate a new slot, and update the map.
getStackSlotFor :: StackMap -> Unique -> (StackMap, Int)

-- | Return the number of stack slots that were allocated
getStackUse :: StackMap -> Int


-- | Utils for calculating general worst, bound, squeese and free,
--   functions.
--   
--   as per: "A Generalized Algorithm for Graph-Coloring Register
--   Allocation" Michael Smith, Normal Ramsey, Glenn Holloway. PLDI 2004
--   
--   These general versions are not used in GHC proper because they are too
--   slow. Instead, hand written optimised versions are provided for each
--   architecture in MachRegs*.hs
--   
--   This code is here because we can test the architecture specific code
--   against it.
module GHC.CmmToAsm.Reg.Graph.Base
data RegClass
ClassG32 :: RegClass
ClassG16 :: RegClass
ClassG8 :: RegClass
ClassF64 :: RegClass

-- | A register of some class
data Reg
Reg :: RegClass -> Int -> Reg
RegSub :: RegSub -> Reg -> Reg

-- | A subcomponent of another register
data RegSub
SubL16 :: RegSub
SubL8 :: RegSub
SubL8H :: RegSub

-- | Worst case displacement
--   
--   a node N of classN has some number of neighbors, all of which are from
--   classC.
--   
--   (worst neighbors classN classC) is the maximum number of potential
--   colors for N that can be lost by coloring its neighbors.
--   
--   This should be hand coded/cached for each particular architecture,
--   because the compute time is very long..
worst :: (RegClass -> UniqSet Reg) -> (Reg -> UniqSet Reg) -> Int -> RegClass -> RegClass -> Int

-- | For a node N of classN and neighbors of classesC (bound classN
--   classesC) is the maximum number of potential colors for N that can be
--   lost by coloring its neighbors.
bound :: (RegClass -> UniqSet Reg) -> (Reg -> UniqSet Reg) -> RegClass -> [RegClass] -> Int

-- | The total squeese on a particular node with a list of neighbors.
--   
--   A version of this should be constructed for each particular
--   architecture, possibly including uses of bound, so that aliased
--   registers don't get counted twice, as per the paper.
squeese :: (RegClass -> UniqSet Reg) -> (Reg -> UniqSet Reg) -> RegClass -> [(Int, RegClass)] -> Int
instance GHC.Enum.Enum GHC.CmmToAsm.Reg.Graph.Base.RegClass
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Graph.Base.RegClass
instance GHC.Show.Show GHC.CmmToAsm.Reg.Graph.Base.RegClass
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Graph.Base.RegSub
instance GHC.Classes.Ord GHC.CmmToAsm.Reg.Graph.Base.RegSub
instance GHC.Enum.Enum GHC.CmmToAsm.Reg.Graph.Base.RegSub
instance GHC.Show.Show GHC.CmmToAsm.Reg.Graph.Base.RegSub
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Graph.Base.Reg
instance GHC.Show.Show GHC.CmmToAsm.Reg.Graph.Base.Reg
instance GHC.Types.Unique.Uniquable GHC.CmmToAsm.Reg.Graph.Base.Reg


-- | A description of the register set of the X86.
--   
--   This isn't used directly in GHC proper.
--   
--   See RegArchBase.hs for the reference. See MachRegs.hs for the actual
--   trivColorable function used in GHC.
module GHC.CmmToAsm.Reg.Graph.X86

-- | Determine the class of a register
classOfReg :: Reg -> RegClass

-- | Determine all the regs that make up a certain class.
regsOfClass :: RegClass -> UniqSet Reg

-- | Determine the common name of a reg returns Nothing if this reg is not
--   part of the machine.
regName :: Reg -> Maybe String

-- | Which regs alias what other regs.
regAlias :: Reg -> UniqSet Reg

-- | Optimised versions of RegColorBase.{worst, squeese} specific to x86
worst :: Int -> RegClass -> RegClass -> Int
squeese :: RegClass -> [(Int, RegClass)] -> Int

module GHC.CmmToAsm.Reg.Utils
toRegMap :: UniqFM VirtualReg elt -> UniqFM Reg elt
toVRegMap :: UniqFM Reg elt -> UniqFM VirtualReg elt

module GHC.CmmToAsm.Reg.Graph.TrivColorable
trivColorable :: Platform -> (RegClass -> VirtualReg -> Int) -> (RegClass -> RealReg -> Int) -> Triv VirtualReg RegClass RealReg


-- | Pretty printing of graphs.
module GHC.Data.Graph.Ppr

-- | Pretty print a graph in a somewhat human readable format.
dumpGraph :: (Outputable k, Outputable color) => Graph k cls color -> SDoc

-- | Pretty print a graph in graphviz .dot format. Conflicts get solid
--   edges. Coalescences get dashed edges.
dotGraph :: (Uniquable k, Outputable k, Outputable cls, Outputable color) => (color -> SDoc) -> Triv k cls color -> Graph k cls color -> SDoc


-- | Basic operations on graphs.
module GHC.Data.Graph.Ops

-- | Add a node to the graph, linking up its edges
addNode :: Uniquable k => k -> Node k cls color -> Graph k cls color -> Graph k cls color

-- | Delete a node and all its edges from the graph.
delNode :: Uniquable k => k -> Graph k cls color -> Maybe (Graph k cls color)

-- | Get a node from the graph, throwing an error if it's not there
getNode :: Uniquable k => Graph k cls color -> k -> Node k cls color

-- | Lookup a node from the graph.
lookupNode :: Uniquable k => Graph k cls color -> k -> Maybe (Node k cls color)

-- | Modify a node in the graph. returns Nothing if the node isn't present.
modNode :: Uniquable k => (Node k cls color -> Node k cls color) -> k -> Graph k cls color -> Maybe (Graph k cls color)

-- | Get the size of the graph, O(n)
size :: Graph k cls color -> Int

-- | Union two graphs together.
union :: Graph k cls color -> Graph k cls color -> Graph k cls color

-- | Add a conflict between nodes to the graph, creating the nodes
--   required. Conflicts are virtual regs which need to be colored
--   differently.
addConflict :: Uniquable k => (k, cls) -> (k, cls) -> Graph k cls color -> Graph k cls color

-- | Delete a conflict edge. k1 -&gt; k2 returns Nothing if the node isn't
--   in the graph
delConflict :: Uniquable k => k -> k -> Graph k cls color -> Maybe (Graph k cls color)

-- | Add some conflicts to the graph, creating nodes if required. All the
--   nodes in the set are taken to conflict with each other.
addConflicts :: Uniquable k => UniqSet k -> (k -> cls) -> Graph k cls color -> Graph k cls color

-- | Add a coalescence edge to the graph, creating nodes if required. It is
--   considered adventageous to assign the same color to nodes in a
--   coalesence.
addCoalesce :: Uniquable k => (k, cls) -> (k, cls) -> Graph k cls color -> Graph k cls color

-- | Delete a coalescence edge (k1 -&gt; k2) from the graph.
delCoalesce :: Uniquable k => k -> k -> Graph k cls color -> Maybe (Graph k cls color)

-- | Add an exclusion to the graph, creating nodes if required. These are
--   extra colors that the node cannot use.
addExclusion :: (Uniquable k, Uniquable color) => k -> (k -> cls) -> color -> Graph k cls color -> Graph k cls color
addExclusions :: (Uniquable k, Uniquable color) => k -> (k -> cls) -> [color] -> Graph k cls color -> Graph k cls color

-- | Add a color preference to the graph, creating nodes if required. The
--   most recently added preference is the most preferred. The algorithm
--   tries to assign a node it's preferred color if possible.
addPreference :: Uniquable k => (k, cls) -> color -> Graph k cls color -> Graph k cls color

-- | Coalesce this pair of nodes unconditionally / aggressively. The
--   resulting node is the one with the least key.
--   
--   returns: Just the pair of keys if the nodes were coalesced the second
--   element of the pair being the least one
--   
--   Nothing if either of the nodes weren't in the graph
coalesceNodes :: (Uniquable k, Ord k, Eq cls) => Bool -> Triv k cls color -> Graph k cls color -> (k, k) -> (Graph k cls color, Maybe (k, k))

-- | Do aggressive coalescing on this graph. returns the new graph and the
--   list of pairs of nodes that got coalesced together. for each pair, the
--   resulting node will have the least key and be second in the pair.
coalesceGraph :: (Uniquable k, Ord k, Eq cls, Outputable k) => Bool -> Triv k cls color -> Graph k cls color -> (Graph k cls color, [(k, k)])

-- | Freeze a node This is for the iterative coalescer. By freezing a node
--   we give up on ever coalescing it. Move all its coalesce edges into the
--   frozen set - and update back edges from other nodes.
freezeNode :: Uniquable k => k -> Graph k cls color -> Graph k cls color

-- | Freeze one node in the graph This if for the iterative coalescer. Look
--   for a move related node of low degree and freeze it.
--   
--   We probably don't need to scan the whole graph looking for the node of
--   absolute lowest degree. Just sample the first few and choose the one
--   with the lowest degree out of those. Also, we don't make any
--   distinction between conflicts of different classes.. this is just a
--   heuristic, after all.
--   
--   IDEA: freezing a node might free it up for Simplify.. would be good to
--   check for triv right here, and add it to a worklist if known
--   triv/non-move nodes.
freezeOneInGraph :: Uniquable k => Graph k cls color -> (Graph k cls color, Bool)

-- | Freeze all the nodes in the graph for debugging the iterative
--   allocator.
freezeAllInGraph :: Uniquable k => Graph k cls color -> Graph k cls color

-- | Find all the nodes in the graph that meet some criteria
scanGraph :: (Node k cls color -> Bool) -> Graph k cls color -> [Node k cls color]

-- | Set the color of a certain node
setColor :: Uniquable k => k -> color -> Graph k cls color -> Graph k cls color

-- | validate the internal structure of a graph all its edges should point
--   to valid nodes If they don't then throw an error
validateGraph :: (Uniquable k, Outputable k, Eq color) => SDoc -> Bool -> Graph k cls color -> Graph k cls color

-- | Slurp out a map of how many nodes had a certain number of conflict
--   neighbours
slurpNodeConflictCount :: Graph k cls color -> UniqFM Int (Int, Int)


-- | Graph Coloring. This is a generic graph coloring library, abstracted
--   over the type of the node keys, nodes and colors.
module GHC.Data.Graph.Color

-- | Try to color a graph with this set of colors. Uses Chaitin's algorithm
--   to color the graph. The graph is scanned for nodes which are deamed
--   'trivially colorable'. These nodes are pushed onto a stack and removed
--   from the graph. Once this process is complete the graph can be colored
--   by removing nodes from the stack (ie in reverse order) and assigning
--   them colors different to their neighbors.
colorGraph :: forall k cls color. (Uniquable k, Uniquable cls, Uniquable color, Eq cls, Ord k, Outputable k, Outputable cls, Outputable color) => Bool -> Int -> UniqFM cls (UniqSet color) -> Triv k cls color -> (Graph k cls color -> k) -> Graph k cls color -> (Graph k cls color, UniqSet k, UniqFM k k)


-- | Linking Haskell units
module GHC.Linker.Unit
collectLinkOpts :: DynFlags -> [UnitInfo] -> ([String], [String], [String])
collectArchives :: DynFlags -> UnitInfo -> IO [FilePath]

-- | Find all the link options in these and the preload packages, returning
--   (package hs lib options, extra library options, other flags)
getUnitLinkOpts :: DynFlags -> UnitEnv -> [UnitId] -> IO ([String], [String], [String])
getLibs :: DynFlags -> UnitEnv -> [UnitId] -> IO [(String, String)]

module GHC.SysTools.Process

-- | Enable process jobs support on Windows if it can be expected to work
--   (e.g. <tt>process &gt;= 1.6.9.0</tt>).
enableProcessJobs :: CreateProcess -> CreateProcess
readCreateProcessWithExitCode' :: CreateProcess -> IO (ExitCode, String)
replaceVar :: (String, String) -> [(String, String)] -> [(String, String)]

-- | Version of <tt>System.Process.readProcessWithExitCode</tt> that takes
--   a key-value tuple to insert into the environment.
readProcessEnvWithExitCode :: String -> [String] -> (String, String) -> IO (ExitCode, String, String)
c_locale_env :: (String, String)
getGccEnv :: [Option] -> IO (Maybe [(String, String)])
runSomething :: Logger -> DynFlags -> String -> String -> [Option] -> IO ()

-- | Run a command, placing the arguments in an external response file.
--   
--   This command is used in order to avoid overlong command line arguments
--   on Windows. The command line arguments are first written to an
--   external, temporary response file, and then passed to the linker via
--   @filepath. response files for passing them in. See:
--   
--   <a>https://gcc.gnu.org/wiki/Response_Files</a>
--   <a>https://gitlab.haskell.org/ghc/ghc/issues/10777</a>
runSomethingResponseFile :: Logger -> TmpFs -> DynFlags -> (String -> String) -> String -> String -> [Option] -> Maybe [(String, String)] -> IO ()
runSomethingFiltered :: Logger -> DynFlags -> (String -> String) -> String -> String -> [Option] -> Maybe FilePath -> Maybe [(String, String)] -> IO ()
runSomethingWith :: Logger -> DynFlags -> String -> String -> [Option] -> ([String] -> IO (ExitCode, a)) -> IO a
handleProc :: String -> String -> IO (ExitCode, r) -> IO r
builderMainLoop :: Logger -> DynFlags -> (String -> String) -> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO ExitCode
readerProc :: Chan BuildMessage -> Handle -> (String -> String) -> IO ()
parseError :: String -> Maybe (String, Int, Int, String)

-- | Break a line of an error message into a filename and the rest of the
--   line, taking care to ignore colons in Windows drive letters (as noted
--   in #17786). For instance,
--   
--   <ul>
--   <li><tt>"hi.c: ABCD"</tt> is mapped to <tt>Just ("hi.c",
--   "ABCD")</tt></li>
--   <li><tt>"C:\hi.c: ABCD"</tt> is mapped to <tt>Just ("C:\hi.c",
--   "ABCD")</tt></li>
--   </ul>
breakColon :: String -> Maybe (String, String)
breakIntColon :: String -> Maybe (Int, String)
data BuildMessage
BuildMsg :: !SDoc -> BuildMessage
BuildError :: !SrcLoc -> !SDoc -> BuildMessage
EOF :: BuildMessage
linesPlatform :: String -> [String]

module GHC.SysTools.Info
neededLinkArgs :: LinkerInfo -> [Option]
getLinkerInfo :: Logger -> DynFlags -> IO LinkerInfo
getLinkerInfo' :: Logger -> DynFlags -> IO LinkerInfo
getCompilerInfo :: Logger -> DynFlags -> IO CompilerInfo
getCompilerInfo' :: Logger -> DynFlags -> IO CompilerInfo

module GHC.SysTools.Elf

-- | Given a section name, read its contents as a ByteString.
--   
--   If the section isn't found or if there is any parsing error, we return
--   Nothing
readElfSectionByName :: Logger -> DynFlags -> ByteString -> String -> IO (Maybe ByteString)

-- | read a Note as a String
--   
--   If you try to read a note from a section which does not support the
--   Note format, the parsing is likely to fail and Nothing will be
--   returned
readElfNoteAsString :: Logger -> DynFlags -> FilePath -> String -> String -> IO (Maybe String)

-- | Generate the GAS code to create a Note section
--   
--   Header fields for notes are 32-bit long (see Note [ELF
--   specification]).
makeElfNote :: Platform -> String -> String -> Word32 -> String -> SDoc


-- | Statistics for per-module compilations
--   
--   (c) The GRASP/AQUA Project, Glasgow University, 1993-1998
module GHC.Hs.Stats

-- | Source Statistics
ppSourceStats :: Bool -> Located HsModule -> SDoc


-- | Generating C symbol names emitted by the compiler.
module GHC.CmmToAsm.CPrim
atomicReadLabel :: Width -> String
atomicWriteLabel :: Width -> String
atomicRMWLabel :: Width -> AtomicMachOp -> String
cmpxchgLabel :: Width -> String
xchgLabel :: Width -> String
popCntLabel :: Width -> String
pdepLabel :: Width -> String
pextLabel :: Width -> String
bSwapLabel :: Width -> String
bRevLabel :: Width -> String
clzLabel :: Width -> String
ctzLabel :: Width -> String
word2FloatLabel :: Width -> String

module GHC.Data.Bitmap

-- | A bitmap represented by a sequence of <a>StgWord</a>s on the
--   <i>target</i> architecture. These are used for bitmaps in info tables
--   and other generated code which need to be emitted as sequences of
--   StgWords.
type Bitmap = [StgWord]

-- | Make a bitmap from a sequence of bits
mkBitmap :: Platform -> [Bool] -> Bitmap

-- | Make a bitmap where the slots specified are the <i>zeros</i> in the
--   bitmap. eg. <tt>[0,1,3], size 4 ==&gt; 0x4</tt> (we leave any bits
--   outside the size as zero, just to make the bitmap easier to read).
--   
--   The list of <tt>Int</tt>s <i>must</i> be already sorted and
--   duplicate-free.
intsToReverseBitmap :: Platform -> Int -> [Int] -> Bitmap

-- | Magic number, must agree with <tt>BITMAP_BITS_SHIFT</tt> in
--   InfoTables.h. Some kinds of bitmap pack a size/bitmap into a single
--   word if possible, or fall back to an external pointer when the bitmap
--   is too large. This value represents the largest size of bitmap that
--   can be packed into a single word.
mAX_SMALL_BITMAP_SIZE :: Platform -> Int


-- | This module manages storing the various GHC option flags in a modules
--   interface file as part of the recompilation checking infrastructure.
module GHC.Iface.Recomp.Flags

-- | Produce a fingerprint of a <tt>DynFlags</tt> value. We only base the
--   finger print on important fields in <tt>DynFlags</tt> so that the
--   recompilation checker can use this fingerprint.
--   
--   NB: The <a>Module</a> parameter is the <a>Module</a> recorded by the
--   *interface* file, not the actual <a>Module</a> according to our
--   <a>DynFlags</a>.
fingerprintDynFlags :: HscEnv -> Module -> (BinHandle -> Name -> IO ()) -> IO Fingerprint
fingerprintOptFlags :: DynFlags -> (BinHandle -> Name -> IO ()) -> IO Fingerprint
fingerprintHpcFlags :: DynFlags -> (BinHandle -> Name -> IO ()) -> IO Fingerprint


-- | Contains a debug function to dump parts of the GHC.Hs AST. It uses a
--   syb traversal which falls back to displaying based on the constructor
--   name, so can be used to dump anything having a <tt>Data.Data</tt>
--   instance.
module GHC.Hs.Dump

-- | Show a GHC syntax tree. This parameterised because it is also used for
--   comparing ASTs in ppr roundtripping tests, where the SrcSpan's are
--   blanked out, to avoid comparing locations, only structure
showAstData :: Data a => BlankSrcSpan -> BlankEpAnnotations -> a -> SDoc
data BlankSrcSpan
BlankSrcSpan :: BlankSrcSpan
BlankSrcSpanFile :: BlankSrcSpan
NoBlankSrcSpan :: BlankSrcSpan
data BlankEpAnnotations
BlankEpAnnotations :: BlankEpAnnotations
NoBlankEpAnnotations :: BlankEpAnnotations
instance GHC.Show.Show GHC.Hs.Dump.BlankSrcSpan
instance GHC.Classes.Eq GHC.Hs.Dump.BlankSrcSpan
instance GHC.Show.Show GHC.Hs.Dump.BlankEpAnnotations
instance GHC.Classes.Eq GHC.Hs.Dump.BlankEpAnnotations

module GHC.Core.TyCon.Set
type TyConSet = UniqSet TyCon
emptyTyConSet :: TyConSet
unitTyConSet :: TyCon -> TyConSet
mkTyConSet :: [TyCon] -> TyConSet
unionTyConSet :: TyConSet -> TyConSet -> TyConSet
unionTyConSets :: [TyConSet] -> TyConSet
minusTyConSet :: TyConSet -> TyConSet -> TyConSet
elemTyConSet :: TyCon -> TyConSet -> Bool
extendTyConSet :: TyConSet -> TyCon -> TyConSet
extendTyConSetList :: TyConSet -> [TyCon] -> TyConSet
delFromTyConSet :: TyConSet -> TyCon -> TyConSet
delListFromTyConSet :: TyConSet -> [TyCon] -> TyConSet
isEmptyTyConSet :: TyConSet -> Bool
filterTyConSet :: (TyCon -> Bool) -> TyConSet -> TyConSet

-- | True if there is a non-empty intersection. <tt>s1
--   <a>intersectsTyConSet</a> s2</tt> doesn't compute <tt>s2</tt> if
--   <tt>s1</tt> is empty
intersectsTyConSet :: TyConSet -> TyConSet -> Bool
disjointTyConSet :: TyConSet -> TyConSet -> Bool
intersectTyConSet :: TyConSet -> TyConSet -> TyConSet
nameSetAny :: (TyCon -> Bool) -> TyConSet -> Bool
nameSetAll :: (TyCon -> Bool) -> TyConSet -> Bool

module GHC.Stg.Subst

-- | A renaming substitution from <a>Id</a>s to <a>Id</a>s. Like
--   <a>RnEnv2</a>, but not maintaining pairs of substitutions. Like
--   <a>Subst</a>, but with the domain being <a>Id</a>s instead of entire
--   <tt>CoreExpr</tt>.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> Subst
type IdSubstEnv = IdEnv Id

-- | <pre>
--   emptySubst = <a>mkEmptySubst</a> <a>emptyInScopeSet</a>
--   </pre>
emptySubst :: Subst

-- | Constructs a new <a>Subst</a> assuming the variables in the given
--   <a>InScopeSet</a> are in scope.
mkEmptySubst :: InScopeSet -> Subst

-- | Substitutes an <a>Id</a> for another one according to the <a>Subst</a>
--   given in a way that avoids shadowing the <a>InScopeSet</a>, returning
--   the result and an updated <a>Subst</a> that should be used by
--   subsequent substitutions.
substBndr :: Id -> Subst -> (Id, Subst)

-- | <pre>
--   substBndrs = runState . traverse (state . substBndr)
--   </pre>
substBndrs :: Traversable f => f Id -> Subst -> (f Id, Subst)

-- | Substitutes an occurrence of an identifier for its counterpart
--   recorded in the <a>Subst</a>.
lookupIdSubst :: HasCallStack => Id -> Subst -> Id

-- | Substitutes an occurrence of an identifier for its counterpart
--   recorded in the <a>Subst</a>. Does not generate a debug warning if the
--   identifier to to substitute wasn't in scope.
noWarnLookupIdSubst :: HasCallStack => Id -> Subst -> Id

-- | Add the <a>Id</a> to the in-scope set and remove any existing
--   substitutions for it.
extendInScope :: Id -> Subst -> Subst

-- | Add a substitution for an <a>Id</a> to the <a>Subst</a>: you must
--   ensure that the in-scope set is such that TyCoSubst Note [The
--   substitution invariant] holds after extending the substitution like
--   this.
extendSubst :: Id -> Id -> Subst -> Subst

module GHC.Data.Graph.UnVar
data UnVarSet
emptyUnVarSet :: UnVarSet
mkUnVarSet :: [Var] -> UnVarSet
varEnvDom :: VarEnv a -> UnVarSet
unionUnVarSet :: UnVarSet -> UnVarSet -> UnVarSet
unionUnVarSets :: [UnVarSet] -> UnVarSet
extendUnVarSet :: Var -> UnVarSet -> UnVarSet
delUnVarSet :: UnVarSet -> Var -> UnVarSet
elemUnVarSet :: Var -> UnVarSet -> Bool
isEmptyUnVarSet :: UnVarSet -> Bool
data UnVarGraph
emptyUnVarGraph :: UnVarGraph
unionUnVarGraph :: UnVarGraph -> UnVarGraph -> UnVarGraph
unionUnVarGraphs :: [UnVarGraph] -> UnVarGraph
completeGraph :: UnVarSet -> UnVarGraph
completeBipartiteGraph :: UnVarSet -> UnVarSet -> UnVarGraph
neighbors :: UnVarGraph -> Var -> UnVarSet
hasLoopAt :: UnVarGraph -> Var -> Bool
delNode :: UnVarGraph -> Var -> UnVarGraph
instance GHC.Classes.Eq GHC.Data.Graph.UnVar.UnVarSet
instance GHC.Utils.Outputable.Outputable GHC.Data.Graph.UnVar.UnVarGraph
instance GHC.Utils.Outputable.Outputable GHC.Data.Graph.UnVar.UnVarSet

module GHC.Core.Opt.StaticArgs
doStaticArgs :: UniqSupply -> CoreProgram -> CoreProgram

module GHC.Core.Tidy
tidyExpr :: TidyEnv -> CoreExpr -> CoreExpr
tidyRules :: TidyEnv -> [CoreRule] -> [CoreRule]
tidyUnfolding :: TidyEnv -> Unfolding -> Unfolding -> Unfolding

module GHC.Stg.Stats
showStgStats :: [StgTopBinding] -> String
instance GHC.Classes.Ord GHC.Stg.Stats.CounterType
instance GHC.Classes.Eq GHC.Stg.Stats.CounterType


-- | Non-global free variable analysis on STG terms. This pass annotates
--   non-top-level closure bindings with captured variables. Global
--   variables are not captured. For example, in a top-level binding like
--   (pseudo-STG)
--   
--   f = [x,y] . let g = [p] . reverse (x ++ p) in g y
--   
--   In g, <a>reverse</a> and <a>(++)</a> are global variables so they're
--   not considered free. <tt>p</tt> is an argument, so <tt>x</tt> is the
--   only actual free variable here. The annotated version is thus:
--   
--   f = [x,y] . let g = [x] [p] . reverse (x ++ p) in g y
--   
--   Note that non-top-level recursive bindings are also considered free
--   within the group:
--   
--   map = {} r [f xs0] let { Rec { go = {f, go} r [xs1] case xs1 of { []
--   -&gt; [] []; : x xs2 -&gt; let { xs' = {go, xs2} u [] go xs2; } in let
--   { x' = {f, x} u [] f x; } in : [x' xs']; }; end Rec } } in go xs0;
--   
--   Here go is free in its RHS.
--   
--   Top-level closure bindings never capture variables as all of their
--   free variables are global.
module GHC.Stg.FVs

-- | Annotates a top-level STG binding group with its free variables.
annTopBindingsFreeVars :: [StgTopBinding] -> [CgStgTopBinding]

-- | Annotates an STG binding with its free variables.
annBindingFreeVars :: StgBinding -> CgStgBinding

module GHC.Stg.DepAnal

-- | Dependency sort a STG program so that dependencies come before uses.
depSortStgPgm :: Module -> [StgTopBinding] -> [StgTopBinding]

module GHC.Stg.Debug
collectDebugInformation :: DynFlags -> ModLocation -> [StgTopBinding] -> ([StgTopBinding], InfoTableProvMap)

module GHC.CoreToStg
coreToStg :: DynFlags -> Module -> ModLocation -> CoreProgram -> ([StgTopBinding], InfoTableProvMap, CollectedCCs)
instance GHC.Classes.Eq GHC.CoreToStg.LetInfo
instance GHC.Classes.Eq GHC.CoreToStg.HowBound
instance GHC.Base.Functor GHC.CoreToStg.CtsM
instance GHC.Base.Applicative GHC.CoreToStg.CtsM
instance GHC.Base.Monad GHC.CoreToStg.CtsM
instance GHC.Driver.Session.HasDynFlags GHC.CoreToStg.CtsM


-- | Hides away distracting bookkeeping while lambda lifting into a
--   <a>LiftM</a> monad.
module GHC.Stg.Lift.Monad

-- | <pre>
--   uncurry <a>mkStgBinding</a> . <a>decomposeStgBinding</a> = id
--   </pre>
decomposeStgBinding :: GenStgBinding pass -> (RecFlag, [(BinderP pass, GenStgRhs pass)])
mkStgBinding :: RecFlag -> [(BinderP pass, GenStgRhs pass)] -> GenStgBinding pass

-- | Environment threaded around in a scoped, <tt>Reader</tt>-like fashion.
data Env
Env :: !DynFlags -> !Subst -> !IdEnv DIdSet -> Env

-- | Read-only.
[e_dflags] :: Env -> !DynFlags

-- | We need to track the renamings of local <a>InId</a>s to their lifted
--   <a>OutId</a>, because shadowing might make a closure's free variables
--   unavailable at its call sites. Consider: <tt> let f y = x + y in let x
--   = 4 in f x </tt> Here, <tt>f</tt> can't be lifted to top-level,
--   because its free variable <tt>x</tt> isn't available at its call site.
[e_subst] :: Env -> !Subst

-- | Lifted <a>Id</a>s don't occur as free variables in any closure
--   anymore, because they are bound at the top-level. Every occurrence
--   must supply the formerly free variables of the lifted <a>Id</a>, so
--   they in turn become free variables of the call sites. This environment
--   tracks this expansion from lifted <a>Id</a>s to their free variables.
--   
--   <a>InId</a>s to <a>OutId</a>s.
--   
--   Invariant: <a>Id</a>s not present in this map won't be substituted.
[e_expansions] :: Env -> !IdEnv DIdSet

-- | We need to detect when we are lifting something out of the RHS of a
--   recursive binding (c.f. <a>GHC.Stg.Lift.Monad#floats</a>), in which
--   case that binding needs to be added to the same top-level recursive
--   group. This requires we detect a certain nesting structure, which is
--   encoded by <a>StartBindingGroup</a> and <a>EndBindingGroup</a>.
--   
--   Although <a>collectFloats</a> will only ever care if the current
--   binding to be lifted (through <a>LiftedBinding</a>) will occur inside
--   such a binding group or not, e.g. doesn't care about the nesting level
--   as long as its greater than 0.
data FloatLang
StartBindingGroup :: FloatLang
EndBindingGroup :: FloatLang
PlainTopBinding :: OutStgTopBinding -> FloatLang
LiftedBinding :: OutStgBinding -> FloatLang

-- | Flattens an expression in <tt>[<a>FloatLang</a>]</tt> into an STG
--   program, see <a>GHC.Stg.Lift.Monad#floats</a>. Important
--   pre-conditions: The nesting of opening <tt>StartBindinGroup</tt>s and
--   closing <tt>EndBindinGroup</tt>s is balanced. Also, it is crucial that
--   every binding group has at least one recursive binding inside.
--   Otherwise there's no point in announcing the binding group in the
--   first place and an <tt>ASSERT</tt> will trigger.
collectFloats :: [FloatLang] -> [OutStgTopBinding]

-- | The analysis monad consists of the following <a>RWST</a> components:
--   
--   <ul>
--   <li><a>Env</a>: Reader-like context. Contains a substitution, info
--   about how how lifted identifiers are to be expanded into applications
--   and details such as <a>DynFlags</a>.</li>
--   <li><tt><a>OrdList</a> <a>FloatLang</a></tt>: Writer output for the
--   resulting STG program.</li>
--   <li>No pure state component</li>
--   <li>But wrapping around <a>UniqSM</a> for generating fresh lifted
--   binders. (The <tt>uniqAway</tt> approach could give the same name to
--   two different lifted binders, so this is necessary.)</li>
--   </ul>
data LiftM a
runLiftM :: DynFlags -> UniqSupply -> LiftM () -> [OutStgTopBinding]

-- | Starts a recursive binding group. See <a>GHC.Stg.Lift.Monad#floats</a>
--   and <a>collectFloats</a>.
startBindingGroup :: LiftM ()

-- | Ends a recursive binding group. See <a>GHC.Stg.Lift.Monad#floats</a>
--   and <a>collectFloats</a>.
endBindingGroup :: LiftM ()

-- | Writes a plain <a>StgTopStringLit</a> to the output.
addTopStringLit :: OutId -> ByteString -> LiftM ()

-- | Lifts a binding to top-level. Depending on whether it's declared
--   inside a recursive RHS (see <a>GHC.Stg.Lift.Monad#floats</a> and
--   <a>collectFloats</a>), this might be added to an existing recursive
--   top-level binding group.
addLiftedBinding :: OutStgBinding -> LiftM ()

-- | Takes a binder and a continuation which is called with the substituted
--   binder. The continuation will be evaluated in a <a>LiftM</a> context
--   in which that binder is deemed in scope. Think of it as a <a>local</a>
--   computation: After the continuation finishes, the new binding won't be
--   in scope anymore.
withSubstBndr :: Id -> (Id -> LiftM a) -> LiftM a

-- | See <a>withSubstBndr</a>.
withSubstBndrs :: Traversable f => f Id -> (f Id -> LiftM a) -> LiftM a

-- | Similarly to <a>withSubstBndr</a>, this function takes a set of
--   variables to abstract over, the binder to lift (and generate a fresh,
--   substituted name for) and a continuation in which that fresh, lifted
--   binder is in scope.
--   
--   It takes care of all the details involved with copying and adjusting
--   the binder and fresh name generation.
withLiftedBndr :: DIdSet -> Id -> (Id -> LiftM a) -> LiftM a

-- | See <a>withLiftedBndr</a>.
withLiftedBndrs :: Traversable f => DIdSet -> f Id -> (f Id -> LiftM a) -> LiftM a

-- | Substitutes a binder <i>occurrence</i>, which was brought in scope
--   earlier by <a>withSubstBndr</a> / <a>withLiftedBndr</a>.
substOcc :: Id -> LiftM Id

-- | Whether the given binding was decided to be lambda lifted.
isLifted :: InId -> LiftM Bool

-- | Returns an empty list for a binding that was not lifted and the list
--   of all local variables the binding abstracts over (so, exactly the
--   additional arguments at adjusted call sites) otherwise.
formerFreeVars :: InId -> LiftM [OutId]

-- | Creates an <i>expander function</i> for the current set of lifted
--   binders. This expander function will replace any <a>InId</a> by their
--   corresponding <a>OutId</a> and, in addition, will expand any lifted
--   binders by the former free variables it abstracts over.
liftedIdsExpander :: LiftM (DIdSet -> DIdSet)
instance GHC.Base.Monad GHC.Stg.Lift.Monad.LiftM
instance GHC.Base.Applicative GHC.Stg.Lift.Monad.LiftM
instance GHC.Base.Functor GHC.Stg.Lift.Monad.LiftM
instance GHC.Driver.Session.HasDynFlags GHC.Stg.Lift.Monad.LiftM
instance GHC.Types.Unique.Supply.MonadUnique GHC.Stg.Lift.Monad.LiftM
instance GHC.Utils.Outputable.Outputable GHC.Stg.Lift.Monad.FloatLang

module GHC.Core.Map.Expr

-- | <tt>CoreMap a</tt> is a map from <a>CoreExpr</a> to <tt>a</tt>. If you
--   are a client, this is the type you want.
data CoreMap a
emptyCoreMap :: CoreMap a
extendCoreMap :: CoreMap a -> CoreExpr -> a -> CoreMap a
lookupCoreMap :: CoreMap a -> CoreExpr -> Maybe a
foldCoreMap :: (a -> b -> b) -> b -> CoreMap a -> b
class TrieMap m where {
    type Key m :: Type;
}
emptyTM :: TrieMap m => m a
lookupTM :: forall b. TrieMap m => Key m -> m b -> Maybe b
alterTM :: forall b. TrieMap m => Key m -> XT b -> m b -> m b
mapTM :: TrieMap m => (a -> b) -> m a -> m b
filterTM :: TrieMap m => (a -> Bool) -> m a -> m a
foldTM :: TrieMap m => (a -> b -> b) -> m a -> b -> b
insertTM :: TrieMap m => Key m -> a -> m a -> m a
deleteTM :: TrieMap m => Key m -> m a -> m a
lkDFreeVar :: Var -> DVarEnv a -> Maybe a
xtDFreeVar :: Var -> XT a -> DVarEnv a -> DVarEnv a
lkDNamed :: NamedThing n => n -> DNameEnv a -> Maybe a
xtDNamed :: NamedThing n => n -> XT a -> DNameEnv a -> DNameEnv a
(>.>) :: (a -> b) -> (b -> c) -> a -> c
infixr 1 >.>
(|>) :: a -> (a -> b) -> b
infixr 1 |>
(|>>) :: TrieMap m2 => (XT (m2 a) -> m1 (m2 a) -> m1 (m2 a)) -> (m2 a -> m2 a) -> m1 (m2 a) -> m1 (m2 a)
infixr 1 |>>
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Expr.CoreMap
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.Map.Expr.CoreMap a)
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Expr.CoreMapX
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Expr.AltMap
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Core.CoreExpr)
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Core.CoreAlt)


-- | Note [CSE for Stg] ~~~~~~~~~~~~~~~~~~
--   
--   This module implements a simple common subexpression elimination pass
--   for STG. This is useful because there are expressions that we want to
--   common up (because they are operationally equivalent), but that we
--   cannot common up in Core, because their types differ. This was
--   originally reported as #9291.
--   
--   There are two types of common code occurrences that we aim for, see
--   note [Case 1: CSEing allocated closures] and note [Case 2: CSEing case
--   binders] below.
--   
--   Note [Case 1: CSEing allocated closures]
--   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   The first kind of CSE opportunity we aim for is generated by this
--   Haskell code:
--   
--   bar :: a -&gt; (Either Int a, Either Bool a) bar x = (Right x, Right
--   x)
--   
--   which produces this Core:
--   
--   bar :: forall a. a -&gt; (Either Int a, Either Bool a) bar <tt>a x =
--   (Right </tt>Int <tt>a x, Right </tt>Bool @a x)
--   
--   where the two components of the tuple are different terms, and cannot
--   be commoned up (easily). On the STG level we have
--   
--   bar [x] = let c1 = Right [x] c2 = Right [x] in (c1,c2)
--   
--   and now it is obvious that we can write
--   
--   bar [x] = let c1 = Right [x] in (c1,c1)
--   
--   instead.
--   
--   Note [Case 2: CSEing case binders] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   The second kind of CSE opportunity we aim for is more interesting, and
--   came up in #9291 and #5344: The Haskell code
--   
--   foo :: Either Int a -&gt; Either Bool a foo (Right x) = Right x foo _
--   = Left False
--   
--   produces this Core
--   
--   foo :: forall a. Either Int a -&gt; Either Bool a foo <tt>a e = case e
--   of b { Left n -&gt; â¦ , Right x -&gt; Right </tt>Bool @a x }
--   
--   where we cannot CSE `Right <tt>Bool </tt>a x` with the case binder
--   <tt>b</tt> as they have different types. But in STG we have
--   
--   foo [e] = case e of b { Left [n] -&gt; â¦ , Right [x] -&gt; Right [x] }
--   
--   and nothing stops us from transforming that to
--   
--   foo [e] = case e of b { Left [n] -&gt; â¦ , Right [x] -&gt; b}
--   
--   Note [StgCse after unarisation] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   Consider two unboxed sum terms:
--   
--   (# 1 | #) :: (# Int | Int# #) (# 1 | #) :: (# Int | Int #)
--   
--   These two terms are not equal as they unarise to different unboxed
--   tuples. However if we run StgCse before Unarise, it'll think the two
--   terms (# 1 | #) are equal, and replace one of these with a binder to
--   the other. That's bad -- #15300.
--   
--   Solution: do unarise first.
module GHC.Stg.CSE
stgCse :: [InStgTopBinding] -> [OutStgTopBinding]
instance GHC.Data.TrieMap.TrieMap GHC.Stg.CSE.ConAppMap
instance GHC.Data.TrieMap.TrieMap GHC.Stg.CSE.StgArgMap

module GHC.Builtin.Names.TH
templateHaskellNames :: [Name]
thSyn :: Module
thLib :: Module
qqLib :: Module
mkTHModule :: FastString -> Module
libFun :: FastString -> Unique -> Name
libTc :: FastString -> Unique -> Name
thFun :: FastString -> Unique -> Name
thTc :: FastString -> Unique -> Name
thCls :: FastString -> Unique -> Name
thCon :: FastString -> Unique -> Name
qqFun :: FastString -> Unique -> Name
liftClassName :: Name
quoteClassName :: Name
qTyConName :: Name
nameTyConName :: Name
fieldExpTyConName :: Name
patTyConName :: Name
fieldPatTyConName :: Name
expTyConName :: Name
decTyConName :: Name
typeTyConName :: Name
matchTyConName :: Name
clauseTyConName :: Name
funDepTyConName :: Name
predTyConName :: Name
codeTyConName :: Name
injAnnTyConName :: Name
overlapTyConName :: Name
decsTyConName :: Name
modNameTyConName :: Name
returnQName :: Name
bindQName :: Name
sequenceQName :: Name
newNameName :: Name
liftName :: Name
mkNameName :: Name
mkNameG_vName :: Name
mkNameG_dName :: Name
mkNameG_tcName :: Name
mkNameLName :: Name
mkNameSName :: Name
liftStringName :: Name
unTypeName :: Name
unTypeCodeName :: Name
unsafeCodeCoerceName :: Name
liftTypedName :: Name
mkModNameName :: Name
charLName :: Name
stringLName :: Name
integerLName :: Name
intPrimLName :: Name
wordPrimLName :: Name
floatPrimLName :: Name
doublePrimLName :: Name
rationalLName :: Name
stringPrimLName :: Name
charPrimLName :: Name
litPName :: Name
varPName :: Name
tupPName :: Name
unboxedTupPName :: Name
unboxedSumPName :: Name
conPName :: Name
infixPName :: Name
tildePName :: Name
bangPName :: Name
asPName :: Name
wildPName :: Name
recPName :: Name
listPName :: Name
sigPName :: Name
viewPName :: Name
fieldPatName :: Name
matchName :: Name
clauseName :: Name
varEName :: Name
conEName :: Name
litEName :: Name
appEName :: Name
appTypeEName :: Name
infixEName :: Name
infixAppName :: Name
sectionLName :: Name
sectionRName :: Name
lamEName :: Name
lamCaseEName :: Name
tupEName :: Name
unboxedTupEName :: Name
unboxedSumEName :: Name
condEName :: Name
multiIfEName :: Name
letEName :: Name
caseEName :: Name
doEName :: Name
mdoEName :: Name
compEName :: Name
staticEName :: Name
unboundVarEName :: Name
labelEName :: Name
implicitParamVarEName :: Name
getFieldEName :: Name
projectionEName :: Name
fromEName :: Name
fromThenEName :: Name
fromToEName :: Name
fromThenToEName :: Name
listEName :: Name
sigEName :: Name
recConEName :: Name
recUpdEName :: Name
fieldExpName :: Name
guardedBName :: Name
normalBName :: Name
normalGEName :: Name
patGEName :: Name
bindSName :: Name
letSName :: Name
noBindSName :: Name
parSName :: Name
recSName :: Name
funDName :: Name
valDName :: Name
dataDName :: Name
newtypeDName :: Name
tySynDName :: Name
classDName :: Name
instanceWithOverlapDName :: Name
sigDName :: Name
kiSigDName :: Name
forImpDName :: Name
pragInlDName :: Name
pragSpecDName :: Name
pragSpecInlDName :: Name
pragSpecInstDName :: Name
pragRuleDName :: Name
pragAnnDName :: Name
standaloneDerivWithStrategyDName :: Name
defaultSigDName :: Name
dataInstDName :: Name
newtypeInstDName :: Name
tySynInstDName :: Name
dataFamilyDName :: Name
openTypeFamilyDName :: Name
closedTypeFamilyDName :: Name
infixLDName :: Name
infixRDName :: Name
infixNDName :: Name
roleAnnotDName :: Name
patSynDName :: Name
patSynSigDName :: Name
pragCompleteDName :: Name
implicitParamBindDName :: Name
cxtName :: Name
noSourceUnpackednessName :: Name
sourceNoUnpackName :: Name
sourceUnpackName :: Name
noSourceStrictnessName :: Name
sourceLazyName :: Name
sourceStrictName :: Name
normalCName :: Name
recCName :: Name
infixCName :: Name
forallCName :: Name
gadtCName :: Name
recGadtCName :: Name
bangName :: Name
bangTypeName :: Name
varBangTypeName :: Name
unidirPatSynName :: Name
implBidirPatSynName :: Name
explBidirPatSynName :: Name
prefixPatSynName :: Name
infixPatSynName :: Name
recordPatSynName :: Name
forallTName :: Name
forallVisTName :: Name
varTName :: Name
conTName :: Name
infixTName :: Name
tupleTName :: Name
unboxedTupleTName :: Name
unboxedSumTName :: Name
arrowTName :: Name
mulArrowTName :: Name
listTName :: Name
appTName :: Name
appKindTName :: Name
sigTName :: Name
equalityTName :: Name
litTName :: Name
promotedTName :: Name
promotedTupleTName :: Name
promotedNilTName :: Name
promotedConsTName :: Name
wildCardTName :: Name
implicitParamTName :: Name
numTyLitName :: Name
strTyLitName :: Name
charTyLitName :: Name
plainTVName :: Name
kindedTVName :: Name
plainInvisTVName :: Name
kindedInvisTVName :: Name
specifiedSpecName :: Name
inferredSpecName :: Name
nominalRName :: Name
representationalRName :: Name
phantomRName :: Name
inferRName :: Name
starKName :: Name
constraintKName :: Name
noSigName :: Name
kindSigName :: Name
tyVarSigName :: Name
injectivityAnnName :: Name
cCallName :: Name
stdCallName :: Name
cApiCallName :: Name
primCallName :: Name
javaScriptCallName :: Name
unsafeName :: Name
safeName :: Name
interruptibleName :: Name
ruleVarName :: Name
typedRuleVarName :: Name
funDepName :: Name
tySynEqnName :: Name
valueAnnotationName :: Name
typeAnnotationName :: Name
moduleAnnotationName :: Name
derivClauseName :: Name
stockStrategyName :: Name
anyclassStrategyName :: Name
newtypeStrategyName :: Name
viaStrategyName :: Name
patQTyConName :: Name
expQTyConName :: Name
stmtTyConName :: Name
conTyConName :: Name
bangTypeTyConName :: Name
varBangTypeTyConName :: Name
typeQTyConName :: Name
decsQTyConName :: Name
ruleBndrTyConName :: Name
tySynEqnTyConName :: Name
roleTyConName :: Name
derivClauseTyConName :: Name
kindTyConName :: Name
tyVarBndrUnitTyConName :: Name
tyVarBndrSpecTyConName :: Name
derivStrategyTyConName :: Name
quoteExpName :: Name
quotePatName :: Name
quoteDecName :: Name
quoteTypeName :: Name
noInlineDataConName :: Name
inlineDataConName :: Name
inlinableDataConName :: Name
conLikeDataConName :: Name
funLikeDataConName :: Name
allPhasesDataConName :: Name
fromPhaseDataConName :: Name
beforePhaseDataConName :: Name
overlappableDataConName :: Name
overlappingDataConName :: Name
overlapsDataConName :: Name
incoherentDataConName :: Name
liftClassKey :: Unique
quoteClassKey :: Unique
expTyConKey :: Unique
matchTyConKey :: Unique
clauseTyConKey :: Unique
qTyConKey :: Unique
expQTyConKey :: Unique
patTyConKey :: Unique
stmtTyConKey :: Unique
conTyConKey :: Unique
typeQTyConKey :: Unique
typeTyConKey :: Unique
tyVarBndrUnitTyConKey :: Unique
tyVarBndrSpecTyConKey :: Unique
decTyConKey :: Unique
bangTypeTyConKey :: Unique
varBangTypeTyConKey :: Unique
fieldExpTyConKey :: Unique
fieldPatTyConKey :: Unique
nameTyConKey :: Unique
patQTyConKey :: Unique
funDepTyConKey :: Unique
predTyConKey :: Unique
predQTyConKey :: Unique
decsQTyConKey :: Unique
ruleBndrTyConKey :: Unique
tySynEqnTyConKey :: Unique
roleTyConKey :: Unique
codeTyConKey :: Unique
injAnnTyConKey :: Unique
kindTyConKey :: Unique
overlapTyConKey :: Unique
derivClauseTyConKey :: Unique
derivStrategyTyConKey :: Unique
decsTyConKey :: Unique
modNameTyConKey :: Unique
noInlineDataConKey :: Unique
inlineDataConKey :: Unique
inlinableDataConKey :: Unique
conLikeDataConKey :: Unique
funLikeDataConKey :: Unique
allPhasesDataConKey :: Unique
fromPhaseDataConKey :: Unique
beforePhaseDataConKey :: Unique
overlappableDataConKey :: Unique
overlappingDataConKey :: Unique
overlapsDataConKey :: Unique
incoherentDataConKey :: Unique
returnQIdKey :: Unique
bindQIdKey :: Unique
sequenceQIdKey :: Unique
liftIdKey :: Unique
newNameIdKey :: Unique
mkNameIdKey :: Unique
mkNameG_vIdKey :: Unique
mkNameG_dIdKey :: Unique
mkNameG_tcIdKey :: Unique
mkNameLIdKey :: Unique
mkNameSIdKey :: Unique
unTypeIdKey :: Unique
unTypeCodeIdKey :: Unique
unsafeCodeCoerceIdKey :: Unique
liftTypedIdKey :: Unique
mkModNameIdKey :: Unique
charLIdKey :: Unique
stringLIdKey :: Unique
integerLIdKey :: Unique
intPrimLIdKey :: Unique
wordPrimLIdKey :: Unique
floatPrimLIdKey :: Unique
doublePrimLIdKey :: Unique
rationalLIdKey :: Unique
stringPrimLIdKey :: Unique
charPrimLIdKey :: Unique
liftStringIdKey :: Unique
litPIdKey :: Unique
varPIdKey :: Unique
tupPIdKey :: Unique
unboxedTupPIdKey :: Unique
unboxedSumPIdKey :: Unique
conPIdKey :: Unique
infixPIdKey :: Unique
tildePIdKey :: Unique
bangPIdKey :: Unique
asPIdKey :: Unique
wildPIdKey :: Unique
recPIdKey :: Unique
listPIdKey :: Unique
sigPIdKey :: Unique
viewPIdKey :: Unique
fieldPatIdKey :: Unique
matchIdKey :: Unique
clauseIdKey :: Unique
varEIdKey :: Unique
conEIdKey :: Unique
litEIdKey :: Unique
appEIdKey :: Unique
appTypeEIdKey :: Unique
infixEIdKey :: Unique
infixAppIdKey :: Unique
sectionLIdKey :: Unique
sectionRIdKey :: Unique
lamEIdKey :: Unique
lamCaseEIdKey :: Unique
tupEIdKey :: Unique
unboxedTupEIdKey :: Unique
unboxedSumEIdKey :: Unique
condEIdKey :: Unique
multiIfEIdKey :: Unique
letEIdKey :: Unique
caseEIdKey :: Unique
doEIdKey :: Unique
compEIdKey :: Unique
fromEIdKey :: Unique
fromThenEIdKey :: Unique
fromToEIdKey :: Unique
fromThenToEIdKey :: Unique
listEIdKey :: Unique
sigEIdKey :: Unique
recConEIdKey :: Unique
recUpdEIdKey :: Unique
staticEIdKey :: Unique
unboundVarEIdKey :: Unique
labelEIdKey :: Unique
implicitParamVarEIdKey :: Unique
mdoEIdKey :: Unique
getFieldEIdKey :: Unique
projectionEIdKey :: Unique
fieldExpIdKey :: Unique
guardedBIdKey :: Unique
normalBIdKey :: Unique
normalGEIdKey :: Unique
patGEIdKey :: Unique
bindSIdKey :: Unique
letSIdKey :: Unique
noBindSIdKey :: Unique
parSIdKey :: Unique
recSIdKey :: Unique
funDIdKey :: Unique
valDIdKey :: Unique
dataDIdKey :: Unique
newtypeDIdKey :: Unique
tySynDIdKey :: Unique
classDIdKey :: Unique
instanceWithOverlapDIdKey :: Unique
instanceDIdKey :: Unique
sigDIdKey :: Unique
forImpDIdKey :: Unique
pragInlDIdKey :: Unique
pragSpecDIdKey :: Unique
pragSpecInlDIdKey :: Unique
pragSpecInstDIdKey :: Unique
pragRuleDIdKey :: Unique
pragAnnDIdKey :: Unique
defaultSigDIdKey :: Unique
dataFamilyDIdKey :: Unique
openTypeFamilyDIdKey :: Unique
closedTypeFamilyDIdKey :: Unique
dataInstDIdKey :: Unique
newtypeInstDIdKey :: Unique
tySynInstDIdKey :: Unique
standaloneDerivWithStrategyDIdKey :: Unique
infixLDIdKey :: Unique
infixRDIdKey :: Unique
infixNDIdKey :: Unique
roleAnnotDIdKey :: Unique
patSynDIdKey :: Unique
patSynSigDIdKey :: Unique
pragCompleteDIdKey :: Unique
implicitParamBindDIdKey :: Unique
kiSigDIdKey :: Unique
cxtIdKey :: Unique
noSourceUnpackednessKey :: Unique
sourceNoUnpackKey :: Unique
sourceUnpackKey :: Unique
noSourceStrictnessKey :: Unique
sourceLazyKey :: Unique
sourceStrictKey :: Unique
normalCIdKey :: Unique
recCIdKey :: Unique
infixCIdKey :: Unique
forallCIdKey :: Unique
gadtCIdKey :: Unique
recGadtCIdKey :: Unique
bangIdKey :: Unique
bangTKey :: Unique
varBangTKey :: Unique
unidirPatSynIdKey :: Unique
implBidirPatSynIdKey :: Unique
explBidirPatSynIdKey :: Unique
prefixPatSynIdKey :: Unique
infixPatSynIdKey :: Unique
recordPatSynIdKey :: Unique
forallTIdKey :: Unique
forallVisTIdKey :: Unique
varTIdKey :: Unique
conTIdKey :: Unique
tupleTIdKey :: Unique
unboxedTupleTIdKey :: Unique
unboxedSumTIdKey :: Unique
arrowTIdKey :: Unique
listTIdKey :: Unique
appTIdKey :: Unique
appKindTIdKey :: Unique
sigTIdKey :: Unique
equalityTIdKey :: Unique
litTIdKey :: Unique
promotedTIdKey :: Unique
promotedTupleTIdKey :: Unique
promotedNilTIdKey :: Unique
promotedConsTIdKey :: Unique
wildCardTIdKey :: Unique
implicitParamTIdKey :: Unique
infixTIdKey :: Unique
numTyLitIdKey :: Unique
strTyLitIdKey :: Unique
charTyLitIdKey :: Unique
plainTVIdKey :: Unique
kindedTVIdKey :: Unique
plainInvisTVIdKey :: Unique
kindedInvisTVIdKey :: Unique
nominalRIdKey :: Unique
representationalRIdKey :: Unique
phantomRIdKey :: Unique
inferRIdKey :: Unique
starKIdKey :: Unique
constraintKIdKey :: Unique
noSigIdKey :: Unique
kindSigIdKey :: Unique
tyVarSigIdKey :: Unique
injectivityAnnIdKey :: Unique
cCallIdKey :: Unique
stdCallIdKey :: Unique
cApiCallIdKey :: Unique
primCallIdKey :: Unique
javaScriptCallIdKey :: Unique
unsafeIdKey :: Unique
safeIdKey :: Unique
interruptibleIdKey :: Unique
funDepIdKey :: Unique
mulArrowTIdKey :: Unique
tySynEqnIdKey :: Unique
quoteExpKey :: Unique
quotePatKey :: Unique
quoteDecKey :: Unique
quoteTypeKey :: Unique
ruleVarIdKey :: Unique
typedRuleVarIdKey :: Unique
valueAnnotationIdKey :: Unique
typeAnnotationIdKey :: Unique
moduleAnnotationIdKey :: Unique
derivClauseIdKey :: Unique
stockStrategyIdKey :: Unique
anyclassStrategyIdKey :: Unique
newtypeStrategyIdKey :: Unique
viaStrategyIdKey :: Unique
specifiedSpecKey :: Unique
inferredSpecKey :: Unique
lift_RDR :: RdrName
liftTyped_RDR :: RdrName
mkNameG_dRDR :: RdrName
mkNameG_vRDR :: RdrName
unsafeCodeCoerce_RDR :: RdrName
conE_RDR :: RdrName
litE_RDR :: RdrName
appE_RDR :: RdrName
infixApp_RDR :: RdrName
stringL_RDR :: RdrName
intPrimL_RDR :: RdrName
wordPrimL_RDR :: RdrName
floatPrimL_RDR :: RdrName
doublePrimL_RDR :: RdrName
stringPrimL_RDR :: RdrName
charPrimL_RDR :: RdrName


-- | Functional dependencies
--   
--   It's better to read it as: "if we know these, then we're going to know
--   these"
module GHC.Tc.Instance.FunDeps
data FunDepEqn loc
FDEqn :: [TyVar] -> [TypeEqn] -> PredType -> PredType -> loc -> FunDepEqn loc
[fd_qtvs] :: FunDepEqn loc -> [TyVar]
[fd_eqs] :: FunDepEqn loc -> [TypeEqn]
[fd_pred1] :: FunDepEqn loc -> PredType
[fd_pred2] :: FunDepEqn loc -> PredType
[fd_loc] :: FunDepEqn loc -> loc
pprEquation :: FunDepEqn a -> SDoc
improveFromInstEnv :: InstEnvs -> (PredType -> SrcSpan -> loc) -> PredType -> [FunDepEqn loc]
improveFromAnother :: loc -> PredType -> PredType -> [FunDepEqn loc]
checkInstCoverage :: Bool -> Class -> [PredType] -> [Type] -> Validity
checkFunDeps :: InstEnvs -> ClsInst -> [ClsInst]
pprFundeps :: Outputable a => [FunDep a] -> SDoc
instance GHC.Utils.Outputable.Outputable (GHC.Tc.Instance.FunDeps.FunDepEqn a)

module GHC.Parser.Types
data SumOrTuple b

-- | Last two are the locations of the '|' before and after the payload
Sum :: ConTag -> Arity -> LocatedA b -> [EpaLocation] -> [EpaLocation] -> SumOrTuple b
Tuple :: [Either (EpAnn EpaLocation) (LocatedA b)] -> SumOrTuple b
pprSumOrTuple :: Outputable b => Boxity -> SumOrTuple b -> SDoc

-- | See Note [Ambiguous syntactic categories] and Note [PatBuilder]
data PatBuilder p
PatBuilderPat :: Pat p -> PatBuilder p
PatBuilderPar :: LocatedA (PatBuilder p) -> AnnParen -> PatBuilder p
PatBuilderApp :: LocatedA (PatBuilder p) -> LocatedA (PatBuilder p) -> PatBuilder p
PatBuilderAppType :: LocatedA (PatBuilder p) -> HsPatSigType GhcPs -> PatBuilder p
PatBuilderOpApp :: LocatedA (PatBuilder p) -> LocatedN RdrName -> LocatedA (PatBuilder p) -> EpAnn [AddEpAnn] -> PatBuilder p
PatBuilderVar :: LocatedN RdrName -> PatBuilder p
PatBuilderOverLit :: HsOverLit GhcPs -> PatBuilder p

-- | An accumulator to build a prefix data constructor, e.g. when parsing
--   <tt>MkT A B C</tt>, the accumulator will evolve as follows:
--   
--   <pre>
--   1. PrefixDataConBuilder []        MkT
--   2. PrefixDataConBuilder [A]       MkT
--   3. PrefixDataConBuilder [A, B]    MkT
--   4. PrefixDataConBuilder [A, B, C] MkT
--   
--   </pre>
--   
--   There are two reasons we have a separate builder type instead of using
--   <tt>HsConDeclDetails GhcPs</tt> directly:
--   
--   <ol>
--   <li>It's faster, because <a>OrdList</a> gives us constant-time
--   snoc.</li>
--   <li>Having a separate type helps ensure that we don't forget to
--   finalize a <tt>RecTy</tt> into a <a>RecCon</a> (we do that in
--   <tt>dataConBuilderDetails</tt>).</li>
--   </ol>
--   
--   See Note [PatBuilder] for another builder type used in the parser.
--   Here the technique is similar, but the motivation is different.
data DataConBuilder
PrefixDataConBuilder :: OrdList (LHsType GhcPs) -> LocatedN RdrName -> DataConBuilder
InfixDataConBuilder :: LHsType GhcPs -> LocatedN RdrName -> LHsType GhcPs -> DataConBuilder
instance GHC.Utils.Outputable.Outputable GHC.Parser.Types.DataConBuilder
instance GHC.Utils.Outputable.Outputable (GHC.Parser.Types.PatBuilder GHC.Hs.Extension.GhcPs)

module GHC.Parser.Errors

-- | A warning that might arise during parsing.
data PsWarning

-- | Warn when tabulations are found
PsWarnTab :: !SrcSpan -> !Word -> PsWarning

-- | First occurrence of a tab
[tabFirst] :: PsWarning -> !SrcSpan

-- | Number of other occurrences
[tabCount] :: PsWarning -> !Word

-- | PsWarnBidirectionalFormatChars is a warning (controlled by the
--   -Wwarn-bidirectional-format-characters flag) that occurs when unicode
--   bi-directional format characters are found within in a file
--   
--   The <a>PsLoc</a> contains the exact position in the buffer the
--   character occured, and the string contains a description of the
--   character.
PsWarnBidirectionalFormatChars :: NonEmpty (PsLoc, Char, String) -> PsWarning

-- | Transitional layout warnings
PsWarnTransitionalLayout :: !SrcSpan -> !TransLayoutReason -> PsWarning

-- | Unrecognised pragma
PsWarnUnrecognisedPragma :: !SrcSpan -> PsWarning

-- | Invalid Haddock comment position
PsWarnHaddockInvalidPos :: !SrcSpan -> PsWarning

-- | Multiple Haddock comment for the same entity
PsWarnHaddockIgnoreMulti :: !SrcSpan -> PsWarning

-- | Found binding occurrence of "*" while StarIsType is enabled
PsWarnStarBinder :: !SrcSpan -> PsWarning

-- | Using "*" for <a>Type</a> without StarIsType enabled
PsWarnStarIsType :: !SrcSpan -> PsWarning

-- | Pre qualified import with <tt>WarnPrepositiveQualifiedModule</tt>
--   enabled
PsWarnImportPreQualified :: !SrcSpan -> PsWarning
PsWarnOperatorWhitespaceExtConflict :: !SrcSpan -> !OperatorWhitespaceSymbol -> PsWarning
PsWarnOperatorWhitespace :: !SrcSpan -> !FastString -> !OperatorWhitespaceOccurrence -> PsWarning
data TransLayoutReason

-- | "`where' clause at the same depth as implicit layout block"
TransLayout_Where :: TransLayoutReason

-- | "`|' at the same depth as implicit layout block")
TransLayout_Pipe :: TransLayoutReason

-- | The operator symbol in the <tt>WarnOperatorWhitespaceExtConflict</tt>
--   warning.
data OperatorWhitespaceSymbol
OperatorWhitespaceSymbol_PrefixPercent :: OperatorWhitespaceSymbol
OperatorWhitespaceSymbol_PrefixDollar :: OperatorWhitespaceSymbol
OperatorWhitespaceSymbol_PrefixDollarDollar :: OperatorWhitespaceSymbol

-- | The operator occurrence type in the <tt>WarnOperatorWhitespace</tt>
--   warning.
data OperatorWhitespaceOccurrence
OperatorWhitespaceOccurrence_Prefix :: OperatorWhitespaceOccurrence
OperatorWhitespaceOccurrence_Suffix :: OperatorWhitespaceOccurrence
OperatorWhitespaceOccurrence_TightInfix :: OperatorWhitespaceOccurrence
data NumUnderscoreReason
NumUnderscore_Integral :: NumUnderscoreReason
NumUnderscore_Float :: NumUnderscoreReason
data PsError
PsError :: !PsErrorDesc -> ![Hint] -> !SrcSpan -> PsError

-- | Error description
[errDesc] :: PsError -> !PsErrorDesc

-- | Hints
[errHints] :: PsError -> ![Hint]

-- | Error position
[errLoc] :: PsError -> !SrcSpan
data PsErrorDesc

-- | LambdaCase syntax used without the extension enabled
PsErrLambdaCase :: PsErrorDesc

-- | Underscores in literals without the extension enabled
PsErrNumUnderscores :: !NumUnderscoreReason -> PsErrorDesc

-- | Invalid character in primitive string
PsErrPrimStringInvalidChar :: PsErrorDesc

-- | Missing block
PsErrMissingBlock :: PsErrorDesc

-- | Lexer error
PsErrLexer :: !LexErr -> !LexErrKind -> PsErrorDesc

-- | Suffix occurrence of <tt>@</tt>
PsErrSuffixAT :: PsErrorDesc

-- | Parse errors
PsErrParse :: !String -> PsErrorDesc

-- | Cmm lexer error
PsErrCmmLexer :: PsErrorDesc

-- | Unsupported boxed sum in expression
PsErrUnsupportedBoxedSumExpr :: !SumOrTuple (HsExpr GhcPs) -> PsErrorDesc

-- | Unsupported boxed sum in pattern
PsErrUnsupportedBoxedSumPat :: !SumOrTuple (PatBuilder GhcPs) -> PsErrorDesc

-- | Unexpected qualified constructor
PsErrUnexpectedQualifiedConstructor :: !RdrName -> PsErrorDesc

-- | Tuple section in pattern context
PsErrTupleSectionInPat :: PsErrorDesc

-- | Bang-pattern without BangPattterns enabled
PsErrIllegalBangPattern :: !Pat GhcPs -> PsErrorDesc

-- | Operator applied to too few arguments
PsErrOpFewArgs :: !StarIsType -> !RdrName -> PsErrorDesc

-- | Import: multiple occurrences of <tt>qualified</tt>
PsErrImportQualifiedTwice :: PsErrorDesc

-- | Post qualified import without <tt>ImportQualifiedPost</tt>
PsErrImportPostQualified :: PsErrorDesc

-- | Explicit namespace keyword without <tt>ExplicitNamespaces</tt>
PsErrIllegalExplicitNamespace :: PsErrorDesc

-- | Expecting a type constructor but found a variable
PsErrVarForTyCon :: !RdrName -> PsErrorDesc

-- | Illegal export form allowed by PatternSynonyms
PsErrIllegalPatSynExport :: PsErrorDesc

-- | Malformed entity string
PsErrMalformedEntityString :: PsErrorDesc

-- | Dots used in record update
PsErrDotsInRecordUpdate :: PsErrorDesc

-- | Precedence out of range
PsErrPrecedenceOutOfRange :: !Int -> PsErrorDesc

-- | Invalid use of record dot syntax <a>.</a>
PsErrOverloadedRecordDotInvalid :: PsErrorDesc

-- | <tt>OverloadedRecordUpdate</tt> is not enabled.
PsErrOverloadedRecordUpdateNotEnabled :: PsErrorDesc

-- | Can't use qualified fields when OverloadedRecordUpdate is enabled.
PsErrOverloadedRecordUpdateNoQualifiedFields :: PsErrorDesc

-- | Cannot parse data constructor in a data/newtype declaration
PsErrInvalidDataCon :: !HsType GhcPs -> PsErrorDesc

-- | Cannot parse data constructor in a data/newtype declaration
PsErrInvalidInfixDataCon :: !HsType GhcPs -> !RdrName -> !HsType GhcPs -> PsErrorDesc

-- | UNPACK applied to a data constructor
PsErrUnpackDataCon :: PsErrorDesc

-- | Unexpected kind application in data/newtype declaration
PsErrUnexpectedKindAppInDataCon :: !DataConBuilder -> !HsType GhcPs -> PsErrorDesc

-- | Not a record constructor
PsErrInvalidRecordCon :: !PatBuilder GhcPs -> PsErrorDesc

-- | Illegal unboxed string literal in pattern
PsErrIllegalUnboxedStringInPat :: !HsLit GhcPs -> PsErrorDesc

-- | Do-notation in pattern
PsErrDoNotationInPat :: PsErrorDesc

-- | If-then-else syntax in pattern
PsErrIfTheElseInPat :: PsErrorDesc

-- | Lambda-case in pattern
PsErrLambdaCaseInPat :: PsErrorDesc

-- | case..of in pattern
PsErrCaseInPat :: PsErrorDesc

-- | let-syntax in pattern
PsErrLetInPat :: PsErrorDesc

-- | Lambda-syntax in pattern
PsErrLambdaInPat :: PsErrorDesc

-- | Arrow expression-syntax in pattern
PsErrArrowExprInPat :: !HsExpr GhcPs -> PsErrorDesc

-- | Arrow command-syntax in pattern
PsErrArrowCmdInPat :: !HsCmd GhcPs -> PsErrorDesc

-- | Arrow command-syntax in expression
PsErrArrowCmdInExpr :: !HsCmd GhcPs -> PsErrorDesc

-- | View-pattern in expression
PsErrViewPatInExpr :: !LHsExpr GhcPs -> !LHsExpr GhcPs -> PsErrorDesc

-- | Type-application without space before <tt>@</tt>
PsErrTypeAppWithoutSpace :: !RdrName -> !LHsExpr GhcPs -> PsErrorDesc

-- | Lazy-pattern (<tt>~</tt>) without space after it
PsErrLazyPatWithoutSpace :: !LHsExpr GhcPs -> PsErrorDesc

-- | Bang-pattern (<tt>!</tt>) without space after it
PsErrBangPatWithoutSpace :: !LHsExpr GhcPs -> PsErrorDesc

-- | Pragma not allowed in this position
PsErrUnallowedPragma :: !HsPragE GhcPs -> PsErrorDesc

-- | Qualified do block in command
PsErrQualifiedDoInCmd :: !ModuleName -> PsErrorDesc

-- | Invalid infix hole, expected an infix operator
PsErrInvalidInfixHole :: PsErrorDesc

-- | Unexpected semi-colons in conditional expression
PsErrSemiColonsInCondExpr :: !HsExpr GhcPs -> !Bool -> !HsExpr GhcPs -> !Bool -> !HsExpr GhcPs -> PsErrorDesc

-- | Unexpected semi-colons in conditional command
PsErrSemiColonsInCondCmd :: !HsExpr GhcPs -> !Bool -> !HsCmd GhcPs -> !Bool -> !HsCmd GhcPs -> PsErrorDesc

-- | @-operator in a pattern position
PsErrAtInPatPos :: PsErrorDesc

-- | Unexpected lambda command in function application
PsErrLambdaCmdInFunAppCmd :: !LHsCmd GhcPs -> PsErrorDesc

-- | Unexpected case command in function application
PsErrCaseCmdInFunAppCmd :: !LHsCmd GhcPs -> PsErrorDesc

-- | Unexpected if command in function application
PsErrIfCmdInFunAppCmd :: !LHsCmd GhcPs -> PsErrorDesc

-- | Unexpected let command in function application
PsErrLetCmdInFunAppCmd :: !LHsCmd GhcPs -> PsErrorDesc

-- | Unexpected do command in function application
PsErrDoCmdInFunAppCmd :: !LHsCmd GhcPs -> PsErrorDesc

-- | Unexpected do block in function application
PsErrDoInFunAppExpr :: !Maybe ModuleName -> !LHsExpr GhcPs -> PsErrorDesc

-- | Unexpected mdo block in function application
PsErrMDoInFunAppExpr :: !Maybe ModuleName -> !LHsExpr GhcPs -> PsErrorDesc

-- | Unexpected lambda expression in function application
PsErrLambdaInFunAppExpr :: !LHsExpr GhcPs -> PsErrorDesc

-- | Unexpected case expression in function application
PsErrCaseInFunAppExpr :: !LHsExpr GhcPs -> PsErrorDesc

-- | Unexpected lambda-case expression in function application
PsErrLambdaCaseInFunAppExpr :: !LHsExpr GhcPs -> PsErrorDesc

-- | Unexpected let expression in function application
PsErrLetInFunAppExpr :: !LHsExpr GhcPs -> PsErrorDesc

-- | Unexpected if expression in function application
PsErrIfInFunAppExpr :: !LHsExpr GhcPs -> PsErrorDesc

-- | Unexpected proc expression in function application
PsErrProcInFunAppExpr :: !LHsExpr GhcPs -> PsErrorDesc

-- | Malformed head of type or class declaration
PsErrMalformedTyOrClDecl :: !LHsType GhcPs -> PsErrorDesc

-- | Illegal 'where' keyword in data declaration
PsErrIllegalWhereInDataDecl :: PsErrorDesc

-- | Illegal datatyp context
PsErrIllegalDataTypeContext :: !LHsContext GhcPs -> PsErrorDesc

-- | Parse error on input
PsErrParseErrorOnInput :: !OccName -> PsErrorDesc

-- | Malformed ... declaration for ...
PsErrMalformedDecl :: !SDoc -> !RdrName -> PsErrorDesc

-- | Unexpected type application in a declaration
PsErrUnexpectedTypeAppInDecl :: !LHsType GhcPs -> !SDoc -> !RdrName -> PsErrorDesc

-- | Not a data constructor
PsErrNotADataCon :: !RdrName -> PsErrorDesc

-- | Record syntax used in pattern synonym declaration
PsErrRecordSyntaxInPatSynDecl :: !LPat GhcPs -> PsErrorDesc

-- | Empty 'where' clause in pattern-synonym declaration
PsErrEmptyWhereInPatSynDecl :: !RdrName -> PsErrorDesc

-- | Invalid binding name in 'where' clause of pattern-synonym declaration
PsErrInvalidWhereBindInPatSynDecl :: !RdrName -> !HsDecl GhcPs -> PsErrorDesc

-- | Multiple bindings in 'where' clause of pattern-synonym declaration
PsErrNoSingleWhereBindInPatSynDecl :: !RdrName -> !HsDecl GhcPs -> PsErrorDesc

-- | Declaration splice not a top-level
PsErrDeclSpliceNotAtTopLevel :: !SpliceDecl GhcPs -> PsErrorDesc

-- | Inferred type variables not allowed here
PsErrInferredTypeVarNotAllowed :: PsErrorDesc

-- | Multiple names in standalone kind signatures
PsErrMultipleNamesInStandaloneKindSignature :: [LIdP GhcPs] -> PsErrorDesc

-- | Illegal import bundle form
PsErrIllegalImportBundleForm :: PsErrorDesc

-- | Illegal role name
PsErrIllegalRoleName :: !FastString -> [Role] -> PsErrorDesc

-- | Invalid type signature
PsErrInvalidTypeSignature :: !LHsExpr GhcPs -> PsErrorDesc

-- | Unexpected type in declaration
PsErrUnexpectedTypeInDecl :: !LHsType GhcPs -> !SDoc -> !RdrName -> [LHsTypeArg GhcPs] -> !SDoc -> PsErrorDesc

-- | Expected a hyphen
PsErrExpectedHyphen :: PsErrorDesc

-- | Found a space in a SCC
PsErrSpaceInSCC :: PsErrorDesc

-- | Found two single quotes
PsErrEmptyDoubleQuotes :: !Bool -> PsErrorDesc

-- | Invalid package name
PsErrInvalidPackageName :: !FastString -> PsErrorDesc

-- | Invalid rule activation marker
PsErrInvalidRuleActivationMarker :: PsErrorDesc

-- | Linear function found but LinearTypes not enabled
PsErrLinearFunction :: PsErrorDesc

-- | Invalid CApi import
PsErrInvalidCApiImport :: PsErrorDesc

-- | Multi-way if-expression found but MultiWayIf not enabled
PsErrMultiWayIf :: PsErrorDesc

-- | Explicit forall found but no extension allowing it is enabled
PsErrExplicitForall :: !Bool -> PsErrorDesc

-- | Found qualified-do without QualifiedDo enabled
PsErrIllegalQualifiedDo :: !SDoc -> PsErrorDesc

-- | Cmm parser error
PsErrCmmParser :: !CmmParserError -> PsErrorDesc

-- | Illegal traditional record syntax
--   
--   TODO: distinguish errors without using SDoc
PsErrIllegalTraditionalRecordSyntax :: !SDoc -> PsErrorDesc

-- | Parse error in command
--   
--   TODO: distinguish errors without using SDoc
PsErrParseErrorInCmd :: !SDoc -> PsErrorDesc

-- | Parse error in pattern
--   
--   TODO: distinguish errors without using SDoc
PsErrParseErrorInPat :: !SDoc -> PsErrorDesc
data LexErr

-- | Lexical error
LexError :: LexErr

-- | Unknown pragma
LexUnknownPragma :: LexErr

-- | Lexical error in pragma
LexErrorInPragma :: LexErr

-- | Numeric escape sequence out of range
LexNumEscapeRange :: LexErr

-- | Llexical error in string/character literal
LexStringCharLit :: LexErr

-- | Unexpected end-of-file in string/character literal
LexStringCharLitEOF :: LexErr

-- | Unterminated `{-'
LexUnterminatedComment :: LexErr

-- | Unterminated OPTIONS pragma
LexUnterminatedOptions :: LexErr

-- | Unterminated quasiquotation
LexUnterminatedQQ :: LexErr

-- | Errors from the Cmm parser
data CmmParserError

-- | Unknown Cmm primitive
CmmUnknownPrimitive :: !FastString -> CmmParserError

-- | Unknown macro
CmmUnknownMacro :: !FastString -> CmmParserError

-- | Unknown calling convention
CmmUnknownCConv :: !String -> CmmParserError

-- | Unrecognised safety
CmmUnrecognisedSafety :: !String -> CmmParserError

-- | Unrecognised hint
CmmUnrecognisedHint :: !String -> CmmParserError
data LexErrKind

-- | End of input
LexErrKind_EOF :: LexErrKind

-- | UTF-8 decoding error
LexErrKind_UTF8 :: LexErrKind

-- | Error at given character
LexErrKind_Char :: !Char -> LexErrKind
data Hint
SuggestTH :: Hint
SuggestRecursiveDo :: Hint
SuggestDo :: Hint
SuggestMissingDo :: Hint
SuggestLetInDo :: Hint
SuggestPatternSynonyms :: Hint
SuggestInfixBindMaybeAtPat :: !RdrName -> Hint

-- | Type applications in patterns are only allowed on data constructors
TypeApplicationsInPatternsOnlyDataCons :: Hint
newtype StarIsType
StarIsType :: Bool -> StarIsType
instance GHC.Classes.Ord GHC.Parser.Errors.NumUnderscoreReason
instance GHC.Classes.Eq GHC.Parser.Errors.NumUnderscoreReason
instance GHC.Show.Show GHC.Parser.Errors.NumUnderscoreReason
instance GHC.Classes.Ord GHC.Parser.Errors.LexErrKind
instance GHC.Classes.Eq GHC.Parser.Errors.LexErrKind
instance GHC.Show.Show GHC.Parser.Errors.LexErrKind

module GHC.Parser.Lexer
data Token
ITas :: Token
ITcase :: Token
ITclass :: Token
ITdata :: Token
ITdefault :: Token
ITderiving :: Token
ITdo :: Maybe FastString -> Token
ITelse :: Token
IThiding :: Token
ITforeign :: Token
ITif :: Token
ITimport :: Token
ITin :: Token
ITinfix :: Token
ITinfixl :: Token
ITinfixr :: Token
ITinstance :: Token
ITlet :: Token
ITmodule :: Token
ITnewtype :: Token
ITof :: Token
ITqualified :: Token
ITthen :: Token
ITtype :: Token
ITwhere :: Token
ITforall :: IsUnicodeSyntax -> Token
ITexport :: Token
ITlabel :: Token
ITdynamic :: Token
ITsafe :: Token
ITinterruptible :: Token
ITunsafe :: Token
ITstdcallconv :: Token
ITccallconv :: Token
ITcapiconv :: Token
ITprimcallconv :: Token
ITjavascriptcallconv :: Token
ITmdo :: Maybe FastString -> Token
ITfamily :: Token
ITrole :: Token
ITgroup :: Token
ITby :: Token
ITusing :: Token
ITpattern :: Token
ITstatic :: Token
ITstock :: Token
ITanyclass :: Token
ITvia :: Token
ITunit :: Token
ITsignature :: Token
ITdependency :: Token
ITrequires :: Token
ITinline_prag :: SourceText -> InlineSpec -> RuleMatchInfo -> Token
ITspec_prag :: SourceText -> Token
ITspec_inline_prag :: SourceText -> Bool -> Token
ITsource_prag :: SourceText -> Token
ITrules_prag :: SourceText -> Token
ITwarning_prag :: SourceText -> Token
ITdeprecated_prag :: SourceText -> Token
ITline_prag :: SourceText -> Token
ITcolumn_prag :: SourceText -> Token
ITscc_prag :: SourceText -> Token
ITunpack_prag :: SourceText -> Token
ITnounpack_prag :: SourceText -> Token
ITann_prag :: SourceText -> Token
ITcomplete_prag :: SourceText -> Token
ITclose_prag :: Token
IToptions_prag :: String -> Token
ITinclude_prag :: String -> Token
ITlanguage_prag :: Token
ITminimal_prag :: SourceText -> Token
IToverlappable_prag :: SourceText -> Token
IToverlapping_prag :: SourceText -> Token
IToverlaps_prag :: SourceText -> Token
ITincoherent_prag :: SourceText -> Token
ITctype :: SourceText -> Token
ITcomment_line_prag :: Token
ITdotdot :: Token
ITcolon :: Token
ITdcolon :: IsUnicodeSyntax -> Token
ITequal :: Token
ITlam :: Token
ITlcase :: Token
ITvbar :: Token
ITlarrow :: IsUnicodeSyntax -> Token
ITrarrow :: IsUnicodeSyntax -> Token
ITdarrow :: IsUnicodeSyntax -> Token
ITlolly :: Token
ITminus :: Token
ITprefixminus :: Token
ITbang :: Token
ITtilde :: Token
ITat :: Token
ITtypeApp :: Token
ITpercent :: Token
ITstar :: IsUnicodeSyntax -> Token
ITdot :: Token
ITproj :: Bool -> Token
ITbiglam :: Token
ITocurly :: Token
ITccurly :: Token
ITvocurly :: Token
ITvccurly :: Token
ITobrack :: Token
ITopabrack :: Token
ITcpabrack :: Token
ITcbrack :: Token
IToparen :: Token
ITcparen :: Token
IToubxparen :: Token
ITcubxparen :: Token
ITsemi :: Token
ITcomma :: Token
ITunderscore :: Token
ITbackquote :: Token
ITsimpleQuote :: Token
ITvarid :: FastString -> Token
ITconid :: FastString -> Token
ITvarsym :: FastString -> Token
ITconsym :: FastString -> Token
ITqvarid :: (FastString, FastString) -> Token
ITqconid :: (FastString, FastString) -> Token
ITqvarsym :: (FastString, FastString) -> Token
ITqconsym :: (FastString, FastString) -> Token
ITdupipvarid :: FastString -> Token
ITlabelvarid :: FastString -> Token
ITchar :: SourceText -> Char -> Token
ITstring :: SourceText -> FastString -> Token
ITinteger :: IntegralLit -> Token
ITrational :: FractionalLit -> Token
ITprimchar :: SourceText -> Char -> Token
ITprimstring :: SourceText -> ByteString -> Token
ITprimint :: SourceText -> Integer -> Token
ITprimword :: SourceText -> Integer -> Token
ITprimfloat :: FractionalLit -> Token
ITprimdouble :: FractionalLit -> Token
ITopenExpQuote :: HasE -> IsUnicodeSyntax -> Token
ITopenPatQuote :: Token
ITopenDecQuote :: Token
ITopenTypQuote :: Token
ITcloseQuote :: IsUnicodeSyntax -> Token
ITopenTExpQuote :: HasE -> Token
ITcloseTExpQuote :: Token
ITdollar :: Token
ITdollardollar :: Token
ITtyQuote :: Token
ITquasiQuote :: (FastString, FastString, PsSpan) -> Token
ITqQuasiQuote :: (FastString, FastString, FastString, PsSpan) -> Token
ITproc :: Token
ITrec :: Token

-- | <pre>
--   (|
--   </pre>
IToparenbar :: IsUnicodeSyntax -> Token

-- | <pre>
--   |)
--   </pre>
ITcparenbar :: IsUnicodeSyntax -> Token

-- | <pre>
--   -&lt;
--   </pre>
ITlarrowtail :: IsUnicodeSyntax -> Token

-- | <pre>
--   &gt;-
--   </pre>
ITrarrowtail :: IsUnicodeSyntax -> Token

-- | <pre>
--   -&lt;&lt;
--   </pre>
ITLarrowtail :: IsUnicodeSyntax -> Token

-- | <pre>
--   &gt;&gt;-
--   </pre>
ITRarrowtail :: IsUnicodeSyntax -> Token

-- | Used when the lexer can't make sense of it
ITunknown :: String -> Token

-- | end of file token
ITeof :: Token

-- | something beginning <tt>-- |</tt>
ITdocCommentNext :: String -> PsSpan -> Token

-- | something beginning <tt>-- ^</tt>
ITdocCommentPrev :: String -> PsSpan -> Token

-- | something beginning <tt>-- $</tt>
ITdocCommentNamed :: String -> PsSpan -> Token

-- | a section heading
ITdocSection :: Int -> String -> PsSpan -> Token

-- | doc options (prune, ignore-exports, etc)
ITdocOptions :: String -> PsSpan -> Token

-- | comment starting by "--"
ITlineComment :: String -> PsSpan -> Token

-- | comment in {- -}
ITblockComment :: String -> PsSpan -> Token
lexer :: Bool -> (Located Token -> P a) -> P a
lexerDbg :: Bool -> (Located Token -> P a) -> P a

-- | Parser options.
--   
--   See <a>mkParserOpts</a> to construct this.
data ParserOpts
ParserOpts :: EnumSet WarningFlag -> !ExtsBitmap -> ParserOpts

-- | enabled warning flags
[pWarningFlags] :: ParserOpts -> EnumSet WarningFlag

-- | bitmap of permitted extensions
[pExtsBitmap] :: ParserOpts -> !ExtsBitmap

-- | Given exactly the information needed, set up the <a>ParserOpts</a>
mkParserOpts :: EnumSet WarningFlag -> EnumSet Extension -> Bool -> Bool -> Bool -> Bool -> ParserOpts
data PState
PState :: StringBuffer -> ParserOpts -> Bag PsWarning -> Bag PsError -> Maybe RealSrcSpan -> !Word -> Maybe (PsLocated Token) -> PsSpan -> PsSpan -> PsSpan -> !Int -> PsLoc -> [LayoutContext] -> [Int] -> [FastString] -> [PsLocated Token] -> Maybe (PsLocated Token) -> PsSpan -> [ALRContext] -> Maybe ALRLayout -> Bool -> Maybe (RealSrcSpan, RealSrcSpan) -> Maybe [LEpaComment] -> [LEpaComment] -> OrdList (PsLocated HdkComment) -> PState
[buffer] :: PState -> StringBuffer
[options] :: PState -> ParserOpts
[warnings] :: PState -> Bag PsWarning
[errors] :: PState -> Bag PsError
[tab_first] :: PState -> Maybe RealSrcSpan
[tab_count] :: PState -> !Word
[last_tk] :: PState -> Maybe (PsLocated Token)
[prev_loc] :: PState -> PsSpan
[prev_loc2] :: PState -> PsSpan
[last_loc] :: PState -> PsSpan
[last_len] :: PState -> !Int
[loc] :: PState -> PsLoc
[context] :: PState -> [LayoutContext]
[lex_state] :: PState -> [Int]
[srcfiles] :: PState -> [FastString]
[alr_pending_implicit_tokens] :: PState -> [PsLocated Token]
[alr_next_token] :: PState -> Maybe (PsLocated Token)
[alr_last_loc] :: PState -> PsSpan
[alr_context] :: PState -> [ALRContext]
[alr_expecting_ocurly] :: PState -> Maybe ALRLayout
[alr_justClosedExplicitLetBlock] :: PState -> Bool
[eof_pos] :: PState -> Maybe (RealSrcSpan, RealSrcSpan)
[header_comments] :: PState -> Maybe [LEpaComment]
[comment_q] :: PState -> [LEpaComment]
[hdk_comments] :: PState -> OrdList (PsLocated HdkComment)

-- | Creates a parse state from a <a>ParserOpts</a> value
initParserState :: ParserOpts -> StringBuffer -> RealSrcLoc -> PState

-- | Set parser options for parsing OPTIONS pragmas
initPragState :: ParserOpts -> StringBuffer -> RealSrcLoc -> PState

-- | The parsing monad, isomorphic to <tt>StateT PState Maybe</tt>.
newtype P a
P :: (PState -> ParseResult a) -> P a
[unP] :: P a -> PState -> ParseResult a

-- | The result of running a parser.
data ParseResult a

-- | The parser has consumed a (possibly empty) prefix of the input and
--   produced a result. Use <a>getMessages</a> to check for accumulated
--   warnings and non-fatal errors.
POk :: PState -> a -> ParseResult a

-- | The parser has consumed a (possibly empty) prefix of the input and
--   failed.
PFailed :: PState -> ParseResult a
allocateComments :: RealSrcSpan -> [LEpaComment] -> ([LEpaComment], [LEpaComment])
allocatePriorComments :: RealSrcSpan -> [LEpaComment] -> Maybe [LEpaComment] -> (Maybe [LEpaComment], [LEpaComment], [LEpaComment])
allocateFinalComments :: RealSrcSpan -> [LEpaComment] -> Maybe [LEpaComment] -> (Maybe [LEpaComment], [LEpaComment], [LEpaComment])

-- | An mtl-style class for monads that support parsing-related operations.
--   For example, sometimes we make a second pass over the parsing results
--   to validate, disambiguate, or rearrange them, and we do so in the PV
--   monad which cannot consume input but can report parsing errors, check
--   for extension bits, and accumulate parsing annotations. Both P and PV
--   are instances of MonadP.
--   
--   MonadP grants us convenient overloading. The other option is to have
--   separate operations for each monad: addErrorP vs addErrorPV, getBitP
--   vs getBitPV, and so on.
class Monad m => MonadP m

-- | Add a non-fatal error. Use this when the parser can produce a result
--   despite the error.
--   
--   For example, when GHC encounters a <tt>forall</tt> in a type, but
--   <tt>-XExplicitForAll</tt> is disabled, the parser constructs
--   <tt>ForAllTy</tt> as if <tt>-XExplicitForAll</tt> was enabled, adding
--   a non-fatal error to the accumulator.
--   
--   Control flow wise, non-fatal errors act like warnings: they are added
--   to the accumulator and parsing continues. This allows GHC to report
--   more than one parse error per file.
addError :: MonadP m => PsError -> m ()

-- | Add a warning to the accumulator. Use <a>getMessages</a> to get the
--   accumulated warnings.
addWarning :: MonadP m => WarningFlag -> PsWarning -> m ()

-- | Add a fatal error. This will be the last error reported by the parser,
--   and the parser will not produce any result, ending in a <a>PFailed</a>
--   state.
addFatalError :: MonadP m => PsError -> m a

-- | Check if a given flag is currently set in the bitmap.
getBit :: MonadP m => ExtBits -> m Bool

-- | Go through the <tt>comment_q</tt> in <tt>PState</tt> and remove all
--   comments that belong within the given span
allocateCommentsP :: MonadP m => RealSrcSpan -> m EpAnnComments

-- | Go through the <tt>comment_q</tt> in <tt>PState</tt> and remove all
--   comments that come before or within the given span
allocatePriorCommentsP :: MonadP m => RealSrcSpan -> m EpAnnComments

-- | Go through the <tt>comment_q</tt> in <tt>PState</tt> and remove all
--   comments that come after the given span
allocateFinalCommentsP :: MonadP m => RealSrcSpan -> m EpAnnComments
getRealSrcLoc :: P RealSrcLoc
getPState :: P PState
failMsgP :: (SrcSpan -> PsError) -> P a
failLocMsgP :: RealSrcLoc -> RealSrcLoc -> (SrcSpan -> PsError) -> P a
srcParseFail :: P a

-- | Get a bag of the errors that have been accumulated so far. Does not
--   take -Werror into account.
getErrorMessages :: PState -> Bag PsError

-- | Get the warnings and errors accumulated so far. Does not take -Werror
--   into account.
getMessages :: PState -> (Bag PsWarning, Bag PsError)
popContext :: P ()
pushModuleContext :: P ()
setLastToken :: PsSpan -> Int -> P ()
setSrcLoc :: RealSrcLoc -> P ()
activeContext :: P Bool
nextIsEOF :: P Bool
getLexState :: P Int
popLexState :: P Int
pushLexState :: Int -> P ()

-- | Various boolean flags, mostly language extensions, that impact lexing
--   and parsing. Note that a handful of these can change during
--   lexing/parsing.
data ExtBits
FfiBit :: ExtBits
InterruptibleFfiBit :: ExtBits
CApiFfiBit :: ExtBits
ArrowsBit :: ExtBits
ThBit :: ExtBits
ThQuotesBit :: ExtBits
IpBit :: ExtBits
OverloadedLabelsBit :: ExtBits
ExplicitForallBit :: ExtBits
BangPatBit :: ExtBits
PatternSynonymsBit :: ExtBits
HaddockBit :: ExtBits
MagicHashBit :: ExtBits
RecursiveDoBit :: ExtBits
QualifiedDoBit :: ExtBits
UnicodeSyntaxBit :: ExtBits
UnboxedTuplesBit :: ExtBits
UnboxedSumsBit :: ExtBits
DatatypeContextsBit :: ExtBits
MonadComprehensionsBit :: ExtBits
TransformComprehensionsBit :: ExtBits
QqBit :: ExtBits
RawTokenStreamBit :: ExtBits
AlternativeLayoutRuleBit :: ExtBits
ALRTransitionalBit :: ExtBits
RelaxedLayoutBit :: ExtBits
NondecreasingIndentationBit :: ExtBits
SafeHaskellBit :: ExtBits
TraditionalRecordSyntaxBit :: ExtBits
ExplicitNamespacesBit :: ExtBits
LambdaCaseBit :: ExtBits
BinaryLiteralsBit :: ExtBits
NegativeLiteralsBit :: ExtBits
HexFloatLiteralsBit :: ExtBits
StaticPointersBit :: ExtBits
NumericUnderscoresBit :: ExtBits
StarIsTypeBit :: ExtBits
BlockArgumentsBit :: ExtBits
NPlusKPatternsBit :: ExtBits
DoAndIfThenElseBit :: ExtBits
MultiWayIfBit :: ExtBits
GadtSyntaxBit :: ExtBits
ImportQualifiedPostBit :: ExtBits
LinearTypesBit :: ExtBits
NoLexicalNegationBit :: ExtBits
OverloadedRecordDotBit :: ExtBits
OverloadedRecordUpdateBit :: ExtBits
InRulePragBit :: ExtBits
InNestedCommentBit :: ExtBits

-- | If this is enabled, '{-# LINE ... -#}' and '{-# COLUMN ... #-}' update
--   the internal position. Otherwise, those pragmas are lexed as tokens of
--   their own.
UsePosPragsBit :: ExtBits
xtest :: ExtBits -> ExtsBitmap -> Bool
xunset :: ExtBits -> ExtsBitmap -> ExtsBitmap
xset :: ExtBits -> ExtsBitmap -> ExtsBitmap
lexTokenStream :: ParserOpts -> StringBuffer -> RealSrcLoc -> ParseResult [Located Token]

-- | Given a <a>SrcSpan</a> that surrounds a <tt>HsPar</tt> or
--   <tt>HsParTy</tt>, generate <a>AddEpAnn</a> values for the opening and
--   closing bordering on the start and end of the span
mkParensEpAnn :: RealSrcSpan -> (AddEpAnn, AddEpAnn)
getCommentsFor :: MonadP m => SrcSpan -> m EpAnnComments
getPriorCommentsFor :: MonadP m => SrcSpan -> m EpAnnComments
getFinalCommentsFor :: MonadP m => SrcSpan -> m EpAnnComments
getEofPos :: P (Maybe (RealSrcSpan, RealSrcSpan))
commentToAnnotation :: RealLocated Token -> LEpaComment

-- | Haddock comment as produced by the lexer. These are accumulated in
--   <a>PState</a> and then processed in
--   <a>GHC.Parser.PostProcess.Haddock</a>.
data HdkComment
HdkCommentNext :: HsDocString -> HdkComment
HdkCommentPrev :: HsDocString -> HdkComment
HdkCommentNamed :: String -> HsDocString -> HdkComment
HdkCommentSection :: Int -> HsDocString -> HdkComment

-- | Test whether a <a>WarningFlag</a> is set
warnopt :: WarningFlag -> ParserOpts -> Bool
instance GHC.Show.Show GHC.Parser.Lexer.Token
instance GHC.Show.Show GHC.Parser.Lexer.LayoutContext
instance GHC.Show.Show GHC.Parser.Lexer.HdkComment
instance GHC.Enum.Enum GHC.Parser.Lexer.ExtBits
instance GHC.Parser.Lexer.MonadP GHC.Parser.Lexer.P
instance GHC.Base.Functor GHC.Parser.Lexer.P
instance GHC.Base.Applicative GHC.Parser.Lexer.P
instance GHC.Base.Monad GHC.Parser.Lexer.P
instance GHC.Utils.Outputable.Outputable GHC.Parser.Lexer.Token


-- | This module implements <a>addHaddockToModule</a>, which inserts
--   Haddock comments accumulated during parsing into the AST (#17544).
--   
--   We process Haddock comments in two phases:
--   
--   <ol>
--   <li>Parse the program (via the Happy parser in <a>y</a>), generating
--   an AST, and (quite separately) a list of all the Haddock comments
--   found in the file. More precisely, the Haddock comments are
--   accumulated in the <a>hdk_comments</a> field of the <a>PState</a>, the
--   parser state (see Lexer.x):data PState = PState { ... , hdk_comments
--   :: [PsLocated HdkComment] }</li>
--   </ol>
--   
--   Each of these Haddock comments has a <a>PsSpan</a>, which gives the
--   <a>BufPos</a> of the beginning and end of the Haddock comment.
--   
--   <ol>
--   <li>Walk over the AST, attaching the Haddock comments to the correct
--   parts of the tree. This step is called <a>addHaddockToModule</a>, and
--   is implemented in this module.</li>
--   </ol>
--   
--   See Note [Adding Haddock comments to the syntax tree].
--   
--   This approach codifies an important principle:
--   
--   The presence or absence of a Haddock comment should never change the
--   parsing of a program.
--   
--   Alternative approaches that did not work properly:
--   
--   <ol>
--   <li>Using <a>SrcLoc</a> instead of <a>BufPos</a>. This led to failures
--   in presence of and other sources of line pragmas. See documentation on
--   <a>BufPos</a> (in GHC.Types.SrcLoc) for the details.</li>
--   <li>In earlier versions of GHC, the Haddock comments were incorporated
--   into the Parser.y grammar. The parser constructed the AST and attached
--   comments to it in a single pass. See Note [Old solution: Haddock in
--   the grammar] for the details.</li>
--   </ol>
module GHC.Parser.PostProcess.Haddock

-- | Add Haddock documentation accumulated in the parser state to a parsed
--   HsModule.
--   
--   Reports badly positioned comments when -Winvalid-haddock is enabled.
addHaddockToModule :: Located HsModule -> P (Located HsModule)
instance GHC.Base.Monoid GHC.Parser.PostProcess.Haddock.HasInnerDocs
instance GHC.Base.Semigroup GHC.Parser.PostProcess.Haddock.HasInnerDocs
instance GHC.Base.Monad GHC.Parser.PostProcess.Haddock.HdkM
instance GHC.Base.Applicative GHC.Parser.PostProcess.Haddock.HdkM
instance GHC.Base.Functor GHC.Parser.PostProcess.Haddock.HdkM
instance GHC.Base.Functor GHC.Parser.PostProcess.Haddock.HdkA
instance GHC.Parser.PostProcess.Haddock.HasHaddock a => GHC.Parser.PostProcess.Haddock.HasHaddock [a]
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Types.SrcLoc.Located GHC.Hs.HsModule)
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedL [GHC.Parser.Annotation.LocatedA (GHC.Hs.ImpExp.IE GHC.Hs.Extension.GhcPs)])
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (GHC.Hs.ImpExp.IE GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.Haddock.HasHaddock (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Types.SrcLoc.Located [GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcPs)])
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedC (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock a => GHC.Parser.PostProcess.Haddock.HasHaddock (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcPs a)
instance GHC.Parser.PostProcess.Haddock.HasHaddock a => GHC.Parser.PostProcess.Haddock.HasHaddock (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcPs a)
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcPs))
instance GHC.Base.Applicative GHC.Parser.PostProcess.Haddock.HdkA
instance GHC.Base.Semigroup GHC.Parser.PostProcess.Haddock.LocRange
instance GHC.Base.Monoid GHC.Parser.PostProcess.Haddock.LocRange
instance GHC.Base.Semigroup GHC.Parser.PostProcess.Haddock.ColumnBound
instance GHC.Base.Monoid GHC.Parser.PostProcess.Haddock.ColumnBound
instance GHC.Base.Semigroup GHC.Parser.PostProcess.Haddock.UpperLocBound
instance GHC.Base.Monoid GHC.Parser.PostProcess.Haddock.UpperLocBound
instance GHC.Base.Semigroup GHC.Parser.PostProcess.Haddock.LowerLocBound
instance GHC.Base.Monoid GHC.Parser.PostProcess.Haddock.LowerLocBound

module GHC.Parser.PostProcess
mkRdrGetField :: SrcSpanAnnA -> LHsExpr GhcPs -> Located (HsFieldLabel GhcPs) -> EpAnnCO -> LHsExpr GhcPs
mkRdrProjection :: NonEmpty (Located (HsFieldLabel GhcPs)) -> EpAnn AnnProjection -> HsExpr GhcPs
type Fbind b = Either (LHsRecField GhcPs (LocatedA b)) (LHsRecProj GhcPs (LocatedA b))

-- | A useful function for building <tt>OpApps</tt>. The operator is always
--   a variable, and we don't know the fixity yet.
mkHsOpApp :: LHsExpr GhcPs -> IdP GhcPs -> LHsExpr GhcPs -> HsExpr GhcPs
mkHsIntegral :: IntegralLit -> HsOverLit GhcPs
mkHsFractional :: FractionalLit -> HsOverLit GhcPs
mkHsIsString :: SourceText -> FastString -> HsOverLit GhcPs
mkHsDo :: HsStmtContext GhcRn -> LocatedL [ExprLStmt GhcPs] -> HsExpr GhcPs
mkSpliceDecl :: LHsExpr GhcPs -> P (LHsDecl GhcPs)
mkRoleAnnotDecl :: SrcSpan -> LocatedN RdrName -> [Located (Maybe FastString)] -> [AddEpAnn] -> P (LRoleAnnotDecl GhcPs)
mkClassDecl :: SrcSpan -> Located (Maybe (LHsContext GhcPs), LHsType GhcPs) -> Located (a, [LHsFunDep GhcPs]) -> OrdList (LHsDecl GhcPs) -> LayoutInfo -> [AddEpAnn] -> P (LTyClDecl GhcPs)
mkTyData :: SrcSpan -> NewOrData -> Maybe (LocatedP CType) -> Located (Maybe (LHsContext GhcPs), LHsType GhcPs) -> Maybe (LHsKind GhcPs) -> [LConDecl GhcPs] -> Located (HsDeriving GhcPs) -> [AddEpAnn] -> P (LTyClDecl GhcPs)
mkDataFamInst :: SrcSpan -> NewOrData -> Maybe (LocatedP CType) -> (Maybe (LHsContext GhcPs), HsOuterFamEqnTyVarBndrs GhcPs, LHsType GhcPs) -> Maybe (LHsKind GhcPs) -> [LConDecl GhcPs] -> Located (HsDeriving GhcPs) -> [AddEpAnn] -> P (LInstDecl GhcPs)
mkTySynonym :: SrcSpan -> LHsType GhcPs -> LHsType GhcPs -> [AddEpAnn] -> P (LTyClDecl GhcPs)
mkTyFamInstEqn :: SrcSpan -> HsOuterFamEqnTyVarBndrs GhcPs -> LHsType GhcPs -> LHsType GhcPs -> [AddEpAnn] -> P (LTyFamInstEqn GhcPs)
mkStandaloneKindSig :: SrcSpan -> Located [LocatedN RdrName] -> LHsSigType GhcPs -> [AddEpAnn] -> P (LStandaloneKindSig GhcPs)
mkTyFamInst :: SrcSpan -> TyFamInstEqn GhcPs -> [AddEpAnn] -> P (LInstDecl GhcPs)
mkFamDecl :: SrcSpan -> FamilyInfo GhcPs -> TopLevelFlag -> LHsType GhcPs -> Located (FamilyResultSig GhcPs) -> Maybe (LInjectivityAnn GhcPs) -> [AddEpAnn] -> P (LTyClDecl GhcPs)
mkInlinePragma :: SourceText -> (InlineSpec, RuleMatchInfo) -> Maybe Activation -> InlinePragma
mkPatSynMatchGroup :: LocatedN RdrName -> LocatedL (OrdList (LHsDecl GhcPs)) -> P (MatchGroup GhcPs (LHsExpr GhcPs))
mkRecConstrOrUpdate :: Bool -> LHsExpr GhcPs -> SrcSpan -> ([Fbind (HsExpr GhcPs)], Maybe SrcSpan) -> EpAnn [AddEpAnn] -> PV (HsExpr GhcPs)

-- | mkClassDecl builds a RdrClassDecl, filling in the names for tycon and
--   datacon by deriving them from the name of the class. We fill in the
--   names for the tycon and datacon corresponding to the class, by
--   deriving them from the name of the class itself. This saves recording
--   the names in the interface file (which would be equally good).
mkTyClD :: LTyClDecl (GhcPass p) -> LHsDecl (GhcPass p)
mkInstD :: LInstDecl (GhcPass p) -> LHsDecl (GhcPass p)
mkRdrRecordCon :: LocatedN RdrName -> HsRecordBinds GhcPs -> EpAnn [AddEpAnn] -> HsExpr GhcPs
mkRdrRecordUpd :: Bool -> LHsExpr GhcPs -> [Fbind (HsExpr GhcPs)] -> EpAnn [AddEpAnn] -> PV (HsExpr GhcPs)

-- | This rather gruesome function is used mainly by the parser. When
--   parsing:
--   
--   <pre>
--   data T a = T | T1 Int
--   </pre>
--   
--   we parse the data constructors as <i>types</i> because of parser
--   ambiguities, so then we need to change the <i>type constr</i> to a
--   <i>data constr</i>
--   
--   The exact-name case <i>can</i> occur when parsing:
--   
--   <pre>
--   data [] a = [] | a : [a]
--   </pre>
--   
--   For the exact-name case we return an original name.
setRdrNameSpace :: RdrName -> NameSpace -> RdrName

-- | Converts <a>LHsTyVarBndr</a> annotated with its <a>Specificity</a> to
--   one without annotations. Only accepts specified variables, and errors
--   if the provided binder has an <a>InferredSpec</a> annotation.
fromSpecTyVarBndr :: LHsTyVarBndr Specificity GhcPs -> P (LHsTyVarBndr () GhcPs)

-- | Converts a list of <a>LHsTyVarBndr</a>s annotated with their
--   <a>Specificity</a> to binders without annotations. Only accepts
--   specified variables, and errors if any of the provided binders has an
--   <a>InferredSpec</a> annotation.
fromSpecTyVarBndrs :: [LHsTyVarBndr Specificity GhcPs] -> P [LHsTyVarBndr () GhcPs]

-- | Add the annotation for a 'where' keyword to existing
--   <tt>HsLocalBinds</tt>
annBinds :: AddEpAnn -> EpAnnComments -> HsLocalBinds GhcPs -> (HsLocalBinds GhcPs, Maybe EpAnnComments)
cvBindGroup :: OrdList (LHsDecl GhcPs) -> P (HsValBinds GhcPs)
cvBindsAndSigs :: OrdList (LHsDecl GhcPs) -> P (LHsBinds GhcPs, [LSig GhcPs], [LFamilyDecl GhcPs], [LTyFamInstDecl GhcPs], [LDataFamInstDecl GhcPs], [LDocDecl GhcPs])

-- | Function definitions are restructured here. Each is assumed to be
--   recursive initially, and non recursive definitions are discovered by
--   the dependency analyser.
cvTopDecls :: OrdList (LHsDecl GhcPs) -> [LHsDecl GhcPs]
placeHolderPunRhs :: DisambECP b => PV (LocatedA b)
mkImport :: Located CCallConv -> Located Safety -> (Located StringLiteral, LocatedN RdrName, LHsSigType GhcPs) -> P (EpAnn [AddEpAnn] -> HsDecl GhcPs)
parseCImport :: Located CCallConv -> Located Safety -> FastString -> String -> Located SourceText -> Maybe ForeignImport
mkExport :: Located CCallConv -> (Located StringLiteral, LocatedN RdrName, LHsSigType GhcPs) -> P (EpAnn [AddEpAnn] -> HsDecl GhcPs)
mkExtName :: RdrName -> CLabelString

-- | Construct a GADT-style data constructor from the constructor names and
--   their type. Some interesting aspects of this function:
--   
--   <ul>
--   <li>This splits up the constructor type into its quantified type
--   variables (if provided), context (if provided), argument types, and
--   result type, and records whether this is a prefix or record GADT
--   constructor. See Note [GADT abstract syntax] in <a>GHC.Hs.Decls</a>
--   for more details.</li>
--   </ul>
mkGadtDecl :: SrcSpan -> [LocatedN RdrName] -> LHsSigType GhcPs -> [AddEpAnn] -> P (LConDecl GhcPs)
mkConDeclH98 :: EpAnn [AddEpAnn] -> LocatedN RdrName -> Maybe [LHsTyVarBndr Specificity GhcPs] -> Maybe (LHsContext GhcPs) -> HsConDeclH98Details GhcPs -> ConDecl GhcPs
checkImportDecl :: Maybe EpaLocation -> Maybe EpaLocation -> P ()

-- | Yield a parse error if we have a function applied directly to a do
--   block etc. and BlockArguments is not enabled.
checkExpBlockArguments :: LHsExpr GhcPs -> PV ()
checkCmdBlockArguments :: LHsCmd GhcPs -> PV ()

-- | Check if a fixity is valid. We support bypassing the usual bound
--   checks for some special operators.
checkPrecP :: Located (SourceText, Int) -> Located (OrdList (LocatedN RdrName)) -> P ()

-- | Validate the context constraints and break up a context into a list of
--   predicates.
--   
--   <pre>
--   (Eq a, Ord b)        --&gt;  [Eq a, Ord b]
--   Eq a                 --&gt;  [Eq a]
--   (Eq a)               --&gt;  [Eq a]
--   (((Eq a)))           --&gt;  [Eq a]
--   </pre>
checkContext :: LHsType GhcPs -> P (LHsContext GhcPs)
checkPattern :: LocatedA (PatBuilder GhcPs) -> P (LPat GhcPs)
checkPattern_hints :: [Hint] -> PV (LocatedA (PatBuilder GhcPs)) -> P (LPat GhcPs)

-- | Check for monad comprehensions
--   
--   If the flag MonadComprehensions is set, return a <a>MonadComp</a>
--   context, otherwise use the usual <a>ListComp</a> context
checkMonadComp :: PV (HsStmtContext GhcRn)
checkValDef :: SrcSpan -> LocatedA (PatBuilder GhcPs) -> Maybe (AddEpAnn, LHsType GhcPs) -> Located (GRHSs GhcPs (LHsExpr GhcPs)) -> P (HsBind GhcPs)
checkValSigLhs :: LHsExpr GhcPs -> P (LocatedN RdrName)
type LRuleTyTmVar = Located RuleTyTmVar

-- | Essentially a wrapper for a <tt>RuleBndr GhcPs</tt>
data RuleTyTmVar
RuleTyTmVar :: EpAnn [AddEpAnn] -> LocatedN RdrName -> Maybe (LHsType GhcPs) -> RuleTyTmVar
mkRuleBndrs :: [LRuleTyTmVar] -> [LRuleBndr GhcPs]
mkRuleTyVarBndrs :: [LRuleTyTmVar] -> [LHsTyVarBndr () GhcPs]
checkRuleTyVarBndrNames :: [LHsTyVarBndr flag GhcPs] -> P ()
checkRecordSyntax :: (MonadP m, Outputable a) => LocatedA a -> m (LocatedA a)

-- | Check if the gadt_constrlist is empty. Only raise parse error for
--   `data T where` to avoid affecting existing error message, see #8258.
checkEmptyGADTs :: Located ([AddEpAnn], [LConDecl GhcPs]) -> P (Located ([AddEpAnn], [LConDecl GhcPs]))

-- | Add a fatal error. This will be the last error reported by the parser,
--   and the parser will not produce any result, ending in a <a>PFailed</a>
--   state.
addFatalError :: MonadP m => PsError -> m a

-- | Hint about bang patterns, assuming <tt>BangPatterns</tt> is off.
hintBangPat :: SrcSpan -> Pat GhcPs -> PV ()
mkBangTy :: EpAnn [AddEpAnn] -> SrcStrictness -> LHsType GhcPs -> HsType GhcPs

-- | Result of parsing <tt>{-# UNPACK #-}</tt> or <tt>{-# NOUNPACK
--   #-}</tt>.
data UnpackednessPragma
UnpackednessPragma :: [AddEpAnn] -> SourceText -> SrcUnpackedness -> UnpackednessPragma
mkMultTy :: IsUnicodeSyntax -> Located Token -> LHsType GhcPs -> HsArrow GhcPs
data ImpExpSubSpec
ImpExpAbs :: ImpExpSubSpec
ImpExpAll :: ImpExpSubSpec
ImpExpList :: [LocatedA ImpExpQcSpec] -> ImpExpSubSpec
ImpExpAllWith :: [LocatedA ImpExpQcSpec] -> ImpExpSubSpec
data ImpExpQcSpec
ImpExpQcName :: LocatedN RdrName -> ImpExpQcSpec
ImpExpQcType :: EpaLocation -> LocatedN RdrName -> ImpExpQcSpec
ImpExpQcWildcard :: ImpExpQcSpec
mkModuleImpExp :: [AddEpAnn] -> LocatedA ImpExpQcSpec -> ImpExpSubSpec -> P (IE GhcPs)
mkTypeImpExp :: LocatedN RdrName -> P (LocatedN RdrName)
mkImpExpSubSpec :: [LocatedA ImpExpQcSpec] -> P ([AddEpAnn], ImpExpSubSpec)
checkImportSpec :: LocatedL [LIE GhcPs] -> P (LocatedL [LIE GhcPs])
starSym :: Bool -> String
warnStarIsType :: SrcSpan -> P ()
warnPrepositiveQualifiedModule :: SrcSpan -> P ()
failOpFewArgs :: MonadP m => LocatedN RdrName -> m a
failOpNotEnabledImportQualifiedPost :: SrcSpan -> P ()
failOpImportQualifiedTwice :: SrcSpan -> P ()
data SumOrTuple b

-- | Last two are the locations of the '|' before and after the payload
Sum :: ConTag -> Arity -> LocatedA b -> [EpaLocation] -> [EpaLocation] -> SumOrTuple b
Tuple :: [Either (EpAnn EpaLocation) (LocatedA b)] -> SumOrTuple b
data PV a
runPV :: PV a -> P a
newtype ECP
ECP :: (forall b. DisambECP b => PV (LocatedA b)) -> ECP
[unECP] :: ECP -> forall b. DisambECP b => PV (LocatedA b)

-- | Disambiguate infix operators. See Note [Ambiguous syntactic
--   categories]
class DisambInfixOp b
mkHsVarOpPV :: DisambInfixOp b => LocatedN RdrName -> PV (LocatedN b)
mkHsConOpPV :: DisambInfixOp b => LocatedN RdrName -> PV (LocatedN b)
mkHsInfixHolePV :: DisambInfixOp b => SrcSpan -> (EpAnnComments -> EpAnn EpAnnUnboundVar) -> PV (Located b)

-- | Disambiguate constructs that may appear when we do not know ahead of
--   time whether we are parsing an expression, a command, or a pattern.
--   See Note [Ambiguous syntactic categories]
class (b ~ (Body b) GhcPs, AnnoBody b) => DisambECP b where {
    
    -- | See Note [Body in DisambECP]
    type Body b :: Type -> Type;
    
    -- | Infix operator representation
    type InfixOp b;
    
    -- | Function argument representation
    type FunArg b;
}

-- | Return a command without ambiguity, or fail in a non-command context.
ecpFromCmd' :: DisambECP b => LHsCmd GhcPs -> PV (LocatedA b)

-- | Return an expression without ambiguity, or fail in a non-expression
--   context.
ecpFromExp' :: DisambECP b => LHsExpr GhcPs -> PV (LocatedA b)
mkHsProjUpdatePV :: DisambECP b => SrcSpan -> Located [Located (HsFieldLabel GhcPs)] -> LocatedA b -> Bool -> [AddEpAnn] -> PV (LHsRecProj GhcPs (LocatedA b))

-- | Disambiguate "... -&gt; ..." (lambda)
mkHsLamPV :: DisambECP b => SrcSpan -> (EpAnnComments -> MatchGroup GhcPs (LocatedA b)) -> PV (LocatedA b)

-- | Disambiguate "let ... in ..."
mkHsLetPV :: DisambECP b => SrcSpan -> HsLocalBinds GhcPs -> LocatedA b -> AnnsLet -> PV (LocatedA b)

-- | Bring superclass constraints on InfixOp into scope. See Note
--   [UndecidableSuperClasses for associated types]
superInfixOp :: DisambECP b => (DisambInfixOp (InfixOp b) => PV (LocatedA b)) -> PV (LocatedA b)

-- | Disambiguate "f # x" (infix operator)
mkHsOpAppPV :: DisambECP b => SrcSpan -> LocatedA b -> LocatedN (InfixOp b) -> LocatedA b -> PV (LocatedA b)

-- | Disambiguate "case ... of ..."
mkHsCasePV :: DisambECP b => SrcSpan -> LHsExpr GhcPs -> LocatedL [LMatch GhcPs (LocatedA b)] -> EpAnnHsCase -> PV (LocatedA b)
mkHsLamCasePV :: DisambECP b => SrcSpan -> LocatedL [LMatch GhcPs (LocatedA b)] -> [AddEpAnn] -> PV (LocatedA b)

-- | Bring superclass constraints on FunArg into scope. See Note
--   [UndecidableSuperClasses for associated types]
superFunArg :: DisambECP b => (DisambECP (FunArg b) => PV (LocatedA b)) -> PV (LocatedA b)

-- | Disambiguate "f x" (function application)
mkHsAppPV :: DisambECP b => SrcSpanAnnA -> LocatedA b -> LocatedA (FunArg b) -> PV (LocatedA b)

-- | Disambiguate "f @t" (visible type application)
mkHsAppTypePV :: DisambECP b => SrcSpanAnnA -> LocatedA b -> SrcSpan -> LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate "if ... then ... else ..."
mkHsIfPV :: DisambECP b => SrcSpan -> LHsExpr GhcPs -> Bool -> LocatedA b -> Bool -> LocatedA b -> AnnsIf -> PV (LocatedA b)

-- | Disambiguate "do { ... }" (do notation)
mkHsDoPV :: DisambECP b => SrcSpan -> Maybe ModuleName -> LocatedL [LStmt GhcPs (LocatedA b)] -> AnnList -> PV (LocatedA b)

-- | Disambiguate "( ... )" (parentheses)
mkHsParPV :: DisambECP b => SrcSpan -> LocatedA b -> AnnParen -> PV (LocatedA b)

-- | Disambiguate a variable "f" or a data constructor <a>MkF</a>.
mkHsVarPV :: DisambECP b => LocatedN RdrName -> PV (LocatedA b)

-- | Disambiguate a monomorphic literal
mkHsLitPV :: DisambECP b => Located (HsLit GhcPs) -> PV (Located b)

-- | Disambiguate an overloaded literal
mkHsOverLitPV :: DisambECP b => Located (HsOverLit GhcPs) -> PV (Located b)

-- | Disambiguate a wildcard
mkHsWildCardPV :: DisambECP b => SrcSpan -> PV (Located b)

-- | Disambiguate "a :: t" (type annotation)
mkHsTySigPV :: DisambECP b => SrcSpanAnnA -> LocatedA b -> LHsType GhcPs -> [AddEpAnn] -> PV (LocatedA b)

-- | Disambiguate "[a,b,c]" (list syntax)
mkHsExplicitListPV :: DisambECP b => SrcSpan -> [LocatedA b] -> AnnList -> PV (LocatedA b)

-- | Disambiguate "$(...)" and "[quasi|...|]" (TH splices)
mkHsSplicePV :: DisambECP b => Located (HsSplice GhcPs) -> PV (Located b)

-- | Disambiguate "f { a = b, ... }" syntax (record construction and record
--   updates)
mkHsRecordPV :: DisambECP b => Bool -> SrcSpan -> SrcSpan -> LocatedA b -> ([Fbind b], Maybe SrcSpan) -> [AddEpAnn] -> PV (LocatedA b)

-- | Disambiguate "-a" (negation)
mkHsNegAppPV :: DisambECP b => SrcSpan -> LocatedA b -> [AddEpAnn] -> PV (LocatedA b)

-- | Disambiguate "(# a)" (right operator section)
mkHsSectionR_PV :: DisambECP b => SrcSpan -> LocatedA (InfixOp b) -> LocatedA b -> PV (Located b)

-- | Disambiguate "(a -&gt; b)" (view pattern)
mkHsViewPatPV :: DisambECP b => SrcSpan -> LHsExpr GhcPs -> LocatedA b -> [AddEpAnn] -> PV (LocatedA b)

-- | Disambiguate "a@b" (as-pattern)
mkHsAsPatPV :: DisambECP b => SrcSpan -> LocatedN RdrName -> LocatedA b -> [AddEpAnn] -> PV (LocatedA b)

-- | Disambiguate "~a" (lazy pattern)
mkHsLazyPatPV :: DisambECP b => SrcSpan -> LocatedA b -> [AddEpAnn] -> PV (LocatedA b)

-- | Disambiguate "!a" (bang pattern)
mkHsBangPatPV :: DisambECP b => SrcSpan -> LocatedA b -> [AddEpAnn] -> PV (LocatedA b)

-- | Disambiguate tuple sections and unboxed sums
mkSumOrTuplePV :: DisambECP b => SrcSpanAnnA -> Boxity -> SumOrTuple b -> [AddEpAnn] -> PV (LocatedA b)

-- | Validate infixexp LHS to reject unwanted {-# SCC ... #-} pragmas
rejectPragmaPV :: DisambECP b => LocatedA b -> PV ()
ecpFromExp :: LHsExpr GhcPs -> ECP
ecpFromCmd :: LHsCmd GhcPs -> ECP

-- | See Note [Ambiguous syntactic categories] and Note [PatBuilder]
data PatBuilder p

-- | Disambiguate constructs that may appear when we do not know ahead of
--   time whether we are parsing a type or a newtype/data constructor.
--   
--   See Note [Ambiguous syntactic categories] for the general idea.
--   
--   See Note [Parsing data constructors is hard] for the specific issue
--   this particular class is solving.
class DisambTD b

-- | Process the head of a type-level function/constructor application,
--   i.e. the <tt>H</tt> in <tt>H a b c</tt>.
mkHsAppTyHeadPV :: DisambTD b => LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate <tt>f x</tt> (function application or prefix data
--   constructor).
mkHsAppTyPV :: DisambTD b => LocatedA b -> LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate <tt>f @t</tt> (visible kind application)
mkHsAppKindTyPV :: DisambTD b => LocatedA b -> SrcSpan -> LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate <tt>f # x</tt> (infix operator)
mkHsOpTyPV :: DisambTD b => LHsType GhcPs -> LocatedN RdrName -> LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate <tt>{-# UNPACK #-} t</tt> (unpack/nounpack pragma)
mkUnpackednessPV :: DisambTD b => Located UnpackednessPragma -> LocatedA b -> PV (LocatedA b)

-- | Annotate a type with either an <tt>{-# UNPACK #-}</tt> or a <tt>{-#
--   NOUNPACK #-}</tt> pragma.
addUnpackednessP :: MonadP m => Located UnpackednessPragma -> LHsType GhcPs -> m (LHsType GhcPs)
dataConBuilderCon :: DataConBuilder -> LocatedN RdrName
dataConBuilderDetails :: DataConBuilder -> HsConDeclH98Details GhcPs
instance GHC.Parser.PostProcess.DisambECP (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambECP (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambECP (GHC.Parser.Types.PatBuilder GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambInfixOp (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambInfixOp GHC.Types.Name.Reader.RdrName
instance GHC.Parser.PostProcess.DisambTD (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambTD GHC.Parser.Types.DataConBuilder
instance GHC.Base.Functor GHC.Parser.PostProcess.PV
instance GHC.Base.Applicative GHC.Parser.PostProcess.PV
instance GHC.Base.Monad GHC.Parser.PostProcess.PV
instance GHC.Parser.Lexer.MonadP GHC.Parser.PostProcess.PV

module GHC.ThToHs
convertToHsExpr :: Origin -> SrcSpan -> Exp -> Either SDoc (LHsExpr GhcPs)
convertToPat :: Origin -> SrcSpan -> Pat -> Either SDoc (LPat GhcPs)
convertToHsDecls :: Origin -> SrcSpan -> [Dec] -> Either SDoc [LHsDecl GhcPs]
convertToHsType :: Origin -> SrcSpan -> Type -> Either SDoc (LHsType GhcPs)
thRdrNameGuesses :: Name -> [RdrName]
instance GHC.Base.Functor GHC.ThToHs.CvtM
instance GHC.ThToHs.CvtFlag () ()
instance GHC.ThToHs.CvtFlag Language.Haskell.TH.Syntax.Specificity GHC.Types.Var.Specificity
instance GHC.Base.Applicative GHC.ThToHs.CvtM
instance GHC.Base.Monad GHC.ThToHs.CvtM


-- | Subsystem configuration
module GHC.Driver.Config

-- | Initialise coercion optimiser configuration from DynFlags
initOptCoercionOpts :: DynFlags -> OptCoercionOpts

-- | Initialise Simple optimiser configuration from DynFlags
initSimpleOpts :: DynFlags -> SimpleOpts

-- | Extracts the flag information needed for parsing
initParserOpts :: DynFlags -> ParserOpts

module GHC.Core.Opt.Simplify.Monad
data SimplM result
initSmpl :: Logger -> DynFlags -> RuleEnv -> (FamInstEnv, FamInstEnv) -> Int -> SimplM a -> IO (a, SimplCount)
traceSmpl :: String -> SDoc -> SimplM ()
getSimplRules :: SimplM RuleEnv
getFamEnvs :: SimplM (FamInstEnv, FamInstEnv)
getOptCoercionOpts :: SimplM OptCoercionOpts

-- | A monad for generating unique identifiers
class Monad m => MonadUnique m

-- | Get a new UniqueSupply
getUniqueSupplyM :: MonadUnique m => m UniqSupply

-- | Get a new unique identifier
getUniqueM :: MonadUnique m => m Unique

-- | Get an infinite list of new unique identifiers
getUniquesM :: MonadUnique m => m [Unique]
newId :: FastString -> Mult -> Type -> SimplM Id
newJoinId :: [Var] -> Type -> SimplM Id
data SimplCount
tick :: Tick -> SimplM ()
freeTick :: Tick -> SimplM ()
checkedTick :: Tick -> SimplM ()
getSimplCount :: SimplM SimplCount
zeroSimplCount :: DynFlags -> SimplCount
pprSimplCount :: SimplCount -> SDoc
plusSimplCount :: SimplCount -> SimplCount -> SimplCount
isZeroSimplCount :: SimplCount -> Bool
instance GHC.Base.Functor GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Base.Applicative GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Base.Monad GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Types.Unique.Supply.MonadUnique GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Driver.Session.HasDynFlags GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Utils.Logger.HasLogger GHC.Core.Opt.Simplify.Monad.SimplM
instance Control.Monad.IO.Class.MonadIO GHC.Core.Opt.Simplify.Monad.SimplM

module GHC.Parser.Errors.Ppr
pprWarning :: PsWarning -> MsgEnvelope DecoratedSDoc
pprError :: PsError -> MsgEnvelope DecoratedSDoc


-- | Extract docs from the renamer output so they can be serialized.
module GHC.HsToCore.Docs

-- | Extract docs from renamer output. This is monadic since we need to be
--   able to read documentation added from Template Haskell's
--   <tt>putDoc</tt>, which is stored in <a>tcg_th_docs</a>.
extractDocs :: MonadIO m => TcGblEnv -> m (Maybe HsDocString, DeclDocMap, ArgDocMap)

-- | Create decl and arg doc-maps by looping through the declarations. For
--   each declaration, find its names, its subordinates, and its doc
--   strings.
mkMaps :: [Name] -> [(LHsDecl GhcRn, [HsDocString])] -> (Map Name HsDocString, Map Name (IntMap HsDocString))
getMainDeclBinder :: (Anno (IdGhcP p) ~ SrcSpanAnnN, CollectPass (GhcPass p)) => HsDecl (GhcPass p) -> [IdP (GhcPass p)]
sigNameNoLoc :: forall pass. UnXRec pass => Sig pass -> [IdP pass]
getInstLoc :: Anno (IdGhcP p) ~ SrcSpanAnnN => InstDecl (GhcPass p) -> SrcSpan

-- | Get all subordinate declarations inside a declaration, and their docs.
--   A subordinate declaration is something like the associate type or data
--   family of a type class.
subordinates :: Map RealSrcSpan Name -> HsDecl GhcRn -> [(Name, [HsDocString], IntMap HsDocString)]

-- | Extract constructor argument docs from inside constructor decls.
conArgDocs :: ConDecl GhcRn -> IntMap HsDocString
h98ConArgDocs :: HsConDeclH98Details GhcRn -> IntMap HsDocString
gadtConArgDocs :: HsConDeclGADTDetails GhcRn -> HsType GhcRn -> IntMap HsDocString
con_arg_docs :: Int -> [HsType GhcRn] -> IntMap HsDocString
isValD :: HsDecl a -> Bool

-- | All the sub declarations of a class (that we handle), ordered by
--   source location, with documentation attached if it exists.
classDecls :: TyClDecl GhcRn -> [(LHsDecl GhcRn, [HsDocString])]

-- | Extract function argument docs from inside top-level decls.
declTypeDocs :: HsDecl GhcRn -> IntMap HsDocString
nubByName :: (a -> Name) -> [a] -> [a]

-- | Extract function argument docs from inside types.
typeDocs :: HsType GhcRn -> IntMap HsDocString

-- | Extract function argument docs from inside types.
sigTypeDocs :: HsSigType GhcRn -> IntMap HsDocString

-- | The top-level declarations of a module that we care about, ordered by
--   source location, with documentation attached if it exists.
topDecls :: HsGroup GhcRn -> [(LHsDecl GhcRn, [HsDocString])]

-- | Take all declarations except pragmas, infix decls, rules from an
--   <a>HsGroup</a>.
ungroup :: HsGroup GhcRn -> [LHsDecl GhcRn]

-- | Collect docs and attach them to the right declarations.
--   
--   A declaration may have multiple doc strings attached to it.
--   
--   This is an example.
collectDocs :: forall p. UnXRec p => [LHsDecl p] -> [(LHsDecl p, [HsDocString])]

-- | Filter out declarations that we don't handle in Haddock
filterDecls :: forall p doc. UnXRec p => [(LHsDecl p, doc)] -> [(LHsDecl p, doc)]

-- | Go through all class declarations and filter their sub-declarations
filterClasses :: forall p doc. IsPass p => [(LHsDecl (GhcPass p), doc)] -> [(LHsDecl (GhcPass p), doc)]

-- | Was this signature given by the user?
isUserSig :: Sig name -> Bool

-- | Take a field of declarations from a data structure and create HsDecls
--   using the given constructor
mkDecls :: (struct -> [GenLocated l decl]) -> (decl -> hsDecl) -> struct -> [GenLocated l hsDecl]

-- | Extracts out individual maps of documentation added via Template
--   Haskell's <tt>putDoc</tt>.
extractTHDocs :: THDocs -> ExtractedTHDocs

-- | Unions together two <tt>ArgDocMaps</tt> (or ArgMaps in haddock-api),
--   such that two maps with values for the same key merge the inner map as
--   well. Left biased so <tt>unionArgMaps a b</tt> prefers <tt>a</tt> over
--   <tt>b</tt>.
unionArgMaps :: Map Name (IntMap b) -> Map Name (IntMap b) -> Map Name (IntMap b)

module GHC.Tc.Types.EvTerm
evDelayedError :: Type -> FastString -> EvTerm
evCallStack :: (MonadThings m, HasModule m, HasDynFlags m) => EvCallStack -> m EvExpr

module GHC.Stg.Unarise
unarise :: UniqSupply -> [StgTopBinding] -> [StgTopBinding]
instance GHC.Utils.Outputable.Outputable GHC.Stg.Unarise.UnariseVal

module GHC.Core.Opt.WorkWrap.Utils
mkWwBodies :: DynFlags -> FamInstEnvs -> VarSet -> Id -> [Demand] -> Cpr -> UniqSM (Maybe WwResult)
mkWWstr :: DynFlags -> FamInstEnvs -> Bool -> [Var] -> UniqSM (Bool, [Var], CoreExpr -> CoreExpr, CoreExpr -> CoreExpr)
mkWorkerArgs :: DynFlags -> [Var] -> Type -> ([Var], [Var])

-- | The information needed to build a pattern for a DataCon to be unboxed.
--   The pattern can be generated from <a>dcpc_dc</a> and
--   <a>dcpc_tc_args</a> via <a>dataConRepInstPat</a>. The coercion
--   <a>dcpc_co</a> is for newtype wrappers.
--   
--   If we get <tt>DataConPatContext dc tys co</tt> for some type
--   <tt>ty</tt> and <tt>dataConRepInstPat ... dc tys = (exs, flds)</tt>,
--   then
--   
--   <ul>
--   <li><tt>dc </tt>exs flds :: T tys@</li>
--   <li><pre>co :: T tys ~ ty</pre></li>
--   </ul>
data DataConPatContext
DataConPatContext :: !DataCon -> ![Type] -> !Coercion -> DataConPatContext
[dcpc_dc] :: DataConPatContext -> !DataCon
[dcpc_tc_args] :: DataConPatContext -> ![Type]
[dcpc_co] :: DataConPatContext -> !Coercion

-- | Describes the outer shape of an argument to be unboxed or left as-is
--   Depending on how <tt>s</tt> is instantiated (e.g., <a>Demand</a>).
data UnboxingDecision s

-- | We ran out of strictness info. Leave untouched.
StopUnboxing :: UnboxingDecision s

-- | The argument is used strictly or the returned product was constructed,
--   so unbox it. The <a>DataConPatContext</a> carries the bits necessary
--   for instantiation with <tt>dataConRepInstPat</tt>. The <tt>[s]</tt>
--   carries the bits of information with which we can continue unboxing,
--   e.g. <tt>s</tt> will be <a>Demand</a>.
Unbox :: !DataConPatContext -> [s] -> UnboxingDecision s

-- | If <tt>splitArgType_maybe ty = Just (dc, tys, co)</tt> then <tt>dc
--   @tys @_ex_tys (_args::_arg_tys) :: tc tys</tt> and <tt>co :: ty ~ tc
--   tys</tt> where underscore prefixes are holes, e.g. yet unspecified.
--   
--   See Note [Which types are unboxed?].
splitArgType_maybe :: FamInstEnvs -> Type -> Maybe DataConPatContext
wantToUnbox :: FamInstEnvs -> Bool -> Type -> Demand -> UnboxingDecision Demand
findTypeShape :: FamInstEnvs -> Type -> TypeShape
isWorkerSmallEnough :: DynFlags -> Int -> [Var] -> Bool


-- | Constructed Product Result analysis. Identifies functions that surely
--   return heap-allocated records on every code path, so that we can
--   eliminate said heap allocation by performing a worker/wrapper split.
--   
--   See
--   <a>https://www.microsoft.com/en-us/research/publication/constructed-product-result-analysis-haskell/</a>.
--   CPR analysis should happen after strictness analysis. See Note [Phase
--   ordering].
module GHC.Core.Opt.CprAnal
cprAnalProgram :: Logger -> DynFlags -> FamInstEnvs -> CoreProgram -> IO CoreProgram
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.CprAnal.AnalEnv
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.CprAnal.SigEnv


-- | Functions for collecting together and applying rewrite rules to a
--   module. The <a>CoreRule</a> datatype itself is declared elsewhere.
module GHC.Core.Rules
emptyRuleBase :: RuleBase
mkRuleBase :: [CoreRule] -> RuleBase
extendRuleBaseList :: RuleBase -> [CoreRule] -> RuleBase
unionRuleBase :: RuleBase -> RuleBase -> RuleBase
pprRuleBase :: RuleBase -> SDoc

-- | Report partial matches for rules beginning with the specified string
--   for the purposes of error reporting
ruleCheckProgram :: RuleOpts -> CompilerPhase -> String -> (Id -> [CoreRule]) -> CoreProgram -> SDoc
extendRuleInfo :: RuleInfo -> [CoreRule] -> RuleInfo
addRuleInfo :: RuleInfo -> RuleInfo -> RuleInfo
addIdSpecialisations :: Id -> [CoreRule] -> Id

-- | Gather all the rules for locally bound identifiers from the supplied
--   bindings
rulesOfBinds :: [CoreBind] -> [CoreRule]
getRules :: RuleEnv -> Id -> [CoreRule]
pprRulesForUser :: [CoreRule] -> SDoc

-- | The main rule matching function. Attempts to apply all (active)
--   supplied rules to this instance of an application in a given context,
--   returning the rule applied and the resulting expression if successful.
lookupRule :: RuleOpts -> InScopeEnv -> (Activation -> Bool) -> Id -> [CoreExpr] -> [CoreRule] -> Maybe (CoreRule, CoreExpr)

-- | Used to make <a>CoreRule</a> for an <a>Id</a> defined in the module
--   being compiled. See also <a>CoreRule</a>
mkRule :: Module -> Bool -> Bool -> RuleName -> Activation -> Name -> [CoreBndr] -> [CoreExpr] -> CoreExpr -> CoreRule

-- | Find the "top" free names of several expressions. Such names are
--   either:
--   
--   <ol>
--   <li>The function finally being applied to in an application chain (if
--   that name is a GlobalId: see <a>GHC.Types.Var#globalvslocal</a>),
--   or</li>
--   <li>The <tt>TyCon</tt> if the expression is a <a>Expr</a></li>
--   </ol>
--   
--   This is used for the fast-match-check for rules; if the top names
--   don't match, the rest can't
roughTopNames :: [CoreExpr] -> [Maybe Name]

-- | Initialize RuleOpts from DynFlags
initRuleOpts :: DynFlags -> RuleOpts

module GHC.Core.Opt.SetLevels
setLevels :: FloatOutSwitches -> CoreProgram -> UniqSupply -> [LevelledBind]
data Level
Level :: Int -> Int -> LevelType -> Level
data LevelType
BndrLvl :: LevelType
JoinCeilLvl :: LevelType
tOP_LEVEL :: Level
isJoinCeilLvl :: Level -> Bool
asJoinCeilLvl :: Level -> Level
type LevelledBind = TaggedBind FloatSpec
type LevelledExpr = TaggedExpr FloatSpec
type LevelledBndr = TaggedBndr FloatSpec
data FloatSpec
FloatMe :: Level -> FloatSpec
StayPut :: Level -> FloatSpec
floatSpecLevel :: FloatSpec -> Level
incMinorLvl :: Level -> Level
ltMajLvl :: Level -> Level -> Bool
ltLvl :: Level -> Level -> Bool
isTopLvl :: Level -> Bool
instance GHC.Classes.Eq GHC.Core.Opt.SetLevels.LevelType
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SetLevels.FloatSpec
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SetLevels.Level
instance GHC.Classes.Eq GHC.Core.Opt.SetLevels.Level

module GHC.Core.Opt.Exitify

-- | Traverses the AST, simply to find all joinrecs and call
--   <tt>exitify</tt> on them. The really interesting function is
--   exitifyRec
exitifyProgram :: CoreProgram -> CoreProgram

module GHC.Core.Opt.CSE
cseProgram :: CoreProgram -> CoreProgram

-- | Runs CSE on a single expression.
--   
--   This entry point is not used in the compiler itself, but is provided
--   as a convenient entry point for users of the GHC API.
cseOneExpr :: InExpr -> OutExpr

module GHC.Builtin.Types.Literals
typeNatTyCons :: [TyCon]
typeNatCoAxiomRules :: UniqFM FastString CoAxiomRule
data BuiltInSynFamily
BuiltInSynFamily :: ([Type] -> Maybe (CoAxiomRule, [Type], Type)) -> ([Type] -> Type -> [TypeEqn]) -> ([Type] -> Type -> [Type] -> Type -> [TypeEqn]) -> BuiltInSynFamily
[sfMatchFam] :: BuiltInSynFamily -> [Type] -> Maybe (CoAxiomRule, [Type], Type)
[sfInteractTop] :: BuiltInSynFamily -> [Type] -> Type -> [TypeEqn]
[sfInteractInert] :: BuiltInSynFamily -> [Type] -> Type -> [Type] -> Type -> [TypeEqn]
typeNatAddTyCon :: TyCon
typeNatMulTyCon :: TyCon
typeNatExpTyCon :: TyCon
typeNatSubTyCon :: TyCon
typeNatDivTyCon :: TyCon
typeNatModTyCon :: TyCon
typeNatLogTyCon :: TyCon
typeNatCmpTyCon :: TyCon
typeSymbolCmpTyCon :: TyCon
typeSymbolAppendTyCon :: TyCon
typeCharCmpTyCon :: TyCon
typeConsSymbolTyCon :: TyCon
typeUnconsSymbolTyCon :: TyCon
typeCharToNatTyCon :: TyCon
typeNatToCharTyCon :: TyCon

module GHC.Core.Opt.WorkWrap
wwTopBinds :: DynFlags -> FamInstEnvs -> UniqSupply -> CoreProgram -> CoreProgram

module GHC.Core.Opt.Simplify.Env
setMode :: SimplMode -> SimplEnv -> SimplEnv
getMode :: SimplEnv -> SimplMode
updMode :: (SimplMode -> SimplMode) -> SimplEnv -> SimplEnv
seDynFlags :: SimplEnv -> DynFlags
seUnfoldingOpts :: SimplEnv -> UnfoldingOpts
seLogger :: SimplEnv -> Logger
data SimplEnv
SimplEnv :: !SimplMode -> TvSubstEnv -> CvSubstEnv -> SimplIdSubst -> !InScopeSet -> !Int -> SimplEnv
[seMode] :: SimplEnv -> !SimplMode
[seTvSubst] :: SimplEnv -> TvSubstEnv
[seCvSubst] :: SimplEnv -> CvSubstEnv
[seIdSubst] :: SimplEnv -> SimplIdSubst
[seInScope] :: SimplEnv -> !InScopeSet
[seCaseDepth] :: SimplEnv -> !Int
pprSimplEnv :: SimplEnv -> SDoc
mkSimplEnv :: SimplMode -> SimplEnv
extendIdSubst :: SimplEnv -> Id -> SimplSR -> SimplEnv
extendTvSubst :: SimplEnv -> TyVar -> Type -> SimplEnv
extendCvSubst :: SimplEnv -> CoVar -> Coercion -> SimplEnv
zapSubstEnv :: SimplEnv -> SimplEnv
setSubstEnv :: SimplEnv -> TvSubstEnv -> CvSubstEnv -> SimplIdSubst -> SimplEnv
bumpCaseDepth :: SimplEnv -> SimplEnv
getInScope :: SimplEnv -> InScopeSet
setInScopeFromE :: SimplEnv -> SimplEnv -> SimplEnv
setInScopeFromF :: SimplEnv -> SimplFloats -> SimplEnv
setInScopeSet :: SimplEnv -> InScopeSet -> SimplEnv
modifyInScope :: SimplEnv -> CoreBndr -> SimplEnv
addNewInScopeIds :: SimplEnv -> [CoreBndr] -> SimplEnv
getSimplRules :: SimplM RuleEnv

-- | A substitution result.
data SimplSR
DoneEx :: OutExpr -> Maybe JoinArity -> SimplSR
DoneId :: OutId -> SimplSR
ContEx :: TvSubstEnv -> CvSubstEnv -> SimplIdSubst -> InExpr -> SimplSR
mkContEx :: SimplEnv -> InExpr -> SimplSR
substId :: SimplEnv -> InId -> SimplSR
lookupRecBndr :: SimplEnv -> InId -> OutId
refineFromInScope :: InScopeSet -> Var -> Var
simplNonRecBndr :: SimplEnv -> InBndr -> SimplM (SimplEnv, OutBndr)
simplNonRecJoinBndr :: SimplEnv -> InBndr -> Mult -> OutType -> SimplM (SimplEnv, OutBndr)
simplRecBndrs :: SimplEnv -> [InBndr] -> SimplM SimplEnv
simplRecJoinBndrs :: SimplEnv -> [InBndr] -> Mult -> OutType -> SimplM SimplEnv
simplBinder :: SimplEnv -> InBndr -> SimplM (SimplEnv, OutBndr)
simplBinders :: SimplEnv -> [InBndr] -> SimplM (SimplEnv, [OutBndr])
substTy :: SimplEnv -> Type -> Type
substTyVar :: SimplEnv -> TyVar -> Type
getTCvSubst :: SimplEnv -> TCvSubst
substCo :: SimplEnv -> Coercion -> Coercion
substCoVar :: SimplEnv -> CoVar -> Coercion
data SimplFloats
SimplFloats :: LetFloats -> JoinFloats -> InScopeSet -> SimplFloats
[sfLetFloats] :: SimplFloats -> LetFloats
[sfJoinFloats] :: SimplFloats -> JoinFloats
[sfInScope] :: SimplFloats -> InScopeSet
emptyFloats :: SimplEnv -> SimplFloats
mkRecFloats :: SimplFloats -> SimplFloats
mkFloatBind :: SimplEnv -> OutBind -> (SimplFloats, SimplEnv)
addLetFloats :: SimplFloats -> LetFloats -> SimplFloats
addJoinFloats :: SimplFloats -> JoinFloats -> SimplFloats
addFloats :: SimplFloats -> SimplFloats -> SimplFloats
extendFloats :: SimplFloats -> OutBind -> SimplFloats
wrapFloats :: SimplFloats -> OutExpr -> OutExpr
doFloatFromRhs :: TopLevelFlag -> RecFlag -> Bool -> SimplFloats -> OutExpr -> Bool
getTopFloatBinds :: SimplFloats -> [CoreBind]
data LetFloats
letFloatBinds :: LetFloats -> [CoreBind]
emptyLetFloats :: LetFloats
unitLetFloat :: OutBind -> LetFloats
addLetFlts :: LetFloats -> LetFloats -> LetFloats
mapLetFloats :: LetFloats -> ((Id, CoreExpr) -> (Id, CoreExpr)) -> LetFloats
type JoinFloat = OutBind
type JoinFloats = OrdList JoinFloat
emptyJoinFloats :: JoinFloats
wrapJoinFloats :: JoinFloats -> OutExpr -> OutExpr
wrapJoinFloatsX :: SimplFloats -> OutExpr -> (SimplFloats, OutExpr)
unitJoinFloat :: OutBind -> JoinFloats
addJoinFlts :: JoinFloats -> JoinFloats -> JoinFloats
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.SimplFloats
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.LetFloats
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.FloatFlag
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.SimplSR

module GHC.Core.Opt.LiberateCase
liberateCase :: DynFlags -> CoreProgram -> CoreProgram

module GHC.Core.Opt.Simplify.Utils
mkLam :: SimplEnv -> [OutBndr] -> OutExpr -> SimplCont -> SimplM OutExpr
mkCase :: DynFlags -> OutExpr -> OutId -> OutType -> [OutAlt] -> SimplM OutExpr
prepareAlts :: OutExpr -> OutId -> [InAlt] -> SimplM ([AltCon], [InAlt])
tryEtaExpandRhs :: SimplMode -> OutId -> OutExpr -> SimplM (ArityType, OutExpr)
preInlineUnconditionally :: SimplEnv -> TopLevelFlag -> InId -> InExpr -> StaticEnv -> Maybe SimplEnv
postInlineUnconditionally :: SimplEnv -> TopLevelFlag -> OutId -> OccInfo -> OutExpr -> Bool
activeUnfolding :: SimplMode -> Id -> Bool
activeRule :: SimplMode -> Activation -> Bool
getUnfoldingInRuleMatch :: SimplEnv -> InScopeEnv
simplEnvForGHCi :: Logger -> DynFlags -> SimplEnv
updModeForStableUnfoldings :: Activation -> SimplMode -> SimplMode
updModeForRules :: SimplMode -> SimplMode
data SimplCont
Stop :: OutType -> CallCtxt -> SimplCont
CastIt :: OutCoercion -> SimplCont -> SimplCont
ApplyToVal :: DupFlag -> OutType -> InExpr -> StaticEnv -> SimplCont -> SimplCont
[sc_dup] :: SimplCont -> DupFlag
[sc_hole_ty] :: SimplCont -> OutType
[sc_arg] :: SimplCont -> InExpr
[sc_env] :: SimplCont -> StaticEnv
[sc_cont] :: SimplCont -> SimplCont
ApplyToTy :: OutType -> OutType -> SimplCont -> SimplCont
[sc_arg_ty] :: SimplCont -> OutType
[sc_hole_ty] :: SimplCont -> OutType
[sc_cont] :: SimplCont -> SimplCont
Select :: DupFlag -> InId -> [InAlt] -> StaticEnv -> SimplCont -> SimplCont
[sc_dup] :: SimplCont -> DupFlag
[sc_bndr] :: SimplCont -> InId
[sc_alts] :: SimplCont -> [InAlt]
[sc_env] :: SimplCont -> StaticEnv
[sc_cont] :: SimplCont -> SimplCont
StrictBind :: DupFlag -> InId -> [InBndr] -> InExpr -> StaticEnv -> SimplCont -> SimplCont
[sc_dup] :: SimplCont -> DupFlag
[sc_bndr] :: SimplCont -> InId
[sc_bndrs] :: SimplCont -> [InBndr]
[sc_body] :: SimplCont -> InExpr
[sc_env] :: SimplCont -> StaticEnv
[sc_cont] :: SimplCont -> SimplCont
StrictArg :: DupFlag -> ArgInfo -> OutType -> SimplCont -> SimplCont
[sc_dup] :: SimplCont -> DupFlag
[sc_fun] :: SimplCont -> ArgInfo
[sc_fun_ty] :: SimplCont -> OutType
[sc_cont] :: SimplCont -> SimplCont
TickIt :: CoreTickish -> SimplCont -> SimplCont
data DupFlag
NoDup :: DupFlag
Simplified :: DupFlag
OkToDup :: DupFlag
type StaticEnv = SimplEnv
isSimplified :: DupFlag -> Bool
contIsStop :: SimplCont -> Bool
contIsDupable :: SimplCont -> Bool
contResultType :: SimplCont -> OutType
contHoleType :: SimplCont -> OutType
contHoleScaling :: SimplCont -> Mult
contIsTrivial :: SimplCont -> Bool
contArgs :: SimplCont -> (Bool, [ArgSummary], SimplCont)
countArgs :: SimplCont -> Int
mkBoringStop :: OutType -> SimplCont
mkRhsStop :: OutType -> SimplCont
mkLazyArgStop :: OutType -> CallCtxt -> SimplCont
contIsRhsOrArg :: SimplCont -> Bool
interestingCallContext :: SimplEnv -> SimplCont -> CallCtxt
data ArgInfo
ArgInfo :: OutId -> [ArgSpec] -> FunRules -> Bool -> [Demand] -> [Int] -> ArgInfo
[ai_fun] :: ArgInfo -> OutId
[ai_args] :: ArgInfo -> [ArgSpec]
[ai_rules] :: ArgInfo -> FunRules
[ai_encl] :: ArgInfo -> Bool
[ai_dmds] :: ArgInfo -> [Demand]
[ai_discs] :: ArgInfo -> [Int]
data ArgSpec
ValArg :: Demand -> OutExpr -> OutType -> ArgSpec
[as_dmd] :: ArgSpec -> Demand
[as_arg] :: ArgSpec -> OutExpr
[as_hole_ty] :: ArgSpec -> OutType
TyArg :: OutType -> OutType -> ArgSpec
[as_arg_ty] :: ArgSpec -> OutType
[as_hole_ty] :: ArgSpec -> OutType
CastBy :: OutCoercion -> ArgSpec
mkArgInfo :: SimplEnv -> Id -> [CoreRule] -> Int -> SimplCont -> ArgInfo
addValArgTo :: ArgInfo -> OutExpr -> OutType -> ArgInfo
addCastTo :: ArgInfo -> OutCoercion -> ArgInfo
addTyArgTo :: ArgInfo -> OutType -> OutType -> ArgInfo
argInfoExpr :: OutId -> [ArgSpec] -> OutExpr
argInfoAppArgs :: [ArgSpec] -> [OutExpr]
pushSimplifiedArgs :: SimplEnv -> [ArgSpec] -> SimplCont -> SimplCont
isStrictArgInfo :: ArgInfo -> Bool
lazyArgContext :: ArgInfo -> CallCtxt
abstractFloats :: UnfoldingOpts -> TopLevelFlag -> [OutTyVar] -> SimplFloats -> OutExpr -> SimplM ([OutBind], OutExpr)
isExitJoinId :: Var -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Utils.SimplCont
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Utils.ArgInfo
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Utils.ArgSpec
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Utils.DupFlag


-- | The <tt>GHC.Builtin.Utils</tt> interface to the compiler's prelude
--   knowledge.
--   
--   This module serves as the central gathering point for names which the
--   compiler knows something about. This includes functions for,
--   
--   <ul>
--   <li>discerning whether a <a>Name</a> is known-key</li>
--   <li>given a <a>Unique</a>, looking up its corresponding known-key
--   <a>Name</a></li>
--   </ul>
--   
--   See Note [Known-key names] and Note [About wired-in things] for
--   information about the two types of prelude things in GHC.
module GHC.Builtin.Utils

-- | Is a <a>Name</a> known-key?
isKnownKeyName :: Name -> Bool

-- | Given a <a>Unique</a> lookup its associated <a>Name</a> if it
--   corresponds to a known-key thing.
lookupKnownKeyName :: Unique -> Maybe Name

-- | Given a <a>Unique</a> lookup any associated arbitrary SDoc's to be
--   displayed by GHCi's ':info' command.
lookupKnownNameInfo :: Name -> SDoc

-- | This list is used to ensure that when you say "Prelude.map" in your
--   source code, or in an interface file, you get a Name with the correct
--   known key (See Note [Known-key names] in <a>GHC.Builtin.Names</a>)
knownKeyNames :: [Name]
wiredInIds :: [Id]
ghcPrimIds :: [Id]
primOpRules :: Name -> PrimOp -> Maybe CoreRule
builtinRules :: [CoreRule]
ghcPrimExports :: [IfaceExport]
ghcPrimDeclDocs :: DeclDocMap
primOpId :: PrimOp -> Id
maybeCharLikeCon :: DataCon -> Bool
maybeIntLikeCon :: DataCon -> Bool
isNumericClass :: Class -> Bool
isStandardClass :: Class -> Bool

module GHC.Iface.Ext.Types
type Span = RealSrcSpan

-- | Current version of <tt>.hie</tt> files
hieVersion :: Integer

-- | GHC builds up a wealth of information about Haskell source as it
--   compiles it. <tt>.hie</tt> files are a way of persisting some of this
--   information to disk so that external tools that need to work with
--   haskell source don't need to parse, typecheck, and rename all over
--   again. These files contain:
--   
--   <ul>
--   <li>a simplified AST<ul><li>nodes are annotated with source positions
--   and types</li><li>identifiers are annotated with scope
--   information</li></ul></li>
--   <li>the raw bytes of the initial Haskell source</li>
--   </ul>
--   
--   Besides saving compilation cycles, <tt>.hie</tt> files also offer a
--   more stable interface than the GHC API.
data HieFile
HieFile :: FilePath -> Module -> Array TypeIndex HieTypeFlat -> HieASTs TypeIndex -> [AvailInfo] -> ByteString -> HieFile

-- | Initial Haskell source file path
[hie_hs_file] :: HieFile -> FilePath

-- | The module this HIE file is for
[hie_module] :: HieFile -> Module

-- | Types referenced in the <a>hie_asts</a>.
--   
--   See Note [Efficient serialization of redundant type info]
[hie_types] :: HieFile -> Array TypeIndex HieTypeFlat

-- | Type-annotated abstract syntax trees
[hie_asts] :: HieFile -> HieASTs TypeIndex

-- | The names that this module exports
[hie_exports] :: HieFile -> [AvailInfo]

-- | Raw bytes of the initial Haskell source
[hie_hs_src] :: HieFile -> ByteString
type TypeIndex = Int

-- | A flattened version of <tt>Type</tt>.
--   
--   See Note [Efficient serialization of redundant type info]
data HieType a
HTyVarTy :: Name -> HieType a
HAppTy :: a -> HieArgs a -> HieType a
HTyConApp :: IfaceTyCon -> HieArgs a -> HieType a
HForAllTy :: ((Name, a), ArgFlag) -> a -> HieType a
HFunTy :: a -> a -> a -> HieType a

-- | type with constraint: <tt>t1 =&gt; t2</tt> (see <tt>IfaceDFunTy</tt>)
HQualTy :: a -> a -> HieType a
HLitTy :: IfaceTyLit -> HieType a
HCastTy :: a -> HieType a
HCoercionTy :: HieType a
type HieTypeFlat = HieType TypeIndex

-- | Roughly isomorphic to the original core <tt>Type</tt>.
newtype HieTypeFix
Roll :: HieType HieTypeFix -> HieTypeFix

-- | A list of type arguments along with their respective visibilities (ie.
--   is this an argument that would return <a>True</a> for
--   <tt>isVisibleArgFlag</tt>?).
newtype HieArgs a
HieArgs :: [(Bool, a)] -> HieArgs a
type HiePath = LexicalFastString
pattern HiePath :: FastString -> HiePath

-- | Mapping from filepaths to the corresponding AST
newtype HieASTs a
HieASTs :: Map HiePath (HieAST a) -> HieASTs a
[getAsts] :: HieASTs a -> Map HiePath (HieAST a)
data HieAST a
Node :: SourcedNodeInfo a -> Span -> [HieAST a] -> HieAST a
[sourcedNodeInfo] :: HieAST a -> SourcedNodeInfo a
[nodeSpan] :: HieAST a -> Span
[nodeChildren] :: HieAST a -> [HieAST a]

-- | NodeInfos grouped by source
newtype SourcedNodeInfo a
SourcedNodeInfo :: Map NodeOrigin (NodeInfo a) -> SourcedNodeInfo a
[getSourcedNodeInfo] :: SourcedNodeInfo a -> Map NodeOrigin (NodeInfo a)

-- | Source of node info
data NodeOrigin
SourceInfo :: NodeOrigin
GeneratedInfo :: NodeOrigin

-- | A node annotation
data NodeAnnotation
NodeAnnotation :: !FastString -> !FastString -> NodeAnnotation

-- | name of the AST node constructor
[nodeAnnotConstr] :: NodeAnnotation -> !FastString

-- | name of the AST node Type
[nodeAnnotType] :: NodeAnnotation -> !FastString

-- | The information stored in one AST node.
--   
--   The type parameter exists to provide flexibility in representation of
--   types (see Note [Efficient serialization of redundant type info]).
data NodeInfo a
NodeInfo :: Set NodeAnnotation -> [a] -> NodeIdentifiers a -> NodeInfo a

-- | Annotations
[nodeAnnotations] :: NodeInfo a -> Set NodeAnnotation

-- | The Haskell types of this node, if any.
[nodeType] :: NodeInfo a -> [a]

-- | All the identifiers and their details
[nodeIdentifiers] :: NodeInfo a -> NodeIdentifiers a
pprNodeIdents :: Outputable a => NodeIdentifiers a -> SDoc
pprIdentifier :: Identifier -> SDoc
type Identifier = Either ModuleName Name
type NodeIdentifiers a = Map Identifier (IdentifierDetails a)

-- | Information associated with every identifier
--   
--   We need to include types with identifiers because sometimes multiple
--   identifiers occur in the same span(Overloaded Record Fields and so on)
data IdentifierDetails a
IdentifierDetails :: Maybe a -> Set ContextInfo -> IdentifierDetails a
[identType] :: IdentifierDetails a -> Maybe a
[identInfo] :: IdentifierDetails a -> Set ContextInfo

-- | Different contexts under which identifiers exist
data ContextInfo

-- | regular variable
Use :: ContextInfo
MatchBind :: ContextInfo

-- | import/export
IEThing :: IEType -> ContextInfo
TyDecl :: ContextInfo

-- | Value binding
ValBind :: BindType -> Scope -> Maybe Span -> ContextInfo

-- | Pattern binding
--   
--   This case is tricky because the bound identifier can be used in two
--   distinct scopes. Consider the following example (with
--   <tt>-XViewPatterns</tt>)
--   
--   <pre>
--   do (b, a, (a -&gt; True)) &lt;- bar
--      foo a
--   </pre>
--   
--   The identifier <tt>a</tt> has two scopes: in the view pattern <tt>(a
--   -&gt; True)</tt> and in the rest of the <tt>do</tt>-block in <tt>foo
--   a</tt>.
PatternBind :: Scope -> Scope -> Maybe Span -> ContextInfo
ClassTyDecl :: Maybe Span -> ContextInfo

-- | Declaration
Decl :: DeclType -> Maybe Span -> ContextInfo

-- | Type variable
TyVarBind :: Scope -> TyVarScope -> ContextInfo

-- | Record field
RecField :: RecFieldContext -> Maybe Span -> ContextInfo

-- | Constraint/Dictionary evidence variable binding
EvidenceVarBind :: EvVarSource -> Scope -> Maybe Span -> ContextInfo

-- | Usage of evidence variable
EvidenceVarUse :: ContextInfo
pprBindSpan :: Maybe Span -> SDoc
data EvVarSource

-- | bound by a pattern match
EvPatternBind :: EvVarSource

-- | bound by a type signature
EvSigBind :: EvVarSource

-- | bound by a hswrapper
EvWrapperBind :: EvVarSource

-- | bound by an implicit variable
EvImplicitBind :: EvVarSource

-- | Bound by some instance of given class
EvInstBind :: Bool -> Name -> EvVarSource
[isSuperInst] :: EvVarSource -> Bool
[cls] :: EvVarSource -> Name

-- | A direct let binding
EvLetBind :: EvBindDeps -> EvVarSource

-- | Eq/Ord instances compare on the converted HieName, as non-exported
--   names may have different uniques after a roundtrip
newtype EvBindDeps
EvBindDeps :: [Name] -> EvBindDeps
[getEvBindDeps] :: EvBindDeps -> [Name]

-- | Types of imports and exports
data IEType
Import :: IEType
ImportAs :: IEType
ImportHiding :: IEType
Export :: IEType
data RecFieldContext
RecFieldDecl :: RecFieldContext
RecFieldAssign :: RecFieldContext
RecFieldMatch :: RecFieldContext
RecFieldOcc :: RecFieldContext
data BindType
RegularBind :: BindType
InstanceBind :: BindType
data DeclType

-- | type or data family
FamDec :: DeclType

-- | type synonym
SynDec :: DeclType

-- | data declaration
DataDec :: DeclType

-- | constructor declaration
ConDec :: DeclType

-- | pattern synonym
PatSynDec :: DeclType

-- | class declaration
ClassDec :: DeclType

-- | instance declaration
InstDec :: DeclType
data Scope
NoScope :: Scope
LocalScope :: Span -> Scope
ModuleScope :: Scope

-- | Scope of a type variable.
--   
--   This warrants a data type apart from <a>Scope</a> because of
--   complexities introduced by features like
--   <tt>-XScopedTypeVariables</tt> and <tt>-XInstanceSigs</tt>. For
--   example, consider:
--   
--   <pre>
--   foo, bar, baz :: forall a. a -&gt; a
--   </pre>
--   
--   Here <tt>a</tt> is in scope in all the definitions of <tt>foo</tt>,
--   <tt>bar</tt>, and <tt>baz</tt>, so we need a list of scopes to keep
--   track of this. Furthermore, this list cannot be computed until we
--   resolve the binding sites of <tt>foo</tt>, <tt>bar</tt>, and
--   <tt>baz</tt>.
--   
--   Consequently, <tt>a</tt> starts with an <tt><a>UnresolvedScope</a>
--   [foo, bar, baz] Nothing</tt> which later gets resolved into a
--   <a>ResolvedScopes</a>.
data TyVarScope
ResolvedScopes :: [Scope] -> TyVarScope

-- | Unresolved scopes should never show up in the final <tt>.hie</tt> file
UnresolvedScope :: [Name] -> Maybe Span -> TyVarScope

-- | <a>Name</a>'s get converted into <a>HieName</a>'s before being written
--   into <tt>.hie</tt> files. See <a>toHieName</a> and
--   <tt>fromHieName</tt> for logic on how to convert between these two
--   types.
data HieName
ExternalName :: !Module -> !OccName -> !SrcSpan -> HieName
LocalName :: !OccName -> !SrcSpan -> HieName
KnownKeyName :: !Unique -> HieName
hieNameOcc :: HieName -> OccName
toHieName :: Name -> HieName
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Iface.Ext.Types.HieArgs a)
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.HieArgs
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.HieArgs
instance GHC.Base.Functor GHC.Iface.Ext.Types.HieArgs
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Iface.Ext.Types.HieType a)
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.HieType
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.HieType
instance GHC.Base.Functor GHC.Iface.Ext.Types.HieType
instance GHC.Classes.Ord GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Enum.Enum GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Classes.Eq GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Classes.Eq GHC.Iface.Ext.Types.NodeAnnotation
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.EvBindDeps
instance GHC.Classes.Ord GHC.Iface.Ext.Types.EvVarSource
instance GHC.Classes.Eq GHC.Iface.Ext.Types.EvVarSource
instance GHC.Classes.Ord GHC.Iface.Ext.Types.IEType
instance GHC.Enum.Enum GHC.Iface.Ext.Types.IEType
instance GHC.Classes.Eq GHC.Iface.Ext.Types.IEType
instance GHC.Classes.Ord GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Enum.Enum GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Classes.Eq GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Enum.Enum GHC.Iface.Ext.Types.BindType
instance GHC.Classes.Ord GHC.Iface.Ext.Types.BindType
instance GHC.Classes.Eq GHC.Iface.Ext.Types.BindType
instance GHC.Enum.Enum GHC.Iface.Ext.Types.DeclType
instance GHC.Classes.Ord GHC.Iface.Ext.Types.DeclType
instance GHC.Classes.Eq GHC.Iface.Ext.Types.DeclType
instance Data.Data.Data GHC.Iface.Ext.Types.Scope
instance GHC.Classes.Ord GHC.Iface.Ext.Types.Scope
instance GHC.Classes.Eq GHC.Iface.Ext.Types.Scope
instance GHC.Classes.Ord GHC.Iface.Ext.Types.TyVarScope
instance GHC.Classes.Eq GHC.Iface.Ext.Types.TyVarScope
instance GHC.Classes.Ord GHC.Iface.Ext.Types.ContextInfo
instance GHC.Classes.Eq GHC.Iface.Ext.Types.ContextInfo
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.IdentifierDetails
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.IdentifierDetails
instance GHC.Base.Functor GHC.Iface.Ext.Types.IdentifierDetails
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Iface.Ext.Types.IdentifierDetails a)
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.NodeInfo
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.NodeInfo
instance GHC.Base.Functor GHC.Iface.Ext.Types.NodeInfo
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.SourcedNodeInfo
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.SourcedNodeInfo
instance GHC.Base.Functor GHC.Iface.Ext.Types.SourcedNodeInfo
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.HieAST
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.HieAST
instance GHC.Base.Functor GHC.Iface.Ext.Types.HieAST
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.HieASTs
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.HieASTs
instance GHC.Base.Functor GHC.Iface.Ext.Types.HieASTs
instance GHC.Classes.Eq GHC.Iface.Ext.Types.HieName
instance GHC.Classes.Ord GHC.Iface.Ext.Types.HieName
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.HieName
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.HieFile
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.HieASTs GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.HieASTs a)
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.HieAST GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.HieAST a)
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.SourcedNodeInfo GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.SourcedNodeInfo a)
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.NodeInfo GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.NodeInfo a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.IdentifierDetails a)
instance GHC.Base.Semigroup (GHC.Iface.Ext.Types.IdentifierDetails a)
instance GHC.Base.Monoid (GHC.Iface.Ext.Types.IdentifierDetails a)
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.IdentifierDetails GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.ContextInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.ContextInfo
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.TyVarScope
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.TyVarScope
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.Scope
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.Scope
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.DeclType
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.DeclType
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.BindType
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.BindType
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.IEType
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.IEType
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.EvVarSource
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.EvVarSource
instance GHC.Classes.Eq GHC.Iface.Ext.Types.EvBindDeps
instance GHC.Classes.Ord GHC.Iface.Ext.Types.EvBindDeps
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.EvBindDeps
instance GHC.Classes.Ord GHC.Iface.Ext.Types.NodeAnnotation
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.NodeAnnotation
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.NodeAnnotation
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.HieType GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.HieArgs GHC.Iface.Ext.Types.TypeIndex)

module GHC.Iface.Ext.Utils
type RefMap a = Map Identifier [(Span, IdentifierDetails a)]
generateReferencesMap :: Foldable f => f (HieAST a) -> RefMap a
renderHieType :: DynFlags -> HieTypeFix -> String
resolveVisibility :: Type -> [Type] -> [(Bool, Type)]
foldType :: (HieType a -> a) -> HieTypeFix -> a
selectPoint :: HieFile -> (Int, Int) -> Maybe (HieAST Int)
findEvidenceUse :: NodeIdentifiers a -> [Name]
data EvidenceInfo a
EvidenceInfo :: Name -> RealSrcSpan -> a -> Maybe (EvVarSource, Scope, Maybe Span) -> EvidenceInfo a
[evidenceVar] :: EvidenceInfo a -> Name
[evidenceSpan] :: EvidenceInfo a -> RealSrcSpan
[evidenceType] :: EvidenceInfo a -> a
[evidenceDetails] :: EvidenceInfo a -> Maybe (EvVarSource, Scope, Maybe Span)
getEvidenceTreesAtPoint :: HieFile -> RefMap a -> (Int, Int) -> Forest (EvidenceInfo a)
getEvidenceTree :: RefMap a -> Name -> Maybe (Tree (EvidenceInfo a))
hieTypeToIface :: HieTypeFix -> IfaceType
data HieTypeState
HTS :: !TypeMap TypeIndex -> !IntMap HieTypeFlat -> !TypeIndex -> HieTypeState
[tyMap] :: HieTypeState -> !TypeMap TypeIndex
[htyTable] :: HieTypeState -> !IntMap HieTypeFlat
[freshIndex] :: HieTypeState -> !TypeIndex
initialHTS :: HieTypeState
freshTypeIndex :: State HieTypeState TypeIndex
compressTypes :: HieASTs Type -> (HieASTs TypeIndex, Array TypeIndex HieTypeFlat)
recoverFullType :: TypeIndex -> Array TypeIndex HieTypeFlat -> HieTypeFix
getTypeIndex :: Type -> State HieTypeState TypeIndex
resolveTyVarScopes :: Map HiePath (HieAST a) -> Map HiePath (HieAST a)
resolveTyVarScopeLocal :: HieAST a -> Map HiePath (HieAST a) -> HieAST a
getNameBinding :: Name -> Map HiePath (HieAST a) -> Maybe Span
getNameScope :: Name -> Map HiePath (HieAST a) -> Maybe [Scope]
getNameBindingInClass :: Name -> Span -> Map HiePath (HieAST a) -> Maybe Span
getNameScopeAndBinding :: Name -> Map HiePath (HieAST a) -> Maybe ([Scope], Maybe Span)
getScopeFromContext :: ContextInfo -> Maybe [Scope]
getBindSiteFromContext :: ContextInfo -> Maybe Span
flattenAst :: HieAST a -> [HieAST a]
smallestContainingSatisfying :: Span -> (HieAST a -> Bool) -> HieAST a -> Maybe (HieAST a)
selectLargestContainedBy :: Span -> HieAST a -> Maybe (HieAST a)
selectSmallestContaining :: Span -> HieAST a -> Maybe (HieAST a)
definedInAsts :: Map HiePath (HieAST a) -> Name -> Bool
getEvidenceBindDeps :: ContextInfo -> [Name]
isEvidenceBind :: ContextInfo -> Bool
isEvidenceContext :: ContextInfo -> Bool
isEvidenceUse :: ContextInfo -> Bool
isOccurrence :: ContextInfo -> Bool
scopeContainsSpan :: Scope -> Span -> Bool

-- | One must contain the other. Leaf nodes cannot contain anything
combineAst :: HieAST Type -> HieAST Type -> HieAST Type

-- | Insert an AST in a sorted list of disjoint Asts
insertAst :: HieAST Type -> [HieAST Type] -> [HieAST Type]
nodeInfo :: HieAST Type -> NodeInfo Type
emptyNodeInfo :: NodeInfo a
sourcedNodeIdents :: SourcedNodeInfo a -> NodeIdentifiers a
combineSourcedNodeInfo :: SourcedNodeInfo Type -> SourcedNodeInfo Type -> SourcedNodeInfo Type

-- | Merge two nodes together.
--   
--   Precondition and postcondition: elements in <a>nodeType</a> are
--   ordered.
combineNodeInfo :: NodeInfo Type -> NodeInfo Type -> NodeInfo Type

-- | Merge two sorted, disjoint lists of ASTs, combining when necessary.
--   
--   In the absence of position-altering pragmas (ex: <tt># line "file.hs"
--   3</tt>), different nodes in an AST tree should either have disjoint
--   spans (in which case you can say for sure which one comes first) or
--   one span should be completely contained in the other (in which case
--   the contained span corresponds to some child node).
--   
--   However, since Haskell does have position-altering pragmas it
--   <i>is</i> possible for spans to be overlapping. Here is an example of
--   a source file in which <tt>foozball</tt> and <tt>quuuuuux</tt> have
--   overlapping spans:
--   
--   <pre>
--   module Baz where
--   
--   # line 3 "Baz.hs"
--   foozball :: Int
--   foozball = 0
--   
--   # line 3 "Baz.hs"
--   bar, quuuuuux :: Int
--   bar = 1
--   quuuuuux = 2
--   </pre>
--   
--   In these cases, we just do our best to produce sensible
--   <a>HieAST</a>'s. The blame should be laid at the feet of whoever wrote
--   the line pragmas in the first place (usually the C preprocessor...).
mergeAsts :: [HieAST Type] -> [HieAST Type] -> [HieAST Type]
rightOf :: Span -> Span -> Bool
leftOf :: Span -> Span -> Bool
startsRightOf :: Span -> Span -> Bool

-- | combines and sorts ASTs using a merge sort
mergeSortAsts :: [HieAST Type] -> [HieAST Type]
simpleNodeInfo :: FastString -> FastString -> NodeInfo a
locOnly :: Monad m => SrcSpan -> ReaderT NodeOrigin m [HieAST a]
mkScopeA :: SrcSpanAnn' ann -> Scope
mkScope :: SrcSpan -> Scope
mkLScope :: Located a -> Scope
mkLScopeA :: GenLocated (SrcSpanAnn' a) e -> Scope
mkLScopeN :: LocatedN a -> Scope
combineScopes :: Scope -> Scope -> Scope
mkSourcedNodeInfo :: NodeOrigin -> NodeInfo a -> SourcedNodeInfo a
makeNodeA :: (Monad m, Data a) => a -> SrcSpanAnn' ann -> ReaderT NodeOrigin m [HieAST b]
makeNode :: (Monad m, Data a) => a -> SrcSpan -> ReaderT NodeOrigin m [HieAST b]
makeTypeNodeA :: (Monad m, Data a) => a -> SrcSpanAnnA -> Type -> ReaderT NodeOrigin m [HieAST Type]
makeTypeNode :: (Monad m, Data a) => a -> SrcSpan -> Type -> ReaderT NodeOrigin m [HieAST Type]
instance GHC.Base.Functor GHC.Iface.Ext.Utils.EvidenceInfo
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Iface.Ext.Utils.EvidenceInfo a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Iface.Ext.Utils.EvidenceInfo a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Utils.EvidenceInfo a)

module GHC.Iface.Ext.Debug
type Diff a = a -> a -> [SDoc]
diffFile :: Diff HieFile
diffAsts :: (Outputable a, Eq a, Ord a) => Diff a -> Diff (Map HiePath (HieAST a))
diffAst :: (Outputable a, Eq a, Ord a) => Diff a -> Diff (HieAST a)
type DiffIdent = Either ModuleName HieName
normalizeIdents :: Ord a => NodeIdentifiers a -> [(DiffIdent, IdentifierDetails a)]
diffList :: Diff a -> Diff [a]
eqDiff :: (Outputable a, Eq a) => Diff a
validAst :: HieAST a -> Either SDoc ()

-- | Look for any identifiers which occur outside of their supposed scopes.
--   Returns a list of error messages.
validateScopes :: Module -> Map HiePath (HieAST a) -> [SDoc]

module GHC.Core.Opt.Simplify
simplTopBinds :: SimplEnv -> [InBind] -> SimplM (SimplFloats, SimplEnv)
simplExpr :: SimplEnv -> CoreExpr -> SimplM CoreExpr
simplRules :: SimplEnv -> Maybe OutId -> [CoreRule] -> MaybeJoinCont -> SimplM [CoreRule]

module GHC.Core.Opt.FloatOut
floatOutwards :: Logger -> FloatOutSwitches -> DynFlags -> UniqSupply -> CoreProgram -> IO CoreProgram
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.FloatOut.FloatBinds

module GHC.Core.Opt.DmdAnal

-- | Options for the demand analysis
newtype DmdAnalOpts
DmdAnalOpts :: Bool -> DmdAnalOpts

-- | Use strict dictionaries
[dmd_strict_dicts] :: DmdAnalOpts -> Bool

-- | Outputs a new copy of the Core program in which binders have been
--   annotated with demand and strictness information.
--   
--   Note: use <tt>seqBinds</tt> on the result to avoid leaks due to
--   lazyness (cf Note [Stamp out space leaks in demand analysis])
dmdAnalProgram :: DmdAnalOpts -> FamInstEnvs -> [CoreRule] -> CoreProgram -> CoreProgram
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.DmdAnal.AnalEnv

module GHC.Core.Opt.CallArity
callArityAnalProgram :: DynFlags -> CoreProgram -> CoreProgram
callArityRHS :: CoreExpr -> CoreExpr


-- | GHC LLVM Mangler
--   
--   This script processes the assembly produced by LLVM, rewriting all
--   symbols of type <tt>function to </tt>object. This keeps them from
--   going through the PLT, which would be bad due to tables-next-to-code.
--   On x86_64, it also rewrites AVX instructions that require alignment to
--   their unaligned counterparts, since the stack is only 16-byte aligned
--   but these instructions require 32-byte alignment.
module GHC.CmmToLlvm.Mangler

-- | Read in assembly file and process
llvmFixupAsm :: Logger -> DynFlags -> FilePath -> FilePath -> IO ()

module GHC.CmmToAsm.Instr

-- | Common things that we can do with instructions, on all architectures.
--   These are used by the shared parts of the native code generator,
--   specifically the register allocators.
class Instruction instr

-- | Get the registers that are being used by this instruction. regUsage
--   doesn't need to do any trickery for jumps and such. Just state
--   precisely the regs read and written by that insn. The consequences of
--   control flow transfers, as far as register allocation goes, are taken
--   care of by the register allocator.
regUsageOfInstr :: Instruction instr => Platform -> instr -> RegUsage

-- | Apply a given mapping to all the register references in this
--   instruction.
patchRegsOfInstr :: Instruction instr => instr -> (Reg -> Reg) -> instr

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
isJumpishInstr :: Instruction instr => instr -> Bool

-- | Give the possible destinations of this jump instruction. Must be
--   defined for all jumpish instructions.
jumpDestsOfInstr :: Instruction instr => instr -> [BlockId]

-- | Change the destination of this jump instruction. Used in the linear
--   allocator when adding fixup blocks for join points.
patchJumpInstr :: Instruction instr => instr -> (BlockId -> BlockId) -> instr

-- | An instruction to spill a register into a spill slot.
mkSpillInstr :: Instruction instr => NCGConfig -> Reg -> Int -> Int -> [instr]

-- | An instruction to reload a register from a spill slot.
mkLoadInstr :: Instruction instr => NCGConfig -> Reg -> Int -> Int -> [instr]

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instruction instr => instr -> Maybe Int

-- | Check whether this instruction is some meta thing inserted into the
--   instruction stream for other purposes.
--   
--   Not something that has to be treated as a real machine instruction and
--   have its registers allocated.
--   
--   eg, comments, delta, ldata, etc.
isMetaInstr :: Instruction instr => instr -> Bool

-- | Copy the value in a register to another one. Must work for all
--   register classes.
mkRegRegMoveInstr :: Instruction instr => Platform -> Reg -> Reg -> instr

-- | Take the source and destination from this reg -&gt; reg move
--   instruction or Nothing if it's not one
takeRegRegMoveInstr :: Instruction instr => instr -> Maybe (Reg, Reg)

-- | Make an unconditional jump instruction. For architectures with branch
--   delay slots, its ok to put a NOP after the jump. Don't fill the delay
--   slot with an instruction that references regs or you'll confuse the
--   linear allocator.
mkJumpInstr :: Instruction instr => BlockId -> [instr]
mkStackAllocInstr :: Instruction instr => Platform -> Int -> [instr]
mkStackDeallocInstr :: Instruction instr => Platform -> Int -> [instr]

-- | Pretty-print an instruction
pprInstr :: Instruction instr => Platform -> instr -> SDoc
mkComment :: Instruction instr => SDoc -> [instr]

-- | Holds a list of source and destination registers used by a particular
--   instruction.
--   
--   Machine registers that are pre-allocated to stgRegs are filtered out,
--   because they are uninteresting from a register allocation standpoint.
--   (We wouldn't want them to end up on the free list!)
--   
--   As far as we are concerned, the fixed registers simply don't exist
--   (for allocation purposes, anyway).
data RegUsage
RU :: [Reg] -> [Reg] -> RegUsage
[reads] :: RegUsage -> [Reg]
[writes] :: RegUsage -> [Reg]

-- | No regs read or written to.
noUsage :: RegUsage
instance GHC.Show.Show GHC.CmmToAsm.Instr.RegUsage

module GHC.Cmm.Ppr.Expr
pprExpr :: Platform -> CmmExpr -> SDoc
pprLit :: Platform -> CmmLit -> SDoc
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.Expr.CmmExpr
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Expr.CmmReg
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.Expr.CmmLit
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Expr.LocalReg
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Expr.Area
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Expr.GlobalReg
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.Expr.GlobalReg

module GHC.Cmm.LRegSet
type LRegSet = IntSet
type LRegKey = Int
emptyLRegSet :: LRegSet
nullLRegSet :: LRegSet -> Bool
insertLRegSet :: LocalReg -> LRegSet -> LRegSet
elemLRegSet :: LocalReg -> LRegSet -> Bool
deleteFromLRegSet :: LRegSet -> LocalReg -> LRegSet
sizeLRegSet :: IntSet -> Int
plusLRegSet :: IntSet -> IntSet -> IntSet
elemsLRegSet :: IntSet -> [Int]

module GHC.Core.Opt.Specialise

-- | Specialise calls to type-class overloaded functions occurring in a
--   program.
specProgram :: ModGuts -> CoreM ModGuts
specUnfolding :: SimpleOpts -> [Var] -> (CoreExpr -> CoreExpr) -> [CoreArg] -> Unfolding -> Unfolding
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.UsageDetails
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.CallInfoSet
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.CallInfo
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.SpecArg
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.DictBind
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.SpecEnv

module GHC.Core.Opt.SpecConstr
specConstrProgram :: ModGuts -> CoreM ModGuts
data SpecConstrAnnotation
NoSpecConstr :: SpecConstrAnnotation
ForceSpecConstr :: SpecConstrAnnotation
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.ScUsage
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.ArgOcc
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.Call
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.HowBound
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.Value

module GHC.Core.Opt.FloatIn
floatInwards :: ModGuts -> CoreM ModGuts


-- | Module finder
module GHC.Unit.Finder

-- | The result of searching for an imported module.
--   
--   NB: FindResult manages both user source-import lookups (which can
--   result in <a>Module</a>) as well as direct imports for interfaces
--   (which always result in <a>InstalledModule</a>).
data FindResult

-- | The module was found
Found :: ModLocation -> Module -> FindResult

-- | The requested unit was not found
NoPackage :: Unit -> FindResult

-- | _Error_: both in multiple packages
FoundMultiple :: [(Module, ModuleOrigin)] -> FindResult

-- | Not found
NotFound :: [FilePath] -> Maybe Unit -> [Unit] -> [Unit] -> [(Unit, UnusableUnitReason)] -> [ModuleSuggestion] -> FindResult

-- | Places where I looked
[fr_paths] :: FindResult -> [FilePath]

-- | Just p =&gt; module is in this unit's manifest, but couldn't find the
--   .hi file
[fr_pkg] :: FindResult -> Maybe Unit

-- | Module is in these units, but the *module* is hidden
[fr_mods_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but the *unit* is hidden
[fr_pkgs_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but it is unusable
[fr_unusables] :: FindResult -> [(Unit, UnusableUnitReason)]

-- | Possible mis-spelled modules
[fr_suggestions] :: FindResult -> [ModuleSuggestion]
data InstalledFindResult
InstalledFound :: ModLocation -> InstalledModule -> InstalledFindResult
InstalledNoPackage :: UnitId -> InstalledFindResult
InstalledNotFound :: [FilePath] -> Maybe UnitId -> InstalledFindResult

-- | The <a>FinderCache</a> maps modules to the result of searching for
--   that module. It records the results of searching for modules along the
--   search path. On <tt>:load</tt>, we flush the entire contents of this
--   cache.
type FinderCache = InstalledModuleEnv InstalledFindResult
flushFinderCaches :: HscEnv -> IO ()

-- | Locate a module that was imported by the user. We have the module's
--   name, and possibly a package name. Without a package name, this
--   function will use the search path and the known exposed packages to
--   find the module, if a package is specified then only that package is
--   searched for the module.
findImportedModule :: HscEnv -> ModuleName -> Maybe FastString -> IO FindResult

-- | Locate a plugin module requested by the user, for a compiler plugin.
--   This consults the same set of exposed packages as
--   <a>findImportedModule</a>, unless <tt>-hide-all-plugin-packages</tt>
--   or <tt>-plugin-package</tt> are specified.
findPluginModule :: HscEnv -> ModuleName -> IO FindResult

-- | Locate a specific <a>Module</a>. The purpose of this function is to
--   create a <a>ModLocation</a> for a given <a>Module</a>, that is to find
--   out where the files associated with this module live. It is used when
--   reading the interface for a module mentioned by another interface, for
--   example (a "system import").
findExactModule :: HscEnv -> InstalledModule -> IO InstalledFindResult
findHomeModule :: HscEnv -> ModuleName -> IO FindResult
findExposedPackageModule :: HscEnv -> ModuleName -> Maybe FastString -> IO FindResult
mkHomeModLocation :: DynFlags -> ModuleName -> FilePath -> IO ModLocation
mkHomeModLocation2 :: DynFlags -> ModuleName -> FilePath -> String -> IO ModLocation
mkHiOnlyModLocation :: DynFlags -> Suffix -> FilePath -> String -> IO ModLocation

-- | Constructs the filename of a .hi file for a given source file. Does
--   <i>not</i> check whether the .hi file exists
mkHiPath :: DynFlags -> FilePath -> String -> FilePath

-- | Constructs the filename of a .o file for a given source file. Does
--   <i>not</i> check whether the .o file exists
mkObjPath :: DynFlags -> FilePath -> String -> FilePath
addHomeModuleToFinder :: HscEnv -> ModuleName -> ModLocation -> IO Module
uncacheModule :: HscEnv -> ModuleName -> IO ()
mkStubPaths :: DynFlags -> ModuleName -> ModLocation -> FilePath
findObjectLinkableMaybe :: Module -> ModLocation -> IO (Maybe Linkable)
findObjectLinkable :: Module -> FilePath -> UTCTime -> IO Linkable

module GHC.HsToCore.Usage
mkUsageInfo :: HscEnv -> Module -> ImportedMods -> NameSet -> [FilePath] -> [(Module, Fingerprint)] -> [ModIface] -> IO [Usage]
mkUsedNames :: TcGblEnv -> NameSet

-- | Extract information from the rename and typecheck phases to produce a
--   dependencies information for the module being compiled.
--   
--   The second argument is additional dependencies from plugins
mkDependencies :: UnitId -> [Module] -> TcGblEnv -> IO Dependencies


-- | Interacting with the iserv interpreter, whether it is running on an
--   external process or in the current process.
module GHC.Runtime.Interpreter

-- | Execute an action of type <tt>IO [a]</tt>, returning
--   <a>ForeignHValue</a>s for each of the results.
evalStmt :: Interp -> DynFlags -> Bool -> EvalExpr ForeignHValue -> IO (EvalStatus_ [ForeignHValue] [HValueRef])
data EvalStatus_ a b
EvalComplete :: Word64 -> EvalResult a -> EvalStatus_ a b
EvalBreak :: Bool -> HValueRef -> Int -> Int -> RemoteRef (ResumeContext b) -> RemotePtr CostCentreStack -> EvalStatus_ a b
type EvalStatus a = EvalStatus_ a a
data EvalResult a
EvalException :: SerializableException -> EvalResult a
EvalSuccess :: a -> EvalResult a

-- | We can pass simple expressions to EvalStmt, consisting of values and
--   application. This allows us to wrap the statement to be executed in
--   another function, which is used by GHCi to implement :set args and
--   :set prog. It might be worthwhile to extend this little language in
--   the future.
data EvalExpr a
EvalThis :: a -> EvalExpr a
EvalApp :: EvalExpr a -> EvalExpr a -> EvalExpr a
resumeStmt :: Interp -> DynFlags -> Bool -> ForeignRef (ResumeContext [HValueRef]) -> IO (EvalStatus_ [ForeignHValue] [HValueRef])
abandonStmt :: Interp -> ForeignRef (ResumeContext [HValueRef]) -> IO ()

-- | Execute an action of type <tt>IO ()</tt>
evalIO :: Interp -> ForeignHValue -> IO ()

-- | Execute an action of type <tt>IO String</tt>
evalString :: Interp -> ForeignHValue -> IO String

-- | Execute an action of type <tt>String -&gt; IO String</tt>
evalStringToIOString :: Interp -> ForeignHValue -> String -> IO String

-- | Allocate and store the given bytes in memory, returning a pointer to
--   the memory in the remote process.
mallocData :: Interp -> ByteString -> IO (RemotePtr ())

-- | Create a set of BCOs that may be mutually recursive.
createBCOs :: Interp -> DynFlags -> [ResolvedBCO] -> IO [HValueRef]
addSptEntry :: Interp -> Fingerprint -> ForeignHValue -> IO ()
mkCostCentres :: Interp -> String -> [(String, String)] -> IO [RemotePtr CostCentre]
costCentreStackInfo :: Interp -> RemotePtr CostCentreStack -> IO [String]
newBreakArray :: Interp -> Int -> IO (ForeignRef BreakArray)
storeBreakpoint :: Interp -> ForeignRef BreakArray -> Int -> Int -> IO ()
breakpointStatus :: Interp -> ForeignRef BreakArray -> Int -> IO Bool
getBreakpointVar :: Interp -> ForeignHValue -> Int -> IO (Maybe ForeignHValue)
getClosure :: Interp -> ForeignHValue -> IO (GenClosure ForeignHValue)
getModBreaks :: HomeModInfo -> ModBreaks

-- | Send a Seq message to the iserv process to force a value #2950
seqHValue :: Interp -> HscEnv -> ForeignHValue -> IO (EvalResult ())

-- | Interpreter uses Dynamic way
interpreterDynamic :: Interp -> Bool

-- | Interpreter uses Profiling way
interpreterProfiled :: Interp -> Bool
initObjLinker :: Interp -> IO ()
lookupSymbol :: Interp -> FastString -> IO (Maybe (Ptr ()))
lookupClosure :: Interp -> String -> IO (Maybe HValueRef)

-- | loadDLL loads a dynamic library using the OS's native linker (i.e.
--   dlopen() on Unix, LoadLibrary() on Windows). It takes either an
--   absolute pathname to the file, or a relative filename (e.g.
--   "libfoo.so" or "foo.dll"). In the latter case, loadDLL searches the
--   standard locations for the appropriate library.
--   
--   Returns:
--   
--   Nothing =&gt; success Just err_msg =&gt; failure
loadDLL :: Interp -> String -> IO (Maybe String)
loadArchive :: Interp -> String -> IO ()
loadObj :: Interp -> String -> IO ()
unloadObj :: Interp -> String -> IO ()
addLibrarySearchPath :: Interp -> String -> IO (Ptr ())
removeLibrarySearchPath :: Interp -> Ptr () -> IO Bool
resolveObjs :: Interp -> IO SuccessFlag
findSystemLibrary :: Interp -> String -> IO (Maybe String)

-- | Run a command in the interpreter's context. With
--   <tt>-fexternal-interpreter</tt>, the command is serialized and sent to
--   an external iserv process, and the response is deserialized (hence the
--   <tt>Binary</tt> constraint). With <tt>-fno-external-interpreter</tt>
--   we execute the command directly here.
interpCmd :: Binary a => Interp -> Message a -> IO a

-- | A <tt>Message a</tt> is a message that returns a value of type
--   <tt>a</tt>. These are requests sent from GHC to the server.
data Message a

-- | Exit the iserv process
[Shutdown] :: Message ()
[RtsRevertCAFs] :: Message ()
[InitLinker] :: Message ()
[LookupSymbol] :: String -> Message (Maybe (RemotePtr ()))
[LookupClosure] :: String -> Message (Maybe HValueRef)
[LoadDLL] :: String -> Message (Maybe String)
[LoadArchive] :: String -> Message ()
[LoadObj] :: String -> Message ()
[UnloadObj] :: String -> Message ()
[AddLibrarySearchPath] :: String -> Message (RemotePtr ())
[RemoveLibrarySearchPath] :: RemotePtr () -> Message Bool
[ResolveObjs] :: Message Bool
[FindSystemLibrary] :: String -> Message (Maybe String)

-- | Create a set of BCO objects, and return HValueRefs to them Note: Each
--   ByteString contains a Binary-encoded [ResolvedBCO], not a ResolvedBCO.
--   The list is to allow us to serialise the ResolvedBCOs in parallel. See
--   <tt>createBCOs</tt> in compiler<i>GHC</i>Runtime/Interpreter.hs.
[CreateBCOs] :: [ByteString] -> Message [HValueRef]

-- | Release <a>HValueRef</a>s
[FreeHValueRefs] :: [HValueRef] -> Message ()

-- | Add entries to the Static Pointer Table
[AddSptEntry] :: Fingerprint -> HValueRef -> Message ()

-- | Malloc some data and return a <a>RemotePtr</a> to it
[MallocData] :: ByteString -> Message (RemotePtr ())
[MallocStrings] :: [ByteString] -> Message [RemotePtr ()]

-- | Calls <a>prepareForeignCall</a>
[PrepFFI] :: FFIConv -> [FFIType] -> FFIType -> Message (RemotePtr C_ffi_cif)

-- | Free data previously created by <a>PrepFFI</a>
[FreeFFI] :: RemotePtr C_ffi_cif -> Message ()

-- | Create an info table for a constructor
[MkConInfoTable] :: Bool -> Int -> Int -> Int -> Int -> ByteString -> Message (RemotePtr StgInfoTable)

-- | Evaluate a statement
[EvalStmt] :: EvalOpts -> EvalExpr HValueRef -> Message (EvalStatus_ [HValueRef] [HValueRef])

-- | Resume evaluation of a statement after a breakpoint
[ResumeStmt] :: EvalOpts -> RemoteRef (ResumeContext [HValueRef]) -> Message (EvalStatus_ [HValueRef] [HValueRef])

-- | Abandon evaluation of a statement after a breakpoint
[AbandonStmt] :: RemoteRef (ResumeContext [HValueRef]) -> Message ()

-- | Evaluate something of type <tt>IO String</tt>
[EvalString] :: HValueRef -> Message (EvalResult String)

-- | Evaluate something of type <tt>String -&gt; IO String</tt>
[EvalStringToString] :: HValueRef -> String -> Message (EvalResult String)

-- | Evaluate something of type <tt>IO ()</tt>
[EvalIO] :: HValueRef -> Message (EvalResult ())

-- | Create a set of CostCentres with the same module name
[MkCostCentres] :: String -> [(String, String)] -> Message [RemotePtr CostCentre]

-- | Show a <a>CostCentreStack</a> as a <tt>[String]</tt>
[CostCentreStackInfo] :: RemotePtr CostCentreStack -> Message [String]

-- | Create a new array of breakpoint flags
[NewBreakArray] :: Int -> Message (RemoteRef BreakArray)

-- | Set how many times a breakpoint should be ignored also used for
--   enable/disable
[SetupBreakpoint] :: RemoteRef BreakArray -> Int -> Int -> Message ()

-- | Query the status of a breakpoint (True <a>=</a> enabled)
[BreakpointStatus] :: RemoteRef BreakArray -> Int -> Message Bool

-- | Get a reference to a free variable at a breakpoint
[GetBreakpointVar] :: HValueRef -> Int -> Message (Maybe HValueRef)

-- | Start a new TH module, return a state token that should be
[StartTH] :: Message (RemoteRef (IORef QState))

-- | Evaluate a TH computation.
--   
--   Returns a ByteString, because we have to force the result before
--   returning it to ensure there are no errors lurking in it. The TH types
--   don't have NFData instances, and even if they did, we have to
--   serialize the value anyway, so we might as well serialize it to force
--   it.
[RunTH] :: RemoteRef (IORef QState) -> HValueRef -> THResultType -> Maybe Loc -> Message (QResult ByteString)

-- | Run the given mod finalizers.
[RunModFinalizers] :: RemoteRef (IORef QState) -> [RemoteRef (Q ())] -> Message (QResult ())

-- | Remote interface to GHC.Exts.Heap.getClosureData. This is used by the
--   GHCi debugger to inspect values in the heap for :print and type
--   reconstruction.
[GetClosure] :: HValueRef -> Message (GenClosure HValueRef)

-- | Evaluate something. This is used to support :force in GHCi.
[Seq] :: HValueRef -> Message (EvalStatus_ () ())

-- | Resume forcing a free variable in a breakpoint (#2950)
[ResumeSeq] :: RemoteRef (ResumeContext ()) -> Message (EvalStatus_ () ())

-- | Grab a lock on the <a>IServ</a> and do something with it. Overloaded
--   because this is used from TcM as well as IO.
withIServ :: ExceptionMonad m => IServConfig -> IServ -> (IServInstance -> m (IServInstance, a)) -> m a
withIServ_ :: (MonadIO m, ExceptionMonad m) => IServConfig -> IServ -> (IServInstance -> m a) -> m a

-- | Retrieve the target code interpreter
--   
--   Fails if no target code interpreter is available
hscInterp :: HscEnv -> Interp

-- | Stop the interpreter
stopInterp :: Interp -> IO ()

-- | Send a <a>Message</a> and receive the response from the iserv process
iservCall :: Binary a => IServInstance -> Message a -> IO a

-- | Read a value from the iserv process
readIServ :: IServInstance -> Get a -> IO a

-- | Send a value to the iserv process
writeIServ :: IServInstance -> Put -> IO ()
purgeLookupSymbolCache :: Interp -> IO ()
freeHValueRefs :: Interp -> [HValueRef] -> IO ()

-- | Creates a <a>ForeignRef</a> that will automatically release the
--   <a>RemoteRef</a> when it is no longer referenced.
mkFinalizedHValue :: Interp -> RemoteRef a -> IO (ForeignRef a)

-- | Convert a <a>ForeignRef</a> to the value it references directly. This
--   only works when the interpreter is running in the same process as the
--   compiler, so it fails when <tt>-fexternal-interpreter</tt> is on.
wormhole :: Interp -> ForeignRef a -> IO a

-- | Convert an <a>RemoteRef</a> to the value it references directly. This
--   only works when the interpreter is running in the same process as the
--   compiler, so it fails when <tt>-fexternal-interpreter</tt> is on.
wormholeRef :: Interp -> RemoteRef a -> IO a
mkEvalOpts :: DynFlags -> Bool -> EvalOpts
fromEvalResult :: EvalResult a -> IO a

module GHC.HsToCore.Coverage
addTicksToBinds :: HscEnv -> Module -> ModLocation -> NameSet -> [TyCon] -> LHsBinds GhcTc -> IO (LHsBinds GhcTc, HpcInfo, Maybe ModBreaks)
hpcInitCode :: DynFlags -> Module -> HpcInfo -> CStub
instance GHC.Classes.Eq GHC.HsToCore.Coverage.TickDensity
instance GHC.Classes.Eq GHC.HsToCore.Coverage.TickishType
instance GHC.Base.Functor GHC.HsToCore.Coverage.TM
instance GHC.Base.Applicative GHC.HsToCore.Coverage.TM
instance GHC.Base.Monad GHC.HsToCore.Coverage.TM
instance GHC.Driver.Session.HasDynFlags GHC.HsToCore.Coverage.TM


-- | Bytecode assembler and linker
module GHC.ByteCode.Linker
type ClosureEnv = NameEnv (Name, ForeignHValue)
emptyClosureEnv :: ClosureEnv
extendClosureEnv :: ClosureEnv -> [(Name, ForeignHValue)] -> ClosureEnv
linkBCO :: Interp -> ItblEnv -> ClosureEnv -> NameEnv Int -> RemoteRef BreakArray -> UnlinkedBCO -> IO ResolvedBCO
lookupStaticPtr :: Interp -> FastString -> IO (Ptr ())
lookupIE :: Interp -> ItblEnv -> Name -> IO (Ptr ())
nameToCLabel :: Name -> String -> FastString
linkFail :: String -> String -> IO a

module GHC.CmmToAsm.X86.Regs

-- | regSqueeze_class reg Calculate the maximum number of register colors
--   that could be denied to a node of this class due to having this reg as
--   a neighbour.
virtualRegSqueeze :: RegClass -> VirtualReg -> Int
realRegSqueeze :: RegClass -> RealReg -> Int
data Imm
ImmInt :: Int -> Imm
ImmInteger :: Integer -> Imm
ImmCLbl :: CLabel -> Imm
ImmLit :: SDoc -> Imm
ImmIndex :: CLabel -> Int -> Imm
ImmFloat :: Rational -> Imm
ImmDouble :: Rational -> Imm
ImmConstantSum :: Imm -> Imm -> Imm
ImmConstantDiff :: Imm -> Imm -> Imm
strImmLit :: String -> Imm
litToImm :: CmmLit -> Imm
data AddrMode
AddrBaseIndex :: EABase -> EAIndex -> Displacement -> AddrMode
ImmAddr :: Imm -> Int -> AddrMode
addrOffset :: AddrMode -> Int -> Maybe AddrMode
spRel :: Platform -> Int -> AddrMode
argRegs :: RegNo -> [Reg]
allArgRegs :: Platform -> [(Reg, Reg)]
allIntArgRegs :: Platform -> [Reg]

-- | these are the regs which we cannot assume stay alive over a C call.
callClobberedRegs :: Platform -> [Reg]
instrClobberedRegs :: Platform -> [Reg]

-- | The complete set of machine registers.
allMachRegNos :: Platform -> [RegNo]

-- | Take the class of a register.
classOfRealReg :: Platform -> RealReg -> RegClass

-- | Get the name of the register with this number. NOTE: fixme, we dont
--   track which "way" the XMM registers are used
showReg :: Platform -> RegNo -> String
data EABase
EABaseNone :: EABase
EABaseReg :: Reg -> EABase
EABaseRip :: EABase
data EAIndex
EAIndexNone :: EAIndex
EAIndex :: Reg -> Int -> EAIndex
addrModeRegs :: AddrMode -> [Reg]
eax :: Reg
ebx :: Reg
ecx :: Reg
edx :: Reg
esi :: Reg
edi :: Reg
ebp :: Reg
esp :: Reg
rax :: Reg
rbx :: Reg
rcx :: Reg
rdx :: Reg
rsi :: Reg
rdi :: Reg
rbp :: Reg
rsp :: Reg
r8 :: Reg
r9 :: Reg
r10 :: Reg
r11 :: Reg
r12 :: Reg
r13 :: Reg
r14 :: Reg
r15 :: Reg
lastint :: Platform -> RegNo
xmm0 :: Reg
xmm1 :: Reg
xmm2 :: Reg
xmm3 :: Reg
xmm4 :: Reg
xmm5 :: Reg
xmm6 :: Reg
xmm7 :: Reg
xmm8 :: Reg
xmm9 :: Reg
xmm10 :: Reg
xmm11 :: Reg
xmm12 :: Reg
xmm13 :: Reg
xmm14 :: Reg
xmm15 :: Reg
xmm :: RegNo -> Reg
firstxmm :: RegNo
lastxmm :: Platform -> RegNo
ripRel :: Displacement -> AddrMode

-- | on 64bit platforms we pass the first 8 float/double arguments in the
--   xmm registers.
allFPArgRegs :: Platform -> [Reg]
allocatableRegs :: Platform -> [RealReg]


-- | Free regs map for x86_64
module GHC.CmmToAsm.Reg.Linear.X86_64
newtype FreeRegs
FreeRegs :: Word64 -> FreeRegs
noFreeRegs :: FreeRegs
releaseReg :: RealReg -> FreeRegs -> FreeRegs
initFreeRegs :: Platform -> FreeRegs
getFreeRegs :: Platform -> RegClass -> FreeRegs -> [RealReg]
allocateReg :: RealReg -> FreeRegs -> FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.X86_64.FreeRegs
instance GHC.Show.Show GHC.CmmToAsm.Reg.Linear.X86_64.FreeRegs


-- | Free regs map for i386
module GHC.CmmToAsm.Reg.Linear.X86
newtype FreeRegs
FreeRegs :: Word32 -> FreeRegs
noFreeRegs :: FreeRegs
releaseReg :: RealReg -> FreeRegs -> FreeRegs
initFreeRegs :: Platform -> FreeRegs
getFreeRegs :: Platform -> RegClass -> FreeRegs -> [RealReg]
allocateReg :: RealReg -> FreeRegs -> FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.X86.FreeRegs
instance GHC.Show.Show GHC.CmmToAsm.Reg.Linear.X86.FreeRegs

module GHC.CmmToAsm.Utils

-- | Returns the info table associated with the CmmDecl's entry point, if
--   any.
topInfoTable :: GenCmmDecl a (LabelMap i) (ListGraph b) -> Maybe i

-- | Return the list of BlockIds in a CmmDecl that are entry points for
--   this proc (i.e. they may be jumped to from outside this proc).
entryBlocks :: GenCmmDecl a (LabelMap i) (ListGraph b) -> [BlockId]

module GHC.CmmToAsm.Types
type NatCmm instr = GenCmmGroup RawCmmStatics (LabelMap RawCmmStatics) (ListGraph instr)
type NatCmmDecl statics instr = GenCmmDecl statics (LabelMap RawCmmStatics) (ListGraph instr)
type NatBasicBlock instr = GenBasicBlock instr
data GenBasicBlock i
BasicBlock :: BlockId -> [i] -> GenBasicBlock i

-- | The branch block id is that of the first block in the branch, which is
--   that branch's entry point
blockId :: GenBasicBlock i -> BlockId
newtype ListGraph i
ListGraph :: [GenBasicBlock i] -> ListGraph i
type RawCmmStatics = GenCmmStatics 'True
type RawCmmDecl = GenCmmDecl RawCmmStatics (LabelMap RawCmmStatics) CmmGraph

module GHC.CmmToAsm.SPARC.Imm

-- | An immediate value. Not all of these are directly representable by the
--   machine. Things like ImmLit are slurped out and put in a data segment
--   instead.
data Imm
ImmInt :: Int -> Imm
ImmInteger :: Integer -> Imm
ImmCLbl :: CLabel -> Imm
ImmLit :: SDoc -> Imm
ImmIndex :: CLabel -> Int -> Imm
ImmFloat :: Rational -> Imm
ImmDouble :: Rational -> Imm
ImmConstantSum :: Imm -> Imm -> Imm
ImmConstantDiff :: Imm -> Imm -> Imm
LO :: Imm -> Imm
HI :: Imm -> Imm

-- | Create a ImmLit containing this string.
strImmLit :: String -> Imm

-- | Convert a CmmLit to an Imm. Narrow to the width: a CmmInt might be out
--   of range, but we assume that ImmInteger only contains in-range values.
--   A signed value should be fine here.
litToImm :: CmmLit -> Imm

module GHC.CmmToAsm.SPARC.AddrMode

-- | Represents a memory address in an instruction. Being a RISC machine,
--   the SPARC addressing modes are very regular.
data AddrMode
AddrRegReg :: Reg -> Reg -> AddrMode
AddrRegImm :: Reg -> Imm -> AddrMode

-- | Add an integer offset to the address in an AddrMode.
addrOffset :: AddrMode -> Int -> Maybe AddrMode

module GHC.CmmToAsm.Ppr
doubleToBytes :: Double -> [Int]
pprASCII :: ByteString -> SDoc

-- | Emit a ".string" directive
pprString :: ByteString -> SDoc

-- | Emit a ".incbin" directive
--   
--   A NULL byte is added after the binary data.
pprFileEmbed :: FilePath -> SDoc
pprSectionHeader :: NCGConfig -> Section -> SDoc


-- | The LLVM Type System.
module GHC.Llvm.Types

-- | A global mutable variable. Maybe defined or external
data LMGlobal
LMGlobal :: LlvmVar -> Maybe LlvmStatic -> LMGlobal

-- | Returns the variable of the <a>LMGlobal</a>
[getGlobalVar] :: LMGlobal -> LlvmVar

-- | Return the value of the <a>LMGlobal</a>
[getGlobalValue] :: LMGlobal -> Maybe LlvmStatic

-- | A String in LLVM
type LMString = FastString

-- | A type alias
type LlvmAlias = (LMString, LlvmType)

-- | Llvm Types
data LlvmType

-- | An integer with a given width in bits.
LMInt :: Int -> LlvmType

-- | 32 bit floating point
LMFloat :: LlvmType

-- | 64 bit floating point
LMDouble :: LlvmType

-- | 80 bit (x86 only) floating point
LMFloat80 :: LlvmType

-- | 128 bit floating point
LMFloat128 :: LlvmType

-- | A pointer to a <a>LlvmType</a>
LMPointer :: LlvmType -> LlvmType

-- | An array of <a>LlvmType</a>
LMArray :: Int -> LlvmType -> LlvmType

-- | A vector of <a>LlvmType</a>
LMVector :: Int -> LlvmType -> LlvmType

-- | A <a>LlvmVar</a> can represent a label (address)
LMLabel :: LlvmType

-- | Void type
LMVoid :: LlvmType

-- | Packed structure type
LMStruct :: [LlvmType] -> LlvmType

-- | Unpacked structure type
LMStructU :: [LlvmType] -> LlvmType

-- | A type alias
LMAlias :: LlvmAlias -> LlvmType

-- | LLVM Metadata
LMMetadata :: LlvmType

-- | Function type, used to create pointers to functions
LMFunction :: LlvmFunctionDecl -> LlvmType
ppType :: LlvmType -> SDoc
ppParams :: LlvmParameterListType -> [LlvmParameter] -> SDoc

-- | An LLVM section definition. If Nothing then let LLVM decide the
--   section
type LMSection = Maybe LMString
type LMAlign = Maybe Int
data LMConst

-- | Mutable global variable
Global :: LMConst

-- | Constant global variable
Constant :: LMConst

-- | Alias of another variable
Alias :: LMConst

-- | LLVM Variables
data LlvmVar

-- | Variables with a global scope.
LMGlobalVar :: LMString -> LlvmType -> LlvmLinkageType -> LMSection -> LMAlign -> LMConst -> LlvmVar

-- | Variables local to a function or parameters.
LMLocalVar :: Unique -> LlvmType -> LlvmVar

-- | Named local variables. Sometimes we need to be able to explicitly name
--   variables (e.g for function arguments).
LMNLocalVar :: LMString -> LlvmType -> LlvmVar

-- | A constant variable
LMLitVar :: LlvmLit -> LlvmVar

-- | Llvm Literal Data.
--   
--   These can be used inline in expressions.
data LlvmLit

-- | Refers to an integer constant (i64 42).
LMIntLit :: Integer -> LlvmType -> LlvmLit

-- | Floating point literal
LMFloatLit :: Double -> LlvmType -> LlvmLit

-- | Literal NULL, only applicable to pointer types
LMNullLit :: LlvmType -> LlvmLit

-- | Vector literal
LMVectorLit :: [LlvmLit] -> LlvmLit

-- | Undefined value, random bit pattern. Useful for optimisations.
LMUndefLit :: LlvmType -> LlvmLit

-- | Llvm Static Data.
--   
--   These represent the possible global level variables and constants.
data LlvmStatic

-- | A comment in a static section
LMComment :: LMString -> LlvmStatic

-- | A static variant of a literal value
LMStaticLit :: LlvmLit -> LlvmStatic

-- | For uninitialised data
LMUninitType :: LlvmType -> LlvmStatic

-- | Defines a static <a>LMString</a>
LMStaticStr :: LMString -> LlvmType -> LlvmStatic

-- | A static array
LMStaticArray :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A static structure type
LMStaticStruc :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A pointer to other data
LMStaticPointer :: LlvmVar -> LlvmStatic

-- | Truncate
LMTrunc :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Pointer to Pointer conversion
LMBitc :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Pointer to Integer conversion
LMPtoI :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Constant addition operation
LMAdd :: LlvmStatic -> LlvmStatic -> LlvmStatic

-- | Constant subtraction operation
LMSub :: LlvmStatic -> LlvmStatic -> LlvmStatic

-- | LLVM code generator options
data LlvmOpts
LlvmOpts :: !Platform -> !Bool -> !Bool -> LlvmOpts

-- | Target platform
[llvmOptsPlatform] :: LlvmOpts -> !Platform

-- | Fill undefined literals with garbage values
[llvmOptsFillUndefWithGarbage] :: LlvmOpts -> !Bool

-- | Split sections
[llvmOptsSplitSections] :: LlvmOpts -> !Bool

-- | Get LlvmOptions from DynFlags
initLlvmOpts :: DynFlags -> LlvmOpts
garbageLit :: LlvmType -> Maybe LlvmLit

-- | Return the <a>LlvmType</a> of the <a>LlvmVar</a>
getVarType :: LlvmVar -> LlvmType

-- | Return the <a>LlvmType</a> of a <a>LlvmLit</a>
getLitType :: LlvmLit -> LlvmType

-- | Return the <a>LlvmType</a> of the <a>LlvmStatic</a>
getStatType :: LlvmStatic -> LlvmType

-- | Return the <a>LlvmLinkageType</a> for a <a>LlvmVar</a>
getLink :: LlvmVar -> LlvmLinkageType

-- | Add a pointer indirection to the supplied type. <a>LMLabel</a> and
--   <a>LMVoid</a> cannot be lifted.
pLift :: LlvmType -> LlvmType

-- | Lift a variable to <a>LMPointer</a> type.
pVarLift :: LlvmVar -> LlvmVar

-- | Remove the pointer indirection of the supplied type. Only
--   <a>LMPointer</a> constructors can be lowered.
pLower :: LlvmType -> LlvmType

-- | Lower a variable of <a>LMPointer</a> type.
pVarLower :: LlvmVar -> LlvmVar

-- | Test if the given <a>LlvmType</a> is an integer
isInt :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is a floating point type
isFloat :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is an <a>LMPointer</a> construct
isPointer :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is an <a>LMVector</a> construct
isVector :: LlvmType -> Bool

-- | Test if a <a>LlvmVar</a> is global.
isGlobal :: LlvmVar -> Bool

-- | Width in bits of an <a>LlvmType</a>, returns 0 if not applicable
llvmWidthInBits :: Platform -> LlvmType -> Int
i128 :: LlvmType
i64 :: LlvmType
i32 :: LlvmType
i16 :: LlvmType
i8 :: LlvmType
i1 :: LlvmType
i8Ptr :: LlvmType

-- | The target architectures word size
llvmWord :: Platform -> LlvmType

-- | The target architectures word size
llvmWordPtr :: Platform -> LlvmType

-- | An LLVM Function
data LlvmFunctionDecl
LlvmFunctionDecl :: LMString -> LlvmLinkageType -> LlvmCallConvention -> LlvmType -> LlvmParameterListType -> [LlvmParameter] -> LMAlign -> LlvmFunctionDecl

-- | Unique identifier of the function
[decName] :: LlvmFunctionDecl -> LMString

-- | LinkageType of the function
[funcLinkage] :: LlvmFunctionDecl -> LlvmLinkageType

-- | The calling convention of the function
[funcCc] :: LlvmFunctionDecl -> LlvmCallConvention

-- | Type of the returned value
[decReturnType] :: LlvmFunctionDecl -> LlvmType

-- | Indicates if this function uses varargs
[decVarargs] :: LlvmFunctionDecl -> LlvmParameterListType

-- | Parameter types and attributes
[decParams] :: LlvmFunctionDecl -> [LlvmParameter]

-- | Function align value, must be power of 2
[funcAlign] :: LlvmFunctionDecl -> LMAlign
type LlvmFunctionDecls = [LlvmFunctionDecl]
type LlvmParameter = (LlvmType, [LlvmParamAttr])

-- | LLVM Parameter Attributes.
--   
--   Parameter attributes are used to communicate additional information
--   about the result or parameters of a function
data LlvmParamAttr

-- | This indicates to the code generator that the parameter or return
--   value should be zero-extended to a 32-bit value by the caller (for a
--   parameter) or the callee (for a return value).
ZeroExt :: LlvmParamAttr

-- | This indicates to the code generator that the parameter or return
--   value should be sign-extended to a 32-bit value by the caller (for a
--   parameter) or the callee (for a return value).
SignExt :: LlvmParamAttr

-- | This indicates that this parameter or return value should be treated
--   in a special target-dependent fashion during while emitting code for a
--   function call or return (usually, by putting it in a register as
--   opposed to memory).
InReg :: LlvmParamAttr

-- | This indicates that the pointer parameter should really be passed by
--   value to the function.
ByVal :: LlvmParamAttr

-- | This indicates that the pointer parameter specifies the address of a
--   structure that is the return value of the function in the source
--   program.
SRet :: LlvmParamAttr

-- | This indicates that the pointer does not alias any global or any other
--   parameter.
NoAlias :: LlvmParamAttr

-- | This indicates that the callee does not make any copies of the pointer
--   that outlive the callee itself
NoCapture :: LlvmParamAttr

-- | This indicates that the pointer parameter can be excised using the
--   trampoline intrinsics.
Nest :: LlvmParamAttr

-- | Llvm Function Attributes.
--   
--   Function attributes are set to communicate additional information
--   about a function. Function attributes are considered to be part of the
--   function, not of the function type, so functions with different
--   parameter attributes can have the same function type. Functions can
--   have multiple attributes.
--   
--   Descriptions taken from
--   <a>http://llvm.org/docs/LangRef.html#fnattrs</a>
data LlvmFuncAttr

-- | This attribute indicates that the inliner should attempt to inline
--   this function into callers whenever possible, ignoring any active
--   inlining size threshold for this caller.
AlwaysInline :: LlvmFuncAttr

-- | This attribute indicates that the source code contained a hint that
--   inlining this function is desirable (such as the "inline" keyword in
--   C/C++). It is just a hint; it imposes no requirements on the inliner.
InlineHint :: LlvmFuncAttr

-- | This attribute indicates that the inliner should never inline this
--   function in any situation. This attribute may not be used together
--   with the alwaysinline attribute.
NoInline :: LlvmFuncAttr

-- | This attribute suggests that optimization passes and code generator
--   passes make choices that keep the code size of this function low, and
--   otherwise do optimizations specifically to reduce code size.
OptSize :: LlvmFuncAttr

-- | This function attribute indicates that the function never returns
--   normally. This produces undefined behavior at runtime if the function
--   ever does dynamically return.
NoReturn :: LlvmFuncAttr

-- | This function attribute indicates that the function never returns with
--   an unwind or exceptional control flow. If the function does unwind,
--   its runtime behavior is undefined.
NoUnwind :: LlvmFuncAttr

-- | This attribute indicates that the function computes its result (or
--   decides to unwind an exception) based strictly on its arguments,
--   without dereferencing any pointer arguments or otherwise accessing any
--   mutable state (e.g. memory, control registers, etc) visible to caller
--   functions. It does not write through any pointer arguments (including
--   byval arguments) and never changes any state visible to callers. This
--   means that it cannot unwind exceptions by calling the C++ exception
--   throwing methods, but could use the unwind instruction.
ReadNone :: LlvmFuncAttr

-- | This attribute indicates that the function does not write through any
--   pointer arguments (including byval arguments) or otherwise modify any
--   state (e.g. memory, control registers, etc) visible to caller
--   functions. It may dereference pointer arguments and read state that
--   may be set in the caller. A readonly function always returns the same
--   value (or unwinds an exception identically) when called with the same
--   set of arguments and global state. It cannot unwind an exception by
--   calling the C++ exception throwing methods, but may use the unwind
--   instruction.
ReadOnly :: LlvmFuncAttr

-- | This attribute indicates that the function should emit a stack
--   smashing protector. It is in the form of a "canary"âa random value
--   placed on the stack before the local variables that's checked upon
--   return from the function to see if it has been overwritten. A
--   heuristic is used to determine if a function needs stack protectors or
--   not.
--   
--   If a function that has an ssp attribute is inlined into a function
--   that doesn't have an ssp attribute, then the resulting function will
--   have an ssp attribute.
Ssp :: LlvmFuncAttr

-- | This attribute indicates that the function should always emit a stack
--   smashing protector. This overrides the ssp function attribute.
--   
--   If a function that has an sspreq attribute is inlined into a function
--   that doesn't have an sspreq attribute or which has an ssp attribute,
--   then the resulting function will have an sspreq attribute.
SspReq :: LlvmFuncAttr

-- | This attribute indicates that the code generator should not use a red
--   zone, even if the target-specific ABI normally permits it.
NoRedZone :: LlvmFuncAttr

-- | This attributes disables implicit floating point instructions.
NoImplicitFloat :: LlvmFuncAttr

-- | This attribute disables prologue / epilogue emission for the function.
--   This can have very system-specific consequences.
Naked :: LlvmFuncAttr

-- | Different types to call a function.
data LlvmCallType

-- | Normal call, allocate a new stack frame.
StdCall :: LlvmCallType

-- | Tail call, perform the call in the current stack frame.
TailCall :: LlvmCallType

-- | Different calling conventions a function can use.
data LlvmCallConvention

-- | The C calling convention. This calling convention (the default if no
--   other calling convention is specified) matches the target C calling
--   conventions. This calling convention supports varargs function calls
--   and tolerates some mismatch in the declared prototype and implemented
--   declaration of the function (as does normal C).
CC_Ccc :: LlvmCallConvention

-- | This calling convention attempts to make calls as fast as possible
--   (e.g. by passing things in registers). This calling convention allows
--   the target to use whatever tricks it wants to produce fast code for
--   the target, without having to conform to an externally specified ABI
--   (Application Binary Interface). Implementations of this convention
--   should allow arbitrary tail call optimization to be supported. This
--   calling convention does not support varargs and requires the prototype
--   of al callees to exactly match the prototype of the function
--   definition.
CC_Fastcc :: LlvmCallConvention

-- | This calling convention attempts to make code in the caller as
--   efficient as possible under the assumption that the call is not
--   commonly executed. As such, these calls often preserve all registers
--   so that the call does not break any live ranges in the caller side.
--   This calling convention does not support varargs and requires the
--   prototype of all callees to exactly match the prototype of the
--   function definition.
CC_Coldcc :: LlvmCallConvention

-- | The GHC-specific <tt>registerised</tt> calling convention.
CC_Ghc :: LlvmCallConvention

-- | Any calling convention may be specified by number, allowing
--   target-specific calling conventions to be used. Target specific
--   calling conventions start at 64.
CC_Ncc :: Int -> LlvmCallConvention

-- | X86 Specific <a>StdCall</a> convention. LLVM includes a specific alias
--   for it rather than just using CC_Ncc.
CC_X86_Stdcc :: LlvmCallConvention

-- | Functions can have a fixed amount of parameters, or a variable amount.
data LlvmParameterListType
FixedArgs :: LlvmParameterListType
VarArgs :: LlvmParameterListType

-- | Linkage type of a symbol.
--   
--   The description of the constructors is copied from the Llvm Assembly
--   Language Reference Manual
--   <a>http://www.llvm.org/docs/LangRef.html#linkage</a>, because they
--   correspond to the Llvm linkage types.
data LlvmLinkageType

-- | Global values with internal linkage are only directly accessible by
--   objects in the current module. In particular, linking code into a
--   module with an internal global value may cause the internal to be
--   renamed as necessary to avoid collisions. Because the symbol is
--   internal to the module, all references can be updated. This
--   corresponds to the notion of the <tt>static</tt> keyword in C.
Internal :: LlvmLinkageType

-- | Globals with <tt>linkonce</tt> linkage are merged with other globals
--   of the same name when linkage occurs. This is typically used to
--   implement inline functions, templates, or other code which must be
--   generated in each translation unit that uses it. Unreferenced linkonce
--   globals are allowed to be discarded.
LinkOnce :: LlvmLinkageType

-- | <tt>weak</tt> linkage is exactly the same as linkonce linkage, except
--   that unreferenced weak globals may not be discarded. This is used for
--   globals that may be emitted in multiple translation units, but that
--   are not guaranteed to be emitted into every translation unit that uses
--   them. One example of this are common globals in C, such as <tt>int
--   X;</tt> at global scope.
Weak :: LlvmLinkageType

-- | <tt>appending</tt> linkage may only be applied to global variables of
--   pointer to array type. When two global variables with appending
--   linkage are linked together, the two global arrays are appended
--   together. This is the Llvm, typesafe, equivalent of having the system
--   linker append together <tt>sections</tt> with identical names when .o
--   files are linked.
Appending :: LlvmLinkageType

-- | The semantics of this linkage follow the ELF model: the symbol is weak
--   until linked, if not linked, the symbol becomes null instead of being
--   an undefined reference.
ExternWeak :: LlvmLinkageType

-- | The symbol participates in linkage and can be used to resolve external
--   symbol references.
ExternallyVisible :: LlvmLinkageType

-- | Alias for <a>ExternallyVisible</a> but with explicit textual form in
--   LLVM assembly.
External :: LlvmLinkageType

-- | Symbol is private to the module and should not appear in the symbol
--   table
Private :: LlvmLinkageType

-- | Llvm binary operators machine operations.
data LlvmMachOp

-- | add two integer, floating point or vector values.
LM_MO_Add :: LlvmMachOp

-- | subtract two ...
LM_MO_Sub :: LlvmMachOp

-- | multiply ..
LM_MO_Mul :: LlvmMachOp

-- | unsigned integer or vector division.
LM_MO_UDiv :: LlvmMachOp

-- | signed integer ..
LM_MO_SDiv :: LlvmMachOp

-- | unsigned integer or vector remainder (mod)
LM_MO_URem :: LlvmMachOp

-- | signed ...
LM_MO_SRem :: LlvmMachOp

-- | add two floating point or vector values.
LM_MO_FAdd :: LlvmMachOp

-- | subtract two ...
LM_MO_FSub :: LlvmMachOp

-- | multiply ...
LM_MO_FMul :: LlvmMachOp

-- | divide ...
LM_MO_FDiv :: LlvmMachOp

-- | remainder ...
LM_MO_FRem :: LlvmMachOp

-- | Left shift
LM_MO_Shl :: LlvmMachOp

-- | Logical shift right Shift right, filling with zero
LM_MO_LShr :: LlvmMachOp

-- | Arithmetic shift right The most significant bits of the result will be
--   equal to the sign bit of the left operand.
LM_MO_AShr :: LlvmMachOp

-- | AND bitwise logical operation.
LM_MO_And :: LlvmMachOp

-- | OR bitwise logical operation.
LM_MO_Or :: LlvmMachOp

-- | XOR bitwise logical operation.
LM_MO_Xor :: LlvmMachOp

-- | Llvm compare operations.
data LlvmCmpOp

-- | Equal (Signed and Unsigned)
LM_CMP_Eq :: LlvmCmpOp

-- | Not equal (Signed and Unsigned)
LM_CMP_Ne :: LlvmCmpOp

-- | Unsigned greater than
LM_CMP_Ugt :: LlvmCmpOp

-- | Unsigned greater than or equal
LM_CMP_Uge :: LlvmCmpOp

-- | Unsigned less than
LM_CMP_Ult :: LlvmCmpOp

-- | Unsigned less than or equal
LM_CMP_Ule :: LlvmCmpOp

-- | Signed greater than
LM_CMP_Sgt :: LlvmCmpOp

-- | Signed greater than or equal
LM_CMP_Sge :: LlvmCmpOp

-- | Signed less than
LM_CMP_Slt :: LlvmCmpOp

-- | Signed less than or equal
LM_CMP_Sle :: LlvmCmpOp

-- | Float equal
LM_CMP_Feq :: LlvmCmpOp

-- | Float not equal
LM_CMP_Fne :: LlvmCmpOp

-- | Float greater than
LM_CMP_Fgt :: LlvmCmpOp

-- | Float greater than or equal
LM_CMP_Fge :: LlvmCmpOp

-- | Float less than
LM_CMP_Flt :: LlvmCmpOp

-- | Float less than or equal
LM_CMP_Fle :: LlvmCmpOp

-- | Llvm cast operations.
data LlvmCastOp

-- | Integer truncate
LM_Trunc :: LlvmCastOp

-- | Integer extend (zero fill)
LM_Zext :: LlvmCastOp

-- | Integer extend (sign fill)
LM_Sext :: LlvmCastOp

-- | Float truncate
LM_Fptrunc :: LlvmCastOp

-- | Float extend
LM_Fpext :: LlvmCastOp

-- | Float to unsigned Integer
LM_Fptoui :: LlvmCastOp

-- | Float to signed Integer
LM_Fptosi :: LlvmCastOp

-- | Unsigned Integer to Float
LM_Uitofp :: LlvmCastOp

-- | Signed Int to Float
LM_Sitofp :: LlvmCastOp

-- | Pointer to Integer
LM_Ptrtoint :: LlvmCastOp

-- | Integer to Pointer
LM_Inttoptr :: LlvmCastOp

-- | Cast between types where no bit manipulation is needed
LM_Bitcast :: LlvmCastOp

-- | Convert a Haskell Double to an LLVM hex encoded floating point form.
--   In Llvm float literals can be printed in a big-endian hexadecimal
--   format, regardless of underlying architecture.
--   
--   See Note [LLVM Float Types].
ppDouble :: Platform -> Double -> SDoc
narrowFp :: Double -> Float
widenFp :: Float -> Double
ppFloat :: Platform -> Float -> SDoc
ppCommaJoin :: Outputable a => [a] -> SDoc
ppSpaceJoin :: Outputable a => [a] -> SDoc
instance GHC.Classes.Eq GHC.Llvm.Types.LMConst
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmParamAttr
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmFuncAttr
instance GHC.Show.Show GHC.Llvm.Types.LlvmCallType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmCallType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmCallConvention
instance GHC.Show.Show GHC.Llvm.Types.LlvmParameterListType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmParameterListType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmLinkageType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmFunctionDecl
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmLit
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmVar
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmMachOp
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmCmpOp
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmCastOp
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmCastOp
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmCmpOp
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmMachOp
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmType
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmFunctionDecl
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmLinkageType
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmCallConvention
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmFuncAttr
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmParamAttr

module GHC.Llvm.MetaData

-- | A reference to an un-named metadata node.
newtype MetaId
MetaId :: Int -> MetaId

-- | LLVM metadata expressions
data MetaExpr
MetaStr :: !LMString -> MetaExpr
MetaNode :: !MetaId -> MetaExpr
MetaVar :: !LlvmVar -> MetaExpr
MetaStruct :: [MetaExpr] -> MetaExpr

-- | Associates some metadata with a specific label for attaching to an
--   instruction.
data MetaAnnot
MetaAnnot :: LMString -> MetaExpr -> MetaAnnot

-- | Metadata declarations. Metadata can only be declared in global scope.
data MetaDecl

-- | Named metadata. Only used for communicating module information to
--   LLVM. ('!name = !{ [!&lt;n&gt;] }' form).
MetaNamed :: !LMString -> [MetaId] -> MetaDecl

-- | Metadata node declaration. ('!0 = metadata !{ &lt;metadata
--   expression&gt; }' form).
MetaUnnamed :: !MetaId -> !MetaExpr -> MetaDecl
instance GHC.Enum.Enum GHC.Llvm.MetaData.MetaId
instance GHC.Classes.Ord GHC.Llvm.MetaData.MetaId
instance GHC.Classes.Eq GHC.Llvm.MetaData.MetaId
instance GHC.Classes.Eq GHC.Llvm.MetaData.MetaExpr
instance GHC.Classes.Eq GHC.Llvm.MetaData.MetaAnnot
instance GHC.Utils.Outputable.Outputable GHC.Llvm.MetaData.MetaId


-- | The LLVM abstract syntax.
module GHC.Llvm.Syntax

-- | Block labels
type LlvmBlockId = Unique

-- | A block of LLVM code.
data LlvmBlock
LlvmBlock :: LlvmBlockId -> [LlvmStatement] -> LlvmBlock

-- | The code label for this block
[blockLabel] :: LlvmBlock -> LlvmBlockId

-- | A list of LlvmStatement's representing the code for this block. This
--   list must end with a control flow statement.
[blockStmts] :: LlvmBlock -> [LlvmStatement]
type LlvmBlocks = [LlvmBlock]

-- | An LLVM Module. This is a top level container in LLVM.
data LlvmModule
LlvmModule :: [LMString] -> [LlvmAlias] -> [MetaDecl] -> [LMGlobal] -> LlvmFunctionDecls -> LlvmFunctions -> LlvmModule

-- | Comments to include at the start of the module.
[modComments] :: LlvmModule -> [LMString]

-- | LLVM Alias type definitions.
[modAliases] :: LlvmModule -> [LlvmAlias]

-- | LLVM meta data.
[modMeta] :: LlvmModule -> [MetaDecl]

-- | Global variables to include in the module.
[modGlobals] :: LlvmModule -> [LMGlobal]

-- | LLVM Functions used in this module but defined in other modules.
[modFwdDecls] :: LlvmModule -> LlvmFunctionDecls

-- | LLVM Functions defined in this module.
[modFuncs] :: LlvmModule -> LlvmFunctions

-- | An LLVM Function
data LlvmFunction
LlvmFunction :: LlvmFunctionDecl -> [LMString] -> [LlvmFuncAttr] -> LMSection -> Maybe LlvmStatic -> LlvmBlocks -> LlvmFunction

-- | The signature of this declared function.
[funcDecl] :: LlvmFunction -> LlvmFunctionDecl

-- | The functions arguments
[funcArgs] :: LlvmFunction -> [LMString]

-- | The function attributes.
[funcAttrs] :: LlvmFunction -> [LlvmFuncAttr]

-- | The section to put the function into,
[funcSect] :: LlvmFunction -> LMSection

-- | Prefix data
[funcPrefix] :: LlvmFunction -> Maybe LlvmStatic

-- | The body of the functions.
[funcBody] :: LlvmFunction -> LlvmBlocks
type LlvmFunctions = [LlvmFunction]
type SingleThreaded = Bool

-- | LLVM ordering types for synchronization purposes. (Introduced in LLVM
--   3.0). Please see the LLVM documentation for a better description.
data LlvmSyncOrdering

-- | Some partial order of operations exists.
SyncUnord :: LlvmSyncOrdering

-- | A single total order for operations at a single address exists.
SyncMonotonic :: LlvmSyncOrdering

-- | Acquire synchronization operation.
SyncAcquire :: LlvmSyncOrdering

-- | Release synchronization operation.
SyncRelease :: LlvmSyncOrdering

-- | Acquire + Release synchronization operation.
SyncAcqRel :: LlvmSyncOrdering

-- | Full sequential Consistency operation.
SyncSeqCst :: LlvmSyncOrdering

-- | LLVM atomic operations. Please see the <tt>atomicrmw</tt> instruction
--   in the LLVM documentation for a complete description.
data LlvmAtomicOp
LAO_Xchg :: LlvmAtomicOp
LAO_Add :: LlvmAtomicOp
LAO_Sub :: LlvmAtomicOp
LAO_And :: LlvmAtomicOp
LAO_Nand :: LlvmAtomicOp
LAO_Or :: LlvmAtomicOp
LAO_Xor :: LlvmAtomicOp
LAO_Max :: LlvmAtomicOp
LAO_Min :: LlvmAtomicOp
LAO_Umax :: LlvmAtomicOp
LAO_Umin :: LlvmAtomicOp

-- | Llvm Statements
data LlvmStatement

-- | Assign an expression to a variable: * dest: Variable to assign to *
--   source: Source expression
Assignment :: LlvmVar -> LlvmExpression -> LlvmStatement

-- | Memory fence operation
Fence :: Bool -> LlvmSyncOrdering -> LlvmStatement

-- | Always branch to the target label
Branch :: LlvmVar -> LlvmStatement

-- | Branch to label targetTrue if cond is true otherwise to label
--   targetFalse * cond: condition that will be tested, must be of type i1
--   * targetTrue: label to branch to if cond is true * targetFalse: label
--   to branch to if cond is false
BranchIf :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmStatement

-- | Comment Plain comment.
Comment :: [LMString] -> LlvmStatement

-- | Set a label on this position. * name: Identifier of this label, unique
--   for this module
MkLabel :: LlvmBlockId -> LlvmStatement

-- | Store variable value in pointer ptr. If value is of type t then ptr
--   must be of type t*. * value: Variable/Constant to store. * ptr:
--   Location to store the value in
Store :: LlvmVar -> LlvmVar -> LMAlign -> LlvmStatement

-- | Multiway branch * scrutinee: Variable or constant which must be of
--   integer type that is determines which arm is chosen. * def: The
--   default label if there is no match in target. * target: A list of
--   (value,label) where the value is an integer constant and label the
--   corresponding label to jump to if the scrutinee matches the value.
Switch :: LlvmVar -> LlvmVar -> [(LlvmVar, LlvmVar)] -> LlvmStatement

-- | Return a result. * result: The variable or constant to return
Return :: Maybe LlvmVar -> LlvmStatement

-- | An instruction for the optimizer that the code following is not
--   reachable
Unreachable :: LlvmStatement

-- | Raise an expression to a statement (if don't want result or want to
--   use Llvm unnamed values.
Expr :: LlvmExpression -> LlvmStatement

-- | A nop LLVM statement. Useful as its often more efficient to use this
--   then to wrap LLvmStatement in a Just or [].
Nop :: LlvmStatement

-- | A LLVM statement with metadata attached to it.
MetaStmt :: [MetaAnnot] -> LlvmStatement -> LlvmStatement

-- | Llvm Expressions
data LlvmExpression

-- | Allocate amount * sizeof(tp) bytes on the stack * tp: LlvmType to
--   reserve room for * amount: The nr of tp's which must be allocated
Alloca :: LlvmType -> Int -> LlvmExpression

-- | Perform the machine operator op on the operands left and right * op:
--   operator * left: left operand * right: right operand
LlvmOp :: LlvmMachOp -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Perform a compare operation on the operands left and right * op:
--   operator * left: left operand * right: right operand
Compare :: LlvmCmpOp -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Extract a scalar element from a vector * val: The vector * idx: The
--   index of the scalar within the vector
Extract :: LlvmVar -> LlvmVar -> LlvmExpression

-- | Extract a scalar element from a structure * val: The structure * idx:
--   The index of the scalar within the structure Corresponds to
--   "extractvalue" instruction.
ExtractV :: LlvmVar -> Int -> LlvmExpression

-- | Insert a scalar element into a vector * val: The source vector * elt:
--   The scalar to insert * index: The index at which to insert the scalar
Insert :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Allocate amount * sizeof(tp) bytes on the heap * tp: LlvmType to
--   reserve room for * amount: The nr of tp's which must be allocated
Malloc :: LlvmType -> Int -> LlvmExpression

-- | Load the value at location ptr
Load :: LlvmVar -> LMAlign -> LlvmExpression

-- | Atomic load of the value at location ptr
ALoad :: LlvmSyncOrdering -> SingleThreaded -> LlvmVar -> LlvmExpression

-- | Navigate in a structure, selecting elements * inbound: Is the pointer
--   inbounds? (computed pointer doesn't overflow) * ptr: Location of the
--   structure * indexes: A list of indexes to select the correct value.
GetElemPtr :: Bool -> LlvmVar -> [LlvmVar] -> LlvmExpression

-- | Cast the variable from to the to type. This is an abstraction of three
--   cast operators in Llvm, inttoptr, ptrtoint and bitcast. * cast: Cast
--   type * from: Variable to cast * to: type to cast to
Cast :: LlvmCastOp -> LlvmVar -> LlvmType -> LlvmExpression

-- | Atomic read-modify-write operation * op: Atomic operation * addr:
--   Address to modify * operand: Operand to operation * ordering: Ordering
--   requirement
AtomicRMW :: LlvmAtomicOp -> LlvmVar -> LlvmVar -> LlvmSyncOrdering -> LlvmExpression

-- | Compare-and-exchange operation * addr: Address to modify * old:
--   Expected value * new: New value * suc_ord: Ordering required in
--   success case * fail_ord: Ordering required in failure case, can be no
--   stronger than suc_ord
--   
--   Result is an <tt>i1</tt>, true if store was successful.
CmpXChg :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmSyncOrdering -> LlvmSyncOrdering -> LlvmExpression

-- | Call a function. The result is the value of the expression. *
--   tailJumps: CallType to signal if the function should be tail called *
--   fnptrval: An LLVM value containing a pointer to a function to be
--   invoked. Can be indirect. Should be LMFunction type. * args: Concrete
--   arguments for the parameters * attrs: A list of function attributes
--   for the call. Only NoReturn, NoUnwind, ReadOnly and ReadNone are valid
--   here.
Call :: LlvmCallType -> LlvmVar -> [LlvmVar] -> [LlvmFuncAttr] -> LlvmExpression

-- | Call a function as above but potentially taking metadata as arguments.
--   * tailJumps: CallType to signal if the function should be tail called
--   * fnptrval: An LLVM value containing a pointer to a function to be
--   invoked. Can be indirect. Should be LMFunction type. * args: Arguments
--   that may include metadata. * attrs: A list of function attributes for
--   the call. Only NoReturn, NoUnwind, ReadOnly and ReadNone are valid
--   here.
CallM :: LlvmCallType -> LlvmVar -> [MetaExpr] -> [LlvmFuncAttr] -> LlvmExpression

-- | Merge variables from different basic blocks which are predecessors of
--   this basic block in a new variable of type tp. * tp: type of the
--   merged variable, must match the types of the predecessor variables. *
--   predecessors: A list of variables and the basic block that they
--   originate from.
Phi :: LlvmType -> [(LlvmVar, LlvmVar)] -> LlvmExpression

-- | Inline assembly expression. Syntax is very similar to the style used
--   by GCC. * assembly: Actual inline assembly code. * constraints:
--   Operand constraints. * return ty: Return type of function. * vars: Any
--   variables involved in the assembly code. * sideeffect: Does the
--   expression have side effects not visible from the constraints list. *
--   alignstack: Should the stack be conservatively aligned before this
--   expression is executed.
Asm :: LMString -> LMString -> LlvmType -> [LlvmVar] -> Bool -> Bool -> LlvmExpression

-- | A LLVM expression with metadata attached to it.
MExpr :: [MetaAnnot] -> LlvmExpression -> LlvmExpression
instance GHC.Classes.Eq GHC.Llvm.Syntax.LlvmSyncOrdering
instance GHC.Show.Show GHC.Llvm.Syntax.LlvmSyncOrdering
instance GHC.Classes.Eq GHC.Llvm.Syntax.LlvmAtomicOp
instance GHC.Show.Show GHC.Llvm.Syntax.LlvmAtomicOp
instance GHC.Classes.Eq GHC.Llvm.Syntax.LlvmExpression
instance GHC.Classes.Eq GHC.Llvm.Syntax.LlvmStatement


-- | Pretty print LLVM IR Code.
module GHC.Llvm.Ppr

-- | Print out a whole LLVM module.
ppLlvmModule :: LlvmOpts -> LlvmModule -> SDoc

-- | Print out a multi-line comment, can be inside a function or on its own
ppLlvmComments :: [LMString] -> SDoc

-- | Print out a comment, can be inside a function or on its own
ppLlvmComment :: LMString -> SDoc

-- | Print out a list of global mutable variable definitions
ppLlvmGlobals :: LlvmOpts -> [LMGlobal] -> SDoc

-- | Print out a global mutable variable definition
ppLlvmGlobal :: LlvmOpts -> LMGlobal -> SDoc

-- | Print out a list of LLVM type aliases.
ppLlvmAliases :: [LlvmAlias] -> SDoc

-- | Print out an LLVM type alias.
ppLlvmAlias :: LlvmAlias -> SDoc

-- | Print out a list of LLVM metadata.
ppLlvmMetas :: LlvmOpts -> [MetaDecl] -> SDoc

-- | Print out an LLVM metadata definition.
ppLlvmMeta :: LlvmOpts -> MetaDecl -> SDoc

-- | Print out a list of function declaration.
ppLlvmFunctionDecls :: LlvmFunctionDecls -> SDoc

-- | Print out a function declaration. Declarations define the function
--   type but don't define the actual body of the function.
ppLlvmFunctionDecl :: LlvmFunctionDecl -> SDoc

-- | Print out a list of function definitions.
ppLlvmFunctions :: LlvmOpts -> LlvmFunctions -> SDoc

-- | Print out a function definition.
ppLlvmFunction :: LlvmOpts -> LlvmFunction -> SDoc
ppVar :: LlvmOpts -> LlvmVar -> SDoc

-- | Print a literal value. No type.
ppLit :: LlvmOpts -> LlvmLit -> SDoc
ppTypeLit :: LlvmOpts -> LlvmLit -> SDoc

-- | Return the variable name or value of the <a>LlvmVar</a> in Llvm IR
--   textual representation (e.g. <tt>@x</tt>, <tt>%y</tt> or <tt>42</tt>).
ppName :: LlvmOpts -> LlvmVar -> SDoc

-- | Return the variable name or value of the <a>LlvmVar</a> in a plain
--   textual representation (e.g. <tt>x</tt>, <tt>y</tt> or <tt>42</tt>).
ppPlainName :: LlvmOpts -> LlvmVar -> SDoc


-- | This module supplies bindings to generate Llvm IR from Haskell
--   (<a>http://www.llvm.org/docs/LangRef.html</a>).
--   
--   Note: this module is developed in a demand driven way. It is no
--   complete LLVM binding library in Haskell, but enough to generate code
--   for GHC.
--   
--   This code is derived from code taken from the Essential Haskell
--   Compiler (EHC) project.
module GHC.Llvm

-- | LLVM code generator options
data LlvmOpts
LlvmOpts :: !Platform -> !Bool -> !Bool -> LlvmOpts

-- | Target platform
[llvmOptsPlatform] :: LlvmOpts -> !Platform

-- | Fill undefined literals with garbage values
[llvmOptsFillUndefWithGarbage] :: LlvmOpts -> !Bool

-- | Split sections
[llvmOptsSplitSections] :: LlvmOpts -> !Bool

-- | Get LlvmOptions from DynFlags
initLlvmOpts :: DynFlags -> LlvmOpts

-- | An LLVM Module. This is a top level container in LLVM.
data LlvmModule
LlvmModule :: [LMString] -> [LlvmAlias] -> [MetaDecl] -> [LMGlobal] -> LlvmFunctionDecls -> LlvmFunctions -> LlvmModule

-- | Comments to include at the start of the module.
[modComments] :: LlvmModule -> [LMString]

-- | LLVM Alias type definitions.
[modAliases] :: LlvmModule -> [LlvmAlias]

-- | LLVM meta data.
[modMeta] :: LlvmModule -> [MetaDecl]

-- | Global variables to include in the module.
[modGlobals] :: LlvmModule -> [LMGlobal]

-- | LLVM Functions used in this module but defined in other modules.
[modFwdDecls] :: LlvmModule -> LlvmFunctionDecls

-- | LLVM Functions defined in this module.
[modFuncs] :: LlvmModule -> LlvmFunctions

-- | An LLVM Function
data LlvmFunction
LlvmFunction :: LlvmFunctionDecl -> [LMString] -> [LlvmFuncAttr] -> LMSection -> Maybe LlvmStatic -> LlvmBlocks -> LlvmFunction

-- | The signature of this declared function.
[funcDecl] :: LlvmFunction -> LlvmFunctionDecl

-- | The functions arguments
[funcArgs] :: LlvmFunction -> [LMString]

-- | The function attributes.
[funcAttrs] :: LlvmFunction -> [LlvmFuncAttr]

-- | The section to put the function into,
[funcSect] :: LlvmFunction -> LMSection

-- | Prefix data
[funcPrefix] :: LlvmFunction -> Maybe LlvmStatic

-- | The body of the functions.
[funcBody] :: LlvmFunction -> LlvmBlocks

-- | An LLVM Function
data LlvmFunctionDecl
LlvmFunctionDecl :: LMString -> LlvmLinkageType -> LlvmCallConvention -> LlvmType -> LlvmParameterListType -> [LlvmParameter] -> LMAlign -> LlvmFunctionDecl

-- | Unique identifier of the function
[decName] :: LlvmFunctionDecl -> LMString

-- | LinkageType of the function
[funcLinkage] :: LlvmFunctionDecl -> LlvmLinkageType

-- | The calling convention of the function
[funcCc] :: LlvmFunctionDecl -> LlvmCallConvention

-- | Type of the returned value
[decReturnType] :: LlvmFunctionDecl -> LlvmType

-- | Indicates if this function uses varargs
[decVarargs] :: LlvmFunctionDecl -> LlvmParameterListType

-- | Parameter types and attributes
[decParams] :: LlvmFunctionDecl -> [LlvmParameter]

-- | Function align value, must be power of 2
[funcAlign] :: LlvmFunctionDecl -> LMAlign
type LlvmFunctions = [LlvmFunction]
type LlvmFunctionDecls = [LlvmFunctionDecl]

-- | Llvm Statements
data LlvmStatement

-- | Assign an expression to a variable: * dest: Variable to assign to *
--   source: Source expression
Assignment :: LlvmVar -> LlvmExpression -> LlvmStatement

-- | Memory fence operation
Fence :: Bool -> LlvmSyncOrdering -> LlvmStatement

-- | Always branch to the target label
Branch :: LlvmVar -> LlvmStatement

-- | Branch to label targetTrue if cond is true otherwise to label
--   targetFalse * cond: condition that will be tested, must be of type i1
--   * targetTrue: label to branch to if cond is true * targetFalse: label
--   to branch to if cond is false
BranchIf :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmStatement

-- | Comment Plain comment.
Comment :: [LMString] -> LlvmStatement

-- | Set a label on this position. * name: Identifier of this label, unique
--   for this module
MkLabel :: LlvmBlockId -> LlvmStatement

-- | Store variable value in pointer ptr. If value is of type t then ptr
--   must be of type t*. * value: Variable/Constant to store. * ptr:
--   Location to store the value in
Store :: LlvmVar -> LlvmVar -> LMAlign -> LlvmStatement

-- | Multiway branch * scrutinee: Variable or constant which must be of
--   integer type that is determines which arm is chosen. * def: The
--   default label if there is no match in target. * target: A list of
--   (value,label) where the value is an integer constant and label the
--   corresponding label to jump to if the scrutinee matches the value.
Switch :: LlvmVar -> LlvmVar -> [(LlvmVar, LlvmVar)] -> LlvmStatement

-- | Return a result. * result: The variable or constant to return
Return :: Maybe LlvmVar -> LlvmStatement

-- | An instruction for the optimizer that the code following is not
--   reachable
Unreachable :: LlvmStatement

-- | Raise an expression to a statement (if don't want result or want to
--   use Llvm unnamed values.
Expr :: LlvmExpression -> LlvmStatement

-- | A nop LLVM statement. Useful as its often more efficient to use this
--   then to wrap LLvmStatement in a Just or [].
Nop :: LlvmStatement

-- | A LLVM statement with metadata attached to it.
MetaStmt :: [MetaAnnot] -> LlvmStatement -> LlvmStatement

-- | Llvm Expressions
data LlvmExpression

-- | Allocate amount * sizeof(tp) bytes on the stack * tp: LlvmType to
--   reserve room for * amount: The nr of tp's which must be allocated
Alloca :: LlvmType -> Int -> LlvmExpression

-- | Perform the machine operator op on the operands left and right * op:
--   operator * left: left operand * right: right operand
LlvmOp :: LlvmMachOp -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Perform a compare operation on the operands left and right * op:
--   operator * left: left operand * right: right operand
Compare :: LlvmCmpOp -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Extract a scalar element from a vector * val: The vector * idx: The
--   index of the scalar within the vector
Extract :: LlvmVar -> LlvmVar -> LlvmExpression

-- | Extract a scalar element from a structure * val: The structure * idx:
--   The index of the scalar within the structure Corresponds to
--   "extractvalue" instruction.
ExtractV :: LlvmVar -> Int -> LlvmExpression

-- | Insert a scalar element into a vector * val: The source vector * elt:
--   The scalar to insert * index: The index at which to insert the scalar
Insert :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Allocate amount * sizeof(tp) bytes on the heap * tp: LlvmType to
--   reserve room for * amount: The nr of tp's which must be allocated
Malloc :: LlvmType -> Int -> LlvmExpression

-- | Load the value at location ptr
Load :: LlvmVar -> LMAlign -> LlvmExpression

-- | Atomic load of the value at location ptr
ALoad :: LlvmSyncOrdering -> SingleThreaded -> LlvmVar -> LlvmExpression

-- | Navigate in a structure, selecting elements * inbound: Is the pointer
--   inbounds? (computed pointer doesn't overflow) * ptr: Location of the
--   structure * indexes: A list of indexes to select the correct value.
GetElemPtr :: Bool -> LlvmVar -> [LlvmVar] -> LlvmExpression

-- | Cast the variable from to the to type. This is an abstraction of three
--   cast operators in Llvm, inttoptr, ptrtoint and bitcast. * cast: Cast
--   type * from: Variable to cast * to: type to cast to
Cast :: LlvmCastOp -> LlvmVar -> LlvmType -> LlvmExpression

-- | Atomic read-modify-write operation * op: Atomic operation * addr:
--   Address to modify * operand: Operand to operation * ordering: Ordering
--   requirement
AtomicRMW :: LlvmAtomicOp -> LlvmVar -> LlvmVar -> LlvmSyncOrdering -> LlvmExpression

-- | Compare-and-exchange operation * addr: Address to modify * old:
--   Expected value * new: New value * suc_ord: Ordering required in
--   success case * fail_ord: Ordering required in failure case, can be no
--   stronger than suc_ord
--   
--   Result is an <tt>i1</tt>, true if store was successful.
CmpXChg :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmSyncOrdering -> LlvmSyncOrdering -> LlvmExpression

-- | Call a function. The result is the value of the expression. *
--   tailJumps: CallType to signal if the function should be tail called *
--   fnptrval: An LLVM value containing a pointer to a function to be
--   invoked. Can be indirect. Should be LMFunction type. * args: Concrete
--   arguments for the parameters * attrs: A list of function attributes
--   for the call. Only NoReturn, NoUnwind, ReadOnly and ReadNone are valid
--   here.
Call :: LlvmCallType -> LlvmVar -> [LlvmVar] -> [LlvmFuncAttr] -> LlvmExpression

-- | Call a function as above but potentially taking metadata as arguments.
--   * tailJumps: CallType to signal if the function should be tail called
--   * fnptrval: An LLVM value containing a pointer to a function to be
--   invoked. Can be indirect. Should be LMFunction type. * args: Arguments
--   that may include metadata. * attrs: A list of function attributes for
--   the call. Only NoReturn, NoUnwind, ReadOnly and ReadNone are valid
--   here.
CallM :: LlvmCallType -> LlvmVar -> [MetaExpr] -> [LlvmFuncAttr] -> LlvmExpression

-- | Merge variables from different basic blocks which are predecessors of
--   this basic block in a new variable of type tp. * tp: type of the
--   merged variable, must match the types of the predecessor variables. *
--   predecessors: A list of variables and the basic block that they
--   originate from.
Phi :: LlvmType -> [(LlvmVar, LlvmVar)] -> LlvmExpression

-- | Inline assembly expression. Syntax is very similar to the style used
--   by GCC. * assembly: Actual inline assembly code. * constraints:
--   Operand constraints. * return ty: Return type of function. * vars: Any
--   variables involved in the assembly code. * sideeffect: Does the
--   expression have side effects not visible from the constraints list. *
--   alignstack: Should the stack be conservatively aligned before this
--   expression is executed.
Asm :: LMString -> LMString -> LlvmType -> [LlvmVar] -> Bool -> Bool -> LlvmExpression

-- | A LLVM expression with metadata attached to it.
MExpr :: [MetaAnnot] -> LlvmExpression -> LlvmExpression
type LlvmBlocks = [LlvmBlock]

-- | A block of LLVM code.
data LlvmBlock
LlvmBlock :: LlvmBlockId -> [LlvmStatement] -> LlvmBlock

-- | The code label for this block
[blockLabel] :: LlvmBlock -> LlvmBlockId

-- | A list of LlvmStatement's representing the code for this block. This
--   list must end with a control flow statement.
[blockStmts] :: LlvmBlock -> [LlvmStatement]

-- | Block labels
type LlvmBlockId = Unique

-- | LLVM Parameter Attributes.
--   
--   Parameter attributes are used to communicate additional information
--   about the result or parameters of a function
data LlvmParamAttr

-- | This indicates to the code generator that the parameter or return
--   value should be zero-extended to a 32-bit value by the caller (for a
--   parameter) or the callee (for a return value).
ZeroExt :: LlvmParamAttr

-- | This indicates to the code generator that the parameter or return
--   value should be sign-extended to a 32-bit value by the caller (for a
--   parameter) or the callee (for a return value).
SignExt :: LlvmParamAttr

-- | This indicates that this parameter or return value should be treated
--   in a special target-dependent fashion during while emitting code for a
--   function call or return (usually, by putting it in a register as
--   opposed to memory).
InReg :: LlvmParamAttr

-- | This indicates that the pointer parameter should really be passed by
--   value to the function.
ByVal :: LlvmParamAttr

-- | This indicates that the pointer parameter specifies the address of a
--   structure that is the return value of the function in the source
--   program.
SRet :: LlvmParamAttr

-- | This indicates that the pointer does not alias any global or any other
--   parameter.
NoAlias :: LlvmParamAttr

-- | This indicates that the callee does not make any copies of the pointer
--   that outlive the callee itself
NoCapture :: LlvmParamAttr

-- | This indicates that the pointer parameter can be excised using the
--   trampoline intrinsics.
Nest :: LlvmParamAttr
type LlvmParameter = (LlvmType, [LlvmParamAttr])

-- | LLVM atomic operations. Please see the <tt>atomicrmw</tt> instruction
--   in the LLVM documentation for a complete description.
data LlvmAtomicOp
LAO_Xchg :: LlvmAtomicOp
LAO_Add :: LlvmAtomicOp
LAO_Sub :: LlvmAtomicOp
LAO_And :: LlvmAtomicOp
LAO_Nand :: LlvmAtomicOp
LAO_Or :: LlvmAtomicOp
LAO_Xor :: LlvmAtomicOp
LAO_Max :: LlvmAtomicOp
LAO_Min :: LlvmAtomicOp
LAO_Umax :: LlvmAtomicOp
LAO_Umin :: LlvmAtomicOp

-- | LLVM ordering types for synchronization purposes. (Introduced in LLVM
--   3.0). Please see the LLVM documentation for a better description.
data LlvmSyncOrdering

-- | Some partial order of operations exists.
SyncUnord :: LlvmSyncOrdering

-- | A single total order for operations at a single address exists.
SyncMonotonic :: LlvmSyncOrdering

-- | Acquire synchronization operation.
SyncAcquire :: LlvmSyncOrdering

-- | Release synchronization operation.
SyncRelease :: LlvmSyncOrdering

-- | Acquire + Release synchronization operation.
SyncAcqRel :: LlvmSyncOrdering

-- | Full sequential Consistency operation.
SyncSeqCst :: LlvmSyncOrdering

-- | Different calling conventions a function can use.
data LlvmCallConvention

-- | The C calling convention. This calling convention (the default if no
--   other calling convention is specified) matches the target C calling
--   conventions. This calling convention supports varargs function calls
--   and tolerates some mismatch in the declared prototype and implemented
--   declaration of the function (as does normal C).
CC_Ccc :: LlvmCallConvention

-- | This calling convention attempts to make calls as fast as possible
--   (e.g. by passing things in registers). This calling convention allows
--   the target to use whatever tricks it wants to produce fast code for
--   the target, without having to conform to an externally specified ABI
--   (Application Binary Interface). Implementations of this convention
--   should allow arbitrary tail call optimization to be supported. This
--   calling convention does not support varargs and requires the prototype
--   of al callees to exactly match the prototype of the function
--   definition.
CC_Fastcc :: LlvmCallConvention

-- | This calling convention attempts to make code in the caller as
--   efficient as possible under the assumption that the call is not
--   commonly executed. As such, these calls often preserve all registers
--   so that the call does not break any live ranges in the caller side.
--   This calling convention does not support varargs and requires the
--   prototype of all callees to exactly match the prototype of the
--   function definition.
CC_Coldcc :: LlvmCallConvention

-- | The GHC-specific <tt>registerised</tt> calling convention.
CC_Ghc :: LlvmCallConvention

-- | Any calling convention may be specified by number, allowing
--   target-specific calling conventions to be used. Target specific
--   calling conventions start at 64.
CC_Ncc :: Int -> LlvmCallConvention

-- | X86 Specific <a>StdCall</a> convention. LLVM includes a specific alias
--   for it rather than just using CC_Ncc.
CC_X86_Stdcc :: LlvmCallConvention

-- | Different types to call a function.
data LlvmCallType

-- | Normal call, allocate a new stack frame.
StdCall :: LlvmCallType

-- | Tail call, perform the call in the current stack frame.
TailCall :: LlvmCallType

-- | Functions can have a fixed amount of parameters, or a variable amount.
data LlvmParameterListType
FixedArgs :: LlvmParameterListType
VarArgs :: LlvmParameterListType

-- | Linkage type of a symbol.
--   
--   The description of the constructors is copied from the Llvm Assembly
--   Language Reference Manual
--   <a>http://www.llvm.org/docs/LangRef.html#linkage</a>, because they
--   correspond to the Llvm linkage types.
data LlvmLinkageType

-- | Global values with internal linkage are only directly accessible by
--   objects in the current module. In particular, linking code into a
--   module with an internal global value may cause the internal to be
--   renamed as necessary to avoid collisions. Because the symbol is
--   internal to the module, all references can be updated. This
--   corresponds to the notion of the <tt>static</tt> keyword in C.
Internal :: LlvmLinkageType

-- | Globals with <tt>linkonce</tt> linkage are merged with other globals
--   of the same name when linkage occurs. This is typically used to
--   implement inline functions, templates, or other code which must be
--   generated in each translation unit that uses it. Unreferenced linkonce
--   globals are allowed to be discarded.
LinkOnce :: LlvmLinkageType

-- | <tt>weak</tt> linkage is exactly the same as linkonce linkage, except
--   that unreferenced weak globals may not be discarded. This is used for
--   globals that may be emitted in multiple translation units, but that
--   are not guaranteed to be emitted into every translation unit that uses
--   them. One example of this are common globals in C, such as <tt>int
--   X;</tt> at global scope.
Weak :: LlvmLinkageType

-- | <tt>appending</tt> linkage may only be applied to global variables of
--   pointer to array type. When two global variables with appending
--   linkage are linked together, the two global arrays are appended
--   together. This is the Llvm, typesafe, equivalent of having the system
--   linker append together <tt>sections</tt> with identical names when .o
--   files are linked.
Appending :: LlvmLinkageType

-- | The semantics of this linkage follow the ELF model: the symbol is weak
--   until linked, if not linked, the symbol becomes null instead of being
--   an undefined reference.
ExternWeak :: LlvmLinkageType

-- | The symbol participates in linkage and can be used to resolve external
--   symbol references.
ExternallyVisible :: LlvmLinkageType

-- | Alias for <a>ExternallyVisible</a> but with explicit textual form in
--   LLVM assembly.
External :: LlvmLinkageType

-- | Symbol is private to the module and should not appear in the symbol
--   table
Private :: LlvmLinkageType

-- | Llvm Function Attributes.
--   
--   Function attributes are set to communicate additional information
--   about a function. Function attributes are considered to be part of the
--   function, not of the function type, so functions with different
--   parameter attributes can have the same function type. Functions can
--   have multiple attributes.
--   
--   Descriptions taken from
--   <a>http://llvm.org/docs/LangRef.html#fnattrs</a>
data LlvmFuncAttr

-- | This attribute indicates that the inliner should attempt to inline
--   this function into callers whenever possible, ignoring any active
--   inlining size threshold for this caller.
AlwaysInline :: LlvmFuncAttr

-- | This attribute indicates that the source code contained a hint that
--   inlining this function is desirable (such as the "inline" keyword in
--   C/C++). It is just a hint; it imposes no requirements on the inliner.
InlineHint :: LlvmFuncAttr

-- | This attribute indicates that the inliner should never inline this
--   function in any situation. This attribute may not be used together
--   with the alwaysinline attribute.
NoInline :: LlvmFuncAttr

-- | This attribute suggests that optimization passes and code generator
--   passes make choices that keep the code size of this function low, and
--   otherwise do optimizations specifically to reduce code size.
OptSize :: LlvmFuncAttr

-- | This function attribute indicates that the function never returns
--   normally. This produces undefined behavior at runtime if the function
--   ever does dynamically return.
NoReturn :: LlvmFuncAttr

-- | This function attribute indicates that the function never returns with
--   an unwind or exceptional control flow. If the function does unwind,
--   its runtime behavior is undefined.
NoUnwind :: LlvmFuncAttr

-- | This attribute indicates that the function computes its result (or
--   decides to unwind an exception) based strictly on its arguments,
--   without dereferencing any pointer arguments or otherwise accessing any
--   mutable state (e.g. memory, control registers, etc) visible to caller
--   functions. It does not write through any pointer arguments (including
--   byval arguments) and never changes any state visible to callers. This
--   means that it cannot unwind exceptions by calling the C++ exception
--   throwing methods, but could use the unwind instruction.
ReadNone :: LlvmFuncAttr

-- | This attribute indicates that the function does not write through any
--   pointer arguments (including byval arguments) or otherwise modify any
--   state (e.g. memory, control registers, etc) visible to caller
--   functions. It may dereference pointer arguments and read state that
--   may be set in the caller. A readonly function always returns the same
--   value (or unwinds an exception identically) when called with the same
--   set of arguments and global state. It cannot unwind an exception by
--   calling the C++ exception throwing methods, but may use the unwind
--   instruction.
ReadOnly :: LlvmFuncAttr

-- | This attribute indicates that the function should emit a stack
--   smashing protector. It is in the form of a "canary"âa random value
--   placed on the stack before the local variables that's checked upon
--   return from the function to see if it has been overwritten. A
--   heuristic is used to determine if a function needs stack protectors or
--   not.
--   
--   If a function that has an ssp attribute is inlined into a function
--   that doesn't have an ssp attribute, then the resulting function will
--   have an ssp attribute.
Ssp :: LlvmFuncAttr

-- | This attribute indicates that the function should always emit a stack
--   smashing protector. This overrides the ssp function attribute.
--   
--   If a function that has an sspreq attribute is inlined into a function
--   that doesn't have an sspreq attribute or which has an ssp attribute,
--   then the resulting function will have an sspreq attribute.
SspReq :: LlvmFuncAttr

-- | This attribute indicates that the code generator should not use a red
--   zone, even if the target-specific ABI normally permits it.
NoRedZone :: LlvmFuncAttr

-- | This attributes disables implicit floating point instructions.
NoImplicitFloat :: LlvmFuncAttr

-- | This attribute disables prologue / epilogue emission for the function.
--   This can have very system-specific consequences.
Naked :: LlvmFuncAttr

-- | Llvm compare operations.
data LlvmCmpOp

-- | Equal (Signed and Unsigned)
LM_CMP_Eq :: LlvmCmpOp

-- | Not equal (Signed and Unsigned)
LM_CMP_Ne :: LlvmCmpOp

-- | Unsigned greater than
LM_CMP_Ugt :: LlvmCmpOp

-- | Unsigned greater than or equal
LM_CMP_Uge :: LlvmCmpOp

-- | Unsigned less than
LM_CMP_Ult :: LlvmCmpOp

-- | Unsigned less than or equal
LM_CMP_Ule :: LlvmCmpOp

-- | Signed greater than
LM_CMP_Sgt :: LlvmCmpOp

-- | Signed greater than or equal
LM_CMP_Sge :: LlvmCmpOp

-- | Signed less than
LM_CMP_Slt :: LlvmCmpOp

-- | Signed less than or equal
LM_CMP_Sle :: LlvmCmpOp

-- | Float equal
LM_CMP_Feq :: LlvmCmpOp

-- | Float not equal
LM_CMP_Fne :: LlvmCmpOp

-- | Float greater than
LM_CMP_Fgt :: LlvmCmpOp

-- | Float greater than or equal
LM_CMP_Fge :: LlvmCmpOp

-- | Float less than
LM_CMP_Flt :: LlvmCmpOp

-- | Float less than or equal
LM_CMP_Fle :: LlvmCmpOp

-- | Llvm binary operators machine operations.
data LlvmMachOp

-- | add two integer, floating point or vector values.
LM_MO_Add :: LlvmMachOp

-- | subtract two ...
LM_MO_Sub :: LlvmMachOp

-- | multiply ..
LM_MO_Mul :: LlvmMachOp

-- | unsigned integer or vector division.
LM_MO_UDiv :: LlvmMachOp

-- | signed integer ..
LM_MO_SDiv :: LlvmMachOp

-- | unsigned integer or vector remainder (mod)
LM_MO_URem :: LlvmMachOp

-- | signed ...
LM_MO_SRem :: LlvmMachOp

-- | add two floating point or vector values.
LM_MO_FAdd :: LlvmMachOp

-- | subtract two ...
LM_MO_FSub :: LlvmMachOp

-- | multiply ...
LM_MO_FMul :: LlvmMachOp

-- | divide ...
LM_MO_FDiv :: LlvmMachOp

-- | remainder ...
LM_MO_FRem :: LlvmMachOp

-- | Left shift
LM_MO_Shl :: LlvmMachOp

-- | Logical shift right Shift right, filling with zero
LM_MO_LShr :: LlvmMachOp

-- | Arithmetic shift right The most significant bits of the result will be
--   equal to the sign bit of the left operand.
LM_MO_AShr :: LlvmMachOp

-- | AND bitwise logical operation.
LM_MO_And :: LlvmMachOp

-- | OR bitwise logical operation.
LM_MO_Or :: LlvmMachOp

-- | XOR bitwise logical operation.
LM_MO_Xor :: LlvmMachOp

-- | Llvm cast operations.
data LlvmCastOp

-- | Integer truncate
LM_Trunc :: LlvmCastOp

-- | Integer extend (zero fill)
LM_Zext :: LlvmCastOp

-- | Integer extend (sign fill)
LM_Sext :: LlvmCastOp

-- | Float truncate
LM_Fptrunc :: LlvmCastOp

-- | Float extend
LM_Fpext :: LlvmCastOp

-- | Float to unsigned Integer
LM_Fptoui :: LlvmCastOp

-- | Float to signed Integer
LM_Fptosi :: LlvmCastOp

-- | Unsigned Integer to Float
LM_Uitofp :: LlvmCastOp

-- | Signed Int to Float
LM_Sitofp :: LlvmCastOp

-- | Pointer to Integer
LM_Ptrtoint :: LlvmCastOp

-- | Integer to Pointer
LM_Inttoptr :: LlvmCastOp

-- | Cast between types where no bit manipulation is needed
LM_Bitcast :: LlvmCastOp

-- | LLVM Variables
data LlvmVar

-- | Variables with a global scope.
LMGlobalVar :: LMString -> LlvmType -> LlvmLinkageType -> LMSection -> LMAlign -> LMConst -> LlvmVar

-- | Variables local to a function or parameters.
LMLocalVar :: Unique -> LlvmType -> LlvmVar

-- | Named local variables. Sometimes we need to be able to explicitly name
--   variables (e.g for function arguments).
LMNLocalVar :: LMString -> LlvmType -> LlvmVar

-- | A constant variable
LMLitVar :: LlvmLit -> LlvmVar

-- | Llvm Static Data.
--   
--   These represent the possible global level variables and constants.
data LlvmStatic

-- | A comment in a static section
LMComment :: LMString -> LlvmStatic

-- | A static variant of a literal value
LMStaticLit :: LlvmLit -> LlvmStatic

-- | For uninitialised data
LMUninitType :: LlvmType -> LlvmStatic

-- | Defines a static <a>LMString</a>
LMStaticStr :: LMString -> LlvmType -> LlvmStatic

-- | A static array
LMStaticArray :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A static structure type
LMStaticStruc :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A pointer to other data
LMStaticPointer :: LlvmVar -> LlvmStatic

-- | Truncate
LMTrunc :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Pointer to Pointer conversion
LMBitc :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Pointer to Integer conversion
LMPtoI :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Constant addition operation
LMAdd :: LlvmStatic -> LlvmStatic -> LlvmStatic

-- | Constant subtraction operation
LMSub :: LlvmStatic -> LlvmStatic -> LlvmStatic

-- | Llvm Literal Data.
--   
--   These can be used inline in expressions.
data LlvmLit

-- | Refers to an integer constant (i64 42).
LMIntLit :: Integer -> LlvmType -> LlvmLit

-- | Floating point literal
LMFloatLit :: Double -> LlvmType -> LlvmLit

-- | Literal NULL, only applicable to pointer types
LMNullLit :: LlvmType -> LlvmLit

-- | Vector literal
LMVectorLit :: [LlvmLit] -> LlvmLit

-- | Undefined value, random bit pattern. Useful for optimisations.
LMUndefLit :: LlvmType -> LlvmLit

-- | Llvm Types
data LlvmType

-- | An integer with a given width in bits.
LMInt :: Int -> LlvmType

-- | 32 bit floating point
LMFloat :: LlvmType

-- | 64 bit floating point
LMDouble :: LlvmType

-- | 80 bit (x86 only) floating point
LMFloat80 :: LlvmType

-- | 128 bit floating point
LMFloat128 :: LlvmType

-- | A pointer to a <a>LlvmType</a>
LMPointer :: LlvmType -> LlvmType

-- | An array of <a>LlvmType</a>
LMArray :: Int -> LlvmType -> LlvmType

-- | A vector of <a>LlvmType</a>
LMVector :: Int -> LlvmType -> LlvmType

-- | A <a>LlvmVar</a> can represent a label (address)
LMLabel :: LlvmType

-- | Void type
LMVoid :: LlvmType

-- | Packed structure type
LMStruct :: [LlvmType] -> LlvmType

-- | Unpacked structure type
LMStructU :: [LlvmType] -> LlvmType

-- | A type alias
LMAlias :: LlvmAlias -> LlvmType

-- | LLVM Metadata
LMMetadata :: LlvmType

-- | Function type, used to create pointers to functions
LMFunction :: LlvmFunctionDecl -> LlvmType

-- | A type alias
type LlvmAlias = (LMString, LlvmType)

-- | A global mutable variable. Maybe defined or external
data LMGlobal
LMGlobal :: LlvmVar -> Maybe LlvmStatic -> LMGlobal

-- | Returns the variable of the <a>LMGlobal</a>
[getGlobalVar] :: LMGlobal -> LlvmVar

-- | Return the value of the <a>LMGlobal</a>
[getGlobalValue] :: LMGlobal -> Maybe LlvmStatic

-- | A String in LLVM
type LMString = FastString

-- | An LLVM section definition. If Nothing then let LLVM decide the
--   section
type LMSection = Maybe LMString
type LMAlign = Maybe Int
data LMConst

-- | Mutable global variable
Global :: LMConst

-- | Constant global variable
Constant :: LMConst

-- | Alias of another variable
Alias :: LMConst
i64 :: LlvmType
i32 :: LlvmType
i16 :: LlvmType
i8 :: LlvmType
i1 :: LlvmType
i8Ptr :: LlvmType

-- | The target architectures word size
llvmWord :: Platform -> LlvmType

-- | The target architectures word size
llvmWordPtr :: Platform -> LlvmType

-- | LLVM metadata expressions
data MetaExpr
MetaStr :: !LMString -> MetaExpr
MetaNode :: !MetaId -> MetaExpr
MetaVar :: !LlvmVar -> MetaExpr
MetaStruct :: [MetaExpr] -> MetaExpr

-- | Associates some metadata with a specific label for attaching to an
--   instruction.
data MetaAnnot
MetaAnnot :: LMString -> MetaExpr -> MetaAnnot

-- | Metadata declarations. Metadata can only be declared in global scope.
data MetaDecl

-- | Named metadata. Only used for communicating module information to
--   LLVM. ('!name = !{ [!&lt;n&gt;] }' form).
MetaNamed :: !LMString -> [MetaId] -> MetaDecl

-- | Metadata node declaration. ('!0 = metadata !{ &lt;metadata
--   expression&gt; }' form).
MetaUnnamed :: !MetaId -> !MetaExpr -> MetaDecl

-- | A reference to an un-named metadata node.
newtype MetaId
MetaId :: Int -> MetaId

-- | Test if a <a>LlvmVar</a> is global.
isGlobal :: LlvmVar -> Bool

-- | Return the <a>LlvmType</a> of a <a>LlvmLit</a>
getLitType :: LlvmLit -> LlvmType

-- | Return the <a>LlvmType</a> of the <a>LlvmVar</a>
getVarType :: LlvmVar -> LlvmType

-- | Return the <a>LlvmLinkageType</a> for a <a>LlvmVar</a>
getLink :: LlvmVar -> LlvmLinkageType

-- | Return the <a>LlvmType</a> of the <a>LlvmStatic</a>
getStatType :: LlvmStatic -> LlvmType

-- | Lift a variable to <a>LMPointer</a> type.
pVarLift :: LlvmVar -> LlvmVar

-- | Lower a variable of <a>LMPointer</a> type.
pVarLower :: LlvmVar -> LlvmVar

-- | Add a pointer indirection to the supplied type. <a>LMLabel</a> and
--   <a>LMVoid</a> cannot be lifted.
pLift :: LlvmType -> LlvmType

-- | Remove the pointer indirection of the supplied type. Only
--   <a>LMPointer</a> constructors can be lowered.
pLower :: LlvmType -> LlvmType

-- | Test if the given <a>LlvmType</a> is an integer
isInt :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is a floating point type
isFloat :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is an <a>LMPointer</a> construct
isPointer :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is an <a>LMVector</a> construct
isVector :: LlvmType -> Bool

-- | Width in bits of an <a>LlvmType</a>, returns 0 if not applicable
llvmWidthInBits :: Platform -> LlvmType -> Int
ppVar :: LlvmOpts -> LlvmVar -> SDoc

-- | Print a literal value. No type.
ppLit :: LlvmOpts -> LlvmLit -> SDoc
ppTypeLit :: LlvmOpts -> LlvmLit -> SDoc

-- | Return the variable name or value of the <a>LlvmVar</a> in Llvm IR
--   textual representation (e.g. <tt>@x</tt>, <tt>%y</tt> or <tt>42</tt>).
ppName :: LlvmOpts -> LlvmVar -> SDoc

-- | Return the variable name or value of the <a>LlvmVar</a> in a plain
--   textual representation (e.g. <tt>x</tt>, <tt>y</tt> or <tt>42</tt>).
ppPlainName :: LlvmOpts -> LlvmVar -> SDoc

-- | Print out a whole LLVM module.
ppLlvmModule :: LlvmOpts -> LlvmModule -> SDoc

-- | Print out a multi-line comment, can be inside a function or on its own
ppLlvmComments :: [LMString] -> SDoc

-- | Print out a comment, can be inside a function or on its own
ppLlvmComment :: LMString -> SDoc

-- | Print out a list of global mutable variable definitions
ppLlvmGlobals :: LlvmOpts -> [LMGlobal] -> SDoc

-- | Print out a global mutable variable definition
ppLlvmGlobal :: LlvmOpts -> LMGlobal -> SDoc

-- | Print out a list of function declaration.
ppLlvmFunctionDecls :: LlvmFunctionDecls -> SDoc

-- | Print out a function declaration. Declarations define the function
--   type but don't define the actual body of the function.
ppLlvmFunctionDecl :: LlvmFunctionDecl -> SDoc

-- | Print out a list of function definitions.
ppLlvmFunctions :: LlvmOpts -> LlvmFunctions -> SDoc

-- | Print out a function definition.
ppLlvmFunction :: LlvmOpts -> LlvmFunction -> SDoc

-- | Print out an LLVM type alias.
ppLlvmAlias :: LlvmAlias -> SDoc

-- | Print out a list of LLVM type aliases.
ppLlvmAliases :: [LlvmAlias] -> SDoc

-- | Print out a list of LLVM metadata.
ppLlvmMetas :: LlvmOpts -> [MetaDecl] -> SDoc

-- | Print out an LLVM metadata definition.
ppLlvmMeta :: LlvmOpts -> MetaDecl -> SDoc


-- | Deal with Cmm registers
module GHC.CmmToLlvm.Regs

-- | Get the LlvmVar function argument storing the real register
lmGlobalRegArg :: Platform -> GlobalReg -> LlvmVar

-- | Get the LlvmVar function variable storing the real register
lmGlobalRegVar :: Platform -> GlobalReg -> LlvmVar

-- | A list of STG Registers that should always be considered alive
alwaysLive :: [GlobalReg]

-- | STG Type Based Alias Analysis hierarchy
stgTBAA :: [(Unique, LMString, Maybe Unique)]

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
baseN :: Unique

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
stackN :: Unique

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
heapN :: Unique

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
rxN :: Unique

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
topN :: Unique

-- | The TBAA metadata identifier
tbaa :: LMString

-- | Get the correct TBAA metadata information for this register type
getTBAA :: GlobalReg -> Unique


-- | Formats on this architecture A Format is a combination of width and
--   class
--   
--   TODO: Signed vs unsigned?
--   
--   TODO: This module is currently shared by all architectures because
--   NCGMonad need to know about it to make a VReg. It would be better to
--   have architecture specific formats, and do the overloading properly.
--   eg SPARC doesn't care about FF80.
module GHC.CmmToAsm.Format
data Format
II8 :: Format
II16 :: Format
II32 :: Format
II64 :: Format
FF32 :: Format
FF64 :: Format

-- | Get the integer format of this width.
intFormat :: Width -> Format

-- | Get the float format of this width.
floatFormat :: Width -> Format

-- | Check if a format represent an integer value.
isIntFormat :: Format -> Bool

-- | Check if a format represents a floating point value.
isFloatFormat :: Format -> Bool

-- | Convert a Cmm type to a Format.
cmmTypeFormat :: CmmType -> Format

-- | Get the Width of a Format.
formatToWidth :: Format -> Width
formatInBytes :: Format -> Int
instance GHC.Classes.Eq GHC.CmmToAsm.Format.Format
instance GHC.Show.Show GHC.CmmToAsm.Format.Format

module GHC.CmmToAsm.X86.RegInfo
mkVirtualReg :: Unique -> Format -> VirtualReg
regDotColor :: Platform -> RealReg -> SDoc

module GHC.CmmToAsm.SPARC.Regs

-- | Get the standard name for the register with this number.
showReg :: RegNo -> String

-- | regSqueeze_class reg Calculate the maximum number of register colors
--   that could be denied to a node of this class due to having this reg as
--   a neighbour.
virtualRegSqueeze :: RegClass -> VirtualReg -> Int
realRegSqueeze :: RegClass -> RealReg -> Int
classOfRealReg :: RealReg -> RegClass

-- | All the allocatable registers in the machine, including register
--   pairs.
allRealRegs :: [RealReg]

-- | Get the regno for this sort of reg
gReg :: Int -> RegNo

-- | Get the regno for this sort of reg
iReg :: Int -> RegNo

-- | Get the regno for this sort of reg
lReg :: Int -> RegNo

-- | Get the regno for this sort of reg
oReg :: Int -> RegNo

-- | Get the regno for this sort of reg
fReg :: Int -> RegNo

-- | Some specific regs used by the code generator.
fp :: Reg

-- | Some specific regs used by the code generator.
sp :: Reg

-- | Some specific regs used by the code generator.
g0 :: Reg

-- | Some specific regs used by the code generator.
g1 :: Reg

-- | Some specific regs used by the code generator.
g2 :: Reg

-- | Some specific regs used by the code generator.
o0 :: Reg

-- | Some specific regs used by the code generator.
o1 :: Reg

-- | Some specific regs used by the code generator.
f0 :: Reg

-- | Some specific regs used by the code generator.
f1 :: Reg

-- | Some specific regs used by the code generator.
f6 :: Reg

-- | Some specific regs used by the code generator.
f8 :: Reg

-- | Some specific regs used by the code generator.
f22 :: Reg

-- | Some specific regs used by the code generator.
f26 :: Reg

-- | Some specific regs used by the code generator.
f27 :: Reg

-- | Produce the second-half-of-a-double register given the first half.
--   
--   All the regs that the register allocator can allocate to, with the
--   fixed use regs removed.
allocatableRegs :: [RealReg]

-- | The registers to place arguments for function calls, for some number
--   of arguments.
argRegs :: RegNo -> [Reg]

-- | All the regs that could possibly be returned by argRegs
allArgRegs :: [Reg]
callClobberedRegs :: [Reg]

-- | Make a virtual reg with this format.
mkVirtualReg :: Unique -> Format -> VirtualReg
regDotColor :: RealReg -> SDoc

module GHC.CmmToAsm.SPARC.Stack

-- | Get an AddrMode relative to the address in sp. This gives us a stack
--   relative addressing mode for volatile temporaries and for excess call
--   arguments.
spRel :: Int -> AddrMode

-- | Get an address relative to the frame pointer. This doesn't work work
--   for offsets greater than 13 bits; we just hope for the best
fpRel :: Int -> AddrMode

-- | Convert a spill slot number to a *byte* offset, with no sign.
spillSlotToOffset :: NCGConfig -> Int -> Int

-- | The maximum number of spill slots available on the C stack. If we use
--   up all of the slots, then we're screwed.
--   
--   Why do we reserve 64 bytes, instead of using the whole thing?? -- BL
--   2009<i>02</i>15
maxSpillSlots :: NCGConfig -> Int


-- | Free regs map for SPARC
module GHC.CmmToAsm.Reg.Linear.SPARC
data FreeRegs
FreeRegs :: !Word32 -> !Word32 -> !Word32 -> FreeRegs

-- | A reg map where no regs are free to be allocated.
noFreeRegs :: FreeRegs

-- | The initial set of free regs.
initFreeRegs :: Platform -> FreeRegs

-- | Get all the free registers of this class.
getFreeRegs :: RegClass -> FreeRegs -> [RealReg]

-- | Grab a register.
allocateReg :: Platform -> RealReg -> FreeRegs -> FreeRegs

-- | Release a register from allocation. The register liveness information
--   says that most regs die after a C call, but we still don't want to
--   allocate to some of them.
releaseReg :: Platform -> RealReg -> FreeRegs -> FreeRegs
bitMask :: Int -> Word32
showFreeRegs :: FreeRegs -> String
instance GHC.Show.Show GHC.CmmToAsm.Reg.Linear.SPARC.FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.SPARC.FreeRegs

module GHC.CmmToAsm.PPC.Regs

-- | regSqueeze_class reg Calculate the maximum number of register colors
--   that could be denied to a node of this class due to having this reg as
--   a neighbour.
virtualRegSqueeze :: RegClass -> VirtualReg -> Int
realRegSqueeze :: RegClass -> RealReg -> Int
mkVirtualReg :: Unique -> Format -> VirtualReg
regDotColor :: RealReg -> SDoc
data Imm
ImmInt :: Int -> Imm
ImmInteger :: Integer -> Imm
ImmCLbl :: CLabel -> Imm
ImmLit :: SDoc -> Imm
ImmIndex :: CLabel -> Int -> Imm
ImmFloat :: Rational -> Imm
ImmDouble :: Rational -> Imm
ImmConstantSum :: Imm -> Imm -> Imm
ImmConstantDiff :: Imm -> Imm -> Imm
LO :: Imm -> Imm
HI :: Imm -> Imm
HA :: Imm -> Imm
HIGHERA :: Imm -> Imm
HIGHESTA :: Imm -> Imm
strImmLit :: String -> Imm
litToImm :: CmmLit -> Imm
data AddrMode
AddrRegReg :: Reg -> Reg -> AddrMode
AddrRegImm :: Reg -> Imm -> AddrMode
addrOffset :: AddrMode -> Int -> Maybe AddrMode
spRel :: Platform -> Int -> AddrMode
argRegs :: RegNo -> [Reg]
allArgRegs :: [Reg]
callClobberedRegs :: Platform -> [Reg]
allMachRegNos :: [RegNo]
classOfRealReg :: RealReg -> RegClass
showReg :: RegNo -> String
toRegNo :: Reg -> RegNo
allFPArgRegs :: Platform -> [Reg]
fits16Bits :: Integral a => a -> Bool
makeImmediate :: Integral a => Width -> Bool -> a -> Maybe Imm
fReg :: Int -> RegNo
r0 :: Reg
sp :: Reg
toc :: Reg
r3 :: Reg
r4 :: Reg
r11 :: Reg
r12 :: Reg
r30 :: Reg
tmpReg :: Platform -> Reg
f1 :: Reg
allocatableRegs :: Platform -> [RealReg]


-- | Free regs map for PowerPC
module GHC.CmmToAsm.Reg.Linear.PPC
data FreeRegs
FreeRegs :: !Word32 -> !Word32 -> FreeRegs
noFreeRegs :: FreeRegs
releaseReg :: RealReg -> FreeRegs -> FreeRegs
initFreeRegs :: Platform -> FreeRegs
getFreeRegs :: RegClass -> FreeRegs -> [RealReg]
allocateReg :: RealReg -> FreeRegs -> FreeRegs
instance GHC.Show.Show GHC.CmmToAsm.Reg.Linear.PPC.FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.PPC.FreeRegs


-- | Constants describing the DWARF format. Most of this simply mirrors
--   /usr/include/dwarf.h.
module GHC.CmmToAsm.Dwarf.Constants

-- | Language ID used for Haskell.
dW_LANG_Haskell :: Word
dW_TAG_compile_unit :: Word
dW_TAG_subroutine_type :: Word
dW_TAG_file_type :: Word
dW_TAG_subprogram :: Word
dW_TAG_lexical_block :: Word
dW_TAG_base_type :: Word
dW_TAG_structure_type :: Word
dW_TAG_pointer_type :: Word
dW_TAG_array_type :: Word
dW_TAG_subrange_type :: Word
dW_TAG_typedef :: Word
dW_TAG_variable :: Word
dW_TAG_arg_variable :: Word
dW_TAG_auto_variable :: Word
dW_TAG_ghc_src_note :: Word
dW_AT_name :: Word
dW_AT_stmt_list :: Word
dW_AT_low_pc :: Word
dW_AT_high_pc :: Word
dW_AT_language :: Word
dW_AT_comp_dir :: Word
dW_AT_producer :: Word
dW_AT_external :: Word
dW_AT_frame_base :: Word
dW_AT_use_UTF8 :: Word
dW_AT_linkage_name :: Word
dW_AT_ghc_tick_parent :: Word
dW_AT_ghc_span_file :: Word
dW_AT_ghc_span_start_line :: Word
dW_AT_ghc_span_start_col :: Word
dW_AT_ghc_span_end_line :: Word
dW_AT_ghc_span_end_col :: Word
dW_CHILDREN_no :: Word8
dW_CHILDREN_yes :: Word8
dW_FORM_addr :: Word
dW_FORM_data2 :: Word
dW_FORM_data4 :: Word
dW_FORM_string :: Word
dW_FORM_flag :: Word
dW_FORM_block1 :: Word
dW_FORM_ref4 :: Word
dW_FORM_ref_addr :: Word
dW_FORM_flag_present :: Word
dW_ATE_address :: Word
dW_ATE_boolean :: Word
dW_ATE_float :: Word
dW_ATE_signed :: Word
dW_ATE_signed_char :: Word
dW_ATE_unsigned :: Word
dW_ATE_unsigned_char :: Word
dW_CFA_set_loc :: Word8
dW_CFA_undefined :: Word8
dW_CFA_same_value :: Word8
dW_CFA_def_cfa :: Word8
dW_CFA_def_cfa_offset :: Word8
dW_CFA_def_cfa_expression :: Word8
dW_CFA_expression :: Word8
dW_CFA_offset_extended_sf :: Word8
dW_CFA_def_cfa_offset_sf :: Word8
dW_CFA_def_cfa_sf :: Word8
dW_CFA_val_offset :: Word8
dW_CFA_val_expression :: Word8
dW_CFA_offset :: Word8
dW_OP_addr :: Word8
dW_OP_deref :: Word8
dW_OP_consts :: Word8
dW_OP_minus :: Word8
dW_OP_mul :: Word8
dW_OP_plus :: Word8
dW_OP_lit0 :: Word8
dW_OP_breg0 :: Word8
dW_OP_call_frame_cfa :: Word8
dwarfInfoSection :: Platform -> SDoc
dwarfAbbrevSection :: Platform -> SDoc
dwarfLineSection :: Platform -> SDoc
dwarfFrameSection :: Platform -> SDoc
dwarfGhcSection :: Platform -> SDoc
dwarfARangesSection :: Platform -> SDoc
dwarfSection :: Platform -> String -> SDoc
dwarfInfoLabel :: PtrString
dwarfAbbrevLabel :: PtrString
dwarfLineLabel :: PtrString
dwarfFrameLabel :: PtrString

-- | Mapping of registers to DWARF register numbers
dwarfRegNo :: Platform -> Reg -> Word8

-- | Virtual register number to use for return address.
dwarfReturnRegNo :: Platform -> Word8

module GHC.CmmToAsm.AArch64.Regs
allMachRegNos :: [RegNo]
allocatableRegs :: Platform -> [RealReg]
allGpArgRegs :: [Reg]
allFpArgRegs :: [Reg]
data AddrMode
AddrRegReg :: Reg -> Reg -> AddrMode
AddrRegImm :: Reg -> Imm -> AddrMode
AddrReg :: Reg -> AddrMode
data Imm
ImmInt :: Int -> Imm
ImmInteger :: Integer -> Imm
ImmCLbl :: CLabel -> Imm
ImmLit :: SDoc -> Imm
ImmIndex :: CLabel -> Int -> Imm
ImmFloat :: Rational -> Imm
ImmDouble :: Rational -> Imm
ImmConstantSum :: Imm -> Imm -> Imm
ImmConstantDiff :: Imm -> Imm -> Imm
strImmLit :: String -> Imm
litToImm :: CmmLit -> Imm

-- | regSqueeze_class reg Calculate the maximum number of register colors
--   that could be denied to a node of this class due to having this reg as
--   a neighbour.
virtualRegSqueeze :: RegClass -> VirtualReg -> Int
realRegSqueeze :: RegClass -> RealReg -> Int
mkVirtualReg :: Unique -> Format -> VirtualReg
classOfRealReg :: RealReg -> RegClass
regDotColor :: RealReg -> SDoc
instance GHC.Show.Show GHC.CmmToAsm.AArch64.Regs.Imm
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Regs.Imm
instance GHC.Show.Show GHC.CmmToAsm.AArch64.Regs.AddrMode
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Regs.AddrMode
instance GHC.Show.Show GHC.Utils.Outputable.SDoc
instance GHC.Classes.Eq GHC.Utils.Outputable.SDoc


-- | Hard wired things related to registers. This is module is preventing
--   the native code generator being able to emit code for non-host
--   architectures.
--   
--   TODO: Do a better job of the overloading, and eliminate this module.
--   We'd probably do better with a Register type class, and hook this to
--   Instruction somehow.
--   
--   TODO: We should also make arch specific versions of
--   RegAlloc.Graph.TrivColorable
module GHC.CmmToAsm.Reg.Target
targetVirtualRegSqueeze :: Platform -> RegClass -> VirtualReg -> Int
targetRealRegSqueeze :: Platform -> RegClass -> RealReg -> Int
targetClassOfRealReg :: Platform -> RealReg -> RegClass
targetMkVirtualReg :: Platform -> Unique -> Format -> VirtualReg
targetRegDotColor :: Platform -> RealReg -> SDoc
targetClassOfReg :: Platform -> Reg -> RegClass

module GHC.CmmToAsm.SPARC.Instr

-- | SPARC instruction set. Not complete. This is only the ones we need.
data Instr
COMMENT :: FastString -> Instr
LDATA :: Section -> RawCmmStatics -> Instr
NEWBLOCK :: BlockId -> Instr
DELTA :: Int -> Instr
LD :: Format -> AddrMode -> Reg -> Instr
ST :: Format -> Reg -> AddrMode -> Instr
ADD :: Bool -> Bool -> Reg -> RI -> Reg -> Instr
SUB :: Bool -> Bool -> Reg -> RI -> Reg -> Instr
UMUL :: Bool -> Reg -> RI -> Reg -> Instr
SMUL :: Bool -> Reg -> RI -> Reg -> Instr
UDIV :: Bool -> Reg -> RI -> Reg -> Instr
SDIV :: Bool -> Reg -> RI -> Reg -> Instr
RDY :: Reg -> Instr
WRY :: Reg -> Reg -> Instr
AND :: Bool -> Reg -> RI -> Reg -> Instr
ANDN :: Bool -> Reg -> RI -> Reg -> Instr
OR :: Bool -> Reg -> RI -> Reg -> Instr
ORN :: Bool -> Reg -> RI -> Reg -> Instr
XOR :: Bool -> Reg -> RI -> Reg -> Instr
XNOR :: Bool -> Reg -> RI -> Reg -> Instr
SLL :: Reg -> RI -> Reg -> Instr
SRL :: Reg -> RI -> Reg -> Instr
SRA :: Reg -> RI -> Reg -> Instr
SETHI :: Imm -> Reg -> Instr
NOP :: Instr
FABS :: Format -> Reg -> Reg -> Instr
FADD :: Format -> Reg -> Reg -> Reg -> Instr
FCMP :: Bool -> Format -> Reg -> Reg -> Instr
FDIV :: Format -> Reg -> Reg -> Reg -> Instr
FMOV :: Format -> Reg -> Reg -> Instr
FMUL :: Format -> Reg -> Reg -> Reg -> Instr
FNEG :: Format -> Reg -> Reg -> Instr
FSQRT :: Format -> Reg -> Reg -> Instr
FSUB :: Format -> Reg -> Reg -> Reg -> Instr
FxTOy :: Format -> Format -> Reg -> Reg -> Instr
BI :: Cond -> Bool -> BlockId -> Instr
BF :: Cond -> Bool -> BlockId -> Instr
JMP :: AddrMode -> Instr
JMP_TBL :: AddrMode -> [Maybe BlockId] -> CLabel -> Instr
CALL :: Either Imm Reg -> Int -> Bool -> Instr

-- | Register or immediate
data RI
RIReg :: Reg -> RI
RIImm :: Imm -> RI

-- | Check if a RI represents a zero value. - a literal zero - register
--   %g0, which is always zero.
riZero :: RI -> Bool

-- | Calculate the effective address which would be used by the
--   corresponding fpRel sequence.
fpRelEA :: Int -> Reg -> Instr

-- | Code to shift the stack pointer by n words.
moveSp :: Int -> Instr

-- | An instruction that will cause the one after it never to be exectuted
isUnconditionalJump :: Instr -> Bool

-- | The maximum number of spill slots available on the C stack. If we use
--   up all of the slots, then we're screwed.
--   
--   Why do we reserve 64 bytes, instead of using the whole thing?? -- BL
--   2009<i>02</i>15
maxSpillSlots :: NCGConfig -> Int

-- | Apply a given mapping to tall the register references in this
--   instruction.
patchRegsOfInstr :: Instr -> (Reg -> Reg) -> Instr
patchJumpInstr :: Instr -> (BlockId -> BlockId) -> Instr

-- | Make a reg-reg move instruction. On SPARC v8 there are no instructions
--   to move directly between floating point and integer regs. If we need
--   to do that then we have to go via memory.
mkRegRegMoveInstr :: Platform -> Reg -> Reg -> Instr

-- | Make a spill reload instruction.
mkLoadInstr :: NCGConfig -> Reg -> Int -> Int -> [Instr]

-- | Make a spill instruction. On SPARC we spill below frame pointer
--   leaving 2 words/spill
mkSpillInstr :: NCGConfig -> Reg -> Int -> Int -> [Instr]

-- | Make an unconditional branch instruction.
mkJumpInstr :: BlockId -> [Instr]

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instr -> Maybe Int
isMetaInstr :: Instr -> Bool
isJumpishInstr :: Instr -> Bool
jumpDestsOfInstr :: Instr -> [BlockId]

-- | Check whether an instruction represents a reg-reg move. The register
--   allocator attempts to eliminate reg-&gt;reg moves whenever it can, by
--   assigning the src and dest temporaries to the same real register.
takeRegRegMoveInstr :: Instr -> Maybe (Reg, Reg)

-- | regUsage returns the sets of src and destination registers used by a
--   particular instruction. Machine registers that are pre-allocated to
--   stgRegs are filtered out, because they are uninteresting from a
--   register allocation standpoint. (We wouldn't want them to end up on
--   the free list!) As far as we are concerned, the fixed registers simply
--   don't exist (for allocation purposes, anyway).
regUsageOfInstr :: Platform -> Instr -> RegUsage

module GHC.CmmToAsm.SPARC.ShortcutJump
data JumpDest
DestBlockId :: BlockId -> JumpDest
DestImm :: Imm -> JumpDest
getJumpDestBlockId :: JumpDest -> Maybe BlockId
canShortcut :: Instr -> Maybe JumpDest
shortcutJump :: (BlockId -> Maybe JumpDest) -> Instr -> Instr
shortcutStatics :: (BlockId -> Maybe JumpDest) -> RawCmmStatics -> RawCmmStatics
shortBlockId :: (BlockId -> Maybe JumpDest) -> BlockId -> CLabel
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.SPARC.ShortcutJump.JumpDest


-- | Expand out synthetic instructions into single machine instrs.
module GHC.CmmToAsm.SPARC.CodeGen.Expand

-- | Expand out synthetic instructions in this top level thing
expandTop :: NatCmmDecl RawCmmStatics Instr -> NatCmmDecl RawCmmStatics Instr

module GHC.CmmToAsm.SPARC.CodeGen.Base

-- | <a>InstrBlock</a>s are the insn sequences generated by the insn
--   selectors. They are really trees of insns to facilitate fast
--   appending, where a left-to-right traversal yields the insns in the
--   correct order.
type InstrBlock = OrdList Instr

-- | Condition codes passed up the tree.
data CondCode
CondCode :: Bool -> Cond -> InstrBlock -> CondCode

-- | a.k.a "Register64" Reg is the lower 32-bit temporary which contains
--   the result. Use getHiVRegFromLo to find the other VRegUnique.
--   
--   Rules of this simplified insn selection game are therefore that the
--   returned Reg may be modified
data ChildCode64
ChildCode64 :: InstrBlock -> Reg -> ChildCode64

-- | Holds code that references a memory address.
data Amode
Amode :: AddrMode -> InstrBlock -> Amode

-- | Code to produce a result into a register. If the result must go in a
--   specific register, it comes out as Fixed. Otherwise, the parent can
--   decide which register to put it in.
data Register
Fixed :: Format -> Reg -> InstrBlock -> Register
Any :: Format -> (Reg -> InstrBlock) -> Register

-- | Change the format field in a Register.
setFormatOfRegister :: Register -> Format -> Register

-- | Grab the Reg for a CmmReg
getRegisterReg :: Platform -> CmmReg -> Reg
mangleIndexTree :: Platform -> CmmExpr -> CmmExpr

module GHC.CmmToAsm.Reg.Linear.AArch64

-- | Armv6 | Armv7-A | Armv8-A AArch64 | | SIMD extension | NEON | NEON |
--   |===========================================================================|
--   | - Operates on 32-bit | - Separate reg. bank, | - Separate reg. bank,
--   | | GP ARM registers | 32x64-bit NEON regs | 32x128-bit NEON regs | |
--   - 8-bit<i>16-bit integer | - 8</i>16<i>32</i>64-bit int | -
--   8<i>16</i>32/64-bit int | | | - Single percision fp | - Single
--   percision fp | | | | - Double precision fp | | | | - Single/Double fp
--   are | | | | IEEE compliant | | - 2x16-bit/4x8-bit ops | - Up to
--   16x8-bit ops | - Up to 16x8-bit ops | | per instruction | per
--   instruction | per instruction |
--   '---------------------------------------------------------------------------'
data FreeRegs
FreeRegs :: !Word32 -> !Word32 -> FreeRegs
noFreeRegs :: FreeRegs
showBits :: Word32 -> String
allocateReg :: HasCallStack => RealReg -> FreeRegs -> FreeRegs
getFreeRegs :: RegClass -> FreeRegs -> [RealReg]
initFreeRegs :: Platform -> FreeRegs
releaseReg :: HasCallStack => RealReg -> FreeRegs -> FreeRegs
instance GHC.Show.Show GHC.CmmToAsm.Reg.Linear.AArch64.FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.AArch64.FreeRegs

module GHC.CmmToAsm.AArch64.Instr

-- | TODO: verify this!
stackFrameHeaderSize :: Platform -> Int

-- | All registers are 8 byte wide.
spillSlotSize :: Int

-- | The number of bytes that the stack pointer should be aligned to.
stackAlign :: Int

-- | The number of spill slots available without allocating more.
maxSpillSlots :: NCGConfig -> Int

-- | Convert a spill slot number to a *byte* offset, with no sign.
spillSlotToOffset :: NCGConfig -> Int -> Int
regUsageOfInstr :: Platform -> Instr -> RegUsage

-- | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
--   16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 |
--   30 | 31 | | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 42
--   | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57
--   | 58 | 59 | 60 | 61 | 62 | 63 | |== General Purpose registers
--   ==================================================================================================================================|
--   | <a>argument passing -------------</a> | IR | <a>tmp registers
--   --------</a> | IP0| IP1| PL | <a>callee saved ------------</a> | FP |
--   LR | SP | | <a>free registers
--   --------------------------------------------------------------------</a>
--   | BR | Sp | Hp | R1 | R2 | R3 | R4 | R5 | R6 | SL | -- | -- | -- | |==
--   SIMD/FP Registers
--   ==========================================================================================================================================|
--   | <a>argument passing -------------</a> | <a>callee saved (lower 64
--   bits) ---</a> | <a>caller saved ----------------------</a> | | <a>free
--   registers -------------</a> | F1 | F2 | F3 | F4 | D1 | D2 | D3 | D4 |
--   <a>free registers
--   -----------------------------------------------------</a> |
--   '---------------------------------------------------------------------------------------------------------------------------------------------------------------'
--   IR: Indirect result location register, IP: Intra-procedure register,
--   PL: Platform register, FP: Frame pointer, LR: Link register, SP: Stack
--   pointer BR: Base, SL: SpLim
callerSavedRegisters :: [Reg]

-- | Apply a given mapping to all the register references in this
--   instruction.
patchRegsOfInstr :: Instr -> (Reg -> Reg) -> Instr

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
isJumpishInstr :: Instr -> Bool

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
jumpDestsOfInstr :: Instr -> [BlockId]

-- | Change the destination of this jump instruction. Used in the linear
--   allocator when adding fixup blocks for join points.
patchJumpInstr :: Instr -> (BlockId -> BlockId) -> Instr

-- | An instruction to spill a register into a spill slot.
mkSpillInstr :: HasCallStack => NCGConfig -> Reg -> Int -> Int -> [Instr]
mkLoadInstr :: NCGConfig -> Reg -> Int -> Int -> [Instr]

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instr -> Maybe Int
isMetaInstr :: Instr -> Bool

-- | Copy the value in a register to another one. Must work for all
--   register classes.
mkRegRegMoveInstr :: Reg -> Reg -> Instr

-- | Take the source and destination from this reg -&gt; reg move
--   instruction or Nothing if it's not one
takeRegRegMoveInstr :: Instr -> Maybe (Reg, Reg)

-- | Make an unconditional jump instruction.
mkJumpInstr :: BlockId -> [Instr]
mkStackAllocInstr :: Platform -> Int -> [Instr]
mkStackDeallocInstr :: Platform -> Int -> [Instr]
allocMoreStack :: Platform -> Int -> NatCmmDecl statics Instr -> UniqSM (NatCmmDecl statics Instr, [(BlockId, BlockId)])
data Instr
COMMENT :: SDoc -> Instr
MULTILINE_COMMENT :: SDoc -> Instr
ANN :: SDoc -> Instr -> Instr
LOCATION :: Int -> Int -> Int -> String -> Instr
LDATA :: Section -> RawCmmStatics -> Instr
NEWBLOCK :: BlockId -> Instr
DELTA :: Int -> Instr
SXTB :: Operand -> Operand -> Instr
UXTB :: Operand -> Operand -> Instr
SXTH :: Operand -> Operand -> Instr
UXTH :: Operand -> Operand -> Instr

-- | SXTW Operand Operand | SXTX Operand Operand
PUSH_STACK_FRAME :: Instr
POP_STACK_FRAME :: Instr

-- | ADC Operand Operand Operang -- rd = rn + rm + C | ADCS ...
ADD :: Operand -> Operand -> Operand -> Instr

-- | ADDS Operand Operand Operand -- rd = rn + rm | ADR ... | ADRP ...
CMN :: Operand -> Operand -> Instr
CMP :: Operand -> Operand -> Instr

-- | MADD ... | MNEG ...
MSUB :: Operand -> Operand -> Operand -> Operand -> Instr
MUL :: Operand -> Operand -> Operand -> Instr
NEG :: Operand -> Operand -> Instr

-- | NEGS ... | NGC ... | NGCS ... | SBC ... | SBCS ...
SDIV :: Operand -> Operand -> Operand -> Instr

-- | SMADDL ... | SMNEGL ... | SMSUBL ...
SMULH :: Operand -> Operand -> Operand -> Instr
SMULL :: Operand -> Operand -> Operand -> Instr
SUB :: Operand -> Operand -> Operand -> Instr

-- | SUBS ...
UDIV :: Operand -> Operand -> Operand -> Instr

-- | UMADDL ... -- Xd = Xa + Wn Ã Wm | UMNEGL ... -- Xd = - Wn Ã Wm |
--   UMSUBL ... -- Xd = Xa - Wn Ã Wm | UMULH ... -- Xd = (Xn Ã Xm)_127:64 |
--   UMULL ... -- Xd = Wn Ã Wm
SBFM :: Operand -> Operand -> Operand -> Operand -> Instr
UBFM :: Operand -> Operand -> Operand -> Operand -> Instr
SBFX :: Operand -> Operand -> Operand -> Operand -> Instr
UBFX :: Operand -> Operand -> Operand -> Operand -> Instr
AND :: Operand -> Operand -> Operand -> Instr
ANDS :: Operand -> Operand -> Operand -> Instr
ASR :: Operand -> Operand -> Operand -> Instr
BIC :: Operand -> Operand -> Operand -> Instr
BICS :: Operand -> Operand -> Operand -> Instr
EON :: Operand -> Operand -> Operand -> Instr
EOR :: Operand -> Operand -> Operand -> Instr
LSL :: Operand -> Operand -> Operand -> Instr
LSR :: Operand -> Operand -> Operand -> Instr
MOV :: Operand -> Operand -> Instr
MOVK :: Operand -> Operand -> Instr

-- | MOVN Operand Operand | MOVZ Operand Operand
MVN :: Operand -> Operand -> Instr
ORN :: Operand -> Operand -> Operand -> Instr
ORR :: Operand -> Operand -> Operand -> Instr
ROR :: Operand -> Operand -> Operand -> Instr
TST :: Operand -> Operand -> Instr
STR :: Format -> Operand -> Operand -> Instr
LDR :: Format -> Operand -> Operand -> Instr
STP :: Format -> Operand -> Operand -> Operand -> Instr
LDP :: Format -> Operand -> Operand -> Operand -> Instr
CSET :: Operand -> Cond -> Instr
CBZ :: Operand -> Target -> Instr
CBNZ :: Operand -> Target -> Instr
J :: Target -> Instr
B :: Target -> Instr
BL :: Target -> [Reg] -> [Reg] -> Instr
BCOND :: Cond -> Target -> Instr
DMBSY :: Instr
FCVT :: Operand -> Operand -> Instr
SCVTF :: Operand -> Operand -> Instr
FCVTZS :: Operand -> Operand -> Instr
FABS :: Operand -> Operand -> Instr
data Target
TBlock :: BlockId -> Target
TLabel :: CLabel -> Target
TReg :: Reg -> Target
data ExtMode
EUXTB :: ExtMode
EUXTH :: ExtMode
EUXTW :: ExtMode
EUXTX :: ExtMode
ESXTB :: ExtMode
ESXTH :: ExtMode
ESXTW :: ExtMode
ESXTX :: ExtMode
data ShiftMode
SLSL :: ShiftMode
SLSR :: ShiftMode
SASR :: ShiftMode
SROR :: ShiftMode
type ExtShift = Int
type RegShift = Int
data Operand
OpReg :: Width -> Reg -> Operand
OpRegExt :: Width -> Reg -> ExtMode -> ExtShift -> Operand
OpRegShift :: Width -> Reg -> ShiftMode -> RegShift -> Operand
OpImm :: Imm -> Operand
OpImmShift :: Imm -> ShiftMode -> RegShift -> Operand
OpAddr :: AddrMode -> Operand
opReg :: Width -> Reg -> Operand
xzr :: Operand
wzr :: Operand
sp :: Operand
ip0 :: Operand
_x :: Int -> Operand
x0 :: Operand
x1 :: Operand
x2 :: Operand
x3 :: Operand
x4 :: Operand
x5 :: Operand
x6 :: Operand
x7 :: Operand
x8 :: Operand
x9 :: Operand
x10 :: Operand
x11 :: Operand
x12 :: Operand
x13 :: Operand
x14 :: Operand
x15 :: Operand
x16 :: Operand
x17 :: Operand
x18 :: Operand
x19 :: Operand
x20 :: Operand
x21 :: Operand
x22 :: Operand
x23 :: Operand
x24 :: Operand
x25 :: Operand
x26 :: Operand
x27 :: Operand
x28 :: Operand
x29 :: Operand
x30 :: Operand
x31 :: Operand
_d :: Int -> Operand
d0 :: Operand
d1 :: Operand
d2 :: Operand
d3 :: Operand
d4 :: Operand
d5 :: Operand
d6 :: Operand
d7 :: Operand
d8 :: Operand
d9 :: Operand
d10 :: Operand
d11 :: Operand
d12 :: Operand
d13 :: Operand
d14 :: Operand
d15 :: Operand
d16 :: Operand
d17 :: Operand
d18 :: Operand
d19 :: Operand
d20 :: Operand
d21 :: Operand
d22 :: Operand
d23 :: Operand
d24 :: Operand
d25 :: Operand
d26 :: Operand
d27 :: Operand
d28 :: Operand
d29 :: Operand
d30 :: Operand
d31 :: Operand
opRegUExt :: Width -> Reg -> Operand
opRegSExt :: Width -> Reg -> Operand
instance GHC.Show.Show GHC.CmmToAsm.AArch64.Instr.ExtMode
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Instr.ExtMode
instance GHC.Show.Show GHC.CmmToAsm.AArch64.Instr.ShiftMode
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Instr.ShiftMode
instance GHC.Show.Show GHC.CmmToAsm.AArch64.Instr.Operand
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Instr.Operand
instance GHC.Show.Show GHC.CmmToAsm.AArch64.Instr.Instr
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Instr.RegUsage

module GHC.CmmToAsm.AArch64.RegInfo
data JumpDest
DestBlockId :: BlockId -> JumpDest
getJumpDestBlockId :: JumpDest -> Maybe BlockId
canShortcut :: Instr -> Maybe JumpDest
shortcutStatics :: (BlockId -> Maybe JumpDest) -> RawCmmStatics -> RawCmmStatics
shortcutJump :: (BlockId -> Maybe JumpDest) -> Instr -> Instr
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.AArch64.RegInfo.JumpDest

module GHC.CmmToAsm.AArch64.Ppr
pprNatCmmDecl :: NCGConfig -> NatCmmDecl RawCmmStatics Instr -> SDoc
pprInstr :: Platform -> Instr -> SDoc
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.AArch64.Instr.Instr

module GHC.Cmm.Utils
primRepCmmType :: Platform -> PrimRep -> CmmType
slotCmmType :: Platform -> SlotTy -> CmmType
typeCmmType :: Platform -> UnaryType -> CmmType
typeForeignHint :: UnaryType -> ForeignHint
primRepForeignHint :: PrimRep -> ForeignHint
zeroCLit :: Platform -> CmmLit
mkIntCLit :: Platform -> Int -> CmmLit
mkWordCLit :: Platform -> Integer -> CmmLit
packHalfWordsCLit :: Platform -> StgHalfWord -> StgHalfWord -> CmmLit

-- | We make a top-level decl for the string, and return a label pointing
--   to it
mkByteStringCLit :: CLabel -> ByteString -> (CmmLit, GenCmmDecl (GenCmmStatics raw) info stmt)

-- | We make a top-level decl for the embedded binary file, and return a
--   label pointing to it
mkFileEmbedLit :: CLabel -> FilePath -> (CmmLit, GenCmmDecl (GenCmmStatics raw) info stmt)

-- | Build a data-segment data block
mkDataLits :: Section -> CLabel -> [CmmLit] -> GenCmmDecl (GenCmmStatics raw) info stmt
mkRODataLits :: CLabel -> [CmmLit] -> GenCmmDecl (GenCmmStatics raw) info stmt
mkStgWordCLit :: Platform -> StgWord -> CmmLit
mkIntExpr :: Platform -> Int -> CmmExpr
zeroExpr :: Platform -> CmmExpr
mkLblExpr :: CLabel -> CmmExpr
cmmRegOff :: CmmReg -> Int -> CmmExpr
cmmOffset :: Platform -> CmmExpr -> Int -> CmmExpr
cmmLabelOff :: CLabel -> Int -> CmmLit
cmmOffsetLit :: CmmLit -> Int -> CmmLit
cmmOffsetExpr :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmRegOffB :: CmmReg -> ByteOff -> CmmExpr
cmmOffsetB :: Platform -> CmmExpr -> ByteOff -> CmmExpr
cmmLabelOffB :: CLabel -> ByteOff -> CmmLit
cmmOffsetLitB :: CmmLit -> ByteOff -> CmmLit
cmmOffsetExprB :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmRegOffW :: Platform -> CmmReg -> WordOff -> CmmExpr
cmmOffsetW :: Platform -> CmmExpr -> WordOff -> CmmExpr
cmmLabelOffW :: Platform -> CLabel -> WordOff -> CmmLit
cmmOffsetLitW :: Platform -> CmmLit -> WordOff -> CmmLit
cmmOffsetExprW :: Platform -> CmmExpr -> CmmExpr -> CmmExpr

-- | Useful for creating an index into an array, with a statically known
--   offset. The type is the element type; used for making the multiplier
cmmIndex :: Platform -> Width -> CmmExpr -> Int -> CmmExpr

-- | Useful for creating an index into an array, with an unknown offset.
cmmIndexExpr :: Platform -> Width -> CmmExpr -> CmmExpr -> CmmExpr
cmmLoadIndex :: Platform -> CmmType -> CmmExpr -> Int -> CmmExpr
cmmLoadIndexW :: Platform -> CmmExpr -> Int -> CmmType -> CmmExpr

-- | Load a naturally-aligned non-pointer word.
cmmLoadBWord :: Platform -> CmmExpr -> CmmExpr

-- | Load a naturally-aligned GC pointer.
cmmLoadGCWord :: Platform -> CmmExpr -> CmmExpr
cmmNegate :: Platform -> CmmExpr -> CmmExpr
cmmULtWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUGeWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUGtWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUShrWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmSLtWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmNeWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmEqWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmOrWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmAndWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmSubWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmAddWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmMulWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmQuotWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmToWord :: Platform -> CmmExpr -> CmmExpr
cmmMkAssign :: Platform -> CmmExpr -> Unique -> (CmmNode O O, CmmExpr)
isTrivialCmmExpr :: CmmExpr -> Bool
hasNoGlobalRegs :: CmmExpr -> Bool
isLit :: CmmExpr -> Bool
isComparisonExpr :: CmmExpr -> Bool
baseExpr :: CmmExpr
spExpr :: CmmExpr
hpExpr :: CmmExpr
spLimExpr :: CmmExpr
hpLimExpr :: CmmExpr
currentTSOExpr :: CmmExpr
currentNurseryExpr :: CmmExpr
cccsExpr :: CmmExpr
cmmTagMask :: Platform -> CmmExpr
cmmPointerMask :: Platform -> CmmExpr
cmmUntag :: Platform -> CmmExpr -> CmmExpr
cmmIsTagged :: Platform -> CmmExpr -> CmmExpr
cmmConstrTag1 :: Platform -> CmmExpr -> CmmExpr
mAX_PTR_TAG :: Platform -> Int
tAG_MASK :: Platform -> Int

-- | Returns True if the two STG registers overlap on the specified
--   platform, in the sense that writing to one will clobber the other.
--   This includes the case that the two registers are the same STG
--   register. See Note [Overlapping global registers] for details.
regsOverlap :: Platform -> CmmReg -> CmmReg -> Bool

-- | Returns True if the STG register is used by the expression, in the
--   sense that a store to the register might affect the value of the
--   expression.
--   
--   We must check for overlapping registers and not just equal registers
--   here, otherwise CmmSink may incorrectly reorder assignments that
--   conflict due to overlap. See #10521 and Note [Overlapping global
--   registers].
regUsedIn :: Platform -> CmmReg -> CmmExpr -> Bool
mkLiveness :: Platform -> [LocalReg] -> Liveness
modifyGraph :: (Graph n C C -> Graph n' C C) -> GenCmmGraph n -> GenCmmGraph n'
ofBlockMap :: BlockId -> LabelMap CmmBlock -> CmmGraph
toBlockMap :: CmmGraph -> LabelMap CmmBlock
ofBlockList :: BlockId -> [CmmBlock] -> CmmGraph
toBlockList :: CmmGraph -> [CmmBlock]
bodyToBlockList :: Body CmmNode -> [CmmBlock]

-- | like <a>toBlockList</a>, but the entry block always comes first
toBlockListEntryFirst :: CmmGraph -> [CmmBlock]

-- | Like <a>toBlockListEntryFirst</a>, but we strive to ensure that we
--   order blocks so that the false case of a conditional jumps to the next
--   block in the output list of blocks. This matches the way OldCmm blocks
--   were output since in OldCmm the false case was a fallthrough, whereas
--   in Cmm conditional branches have both true and false successors. Block
--   ordering can make a big difference in performance in the LLVM backend.
--   Note that we rely crucially on the order of successors returned for
--   CmmCondBranch by the NonLocal instance for CmmNode defined in
--   <a>GHC.Cmm.Node</a>. -GBM
toBlockListEntryFirstFalseFallthrough :: CmmGraph -> [CmmBlock]
foldlGraphBlocks :: (a -> CmmBlock -> a) -> a -> CmmGraph -> a
mapGraphNodes :: (CmmNode C O -> CmmNode C O, CmmNode O O -> CmmNode O O, CmmNode O C -> CmmNode O C) -> CmmGraph -> CmmGraph
revPostorder :: CmmGraph -> [CmmBlock]
mapGraphNodes1 :: (forall e x. CmmNode e x -> CmmNode e x) -> CmmGraph -> CmmGraph

-- | Extract all tick annotations from the given block
blockTicks :: Block CmmNode C C -> [CmmTickish]

module GHC.StgToCmm.Closure
type DynTag = Int
tagForCon :: Platform -> DataCon -> DynTag
isSmallFamily :: Platform -> Int -> Bool

-- | Assumes that there is precisely one <a>PrimRep</a> of the type. This
--   assumption holds after unarise. See Note [Post-unarisation invariants]
idPrimRep :: Id -> PrimRep
isVoidRep :: PrimRep -> Bool
isGcPtrRep :: PrimRep -> Bool

-- | Assumes that Ids have one PrimRep, which holds after unarisation. See
--   Note [Post-unarisation invariants]
addIdReps :: [NonVoid Id] -> [NonVoid (PrimRep, Id)]

-- | Assumes that arguments have one PrimRep, which holds after
--   unarisation. See Note [Post-unarisation invariants]
addArgReps :: [NonVoid StgArg] -> [NonVoid (PrimRep, StgArg)]

-- | Assumes that the argument has one PrimRep, which holds after
--   unarisation. See Note [Post-unarisation invariants]
argPrimRep :: StgArg -> PrimRep
newtype NonVoid a
NonVoid :: a -> NonVoid a
fromNonVoid :: NonVoid a -> a
nonVoidIds :: [Id] -> [NonVoid Id]
nonVoidStgArgs :: [StgArg] -> [NonVoid StgArg]

-- | Used in places where some invariant ensures that all these Ids are
--   non-void; e.g. constructor field binders in case expressions. See Note
--   [Post-unarisation invariants] in <a>GHC.Stg.Unarise</a>.
assertNonVoidIds :: [Id] -> [NonVoid Id]

-- | Used in places where some invariant ensures that all these arguments
--   are non-void; e.g. constructor arguments. See Note [Post-unarisation
--   invariants] in <a>GHC.Stg.Unarise</a>.
assertNonVoidStgArgs :: [StgArg] -> [NonVoid StgArg]

-- | Information about an identifier, from the code generator's point of
--   view. Every identifier is bound to a LambdaFormInfo in the
--   environment, which gives the code generator enough info to be able to
--   tail call or return that identifier.
data LambdaFormInfo

-- | StandardFormInfo tells whether this thunk has one of a small number of
--   standard forms
data StandardFormInfo
mkLFThunk :: Type -> TopLevelFlag -> [Id] -> UpdateFlag -> LambdaFormInfo
mkLFReEntrant :: TopLevelFlag -> [Id] -> [Id] -> ArgDescr -> LambdaFormInfo
mkConLFInfo :: DataCon -> LambdaFormInfo
mkSelectorLFInfo :: Id -> Int -> Bool -> LambdaFormInfo
mkApLFInfo :: Id -> UpdateFlag -> Arity -> LambdaFormInfo
mkLFImported :: Id -> LambdaFormInfo
mkLFArgument :: Id -> LambdaFormInfo
mkLFLetNoEscape :: LambdaFormInfo
mkLFStringLit :: LambdaFormInfo

-- | Return the tag in the low order bits of a variable bound to this
--   LambdaForm
lfDynTag :: Platform -> LambdaFormInfo -> DynTag
isLFThunk :: LambdaFormInfo -> Bool
isLFReEntrant :: LambdaFormInfo -> Bool
lfUpdatable :: LambdaFormInfo -> Bool
data CgLoc
CmmLoc :: CmmExpr -> CgLoc
LneLoc :: BlockId -> [LocalReg] -> CgLoc
type SelfLoopInfo = (Id, BlockId, [LocalReg])
data CallMethod
EnterIt :: CallMethod
JumpToIt :: BlockId -> [LocalReg] -> CallMethod
ReturnIt :: CallMethod
SlowCall :: CallMethod
DirectEntry :: CLabel -> RepArity -> CallMethod
nodeMustPointToIt :: Profile -> LambdaFormInfo -> Bool
isKnownFun :: LambdaFormInfo -> Bool
funTag :: Platform -> ClosureInfo -> DynTag
tagForArity :: Platform -> RepArity -> DynTag
data CallOpts
CallOpts :: !Profile -> !Bool -> !Bool -> CallOpts

-- | Platform profile
[co_profile] :: CallOpts -> !Profile

-- | Loopification enabled (cf <tt>-floopification</tt>)
[co_loopification] :: CallOpts -> !Bool

-- | Ticky profiling enabled (cf <tt>-ticky</tt>)
[co_ticky] :: CallOpts -> !Bool
getCallMethod :: CallOpts -> Name -> Id -> LambdaFormInfo -> RepArity -> RepArity -> CgLoc -> Maybe SelfLoopInfo -> CallMethod
data ClosureInfo
mkClosureInfo :: Profile -> Bool -> Id -> LambdaFormInfo -> Int -> Int -> String -> ClosureInfo

-- | Convert from <a>ClosureInfo</a> to <a>CmmInfoTable</a>.
mkCmmInfo :: ClosureInfo -> Id -> CostCentreStack -> CmmInfoTable
closureLFInfo :: ClosureInfo -> LambdaFormInfo
closureName :: ClosureInfo -> Name
closureInfoLabel :: ClosureInfo -> CLabel
staticClosureLabel :: Platform -> ClosureInfo -> CLabel
closureSlowEntryLabel :: Platform -> ClosureInfo -> CLabel
closureLocalEntryLabel :: Platform -> ClosureInfo -> CLabel
closureUpdReqd :: ClosureInfo -> Bool
closureReEntrant :: ClosureInfo -> Bool
closureFunInfo :: ClosureInfo -> Maybe (RepArity, ArgDescr)
isToplevClosure :: ClosureInfo -> Bool
blackHoleOnEntry :: ClosureInfo -> Bool
isStaticClosure :: ClosureInfo -> Bool
mkDataConInfoTable :: Profile -> DataCon -> ConInfoTableLocation -> Bool -> Int -> Int -> CmmInfoTable
cafBlackHoleInfoTable :: CmmInfoTable
indStaticInfoTable :: CmmInfoTable
staticClosureNeedsLink :: Bool -> CmmInfoTable -> Bool
instance GHC.Show.Show a => GHC.Show.Show (GHC.StgToCmm.Closure.NonVoid a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.StgToCmm.Closure.NonVoid a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.StgToCmm.Closure.NonVoid a)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.StgToCmm.Closure.CgLoc

module GHC.StgToCmm.ArgRep
data ArgRep
P :: ArgRep
N :: ArgRep
L :: ArgRep
V :: ArgRep
F :: ArgRep
D :: ArgRep
V16 :: ArgRep
V32 :: ArgRep
V64 :: ArgRep
toArgRep :: Platform -> PrimRep -> ArgRep
argRepSizeW :: Platform -> ArgRep -> WordOff
argRepString :: ArgRep -> String
isNonV :: ArgRep -> Bool
idArgRep :: Platform -> Id -> ArgRep
slowCallPattern :: [ArgRep] -> (FastString, RepArity)
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.ArgRep.ArgRep

module GHC.StgToCmm.CgUtils

-- | Fixup global registers so that they assign to locations within the
--   RegTable if they aren't pinned for the current target.
fixStgRegisters :: Platform -> RawCmmDecl -> RawCmmDecl
baseRegOffset :: Platform -> GlobalReg -> Int
get_Regtable_addr_from_offset :: Platform -> Int -> CmmExpr
regTableOffset :: Platform -> Int -> CmmExpr

-- | We map STG registers onto appropriate CmmExprs. Either they map to
--   real machine registers or stored as offsets from BaseReg. Given a
--   GlobalReg, get_GlobalReg_addr always produces the register table
--   address for it.
get_GlobalReg_addr :: Platform -> GlobalReg -> CmmExpr


-- | Base LLVM Code Generation module
--   
--   Contains functions useful through out the code generator.
module GHC.CmmToLlvm.Base
type LlvmCmmDecl = GenCmmDecl [LlvmData] (Maybe RawCmmStatics) (ListGraph LlvmStatement)
type LlvmBasicBlock = GenBasicBlock LlvmStatement

-- | Global registers live on proc entry
type LiveGlobalRegs = [GlobalReg]

-- | Unresolved code. Of the form: (data label, data type, unresolved data)
type LlvmUnresData = (CLabel, Section, LlvmType, [UnresStatic])

-- | Top level LLVM Data (globals and type aliases)
type LlvmData = ([LMGlobal], [LlvmType])

-- | An unresolved Label.
--   
--   Labels are unresolved when we haven't yet determined if they are
--   defined in the module we are currently compiling, or an external one.
type UnresLabel = CmmLit
type UnresStatic = Either UnresLabel LlvmStatic
data LlvmVersion

-- | The (inclusive) lower bound on the LLVM Version that is currently
--   supported.
supportedLlvmVersionLowerBound :: LlvmVersion

-- | The (not-inclusive) upper bound bound on the LLVM Version that is
--   currently supported.
supportedLlvmVersionUpperBound :: LlvmVersion
llvmVersionSupported :: LlvmVersion -> Bool
parseLlvmVersion :: String -> Maybe LlvmVersion
llvmVersionStr :: LlvmVersion -> String
llvmVersionList :: LlvmVersion -> [Int]

-- | The Llvm monad. Wraps <tt>LlvmEnv</tt> state as well as the
--   <tt>IO</tt> monad
data LlvmM a

-- | Get initial Llvm environment.
runLlvm :: Logger -> DynFlags -> LlvmVersion -> BufHandle -> LlvmM a -> IO a

-- | Clear variables from the environment for a subcomputation
withClearVars :: LlvmM a -> LlvmM a

-- | Lookup variables or functions in the environment.
varLookup :: Uniquable key => key -> LlvmM (Maybe LlvmType)

-- | Insert variables or functions into the environment.
varInsert :: Uniquable key => key -> LlvmType -> LlvmM ()

-- | Set a register as allocated on the stack
markStackReg :: GlobalReg -> LlvmM ()

-- | Check whether a register is allocated on the stack
checkStackReg :: GlobalReg -> LlvmM Bool

-- | Lookup variables or functions in the environment.
funLookup :: Uniquable key => key -> LlvmM (Maybe LlvmType)

-- | Insert variables or functions into the environment.
funInsert :: Uniquable key => key -> LlvmType -> LlvmM ()

-- | Get the LLVM version we are generating code for
getLlvmVer :: LlvmM LlvmVersion
getDynFlags :: HasDynFlags m => m DynFlags

-- | Dumps the document if the corresponding flag has been set by the user
dumpIfSetLlvm :: DumpFlag -> String -> DumpFormat -> SDoc -> LlvmM ()

-- | Prints the given contents to the output handle
renderLlvm :: SDoc -> LlvmM ()

-- | Marks a variable as "used"
markUsedVar :: LlvmVar -> LlvmM ()

-- | Return all variables marked as "used" so far
getUsedVars :: LlvmM [LlvmVar]

-- | Here we pre-initialise some functions that are used internally by GHC
--   so as to make sure they have the most general type in the case that
--   user code also uses these functions but with a different type than GHC
--   internally. (Main offender is treating return type as <tt>void</tt>
--   instead of 'void *'). Fixes trac #5486.
ghcInternalFunctions :: LlvmM ()

-- | Get target platform
getPlatform :: LlvmM Platform

-- | Get LLVM options
getLlvmOpts :: LlvmM LlvmOpts

-- | Allocate a new global unnamed metadata identifier
getMetaUniqueId :: LlvmM MetaId

-- | Sets metadata node for a given unique
setUniqMeta :: Unique -> MetaId -> LlvmM ()

-- | Gets metadata node for given unique
getUniqMeta :: Unique -> LlvmM (Maybe MetaId)

-- | Lifting of IO actions. Not exported, as we want to encapsulate IO.
liftIO :: IO a -> LlvmM a

-- | Translate a basic CmmType to an LlvmType.
cmmToLlvmType :: CmmType -> LlvmType

-- | Translate a Cmm Float Width to a LlvmType.
widthToLlvmFloat :: Width -> LlvmType

-- | Translate a Cmm Bit Width to a LlvmType.
widthToLlvmInt :: Width -> LlvmType

-- | Llvm Function type for Cmm function
llvmFunTy :: LiveGlobalRegs -> LlvmM LlvmType

-- | Llvm Function signature
llvmFunSig :: LiveGlobalRegs -> CLabel -> LlvmLinkageType -> LlvmM LlvmFunctionDecl

-- | A Function's arguments
llvmFunArgs :: Platform -> LiveGlobalRegs -> [LlvmVar]

-- | Llvm standard fun attributes
llvmStdFunAttrs :: [LlvmFuncAttr]

-- | Alignment to use for functions
llvmFunAlign :: Platform -> LMAlign

-- | Alignment to use for into tables
llvmInfAlign :: Platform -> LMAlign

-- | Pointer width
llvmPtrBits :: Platform -> Int

-- | Convert a list of types to a list of function parameters (each with no
--   parameter attributes)
tysToParams :: [LlvmType] -> [LlvmParameter]

-- | Section to use for a function
llvmFunSection :: LlvmOpts -> LMString -> LMSection

-- | Return a list of "padding" registers for LLVM function calls.
--   
--   When we generate LLVM function signatures, we can't just make any
--   register alive on function entry. Instead, we need to insert fake
--   arguments of the same register class until we are sure that one of
--   them is mapped to the register we want alive. E.g. to ensure that F5
--   is alive, we may need to insert fake arguments mapped to F1, F2, F3
--   and F4.
--   
--   Invariant: Cmm FPR regs with number "n" maps to real registers with
--   number "n" If the calling convention uses registers in a different
--   order or if the invariant doesn't hold, this code probably won't be
--   correct.
padLiveArgs :: Platform -> LiveGlobalRegs -> LiveGlobalRegs
isFPR :: GlobalReg -> Bool

-- | Pretty print a <a>CLabel</a>.
strCLabel_llvm :: CLabel -> LlvmM LMString

-- | Create/get a pointer to a global value. Might return an alias if the
--   value in question hasn't been defined yet. We especially make no
--   guarantees on the type of the returned pointer.
getGlobalPtr :: LMString -> LlvmM LlvmVar

-- | Generate definitions for aliases forward-referenced by
--   <tt>getGlobalPtr</tt>.
--   
--   Must be called at a point where we are sure that no new global
--   definitions will be generated anymore!
generateExternDecls :: LlvmM ([LMGlobal], [LlvmType])

-- | Here we take a global variable definition, rename it with a
--   <tt>$def</tt> suffix, and generate the appropriate alias.
aliasify :: LMGlobal -> LlvmM [LMGlobal]

-- | Derive the definition label. It has an identified structure type.
llvmDefLabel :: LMString -> LMString
instance GHC.Classes.Ord GHC.CmmToLlvm.Base.LlvmVersion
instance GHC.Classes.Eq GHC.CmmToLlvm.Base.LlvmVersion
instance GHC.Base.Functor GHC.CmmToLlvm.Base.LlvmM
instance GHC.Base.Applicative GHC.CmmToLlvm.Base.LlvmM
instance GHC.Base.Monad GHC.CmmToLlvm.Base.LlvmM
instance GHC.Driver.Session.HasDynFlags GHC.CmmToLlvm.Base.LlvmM
instance GHC.Utils.Logger.HasLogger GHC.CmmToLlvm.Base.LlvmM
instance GHC.Types.Unique.Supply.MonadUnique GHC.CmmToLlvm.Base.LlvmM

module GHC.SysTools.Tasks
runUnlit :: Logger -> DynFlags -> [Option] -> IO ()
runCpp :: Logger -> DynFlags -> [Option] -> IO ()
runPp :: Logger -> DynFlags -> [Option] -> IO ()

-- | Run compiler of C-like languages and raw objects (such as gcc or
--   clang).
runCc :: Maybe ForeignSrcLang -> Logger -> TmpFs -> DynFlags -> [Option] -> IO ()
isContainedIn :: String -> String -> Bool

-- | Run the linker with some arguments and return the output
askLd :: Logger -> DynFlags -> [Option] -> IO String
runAs :: Logger -> DynFlags -> [Option] -> IO ()

-- | Run the LLVM Optimiser
runLlvmOpt :: Logger -> DynFlags -> [Option] -> IO ()

-- | Run the LLVM Compiler
runLlvmLlc :: Logger -> DynFlags -> [Option] -> IO ()

-- | Run the clang compiler (used as an assembler for the LLVM backend on
--   OS X as LLVM doesn't support the OS X system assembler)
runClang :: Logger -> DynFlags -> [Option] -> IO ()

-- | Figure out which version of LLVM we are running this session
figureLlvmVersion :: Logger -> DynFlags -> IO (Maybe LlvmVersion)
runLink :: Logger -> TmpFs -> DynFlags -> [Option] -> IO ()
runMergeObjects :: Logger -> TmpFs -> DynFlags -> [Option] -> IO ()
runLibtool :: Logger -> DynFlags -> [Option] -> IO ()
runAr :: Logger -> DynFlags -> Maybe FilePath -> [Option] -> IO ()
askOtool :: Logger -> DynFlags -> Maybe FilePath -> [Option] -> IO String
runInstallNameTool :: Logger -> DynFlags -> [Option] -> IO ()
runRanlib :: Logger -> DynFlags -> [Option] -> IO ()
runWindres :: Logger -> DynFlags -> [Option] -> IO ()
touch :: Logger -> DynFlags -> String -> String -> IO ()

-- | Record in the eventlog when the given tool command starts and
--   finishes, prepending the given <a>String</a> with "systool:", to
--   easily be able to collect and process all the systool events.
--   
--   For those events to show up in the eventlog, you need to run GHC with
--   <tt>-v2</tt> or <tt>-ddump-timings</tt>.
traceToolCommand :: Logger -> DynFlags -> String -> IO a -> IO a

module GHC.Linker.MacOS

-- | On macOS we rely on the linkers <tt>-dead_strip_dylibs</tt> flag to
--   remove unused libraries from the dynamic library. We do this to reduce
--   the number of load commands that end up in the dylib, and has been
--   limited to 32K (32768) since macOS Sierra (10.14).
--   
--   <tt>-dead_strip_dylibs</tt> does not dead strip <tt>-rpath</tt>
--   entries, as such passing <tt>-l</tt> and <tt>-rpath</tt> to the linker
--   will result in the unnecesasry libraries not being included in the
--   load commands, however the <tt>-rpath</tt> entries are all forced to
--   be included. This can lead to 100s of <tt>-rpath</tt> entries being
--   included when only a handful of libraries end up being truly linked.
--   
--   Thus after building the library, we run a fixup phase where we inject
--   the <tt>-rpath</tt> for each found library (in the given library
--   search paths) into the dynamic library through <tt>-add_rpath</tt>.
--   
--   See Note [Dynamic linking on macOS]
runInjectRPaths :: Logger -> DynFlags -> [FilePath] -> FilePath -> IO ()
getUnitFrameworkOpts :: UnitEnv -> [UnitId] -> IO [String]
getFrameworkOpts :: DynFlags -> Platform -> [String]
loadFramework :: Interp -> [FilePath] -> FilePath -> IO (Maybe String)

module GHC.Linker.ExtraObj
mkExtraObj :: Logger -> TmpFs -> DynFlags -> UnitState -> Suffix -> String -> IO FilePath
mkExtraObjToLinkIntoBinary :: Logger -> TmpFs -> DynFlags -> UnitState -> IO (Maybe FilePath)
mkNoteObjsToLinkIntoBinary :: Logger -> TmpFs -> DynFlags -> UnitEnv -> [UnitId] -> IO [FilePath]
checkLinkInfo :: Logger -> DynFlags -> UnitEnv -> [UnitId] -> FilePath -> IO Bool

-- | Return the "link info" string
--   
--   See Note [LinkInfo section]
getLinkInfo :: DynFlags -> UnitEnv -> [UnitId] -> IO String
getCompilerInfo :: Logger -> DynFlags -> IO CompilerInfo
ghcLinkInfoSectionName :: String
ghcLinkInfoNoteName :: String
platformSupportsSavingLinkOpts :: OS -> Bool
haveRtsOptsFlags :: DynFlags -> Bool

module GHC.SysTools
initSysTools :: String -> IO Settings
lazyInitLlvmConfig :: String -> IO LlvmConfig
copy :: Logger -> DynFlags -> String -> FilePath -> FilePath -> IO ()
copyWithHeader :: Logger -> DynFlags -> String -> Maybe String -> FilePath -> FilePath -> IO ()

-- | When invoking external tools as part of the compilation pipeline, we
--   pass these a sequence of options on the command-line. Rather than just
--   using a list of Strings, we use a type that allows us to distinguish
--   between filepaths and 'other stuff'. The reason for this is that this
--   type gives us a handle on transforming filenames, and filenames only,
--   to whatever format they're expected to be on a particular platform.
data Option
FileOption :: String -> String -> Option
Option :: String -> Option

-- | Expand occurrences of the <tt>$topdir</tt> interpolation in a string.
expandTopDir :: FilePath -> String -> String

module GHC.Linker.Windows
maybeCreateManifest :: Logger -> TmpFs -> DynFlags -> FilePath -> IO [FilePath]


-- | Dynamic linker
module GHC.Linker.Dynamic
linkDynLib :: Logger -> TmpFs -> DynFlags -> UnitEnv -> [String] -> [UnitId] -> IO ()

-- | Some platforms require that we explicitly link against <tt>libm</tt>
--   if any math-y things are used (which we assume to include all
--   programs). See #14022.
libmLinkOpts :: [Option]

module GHC.Linker.Static
linkBinary :: Logger -> TmpFs -> DynFlags -> UnitEnv -> [FilePath] -> [UnitId] -> IO ()
linkBinary' :: Bool -> Logger -> TmpFs -> DynFlags -> UnitEnv -> [FilePath] -> [UnitId] -> IO ()

-- | Linking a static lib will not really link anything. It will merely
--   produce a static archive of all dependent static libraries. The
--   resulting library will still need to be linked with any remaining link
--   flags.
linkStaticLib :: Logger -> DynFlags -> UnitEnv -> [String] -> [UnitId] -> IO ()

-- | Compute the output file name of a program.
--   
--   StaticLink boolean is used to indicate if the program is actually a
--   static library (e.g., on iOS).
--   
--   Use the provided filename (if any), otherwise use "main.exe"
--   (Windows), "a.out (otherwise without StaticLink set), "liba.a". In
--   every case, add the extension if it is missing.
exeFileName :: Platform -> Bool -> Maybe FilePath -> FilePath


-- | Handle conversion of CmmData to LLVM code.
module GHC.CmmToLlvm.Data

-- | Pass a CmmStatic section to an equivalent Llvm code.
genLlvmData :: (Section, RawCmmStatics) -> LlvmM LlvmData

-- | Handle static data
genData :: CmmStatic -> LlvmM LlvmStatic


-- | Pretty print helpers for the LLVM Code generator.
module GHC.CmmToLlvm.Ppr

-- | Pretty print LLVM code
pprLlvmCmmDecl :: LlvmCmmDecl -> LlvmM (SDoc, [LlvmVar])

-- | Pretty print LLVM data code
pprLlvmData :: LlvmOpts -> LlvmData -> SDoc

-- | The section we are putting info tables and their entry code into,
--   should be unique since we process the assembly pattern matching this.
infoSection :: String

module GHC.Cmm.Switch.Implement

-- | Traverses the <a>GenCmmGraph</a>, making sure that <a>CmmSwitch</a>
--   are suitable for code generation.
cmmImplementSwitchPlans :: Backend -> Platform -> CmmGraph -> UniqSM CmmGraph

module GHC.Cmm.Ppr.Decl
pprCmms :: (OutputableP Platform info, OutputableP Platform g) => Platform -> [GenCmmGroup RawCmmStatics info g] -> SDoc
pprCmmGroup :: (OutputableP Platform d, OutputableP Platform info, OutputableP Platform g) => Platform -> GenCmmGroup d info g -> SDoc
pprSection :: Platform -> Section -> SDoc
pprStatic :: Platform -> CmmStatic -> SDoc
instance (GHC.Utils.Outputable.OutputableP GHC.Platform.Platform d, GHC.Utils.Outputable.OutputableP GHC.Platform.Platform info, GHC.Utils.Outputable.OutputableP GHC.Platform.Platform i) => GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.GenCmmDecl d info i)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.GenCmmStatics a)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CmmStatic
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CmmInfoTable
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Type.ForeignHint

module GHC.Cmm.Ppr
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CmmStackInfo
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CmmTopInfo
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Node.CmmNode e x)
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Node.Convention
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Node.ForeignConvention
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.Node.ForeignTarget
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Node.CmmReturnInfo
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Block.Block GHC.Cmm.Node.CmmNode GHC.Cmm.Dataflow.Block.C GHC.Cmm.Dataflow.Block.C)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Block.Block GHC.Cmm.Node.CmmNode GHC.Cmm.Dataflow.Block.C GHC.Cmm.Dataflow.Block.O)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Block.Block GHC.Cmm.Node.CmmNode GHC.Cmm.Dataflow.Block.O GHC.Cmm.Dataflow.Block.C)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Block.Block GHC.Cmm.Node.CmmNode GHC.Cmm.Dataflow.Block.O GHC.Cmm.Dataflow.Block.O)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Graph.Graph GHC.Cmm.Node.CmmNode e x)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CmmGraph


-- | Handle conversion of CmmProc to LLVM code.
module GHC.CmmToLlvm.CodeGen

-- | Top-level of the LLVM proc Code generator
genLlvmProc :: RawCmmDecl -> LlvmM [LlvmCmmDecl]
instance GHC.Show.Show GHC.CmmToLlvm.CodeGen.Signage
instance GHC.Classes.Eq GHC.CmmToLlvm.CodeGen.Signage
instance GHC.Base.Semigroup GHC.CmmToLlvm.CodeGen.LlvmAccum
instance GHC.Base.Monoid GHC.CmmToLlvm.CodeGen.LlvmAccum


-- | This is the top-level module in the LLVM code generator.
module GHC.CmmToLlvm
data LlvmVersion
llvmVersionList :: LlvmVersion -> [Int]

-- | Top-level of the LLVM Code generator
llvmCodeGen :: Logger -> DynFlags -> Handle -> Stream IO RawCmmGroup a -> IO a

-- | Read in assembly file and process
llvmFixupAsm :: Logger -> DynFlags -> FilePath -> FilePath -> IO ()

module GHC.CmmToC
cmmToC :: Platform -> RawCmmGroup -> SDoc
instance GHC.Base.Functor GHC.CmmToC.TE
instance GHC.Base.Applicative GHC.CmmToC.TE
instance GHC.Base.Monad GHC.CmmToC.TE

module GHC.CmmToAsm.SPARC.Ppr
pprNatCmmDecl :: NCGConfig -> NatCmmDecl RawCmmStatics Instr -> SDoc
pprBasicBlock :: Platform -> LabelMap RawCmmStatics -> NatBasicBlock Instr -> SDoc
pprData :: Platform -> CmmStatic -> SDoc

-- | Pretty print an instruction.
pprInstr :: Platform -> Instr -> SDoc

-- | Pretty print a format for an instruction suffix.
pprFormat :: Format -> SDoc

-- | Pretty print an immediate value.
pprImm :: Platform -> Imm -> SDoc

-- | Pretty print a data item.
pprDataItem :: Platform -> CmmLit -> SDoc
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.CmmToAsm.SPARC.Instr.Instr


-- | One ounce of sanity checking is worth 10000000000000000 ounces of
--   staring blindly at assembly code trying to find the problem..
module GHC.CmmToAsm.SPARC.CodeGen.Sanity

-- | Enforce intra-block invariants.
checkBlock :: Platform -> CmmBlock -> NatBasicBlock Instr -> NatBasicBlock Instr

module GHC.CmmToAsm.CFG

-- | A control flow graph where edges have been annotated with a weight.
--   Implemented as IntMap (IntMap &lt;edgeData&gt;) We must uphold the
--   invariant that for each edge A -&gt; B we must have: A entry B in the
--   outer map. A entry B in the map we get when looking up A. Maintaining
--   this invariant is useful as any failed lookup now indicates an actual
--   error in code which might go unnoticed for a while otherwise.
type CFG = EdgeInfoMap EdgeInfo
data CfgEdge
CfgEdge :: !BlockId -> !BlockId -> !EdgeInfo -> CfgEdge
[edgeFrom] :: CfgEdge -> !BlockId
[edgeTo] :: CfgEdge -> !BlockId
[edgeInfo] :: CfgEdge -> !EdgeInfo

-- | Information about edges
data EdgeInfo
EdgeInfo :: !TransitionSource -> !EdgeWeight -> EdgeInfo
[transitionSource] :: EdgeInfo -> !TransitionSource
[edgeWeight] :: EdgeInfo -> !EdgeWeight
newtype EdgeWeight
EdgeWeight :: Double -> EdgeWeight
[weightToDouble] :: EdgeWeight -> Double

-- | Can we trace back a edge to a specific Cmm Node or has it been
--   introduced during assembly codegen. We use this to maintain some
--   information which would otherwise be lost during the Cmm &lt;-&gt; asm
--   transition. See also Note [Inverting Conditional Branches]
data TransitionSource
CmmSource :: CmmNode O C -> BranchInfo -> TransitionSource
[trans_cmmNode] :: TransitionSource -> CmmNode O C
[trans_info] :: TransitionSource -> BranchInfo
AsmCodeGen :: TransitionSource

-- | Adds a edge with the given weight to the cfg If there already existed
--   an edge it is overwritten. `addWeightEdge from to weight cfg`
addWeightEdge :: BlockId -> BlockId -> EdgeWeight -> CFG -> CFG

-- | Adds a new edge, overwrites existing edges if present
addEdge :: BlockId -> BlockId -> EdgeInfo -> CFG -> CFG
delEdge :: BlockId -> BlockId -> CFG -> CFG

-- | Insert a block in the control flow between two other blocks. We pass a
--   list of tuples (A,B,C) where * A -&gt; C: Old edge * A -&gt; B -&gt; C
--   : New Arc, where B is the new block. It's possible that a block has
--   two jumps to the same block in the assembly code. However we still
--   only store a single edge for these cases. We assign the old edge info
--   to the edge A -&gt; B and assign B -&gt; C the weight of an
--   unconditional jump.
addNodesBetween :: Weights -> CFG -> [(BlockId, BlockId, BlockId)] -> CFG
shortcutWeightMap :: LabelMap (Maybe BlockId) -> CFG -> CFG
reverseEdges :: CFG -> CFG

-- | Filter the CFG with a custom function f. Paramaeters are `f from to
--   edgeInfo`
filterEdges :: (BlockId -> BlockId -> EdgeInfo -> Bool) -> CFG -> CFG

-- | Sometimes we insert a block which should unconditionally be executed
--   after a given block. This function updates the CFG for these cases. So
--   we get A -&gt; B =&gt; A -&gt; A' -&gt; B -- -&gt; C =&gt; -&gt; C
addImmediateSuccessor :: Weights -> BlockId -> BlockId -> CFG -> CFG

-- | Convenience function, generate edge info based on weight not
--   originating from cmm.
mkWeightInfo :: EdgeWeight -> EdgeInfo

-- | Adjust the weight between the blocks using the given function. If
--   there is no such edge returns the original map.
adjustEdgeWeight :: CFG -> (EdgeWeight -> EdgeWeight) -> BlockId -> BlockId -> CFG

-- | Set the weight between the blocks to the given weight. If there is no
--   such edge returns the original map.
setEdgeWeight :: CFG -> EdgeWeight -> BlockId -> BlockId -> CFG

-- | Returns a unordered list of all edges with info
infoEdgeList :: CFG -> [CfgEdge]

-- | Returns a unordered list of all edges without weights
edgeList :: CFG -> [Edge]

-- | Get successors of a given node with edge weights.
getSuccessorEdges :: HasDebugCallStack => CFG -> BlockId -> [(BlockId, EdgeInfo)]

-- | Get successors of a given node without edge weights.
getSuccessors :: HasDebugCallStack => CFG -> BlockId -> [BlockId]

-- | Destinations from bid ordered by weight (descending)
getSuccEdgesSorted :: CFG -> BlockId -> [(BlockId, EdgeInfo)]
getEdgeInfo :: BlockId -> BlockId -> CFG -> Maybe EdgeInfo
getCfgNodes :: CFG -> [BlockId]

-- | Is this block part of this graph?
hasNode :: CFG -> BlockId -> Bool

-- | Determine loop membership of blocks based on SCC analysis This is
--   faster but only gives yes/no answers.
loopMembers :: HasDebugCallStack => CFG -> LabelMap Bool
loopLevels :: CFG -> BlockId -> LabelMap Int

-- | Determine loop membership of blocks based on Dominator analysis. This
--   is slower but gives loop levels instead of just loop membership.
--   However it only detects natural loops. Irreducible control flow is not
--   recognized even if it loops. But that is rare enough that we don't
--   have to care about that special case.
loopInfo :: HasDebugCallStack => CFG -> BlockId -> LoopInfo
getCfg :: Platform -> Weights -> CmmGraph -> CFG

-- | Generate weights for a Cmm proc based on some simple heuristics.
getCfgProc :: Platform -> Weights -> RawCmmDecl -> CFG
pprEdgeWeights :: CFG -> SDoc

-- | Check if the nodes in the cfg and the set of blocks are the same. In a
--   case of a missmatch we panic and show the difference.
sanityCheckCfg :: CFG -> LabelSet -> SDoc -> Bool
optimizeCFG :: Bool -> Weights -> RawCmmDecl -> CFG -> CFG

-- | We take in a CFG which has on its edges weights which are relative
--   only to other edges originating from the same node.
--   
--   We return a CFG for which each edge represents a GLOBAL weight. This
--   means edge weights are comparable across the whole graph.
--   
--   For irreducible control flow results might be imprecise, otherwise
--   they are reliable.
--   
--   The algorithm is based on the Paper "Static Branch Prediction and
--   Program Profile Analysis" by Y Wu, JR Larus The only big change is
--   that we go over the nodes in the body of loops in reverse post order.
--   Which is required for diamond control flow to work probably.
--   
--   We also apply a few prediction heuristics (based on the same paper)
--   
--   The returned result represents frequences. For blocks it's the
--   expected number of executions and for edges is the number of
--   traversals.
mkGlobalWeights :: HasDebugCallStack => BlockId -> CFG -> (LabelMap Double, LabelMap (LabelMap Double))
instance GHC.Real.Fractional GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Real.Real GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Num.Num GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Enum.Enum GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Classes.Ord GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.BranchInfo
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.TransitionSource
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.EdgeInfo
instance GHC.Cmm.Dataflow.Graph.NonLocal GHC.CmmToAsm.CFG.BlockNode
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.LoopInfo
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.CfgEdge
instance GHC.Classes.Ord GHC.CmmToAsm.CFG.CfgEdge
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.CfgEdge
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.EdgeInfo
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.BranchInfo
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.EdgeWeight

module GHC.CmmToAsm.Reg.Liveness
type RegSet = UniqSet Reg

-- | Map from some kind of register to a.
--   
--   While we give the type for keys as Reg which is the common case
--   sometimes we end up using VirtualReq or naked Uniques. See Note
--   [UniqFM and the register allocator]
type RegMap a = UniqFM Reg a
emptyRegMap :: RegMap a
type BlockMap a = LabelMap a
mapEmpty :: IsMap map => map a

-- | A top level thing which carries liveness information.
type LiveCmmDecl statics instr = GenCmmDecl statics LiveInfo [SCC (LiveBasicBlock instr)]

-- | The register allocator also wants to use SPILL/RELOAD meta
--   instructions, so we'll keep those here.
data InstrSR instr

-- | A real machine instruction
Instr :: instr -> InstrSR instr

-- | spill this reg to a stack slot
SPILL :: Reg -> Int -> InstrSR instr

-- | reload this reg from a stack slot
RELOAD :: Int -> Reg -> InstrSR instr

-- | An instruction with liveness information.
data LiveInstr instr
LiveInstr :: InstrSR instr -> Maybe Liveness -> LiveInstr instr

-- | Liveness information. The regs which die are ones which are no longer
--   live in the *next* instruction in this sequence. (NB. if the
--   instruction is a jump, these registers might still be live at the jump
--   target(s) - you have to check the liveness at the destination block to
--   find out).
data Liveness
Liveness :: RegSet -> RegSet -> RegSet -> Liveness

-- | registers born in this instruction (written to for first time).
[liveBorn] :: Liveness -> RegSet

-- | registers that died because they were read for the last time.
[liveDieRead] :: Liveness -> RegSet

-- | registers that died because they were clobbered by something.
[liveDieWrite] :: Liveness -> RegSet

-- | Stash regs live on entry to each basic block in the info part of the
--   cmm code.
data LiveInfo
LiveInfo :: LabelMap RawCmmStatics -> [BlockId] -> BlockMap RegSet -> BlockMap IntSet -> LiveInfo

-- | A basic block with liveness information.
type LiveBasicBlock instr = GenBasicBlock (LiveInstr instr)

-- | map a function across all the basic blocks in this code
mapBlockTop :: (LiveBasicBlock instr -> LiveBasicBlock instr) -> LiveCmmDecl statics instr -> LiveCmmDecl statics instr

-- | map a function across all the basic blocks in this code (monadic
--   version)
mapBlockTopM :: Monad m => (LiveBasicBlock instr -> m (LiveBasicBlock instr)) -> LiveCmmDecl statics instr -> m (LiveCmmDecl statics instr)
mapSCCM :: Monad m => (a -> m b) -> SCC a -> m (SCC b)
mapGenBlockTop :: (GenBasicBlock i -> GenBasicBlock i) -> GenCmmDecl d h (ListGraph i) -> GenCmmDecl d h (ListGraph i)

-- | map a function across all the basic blocks in this code (monadic
--   version)
mapGenBlockTopM :: Monad m => (GenBasicBlock i -> m (GenBasicBlock i)) -> GenCmmDecl d h (ListGraph i) -> m (GenCmmDecl d h (ListGraph i))

-- | Map over instruction type in <a>LiveCmmDecl</a>
mapLiveCmmDecl :: (instr -> b) -> LiveCmmDecl statics instr -> LiveCmmDecl statics b

-- | Pretty-print a <a>LiveCmmDecl</a>
pprLiveCmmDecl :: (OutputableP Platform statics, Instruction instr) => Platform -> LiveCmmDecl statics instr -> SDoc

-- | Strip away liveness information, yielding NatCmmDecl
stripLive :: (OutputableP Platform statics, Instruction instr) => NCGConfig -> LiveCmmDecl statics instr -> NatCmmDecl statics instr

-- | Strip away liveness information from a basic block, and make real
--   spill instructions out of SPILL, RELOAD pseudos along the way.
stripLiveBlock :: Instruction instr => NCGConfig -> LiveBasicBlock instr -> NatBasicBlock instr

-- | Slurp out the list of register conflicts and reg-reg moves from this
--   top level thing. Slurping of conflicts and moves is wrapped up
--   together so we don't have to make two passes over the same code when
--   we want to build the graph.
slurpConflicts :: Instruction instr => LiveCmmDecl statics instr -> (Bag (UniqSet Reg), Bag (Reg, Reg))

-- | For spill/reloads
--   
--   SPILL v1, slot1 ... RELOAD slot1, v2
--   
--   If we can arrange that v1 and v2 are allocated to the same hreg it's
--   more likely the spill/reload instrs can be cleaned and replaced by a
--   nop reg-reg move.
slurpReloadCoalesce :: forall statics instr. Instruction instr => LiveCmmDecl statics instr -> Bag (Reg, Reg)

-- | Erase Delta instructions.
eraseDeltasLive :: Instruction instr => LiveCmmDecl statics instr -> LiveCmmDecl statics instr

-- | Patch the registers in this code according to this register mapping.
--   also erase reg -&gt; reg moves when the reg is the same. also erase
--   reg -&gt; reg moves when the destination dies in this instr.
patchEraseLive :: Instruction instr => (Reg -> Reg) -> LiveCmmDecl statics instr -> LiveCmmDecl statics instr

-- | Patch registers in this LiveInstr, including the liveness information.
patchRegsLiveInstr :: Instruction instr => (Reg -> Reg) -> LiveInstr instr -> LiveInstr instr

-- | If we've compute liveness info for this code already we have to
--   reverse the SCCs in each top to get them back to the right order so we
--   can do it again.
reverseBlocksInTops :: LiveCmmDecl statics instr -> LiveCmmDecl statics instr
regLiveness :: Instruction instr => Platform -> LiveCmmDecl statics instr -> UniqSM (LiveCmmDecl statics instr)

-- | Convert a NatCmmDecl to a LiveCmmDecl, with liveness information
cmmTopLiveness :: Instruction instr => Maybe CFG -> Platform -> NatCmmDecl statics instr -> UniqSM (LiveCmmDecl statics instr)
instance GHC.Base.Functor GHC.CmmToAsm.Reg.Liveness.InstrSR
instance GHC.Base.Functor GHC.CmmToAsm.Reg.Liveness.LiveInstr
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.CmmToAsm.Reg.Liveness.LiveInfo
instance GHC.Utils.Outputable.Outputable instr => GHC.Utils.Outputable.Outputable (GHC.CmmToAsm.Reg.Liveness.LiveInstr instr)
instance GHC.Utils.Outputable.OutputableP env instr => GHC.Utils.Outputable.OutputableP env (GHC.CmmToAsm.Reg.Liveness.LiveInstr instr)
instance GHC.CmmToAsm.Instr.Instruction instr => GHC.CmmToAsm.Instr.Instruction (GHC.CmmToAsm.Reg.Liveness.InstrSR instr)
instance GHC.Utils.Outputable.Outputable instr => GHC.Utils.Outputable.Outputable (GHC.CmmToAsm.Reg.Liveness.InstrSR instr)


-- | Put common type definitions here to break recursive module
--   dependencies.
module GHC.CmmToAsm.Reg.Linear.Base

-- | Used to store the register assignment on entry to a basic block. We
--   use this to handle join points, where multiple branch instructions
--   target a particular label. We have to insert fixup code to make the
--   register assignments from the different sources match up.
data BlockAssignment freeRegs

-- | Find the register mapping for a specific BlockId.
lookupBlockAssignment :: BlockId -> BlockAssignment freeRegs -> Maybe (freeRegs, RegMap Loc)

-- | Lookup which register a virtual register was first assigned to.
lookupFirstUsed :: VirtualReg -> BlockAssignment freeRegs -> Maybe RealReg

-- | An initial empty <a>BlockAssignment</a>
emptyBlockAssignment :: BlockAssignment freeRegs

-- | Add new register mappings for a specific block.
updateBlockAssignment :: BlockId -> (freeRegs, RegMap Loc) -> BlockAssignment freeRegs -> BlockAssignment freeRegs

-- | Where a vreg is currently stored A temporary can be marked as living
--   in both a register and memory (InBoth), for example if it was recently
--   loaded from a spill location. This makes it cheap to spill (no save
--   instruction required), but we have to be careful to turn this into
--   InReg if the value in the register is changed.
data Loc

-- | vreg is in a register
InReg :: !RealReg -> Loc

-- | vreg is held in a stack slot
InMem :: {-# UNPACK #-} !StackSlot -> Loc

-- | vreg is held in both a register and a stack slot
InBoth :: !RealReg -> {-# UNPACK #-} !StackSlot -> Loc

-- | Get the reg numbers stored in this Loc.
regsOfLoc :: Loc -> [RealReg]

-- | Reasons why instructions might be inserted by the spiller. Used when
--   generating stats for -ddrop-asm-stats.
data SpillReason

-- | vreg was spilled to a slot so we could use its current hreg for
--   another vreg
SpillAlloc :: !Unique -> SpillReason

-- | vreg was moved because its hreg was clobbered
SpillClobber :: !Unique -> SpillReason

-- | vreg was loaded from a spill slot
SpillLoad :: !Unique -> SpillReason

-- | reg-reg move inserted during join to targets
SpillJoinRR :: !Unique -> SpillReason

-- | reg-mem move inserted during join to targets
SpillJoinRM :: !Unique -> SpillReason

-- | Used to carry interesting stats out of the register allocator.
data RegAllocStats
RegAllocStats :: UniqFM Unique [Int] -> [(BlockId, BlockId, BlockId)] -> RegAllocStats
[ra_spillInstrs] :: RegAllocStats -> UniqFM Unique [Int]

-- | (from,fixup,to) : We inserted fixup code between from and to
[ra_fixupList] :: RegAllocStats -> [(BlockId, BlockId, BlockId)]

-- | The register allocator state
data RA_State freeRegs
RA_State :: BlockAssignment freeRegs -> !freeRegs -> RegMap Loc -> Int -> StackMap -> UniqSupply -> [SpillReason] -> !NCGConfig -> [(BlockId, BlockId, BlockId)] -> RA_State freeRegs

-- | the current mapping from basic blocks to the register assignments at
--   the beginning of that block.
[ra_blockassig] :: RA_State freeRegs -> BlockAssignment freeRegs

-- | free machine registers
[ra_freeregs] :: RA_State freeRegs -> !freeRegs

-- | assignment of temps to locations
[ra_assig] :: RA_State freeRegs -> RegMap Loc

-- | current stack delta
[ra_delta] :: RA_State freeRegs -> Int

-- | free stack slots for spilling
[ra_stack] :: RA_State freeRegs -> StackMap

-- | unique supply for generating names for join point fixup blocks.
[ra_us] :: RA_State freeRegs -> UniqSupply

-- | Record why things were spilled, for -ddrop-asm-stats. Just keep a list
--   here instead of a map of regs -&gt; reasons. We don't want to slow
--   down the allocator if we're not going to emit the stats.
[ra_spills] :: RA_State freeRegs -> [SpillReason]

-- | Native code generator configuration
[ra_config] :: RA_State freeRegs -> !NCGConfig

-- | (from,fixup,to) : We inserted fixup code between from and to
[ra_fixups] :: RA_State freeRegs -> [(BlockId, BlockId, BlockId)]
instance GHC.Classes.Ord GHC.CmmToAsm.Reg.Linear.Base.ReadingOrWriting
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Linear.Base.ReadingOrWriting
instance GHC.Classes.Ord GHC.CmmToAsm.Reg.Linear.Base.Loc
instance GHC.Show.Show GHC.CmmToAsm.Reg.Linear.Base.Loc
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Linear.Base.Loc
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.Base.Loc

module GHC.CmmToAsm.Reg.Linear.Stats

-- | Build a map of how many times each reg was alloced, clobbered, loaded
--   etc.
binSpillReasons :: [SpillReason] -> UniqFM Unique [Int]

-- | Count reg-reg moves remaining in this code.
countRegRegMovesNat :: Instruction instr => NatCmmDecl statics instr -> Int

-- | Pretty print some RegAllocStats
pprStats :: Instruction instr => [NatCmmDecl statics instr] -> [RegAllocStats] -> SDoc


-- | State monad for the linear register allocator.
module GHC.CmmToAsm.Reg.Linear.State

-- | The register allocator state
data RA_State freeRegs
RA_State :: BlockAssignment freeRegs -> !freeRegs -> RegMap Loc -> Int -> StackMap -> UniqSupply -> [SpillReason] -> !NCGConfig -> [(BlockId, BlockId, BlockId)] -> RA_State freeRegs

-- | the current mapping from basic blocks to the register assignments at
--   the beginning of that block.
[ra_blockassig] :: RA_State freeRegs -> BlockAssignment freeRegs

-- | free machine registers
[ra_freeregs] :: RA_State freeRegs -> !freeRegs

-- | assignment of temps to locations
[ra_assig] :: RA_State freeRegs -> RegMap Loc

-- | current stack delta
[ra_delta] :: RA_State freeRegs -> Int

-- | free stack slots for spilling
[ra_stack] :: RA_State freeRegs -> StackMap

-- | unique supply for generating names for join point fixup blocks.
[ra_us] :: RA_State freeRegs -> UniqSupply

-- | Record why things were spilled, for -ddrop-asm-stats. Just keep a list
--   here instead of a map of regs -&gt; reasons. We don't want to slow
--   down the allocator if we're not going to emit the stats.
[ra_spills] :: RA_State freeRegs -> [SpillReason]

-- | Native code generator configuration
[ra_config] :: RA_State freeRegs -> !NCGConfig

-- | (from,fixup,to) : We inserted fixup code between from and to
[ra_fixups] :: RA_State freeRegs -> [(BlockId, BlockId, BlockId)]

-- | The register allocator monad type.
data RegM freeRegs a

-- | Run a computation in the RegM register allocator monad.
runR :: NCGConfig -> BlockAssignment freeRegs -> freeRegs -> RegMap Loc -> StackMap -> UniqSupply -> RegM freeRegs a -> (BlockAssignment freeRegs, StackMap, RegAllocStats, a)
spillR :: Instruction instr => Reg -> Unique -> RegM freeRegs ([instr], Int)
loadR :: Instruction instr => Reg -> Int -> RegM freeRegs [instr]
getFreeRegsR :: RegM freeRegs freeRegs
setFreeRegsR :: freeRegs -> RegM freeRegs ()
getAssigR :: RegM freeRegs (RegMap Loc)
setAssigR :: RegMap Loc -> RegM freeRegs ()
getBlockAssigR :: RegM freeRegs (BlockAssignment freeRegs)
setBlockAssigR :: BlockAssignment freeRegs -> RegM freeRegs ()
setDeltaR :: Int -> RegM freeRegs ()
getDeltaR :: RegM freeRegs Int
getUniqueR :: RegM freeRegs Unique

-- | Get native code generator configuration
getConfig :: RegM a NCGConfig

-- | Get target platform from native code generator configuration
getPlatform :: RegM a Platform

-- | Record that a spill instruction was inserted, for profiling.
recordSpill :: SpillReason -> RegM freeRegs ()

-- | Record a created fixup block
recordFixupBlock :: BlockId -> BlockId -> BlockId -> RegM freeRegs ()
instance GHC.Base.Functor (GHC.CmmToAsm.Reg.Linear.State.RegM freeRegs)
instance GHC.Base.Applicative (GHC.CmmToAsm.Reg.Linear.State.RegM freeRegs)
instance GHC.Base.Monad (GHC.CmmToAsm.Reg.Linear.State.RegM freeRegs)


-- | Clean out unneeded spill/reload instructions.
--   
--   Handling of join points ~~~~~~~~~~~~~~~~~~~~~~~
--   
--   <pre>
--   B1:                          B2:
--    ...                          ...
--       RELOAD SLOT(0), %r1          RELOAD SLOT(0), %r1
--       ... A ...                    ... B ...
--       jump B3                      jump B3
--   
--                B3: ... C ...
--                    RELOAD SLOT(0), %r1
--                    ...
--   
--   </pre>
--   
--   The Plan ~~~~~~~~
--   
--   As long as %r1 hasn't been written to in A, B or C then we don't need
--   the reload in B3.
--   
--   What we really care about here is that on the entry to B3, %r1 will
--   always have the same value that is in SLOT(0) (ie, %r1 is _valid_)
--   
--   This also works if the reloads in B1/B2 were spills instead, because
--   spilling %r1 to a slot makes that slot have the same value as %r1.
module GHC.CmmToAsm.Reg.Graph.SpillClean

-- | Clean out unneeded spill/reloads from this top level thing.
cleanSpills :: Instruction instr => Platform -> LiveCmmDecl statics instr -> LiveCmmDecl statics instr
instance GHC.Types.Unique.Uniquable GHC.CmmToAsm.Reg.Graph.SpillClean.Store
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Graph.SpillClean.Store


-- | When there aren't enough registers to hold all the vregs we have to
--   spill some of those vregs to slots on the stack. This module is used
--   modify the code to use those slots.
module GHC.CmmToAsm.Reg.Graph.Spill

-- | Spill all these virtual regs to stack slots.
--   
--   Bumps the number of required stack slots if required.
--   
--   TODO: See if we can split some of the live ranges instead of just
--   globally spilling the virtual reg. This might make the spill cleaner's
--   job easier.
--   
--   TODO: On CISCy x86 and x86_64 we don't necessarily have to add a mov
--   instruction when making spills. If an instr is using a spilled virtual
--   we may be able to address the spill slot directly.
regSpill :: Instruction instr => Platform -> [LiveCmmDecl statics instr] -> UniqSet Int -> Int -> UniqSet VirtualReg -> UniqSM ([LiveCmmDecl statics instr], UniqSet Int, Int, SpillStats)

-- | Spiller statistics. Tells us what registers were spilled.
data SpillStats
SpillStats :: UniqFM Reg (Reg, Int, Int) -> SpillStats
[spillStoreLoad] :: SpillStats -> UniqFM Reg (Reg, Int, Int)

-- | Add a spill/reload count to a stats record for a register.
accSpillSL :: (Reg, Int, Int) -> (Reg, Int, Int) -> (Reg, Int, Int)
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Graph.Spill.SpillStats


-- | Register coalescing.
module GHC.CmmToAsm.Reg.Graph.Coalesce

-- | Do register coalescing on this top level thing
--   
--   For Reg -&gt; Reg moves, if the first reg dies at the same time the
--   second reg is born then the mov only serves to join live ranges. The
--   two regs can be renamed to be the same and the move instruction safely
--   erased.
regCoalesce :: Instruction instr => [LiveCmmDecl statics instr] -> UniqSM [LiveCmmDecl statics instr]

-- | Slurp out mov instructions that only serve to join live ranges.
--   
--   During a mov, if the source reg dies and the destination reg is born
--   then we can rename the two regs to the same thing and eliminate the
--   move.
slurpJoinMovs :: Instruction instr => LiveCmmDecl statics instr -> Bag (Reg, Reg)

module GHC.CmmToAsm.Reg.Graph.SpillCost

-- | Records the expected cost to spill some register.
type SpillCostRecord = (VirtualReg, Int, Int, Int)

-- | Add two spill cost records.
plusSpillCostRecord :: SpillCostRecord -> SpillCostRecord -> SpillCostRecord

-- | Show a spill cost record, including the degree from the graph and
--   final calculated spill cost.
pprSpillCostRecord :: (VirtualReg -> RegClass) -> (Reg -> SDoc) -> Graph VirtualReg RegClass RealReg -> SpillCostRecord -> SDoc

-- | Map of <a>SpillCostRecord</a>
type SpillCostInfo = UniqFM VirtualReg SpillCostRecord

-- | An empty map of spill costs.
zeroSpillCostInfo :: SpillCostInfo

-- | Add two spill cost infos.
plusSpillCostInfo :: SpillCostInfo -> SpillCostInfo -> SpillCostInfo

-- | Slurp out information used for determining spill costs.
--   
--   For each vreg, the number of times it was written to, read from, and
--   the number of instructions it was live on entry to (lifetime)
slurpSpillCostInfo :: forall instr statics. Instruction instr => Platform -> Maybe CFG -> LiveCmmDecl statics instr -> SpillCostInfo

-- | Choose a node to spill from this graph
chooseSpill :: SpillCostInfo -> Graph VirtualReg RegClass RealReg -> VirtualReg

-- | Extract a map of register lifetimes from a <a>SpillCostInfo</a>.
lifeMapFromSpillCostInfo :: SpillCostInfo -> UniqFM VirtualReg (VirtualReg, Int)


-- | Carries interesting info for debugging / profiling of the graph
--   coloring register allocator.
module GHC.CmmToAsm.Reg.Graph.Stats

-- | Holds interesting statistics from the register allocator.
data RegAllocStats statics instr
RegAllocStatsStart :: [LiveCmmDecl statics instr] -> Graph VirtualReg RegClass RealReg -> SpillCostInfo -> !Platform -> RegAllocStats statics instr

-- | Initial code, with liveness.
[raLiveCmm] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | The initial, uncolored graph.
[raGraph] :: RegAllocStats statics instr -> Graph VirtualReg RegClass RealReg

-- | Information to help choose which regs to spill.
[raSpillCosts] :: RegAllocStats statics instr -> SpillCostInfo

-- | Target platform
[raPlatform] :: RegAllocStats statics instr -> !Platform
RegAllocStatsSpill :: [LiveCmmDecl statics instr] -> Graph VirtualReg RegClass RealReg -> UniqFM VirtualReg VirtualReg -> SpillStats -> SpillCostInfo -> [LiveCmmDecl statics instr] -> !Platform -> RegAllocStats statics instr

-- | Code we tried to allocate registers for.
[raCode] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | The initial, uncolored graph.
[raGraph] :: RegAllocStats statics instr -> Graph VirtualReg RegClass RealReg

-- | The regs that were coalesced.
[raCoalesced] :: RegAllocStats statics instr -> UniqFM VirtualReg VirtualReg

-- | Spiller stats.
[raSpillStats] :: RegAllocStats statics instr -> SpillStats

-- | Information to help choose which regs to spill.
[raSpillCosts] :: RegAllocStats statics instr -> SpillCostInfo

-- | Code with spill instructions added.
[raSpilled] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | Target platform
[raPlatform] :: RegAllocStats statics instr -> !Platform
RegAllocStatsColored :: [LiveCmmDecl statics instr] -> Graph VirtualReg RegClass RealReg -> Graph VirtualReg RegClass RealReg -> UniqFM VirtualReg VirtualReg -> [LiveCmmDecl statics instr] -> [LiveCmmDecl statics instr] -> [LiveCmmDecl statics instr] -> [NatCmmDecl statics instr] -> (Int, Int, Int) -> !Platform -> RegAllocStats statics instr

-- | Code we tried to allocate registers for.
[raCode] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | The initial, uncolored graph.
[raGraph] :: RegAllocStats statics instr -> Graph VirtualReg RegClass RealReg

-- | Coalesced and colored graph.
[raGraphColored] :: RegAllocStats statics instr -> Graph VirtualReg RegClass RealReg

-- | The regs that were coalesced.
[raCoalesced] :: RegAllocStats statics instr -> UniqFM VirtualReg VirtualReg

-- | Code with coalescings applied.
[raCodeCoalesced] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | Code with vregs replaced by hregs.
[raPatched] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | Code with unneeded spill/reloads cleaned out.
[raSpillClean] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | Final code.
[raFinal] :: RegAllocStats statics instr -> [NatCmmDecl statics instr]

-- | Spill/reload/reg-reg moves present in this code.
[raSRMs] :: RegAllocStats statics instr -> (Int, Int, Int)

-- | Target platform
[raPlatform] :: RegAllocStats statics instr -> !Platform

-- | Do all the different analysis on this list of RegAllocStats
pprStats :: [RegAllocStats statics instr] -> Graph VirtualReg RegClass RealReg -> SDoc

-- | Dump a table of how many spill loads / stores were inserted for each
--   vreg.
pprStatsSpills :: [RegAllocStats statics instr] -> SDoc

-- | Dump a table of how long vregs tend to live for in the initial code.
pprStatsLifetimes :: [RegAllocStats statics instr] -> SDoc

-- | Dump a table of how many conflicts vregs tend to have in the initial
--   code.
pprStatsConflict :: [RegAllocStats statics instr] -> SDoc

-- | For every vreg, dump how many conflicts it has, and its lifetime. Good
--   for making a scatter plot.
pprStatsLifeConflict :: [RegAllocStats statics instr] -> Graph VirtualReg RegClass RealReg -> SDoc

-- | Count spill<i>reload</i>reg-reg moves. Lets us see how well the
--   register allocator has done.
countSRMs :: Instruction instr => LiveCmmDecl statics instr -> (Int, Int, Int)
addSRM :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int)
instance GHC.Base.Functor (GHC.CmmToAsm.Reg.Graph.Stats.RegAllocStats statics)
instance (GHC.Utils.Outputable.OutputableP GHC.Platform.Platform statics, GHC.Utils.Outputable.OutputableP GHC.Platform.Platform instr) => GHC.Utils.Outputable.Outputable (GHC.CmmToAsm.Reg.Graph.Stats.RegAllocStats statics instr)


-- | Graph coloring register allocator.
module GHC.CmmToAsm.Reg.Graph

-- | The top level of the graph coloring register allocator.
regAlloc :: (OutputableP Platform statics, Instruction instr) => NCGConfig -> UniqFM RegClass (UniqSet RealReg) -> UniqSet Int -> Int -> [LiveCmmDecl statics instr] -> Maybe CFG -> UniqSM ([NatCmmDecl statics instr], Maybe Int, [RegAllocStats statics instr])

module GHC.Cmm.Opt
constantFoldNode :: Platform -> CmmNode e x -> CmmNode e x
constantFoldExpr :: Platform -> CmmExpr -> CmmExpr
cmmMachOpFold :: Platform -> MachOp -> [CmmExpr] -> CmmExpr
cmmMachOpFoldM :: Platform -> MachOp -> [CmmExpr] -> Maybe CmmExpr

module GHC.Cmm.Info
mkEmptyContInfoTable :: CLabel -> CmmInfoTable
cmmToRawCmm :: Logger -> DynFlags -> Stream IO CmmGroupSRTs a -> IO (Stream IO RawCmmGroup a)

-- | Value of the srt field of an info table when using an StgLargeSRT
srtEscape :: Platform -> StgHalfWord
data PtrOpts
PtrOpts :: !Profile -> !Bool -> PtrOpts

-- | Platform profile
[po_profile] :: PtrOpts -> !Profile

-- | Insert alignment check (cf <tt>-falignment-sanitisation</tt>)
[po_align_check] :: PtrOpts -> !Bool

-- | Takes a closure pointer and returns the info table pointer
closureInfoPtr :: PtrOpts -> CmmExpr -> CmmExpr

-- | Takes an info pointer (the first word of a closure) and returns its
--   entry code
entryCode :: Platform -> CmmExpr -> CmmExpr

-- | Takes a closure pointer, and return the *zero-indexed* constructor tag
--   obtained from the info table This lives in the SRT field of the info
--   table (constructors don't need SRTs).
getConstrTag :: PtrOpts -> CmmExpr -> CmmExpr

-- | Takes a closure pointer, and return the closure type obtained from the
--   info table
cmmGetClosureType :: PtrOpts -> CmmExpr -> CmmExpr

-- | Takes an info pointer (the first word of a closure) and returns a
--   pointer to the first word of the standard-form info table, excluding
--   the entry-code word (if present)
infoTable :: Profile -> CmmExpr -> CmmExpr

-- | Takes an info table pointer (from infoTable) and returns the constr
--   tag field of the info table (same as the srt_bitmap field)
infoTableConstrTag :: Profile -> CmmExpr -> CmmExpr

-- | Takes an info table pointer (from infoTable) and returns the
--   srt_bitmap field of the info table
infoTableSrtBitmap :: Profile -> CmmExpr -> CmmExpr

-- | Takes an info table pointer (from infoTable) and returns the closure
--   type field of the info table.
infoTableClosureType :: Profile -> CmmExpr -> CmmExpr
infoTablePtrs :: Profile -> CmmExpr -> CmmExpr
infoTableNonPtrs :: Profile -> CmmExpr -> CmmExpr

-- | Takes the info pointer of a function, and returns a pointer to the
--   first word of the StgFunInfoExtra struct in the info table.
funInfoTable :: Profile -> CmmExpr -> CmmExpr

-- | Takes the info pointer of a function, returns the function's arity
funInfoArity :: Profile -> CmmExpr -> CmmExpr
stdInfoTableSizeW :: Profile -> WordOff
fixedInfoTableSizeW :: WordOff
profInfoTableSizeW :: WordOff
maxStdInfoTableSizeW :: WordOff
maxRetInfoTableSizeW :: WordOff
stdInfoTableSizeB :: Profile -> ByteOff
conInfoTableSizeB :: Profile -> Int

-- | Byte offset of the SRT bitmap half-word which is in the
--   *higher-addressed* part of the type_lit
stdSrtBitmapOffset :: Profile -> ByteOff

-- | Byte offset of the closure type half-word
stdClosureTypeOffset :: Profile -> ByteOff
stdPtrsOffset :: Profile -> ByteOff
stdNonPtrsOffset :: Profile -> ByteOff

module GHC.CmmToAsm.PPC.Instr
data Instr
COMMENT :: FastString -> Instr
LOCATION :: Int -> Int -> Int -> String -> Instr
LDATA :: Section -> RawCmmStatics -> Instr
NEWBLOCK :: BlockId -> Instr
DELTA :: Int -> Instr
LD :: Format -> Reg -> AddrMode -> Instr
LDFAR :: Format -> Reg -> AddrMode -> Instr
LDR :: Format -> Reg -> AddrMode -> Instr
LA :: Format -> Reg -> AddrMode -> Instr
ST :: Format -> Reg -> AddrMode -> Instr
STFAR :: Format -> Reg -> AddrMode -> Instr
STU :: Format -> Reg -> AddrMode -> Instr
STC :: Format -> Reg -> AddrMode -> Instr
LIS :: Reg -> Imm -> Instr
LI :: Reg -> Imm -> Instr
MR :: Reg -> Reg -> Instr
CMP :: Format -> Reg -> RI -> Instr
CMPL :: Format -> Reg -> RI -> Instr
BCC :: Cond -> BlockId -> Maybe Bool -> Instr
BCCFAR :: Cond -> BlockId -> Maybe Bool -> Instr
JMP :: CLabel -> [Reg] -> Instr
MTCTR :: Reg -> Instr
BCTR :: [Maybe BlockId] -> Maybe CLabel -> [Reg] -> Instr
BL :: CLabel -> [Reg] -> Instr
BCTRL :: [Reg] -> Instr
ADD :: Reg -> Reg -> RI -> Instr
ADDO :: Reg -> Reg -> Reg -> Instr
ADDC :: Reg -> Reg -> Reg -> Instr
ADDE :: Reg -> Reg -> Reg -> Instr
ADDZE :: Reg -> Reg -> Instr
ADDIS :: Reg -> Reg -> Imm -> Instr
SUBF :: Reg -> Reg -> Reg -> Instr
SUBFO :: Reg -> Reg -> Reg -> Instr
SUBFC :: Reg -> Reg -> RI -> Instr
SUBFE :: Reg -> Reg -> Reg -> Instr
MULL :: Format -> Reg -> Reg -> RI -> Instr
MULLO :: Format -> Reg -> Reg -> Reg -> Instr
MFOV :: Format -> Reg -> Instr
MULHU :: Format -> Reg -> Reg -> Reg -> Instr
DIV :: Format -> Bool -> Reg -> Reg -> Reg -> Instr
AND :: Reg -> Reg -> RI -> Instr
ANDC :: Reg -> Reg -> Reg -> Instr
NAND :: Reg -> Reg -> Reg -> Instr
OR :: Reg -> Reg -> RI -> Instr
ORIS :: Reg -> Reg -> Imm -> Instr
XOR :: Reg -> Reg -> RI -> Instr
XORIS :: Reg -> Reg -> Imm -> Instr
EXTS :: Format -> Reg -> Reg -> Instr
CNTLZ :: Format -> Reg -> Reg -> Instr
NEG :: Reg -> Reg -> Instr
NOT :: Reg -> Reg -> Instr
SL :: Format -> Reg -> Reg -> RI -> Instr
SR :: Format -> Reg -> Reg -> RI -> Instr
SRA :: Format -> Reg -> Reg -> RI -> Instr
RLWINM :: Reg -> Reg -> Int -> Int -> Int -> Instr
CLRLI :: Format -> Reg -> Reg -> Int -> Instr
CLRRI :: Format -> Reg -> Reg -> Int -> Instr
FADD :: Format -> Reg -> Reg -> Reg -> Instr
FSUB :: Format -> Reg -> Reg -> Reg -> Instr
FMUL :: Format -> Reg -> Reg -> Reg -> Instr
FDIV :: Format -> Reg -> Reg -> Reg -> Instr
FABS :: Reg -> Reg -> Instr
FNEG :: Reg -> Reg -> Instr
FCMP :: Reg -> Reg -> Instr
FCTIWZ :: Reg -> Reg -> Instr
FCTIDZ :: Reg -> Reg -> Instr
FCFID :: Reg -> Reg -> Instr
FRSP :: Reg -> Reg -> Instr
CRNOR :: Int -> Int -> Int -> Instr
MFCR :: Reg -> Instr
MFLR :: Reg -> Instr
FETCHPC :: Reg -> Instr
HWSYNC :: Instr
ISYNC :: Instr
LWSYNC :: Instr
NOP :: Instr
data RI
RIReg :: Reg -> RI
RIImm :: Imm -> RI
archWordFormat :: Bool -> Format

-- | The size of a minimal stackframe header including minimal parameter
--   save area.
stackFrameHeaderSize :: Platform -> Int

-- | The number of spill slots available without allocating more.
maxSpillSlots :: NCGConfig -> Int
allocMoreStack :: Platform -> Int -> NatCmmDecl statics Instr -> UniqSM (NatCmmDecl statics Instr, [(BlockId, BlockId)])
makeFarBranches :: LabelMap RawCmmStatics -> [NatBasicBlock Instr] -> [NatBasicBlock Instr]

-- | Make an unconditional jump instruction.
mkJumpInstr :: BlockId -> [Instr]
mkLoadInstr :: NCGConfig -> Reg -> Int -> Int -> [Instr]

-- | An instruction to spill a register into a spill slot.
mkSpillInstr :: NCGConfig -> Reg -> Int -> Int -> [Instr]

-- | Change the destination of this jump instruction. Used in the linear
--   allocator when adding fixup blocks for join points.
patchJumpInstr :: Instr -> (BlockId -> BlockId) -> Instr

-- | Apply a given mapping to all the register references in this
--   instruction.
patchRegsOfInstr :: Instr -> (Reg -> Reg) -> Instr

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
jumpDestsOfInstr :: Instr -> [BlockId]

-- | Take the source and destination from this reg -&gt; reg move
--   instruction or Nothing if it's not one
takeRegRegMoveInstr :: Instr -> Maybe (Reg, Reg)

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instr -> Maybe Int

-- | Copy the value in a register to another one. Must work for all
--   register classes.
mkRegRegMoveInstr :: Reg -> Reg -> Instr
mkStackAllocInstr :: Platform -> Int -> [Instr]
mkStackDeallocInstr :: Platform -> Int -> [Instr]

-- | Get the registers that are being used by this instruction. regUsage
--   doesn't need to do any trickery for jumps and such. Just state
--   precisely the regs read and written by that insn. The consequences of
--   control flow transfers, as far as register allocation goes, are taken
--   care of by the register allocator.
regUsageOfInstr :: Platform -> Instr -> RegUsage

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
isJumpishInstr :: Instr -> Bool
isMetaInstr :: Instr -> Bool

module GHC.CmmToAsm.PPC.RegInfo
data JumpDest
DestBlockId :: BlockId -> JumpDest
getJumpDestBlockId :: JumpDest -> Maybe BlockId
canShortcut :: Instr -> Maybe JumpDest
shortcutJump :: (BlockId -> Maybe JumpDest) -> Instr -> Instr
shortcutStatics :: (BlockId -> Maybe JumpDest) -> RawCmmStatics -> RawCmmStatics
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.PPC.RegInfo.JumpDest

module GHC.CmmToAsm.PPC.Ppr
pprNatCmmDecl :: NCGConfig -> NatCmmDecl RawCmmStatics Instr -> SDoc
pprInstr :: Platform -> Instr -> SDoc

module GHC.Cmm.Parser.Monad
newtype PD a
PD :: (DynFlags -> HomeUnit -> PState -> ParseResult a) -> PD a
[unPD] :: PD a -> DynFlags -> HomeUnit -> PState -> ParseResult a
liftP :: P a -> PD a
failMsgPD :: (SrcSpan -> PsError) -> PD a
getProfile :: PD Profile
getPlatform :: PD Platform
getPtrOpts :: PD PtrOpts

-- | Return the UnitId of the home-unit. This is used to create labels.
getHomeUnitId :: PD UnitId
instance GHC.Base.Functor GHC.Cmm.Parser.Monad.PD
instance GHC.Base.Applicative GHC.Cmm.Parser.Monad.PD
instance GHC.Base.Monad GHC.Cmm.Parser.Monad.PD
instance GHC.Driver.Session.HasDynFlags GHC.Cmm.Parser.Monad.PD

module GHC.Cmm.Lexer
data CmmToken
CmmT_SpecChar :: Char -> CmmToken
CmmT_DotDot :: CmmToken
CmmT_DoubleColon :: CmmToken
CmmT_Shr :: CmmToken
CmmT_Shl :: CmmToken
CmmT_Ge :: CmmToken
CmmT_Le :: CmmToken
CmmT_Eq :: CmmToken
CmmT_Ne :: CmmToken
CmmT_BoolAnd :: CmmToken
CmmT_BoolOr :: CmmToken
CmmT_CLOSURE :: CmmToken
CmmT_INFO_TABLE :: CmmToken
CmmT_INFO_TABLE_RET :: CmmToken
CmmT_INFO_TABLE_FUN :: CmmToken
CmmT_INFO_TABLE_CONSTR :: CmmToken
CmmT_INFO_TABLE_SELECTOR :: CmmToken
CmmT_else :: CmmToken
CmmT_export :: CmmToken
CmmT_section :: CmmToken
CmmT_goto :: CmmToken
CmmT_if :: CmmToken
CmmT_call :: CmmToken
CmmT_jump :: CmmToken
CmmT_foreign :: CmmToken
CmmT_never :: CmmToken
CmmT_prim :: CmmToken
CmmT_reserve :: CmmToken
CmmT_return :: CmmToken
CmmT_returns :: CmmToken
CmmT_import :: CmmToken
CmmT_switch :: CmmToken
CmmT_case :: CmmToken
CmmT_default :: CmmToken
CmmT_push :: CmmToken
CmmT_unwind :: CmmToken
CmmT_bits8 :: CmmToken
CmmT_bits16 :: CmmToken
CmmT_bits32 :: CmmToken
CmmT_bits64 :: CmmToken
CmmT_bits128 :: CmmToken
CmmT_bits256 :: CmmToken
CmmT_bits512 :: CmmToken
CmmT_float32 :: CmmToken
CmmT_float64 :: CmmToken
CmmT_gcptr :: CmmToken
CmmT_GlobalReg :: GlobalReg -> CmmToken
CmmT_Name :: FastString -> CmmToken
CmmT_String :: String -> CmmToken
CmmT_Int :: Integer -> CmmToken
CmmT_Float :: Rational -> CmmToken
CmmT_EOF :: CmmToken
CmmT_False :: CmmToken
CmmT_True :: CmmToken
CmmT_likely :: CmmToken
cmmlex :: (Located CmmToken -> PD a) -> PD a
instance GHC.Show.Show GHC.Cmm.Lexer.CmmToken

module GHC.Cmm.DebugBlock

-- | Debug information about a block of code. Ticks scope over nested
--   blocks.
data DebugBlock
DebugBlock :: !Label -> !Label -> !CLabel -> !Bool -> !Maybe DebugBlock -> ![CmmTickish] -> !Maybe CmmTickish -> !Maybe Int -> [UnwindPoint] -> ![DebugBlock] -> DebugBlock

-- | Entry label of containing proc
[dblProcedure] :: DebugBlock -> !Label

-- | Hoopl label
[dblLabel] :: DebugBlock -> !Label

-- | Output label
[dblCLabel] :: DebugBlock -> !CLabel

-- | Has an info table?
[dblHasInfoTbl] :: DebugBlock -> !Bool

-- | The parent of this proc. See Note [Splitting DebugBlocks]
[dblParent] :: DebugBlock -> !Maybe DebugBlock

-- | Ticks defined in this block
[dblTicks] :: DebugBlock -> ![CmmTickish]

-- | Best source tick covering block
[dblSourceTick] :: DebugBlock -> !Maybe CmmTickish

-- | Output position relative to other blocks. <tt>Nothing</tt> means the
--   block was optimized out
[dblPosition] :: DebugBlock -> !Maybe Int
[dblUnwind] :: DebugBlock -> [UnwindPoint]

-- | Nested blocks
[dblBlocks] :: DebugBlock -> ![DebugBlock]

-- | Extract debug data from a group of procedures. We will prefer source
--   notes that come from the given module (presumably the module that we
--   are currently compiling).
cmmDebugGen :: ModLocation -> RawCmmGroup -> [DebugBlock]
cmmDebugLabels :: (i -> Bool) -> GenCmmGroup d g (ListGraph i) -> [Label]

-- | Sets position and unwind table fields in the debug block tree
--   according to native generated code.
cmmDebugLink :: [Label] -> LabelMap [UnwindPoint] -> [DebugBlock] -> [DebugBlock]

-- | Converts debug blocks into a label map for easier lookups
debugToMap :: [DebugBlock] -> LabelMap DebugBlock

-- | Maps registers to expressions that yield their "old" values further up
--   the stack. Most interesting for the stack pointer <tt>Sp</tt>, but
--   might be useful to document saved registers, too. Note that a
--   register's value will be <a>Nothing</a> when the register's previous
--   value cannot be reconstructed.
type UnwindTable = Map GlobalReg (Maybe UnwindExpr)

-- | A label associated with an <a>UnwindTable</a>
data UnwindPoint
UnwindPoint :: !CLabel -> !UnwindTable -> UnwindPoint

-- | Expressions, used for unwind information
data UnwindExpr

-- | literal value
UwConst :: !Int -> UnwindExpr

-- | register plus offset
UwReg :: !GlobalReg -> !Int -> UnwindExpr

-- | pointer dereferencing
UwDeref :: UnwindExpr -> UnwindExpr
UwLabel :: CLabel -> UnwindExpr
UwPlus :: UnwindExpr -> UnwindExpr -> UnwindExpr
UwMinus :: UnwindExpr -> UnwindExpr -> UnwindExpr
UwTimes :: UnwindExpr -> UnwindExpr -> UnwindExpr

-- | Conversion of Cmm expressions to unwind expressions. We check for
--   unsupported operator usages and simplify the expression as far as
--   possible.
toUnwindExpr :: Platform -> CmmExpr -> UnwindExpr
instance GHC.Classes.Eq GHC.Cmm.DebugBlock.UnwindExpr
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.DebugBlock.DebugBlock
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.DebugBlock.UnwindPoint
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.DebugBlock.UnwindExpr

module GHC.CmmToAsm.X86.Instr
data Instr
COMMENT :: FastString -> Instr
LOCATION :: Int -> Int -> Int -> String -> Instr
LDATA :: Section -> (Alignment, RawCmmStatics) -> Instr
NEWBLOCK :: BlockId -> Instr
UNWIND :: CLabel -> UnwindTable -> Instr
DELTA :: Int -> Instr
MOV :: Format -> Operand -> Operand -> Instr
CMOV :: Cond -> Format -> Operand -> Reg -> Instr
MOVZxL :: Format -> Operand -> Operand -> Instr
MOVSxL :: Format -> Operand -> Operand -> Instr
LEA :: Format -> Operand -> Operand -> Instr
ADD :: Format -> Operand -> Operand -> Instr
ADC :: Format -> Operand -> Operand -> Instr
SUB :: Format -> Operand -> Operand -> Instr
SBB :: Format -> Operand -> Operand -> Instr
MUL :: Format -> Operand -> Operand -> Instr
MUL2 :: Format -> Operand -> Instr
IMUL :: Format -> Operand -> Operand -> Instr
IMUL2 :: Format -> Operand -> Instr
DIV :: Format -> Operand -> Instr
IDIV :: Format -> Operand -> Instr
ADD_CC :: Format -> Operand -> Operand -> Instr
SUB_CC :: Format -> Operand -> Operand -> Instr
AND :: Format -> Operand -> Operand -> Instr
OR :: Format -> Operand -> Operand -> Instr
XOR :: Format -> Operand -> Operand -> Instr
NOT :: Format -> Operand -> Instr
NEGI :: Format -> Operand -> Instr
BSWAP :: Format -> Reg -> Instr
SHL :: Format -> Operand -> Operand -> Instr
SAR :: Format -> Operand -> Operand -> Instr
SHR :: Format -> Operand -> Operand -> Instr
BT :: Format -> Imm -> Operand -> Instr
NOP :: Instr
X87Store :: Format -> AddrMode -> Instr
CVTSS2SD :: Reg -> Reg -> Instr
CVTSD2SS :: Reg -> Reg -> Instr
CVTTSS2SIQ :: Format -> Operand -> Reg -> Instr
CVTTSD2SIQ :: Format -> Operand -> Reg -> Instr
CVTSI2SS :: Format -> Operand -> Reg -> Instr
CVTSI2SD :: Format -> Operand -> Reg -> Instr
FDIV :: Format -> Operand -> Operand -> Instr
SQRT :: Format -> Operand -> Reg -> Instr
TEST :: Format -> Operand -> Operand -> Instr
CMP :: Format -> Operand -> Operand -> Instr
SETCC :: Cond -> Operand -> Instr
PUSH :: Format -> Operand -> Instr
POP :: Format -> Operand -> Instr
JMP :: Operand -> [Reg] -> Instr
JXX :: Cond -> BlockId -> Instr
JXX_GBL :: Cond -> Imm -> Instr
JMP_TBL :: Operand -> [Maybe JumpDest] -> Section -> CLabel -> Instr

-- | X86 call instruction
CALL :: Either Imm Reg -> [Reg] -> Instr
CLTD :: Format -> Instr
FETCHGOT :: Reg -> Instr
FETCHPC :: Reg -> Instr
POPCNT :: Format -> Operand -> Reg -> Instr
LZCNT :: Format -> Operand -> Reg -> Instr
TZCNT :: Format -> Operand -> Reg -> Instr
BSF :: Format -> Operand -> Reg -> Instr
BSR :: Format -> Operand -> Reg -> Instr
PDEP :: Format -> Operand -> Operand -> Reg -> Instr
PEXT :: Format -> Operand -> Operand -> Reg -> Instr
PREFETCH :: PrefetchVariant -> Format -> Operand -> Instr
LOCK :: Instr -> Instr
XADD :: Format -> Operand -> Operand -> Instr
CMPXCHG :: Format -> Operand -> Operand -> Instr
XCHG :: Format -> Operand -> Reg -> Instr
MFENCE :: Instr
data Operand
OpReg :: Reg -> Operand
OpImm :: Imm -> Operand
OpAddr :: AddrMode -> Operand
data PrefetchVariant
NTA :: PrefetchVariant
Lvl0 :: PrefetchVariant
Lvl1 :: PrefetchVariant
Lvl2 :: PrefetchVariant
data JumpDest
DestBlockId :: BlockId -> JumpDest
DestImm :: Imm -> JumpDest
getJumpDestBlockId :: JumpDest -> Maybe BlockId
canShortcut :: Instr -> Maybe JumpDest
shortcutStatics :: (BlockId -> Maybe JumpDest) -> (Alignment, RawCmmStatics) -> (Alignment, RawCmmStatics)
shortcutJump :: (BlockId -> Maybe JumpDest) -> Instr -> Instr
allocMoreStack :: Platform -> Int -> NatCmmDecl statics Instr -> UniqSM (NatCmmDecl statics Instr, [(BlockId, BlockId)])
maxSpillSlots :: NCGConfig -> Int
archWordFormat :: Bool -> Format

-- | Check whether an instruction represents a reg-reg move. The register
--   allocator attempts to eliminate reg-&gt;reg moves whenever it can, by
--   assigning the src and dest temporaries to the same real register.
takeRegRegMoveInstr :: Instr -> Maybe (Reg, Reg)

-- | Returns which registers are read and written as a (read, written)
--   pair.
regUsageOfInstr :: Platform -> Instr -> RegUsage

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instr -> Maybe Int

-- | Make a spill reload instruction.
mkLoadInstr :: NCGConfig -> Reg -> Int -> Int -> [Instr]

-- | Make an unconditional branch instruction.
mkJumpInstr :: BlockId -> [Instr]
mkStackAllocInstr :: Platform -> Int -> [Instr]
mkStackDeallocInstr :: Platform -> Int -> [Instr]

-- | Make a spill instruction.
mkSpillInstr :: NCGConfig -> Reg -> Int -> Int -> [Instr]

-- | Make a reg-reg move instruction. On SPARC v8 there are no instructions
--   to move directly between floating point and integer regs. If we need
--   to do that then we have to go via memory.
mkRegRegMoveInstr :: Platform -> Reg -> Reg -> Instr
jumpDestsOfInstr :: Instr -> [BlockId]

-- | Applies the supplied function to all registers in instructions.
--   Typically used to change virtual registers to real registers.
patchRegsOfInstr :: Instr -> (Reg -> Reg) -> Instr
patchJumpInstr :: Instr -> (BlockId -> BlockId) -> Instr
isMetaInstr :: Instr -> Bool
isJumpishInstr :: Instr -> Bool
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.X86.Instr.JumpDest

module GHC.CmmToAsm.X86.Ppr
pprNatCmmDecl :: NCGConfig -> NatCmmDecl (Alignment, RawCmmStatics) Instr -> SDoc
pprData :: NCGConfig -> CmmStatic -> SDoc
pprInstr :: Platform -> Instr -> SDoc
pprFormat :: Format -> SDoc
pprImm :: Platform -> Imm -> SDoc
pprDataItem :: NCGConfig -> CmmLit -> SDoc

module GHC.CmmToAsm.Reg.Linear.FreeRegs
class Show freeRegs => FR freeRegs
frAllocateReg :: FR freeRegs => Platform -> RealReg -> freeRegs -> freeRegs
frGetFreeRegs :: FR freeRegs => Platform -> RegClass -> freeRegs -> [RealReg]
frInitFreeRegs :: FR freeRegs => Platform -> freeRegs
frReleaseReg :: FR freeRegs => Platform -> RealReg -> freeRegs -> freeRegs
maxSpillSlots :: NCGConfig -> Int
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.X86.FreeRegs
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.X86_64.FreeRegs
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.PPC.FreeRegs
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.AArch64.FreeRegs
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.SPARC.FreeRegs


-- | Handles joining of a jump instruction to its targets.
module GHC.CmmToAsm.Reg.Linear.JoinToTargets

-- | For a jump instruction at the end of a block, generate fixup code so
--   its vregs are in the correct regs for its destination.
joinToTargets :: (FR freeRegs, Instruction instr) => BlockMap RegSet -> BlockId -> instr -> RegM freeRegs ([NatBasicBlock instr], instr)

module GHC.CmmToAsm.Reg.Linear
regAlloc :: Instruction instr => NCGConfig -> LiveCmmDecl statics instr -> UniqSM (NatCmmDecl statics instr, Maybe Int, Maybe RegAllocStats)

module GHC.CmmToAsm.Monad
data NcgImpl statics instr jumpDest
NcgImpl :: !NCGConfig -> (RawCmmDecl -> NatM [NatCmmDecl statics instr]) -> (instr -> Maybe (NatCmmDecl statics instr)) -> (jumpDest -> Maybe BlockId) -> (instr -> Maybe jumpDest) -> ((BlockId -> Maybe jumpDest) -> statics -> statics) -> ((BlockId -> Maybe jumpDest) -> instr -> instr) -> (NatCmmDecl statics instr -> SDoc) -> Int -> [RealReg] -> ([NatCmmDecl statics instr] -> [NatCmmDecl statics instr]) -> (Int -> NatCmmDecl statics instr -> UniqSM (NatCmmDecl statics instr, [(BlockId, BlockId)])) -> (LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]) -> ([instr] -> [UnwindPoint]) -> (Maybe CFG -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]) -> NcgImpl statics instr jumpDest
[ncgConfig] :: NcgImpl statics instr jumpDest -> !NCGConfig
[cmmTopCodeGen] :: NcgImpl statics instr jumpDest -> RawCmmDecl -> NatM [NatCmmDecl statics instr]
[generateJumpTableForInstr] :: NcgImpl statics instr jumpDest -> instr -> Maybe (NatCmmDecl statics instr)
[getJumpDestBlockId] :: NcgImpl statics instr jumpDest -> jumpDest -> Maybe BlockId
[canShortcut] :: NcgImpl statics instr jumpDest -> instr -> Maybe jumpDest
[shortcutStatics] :: NcgImpl statics instr jumpDest -> (BlockId -> Maybe jumpDest) -> statics -> statics
[shortcutJump] :: NcgImpl statics instr jumpDest -> (BlockId -> Maybe jumpDest) -> instr -> instr

-- | <a>Module</a> is only for printing internal labels. See Note [Internal
--   proc labels] in CLabel.
[pprNatCmmDecl] :: NcgImpl statics instr jumpDest -> NatCmmDecl statics instr -> SDoc
[maxSpillSlots] :: NcgImpl statics instr jumpDest -> Int
[allocatableRegs] :: NcgImpl statics instr jumpDest -> [RealReg]
[ncgExpandTop] :: NcgImpl statics instr jumpDest -> [NatCmmDecl statics instr] -> [NatCmmDecl statics instr]

-- | The list of block ids records the redirected jumps to allow us to
--   update the CFG.
[ncgAllocMoreStack] :: NcgImpl statics instr jumpDest -> Int -> NatCmmDecl statics instr -> UniqSM (NatCmmDecl statics instr, [(BlockId, BlockId)])
[ncgMakeFarBranches] :: NcgImpl statics instr jumpDest -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]

-- | given the instruction sequence of a block, produce a list of the
--   block's <a>UnwindPoint</a>s See Note [What is this unwinding
--   business?] in <a>GHC.Cmm.DebugBlock</a> and Note [Unwinding
--   information in the NCG] in this module.
[extractUnwindPoints] :: NcgImpl statics instr jumpDest -> [instr] -> [UnwindPoint]

-- | Turn the sequence of <tt>jcc l1; jmp l2</tt> into <tt>jncc l2;
--   &lt;block_l1&gt;</tt> when possible.
[invertCondBranches] :: NcgImpl statics instr jumpDest -> Maybe CFG -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]
data NatM_State
NatM_State :: UniqSupply -> Int -> [CLabel] -> Maybe Reg -> NCGConfig -> ModLocation -> DwarfFiles -> LabelMap DebugBlock -> CFG -> NatM_State
[natm_us] :: NatM_State -> UniqSupply
[natm_delta] :: NatM_State -> Int
[natm_imports] :: NatM_State -> [CLabel]
[natm_pic] :: NatM_State -> Maybe Reg
[natm_config] :: NatM_State -> NCGConfig
[natm_modloc] :: NatM_State -> ModLocation
[natm_fileid] :: NatM_State -> DwarfFiles
[natm_debug_map] :: NatM_State -> LabelMap DebugBlock

-- | Having a CFG with additional information is essential for some
--   operations. However we can't reconstruct all information once we
--   generated instructions. So instead we update the CFG as we go.
[natm_cfg] :: NatM_State -> CFG
mkNatM_State :: UniqSupply -> Int -> NCGConfig -> ModLocation -> DwarfFiles -> LabelMap DebugBlock -> CFG -> NatM_State
data NatM result
initNat :: NatM_State -> NatM a -> (a, NatM_State)
addImportNat :: CLabel -> NatM ()

-- | Record that we added a block between <tt>from</tt> and <tt>old</tt>.
addNodeBetweenNat :: BlockId -> BlockId -> BlockId -> NatM ()

-- | Place <a>succ</a> after <tt>block</tt> and change any edges block
--   -&gt; X to <a>succ</a> -&gt; X
addImmediateSuccessorNat :: BlockId -> BlockId -> NatM ()
updateCfgNat :: (CFG -> CFG) -> NatM ()
getUniqueNat :: NatM Unique
mapAccumLNat :: (acc -> x -> NatM (acc, y)) -> acc -> [x] -> NatM (acc, [y])
setDeltaNat :: Int -> NatM ()

-- | Get native code generator configuration
getConfig :: NatM NCGConfig

-- | Get target platform from native code generator configuration
getPlatform :: NatM Platform
getDeltaNat :: NatM Int
getThisModuleNat :: NatM Module
getBlockIdNat :: NatM BlockId
getNewLabelNat :: NatM CLabel
getNewRegNat :: Format -> NatM Reg
getNewRegPairNat :: Format -> NatM (Reg, Reg)
getPicBaseMaybeNat :: NatM (Maybe Reg)
getPicBaseNat :: Format -> NatM Reg

-- | Get CFG edge weights
getCfgWeights :: NatM Weights
getModLoc :: NatM ModLocation
getFileId :: FastString -> NatM Int
getDebugBlock :: Label -> NatM (Maybe DebugBlock)
type DwarfFiles = UniqFM FastString (FastString, Int)
instance GHC.Base.Functor GHC.CmmToAsm.Monad.NatM
instance GHC.Base.Applicative GHC.CmmToAsm.Monad.NatM
instance GHC.Base.Monad GHC.CmmToAsm.Monad.NatM
instance GHC.Types.Unique.Supply.MonadUnique GHC.CmmToAsm.Monad.NatM
instance GHC.Unit.Module.HasModule GHC.CmmToAsm.Monad.NatM

module GHC.CmmToAsm.SPARC.CodeGen.Amode

-- | Generate code to reference a memory address.
getAmode :: CmmExpr -> NatM Amode


-- | Evaluation of 32 bit values.
module GHC.CmmToAsm.SPARC.CodeGen.Gen32

-- | The dual to getAnyReg: compute an expression into a register, but we
--   don't mind which one it is.
getSomeReg :: CmmExpr -> NatM (Reg, InstrBlock)

-- | Make code to evaluate a 32 bit expression.
getRegister :: CmmExpr -> NatM Register


-- | Evaluation of 64 bit values on 32 bit platforms.
module GHC.CmmToAsm.SPARC.CodeGen.Gen64

-- | Code to assign a 64 bit value to memory.
assignMem_I64Code :: CmmExpr -> CmmExpr -> NatM InstrBlock

-- | Code to assign a 64 bit value to a register.
assignReg_I64Code :: CmmReg -> CmmExpr -> NatM InstrBlock

-- | Get the value of an expression into a 64 bit register.
iselExpr64 :: CmmExpr -> NatM ChildCode64

module GHC.CmmToAsm.SPARC.CodeGen.CondCode
getCondCode :: CmmExpr -> NatM CondCode
condIntCode :: Cond -> CmmExpr -> CmmExpr -> NatM CondCode
condFltCode :: Cond -> CmmExpr -> CmmExpr -> NatM CondCode

module GHC.CmmToAsm.PIC
cmmMakeDynamicReference :: CmmMakeDynamicReferenceM m => NCGConfig -> ReferenceKind -> CLabel -> m CmmExpr
class Monad m => CmmMakeDynamicReferenceM m
addImport :: CmmMakeDynamicReferenceM m => CLabel -> m ()
data ReferenceKind
DataReference :: ReferenceKind
CallReference :: ReferenceKind
JumpReference :: ReferenceKind
needImportedSymbols :: NCGConfig -> Bool
pprImportedSymbol :: NCGConfig -> CLabel -> SDoc
pprGotDeclaration :: NCGConfig -> SDoc
initializePicBase_ppc :: Arch -> OS -> Reg -> [NatCmmDecl RawCmmStatics Instr] -> NatM [NatCmmDecl RawCmmStatics Instr]
initializePicBase_x86 :: Arch -> OS -> Reg -> [NatCmmDecl (Alignment, RawCmmStatics) Instr] -> NatM [NatCmmDecl (Alignment, RawCmmStatics) Instr]
instance GHC.Classes.Eq GHC.CmmToAsm.PIC.ReferenceKind
instance GHC.CmmToAsm.PIC.CmmMakeDynamicReferenceM GHC.CmmToAsm.Monad.NatM

module GHC.CmmToAsm.X86.CodeGen
cmmTopCodeGen :: RawCmmDecl -> NatM [NatCmmDecl (Alignment, RawCmmStatics) Instr]
generateJumpTableForInstr :: NCGConfig -> Instr -> Maybe (NatCmmDecl (Alignment, RawCmmStatics) Instr)
extractUnwindPoints :: [Instr] -> [UnwindPoint]

-- | This works on the invariant that all jumps in the given blocks are
--   required. Starting from there we try to make a few more jumps
--   redundant by reordering them. We depend on the information in the CFG
--   to do so so without a given CFG we do nothing.
invertCondBranches :: Maybe CFG -> LabelMap a -> [NatBasicBlock Instr] -> [NatBasicBlock Instr]

-- | <a>InstrBlock</a>s are the insn sequences generated by the insn
--   selectors. They are really trees of insns to facilitate fast
--   appending, where a left-to-right traversal yields the insns in the
--   correct order.
type InstrBlock = OrdList Instr


-- | Native code generator for x86 and x86-64 architectures
module GHC.CmmToAsm.X86
ncgX86_64 :: NCGConfig -> NcgImpl (Alignment, RawCmmStatics) Instr JumpDest
ncgX86 :: NCGConfig -> NcgImpl (Alignment, RawCmmStatics) Instr JumpDest
instance GHC.CmmToAsm.Instr.Instruction GHC.CmmToAsm.X86.Instr.Instr

module GHC.CmmToAsm.SPARC.CodeGen

-- | Top level code generation
cmmTopCodeGen :: RawCmmDecl -> NatM [NatCmmDecl RawCmmStatics Instr]
generateJumpTableForInstr :: Platform -> Instr -> Maybe (NatCmmDecl RawCmmStatics Instr)

-- | <a>InstrBlock</a>s are the insn sequences generated by the insn
--   selectors. They are really trees of insns to facilitate fast
--   appending, where a left-to-right traversal yields the insns in the
--   correct order.
type InstrBlock = OrdList Instr


-- | Native code generator for SPARC architectures
module GHC.CmmToAsm.SPARC
ncgSPARC :: NCGConfig -> NcgImpl RawCmmStatics Instr JumpDest
instance GHC.CmmToAsm.Instr.Instruction GHC.CmmToAsm.SPARC.Instr.Instr

module GHC.CmmToAsm.PPC.CodeGen

-- | <a>InstrBlock</a>s are the insn sequences generated by the insn
--   selectors. They are really trees of insns to facilitate fast
--   appending, where a left-to-right traversal (pre-order?) yields the
--   insns in the correct order.
cmmTopCodeGen :: RawCmmDecl -> NatM [NatCmmDecl RawCmmStatics Instr]
generateJumpTableForInstr :: NCGConfig -> Instr -> Maybe (NatCmmDecl RawCmmStatics Instr)

-- | <a>InstrBlock</a>s are the insn sequences generated by the insn
--   selectors. They are really trees of insns to facilitate fast
--   appending, where a left-to-right traversal yields the insns in the
--   correct order.
type InstrBlock = OrdList Instr


-- | Native code generator for PPC architectures
module GHC.CmmToAsm.PPC
ncgPPC :: NCGConfig -> NcgImpl RawCmmStatics Instr JumpDest
instance GHC.CmmToAsm.Instr.Instruction GHC.CmmToAsm.PPC.Instr.Instr

module GHC.CmmToAsm.BlockLayout
sequenceTop :: Instruction instr => NcgImpl statics instr jumpDest -> Maybe CFG -> NatCmmDecl statics instr -> NatCmmDecl statics instr
backendMaintainsCfg :: Platform -> Bool
instance GHC.Classes.Eq GHC.CmmToAsm.BlockLayout.BlockChain
instance GHC.Classes.Ord GHC.CmmToAsm.BlockLayout.BlockChain
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.BlockLayout.BlockChain

module GHC.CmmToAsm.Dwarf.Types

-- | Individual dwarf records. Each one will be encoded as an entry in the
--   <tt>.debug_info</tt> section.
data DwarfInfo
DwarfCompileUnit :: [DwarfInfo] -> String -> String -> String -> CLabel -> CLabel -> PtrString -> DwarfInfo
[dwChildren] :: DwarfInfo -> [DwarfInfo]
[dwName] :: DwarfInfo -> String
[dwProducer] :: DwarfInfo -> String
[dwCompDir] :: DwarfInfo -> String
[dwLowLabel] :: DwarfInfo -> CLabel
[dwHighLabel] :: DwarfInfo -> CLabel
[dwLineLabel] :: DwarfInfo -> PtrString
DwarfSubprogram :: [DwarfInfo] -> String -> CLabel -> Maybe CLabel -> DwarfInfo
[dwChildren] :: DwarfInfo -> [DwarfInfo]
[dwName] :: DwarfInfo -> String
[dwLabel] :: DwarfInfo -> CLabel

-- | label of DIE belonging to the parent tick
[dwParent] :: DwarfInfo -> Maybe CLabel
DwarfBlock :: [DwarfInfo] -> CLabel -> Maybe CLabel -> DwarfInfo
[dwChildren] :: DwarfInfo -> [DwarfInfo]
[dwLabel] :: DwarfInfo -> CLabel
[dwMarker] :: DwarfInfo -> Maybe CLabel
DwarfSrcNote :: RealSrcSpan -> DwarfInfo
[dwSrcSpan] :: DwarfInfo -> RealSrcSpan

-- | Generate assembly for DWARF data
pprDwarfInfo :: Platform -> Bool -> DwarfInfo -> SDoc

-- | Abbreviation declaration. This explains the binary encoding we use for
--   representing <a>DwarfInfo</a>. Be aware that this must be updated
--   along with <a>pprDwarfInfo</a>.
pprAbbrevDecls :: Platform -> Bool -> SDoc

-- | A DWARF address range. This is used by the debugger to quickly locate
--   which compilation unit a given address belongs to. This type assumes a
--   non-segmented address-space.
data DwarfARange
DwarfARange :: CLabel -> CLabel -> DwarfARange
[dwArngStartLabel] :: DwarfARange -> CLabel
[dwArngEndLabel] :: DwarfARange -> CLabel

-- | Print assembler directives corresponding to a DWARF
--   <tt>.debug_aranges</tt> address table entry.
pprDwarfARanges :: Platform -> [DwarfARange] -> Unique -> SDoc

-- | Information about unwind instructions for a procedure. This
--   corresponds to a "Common Information Entry" (CIE) in DWARF.
data DwarfFrame
DwarfFrame :: CLabel -> UnwindTable -> [DwarfFrameProc] -> DwarfFrame
[dwCieLabel] :: DwarfFrame -> CLabel
[dwCieInit] :: DwarfFrame -> UnwindTable
[dwCieProcs] :: DwarfFrame -> [DwarfFrameProc]

-- | Unwind instructions for an individual procedure. Corresponds to a
--   "Frame Description Entry" (FDE) in DWARF.
data DwarfFrameProc
DwarfFrameProc :: CLabel -> Bool -> [DwarfFrameBlock] -> DwarfFrameProc
[dwFdeProc] :: DwarfFrameProc -> CLabel
[dwFdeHasInfo] :: DwarfFrameProc -> Bool

-- | List of blocks. Order must match asm!
[dwFdeBlocks] :: DwarfFrameProc -> [DwarfFrameBlock]

-- | Unwind instructions for a block. Will become part of the containing
--   FDE.
data DwarfFrameBlock
DwarfFrameBlock :: Bool -> [UnwindPoint] -> DwarfFrameBlock
[dwFdeBlkHasInfo] :: DwarfFrameBlock -> Bool

-- | these unwind points must occur in the same order as they occur in the
--   block
[dwFdeUnwind] :: DwarfFrameBlock -> [UnwindPoint]

-- | Header for the <tt>.debug_frame</tt> section. Here we emit the "Common
--   Information Entry" record that establishes general call frame
--   parameters and the default stack layout.
pprDwarfFrame :: Platform -> DwarfFrame -> SDoc

-- | Assembly for a single byte of constant DWARF data
pprByte :: Word8 -> SDoc

-- | Assembly for a two-byte constant integer
pprHalf :: Word16 -> SDoc

-- | Assembly for 4 bytes of dynamic DWARF data
pprData4' :: SDoc -> SDoc

-- | Assembly for a DWARF word of dynamic data. This means 32 bit, as we
--   are generating 32 bit DWARF.
pprDwWord :: SDoc -> SDoc

-- | Assembly for a machine word of dynamic data. Depends on the
--   architecture we are currently generating code for.
pprWord :: Platform -> SDoc -> SDoc

-- | Prints a number in "little endian base 128" format. The idea is to
--   optimize for small numbers by stopping once all further bytes would be
--   0. The highest bit in every byte signals whether there are further
--   bytes to read.
pprLEBWord :: Word -> SDoc

-- | Same as <tt>pprLEBWord</tt>, but for a signed number
pprLEBInt :: Int -> SDoc

-- | Align assembly at (machine) word boundary
wordAlign :: Platform -> SDoc

-- | Generate an offset into another section. This is tricky because this
--   is handled differently depending on platform: Mac Os expects us to
--   calculate the offset using assembler arithmetic. Linux expects us to
--   just reference the target directly, and will figure out on their own
--   that we actually need an offset. Finally, Windows has a special
--   directive to refer to relative offsets. Fun.
sectionOffset :: Platform -> SDoc -> SDoc -> SDoc
instance GHC.Enum.Enum GHC.CmmToAsm.Dwarf.Types.DwarfAbbrev
instance GHC.Classes.Eq GHC.CmmToAsm.Dwarf.Types.DwarfAbbrev
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.CmmToAsm.Dwarf.Types.DwarfFrameBlock

module GHC.CmmToAsm.Dwarf

-- | Generate DWARF/debug information
dwarfGen :: NCGConfig -> ModLocation -> UniqSupply -> [DebugBlock] -> IO (SDoc, UniqSupply)

module GHC.CmmToAsm.AArch64.CodeGen
cmmTopCodeGen :: RawCmmDecl -> NatM [NatCmmDecl RawCmmStatics Instr]
generateJumpTableForInstr :: NCGConfig -> Instr -> Maybe (NatCmmDecl RawCmmStatics Instr)


-- | Native code generator for x86 and x86-64 architectures
module GHC.CmmToAsm.AArch64
ncgAArch64 :: NCGConfig -> NcgImpl RawCmmStatics Instr JumpDest
instance GHC.CmmToAsm.Instr.Instruction GHC.CmmToAsm.AArch64.Instr.Instr


-- | Native code generator
--   
--   The native-code generator has machine-independent and
--   machine-dependent modules.
--   
--   This module (<a>GHC.CmmToAsm</a>) is the top-level machine-independent
--   module. Before entering machine-dependent land, we do some
--   machine-independent optimisations (defined below) on the
--   <tt>CmmStmts</tt>s.
--   
--   We convert to the machine-specific <a>Instr</a> datatype with
--   <tt>cmmCodeGen</tt>, assuming an infinite supply of registers. We then
--   use a machine-independent register allocator (<tt>regAlloc</tt>) to
--   rejoin reality. Obviously, <tt>regAlloc</tt> has machine-specific
--   helper functions (see about <a>RegAllocInfo</a> below).
--   
--   Finally, we order the basic blocks of the function so as to minimise
--   the number of jumps between blocks, by utilising fallthrough wherever
--   possible.
--   
--   The machine-dependent bits break down as follows:
--   
--   <ul>
--   <li>[<a>MachRegs</a>] Everything about the target platform's machine
--   registers (and immediate operands, and addresses, which tend to
--   intermingle/interact with registers).</li>
--   <li>[<a>MachInstrs</a>] Includes the <a>Instr</a> datatype (possibly
--   should have a module of its own), plus a miscellany of other things
--   (e.g., <tt>targetDoubleSize</tt>, <tt>smStablePtrTable</tt>, ...)</li>
--   <li>[<a>MachCodeGen</a>] is where <tt>Cmm</tt> stuff turns into
--   machine instructions.</li>
--   <li>[<a>PprMach</a>] <a>pprInstr</a> turns an <a>Instr</a> into text
--   (well, really a <a>SDoc</a>).</li>
--   <li>[<a>RegAllocInfo</a>] In the register allocator, we manipulate
--   <tt>MRegsState</tt>s, which are <tt>BitSet</tt>s, one bit per machine
--   register. When we want to say something about a specific machine
--   register (e.g., ``it gets clobbered by this instruction''), we
--   set/unset its bit. Obviously, we do this <tt>BitSet</tt> thing for
--   efficiency reasons.</li>
--   </ul>
--   
--   The <tt>RegAllocInfo</tt> module collects together the
--   machine-specific info needed to do register allocation.
--   
--   <ul>
--   <li>[<a>RegisterAlloc</a>] The (machine-independent) register
--   allocator. -}</li>
--   </ul>
module GHC.CmmToAsm
nativeCodeGen :: forall a. Logger -> DynFlags -> Module -> ModLocation -> Handle -> UniqSupply -> Stream IO RawCmmGroup a -> IO a

-- | Complete native code generation phase for a single top-level chunk of
--   Cmm. Dumping the output of each stage along the way. Global conflict
--   graph and NGC stats
cmmNativeGen :: forall statics instr jumpDest. (Instruction instr, OutputableP Platform statics, Outputable jumpDest) => Logger -> DynFlags -> ModLocation -> NcgImpl statics instr jumpDest -> UniqSupply -> DwarfFiles -> LabelMap DebugBlock -> RawCmmDecl -> Int -> IO (UniqSupply, DwarfFiles, [NatCmmDecl statics instr], [CLabel], Maybe [RegAllocStats statics instr], Maybe [RegAllocStats], LabelMap [UnwindPoint])
data NcgImpl statics instr jumpDest
NcgImpl :: !NCGConfig -> (RawCmmDecl -> NatM [NatCmmDecl statics instr]) -> (instr -> Maybe (NatCmmDecl statics instr)) -> (jumpDest -> Maybe BlockId) -> (instr -> Maybe jumpDest) -> ((BlockId -> Maybe jumpDest) -> statics -> statics) -> ((BlockId -> Maybe jumpDest) -> instr -> instr) -> (NatCmmDecl statics instr -> SDoc) -> Int -> [RealReg] -> ([NatCmmDecl statics instr] -> [NatCmmDecl statics instr]) -> (Int -> NatCmmDecl statics instr -> UniqSM (NatCmmDecl statics instr, [(BlockId, BlockId)])) -> (LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]) -> ([instr] -> [UnwindPoint]) -> (Maybe CFG -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]) -> NcgImpl statics instr jumpDest
[ncgConfig] :: NcgImpl statics instr jumpDest -> !NCGConfig
[cmmTopCodeGen] :: NcgImpl statics instr jumpDest -> RawCmmDecl -> NatM [NatCmmDecl statics instr]
[generateJumpTableForInstr] :: NcgImpl statics instr jumpDest -> instr -> Maybe (NatCmmDecl statics instr)
[getJumpDestBlockId] :: NcgImpl statics instr jumpDest -> jumpDest -> Maybe BlockId
[canShortcut] :: NcgImpl statics instr jumpDest -> instr -> Maybe jumpDest
[shortcutStatics] :: NcgImpl statics instr jumpDest -> (BlockId -> Maybe jumpDest) -> statics -> statics
[shortcutJump] :: NcgImpl statics instr jumpDest -> (BlockId -> Maybe jumpDest) -> instr -> instr

-- | <a>Module</a> is only for printing internal labels. See Note [Internal
--   proc labels] in CLabel.
[pprNatCmmDecl] :: NcgImpl statics instr jumpDest -> NatCmmDecl statics instr -> SDoc
[maxSpillSlots] :: NcgImpl statics instr jumpDest -> Int
[allocatableRegs] :: NcgImpl statics instr jumpDest -> [RealReg]
[ncgExpandTop] :: NcgImpl statics instr jumpDest -> [NatCmmDecl statics instr] -> [NatCmmDecl statics instr]

-- | The list of block ids records the redirected jumps to allow us to
--   update the CFG.
[ncgAllocMoreStack] :: NcgImpl statics instr jumpDest -> Int -> NatCmmDecl statics instr -> UniqSM (NatCmmDecl statics instr, [(BlockId, BlockId)])
[ncgMakeFarBranches] :: NcgImpl statics instr jumpDest -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]

-- | given the instruction sequence of a block, produce a list of the
--   block's <a>UnwindPoint</a>s See Note [What is this unwinding
--   business?] in <a>GHC.Cmm.DebugBlock</a> and Note [Unwinding
--   information in the NCG] in this module.
[extractUnwindPoints] :: NcgImpl statics instr jumpDest -> [instr] -> [UnwindPoint]

-- | Turn the sequence of <tt>jcc l1; jmp l2</tt> into <tt>jncc l2;
--   &lt;block_l1&gt;</tt> when possible.
[invertCondBranches] :: NcgImpl statics instr jumpDest -> Maybe CFG -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]

-- | Initialize the native code generator configuration from the DynFlags
initNCGConfig :: DynFlags -> Module -> NCGConfig
instance GHC.Base.Functor GHC.CmmToAsm.CmmOptM
instance GHC.Base.Applicative GHC.CmmToAsm.CmmOptM
instance GHC.Base.Monad GHC.CmmToAsm.CmmOptM
instance GHC.CmmToAsm.PIC.CmmMakeDynamicReferenceM GHC.CmmToAsm.CmmOptM

module GHC.Cmm.Dataflow
type C = 'Closed
type O = 'Open

-- | A sequence of nodes. May be any of four shapes (O<i>O, O</i>C, C<i>O,
--   C</i>C). Open at the entry means single entry, mutatis mutandis for
--   exit. A closed<i>closed block is a </i>basic/ block and can't be
--   extended further. Clients should avoid manipulating blocks and should
--   stick to either nodes or graphs.
data Block n e x
lastNode :: Block n x C -> n O C
entryLabel :: NonLocal thing => thing C x -> Label

-- | Folds backward over all nodes of an open-open block. Strict in the
--   accumulator.
foldNodesBwdOO :: (CmmNode O O -> f -> f) -> Block CmmNode O O -> f -> f

-- | Folds backward over all the nodes of an open-open block and allows
--   rewriting them. The accumulator is both the block of nodes and
--   <tt>f</tt> (usually dataflow facts). Strict in both accumulated parts.
foldRewriteNodesBwdOO :: forall f. (CmmNode O O -> f -> UniqSM (Block CmmNode O O, f)) -> Block CmmNode O O -> f -> UniqSM (Block CmmNode O O, f)
data DataflowLattice a
DataflowLattice :: a -> JoinFun a -> DataflowLattice a
[fact_bot] :: DataflowLattice a -> a
[fact_join] :: DataflowLattice a -> JoinFun a
newtype OldFact a
OldFact :: a -> OldFact a
newtype NewFact a
NewFact :: a -> NewFact a

-- | The result of joining OldFact and NewFact.
data JoinedFact a

-- | Result is different than OldFact.
Changed :: !a -> JoinedFact a

-- | Result is the same as OldFact.
NotChanged :: !a -> JoinedFact a
type TransferFun f = CmmBlock -> FactBase f -> FactBase f

-- | Function for rewrtiting and analysis combined. To be used with
--   <tt>rewriteCmm</tt>.
--   
--   Currently set to work with <tt>UniqSM</tt> monad, but we could
--   probably abstract that away (if we do that, we might want to
--   specialize the fixpoint algorithms to the particular monads through
--   SPECIALIZE).
type RewriteFun f = CmmBlock -> FactBase f -> UniqSM (CmmBlock, FactBase f)
type family Fact (x :: Extensibility) f :: Type
type FactBase f = LabelMap f
getFact :: DataflowLattice f -> Label -> FactBase f -> f

-- | Returns the joined facts for each label.
mkFactBase :: DataflowLattice f -> [(Label, f)] -> FactBase f
analyzeCmmFwd :: DataflowLattice f -> TransferFun f -> CmmGraph -> FactBase f -> FactBase f
analyzeCmmBwd :: DataflowLattice f -> TransferFun f -> CmmGraph -> FactBase f -> FactBase f
rewriteCmmBwd :: DataflowLattice f -> RewriteFun f -> CmmGraph -> FactBase f -> UniqSM (CmmGraph, FactBase f)
changedIf :: Bool -> a -> JoinedFact a

-- | Returns the result of joining the facts from all the successors of the
--   provided node or block.
joinOutFacts :: NonLocal n => DataflowLattice f -> n e C -> FactBase f -> f
joinFacts :: DataflowLattice f -> [f] -> f

module GHC.Cmm.Liveness
type CmmLocalLive = CmmLive LocalReg

-- | Calculated liveness info for a CmmGraph
cmmLocalLiveness :: Platform -> CmmGraph -> BlockEntryLiveness LocalReg
cmmLocalLivenessL :: Platform -> CmmGraph -> BlockEntryLivenessL
cmmGlobalLiveness :: Platform -> CmmGraph -> BlockEntryLiveness GlobalReg

-- | The dataflow lattice
liveLattice :: Ord r => DataflowLattice (CmmLive r)

-- | The dataflow lattice
liveLatticeL :: DataflowLattice LRegSet
gen_kill :: (DefinerOfRegs r n, UserOfRegs r n) => Platform -> n -> CmmLive r -> CmmLive r
gen_killL :: (DefinerOfRegs LocalReg n, UserOfRegs LocalReg n) => Platform -> n -> LRegSet -> LRegSet

module GHC.Cmm.Sink
cmmSink :: Platform -> CmmGraph -> CmmGraph

module GHC.Cmm.ProcPoint
type ProcPointSet = LabelSet
data Status
ReachedBy :: ProcPointSet -> Status
ProcPoint :: Status
callProcPoints :: CmmGraph -> ProcPointSet
minimalProcPointSet :: Platform -> ProcPointSet -> CmmGraph -> UniqSM ProcPointSet
splitAtProcPoints :: Platform -> CLabel -> ProcPointSet -> ProcPointSet -> LabelMap Status -> CmmDecl -> UniqSM [CmmDecl]
procPointAnalysis :: ProcPointSet -> CmmGraph -> LabelMap Status
attachContInfoTables :: ProcPointSet -> CmmDecl -> CmmDecl
instance GHC.Utils.Outputable.Outputable GHC.Cmm.ProcPoint.Status

module GHC.Cmm.Lint
cmmLint :: (OutputableP Platform d, OutputableP Platform h) => Platform -> GenCmmGroup d h CmmGraph -> Maybe SDoc
cmmLintGraph :: Platform -> CmmGraph -> Maybe SDoc
instance GHC.Base.Functor GHC.Cmm.Lint.CmmLint
instance GHC.Base.Applicative GHC.Cmm.Lint.CmmLint
instance GHC.Base.Monad GHC.Cmm.Lint.CmmLint

module GHC.Driver.CodeOutput
codeOutput :: Logger -> TmpFs -> DynFlags -> UnitState -> Module -> FilePath -> ModLocation -> (a -> ForeignStubs) -> [(ForeignSrcLang, FilePath)] -> [UnitId] -> Stream IO RawCmmGroup a -> IO (FilePath, (Bool, Maybe FilePath), [(ForeignSrcLang, FilePath)], a)
outputForeignStubs :: Logger -> TmpFs -> DynFlags -> UnitState -> Module -> ModLocation -> ForeignStubs -> IO (Bool, Maybe FilePath)

-- | Generate code to initialise cost centres
profilingInitCode :: Platform -> Module -> CollectedCCs -> CStub

-- | Generate code to initialise info pointer origin See note [Mapping Info
--   Tables to Source Positions]
ipInitCode :: DynFlags -> Module -> [InfoProvEnt] -> CStub

module GHC.Cmm.ContFlowOpt
cmmCfgOpts :: Bool -> CmmGraph -> CmmGraph
cmmCfgOptsProc :: Bool -> CmmDecl -> CmmDecl
removeUnreachableBlocksProc :: CmmDecl -> CmmDecl
replaceLabels :: LabelMap BlockId -> CmmGraph -> CmmGraph

module GHC.Cmm.CommonBlockElim
elimCommonBlocks :: CmmGraph -> CmmGraph

module GHC.Cmm.CallConv
data ParamLocation
RegisterParam :: GlobalReg -> ParamLocation
StackParam :: ByteOff -> ParamLocation

-- | Given a list of arguments, and a function that tells their types,
--   return a list showing where each argument is passed
assignArgumentsPos :: Profile -> ByteOff -> Convention -> (a -> CmmType) -> [a] -> (ByteOff, [(a, ParamLocation)])
assignStack :: Platform -> ByteOff -> (a -> CmmType) -> [a] -> (ByteOff, [(a, ParamLocation)])
realArgRegsCover :: Platform -> [GlobalReg]
tupleRegsCover :: Platform -> [GlobalReg]
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CallConv.ParamLocation

module GHC.Cmm.Graph

-- | CmmAGraph is a chunk of code consisting of:
--   
--   <ul>
--   <li>ordinary statements (assignments, stores etc.)</li>
--   <li>jumps</li>
--   <li>labels</li>
--   <li>out-of-line labelled blocks</li>
--   </ul>
--   
--   The semantics is that control falls through labels and out-of-line
--   blocks. Everything after a jump up to the next label is by definition
--   unreachable code, and will be discarded.
--   
--   Two CmmAGraphs can be stuck together with <a>*</a>, with the meaning
--   that control flows from the first to the second.
--   
--   A <a>CmmAGraph</a> can be turned into a <a>GenCmmGraph</a> (closed at
--   both ends) by providing a label for the entry point and a tick scope;
--   see <a>labelAGraph</a>.
type CmmAGraph = OrdList CgStmt

-- | Unlabeled graph with tick scope
type CmmAGraphScoped = (CmmAGraph, CmmTickScope)
data CgStmt
CgLabel :: BlockId -> CmmTickScope -> CgStmt
CgStmt :: CmmNode O O -> CgStmt
CgLast :: CmmNode O C -> CgStmt
CgFork :: BlockId -> CmmAGraph -> CmmTickScope -> CgStmt
(<*>) :: CmmAGraph -> CmmAGraph -> CmmAGraph
catAGraphs :: [CmmAGraph] -> CmmAGraph

-- | creates a sequence "goto id; id:" as an AGraph
mkLabel :: BlockId -> CmmTickScope -> CmmAGraph

-- | creates an open AGraph from a given node
mkMiddle :: CmmNode O O -> CmmAGraph

-- | creates a closed AGraph from a given node
mkLast :: CmmNode O C -> CmmAGraph

-- | A labelled code block; should end in a last node
outOfLine :: BlockId -> CmmAGraphScoped -> CmmAGraph

-- | allocate a fresh label for the entry point
lgraphOfAGraph :: CmmAGraphScoped -> UniqSM CmmGraph

-- | use the given BlockId as the label of the entry point
labelAGraph :: BlockId -> CmmAGraphScoped -> CmmGraph
stackStubExpr :: Width -> CmmExpr
mkNop :: CmmAGraph
mkAssign :: CmmReg -> CmmExpr -> CmmAGraph

-- | Assumes natural alignment
mkStore :: CmmExpr -> CmmExpr -> CmmAGraph
mkUnsafeCall :: ForeignTarget -> [CmmFormal] -> [CmmActual] -> CmmAGraph
mkFinalCall :: Profile -> CmmExpr -> CCallConv -> [CmmExpr] -> UpdFrameOffset -> CmmAGraph
mkCallReturnsTo :: Profile -> CmmExpr -> Convention -> [CmmExpr] -> BlockId -> ByteOff -> UpdFrameOffset -> [CmmExpr] -> CmmAGraph
mkJumpReturnsTo :: Profile -> CmmExpr -> Convention -> [CmmExpr] -> BlockId -> ByteOff -> UpdFrameOffset -> CmmAGraph
mkJump :: Profile -> Convention -> CmmExpr -> [CmmExpr] -> UpdFrameOffset -> CmmAGraph
mkJumpExtra :: Profile -> Convention -> CmmExpr -> [CmmExpr] -> UpdFrameOffset -> [CmmExpr] -> CmmAGraph

-- | A jump where the caller says what the live GlobalRegs are. Used for
--   low-level hand-written Cmm.
mkRawJump :: Profile -> CmmExpr -> UpdFrameOffset -> [GlobalReg] -> CmmAGraph
mkCbranch :: CmmExpr -> BlockId -> BlockId -> Maybe Bool -> CmmAGraph
mkSwitch :: CmmExpr -> SwitchTargets -> CmmAGraph
mkReturn :: Profile -> CmmExpr -> [CmmExpr] -> UpdFrameOffset -> CmmAGraph
mkComment :: FastString -> CmmAGraph
mkCallEntry :: Profile -> Convention -> [CmmFormal] -> [CmmFormal] -> (Int, [GlobalReg], CmmAGraph)
mkBranch :: BlockId -> CmmAGraph

-- | Construct a <a>CmmUnwind</a> node for the given register and unwinding
--   expression.
mkUnwind :: GlobalReg -> CmmExpr -> CmmAGraph
copyInOflow :: Profile -> Convention -> Area -> [CmmFormal] -> [CmmFormal] -> (Int, [GlobalReg], CmmAGraph)
copyOutOflow :: Profile -> Convention -> Transfer -> Area -> [CmmExpr] -> UpdFrameOffset -> [CmmExpr] -> (Int, [GlobalReg], CmmAGraph)
noExtraStack :: [CmmExpr]
toCall :: CmmExpr -> Maybe BlockId -> UpdFrameOffset -> ByteOff -> ByteOff -> [GlobalReg] -> CmmAGraph
data Transfer
Call :: Transfer
JumpRet :: Transfer
Jump :: Transfer
Ret :: Transfer
instance GHC.Classes.Eq GHC.Cmm.Graph.Transfer

module GHC.StgToCmm.Monad
data FCode a
initC :: IO CgState
runC :: DynFlags -> Module -> CgState -> FCode a -> (a, CgState)
fixC :: (a -> FCode a) -> FCode a
newUnique :: FCode Unique
emitLabel :: BlockId -> FCode ()
emit :: CmmAGraph -> FCode ()
emitDecl :: CmmDecl -> FCode ()
emitProcWithConvention :: Convention -> Maybe CmmInfoTable -> CLabel -> [CmmFormal] -> CmmAGraphScoped -> FCode ()
emitProcWithStackFrame :: Convention -> Maybe CmmInfoTable -> CLabel -> [CmmFormal] -> [CmmFormal] -> CmmAGraphScoped -> Bool -> FCode ()
emitOutOfLine :: BlockId -> CmmAGraphScoped -> FCode ()
emitAssign :: CmmReg -> CmmExpr -> FCode ()

-- | Assumes natural alignment.
emitStore :: CmmExpr -> CmmExpr -> FCode ()
emitStore' :: AlignmentSpec -> CmmExpr -> CmmExpr -> FCode ()
emitComment :: FastString -> FCode ()
emitTick :: CmmTickish -> FCode ()
emitUnwind :: [(GlobalReg, Maybe CmmExpr)] -> FCode ()
getCmm :: FCode a -> FCode (a, CmmGroup)
aGraphToGraph :: CmmAGraphScoped -> FCode CmmGraph
getPlatform :: FCode Platform
getProfile :: FCode Profile
getCodeR :: FCode a -> FCode (a, CmmAGraph)
getCode :: FCode a -> FCode CmmAGraph

-- | Generate code into a fresh tick (sub-)scope and gather generated code
getCodeScoped :: FCode a -> FCode (a, CmmAGraphScoped)
getHeapUsage :: (VirtualHpOffset -> FCode a) -> FCode a
getCallOpts :: FCode CallOpts
getPtrOpts :: FCode PtrOpts
mkCmmIfThenElse :: CmmExpr -> CmmAGraph -> CmmAGraph -> FCode CmmAGraph
mkCmmIfThen :: CmmExpr -> CmmAGraph -> FCode CmmAGraph
mkCmmIfGoto :: CmmExpr -> BlockId -> FCode CmmAGraph
mkCmmIfThenElse' :: CmmExpr -> CmmAGraph -> CmmAGraph -> Maybe Bool -> FCode CmmAGraph
mkCmmIfThen' :: CmmExpr -> CmmAGraph -> Maybe Bool -> FCode CmmAGraph
mkCmmIfGoto' :: CmmExpr -> BlockId -> Maybe Bool -> FCode CmmAGraph
mkCall :: CmmExpr -> (Convention, Convention) -> [CmmFormal] -> [CmmExpr] -> UpdFrameOffset -> [CmmExpr] -> FCode CmmAGraph
mkCmmCall :: CmmExpr -> [CmmFormal] -> [CmmExpr] -> UpdFrameOffset -> FCode CmmAGraph
forkClosureBody :: FCode () -> FCode ()
forkLneBody :: FCode a -> FCode a
forkAlts :: [FCode a] -> FCode [a]
forkAltPair :: FCode a -> FCode a -> FCode (a, a)
codeOnly :: FCode () -> FCode ()

-- | A *zero-indexed* constructor tag
type ConTagZ = Int
data Sequel
Return :: Sequel
AssignTo :: [LocalReg] -> Bool -> Sequel
data ReturnKind
AssignedDirectly :: ReturnKind
ReturnedTo :: BlockId -> ByteOff -> ReturnKind
withSequel :: Sequel -> FCode a -> FCode a
getSequel :: FCode Sequel
setTickyCtrLabel :: CLabel -> FCode a -> FCode a
getTickyCtrLabel :: FCode CLabel

-- | Places blocks generated by the given code into a fresh (sub-)scope.
--   This will make sure that Cmm annotations in our scope will apply to
--   the Cmm blocks generated therein - but not the other way around.
tickScope :: FCode a -> FCode a

-- | The current tick scope. We will assign this to generated blocks.
getTickScope :: FCode CmmTickScope
withUpdFrameOff :: UpdFrameOffset -> FCode a -> FCode a
getUpdFrameOff :: FCode UpdFrameOffset
initUpdFrameOff :: Platform -> UpdFrameOffset
data HeapUsage
HeapUsage :: VirtualHpOffset -> VirtualHpOffset -> HeapUsage
[virtHp] :: HeapUsage -> VirtualHpOffset
[realHp] :: HeapUsage -> VirtualHpOffset
type VirtualHpOffset = WordOff
initHpUsage :: HeapUsage
getHpUsage :: FCode HeapUsage
setHpUsage :: HeapUsage -> FCode ()
heapHWM :: HeapUsage -> VirtualHpOffset
setVirtHp :: VirtualHpOffset -> FCode ()
getVirtHp :: FCode VirtualHpOffset
setRealHp :: VirtualHpOffset -> FCode ()
getModuleName :: FCode Module
getState :: FCode CgState
setState :: CgState -> FCode ()
getSelfLoop :: FCode (Maybe SelfLoopInfo)
withSelfLoop :: SelfLoopInfo -> FCode a -> FCode a
getInfoDown :: FCode CgInfoDownwards
getDynFlags :: HasDynFlags m => m DynFlags
data CgIdInfo
CgIdInfo :: Id -> LambdaFormInfo -> CgLoc -> CgIdInfo
[cg_id] :: CgIdInfo -> Id
[cg_lf] :: CgIdInfo -> LambdaFormInfo
[cg_loc] :: CgIdInfo -> CgLoc
getBinds :: FCode CgBindings
setBinds :: CgBindings -> FCode ()
data CgInfoDownwards
MkCgInfoDown :: DynFlags -> Module -> UpdFrameOffset -> CLabel -> Sequel -> Maybe SelfLoopInfo -> CmmTickScope -> CgInfoDownwards
[cgd_dflags] :: CgInfoDownwards -> DynFlags
[cgd_mod] :: CgInfoDownwards -> Module
[cgd_updfr_off] :: CgInfoDownwards -> UpdFrameOffset
[cgd_ticky] :: CgInfoDownwards -> CLabel
[cgd_sequel] :: CgInfoDownwards -> Sequel
[cgd_self_loop] :: CgInfoDownwards -> Maybe SelfLoopInfo
[cgd_tick_scope] :: CgInfoDownwards -> CmmTickScope
data CgState
MkCgState :: CmmAGraph -> OrdList CmmDecl -> CgBindings -> HeapUsage -> UniqSupply -> CgState
[cgs_stmts] :: CgState -> CmmAGraph
[cgs_tops] :: CgState -> OrdList CmmDecl
[cgs_binds] :: CgState -> CgBindings
[cgs_hp_usg] :: CgState -> HeapUsage
[cgs_uniqs] :: CgState -> UniqSupply
instance GHC.Base.Functor GHC.StgToCmm.Monad.FCode
instance GHC.Base.Applicative GHC.StgToCmm.Monad.FCode
instance GHC.Base.Monad GHC.StgToCmm.Monad.FCode
instance GHC.Types.Unique.Supply.MonadUnique GHC.StgToCmm.Monad.FCode
instance GHC.Driver.Session.HasDynFlags GHC.StgToCmm.Monad.FCode
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Monad.Sequel
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.StgToCmm.Monad.CgIdInfo

module GHC.StgToCmm.Utils
cgLit :: Literal -> FCode CmmLit
mkSimpleLit :: Platform -> Literal -> CmmLit

-- | Emit a data-segment data block
emitDataLits :: CLabel -> [CmmLit] -> FCode ()

-- | Emit a read-only data block
emitRODataLits :: CLabel -> [CmmLit] -> FCode ()
emitDataCon :: CLabel -> CmmInfoTable -> CostCentreStack -> [CmmLit] -> FCode ()
emitRtsCall :: UnitId -> FastString -> [(CmmExpr, ForeignHint)] -> Bool -> FCode ()
emitRtsCallWithResult :: LocalReg -> ForeignHint -> UnitId -> FastString -> [(CmmExpr, ForeignHint)] -> Bool -> FCode ()
emitRtsCallGen :: [(LocalReg, ForeignHint)] -> CLabel -> [(CmmExpr, ForeignHint)] -> Bool -> FCode ()
assignTemp :: CmmExpr -> FCode LocalReg
newTemp :: MonadUnique m => CmmType -> m LocalReg
newUnboxedTupleRegs :: Type -> FCode ([LocalReg], [ForeignHint])
emitMultiAssign :: [LocalReg] -> [CmmExpr] -> FCode ()
emitCmmLitSwitch :: CmmExpr -> [(Literal, CmmAGraphScoped)] -> CmmAGraphScoped -> FCode ()
emitSwitch :: CmmExpr -> [(ConTagZ, CmmAGraphScoped)] -> Maybe CmmAGraphScoped -> ConTagZ -> ConTagZ -> FCode ()
tagToClosure :: Platform -> TyCon -> CmmExpr -> CmmExpr
mkTaggedObjectLoad :: Platform -> LocalReg -> LocalReg -> ByteOff -> DynTag -> CmmAGraph

-- | Returns <a>True</a> if this global register is stored in a
--   caller-saves machine register.
callerSaves :: Platform -> GlobalReg -> Bool
callerSaveVolatileRegs :: Platform -> (CmmAGraph, CmmAGraph)

-- | We map STG registers onto appropriate CmmExprs. Either they map to
--   real machine registers or stored as offsets from BaseReg. Given a
--   GlobalReg, get_GlobalReg_addr always produces the register table
--   address for it.
get_GlobalReg_addr :: Platform -> GlobalReg -> CmmExpr
callerSaveGlobalReg :: Platform -> GlobalReg -> CmmAGraph
callerRestoreGlobalReg :: Platform -> GlobalReg -> CmmAGraph
cmmAndWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmOrWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmNegate :: Platform -> CmmExpr -> CmmExpr
cmmEqWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmNeWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUGtWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmSubWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmMulWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmAddWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUShrWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmOffsetExprW :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmOffsetExprB :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmRegOffW :: Platform -> CmmReg -> WordOff -> CmmExpr
cmmRegOffB :: CmmReg -> ByteOff -> CmmExpr
cmmLabelOffW :: Platform -> CLabel -> WordOff -> CmmLit
cmmLabelOffB :: CLabel -> ByteOff -> CmmLit
cmmOffsetW :: Platform -> CmmExpr -> WordOff -> CmmExpr
cmmOffsetB :: Platform -> CmmExpr -> ByteOff -> CmmExpr
cmmOffsetLitW :: Platform -> CmmLit -> WordOff -> CmmLit
cmmOffsetLitB :: CmmLit -> ByteOff -> CmmLit
cmmLoadIndexW :: Platform -> CmmExpr -> Int -> CmmType -> CmmExpr
cmmConstrTag1 :: Platform -> CmmExpr -> CmmExpr
cmmUntag :: Platform -> CmmExpr -> CmmExpr
cmmIsTagged :: Platform -> CmmExpr -> CmmExpr

-- | <tt>addToMem rep ptr n</tt> adds <tt>n</tt> to the integer pointed-to
--   by <tt>ptr</tt>.
addToMem :: CmmType -> CmmExpr -> Int -> CmmAGraph

-- | <tt>addToMemE rep ptr n</tt> adds <tt>n</tt> to the integer pointed-to
--   by <tt>ptr</tt>.
addToMemE :: CmmType -> CmmExpr -> CmmExpr -> CmmAGraph
addToMemLblE :: CmmType -> CLabel -> CmmExpr -> CmmAGraph
addToMemLbl :: CmmType -> CLabel -> Int -> CmmAGraph
newStringCLit :: String -> FCode CmmLit
newByteStringCLit :: ByteString -> FCode CmmLit
whenUpdRemSetEnabled :: FCode a -> FCode ()

-- | Emit code to add an entry to a now-overwritten pointer to the update
--   remembered set.
emitUpdRemSetPush :: CmmExpr -> FCode ()
emitUpdRemSetPushThunk :: CmmExpr -> FCode ()

-- | Convert source information collected about identifiers in <a>Debug</a>
--   to entries suitable for placing into the info table provenenance
--   table.
convertInfoProvMap :: DynFlags -> [CmmInfoTable] -> Module -> InfoTableProvMap -> [InfoProvEnt]

-- | A bare bones InfoProvEnt for things which don't have a good source
--   location
cmmInfoTableToInfoProvEnt :: Module -> CmmInfoTable -> InfoProvEnt

module GHC.StgToCmm.Prof
initCostCentres :: CollectedCCs -> FCode ()
ccType :: Platform -> CmmType
ccsType :: Platform -> CmmType
mkCCostCentre :: CostCentre -> CmmLit
mkCCostCentreStack :: CostCentreStack -> CmmLit
initInfoTableProv :: [CmmInfoTable] -> InfoTableProvMap -> Module -> FCode CStub
emitInfoTableProv :: InfoProvEnt -> FCode ()

-- | Profiling header words in a dynamic closure
dynProfHdr :: Profile -> CmmExpr -> [CmmExpr]

-- | Record the allocation of a closure. The CmmExpr is the cost centre
--   stack to which to attribute the allocation.
profDynAlloc :: SMRep -> CmmExpr -> FCode ()

-- | Record the allocation of a closure (size is given by a CmmExpr) The
--   size must be in words, because the allocation counter in a CCS counts
--   in words.
profAlloc :: CmmExpr -> CmmExpr -> FCode ()

-- | The profiling header words in a static closure
staticProfHdr :: Profile -> CostCentreStack -> [CmmLit]

-- | Initialise the profiling field of an update frame
initUpdFrameProf :: CmmExpr -> FCode ()
enterCostCentreThunk :: CmmExpr -> FCode ()
enterCostCentreFun :: CostCentreStack -> CmmExpr -> FCode ()
costCentreFrom :: Platform -> CmmExpr -> CmmExpr
storeCurCCS :: CmmExpr -> CmmAGraph
emitSetCCC :: CostCentre -> Bool -> Bool -> FCode ()
saveCurrentCostCentre :: FCode (Maybe LocalReg)
restoreCurrentCostCentre :: Maybe LocalReg -> FCode ()
ldvEnter :: CmmExpr -> FCode ()

-- | Called when a closure is entered, marks the closure as having been
--   "used". The closure is not an "inherently used" one. The closure is
--   not <tt>IND</tt> because that is not considered for LDV profiling.
ldvEnterClosure :: ClosureInfo -> CmmReg -> FCode ()
ldvRecordCreate :: CmmExpr -> FCode ()

module GHC.StgToCmm.Hpc

-- | Emit top-level tables for HPC and return code to initialise
initHpc :: Module -> HpcInfo -> FCode ()
mkTickBox :: Platform -> Module -> Int -> CmmAGraph


-- | Our extended FCode monad.
module GHC.StgToCmm.ExtCode

-- | Does a computation in the FCode monad, with a current environment and
--   a list of local declarations. Returns the resulting list of
--   declarations.
data CmmParse a
unEC :: CmmParse a -> String -> Env -> Decls -> FCode (Decls, a)

-- | The environment contains variable definitions or blockids.
data Named

-- | Holds CmmLit(CmmLabel ..) which gives the label type, eg, RtsLabel,
--   ForeignLabel, CmmLabel etc.
VarN :: CmmExpr -> Named

-- | A function name from this unit
FunN :: UnitId -> Named

-- | A blockid of some code or data.
LabelN :: BlockId -> Named

-- | An environment of named things.
type Env = UniqFM FastString Named

-- | Takes the variable declarations and imports from the monad and makes
--   an environment, which is looped back into the computation. In this
--   way, we can have embedded declarations that scope over the whole
--   procedure, and imports that scope over the entire module. Discards the
--   local declaration contained within decl'
loopDecls :: CmmParse a -> CmmParse a

-- | Get the current environment from the monad.
getEnv :: CmmParse Env

-- | Set context name for a sub-parse
withName :: String -> CmmParse a -> CmmParse a

-- | Get the current context name from the monad
getName :: CmmParse String

-- | Create a fresh local variable of a given type.
newLocal :: CmmType -> FastString -> CmmParse LocalReg

-- | Allocate a fresh label.
newLabel :: FastString -> CmmParse BlockId
newBlockId :: MonadUnique m => m BlockId

-- | Add a local function to the environment.
newFunctionName :: FastString -> UnitId -> ExtCode

-- | Add an imported foreign label to the list of local declarations. If
--   this is done at the start of the module the declaration will scope
--   over the whole module.
newImport :: (FastString, CLabel) -> CmmParse ()

-- | Lookup the BlockId bound to the label with this name. If one hasn't
--   been bound yet, create a fresh one based on the Unique of the name.
lookupLabel :: FastString -> CmmParse BlockId

-- | Lookup the location of a named variable. Unknown names are treated as
--   if they had been 'import'ed from the runtime system. This saves us a
--   lot of bother in the RTS sources, at the expense of deferring some
--   errors to link time.
lookupName :: FastString -> CmmParse CmmExpr

-- | Lift an FCode computation into the CmmParse monad
code :: FCode a -> CmmParse a
emit :: CmmAGraph -> CmmParse ()
emitLabel :: BlockId -> CmmParse ()
emitAssign :: CmmReg -> CmmExpr -> CmmParse ()
emitStore :: CmmExpr -> CmmExpr -> CmmParse ()
getCode :: CmmParse a -> CmmParse CmmAGraph
getCodeR :: CmmParse a -> CmmParse (a, CmmAGraph)
getCodeScoped :: CmmParse a -> CmmParse (a, CmmAGraphScoped)
emitOutOfLine :: BlockId -> CmmAGraphScoped -> CmmParse ()
withUpdFrameOff :: UpdFrameOffset -> CmmParse () -> CmmParse ()
getUpdFrameOff :: CmmParse UpdFrameOffset
getProfile :: CmmParse Profile
getPlatform :: CmmParse Platform
getPtrOpts :: CmmParse PtrOpts
instance GHC.Base.Functor GHC.StgToCmm.ExtCode.CmmParse
instance GHC.Base.Applicative GHC.StgToCmm.ExtCode.CmmParse
instance GHC.Base.Monad GHC.StgToCmm.ExtCode.CmmParse
instance GHC.Types.Unique.Supply.MonadUnique GHC.StgToCmm.ExtCode.CmmParse
instance GHC.Driver.Session.HasDynFlags GHC.StgToCmm.ExtCode.CmmParse

module GHC.StgToCmm.Env
data CgIdInfo
litIdInfo :: Platform -> Id -> LambdaFormInfo -> CmmLit -> CgIdInfo
lneIdInfo :: Platform -> Id -> [NonVoid Id] -> CgIdInfo
rhsIdInfo :: Id -> LambdaFormInfo -> FCode (CgIdInfo, LocalReg)
mkRhsInit :: Platform -> LocalReg -> LambdaFormInfo -> CmmExpr -> CmmAGraph
idInfoToAmode :: CgIdInfo -> CmmExpr
addBindC :: CgIdInfo -> FCode ()
addBindsC :: [CgIdInfo] -> FCode ()
bindArgsToRegs :: [NonVoid Id] -> FCode [LocalReg]
bindToReg :: NonVoid Id -> LambdaFormInfo -> FCode LocalReg
rebindToReg :: NonVoid Id -> FCode LocalReg
bindArgToReg :: NonVoid Id -> FCode LocalReg
idToReg :: Platform -> NonVoid Id -> LocalReg
getArgAmode :: NonVoid StgArg -> FCode CmmExpr
getNonVoidArgAmodes :: [StgArg] -> FCode [CmmExpr]
getCgIdInfo :: Id -> FCode CgIdInfo
maybeLetNoEscape :: CgIdInfo -> Maybe (BlockId, [LocalReg])

module GHC.StgToCmm.Foreign

-- | Emit code for a foreign call, and return the results to the sequel.
--   Precondition: the length of the arguments list is the same as the
--   arity of the foreign function.
cgForeignCall :: ForeignCall -> Type -> [StgArg] -> Type -> FCode ReturnKind
emitPrimCall :: [CmmFormal] -> CallishMachOp -> [CmmActual] -> FCode ()
emitCCall :: [(CmmFormal, ForeignHint)] -> CmmExpr -> [(CmmActual, ForeignHint)] -> FCode ()
emitForeignCall :: Safety -> [CmmFormal] -> ForeignTarget -> [CmmActual] -> FCode ReturnKind
emitSaveThreadState :: FCode ()

-- | Produce code to save the current thread state to <tt>CurrentTSO</tt>
saveThreadState :: MonadUnique m => Profile -> m CmmAGraph
emitLoadThreadState :: FCode ()

-- | Save STG registers
--   
--   STG registers must be saved around a C call, just in case the STG
--   register is mapped to a caller-saves machine register. Normally we
--   don't need to worry about this the code generator has already loaded
--   any live STG registers into variables for us, but in hand-written
--   low-level Cmm code where we don't know which registers are live, we
--   might have to save them all.
emitSaveRegs :: FCode ()

-- | Restore STG registers (see <a>emitSaveRegs</a>)
emitRestoreRegs :: FCode ()

-- | Push a subset of STG registers onto the stack, specified by the bitmap
--   
--   Sometimes, a "live" subset of the STG registers needs to be saved on
--   the stack, for example when storing an unboxed tuple to be used in the
--   GHCi bytecode interpreter.
--   
--   The "live registers" bitmap corresponds to the list of registers given
--   by <a>tupleRegsCover</a>, with the least significant bit indicating
--   liveness of the first register in the list.
--   
--   Each register is saved to a stack slot of one or more machine words,
--   even if the register size itself is smaller.
--   
--   The resulting Cmm code looks like this, with a line for each real or
--   virtual register used for returning tuples:
--   
--   ... if((mask &amp; 2) != 0) { Sp_adj(-1); Sp(0) = R2; } if((mask &amp;
--   1) != 0) { Sp_adj(-1); Sp(0) = R1; }
--   
--   See Note [GHCi tuple layout]
emitPushTupleRegs :: CmmExpr -> FCode ()

-- | Pop a subset of STG registers from the stack (see
--   <a>emitPushTupleRegs</a>)
emitPopTupleRegs :: CmmExpr -> FCode ()

-- | Produce code to load the current thread state from <tt>CurrentTSO</tt>
loadThreadState :: MonadUnique m => Profile -> m CmmAGraph
emitOpenNursery :: FCode ()
emitCloseNursery :: FCode ()

module GHC.StgToCmm.Layout
mkArgDescr :: Platform -> [Id] -> ArgDescr

-- | <tt>emitCall conv fun args</tt> makes a call to the entry-code of
--   <tt>fun</tt>, using the call/return convention <tt>conv</tt>, passing
--   <tt>args</tt>, and returning the results to the current sequel.
emitCall :: (Convention, Convention) -> CmmExpr -> [CmmExpr] -> FCode ReturnKind

-- | Return multiple values to the sequel
--   
--   If the sequel is <tt>Return</tt>
--   
--   <pre>
--   return (x,y)
--   </pre>
--   
--   If the sequel is <tt>AssignTo [p,q]</tt>
--   
--   <pre>
--   p=x; q=y;
--   </pre>
emitReturn :: [CmmExpr] -> FCode ReturnKind
adjustHpBackwards :: FCode ()
emitClosureProcAndInfoTable :: Bool -> Id -> LambdaFormInfo -> CmmInfoTable -> [NonVoid Id] -> ((Int, LocalReg, [LocalReg]) -> FCode ()) -> FCode ()
emitClosureAndInfoTable :: Platform -> CmmInfoTable -> Convention -> [LocalReg] -> FCode () -> FCode ()
slowCall :: CmmExpr -> [StgArg] -> FCode ReturnKind
directCall :: Convention -> CLabel -> RepArity -> [StgArg] -> FCode ReturnKind
data FieldOffOrPadding a
FieldOff :: NonVoid a -> ByteOff -> FieldOffOrPadding a
Padding :: ByteOff -> ByteOff -> FieldOffOrPadding a

-- | Used to tell the various <tt>mkVirtHeapOffsets</tt> functions what
--   kind of header the object has. This will be accounted for in the
--   offsets of the fields returned.
data ClosureHeader
NoHeader :: ClosureHeader
StdHeader :: ClosureHeader
ThunkHeader :: ClosureHeader
mkVirtHeapOffsets :: Profile -> ClosureHeader -> [NonVoid (PrimRep, a)] -> (WordOff, WordOff, [(NonVoid a, ByteOff)])
mkVirtHeapOffsetsWithPadding :: Profile -> ClosureHeader -> [NonVoid (PrimRep, a)] -> (WordOff, WordOff, [FieldOffOrPadding a])

-- | Just like mkVirtHeapOffsets, but for constructors
mkVirtConstrOffsets :: Profile -> [NonVoid (PrimRep, a)] -> (WordOff, WordOff, [(NonVoid a, ByteOff)])

-- | Just like mkVirtConstrOffsets, but used when we don't have the actual
--   arguments. Useful when e.g. generating info tables; we just need to
--   know sizes of pointer and non-pointer fields.
mkVirtConstrSizes :: Profile -> [NonVoid PrimRep] -> (WordOff, WordOff)
getHpRelOffset :: VirtualHpOffset -> FCode CmmExpr
data ArgRep
P :: ArgRep
N :: ArgRep
L :: ArgRep
V :: ArgRep
F :: ArgRep
D :: ArgRep
V16 :: ArgRep
V32 :: ArgRep
V64 :: ArgRep
toArgRep :: Platform -> PrimRep -> ArgRep
argRepSizeW :: Platform -> ArgRep -> WordOff

module GHC.StgToCmm.Ticky
withNewTickyCounterFun :: Bool -> Name -> [NonVoid Id] -> FCode a -> FCode a
withNewTickyCounterLNE :: Name -> [NonVoid Id] -> FCode a -> FCode a
withNewTickyCounterThunk :: Bool -> Bool -> Name -> FCode a -> FCode a
withNewTickyCounterStdThunk :: Bool -> Name -> FCode a -> FCode a
withNewTickyCounterCon :: Name -> DataCon -> FCode a -> FCode a
tickyDynAlloc :: Maybe Id -> SMRep -> LambdaFormInfo -> FCode ()
tickyAllocHeap :: Bool -> VirtualHpOffset -> FCode ()
tickyAllocPrim :: CmmExpr -> CmmExpr -> CmmExpr -> FCode ()
tickyAllocThunk :: CmmExpr -> CmmExpr -> FCode ()
tickyAllocPAP :: CmmExpr -> CmmExpr -> FCode ()
tickyHeapCheck :: FCode ()
tickyStackCheck :: FCode ()
tickyDirectCall :: RepArity -> [StgArg] -> FCode ()
tickyPushUpdateFrame :: FCode ()
tickyUpdateFrameOmitted :: FCode ()
tickyEnterDynCon :: FCode ()
tickyEnterFun :: ClosureInfo -> FCode ()
tickyEnterThunk :: ClosureInfo -> FCode ()
tickyEnterLNE :: FCode ()
tickyUpdateBhCaf :: ClosureInfo -> FCode ()
tickyUnboxedTupleReturn :: RepArity -> FCode ()
tickyReturnOldCon :: RepArity -> FCode ()
tickyReturnNewCon :: RepArity -> FCode ()
tickySlowCall :: LambdaFormInfo -> [StgArg] -> FCode ()


-- | Provides the heuristics for when it's beneficial to lambda lift
--   bindings. Most significantly, this employs a cost model to estimate
--   impact on heap allocations, by looking at an STG expression's
--   <a>Skeleton</a>.
module GHC.Stg.Lift.Analysis

-- | Captures details of the syntax tree relevant to the cost model, such
--   as closures, multi-shot lambdas and case expressions.
data Skeleton
ClosureSk :: !Id -> !DIdSet -> !Skeleton -> Skeleton
RhsSk :: !Card -> !Skeleton -> Skeleton
AltSk :: !Skeleton -> !Skeleton -> Skeleton
BothSk :: !Skeleton -> !Skeleton -> Skeleton
NilSk :: Skeleton

-- | The type used in binder positions in <a>GenStgExpr</a>s.
data BinderInfo

-- | Let(-no-escape)-bound thing with a flag indicating whether it occurs
--   as an argument or in a nullary application (see
--   <a>GHC.Stg.Lift.Analysis#arg_occs</a>).
BindsClosure :: !Id -> !Bool -> BinderInfo

-- | Every other kind of binder
BoringBinder :: !Id -> BinderInfo

-- | Gets the bound <a>Id</a> out a <a>BinderInfo</a>.
binderInfoBndr :: BinderInfo -> Id
type LlStgBinding = GenStgBinding 'LiftLams
type LlStgExpr = GenStgExpr 'LiftLams
type LlStgRhs = GenStgRhs 'LiftLams
type LlStgAlt = GenStgAlt 'LiftLams

-- | Tags every binder with its <a>BinderInfo</a> and let bindings with
--   their <a>Skeleton</a>s.
tagSkeletonTopBind :: CgStgBinding -> LlStgBinding

-- | Combines several heuristics to decide whether to lambda-lift a given
--   <tt>let</tt>-binding to top-level. See
--   <a>GHC.Stg.Lift.Analysis#when</a> for details.
goodToLift :: DynFlags -> TopLevelFlag -> RecFlag -> (DIdSet -> DIdSet) -> [(BinderInfo, LlStgRhs)] -> Skeleton -> Maybe DIdSet

-- | <tt>closureGrowth expander sizer f fvs</tt> computes the closure
--   growth in words as a result of lifting <tt>f</tt> to top-level. If
--   there was any growing closure under a multi-shot lambda, the result
--   will be <a>infinity</a>. Also see <a>GHC.Stg.Lift.Analysis#clogro</a>.
closureGrowth :: (DIdSet -> DIdSet) -> (Id -> Int) -> IdSet -> DIdSet -> Skeleton -> IntWithInf
instance GHC.Utils.Outputable.Outputable GHC.Stg.Lift.Analysis.BinderInfo
instance GHC.Utils.Outputable.OutputableBndr GHC.Stg.Lift.Analysis.BinderInfo
instance GHC.Utils.Outputable.Outputable GHC.Stg.Lift.Analysis.Skeleton


-- | Implements a selective lambda lifter, running late in the optimisation
--   pipeline.
--   
--   If you are interested in the cost model that is employed to decide
--   whether to lift a binding or not, look at
--   <a>GHC.Stg.Lift.Analysis</a>. <a>GHC.Stg.Lift.Monad</a> contains the
--   transformation monad that hides away some plumbing of the
--   transformation.
module GHC.Stg.Lift

-- | Lambda lifts bindings to top-level deemed worth lifting (see
--   <a>goodToLift</a>).
--   
--   (Mostly) textbook instance of the lambda lifting transformation,
--   selecting which bindings to lambda lift by consulting
--   <a>goodToLift</a>.
stgLiftLams :: DynFlags -> UniqSupply -> [InStgTopBinding] -> [OutStgTopBinding]


-- | Bytecode instruction definitions
module GHC.ByteCode.Instr
data BCInstr
STKCHECK :: Word -> BCInstr
PUSH_L :: !Word16 -> BCInstr
PUSH_LL :: !Word16 -> !Word16 -> BCInstr
PUSH_LLL :: !Word16 -> !Word16 -> !Word16 -> BCInstr
PUSH8 :: !Word16 -> BCInstr
PUSH16 :: !Word16 -> BCInstr
PUSH32 :: !Word16 -> BCInstr
PUSH8_W :: !Word16 -> BCInstr
PUSH16_W :: !Word16 -> BCInstr
PUSH32_W :: !Word16 -> BCInstr
PUSH_G :: Name -> BCInstr
PUSH_PRIMOP :: PrimOp -> BCInstr
PUSH_BCO :: ProtoBCO Name -> BCInstr
PUSH_ALTS :: ProtoBCO Name -> BCInstr
PUSH_ALTS_UNLIFTED :: ProtoBCO Name -> ArgRep -> BCInstr
PUSH_ALTS_TUPLE :: ProtoBCO Name -> !TupleInfo -> ProtoBCO Name -> BCInstr
PUSH_PAD8 :: BCInstr
PUSH_PAD16 :: BCInstr
PUSH_PAD32 :: BCInstr
PUSH_UBX8 :: Literal -> BCInstr
PUSH_UBX16 :: Literal -> BCInstr
PUSH_UBX32 :: Literal -> BCInstr
PUSH_UBX :: Literal -> Word16 -> BCInstr
PUSH_APPLY_N :: BCInstr
PUSH_APPLY_V :: BCInstr
PUSH_APPLY_F :: BCInstr
PUSH_APPLY_D :: BCInstr
PUSH_APPLY_L :: BCInstr
PUSH_APPLY_P :: BCInstr
PUSH_APPLY_PP :: BCInstr
PUSH_APPLY_PPP :: BCInstr
PUSH_APPLY_PPPP :: BCInstr
PUSH_APPLY_PPPPP :: BCInstr
PUSH_APPLY_PPPPPP :: BCInstr
SLIDE :: Word16 -> Word16 -> BCInstr
ALLOC_AP :: !Word16 -> BCInstr
ALLOC_AP_NOUPD :: !Word16 -> BCInstr
ALLOC_PAP :: !Word16 -> !Word16 -> BCInstr
MKAP :: !Word16 -> !Word16 -> BCInstr
MKPAP :: !Word16 -> !Word16 -> BCInstr
UNPACK :: !Word16 -> BCInstr
PACK :: DataCon -> !Word16 -> BCInstr
LABEL :: LocalLabel -> BCInstr
TESTLT_I :: Int -> LocalLabel -> BCInstr
TESTEQ_I :: Int -> LocalLabel -> BCInstr
TESTLT_W :: Word -> LocalLabel -> BCInstr
TESTEQ_W :: Word -> LocalLabel -> BCInstr
TESTLT_F :: Float -> LocalLabel -> BCInstr
TESTEQ_F :: Float -> LocalLabel -> BCInstr
TESTLT_D :: Double -> LocalLabel -> BCInstr
TESTEQ_D :: Double -> LocalLabel -> BCInstr
TESTLT_P :: Word16 -> LocalLabel -> BCInstr
TESTEQ_P :: Word16 -> LocalLabel -> BCInstr
CASEFAIL :: BCInstr
JMP :: LocalLabel -> BCInstr
CCALL :: Word16 -> RemotePtr C_ffi_cif -> Word16 -> BCInstr
SWIZZLE :: Word16 -> Word16 -> BCInstr
ENTER :: BCInstr
RETURN :: BCInstr
RETURN_UNLIFTED :: ArgRep -> BCInstr
RETURN_TUPLE :: BCInstr
BRK_FUN :: Word16 -> Unique -> RemotePtr CostCentre -> BCInstr
data ProtoBCO a
ProtoBCO :: a -> [BCInstr] -> [StgWord] -> Word16 -> Int -> Either [CgStgAlt] CgStgRhs -> [FFIInfo] -> ProtoBCO a
[protoBCOName] :: ProtoBCO a -> a
[protoBCOInstrs] :: ProtoBCO a -> [BCInstr]
[protoBCOBitmap] :: ProtoBCO a -> [StgWord]
[protoBCOBitmapSize] :: ProtoBCO a -> Word16
[protoBCOArity] :: ProtoBCO a -> Int
[protoBCOExpr] :: ProtoBCO a -> Either [CgStgAlt] CgStgRhs
[protoBCOFFIs] :: ProtoBCO a -> [FFIInfo]
bciStackUse :: BCInstr -> Word

-- | A local block label (e.g. identifying a case alternative).
newtype LocalLabel
LocalLabel :: Word32 -> LocalLabel
[getLocalLabel] :: LocalLabel -> Word32
instance GHC.Classes.Ord GHC.ByteCode.Instr.LocalLabel
instance GHC.Classes.Eq GHC.ByteCode.Instr.LocalLabel
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.ByteCode.Instr.ProtoBCO a)
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Instr.BCInstr
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Instr.LocalLabel

module GHC.StgToCmm.Heap
getVirtHp :: FCode VirtualHpOffset
setVirtHp :: VirtualHpOffset -> FCode ()
setRealHp :: VirtualHpOffset -> FCode ()
getHpRelOffset :: VirtualHpOffset -> FCode CmmExpr
entryHeapCheck :: ClosureInfo -> Maybe LocalReg -> Int -> [LocalReg] -> FCode () -> FCode ()
altHeapCheck :: [LocalReg] -> FCode a -> FCode a
noEscapeHeapCheck :: [LocalReg] -> FCode a -> FCode a
altHeapCheckReturnsTo :: [LocalReg] -> Label -> ByteOff -> FCode a -> FCode a
heapStackCheckGen :: Maybe CmmExpr -> Maybe CmmExpr -> FCode ()

-- | lower-level version for <a>GHC.Cmm.Parser</a>
entryHeapCheck' :: Bool -> CmmExpr -> Int -> [LocalReg] -> FCode () -> FCode ()
mkStaticClosureFields :: Profile -> CmmInfoTable -> CostCentreStack -> CafInfo -> [CmmLit] -> [CmmLit]
mkStaticClosure :: Profile -> CLabel -> CostCentreStack -> [CmmLit] -> [CmmLit] -> [CmmLit] -> [CmmLit] -> [CmmLit]
allocDynClosure :: Maybe Id -> CmmInfoTable -> LambdaFormInfo -> CmmExpr -> CmmExpr -> [(NonVoid StgArg, VirtualHpOffset)] -> FCode CmmExpr
allocDynClosureCmm :: Maybe Id -> CmmInfoTable -> LambdaFormInfo -> CmmExpr -> CmmExpr -> [(CmmExpr, ByteOff)] -> FCode CmmExpr

-- | Low-level heap object allocation.
allocHeapClosure :: SMRep -> CmmExpr -> CmmExpr -> [(CmmExpr, ByteOff)] -> FCode CmmExpr
emitSetDynHdr :: CmmExpr -> CmmExpr -> CmmExpr -> FCode ()

module GHC.Cmm.Info.Build
type CAFSet = Set CAFLabel
type CAFEnv = LabelMap CAFSet

-- | For each code block: - collect the references reachable from this code
--   block to FUN, THUNK or RET labels for which hasCAF == True
--   
--   This gives us a <a>CAFEnv</a>: a mapping from code block to sets of
--   labels
cafAnal :: Platform -> LabelSet -> CLabel -> CmmGraph -> CAFEnv
cafAnalData :: Platform -> CmmStatics -> CAFSet

-- | Attach SRTs to all info tables in the CmmDecls, and add SRT
--   declarations to the ModuleSRTInfo.
doSRTs :: DynFlags -> ModuleSRTInfo -> [(CAFEnv, [CmmDecl])] -> [(CAFSet, CmmDecl)] -> IO (ModuleSRTInfo, [CmmDeclSRTs])
data ModuleSRTInfo
ModuleSRTInfo :: Module -> Map (Set SRTEntry) SRTEntry -> Map SRTEntry (Set SRTEntry) -> SRTMap -> ModuleSRTInfo

-- | Current module being compiled. Required for calling labelDynamic.
[thisModule] :: ModuleSRTInfo -> Module

-- | previous SRTs we've emitted, so we can de-duplicate. Used to implement
--   the [Common] optimisation.
[dedupSRTs] :: ModuleSRTInfo -> Map (Set SRTEntry) SRTEntry

-- | The reverse mapping, so that we can remove redundant entries. e.g. if
--   we have an SRT [a,b,c], and we know that b points to [c,d], we can
--   omit c and emit [a,b]. Used to implement the [Filter] optimisation.
[flatSRTs] :: ModuleSRTInfo -> Map SRTEntry (Set SRTEntry)
[moduleSRTMap] :: ModuleSRTInfo -> SRTMap
emptySRT :: Module -> ModuleSRTInfo

-- | Maps labels from <a>cafAnal</a> to the final CLabel that will appear
--   in the SRT. - closures with singleton SRTs resolve to their single
--   entry - closures with larger SRTs map to the label for that SRT - CAFs
--   must not map to anything! - if a labels maps to Nothing, we found that
--   this label's SRT is empty, so we don't need to refer to it from other
--   SRTs.
type SRTMap = Map CAFLabel (Maybe SRTEntry)

-- | Given <a>SRTMap</a> of a module, returns the set of non-CAFFY names in
--   the module. Any <tt>Name</tt>s not in the set are CAFFY.
srtMapNonCAFs :: SRTMap -> NonCaffySet
instance GHC.Classes.Ord GHC.Cmm.Info.Build.CAFLabel
instance GHC.Classes.Eq GHC.Cmm.Info.Build.CAFLabel
instance GHC.Classes.Ord GHC.Cmm.Info.Build.SRTEntry
instance GHC.Classes.Eq GHC.Cmm.Info.Build.SRTEntry
instance GHC.Classes.Ord GHC.Cmm.Info.Build.SomeLabel
instance GHC.Classes.Eq GHC.Cmm.Info.Build.SomeLabel
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.Info.Build.CAFLabel
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.Info.Build.SRTEntry
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.Info.Build.ModuleSRTInfo
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.Info.Build.SomeLabel

module GHC.StgToCmm.Prim
cgOpApp :: StgOp -> [StgArg] -> Type -> FCode ReturnKind
shouldInlinePrimOp :: DynFlags -> PrimOp -> [CmmExpr] -> Bool

module GHC.StgToCmm.DataCon
cgTopRhsCon :: DynFlags -> Id -> DataCon -> ConstructorNumber -> [NonVoid StgArg] -> (CgIdInfo, FCode ())
buildDynCon :: Id -> ConstructorNumber -> Bool -> CostCentreStack -> DataCon -> [NonVoid StgArg] -> FCode (CgIdInfo, FCode CmmAGraph)
bindConArgs :: AltCon -> LocalReg -> [NonVoid Id] -> FCode [LocalReg]

module GHC.StgToCmm.Bind
cgTopRhsClosure :: Platform -> RecFlag -> Id -> CostCentreStack -> UpdateFlag -> [Id] -> CgStgExpr -> (CgIdInfo, FCode ())
cgBind :: CgStgBinding -> FCode ()
emitBlackHoleCode :: CmmExpr -> FCode ()
pushUpdateFrame :: CLabel -> CmmExpr -> FCode () -> FCode ()
emitUpdateFrame :: CmmExpr -> CLabel -> CmmExpr -> FCode ()

module GHC.StgToCmm.Expr
cgExpr :: CgStgExpr -> FCode ReturnKind

module GHC.StgToCmm
codeGen :: Logger -> TmpFs -> DynFlags -> Module -> InfoTableProvMap -> [TyCon] -> CollectedCCs -> [CgStgTopBinding] -> HpcInfo -> Stream IO CmmGroup (CStub, ModuleLFInfos)

module GHC.Cmm.Parser
parseCmmFile :: DynFlags -> Module -> HomeUnit -> FilePath -> IO (Bag PsWarning, Bag PsError, Maybe (CmmGroup, [InfoProvEnt]))

module GHC.Cmm.LayoutStack
cmmLayoutStack :: DynFlags -> ProcPointSet -> ByteOff -> CmmGraph -> UniqSM (CmmGraph, LabelMap StackMap)
setInfoTableStackMap :: Platform -> LabelMap StackMap -> CmmDecl -> CmmDecl
instance GHC.Utils.Outputable.Outputable GHC.Cmm.LayoutStack.StackSlot
instance GHC.Utils.Outputable.Outputable GHC.Cmm.LayoutStack.StackMap


-- | Generate infotables for interpreter-made bytecodes
module GHC.ByteCode.InfoTable
mkITbls :: Interp -> Profile -> [TyCon] -> IO ItblEnv


-- | Bytecode assembler and linker
module GHC.ByteCode.Asm
assembleBCOs :: Interp -> Profile -> [ProtoBCO Name] -> [TyCon] -> [RemotePtr ()] -> Maybe ModBreaks -> IO CompiledByteCode
assembleOneBCO :: Interp -> Profile -> ProtoBCO Name -> IO UnlinkedBCO

-- | Finds external references. Remember to remove the names defined by
--   this group of BCOs themselves
bcoFreeNames :: UnlinkedBCO -> UniqDSet Name
data SizedSeq a
sizeSS :: SizedSeq a -> Word
ssElts :: SizedSeq a -> [a]
iNTERP_STACK_CHECK_THRESH :: Int
mkTupleInfoLit :: Platform -> TupleInfo -> Literal
instance GHC.Base.Functor GHC.ByteCode.Asm.Assembler
instance GHC.Base.Applicative GHC.ByteCode.Asm.Assembler
instance GHC.Base.Monad GHC.ByteCode.Asm.Assembler


-- | GHC.StgToByteCode: Generate bytecode from STG
module GHC.StgToByteCode
data UnlinkedBCO
byteCodeGen :: HscEnv -> Module -> [StgTopBinding] -> [TyCon] -> Maybe ModBreaks -> IO CompiledByteCode
instance GHC.Classes.Ord GHC.StgToByteCode.Discr
instance GHC.Classes.Eq GHC.StgToByteCode.Discr
instance GHC.Base.Functor GHC.StgToByteCode.BcM
instance GHC.Base.Applicative GHC.StgToByteCode.BcM
instance GHC.Base.Monad GHC.StgToByteCode.BcM
instance GHC.Driver.Session.HasDynFlags GHC.StgToByteCode.BcM
instance GHC.Utils.Outputable.Outputable GHC.StgToByteCode.Discr


-- | (c) The GRASP/AQUA Project, Glasgow University, 1993-1998
--   
--   A lint pass to check basic STG invariants:
--   
--   <ul>
--   <li>Variables should be defined before used.</li>
--   <li>Let bindings should not have unboxed types (unboxed bindings
--   should only appear in case), except when they're join points (see Note
--   [Core let/app invariant] and #14117).</li>
--   <li>If linting after unarisation, invariants listed in Note
--   [Post-unarisation invariants].</li>
--   </ul>
--   
--   Because we don't have types and coercions in STG we can't really check
--   types here.
--   
--   Some history:
--   
--   StgLint used to check types, but it never worked and so it was
--   disabled in 2000 with this note:
--   
--   WARNING: ~~~~~~~~
--   
--   This module has suffered bit-rot; it is likely to yield lint errors
--   for Stg code that is currently perfectly acceptable for code
--   generation. Solution: don't use it! (KSW 2000-05).
--   
--   Since then there were some attempts at enabling it again, as
--   summarised in #14787. It's finally decided that we remove all type
--   checking and only look for basic properties listed above.
module GHC.Stg.Lint
lintStgTopBindings :: forall a. (OutputablePass a, BinderP a ~ Id) => Logger -> DynFlags -> InteractiveContext -> Module -> Bool -> String -> [GenStgTopBinding a] -> IO ()
instance GHC.Base.Functor GHC.Stg.Lint.LintM
instance GHC.Base.Applicative GHC.Stg.Lint.LintM
instance GHC.Base.Monad GHC.Stg.Lint.LintM

module GHC.Stg.Pipeline
stg2stg :: Logger -> DynFlags -> InteractiveContext -> Module -> [StgTopBinding] -> IO [StgTopBinding]
instance Control.Monad.IO.Class.MonadIO GHC.Stg.Pipeline.StgM
instance GHC.Base.Monad GHC.Stg.Pipeline.StgM
instance GHC.Base.Applicative GHC.Stg.Pipeline.StgM
instance GHC.Base.Functor GHC.Stg.Pipeline.StgM
instance GHC.Classes.Eq GHC.Stg.Pipeline.StgToDo
instance GHC.Types.Unique.Supply.MonadUnique GHC.Stg.Pipeline.StgM

module GHC.Cmm.Pipeline

-- | Top level driver for C-- pipeline
cmmPipeline :: HscEnv -> ModuleSRTInfo -> CmmGroup -> IO (ModuleSRTInfo, CmmGroupSRTs)

module GHC.Core.Opt.Pipeline
core2core :: HscEnv -> ModGuts -> IO ModGuts
simplifyExpr :: HscEnv -> CoreExpr -> IO CoreExpr


-- | This is the syntax for bkp files which are parsed in 'ghc --backpack'
--   mode. This syntax is used purely for testing purposes.
module GHC.Driver.Backpack.Syntax
data HsUnitId n
HsUnitId :: Located n -> [LHsModuleSubst n] -> HsUnitId n
type LHsUnitId n = Located (HsUnitId n)
type HsModuleSubst n = (Located ModuleName, LHsModuleId n)
type LHsModuleSubst n = Located (HsModuleSubst n)
data HsModuleId n
HsModuleVar :: Located ModuleName -> HsModuleId n
HsModuleId :: LHsUnitId n -> Located ModuleName -> HsModuleId n
type LHsModuleId n = Located (HsModuleId n)
data HsComponentId
HsComponentId :: PackageName -> IndefUnitId -> HsComponentId
[hsPackageName] :: HsComponentId -> PackageName
[hsComponentId] :: HsComponentId -> IndefUnitId
type LHsUnit n = Located (HsUnit n)

-- | Top level <tt>unit</tt> declaration in a Backpack file.
data HsUnit n
HsUnit :: Located n -> [LHsUnitDecl n] -> HsUnit n
[hsunitName] :: HsUnit n -> Located n
[hsunitBody] :: HsUnit n -> [LHsUnitDecl n]
type LHsUnitDecl n = Located (HsUnitDecl n)

-- | A declaration in a package, e.g. a module or signature definition, or
--   an include.
data HsUnitDecl n
DeclD :: HscSource -> Located ModuleName -> Maybe (Located HsModule) -> HsUnitDecl n
IncludeD :: IncludeDecl n -> HsUnitDecl n

-- | An include of another unit
data IncludeDecl n
IncludeDecl :: LHsUnitId n -> Maybe [LRenaming] -> Bool -> IncludeDecl n
[idUnitId] :: IncludeDecl n -> LHsUnitId n
[idModRenaming] :: IncludeDecl n -> Maybe [LRenaming]

-- | Is this a <tt>dependency signature</tt> include? If so, we don't
--   compile this include when we instantiate this unit (as there should
--   not be any modules brought into scope.)
[idSignatureInclude] :: IncludeDecl n -> Bool
type LRenaming = Located Renaming

-- | Rename a module from one name to another. The identity renaming means
--   that the module should be brought into scope.
data Renaming
Renaming :: Located ModuleName -> Maybe (Located ModuleName) -> Renaming
[renameFrom] :: Renaming -> Located ModuleName
[renameTo] :: Renaming -> Maybe (Located ModuleName)
instance GHC.Utils.Outputable.Outputable GHC.Driver.Backpack.Syntax.HsComponentId


-- | This module provides the generated Happy parser for Haskell. It
--   exports a number of parsers which may be used in any library that uses
--   the GHC API. A common usage pattern is to initialize the parser state
--   with a given string and then parse that string:
--   
--   <pre>
--   runParser :: ParserOpts -&gt; String -&gt; P a -&gt; ParseResult a
--   runParser opts str parser = unP parser parseState
--   where
--     filename = "&lt;interactive&gt;"
--     location = mkRealSrcLoc (mkFastString filename) 1 1
--     buffer = stringToStringBuffer str
--     parseState = initParserState opts buffer location
--   </pre>
module GHC.Parser

-- | Parse a Haskell module with Haddock comments. This is done in two
--   steps:
--   
--   <ul>
--   <li><a>parseModuleNoHaddock</a> to build the AST</li>
--   <li><a>addHaddockToModule</a> to insert Haddock comments into it</li>
--   </ul>
--   
--   This is the only parser entry point that deals with Haddock comments.
--   The other entry points (<a>parseDeclaration</a>,
--   <a>parseExpression</a>, etc) do not insert them into the AST.
parseModule :: P (Located HsModule)
parseSignature :: P (Located HsModule)
parseImport :: P (GenLocated SrcSpanAnnA (ImportDecl GhcPs))
parseStatement :: P (GenLocated SrcSpanAnnA (StmtLR GhcPs GhcPs (GenLocated SrcSpanAnnA (HsExpr GhcPs))))
parseBackpack :: P [LHsUnit PackageName]
parseDeclaration :: P (GenLocated SrcSpanAnnA (HsDecl GhcPs))
parseExpression :: P ECP
parsePattern :: P (GenLocated SrcSpanAnnA (Pat GhcPs))
parseTypeSignature :: P (GenLocated SrcSpanAnnA (HsDecl GhcPs))
parseStmt :: P (Maybe (GenLocated SrcSpanAnnA (StmtLR GhcPs GhcPs (GenLocated SrcSpanAnnA (HsExpr GhcPs)))))
parseIdentifier :: P (LocatedN RdrName)
parseType :: P (GenLocated SrcSpanAnnA (HsType GhcPs))
parseHeader :: P (Located HsModule)
parseModuleNoHaddock :: P (Located HsModule)

module GHC.Parser.Utils

-- | Returns <tt>True</tt> if passed string is a statement.
isStmt :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string has an import declaration.
hasImport :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string is an import declaration.
isImport :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string is a declaration but <b><i>not
--   a splice</i></b>.
isDecl :: ParserOpts -> String -> Bool


-- | Parsing the top of a Haskell source file to get its module name,
--   imports and options.
--   
--   (c) Simon Marlow 2005 (c) Lemmih 2006
module GHC.Parser.Header

-- | Parse the imports of a source file.
--   
--   Throws a <a>SourceError</a> if parsing fails.
getImports :: ParserOpts -> Bool -> StringBuffer -> FilePath -> FilePath -> IO (Either (Bag PsError) ([(Maybe FastString, Located ModuleName)], [(Maybe FastString, Located ModuleName)], Located ModuleName))
mkPrelImports :: ModuleName -> SrcSpan -> Bool -> [LImportDecl GhcPs] -> [LImportDecl GhcPs]

-- | Parse OPTIONS and LANGUAGE pragmas of the source file.
--   
--   Throws a <a>SourceError</a> if flag parsing fails (including
--   unsupported flags.)
getOptionsFromFile :: DynFlags -> FilePath -> IO [Located String]

-- | Parse OPTIONS and LANGUAGE pragmas of the source file.
--   
--   Throws a <a>SourceError</a> if flag parsing fails (including
--   unsupported flags.)
getOptions :: DynFlags -> StringBuffer -> FilePath -> [Located String]
optionsErrorMsgs :: [String] -> [Located String] -> FilePath -> Messages DecoratedSDoc

-- | Complain about non-dynamic flags in OPTIONS pragmas.
--   
--   Throws a <a>SourceError</a> if the input list is non-empty claiming
--   that the input flags are unknown.
checkProcessArgsResult :: MonadIO m => [Located String] -> m ()


-- | Main API for compiling plain Haskell source code.
--   
--   This module implements compilation of a Haskell source. It is
--   <i>not</i> concerned with preprocessing of source files; this is
--   handled in <a>GHC.Driver.Pipeline</a>
--   
--   There are various entry points depending on what mode we're in:
--   "batch" mode (<tt>--make</tt>), "one-shot" mode (<tt>-c</tt>,
--   <tt>-S</tt> etc.), and "interactive" mode (GHCi). There are also entry
--   points for individual passes: parsing, typechecking/renaming,
--   desugaring, and simplification.
--   
--   All the functions here take an <a>HscEnv</a> as a parameter, but none
--   of them return a new one: <a>HscEnv</a> is treated as an immutable
--   value from here on in (although it has mutable components, for the
--   caches).
--   
--   We use the Hsc monad to deal with warning messages consistently:
--   specifically, while executing within an Hsc monad, warnings are
--   collected. When a Hsc monad returns to an IO monad, the warnings are
--   printed, or compilation aborts if the <tt>-Werror</tt> flag is
--   enabled.
--   
--   (c) The GRASP/AQUA Project, Glasgow University, 1993-2000
module GHC.Driver.Main
newHscEnv :: DynFlags -> IO HscEnv
type Messager = HscEnv -> (Int, Int) -> RecompileRequired -> ModuleGraphNode -> IO ()
batchMsg :: Messager

-- | Status of a module compilation to machine code
data HscStatus

-- | Nothing to do.
HscNotGeneratingCode :: ModIface -> ModDetails -> HscStatus

-- | Nothing to do because code already exists.
HscUpToDate :: ModIface -> ModDetails -> HscStatus

-- | Update boot file result.
HscUpdateBoot :: ModIface -> ModDetails -> HscStatus

-- | Generate signature file (backpack)
HscUpdateSig :: ModIface -> ModDetails -> HscStatus

-- | Recompile this module.
HscRecomp :: CgGuts -> !ModLocation -> !PartialModIface -> !Maybe Fingerprint -> HscStatus

-- | Information for the code generator.
[hscs_guts] :: HscStatus -> CgGuts

-- | Module info
[hscs_mod_location] :: HscStatus -> !ModLocation

-- | Partial interface
[hscs_partial_iface] :: HscStatus -> !PartialModIface

-- | Old interface hash for this compilation, if an old interface file
--   exists. Pass to <tt>hscMaybeWriteIface</tt> when writing the interface
--   to avoid updating the existing interface when the interface isn't
--   changed.
[hscs_old_iface_hash] :: HscStatus -> !Maybe Fingerprint

-- | Used by both OneShot and batch mode. Runs the pipeline HsSyn and Core
--   parts of the pipeline. We return a interface if we already had an old
--   one around and recompilation was not needed. Otherwise it will be
--   created during later passes when we run the compilation pipeline.
hscIncrementalCompile :: Bool -> Maybe TcGblEnv -> Maybe Messager -> HscEnv -> ModSummary -> SourceModified -> Maybe ModIface -> (Int, Int) -> IO (HscStatus, HscEnv)
initModDetails :: HscEnv -> ModSummary -> ModIface -> IO ModDetails

-- | Write interface files
hscMaybeWriteIface :: Logger -> DynFlags -> Bool -> ModIface -> Maybe Fingerprint -> ModLocation -> IO ()
hscCompileCmmFile :: HscEnv -> FilePath -> FilePath -> IO (Maybe FilePath)

-- | Compile to hard-code.
hscGenHardCode :: HscEnv -> CgGuts -> ModLocation -> FilePath -> IO (FilePath, Maybe FilePath, [(ForeignSrcLang, FilePath)], CgInfos)
hscInteractive :: HscEnv -> CgGuts -> ModLocation -> IO (Maybe FilePath, CompiledByteCode, [SptEntry])

-- | parse a file, returning the abstract syntax
hscParse :: HscEnv -> ModSummary -> IO HsParsedModule

-- | Rename and typecheck a module, additionally returning the renamed
--   syntax
hscTypecheckRename :: HscEnv -> ModSummary -> HsParsedModule -> IO (TcGblEnv, RenamedStuff)

-- | Convert a typechecked module to Core
hscDesugar :: HscEnv -> ModSummary -> TcGblEnv -> IO ModGuts

-- | Make a <a>ModDetails</a> from the results of typechecking. Used when
--   typechecking only, as opposed to full compilation.
makeSimpleDetails :: HscEnv -> TcGblEnv -> IO ModDetails

-- | Run Core2Core simplifier. The list of String is a list of (Core)
--   plugin module names added via TH (cf <tt>addCorePlugin</tt>).
hscSimplify :: HscEnv -> [String] -> ModGuts -> IO ModGuts

-- | Check that a module is safe to import.
--   
--   We return True to indicate the import is safe and False otherwise
--   although in the False case an exception may be thrown first.
hscCheckSafe :: HscEnv -> Module -> SrcSpan -> IO Bool

-- | Return if a module is trusted and the pkgs it depends on to be
--   trusted.
hscGetSafe :: HscEnv -> Module -> SrcSpan -> IO (Bool, Set UnitId)
hscParseIdentifier :: HscEnv -> String -> IO (LocatedN RdrName)
hscTcRcLookupName :: HscEnv -> Name -> IO (Maybe TyThing)
hscTcRnGetInfo :: HscEnv -> Name -> IO (Maybe (TyThing, Fixity, [ClsInst], [FamInst], SDoc))
hscIsGHCiMonad :: HscEnv -> String -> IO Name
hscGetModuleInterface :: HscEnv -> Module -> IO ModIface

-- | Rename some import declarations
hscRnImportDecls :: HscEnv -> [LImportDecl GhcPs] -> IO GlobalRdrEnv

-- | Lookup things in the compiler's environment
hscTcRnLookupRdrName :: HscEnv -> LocatedN RdrName -> IO [Name]

-- | Compile a stmt all the way to an HValue, but don't run it
--   
--   We return Nothing to indicate an empty statement (or comment only),
--   not a parse error.
hscStmt :: HscEnv -> String -> IO (Maybe ([Id], ForeignHValue, FixityEnv))
hscParseStmtWithLocation :: String -> Int -> String -> Hsc (Maybe (GhciLStmt GhcPs))

-- | Compile a stmt all the way to an HValue, but don't run it
--   
--   We return Nothing to indicate an empty statement (or comment only),
--   not a parse error.
hscStmtWithLocation :: HscEnv -> String -> String -> Int -> IO (Maybe ([Id], ForeignHValue, FixityEnv))
hscParsedStmt :: HscEnv -> GhciLStmt GhcPs -> IO (Maybe ([Id], ForeignHValue, FixityEnv))

-- | Compile a decls
hscDecls :: HscEnv -> String -> IO ([TyThing], InteractiveContext)
hscParseDeclsWithLocation :: HscEnv -> String -> Int -> String -> IO [LHsDecl GhcPs]

-- | Compile a decls
hscDeclsWithLocation :: HscEnv -> String -> String -> Int -> IO ([TyThing], InteractiveContext)
hscParsedDecls :: HscEnv -> [LHsDecl GhcPs] -> IO ([TyThing], InteractiveContext)

-- | Typecheck an expression (but don't run it)
hscTcExpr :: HscEnv -> TcRnExprMode -> String -> IO Type

-- | How should we infer a type? See Note [TcRnExprMode]
data TcRnExprMode

-- | Instantiate inferred quantifiers only (:type)
TM_Inst :: TcRnExprMode

-- | Instantiate all quantifiers, and do eager defaulting (:type +d)
TM_Default :: TcRnExprMode
hscImport :: HscEnv -> String -> IO (ImportDecl GhcPs)

-- | Find the kind of a type, after generalisation
hscKcType :: HscEnv -> Bool -> String -> IO (Type, Kind)
hscParseExpr :: String -> Hsc (LHsExpr GhcPs)
hscParseType :: String -> Hsc (LHsType GhcPs)
hscCompileCoreExpr :: HscEnv -> SrcSpan -> CoreExpr -> IO ForeignHValue
hscCompileCoreExpr' :: HscEnv -> SrcSpan -> CoreExpr -> IO ForeignHValue
hscParse' :: ModSummary -> Hsc HsParsedModule

-- | Run Core2Core simplifier. The list of String is a list of (Core)
--   plugin module names added via TH (cf <tt>addCorePlugin</tt>).
hscSimplify' :: [String] -> ModGuts -> Hsc ModGuts
hscDesugar' :: ModLocation -> TcGblEnv -> Hsc ModGuts
tcRnModule' :: ModSummary -> Bool -> HsParsedModule -> Hsc TcGblEnv
doCodeGen :: HscEnv -> Module -> InfoTableProvMap -> [TyCon] -> CollectedCCs -> [StgTopBinding] -> HpcInfo -> IO (Stream IO CmmGroupSRTs CgInfos)
getHscEnv :: Hsc HscEnv
hscSimpleIface' :: TcGblEnv -> Maybe Fingerprint -> Hsc (ModIface, Maybe Fingerprint, ModDetails)
oneShotMsg :: HscEnv -> RecompileRequired -> IO ()
dumpIfaceStats :: HscEnv -> IO ()

-- | Deal with errors and warnings returned by a compilation step
--   
--   In order to reduce dependencies to other parts of the compiler,
--   functions outside the "main" parts of GHC return warnings and errors
--   as a parameter and signal success via by wrapping the result in a
--   <a>Maybe</a> type. This function logs the returned warnings and
--   propagates errors as exceptions (of type <a>SourceError</a>).
--   
--   This function assumes the following invariants:
--   
--   <ol>
--   <li>If the second result indicates success (is of the form 'Just x'),
--   there must be no error messages in the first result.</li>
--   <li>If there are no error messages, but the second result indicates
--   failure there should be warnings in the first result. That is, if the
--   action failed, it must have been due to the warnings (i.e.,
--   <tt>-Werror</tt>).</li>
--   </ol>
ioMsgMaybe :: IO (Messages DecoratedSDoc, Maybe a) -> Hsc a
showModuleIndex :: (Int, Int) -> SDoc

-- | Load the given static-pointer table entries into the interpreter. See
--   Note [Grand plan for static forms] in
--   <a>GHC.Iface.Tidy.StaticPtrTable</a>.
hscAddSptEntries :: HscEnv -> [SptEntry] -> IO ()


-- | Specialisations of the <tt>HsSyn</tt> syntax for the typechecker
--   
--   This module is an extension of <tt>HsSyn</tt> syntax, for use in the
--   type checker.
module GHC.Tc.Utils.Zonk
hsLitType :: HsLit (GhcPass p) -> TcType
hsPatType :: Pat GhcTc -> Type
hsLPatType :: LPat GhcTc -> Type
mkHsDictLet :: TcEvBinds -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsApp :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsAppTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)

-- | A simple case alternative with a single pattern, no binds, no guards;
--   pre-typechecking
mkHsCaseAlt :: (Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpan, Anno (Match (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpanAnnA) => LPat (GhcPass p) -> LocatedA (body (GhcPass p)) -> LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
tcShortCutLit :: HsOverLit GhcRn -> ExpRhoType -> TcM (Maybe (HsOverLit GhcTc))
shortCutLit :: Platform -> OverLitVal -> TcType -> Maybe (HsExpr GhcTc)
hsOverLitName :: OverLitVal -> Name

-- | Returns the type of the whole pattern
conLikeResTy :: ConLike -> [Type] -> Type
type TcId = Id
type TcIdSet = IdSet
zonkTopDecls :: Bag EvBind -> LHsBinds GhcTc -> [LRuleDecl GhcTc] -> [LTcSpecPrag] -> [LForeignDecl GhcTc] -> TcM (TypeEnv, Bag EvBind, LHsBinds GhcTc, [LForeignDecl GhcTc], [LTcSpecPrag], [LRuleDecl GhcTc])
zonkTopExpr :: HsExpr GhcTc -> TcM (HsExpr GhcTc)
zonkTopLExpr :: LHsExpr GhcTc -> TcM (LHsExpr GhcTc)
zonkTopBndrs :: [TcId] -> TcM [Id]

-- | See Note [The ZonkEnv] Confused by zonking? See Note [What is
--   zonking?] in <a>GHC.Tc.Utils.TcMType</a>.
data ZonkEnv
data ZonkFlexi
DefaultFlexi :: ZonkFlexi
SkolemiseFlexi :: ZonkFlexi
RuntimeUnkFlexi :: ZonkFlexi
NoFlexi :: ZonkFlexi
emptyZonkEnv :: TcM ZonkEnv
mkEmptyZonkEnv :: ZonkFlexi -> TcM ZonkEnv
initZonkEnv :: (ZonkEnv -> TcM b) -> TcM b
zonkTyVarBindersX :: ZonkEnv -> [VarBndr TcTyVar vis] -> TcM (ZonkEnv, [VarBndr TyVar vis])
zonkTyVarBinderX :: ZonkEnv -> VarBndr TcTyVar vis -> TcM (ZonkEnv, VarBndr TyVar vis)
zonkTyBndrs :: [TcTyVar] -> TcM (ZonkEnv, [TyVar])
zonkTyBndrsX :: ZonkEnv -> [TcTyVar] -> TcM (ZonkEnv, [TyVar])
zonkTcTypeToType :: TcType -> TcM Type
zonkTcTypeToTypeX :: ZonkEnv -> TcType -> TcM Type
zonkTcTypesToTypesX :: ZonkEnv -> [TcType] -> TcM [Type]
zonkScaledTcTypesToTypesX :: ZonkEnv -> [Scaled TcType] -> TcM [Scaled Type]
zonkTyVarOcc :: ZonkEnv -> TyVar -> TcM TcType
zonkCoToCo :: ZonkEnv -> Coercion -> TcM Coercion
zonkEvBinds :: ZonkEnv -> Bag EvBind -> TcM (ZonkEnv, Bag EvBind)
zonkTcEvBinds :: ZonkEnv -> TcEvBinds -> TcM (ZonkEnv, TcEvBinds)
zonkTcMethInfoToMethInfoX :: ZonkEnv -> TcMethInfo -> TcM MethInfo
lookupTyVarOcc :: ZonkEnv -> TcTyVar -> Maybe TyVar
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.Zonk.ZonkEnv


-- | Monadic type operations
--   
--   This module contains monadic operations over types that contain
--   mutable type variables.
module GHC.Tc.Utils.TcMType

-- | Type variable that might be a metavariable
type TcTyVar = Var
type TcKind = Kind
type TcType = Type
type TcTauType = TcType
type TcThetaType = ThetaType
type TcTyVarSet = TyVarSet
newFlexiTyVar :: Kind -> TcM TcTyVar

-- | Create a new flexi ty var with a specific name
newNamedFlexiTyVar :: FastString -> Kind -> TcM TcTyVar
newFlexiTyVarTy :: Kind -> TcM TcType
newFlexiTyVarTys :: Int -> Kind -> TcM [TcType]
newOpenFlexiTyVar :: TcM TcTyVar

-- | Create a tyvar that can be a lifted or unlifted type. Returns alpha ::
--   TYPE kappa, where both alpha and kappa are fresh
newOpenFlexiTyVarTy :: TcM TcType
newOpenTypeKind :: TcM TcKind
newOpenBoxedTypeKind :: TcM TcKind
newMetaKindVar :: TcM TcKind
newMetaKindVars :: Int -> TcM [TcKind]
newMetaTyVarTyAtLevel :: TcLevel -> TcKind -> TcM TcType
newAnonMetaTyVar :: MetaInfo -> Kind -> TcM TcTyVar
cloneMetaTyVar :: TcTyVar -> TcM TcTyVar
newCycleBreakerTyVar :: TcKind -> TcM TcTyVar
newMultiplicityVar :: TcM TcType
readMetaTyVar :: TyVar -> TcM MetaDetails
writeMetaTyVar :: TcTyVar -> TcType -> TcM ()
writeMetaTyVarRef :: TcTyVar -> TcRef MetaDetails -> TcType -> TcM ()
newTauTvDetailsAtLevel :: TcLevel -> TcM TcTyVarDetails
newMetaDetails :: MetaInfo -> TcM TcTyVarDetails
newMetaTyVarName :: FastString -> TcM Name
isFilledMetaTyVar_maybe :: TcTyVar -> TcM (Maybe Type)
isFilledMetaTyVar :: TyVar -> TcM Bool
isUnfilledMetaTyVar :: TyVar -> TcM Bool
newEvVar :: TcPredType -> TcRnIf gbl lcl EvVar
newEvVars :: TcThetaType -> TcM [EvVar]
newDict :: Class -> [TcType] -> TcM DictId
newWanted :: CtOrigin -> Maybe TypeOrKind -> PredType -> TcM CtEvidence
newWanteds :: CtOrigin -> ThetaType -> TcM [CtEvidence]
cloneWanted :: Ct -> TcM Ct
cloneWC :: WantedConstraints -> TcM WantedConstraints

-- | Emits a new Wanted. Deals with both equalities and non-equalities.
emitWanted :: CtOrigin -> TcPredType -> TcM EvTerm

-- | Emits a new equality constraint
emitWantedEq :: CtOrigin -> TypeOrKind -> Role -> TcType -> TcType -> TcM Coercion

-- | Creates a new EvVar and immediately emits it as a Wanted. No equality
--   predicates here.
emitWantedEvVar :: CtOrigin -> TcPredType -> TcM EvVar
emitWantedEvVars :: CtOrigin -> [TcPredType] -> TcM [EvVar]
emitDerivedEqs :: CtOrigin -> [(TcType, TcType)] -> TcM ()
newTcEvBinds :: TcM EvBindsVar

-- | Creates an EvBindsVar incapable of holding any bindings. It still
--   tracks covar usages (see comments on ebv_tcvs in
--   <a>GHC.Tc.Types.Evidence</a>), thus must be made monadically
newNoTcEvBinds :: TcM EvBindsVar
addTcEvBind :: EvBindsVar -> EvBind -> TcM ()

-- | Emit a new wanted expression hole
emitNewExprHole :: OccName -> Type -> TcM HoleExprRef
newCoercionHole :: TcPredType -> TcM CoercionHole

-- | Put a value in a coercion hole
fillCoercionHole :: CoercionHole -> Coercion -> TcM ()

-- | Is a coercion hole filled in?
isFilledCoercionHole :: CoercionHole -> TcM Bool

-- | Retrieve the contents of a coercion hole. Panics if the hole is
--   unfilled
unpackCoercionHole :: CoercionHole -> TcM Coercion

-- | Retrieve the contents of a coercion hole, if it is filled
unpackCoercionHole_maybe :: CoercionHole -> TcM (Maybe Coercion)

-- | Check that a coercion is appropriate for filling a hole. (The hole
--   itself is needed only for printing.) Always returns the checked
--   coercion, but this return value is necessary so that the input
--   coercion is forced only when the output is forced.
checkCoercionHole :: CoVar -> Coercion -> TcM Coercion

-- | Create a new <a>Implication</a> with as many sensible defaults for its
--   fields as possible. Note that the <a>ic_tclvl</a>, <a>ic_binds</a>,
--   and <a>ic_info</a> fields do <i>not</i> have sensible defaults, so
--   they are initialized with lazy thunks that will <a>panic</a> if
--   forced, so one should take care to initialize these fields after
--   creation.
--   
--   This is monadic to look up the <a>TcLclEnv</a>, which is used to
--   initialize <a>ic_env</a>, and to set the -Winaccessible-code flag. See
--   Note [Avoid -Winaccessible-code when deriving] in
--   <a>GHC.Tc.TyCl.Instance</a>.
newImplication :: TcM Implication
newMetaTyVars :: [TyVar] -> TcM (TCvSubst, [TcTyVar])
newMetaTyVarX :: TCvSubst -> TyVar -> TcM (TCvSubst, TcTyVar)
newMetaTyVarsX :: TCvSubst -> [TyVar] -> TcM (TCvSubst, [TcTyVar])
newMetaTyVarTyVarX :: TCvSubst -> TyVar -> TcM (TCvSubst, TcTyVar)
newTyVarTyVar :: Name -> Kind -> TcM TcTyVar
cloneTyVarTyVar :: Name -> Kind -> TcM TcTyVar
newPatSigTyVar :: Name -> Kind -> TcM TcTyVar
newSkolemTyVar :: Name -> Kind -> TcM TcTyVar
newWildCardX :: TCvSubst -> TyVar -> TcM (TCvSubst, TcTyVar)

-- | An expected type to check against during type-checking. See Note
--   [ExpType] in <a>GHC.Tc.Utils.TcMType</a>, where you'll also find
--   manipulators.
data ExpType
Check :: TcType -> ExpType
Infer :: !InferResult -> ExpType
type ExpSigmaType = ExpType
type ExpRhoType = ExpType

-- | Make an <a>ExpType</a> suitable for checking.
mkCheckExpType :: TcType -> ExpType
newInferExpType :: TcM ExpType

-- | Infer a type using a fresh ExpType See also Note [ExpType] in
--   <a>GHC.Tc.Utils.TcMType</a>
tcInfer :: (ExpSigmaType -> TcM a) -> TcM (a, TcSigmaType)

-- | Extract a type out of an ExpType. Otherwise, panics.
readExpType :: ExpType -> TcM TcType

-- | Extract a type out of an ExpType, if one exists. But one should always
--   exist. Unless you're quite sure you know what you're doing.
readExpType_maybe :: ExpType -> TcM (Maybe TcType)

-- | Same as readExpType, but for Scaled ExpTypes
readScaledExpType :: Scaled ExpType -> TcM (Scaled Type)

-- | Extracts the expected type if there is one, or generates a new TauTv
--   if there isn't.
expTypeToType :: ExpType -> TcM TcType
scaledExpTypeToType :: Scaled ExpType -> TcM (Scaled TcType)

-- | Returns the expected type when in checking mode.
checkingExpType_maybe :: ExpType -> Maybe TcType

-- | Returns the expected type when in checking mode. Panics if in
--   inference mode.
checkingExpType :: String -> ExpType -> TcType
inferResultToType :: InferResult -> TcM Type
fillInferResult :: TcType -> InferResult -> TcM TcCoercionN
promoteTcType :: TcLevel -> TcType -> TcM (TcCoercionN, TcType)
zonkTidyTcType :: TidyEnv -> TcType -> TcM (TidyEnv, TcType)
zonkTidyTcTypes :: TidyEnv -> [TcType] -> TcM (TidyEnv, [TcType])
zonkTidyOrigin :: TidyEnv -> CtOrigin -> TcM (TidyEnv, CtOrigin)
tidyEvVar :: TidyEnv -> EvVar -> EvVar
tidyCt :: TidyEnv -> Ct -> Ct
tidyHole :: TidyEnv -> Hole -> Hole
tidySkolemInfo :: TidyEnv -> SkolemInfo -> SkolemInfo
zonkTcTyVar :: TcTyVar -> TcM TcType
zonkTcTyVars :: [TcTyVar] -> TcM [TcType]
zonkTcTyVarToTyVar :: HasDebugCallStack => TcTyVar -> TcM TcTyVar
zonkInvisTVBinder :: VarBndr TcTyVar spec -> TcM (VarBndr TyVar spec)
zonkTyCoVarsAndFV :: TyCoVarSet -> TcM TyCoVarSet
zonkTcTypeAndFV :: TcType -> TcM DTyCoVarSet
zonkDTyCoVarSetAndFV :: DTyCoVarSet -> TcM DTyCoVarSet
zonkTyCoVarsAndFVList :: [TyCoVar] -> TcM [TyCoVar]
zonkTcType :: TcType -> TcM TcType
zonkTcTypes :: [TcType] -> TcM [TcType]
zonkCo :: Coercion -> TcM Coercion
zonkTyCoVarKind :: TyCoVar -> TcM TyCoVar
zonkTyCoVarKindBinder :: VarBndr TyCoVar fl -> TcM (VarBndr TyCoVar fl)
zonkEvVar :: EvVar -> TcM EvVar
zonkWC :: WantedConstraints -> TcM WantedConstraints
zonkImplication :: Implication -> TcM Implication
zonkSimples :: Cts -> TcM Cts
zonkId :: TcId -> TcM TcId
zonkCoVar :: CoVar -> TcM CoVar
zonkCt :: Ct -> TcM Ct
zonkSkolemInfo :: SkolemInfo -> TcM SkolemInfo
defaultTyVar :: Bool -> TcTyVar -> TcM Bool
promoteMetaTyVarTo :: TcLevel -> TcTyVar -> TcM Bool
promoteTyVarSet :: TcTyVarSet -> TcM Bool
quantifyTyVars :: CandidatesQTvs -> TcM [TcTyVar]
isQuantifiableTv :: TcLevel -> TcTyVar -> Bool
skolemiseUnboundMetaTyVar :: TcTyVar -> TcM TyVar
zonkAndSkolemise :: TcTyCoVar -> TcM TcTyCoVar
skolemiseQuantifiedTyVar :: TcTyVar -> TcM TcTyVar
doNotQuantifyTyVars :: CandidatesQTvs -> (TidyEnv -> TcM (TidyEnv, SDoc)) -> TcM ()

-- | Gathers free variables to use as quantification candidates (in
--   <a>quantifyTyVars</a>). This might output the same var in both sets,
--   if it's used in both a type and a kind. The variables to quantify must
--   have a TcLevel strictly greater than the ambient level. (See Wrinkle
--   in Note [Naughty quantification candidates]) See Note [CandidatesQTvs
--   determinism and order] See Note [Dependent type variables]
candidateQTyVarsOfType :: TcType -> TcM CandidatesQTvs

-- | Like <a>candidateQTyVarsOfType</a>, but consider every free variable
--   to be dependent. This is appropriate when generalizing a *kind*,
--   instead of a type. (That way, -XNoPolyKinds will default the variables
--   to Type.)
candidateQTyVarsOfKind :: TcKind -> TcM CandidatesQTvs

-- | Like <a>candidateQTyVarsOfType</a>, but over a list of types The
--   variables to quantify must have a TcLevel strictly greater than the
--   ambient level. (See Wrinkle in Note [Naughty quantification
--   candidates])
candidateQTyVarsOfTypes :: [Type] -> TcM CandidatesQTvs
candidateQTyVarsOfKinds :: [TcKind] -> TcM CandidatesQTvs
data CandidatesQTvs
DV :: DTyVarSet -> DTyVarSet -> CoVarSet -> CandidatesQTvs
[dv_kvs] :: CandidatesQTvs -> DTyVarSet
[dv_tvs] :: CandidatesQTvs -> DTyVarSet
[dv_cvs] :: CandidatesQTvs -> CoVarSet
delCandidates :: CandidatesQTvs -> [Var] -> CandidatesQTvs
candidateKindVars :: CandidatesQTvs -> TyVarSet
partitionCandidates :: CandidatesQTvs -> (TyVar -> Bool) -> (TyVarSet, CandidatesQTvs)

-- | According to the rules around representation polymorphism (see
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/no-sub-kinds)</a>, no
--   binder can have a representation-polymorphic type. This check ensures
--   that we respect this rule. It is a bit regrettable that this error
--   occurs in zonking, after which we should have reported all errors. But
--   it's hard to see where else to do it, because this can be discovered
--   only after all solving is done. And, perhaps most importantly, this
--   isn't really a compositional property of a type system, so it's not a
--   terrible surprise that the check has to go in an awkward spot.
ensureNotLevPoly :: Type -> SDoc -> TcM ()
checkForLevPoly :: SDoc -> Type -> TcM ()
checkForLevPolyX :: Monad m => (SDoc -> m ()) -> SDoc -> Type -> m ()
formatLevPolyErr :: Type -> SDoc
instance GHC.Base.Semigroup GHC.Tc.Utils.TcMType.CandidatesQTvs
instance GHC.Base.Monoid GHC.Tc.Utils.TcMType.CandidatesQTvs
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcMType.CandidatesQTvs


-- | Type subsumption and unification
module GHC.Tc.Utils.Unify
tcWrapResult :: HsExpr GhcRn -> HsExpr GhcTc -> TcSigmaType -> ExpRhoType -> TcM (HsExpr GhcTc)
tcWrapResultO :: CtOrigin -> HsExpr GhcRn -> HsExpr GhcTc -> TcSigmaType -> ExpRhoType -> TcM (HsExpr GhcTc)
tcWrapResultMono :: HsExpr GhcRn -> HsExpr GhcTc -> TcRhoType -> ExpRhoType -> TcM (HsExpr GhcTc)
tcTopSkolemise :: UserTypeCtxt -> TcSigmaType -> (TcType -> TcM result) -> TcM (HsWrapper, result)
tcSkolemiseScoped :: UserTypeCtxt -> TcSigmaType -> (TcType -> TcM result) -> TcM (HsWrapper, result)

-- | Variant of <a>tcTopSkolemise</a> that takes an ExpType
tcSkolemiseExpType :: UserTypeCtxt -> ExpSigmaType -> (ExpRhoType -> TcM result) -> TcM (HsWrapper, result)
tcSubType :: CtOrigin -> UserTypeCtxt -> TcSigmaType -> ExpRhoType -> TcM HsWrapper
tcSubTypeSigma :: CtOrigin -> UserTypeCtxt -> TcSigmaType -> TcSigmaType -> TcM HsWrapper
tcSubTypePat :: CtOrigin -> UserTypeCtxt -> ExpSigmaType -> TcSigmaType -> TcM HsWrapper
tcSubTypeDS :: HsExpr GhcRn -> TcRhoType -> ExpRhoType -> TcM HsWrapper
tcSubTypeAmbiguity :: UserTypeCtxt -> TcSigmaType -> TcSigmaType -> TcM HsWrapper
tcSubMult :: CtOrigin -> Mult -> Mult -> TcM HsWrapper
checkConstraints :: SkolemInfo -> [TcTyVar] -> [EvVar] -> TcM result -> TcM (TcEvBinds, result)
checkTvConstraints :: SkolemInfo -> [TcTyVar] -> TcM result -> TcM result
buildImplicationFor :: TcLevel -> SkolemInfo -> [TcTyVar] -> [EvVar] -> WantedConstraints -> TcM (Bag Implication, TcEvBinds)
buildTvImplication :: SkolemInfo -> [TcTyVar] -> TcLevel -> WantedConstraints -> TcM Implication
emitResidualTvConstraint :: SkolemInfo -> [TcTyVar] -> TcLevel -> WantedConstraints -> TcM ()
unifyType :: Maybe SDoc -> TcTauType -> TcTauType -> TcM TcCoercionN
unifyKind :: Maybe SDoc -> TcKind -> TcKind -> TcM CoercionN
unifyExpectedType :: HsExpr GhcRn -> TcRhoType -> ExpRhoType -> TcM TcCoercionN
uType :: TypeOrKind -> CtOrigin -> TcType -> TcType -> TcM CoercionN
promoteTcType :: TcLevel -> TcType -> TcM (TcCoercionN, TcType)
swapOverTyVars :: Bool -> TcTyVar -> TcTyVar -> Bool
canSolveByUnification :: MetaInfo -> TcType -> Bool

-- | Infer a type using a fresh ExpType See also Note [ExpType] in
--   <a>GHC.Tc.Utils.TcMType</a>
tcInfer :: (ExpSigmaType -> TcM a) -> TcM (a, TcSigmaType)
matchExpectedListTy :: TcRhoType -> TcM (TcCoercionN, TcRhoType)
matchExpectedTyConApp :: TyCon -> TcRhoType -> TcM (TcCoercionN, [TcSigmaType])
matchExpectedAppTy :: TcRhoType -> TcM (TcCoercion, (TcSigmaType, TcSigmaType))
matchExpectedFunTys :: forall a. SDoc -> UserTypeCtxt -> Arity -> ExpRhoType -> ([Scaled ExpSigmaType] -> ExpRhoType -> TcM a) -> TcM (HsWrapper, a)

-- | Breaks apart a function kind into its pieces.
matchExpectedFunKind :: Outputable fun => fun -> Arity -> TcKind -> TcM Coercion

-- | matchActualFunTySigma does looks for just one function arrow returning
--   an uninstantiated sigma-type
matchActualFunTySigma :: SDoc -> Maybe SDoc -> (Arity, [Scaled TcSigmaType]) -> TcRhoType -> TcM (HsWrapper, Scaled TcSigmaType, TcSigmaType)
matchActualFunTysRho :: SDoc -> CtOrigin -> Maybe SDoc -> Arity -> TcSigmaType -> TcM (HsWrapper, [Scaled TcSigmaType], TcRhoType)
checkTyVarEq :: DynFlags -> TcTyVar -> TcType -> CheckTyEqResult
checkTyFamEq :: DynFlags -> TyCon -> [TcType] -> TcType -> CheckTyEqResult
checkTypeEq :: DynFlags -> CanEqLHS -> TcType -> CheckTyEqResult


-- | Functions for working with the typechecker environment (setters,
--   getters...).
module GHC.Tc.Utils.Monad

-- | Setup the initial typechecking environment
initTc :: HscEnv -> HscSource -> Bool -> Module -> RealSrcSpan -> TcM r -> IO (Messages DecoratedSDoc, Maybe r)

-- | Run a <a>TcM</a> action in the context of an existing <tt>GblEnv</tt>.
initTcWithGbl :: HscEnv -> TcGblEnv -> RealSrcSpan -> TcM r -> IO (Messages DecoratedSDoc, Maybe r)
initTcInteractive :: HscEnv -> TcM a -> IO (Messages DecoratedSDoc, Maybe a)
initTcRnIf :: Char -> HscEnv -> gbl -> lcl -> TcRnIf gbl lcl a -> IO a
discardResult :: TcM a -> TcM ()
getTopEnv :: TcRnIf gbl lcl HscEnv
updTopEnv :: (HscEnv -> HscEnv) -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
getGblEnv :: TcRnIf gbl lcl gbl
updGblEnv :: (gbl -> gbl) -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
setGblEnv :: gbl -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
getLclEnv :: TcRnIf gbl lcl lcl
updLclEnv :: (lcl -> lcl) -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
setLclEnv :: lcl' -> TcRnIf gbl lcl' a -> TcRnIf gbl lcl a
getEnvs :: TcRnIf gbl lcl (gbl, lcl)
setEnvs :: (gbl', lcl') -> TcRnIf gbl' lcl' a -> TcRnIf gbl lcl a
xoptM :: Extension -> TcRnIf gbl lcl Bool
doptM :: DumpFlag -> TcRnIf gbl lcl Bool
goptM :: GeneralFlag -> TcRnIf gbl lcl Bool
woptM :: WarningFlag -> TcRnIf gbl lcl Bool
setXOptM :: Extension -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
unsetXOptM :: Extension -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
unsetGOptM :: GeneralFlag -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
unsetWOptM :: WarningFlag -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a

-- | Do it flag is true
whenDOptM :: DumpFlag -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
whenGOptM :: GeneralFlag -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
whenWOptM :: WarningFlag -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
whenXOptM :: Extension -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
unlessXOptM :: Extension -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
getGhcMode :: TcRnIf gbl lcl GhcMode
withDynamicNow :: TcRnIf gbl lcl a -> TcRnIf gbl lcl a
withoutDynamicNow :: TcRnIf gbl lcl a -> TcRnIf gbl lcl a
getEpsVar :: TcRnIf gbl lcl (TcRef ExternalPackageState)
getEps :: TcRnIf gbl lcl ExternalPackageState

-- | Update the external package state. Returns the second result of the
--   modifier function.
--   
--   This is an atomic operation and forces evaluation of the modified EPS
--   in order to avoid space leaks.
updateEps :: (ExternalPackageState -> (ExternalPackageState, a)) -> TcRnIf gbl lcl a

-- | Update the external package state.
--   
--   This is an atomic operation and forces evaluation of the modified EPS
--   in order to avoid space leaks.
updateEps_ :: (ExternalPackageState -> ExternalPackageState) -> TcRnIf gbl lcl ()
getHpt :: TcRnIf gbl lcl HomePackageTable
getEpsAndHpt :: TcRnIf gbl lcl (ExternalPackageState, HomePackageTable)
newArrowScope :: TcM a -> TcM a
escapeArrowScope :: TcM a -> TcM a
newUnique :: TcRnIf gbl lcl Unique
newUniqueSupply :: TcRnIf gbl lcl UniqSupply
newName :: OccName -> TcM Name
newNameAt :: OccName -> SrcSpan -> TcM Name
cloneLocalName :: Name -> TcM Name
newSysName :: OccName -> TcRnIf gbl lcl Name
newSysLocalId :: FastString -> Mult -> TcType -> TcRnIf gbl lcl TcId
newSysLocalIds :: FastString -> [Scaled TcType] -> TcRnIf gbl lcl [TcId]
newTcRef :: a -> TcRnIf gbl lcl (TcRef a)
readTcRef :: TcRef a -> TcRnIf gbl lcl a
writeTcRef :: TcRef a -> a -> TcRnIf gbl lcl ()
updTcRef :: TcRef a -> (a -> a) -> TcRnIf gbl lcl ()
traceTc :: String -> SDoc -> TcRn ()
traceRn :: String -> SDoc -> TcRn ()
traceOptTcRn :: DumpFlag -> SDoc -> TcRn ()

-- | Dump if the given <a>DumpFlag</a> is set.
dumpOptTcRn :: DumpFlag -> String -> DumpFormat -> SDoc -> TcRn ()

-- | Unconditionally dump some trace output
--   
--   Certain tests (T3017, Roles3, T12763 etc.) expect part of the output
--   generated by `-ddump-types` to be in <a>PprUser</a> style. However,
--   generally we want all other debugging output to use <a>PprDump</a>
--   style. We <a>PprUser</a> style if <tt>useUserStyle</tt> is True.
dumpTcRn :: Bool -> DumpFlag -> String -> DumpFormat -> SDoc -> TcRn ()
getPrintUnqualified :: TcRn PrintUnqualified

-- | Like logInfoTcRn, but for user consumption
printForUserTcRn :: SDoc -> TcRn ()
traceIf :: SDoc -> TcRnIf m n ()
traceHiDiffs :: SDoc -> TcRnIf m n ()
traceOptIf :: DumpFlag -> SDoc -> TcRnIf m n ()
debugTc :: TcM () -> TcM ()
getIsGHCi :: TcRn Bool
getGHCiMonad :: TcRn Name
getInteractivePrintName :: TcRn Name
tcIsHsBootOrSig :: TcRn Bool
tcIsHsig :: TcRn Bool
tcSelfBootInfo :: TcRn SelfBootInfo
getGlobalRdrEnv :: TcRn GlobalRdrEnv
getRdrEnvs :: TcRn (GlobalRdrEnv, LocalRdrEnv)
getImports :: TcRn ImportAvails
getFixityEnv :: TcRn FixityEnv
extendFixityEnv :: [(Name, FixItem)] -> RnM a -> RnM a
getRecFieldEnv :: TcRn RecFieldEnv
getDeclaredDefaultTys :: TcRn (Maybe [Type])
addDependentFiles :: [FilePath] -> TcRn ()
getSrcSpanM :: TcRn SrcSpan
setSrcSpan :: SrcSpan -> TcRn a -> TcRn a
setSrcSpanA :: SrcSpanAnn' ann -> TcRn a -> TcRn a
addLocM :: (a -> TcM b) -> Located a -> TcM b
addLocMA :: (a -> TcM b) -> GenLocated (SrcSpanAnn' ann) a -> TcM b
inGeneratedCode :: TcRn Bool
wrapLocM :: (a -> TcM b) -> Located a -> TcM (Located b)
wrapLocAM :: (a -> TcM b) -> LocatedAn an a -> TcM (Located b)
wrapLocFstM :: (a -> TcM (b, c)) -> Located a -> TcM (Located b, c)
wrapLocFstMA :: (a -> TcM (b, c)) -> LocatedA a -> TcM (LocatedA b, c)
wrapLocSndM :: (a -> TcM (b, c)) -> Located a -> TcM (b, Located c)
wrapLocSndMA :: (a -> TcM (b, c)) -> LocatedA a -> TcM (b, LocatedA c)
wrapLocM_ :: (a -> TcM ()) -> Located a -> TcM ()
wrapLocMA_ :: (a -> TcM ()) -> LocatedA a -> TcM ()
wrapLocMA :: (a -> TcM b) -> GenLocated (SrcSpanAnn' ann) a -> TcRn (GenLocated (SrcSpanAnn' ann) b)
getErrsVar :: TcRn (TcRef (Messages DecoratedSDoc))
setErrsVar :: TcRef (Messages DecoratedSDoc) -> TcRn a -> TcRn a
addErr :: SDoc -> TcRn ()
failWith :: SDoc -> TcRn a
failAt :: SrcSpan -> SDoc -> TcRn a
addErrAt :: SrcSpan -> SDoc -> TcRn ()
addErrs :: [(SrcSpan, SDoc)] -> TcRn ()
checkErr :: Bool -> SDoc -> TcRn ()
addMessages :: Messages DecoratedSDoc -> TcRn ()
discardWarnings :: TcRn a -> TcRn a

-- | <tt>tcCollectingUsage thing_inside</tt> runs <tt>thing_inside</tt> and
--   returns the usage information which was collected as part of the
--   execution of <tt>thing_inside</tt>. Careful: <tt>tcCollectingUsage
--   thing_inside</tt> itself does not report any usage information, it's
--   up to the caller to incorporate the returned usage information into
--   the larger context appropriately.
tcCollectingUsage :: TcM a -> TcM (UsageEnv, a)

-- | <tt>tcScalingUsage mult thing_inside</tt> runs <tt>thing_inside</tt>
--   and scales all the usage information by <tt>mult</tt>.
tcScalingUsage :: Mult -> TcM a -> TcM a
tcEmitBindingUsage :: UsageEnv -> TcM ()
mkLongErrAt :: SrcSpan -> SDoc -> SDoc -> TcRn (MsgEnvelope DecoratedSDoc)
mkDecoratedSDocAt :: SrcSpan -> SDoc -> SDoc -> SDoc -> TcRn (MsgEnvelope DecoratedSDoc)
addLongErrAt :: SrcSpan -> SDoc -> SDoc -> TcRn ()
reportErrors :: [MsgEnvelope DecoratedSDoc] -> TcM ()
reportError :: MsgEnvelope DecoratedSDoc -> TcRn ()
reportWarning :: WarnReason -> MsgEnvelope DecoratedSDoc -> TcRn ()
recoverM :: TcRn r -> TcRn r -> TcRn r

-- | Drop elements of the input that fail, so the result list can be
--   shorter than the argument list
mapAndRecoverM :: (a -> TcRn b) -> [a] -> TcRn [b]

-- | Apply the function to all elements on the input list If all succeed,
--   return the list of results Otherwise fail, propagating all errors
mapAndReportM :: (a -> TcRn b) -> [a] -> TcRn [b]

-- | The accumulator is not updated if the action fails
foldAndRecoverM :: (b -> a -> TcRn b) -> b -> [a] -> TcRn b
attemptM :: TcRn r -> TcRn (Maybe r)
tryTc :: TcRn a -> TcRn (Maybe a, Messages DecoratedSDoc)
askNoErrs :: TcRn a -> TcRn (a, Bool)
discardErrs :: TcRn a -> TcRn a
tryTcDiscardingErrs :: TcM r -> TcM r -> TcM r
checkNoErrs :: TcM r -> TcM r
whenNoErrs :: TcM () -> TcM ()
ifErrsM :: TcRn r -> TcRn r -> TcRn r
failIfErrsM :: TcRn ()
getErrCtxt :: TcM [ErrCtxt]
setErrCtxt :: [ErrCtxt] -> TcM a -> TcM a

-- | Add a fixed message to the error context. This message should not do
--   any tidying.
addErrCtxt :: SDoc -> TcM a -> TcM a

-- | Add a message to the error context. This message may do tidying.
addErrCtxtM :: (TidyEnv -> TcM (TidyEnv, SDoc)) -> TcM a -> TcM a

-- | Add a fixed landmark message to the error context. A landmark message
--   is always sure to be reported, even if there is a lot of context. It
--   also doesn't count toward the maximum number of contexts reported.
addLandmarkErrCtxt :: SDoc -> TcM a -> TcM a

-- | Variant of <a>addLandmarkErrCtxt</a> that allows for monadic
--   operations and tidying.
addLandmarkErrCtxtM :: (TidyEnv -> TcM (TidyEnv, SDoc)) -> TcM a -> TcM a
popErrCtxt :: TcM a -> TcM a
getCtLocM :: CtOrigin -> Maybe TypeOrKind -> TcM CtLoc
setCtLocM :: CtLoc -> TcM a -> TcM a
addErrTc :: SDoc -> TcM ()
addErrTcM :: (TidyEnv, SDoc) -> TcM ()
failWithTc :: SDoc -> TcM a
failWithTcM :: (TidyEnv, SDoc) -> TcM a
checkTc :: Bool -> SDoc -> TcM ()
checkTcM :: Bool -> (TidyEnv, SDoc) -> TcM ()
failIfTc :: Bool -> SDoc -> TcM ()
failIfTcM :: Bool -> (TidyEnv, SDoc) -> TcM ()

-- | Display a warning if a condition is met, and the warning is enabled
warnIfFlag :: WarningFlag -> Bool -> SDoc -> TcRn ()

-- | Display a warning if a condition is met.
warnIf :: Bool -> SDoc -> TcRn ()

-- | Display a warning if a condition is met.
warnTc :: WarnReason -> Bool -> SDoc -> TcM ()

-- | Display a warning if a condition is met.
warnTcM :: WarnReason -> Bool -> (TidyEnv, SDoc) -> TcM ()

-- | Display a warning in the current context.
addWarnTc :: WarnReason -> SDoc -> TcM ()

-- | Display a warning in a given context.
addWarnTcM :: WarnReason -> (TidyEnv, SDoc) -> TcM ()

-- | Display a warning for the current source location.
addWarn :: WarnReason -> SDoc -> TcRn ()

-- | Display a warning for a given source location.
addWarnAt :: WarnReason -> SrcSpan -> SDoc -> TcRn ()

-- | Display a warning, with an optional flag, for the current source
--   location.
add_warn :: WarnReason -> SDoc -> SDoc -> TcRn ()
mkErrInfo :: TidyEnv -> [ErrCtxt] -> TcM SDoc
newTcEvBinds :: TcM EvBindsVar

-- | Creates an EvBindsVar incapable of holding any bindings. It still
--   tracks covar usages (see comments on ebv_tcvs in
--   <a>GHC.Tc.Types.Evidence</a>), thus must be made monadically
newNoTcEvBinds :: TcM EvBindsVar
cloneEvBindsVar :: EvBindsVar -> TcM EvBindsVar
addTcEvBind :: EvBindsVar -> EvBind -> TcM ()
addTopEvBinds :: Bag EvBind -> TcM a -> TcM a
getTcEvTyCoVars :: EvBindsVar -> TcM TyCoVarSet
getTcEvBindsMap :: EvBindsVar -> TcM EvBindMap
setTcEvBindsMap :: EvBindsVar -> EvBindMap -> TcM ()
chooseUniqueOccTc :: (OccSet -> OccName) -> TcM OccName
getConstraintVar :: TcM (TcRef WantedConstraints)
setConstraintVar :: TcRef WantedConstraints -> TcM a -> TcM a
emitConstraints :: WantedConstraints -> TcM ()
emitStaticConstraints :: WantedConstraints -> TcM ()
emitSimple :: Ct -> TcM ()
emitSimples :: Cts -> TcM ()
emitImplication :: Implication -> TcM ()
emitImplications :: Bag Implication -> TcM ()
emitInsoluble :: Ct -> TcM ()
emitHole :: Hole -> TcM ()
emitHoles :: Bag Hole -> TcM ()

-- | Throw out any constraints emitted by the thing_inside
discardConstraints :: TcM a -> TcM a
captureConstraints :: TcM a -> TcM (a, WantedConstraints)
tryCaptureConstraints :: TcM a -> TcM (Maybe a, WantedConstraints)

-- | The name says it all. The returned TcLevel is the *inner* TcLevel.
pushLevelAndCaptureConstraints :: TcM a -> TcM (TcLevel, WantedConstraints, a)
pushTcLevelM_ :: TcM a -> TcM a
pushTcLevelM :: TcM a -> TcM (TcLevel, a)
pushTcLevelsM :: Int -> TcM a -> TcM (a, TcLevel)
getTcLevel :: TcM TcLevel
setTcLevel :: TcLevel -> TcM a -> TcM a
isTouchableTcM :: TcTyVar -> TcM Bool
getLclTypeEnv :: TcM TcTypeEnv
setLclTypeEnv :: TcLclEnv -> TcM a -> TcM a
traceTcConstraints :: String -> TcM ()
emitNamedTypeHole :: (Name, TcTyVar) -> TcM ()
data IsExtraConstraint
YesExtraConstraint :: IsExtraConstraint
NoExtraConstraint :: IsExtraConstraint
emitAnonTypeHole :: IsExtraConstraint -> TcTyVar -> TcM ()
recordThUse :: TcM ()
recordThSpliceUse :: TcM ()
keepAlive :: Name -> TcRn ()
getStage :: TcM ThStage
getStageAndBindLevel :: Name -> TcRn (Maybe (TopLevelFlag, ThLevel, ThStage))
setStage :: ThStage -> TcM a -> TcRn a

-- | Adds the given modFinalizers to the global environment and set them to
--   use the current local environment.
addModFinalizersWithLclEnv :: ThModFinalizers -> TcM ()

-- | Mark that safe inference has failed See Note [Safe Haskell Overlapping
--   Instances Implementation] although this is used for more than just
--   that failure case.
recordUnsafeInfer :: WarningMessages -> TcM ()

-- | Figure out the final correct safe haskell mode
finalSafeMode :: DynFlags -> TcGblEnv -> IO SafeHaskellMode

-- | Switch instances to safe instances if we're in Safe mode.
fixSafeInstances :: SafeHaskellMode -> [ClsInst] -> [ClsInst]
getLocalRdrEnv :: RnM LocalRdrEnv
setLocalRdrEnv :: LocalRdrEnv -> RnM a -> RnM a
mkIfLclEnv :: Module -> SDoc -> IsBootInterface -> IfLclEnv

-- | Run an <a>IfG</a> (top-level interface monad) computation inside an
--   existing <a>TcRn</a> (typecheck-renaming monad) computation by
--   initializing an <a>IfGblEnv</a> based on <a>TcGblEnv</a>.
initIfaceTcRn :: IfG a -> TcRn a
initIfaceCheck :: SDoc -> HscEnv -> IfG a -> IO a
initIfaceLcl :: Module -> SDoc -> IsBootInterface -> IfL a -> IfM lcl a

-- | Initialize interface typechecking, but with a <a>NameShape</a> to
--   apply when typechecking top-level <a>OccName</a>s (see
--   <tt>lookupIfaceTop</tt>)
initIfaceLclWithSubst :: Module -> SDoc -> IsBootInterface -> NameShape -> IfL a -> IfM lcl a
initIfaceLoad :: HscEnv -> IfG a -> IO a
getIfModule :: IfL Module
failIfM :: SDoc -> IfL a

-- | Run thing_inside in an interleaved thread. It shares everything with
--   the parent thread, so this is DANGEROUS.
--   
--   It returns Nothing if the computation fails
--   
--   It's used for lazily type-checking interface signatures, which is
--   pretty benign.
--   
--   See Note [Masking exceptions in forkM_maybe]
forkM_maybe :: SDoc -> IfL a -> IfL (Maybe a)
forkM :: SDoc -> IfL a -> IfL a
setImplicitEnvM :: TypeEnv -> IfL a -> IfL a

-- | A convenient wrapper for taking a <tt>MaybeErr SDoc a</tt> and
--   throwing an exception if it is an error.
withException :: TcRnIf gbl lcl (MaybeErr SDoc a) -> TcRnIf gbl lcl a

-- | Get the next cost centre index associated with a given name.
getCCIndexM :: (gbl -> TcRef CostCentreState) -> FastString -> TcRnIf gbl lcl CostCentreIndex

-- | See <a>getCCIndexM</a>.
getCCIndexTcM :: FastString -> TcM CostCentreIndex
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.Monad.IsExtraConstraint
instance GHC.Types.Unique.Supply.MonadUnique (GHC.Data.IOEnv.IOEnv (GHC.Tc.Types.Env gbl lcl))

module GHC.Tc.Utils.Env

-- | A global typecheckable-thing, essentially anything that has a name.
--   Not to be confused with a <tt>TcTyThing</tt>, which is also a
--   typecheckable thing but in the *local* context. See
--   <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a> given a
--   <a>Name</a>.
data TyThing
AnId :: Id -> TyThing
AConLike :: ConLike -> TyThing
ATyCon :: TyCon -> TyThing
ACoAxiom :: CoAxiom Branched -> TyThing

-- | A typecheckable thing available in a local context. Could be
--   <a>AGlobal</a> <a>TyThing</a>, but also lexically scoped variables,
--   etc. See <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a>
--   given a <a>Name</a>.
data TcTyThing
AGlobal :: TyThing -> TcTyThing
ATcId :: TcId -> IdBindingInfo -> TcTyThing
[tct_id] :: TcTyThing -> TcId
[tct_info] :: TcTyThing -> IdBindingInfo
ATyVar :: Name -> TcTyVar -> TcTyThing
ATcTyCon :: TyCon -> TcTyThing
APromotionErr :: PromotionErr -> TcTyThing
type TcId = Id
data InstInfo a
InstInfo :: ClsInst -> InstBindings a -> InstInfo a
[iSpec] :: InstInfo a -> ClsInst
[iBinds] :: InstInfo a -> InstBindings a
iDFunId :: InstInfo a -> DFunId
pprInstInfoDetails :: OutputableBndrId a => InstInfo (GhcPass a) -> SDoc
simpleInstInfoClsTy :: InstInfo a -> (Class, Type)
simpleInstInfoTy :: InstInfo a -> Type
simpleInstInfoTyCon :: InstInfo a -> TyCon
data InstBindings a
InstBindings :: [Name] -> LHsBinds a -> [LSig a] -> [Extension] -> Bool -> InstBindings a
[ib_tyvars] :: InstBindings a -> [Name]
[ib_binds] :: InstBindings a -> LHsBinds a
[ib_pragmas] :: InstBindings a -> [LSig a]
[ib_extensions] :: InstBindings a -> [Extension]
[ib_derived] :: InstBindings a -> Bool
tcExtendGlobalEnv :: [TyThing] -> TcM r -> TcM r
tcExtendTyConEnv :: [TyCon] -> TcM r -> TcM r
tcExtendGlobalEnvImplicit :: [TyThing] -> TcM r -> TcM r
setGlobalTypeEnv :: TcGblEnv -> TypeEnv -> TcM TcGblEnv
tcExtendGlobalValEnv :: [Id] -> TcM a -> TcM a
tcLookupLocatedGlobal :: LocatedA Name -> TcM TyThing
tcLookupGlobal :: Name -> TcM TyThing
tcLookupGlobalOnly :: Name -> TcM TyThing
tcLookupTyCon :: Name -> TcM TyCon
tcLookupClass :: Name -> TcM Class
tcLookupDataCon :: Name -> TcM DataCon
tcLookupPatSyn :: Name -> TcM PatSyn
tcLookupConLike :: Name -> TcM ConLike
tcLookupLocatedGlobalId :: LocatedA Name -> TcM Id
tcLookupLocatedTyCon :: LocatedN Name -> TcM TyCon
tcLookupLocatedClass :: LocatedA Name -> TcM Class
tcLookupAxiom :: Name -> TcM (CoAxiom Branched)
lookupGlobal :: HscEnv -> Name -> IO TyThing
ioLookupDataCon :: HscEnv -> Name -> IO DataCon
addTypecheckedBinds :: TcGblEnv -> [LHsBinds GhcTc] -> TcGblEnv
tcExtendKindEnv :: NameEnv TcTyThing -> TcM r -> TcM r
tcExtendKindEnvList :: [(Name, TcTyThing)] -> TcM r -> TcM r
tcExtendTyVarEnv :: [TyVar] -> TcM r -> TcM r
tcExtendNameTyVarEnv :: [(Name, TcTyVar)] -> TcM r -> TcM r
tcExtendLetEnv :: TopLevelFlag -> TcSigFun -> IsGroupClosed -> [TcId] -> TcM a -> TcM a
tcExtendSigIds :: TopLevelFlag -> [TcId] -> TcM a -> TcM a
tcExtendRecIds :: [(Name, TcId)] -> TcM a -> TcM a
tcExtendIdEnv :: [TcId] -> TcM a -> TcM a
tcExtendIdEnv1 :: Name -> TcId -> TcM a -> TcM a
tcExtendIdEnv2 :: [(Name, TcId)] -> TcM a -> TcM a
tcExtendBinderStack :: [TcBinder] -> TcM a -> TcM a
tcExtendLocalTypeEnv :: TcLclEnv -> [(Name, TcTyThing)] -> TcLclEnv
isTypeClosedLetBndr :: Id -> Bool

-- | <tt>tcCheckUsage name mult thing_inside</tt> runs
--   <tt>thing_inside</tt>, checks that the usage of <tt>name</tt> is a
--   submultiplicity of <tt>mult</tt>, and removes <tt>name</tt> from the
--   usage environment. See also Note [Wrapper returned from tcSubMult] in
--   GHC.Tc.Utils.Unify, which applies to the wrapper returned from this
--   function.
tcCheckUsage :: Name -> Mult -> TcM a -> TcM (a, HsWrapper)
tcLookup :: Name -> TcM TcTyThing
tcLookupLocated :: LocatedA Name -> TcM TcTyThing
tcLookupLocalIds :: [Name] -> TcM [TcId]
tcLookupId :: Name -> TcM Id
tcLookupIdMaybe :: Name -> TcM (Maybe Id)
tcLookupTyVar :: Name -> TcM TcTyVar
tcLookupTcTyCon :: HasDebugCallStack => Name -> TcM TcTyCon
tcLookupLcl_maybe :: Name -> TcM (Maybe TcTyThing)
getInLocalScope :: TcM (Name -> Bool)
wrongThingErr :: String -> TcTyThing -> Name -> TcM a
pprBinders :: [Name] -> SDoc
tcAddDataFamConPlaceholders :: [LInstDecl GhcRn] -> TcM a -> TcM a
tcAddPatSynPlaceholders :: [PatSynBind GhcRn GhcRn] -> TcM a -> TcM a
getTypeSigNames :: [LSig GhcRn] -> NameSet
tcExtendRecEnv :: [(Name, TyThing)] -> TcM r -> TcM r
tcInitTidyEnv :: TcM TidyEnv

-- | Get a <a>TidyEnv</a> that includes mappings for all vars free in the
--   given type. Useful when tidying open types.
tcInitOpenTidyEnv :: [TyCoVar] -> TcM TidyEnv
tcLookupInstance :: Class -> [Type] -> TcM ClsInst
tcGetInstEnvs :: TcM InstEnvs
tcExtendRules :: [LRuleDecl GhcTc] -> TcM a -> TcM a
tcGetDefaultTys :: TcM ([Type], (Bool, Bool))
checkWellStaged :: SDoc -> ThLevel -> ThLevel -> TcM ()
tcMetaTy :: Name -> TcM Type
thLevel :: ThStage -> ThLevel
topIdLvl :: Id -> ThLevel
isBrackStage :: ThStage -> Bool

-- | Make a name for the dict fun for an instance decl. It's an *external*
--   name, like other top-level names, and hence must be made with
--   newGlobalBinder.
newDFunName :: Class -> [Type] -> SrcSpan -> TcM Name
newFamInstTyConName :: LocatedN Name -> [Type] -> TcM Name
newFamInstAxiomName :: LocatedN Name -> [[Type]] -> TcM Name
mkStableIdFromString :: String -> Type -> SrcSpan -> (OccName -> OccName) -> TcM TcId
mkStableIdFromName :: Name -> Type -> SrcSpan -> (OccName -> OccName) -> TcM TcId
mkWrapperName :: (MonadIO m, HasDynFlags m, HasModule m) => String -> String -> m FastString
instance GHC.Hs.Extension.OutputableBndrId a => GHC.Utils.Outputable.Outputable (GHC.Tc.Utils.Env.InstInfo (GHC.Hs.Extension.GhcPass a))
instance GHC.Types.TyThing.MonadThings (GHC.Data.IOEnv.IOEnv (GHC.Tc.Types.Env GHC.Tc.Types.TcGblEnv GHC.Tc.Types.TcLclEnv))


-- | Loading interface files
module GHC.Iface.Load
tcLookupImported_maybe :: Name -> TcM (MaybeErr SDoc TyThing)
importDecl :: Name -> IfM lcl (MaybeErr SDoc TyThing)
checkWiredInTyCon :: TyCon -> TcM ()
ifCheckWiredInThing :: TyThing -> IfL ()

-- | Load interface directly for a fully qualified <a>Module</a>. (This is
--   a fairly rare operation, but in particular it is used to load orphan
--   modules in order to pull their instances into the global package table
--   and to handle some operations in GHCi).
loadModuleInterface :: SDoc -> Module -> TcM ModIface

-- | Load interfaces for a collection of modules.
loadModuleInterfaces :: SDoc -> [Module] -> TcM ()

-- | Load the interface corresponding to an <tt>import</tt> directive in
--   source code. On a failure, fail in the monad with an error message.
loadSrcInterface :: SDoc -> ModuleName -> IsBootInterface -> Maybe FastString -> RnM ModIface

-- | Like <a>loadSrcInterface</a>, but returns a <a>MaybeErr</a>.
loadSrcInterface_maybe :: SDoc -> ModuleName -> IsBootInterface -> Maybe FastString -> RnM (MaybeErr SDoc ModIface)

-- | Loads the interface for a given Name. Should only be called for an
--   imported name; otherwise loadSysInterface may not find the interface
loadInterfaceForName :: SDoc -> Name -> TcRn ModIface

-- | Only loads the interface for external non-local names.
loadInterfaceForNameMaybe :: SDoc -> Name -> TcRn (Maybe ModIface)

-- | Loads the interface for a given Module.
loadInterfaceForModule :: SDoc -> Module -> TcRn ModIface
loadInterface :: SDoc -> Module -> WhereFrom -> IfM lcl (MaybeErr SDoc ModIface)

-- | Loads a system interface and throws an exception if it fails
loadSysInterface :: SDoc -> Module -> IfM lcl ModIface

-- | Loads a user interface and throws an exception if it fails. The first
--   parameter indicates whether we should import the boot variant of the
--   module
loadUserInterface :: IsBootInterface -> SDoc -> Module -> IfM lcl ModIface
loadPluginInterface :: SDoc -> Module -> IfM lcl ModIface
findAndReadIface :: SDoc -> InstalledModule -> Module -> IsBootInterface -> TcRnIf gbl lcl (MaybeErr SDoc (ModIface, FilePath))
readIface :: Module -> FilePath -> TcRnIf gbl lcl (MaybeErr SDoc ModIface)

-- | Write interface file
writeIface :: Logger -> DynFlags -> FilePath -> ModIface -> IO ()
initExternalPackageState :: ExternalPackageState

-- | Compute the signatures which must be compiled in order to load the
--   interface for a <a>Module</a>. The output of this function is always a
--   subset of <a>moduleFreeHoles</a>; it is more precise because in
--   signature <tt>p[A=&lt;A&gt;,B=&lt;B&gt;]:B</tt>, although the free
--   holes are A and B, B might not depend on A at all!
--   
--   If this is invoked on a signature, this does NOT include the signature
--   itself; e.g. precise free module holes of
--   <tt>p[A=&lt;A&gt;,B=&lt;B&gt;]:B</tt> never includes B.
moduleFreeHolesPrecise :: SDoc -> Module -> TcRnIf gbl lcl (MaybeErr SDoc (UniqDSet ModuleName))
needWiredInHomeIface :: TyThing -> Bool

-- | An <a>IfM</a> function to load the home interface for a wired-in
--   thing, so that we're sure that we see its instance declarations and
--   rules See Note [Loading instances for wired-in things]
loadWiredInHomeIface :: Name -> IfM lcl ()

-- | Show a ModIface but don't display details; suitable for ModIfaces
--   stored in the EPT.
pprModIfaceSimple :: UnitState -> ModIface -> SDoc
ifaceStats :: ExternalPackageState -> SDoc

-- | Show a ModIface
--   
--   The UnitState is used to pretty-print units
pprModIface :: UnitState -> ModIface -> SDoc

-- | Read binary interface, and print it out
showIface :: HscEnv -> FilePath -> IO ()
cannotFindModule :: HscEnv -> ModuleName -> FindResult -> SDoc
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Warnings.Warnings

module GHC.IfaceToCore
tcLookupImported_maybe :: Name -> TcM (MaybeErr SDoc TyThing)
importDecl :: Name -> IfM lcl (MaybeErr SDoc TyThing)
checkWiredInTyCon :: TyCon -> TcM ()
tcHiBootIface :: HscSource -> Module -> TcRn SelfBootInfo
typecheckIface :: ModIface -> IfG ModDetails

-- | This is a very interesting function. Like typecheckIface, we want to
--   type check an interface file into a ModDetails. However, the use-case
--   for these ModDetails is different: we want to compare all of the
--   ModDetails to ensure they define compatible declarations, and then
--   merge them together. So in particular, we have to take a different
--   strategy for knot-tying: we first speculatively merge the declarations
--   to get the "base" truth for what we believe the types will be (this is
--   "type computation.") Then we read everything in relative to this truth
--   and check for compatibility.
--   
--   During the merge process, we may need to nondeterministically pick a
--   particular declaration to use, if multiple signatures define the
--   declaration (<a>mergeIfaceDecl</a>). If, for all choices, there are no
--   type synonym cycles in the resulting merged graph, then we can show
--   that our choice cannot matter. Consider the set of entities which the
--   declarations depend on: by assumption of acyclicity, we can assume
--   that these have already been shown to be equal to each other
--   (otherwise merging will fail). Then it must be the case that all
--   candidate declarations here are type-equal (the choice doesn't matter)
--   or there is an inequality (in which case merging will fail.)
--   
--   Unfortunately, the choice can matter if there is a cycle. Consider the
--   following merge:
--   
--   signature H where { type A = C; type B = A; data C } signature H where
--   { type A = (); data B; type C = B }
--   
--   If we pick <tt>type A = C</tt> as our representative, there will be a
--   cycle and merging will fail. But if we pick <tt>type A = ()</tt> as
--   our representative, no cycle occurs, and we instead conclude that all
--   of the types are unit. So it seems that we either (a) need a stronger
--   acyclicity check which considers *all* possible choices from a merge,
--   or (b) we must find a selection of declarations which is acyclic, and
--   show that this is always the "best" choice we could have made (ezyang
--   conjectures this is the case but does not have a proof). For now this
--   is not implemented.
--   
--   It's worth noting that at the moment, a data constructor and a type
--   synonym are never compatible. Consider:
--   
--   signature H where { type Int=C; type B = Int; data C = Int} signature
--   H where { export Prelude.Int; data B; type C = B; }
--   
--   This will be rejected, because the reexported Int in the second
--   signature (a proper data type) is never considered equal to a type
--   synonym. Perhaps this should be relaxed, where a type synonym in a
--   signature is considered implemented by a data type declaration which
--   matches the reference of the type synonym.
typecheckIfacesForMerging :: Module -> [ModIface] -> IORef TypeEnv -> IfM lcl (TypeEnv, [ModDetails])

-- | Typecheck a signature <a>ModIface_</a> under the assumption that we
--   have instantiated it under some implementation (recorded in
--   <a>mi_semantic_module</a>) and want to check if the implementation
--   fills the signature.
--   
--   This needs to operate slightly differently than <a>typecheckIface</a>
--   because (1) we have a <a>NameShape</a>, from the exports of the
--   implementing module, which we will use to give our top-level
--   declarations the correct <a>Name</a>s even when the implementor
--   provided them with a reexport, and (2) we have to deal with DFun
--   silliness (see Note [rnIfaceNeverExported])
typecheckIfaceForInstantiate :: NameShape -> ModIface -> IfM lcl ModDetails
tcIfaceDecl :: Bool -> IfaceDecl -> IfL TyThing
tcIfaceDecls :: Bool -> [(Fingerprint, IfaceDecl)] -> IfL [(Name, TyThing)]
tcIfaceInst :: IfaceClsInst -> IfL ClsInst
tcIfaceFamInst :: IfaceFamInst -> IfL FamInst
tcIfaceRules :: Bool -> [IfaceRule] -> IfL [CoreRule]
tcIfaceAnnotations :: [IfaceAnnotation] -> IfL [Annotation]
tcIfaceCompleteMatches :: [IfaceCompleteMatch] -> IfL [CompleteMatch]
tcIfaceExpr :: IfaceExpr -> IfL CoreExpr
tcIfaceGlobal :: Name -> IfL TyThing
tcIfaceOneShot :: IfaceOneShot -> OneShotInfo

module GHC.Tc.TyCl.Build
buildDataCon :: FamInstEnvs -> Name -> Bool -> TyConRepName -> [HsSrcBang] -> Maybe [HsImplBang] -> [FieldLabel] -> [TyVar] -> [TyCoVar] -> [InvisTVBinder] -> [EqSpec] -> KnotTied ThetaType -> [KnotTied (Scaled Type)] -> KnotTied Type -> KnotTied TyCon -> NameEnv ConTag -> TcRnIf m n DataCon
buildPatSyn :: Name -> Bool -> PatSynMatcher -> PatSynBuilder -> ([InvisTVBinder], ThetaType) -> ([InvisTVBinder], ThetaType) -> [Type] -> Type -> [FieldLabel] -> PatSyn
type TcMethInfo = MethInfo
type MethInfo = (Name, Type, Maybe (DefMethSpec (SrcSpan, Type)))
buildClass :: Name -> [TyConBinder] -> [Role] -> [FunDep TyVar] -> Maybe (KnotTied ThetaType, [ClassATItem], [KnotTied MethInfo], ClassMinimalDef) -> TcRnIf m n Class

-- | Monadic because it makes a Name for the coercion TyCon We pass the
--   Name of the parent TyCon, as well as the TyCon itself, because the
--   latter is part of a knot, whereas the former is not.
mkNewTyConRhs :: Name -> TyCon -> DataCon -> TcRnIf m n AlgTyConRhs
newImplicitBinder :: Name -> (OccName -> OccName) -> TcRnIf m n Name

-- | Make the <a>TyConRepName</a> for this <a>TyCon</a>
newTyConRepName :: Name -> TcRnIf gbl lcl TyConRepName

module GHC.Iface.Env
newGlobalBinder :: Module -> OccName -> SrcSpan -> TcRnIf a b Name
newInteractiveBinder :: HscEnv -> OccName -> SrcSpan -> IO Name
externaliseName :: Module -> Name -> TcRnIf m n Name

-- | Look up a top-level name from the current Iface module
lookupIfaceTop :: OccName -> IfL Name

-- | Look up the <a>Name</a> for a given <a>Module</a> and <a>OccName</a>.
--   Consider alternatively using <a>lookupIfaceTop</a> if you're in the
--   <a>IfL</a> monad and <a>Module</a> is simply that of the
--   <a>ModIface_</a> you are typechecking.
lookupOrig :: Module -> OccName -> TcRnIf a b Name
lookupOrigIO :: HscEnv -> Module -> OccName -> IO Name
lookupOrigNameCache :: OrigNameCache -> Module -> OccName -> Maybe Name
extendNameCache :: OrigNameCache -> Module -> OccName -> Name -> OrigNameCache
newIfaceName :: OccName -> IfL Name
newIfaceNames :: [OccName] -> IfL [Name]
extendIfaceIdEnv :: [Id] -> IfL a -> IfL a
extendIfaceTyVarEnv :: [TyVar] -> IfL a -> IfL a
tcIfaceLclId :: FastString -> IfL Id
tcIfaceTyVar :: FastString -> IfL TyVar
lookupIfaceVar :: IfaceBndr -> IfL (Maybe TyCoVar)
lookupIfaceTyVar :: IfaceTvBndr -> IfL (Maybe TyVar)
extendIfaceEnvs :: [TyCoVar] -> IfL a -> IfL a

-- | Set the <a>Module</a> of a <a>Name</a>.
setNameModule :: Maybe Module -> Name -> TcRnIf m n Name
ifaceExportNames :: [IfaceExport] -> TcRnIf gbl lcl [AvailInfo]
allocateGlobalBinder :: NameCache -> Module -> OccName -> SrcSpan -> (NameCache, Name)
updNameCacheTc :: Module -> OccName -> (NameCache -> (NameCache, c)) -> TcRnIf a b c
updNameCache :: IORef NameCache -> (NameCache -> (NameCache, c)) -> IO c
mkNameCacheUpdater :: TcRnIf a b NameCacheUpdater

-- | A function that atomically updates the name cache given a modifier
--   function. The second result of the modifier function will be the
--   result of the IO action.
newtype NameCacheUpdater
NCU :: (forall c. (NameCache -> (NameCache, c)) -> IO c) -> NameCacheUpdater
[updateNameCache] :: NameCacheUpdater -> forall c. (NameCache -> (NameCache, c)) -> IO c


-- | This module implements interface renaming, which is used to rewrite
--   interface files on the fly when we are doing indefinite typechecking
--   and need instantiations of modules which do not necessarily exist yet.
module GHC.Iface.Rename

-- | What we have is a generalized ModIface, which corresponds to a module
--   that looks like p[A=&lt;A&gt;]:B. We need a *specific* ModIface, e.g.
--   p[A=q():A]:B (or maybe even p[A=&lt;B&gt;]:B) which we load up (either
--   to merge it, or to just use during typechecking).
--   
--   Suppose we have:
--   
--   p[A=&lt;A&gt;]:M ==&gt; p[A=q():A]:M
--   
--   Substitute all occurrences of &lt;A&gt; with q():A (renameHoleModule).
--   Then, for any Name of form {A.T}, replace the Name with the Name
--   according to the exports of the implementing module. This works even
--   for p[A=&lt;B&gt;]:M, since we just read in the exports of B.hi, which
--   is assumed to be ready now.
--   
--   This function takes an optional <a>NameShape</a>, which can be used to
--   further refine the identities in this interface: suppose we read a
--   declaration for {H.T} but we actually know that this should be Foo.T;
--   then we'll also rename this (this is used when loading an interface to
--   merge it into a requirement.)
rnModIface :: HscEnv -> [(ModuleName, Module)] -> Maybe NameShape -> ModIface -> IO (Either ErrorMessages ModIface)

-- | Rename just the exports of a <a>ModIface_</a>. Useful when we're doing
--   shaping prior to signature merging.
rnModExports :: HscEnv -> [(ModuleName, Module)] -> ModIface -> IO (Either ErrorMessages [AvailInfo])
tcRnModIface :: [(ModuleName, Module)] -> Maybe NameShape -> ModIface -> TcM ModIface
tcRnModExports :: [(ModuleName, Module)] -> ModIface -> TcM [AvailInfo]

module GHC.Types.Name.Shape

-- | A <a>NameShape</a> is a substitution on <a>Name</a>s that can be used
--   to refine the identities of a hole while we are renaming interfaces
--   (see <a>GHC.Iface.Rename</a>). Specifically, a <a>NameShape</a> for
--   <tt>ns_module_name</tt> <tt>A</tt>, defines a mapping from
--   <tt>{A.T}</tt> (for some <a>OccName</a> <tt>T</tt>) to some arbitrary
--   other <a>Name</a>.
--   
--   The most intruiging thing about a <a>NameShape</a>, however, is how
--   it's constructed. A <a>NameShape</a> is *implied* by the exported
--   <a>AvailInfo</a>s of the implementor of an interface: if an
--   implementor of signature <tt>&lt;H&gt;</tt> exports <tt>M.T</tt>, you
--   implicitly define a substitution from <tt>{H.T}</tt> to <tt>M.T</tt>.
--   So a <a>NameShape</a> is computed from the list of <a>AvailInfo</a>s
--   that are exported by the implementation of a module, or successively
--   merged together by the export lists of signatures which are joining
--   together.
--   
--   It's not the most obvious way to go about doing this, but it does seem
--   to work!
--   
--   NB: Can't boot this and put it in NameShape because then we start
--   pulling in too many DynFlags things.
data NameShape
NameShape :: ModuleName -> [AvailInfo] -> OccEnv Name -> NameShape
[ns_mod_name] :: NameShape -> ModuleName
[ns_exports] :: NameShape -> [AvailInfo]
[ns_map] :: NameShape -> OccEnv Name

-- | Create an empty <a>NameShape</a> (i.e., the renaming that would occur
--   with an implementing module with no exports) for a specific hole
--   <tt>mod_name</tt>.
emptyNameShape :: ModuleName -> NameShape

-- | Create a <a>NameShape</a> corresponding to an implementing module for
--   the hole <tt>mod_name</tt> that exports a list of <a>AvailInfo</a>s.
mkNameShape :: ModuleName -> [AvailInfo] -> NameShape

-- | Given an existing <a>NameShape</a>, merge it with a list of
--   <a>AvailInfo</a>s with Backpack style mix-in linking. This is used
--   solely when merging signatures together: we successively merge the
--   exports of each signature until we have the final, full exports of the
--   merged signature.
--   
--   What makes this operation nontrivial is what we are supposed to do
--   when we want to merge in an export for M.T when we already have an
--   existing export {H.T}. What should happen in this case is that {H.T}
--   should be unified with <tt>M.T</tt>: we've determined a more *precise*
--   identity for the export at <a>OccName</a> <tt>T</tt>.
--   
--   Note that we don't do unrestricted unification: only name holes from
--   <tt>ns_mod_name ns</tt> are flexible. This is because we have a much
--   more restricted notion of shaping than in Backpack'14: we do shaping
--   *as* we do type-checking. Thus, once we shape a signature, its exports
--   are *final* and we're not allowed to refine them further,
extendNameShape :: HscEnv -> NameShape -> [AvailInfo] -> IO (Either SDoc NameShape)

-- | The export list associated with this <a>NameShape</a> (i.e., what the
--   exports of an implementing module which induces this <a>NameShape</a>
--   would be.)
nameShapeExports :: NameShape -> [AvailInfo]

-- | Given a <a>Name</a>, substitute it according to the <a>NameShape</a>
--   implied substitution, i.e. map <tt>{A.T}</tt> to <tt>M.T</tt>, if the
--   implementing module exports <tt>M.T</tt>.
substNameShape :: NameShape -> Name -> Name

-- | Like <a>substNameShape</a>, but returns <tt>Nothing</tt> if no
--   substitution works.
maybeSubstNameShape :: NameShape -> Name -> Maybe Name


-- | Binary interface file support.
module GHC.Iface.Binary

-- | Write an interface file
writeBinIface :: Profile -> TraceBinIFace -> FilePath -> ModIface -> IO ()

-- | Read an interface file
readBinIface :: CheckHiWay -> TraceBinIFace -> FilePath -> TcRnIf a b ModIface

-- | Read an interface file in <a>IO</a>.
readBinIface_ :: Profile -> CheckHiWay -> TraceBinIFace -> FilePath -> NameCacheUpdater -> IO ModIface
getSymtabName :: NameCacheUpdater -> Dictionary -> SymbolTable -> BinHandle -> IO Name
getDictFastString :: Dictionary -> BinHandle -> IO FastString
data CheckHiWay
CheckHiWay :: CheckHiWay
IgnoreHiWay :: CheckHiWay
data TraceBinIFace
TraceBinIFace :: (SDoc -> IO ()) -> TraceBinIFace
QuietBinIFace :: TraceBinIFace

-- | This performs a get action after reading the dictionary and symbol
--   table. It is necessary to run this before trying to deserialise any
--   Names or FastStrings.
getWithUserData :: Binary a => NameCacheUpdater -> BinHandle -> IO a

-- | Put a piece of data with an initialised <a>UserData</a> field. This is
--   necessary if you want to serialise Names or FastStrings. It also
--   writes a symbol table and the dictionary. This segment should be read
--   using <a>getWithUserData</a>.
putWithUserData :: Binary a => TraceBinIFace -> BinHandle -> a -> IO ()
getSymbolTable :: BinHandle -> NameCacheUpdater -> IO SymbolTable
putName :: BinDictionary -> BinSymbolTable -> BinHandle -> Name -> IO ()
putDictionary :: BinHandle -> Int -> UniqFM FastString (Int, FastString) -> IO ()
putFastString :: BinDictionary -> BinHandle -> FastString -> IO ()
putSymbolTable :: BinHandle -> Int -> UniqFM Name (Int, Name) -> IO ()
data BinSymbolTable
BinSymbolTable :: !FastMutInt -> !IORef (UniqFM Name (Int, Name)) -> BinSymbolTable
[bin_symtab_next] :: BinSymbolTable -> !FastMutInt
[bin_symtab_map] :: BinSymbolTable -> !IORef (UniqFM Name (Int, Name))
data BinDictionary
BinDictionary :: !FastMutInt -> !IORef (UniqFM FastString (Int, FastString)) -> BinDictionary
[bin_dict_next] :: BinDictionary -> !FastMutInt
[bin_dict_map] :: BinDictionary -> !IORef (UniqFM FastString (Int, FastString))
instance GHC.Classes.Eq GHC.Iface.Binary.CheckHiWay

module GHC.Tc.Utils.Instantiate
topSkolemise :: TcSigmaType -> TcM (HsWrapper, [(Name, TyVar)], [EvVar], TcRhoType)
topInstantiate :: CtOrigin -> TcSigmaType -> TcM (HsWrapper, TcRhoType)
instantiateSigma :: CtOrigin -> [TyVar] -> TcThetaType -> TcSigmaType -> TcM ([TcTyVar], HsWrapper, TcSigmaType)
instCall :: CtOrigin -> [TcType] -> TcThetaType -> TcM HsWrapper
instDFunType :: DFunId -> [DFunInstType] -> TcM ([TcType], TcThetaType)
instStupidTheta :: CtOrigin -> TcThetaType -> TcM ()
instTyVarsWith :: CtOrigin -> [TyVar] -> [TcType] -> TcM TCvSubst
newWanted :: CtOrigin -> Maybe TypeOrKind -> PredType -> TcM CtEvidence
newWanteds :: CtOrigin -> ThetaType -> TcM [CtEvidence]
tcInstType :: ([TyVar] -> TcM (TCvSubst, [TcTyVar])) -> Id -> TcM ([(Name, TcTyVar)], TcThetaType, TcType)
tcInstTypeBndrs :: Id -> TcM ([(Name, InvisTVBinder)], TcThetaType, TcType)

-- | Given a list of <tt>[<a>TyVar</a>]</tt>, skolemize the type variables,
--   returning a substitution mapping the original tyvars to the skolems,
--   and the list of newly bound skolems.
tcInstSkolTyVars :: [TyVar] -> TcM (TCvSubst, [TcTyVar])
tcInstSkolTyVarsX :: TCvSubst -> [TyVar] -> TcM (TCvSubst, [TcTyVar])
tcInstSkolTyVarsAt :: TcLevel -> Bool -> TCvSubst -> [TyVar] -> TcM (TCvSubst, [TcTyVar])
tcSkolDFunType :: DFunId -> TcM ([TcTyVar], TcThetaType, TcType)
tcSuperSkolTyVars :: [TyVar] -> (TCvSubst, [TcTyVar])
tcInstSuperSkolTyVarsX :: TCvSubst -> [TyVar] -> TcM (TCvSubst, [TcTyVar])

-- | Give fresh uniques to a bunch of TyVars, but they stay as TyVars,
--   rather than becoming TcTyVars Used in <a>newFamInst</a>, and
--   <a>newClsInst</a>
freshenTyVarBndrs :: [TyVar] -> TcM (TCvSubst, [TyVar])

-- | Give fresh uniques to a bunch of CoVars Used in
--   "GHC.Tc.Instance.Family.newFamInst"
freshenCoVarBndrsX :: TCvSubst -> [CoVar] -> TcM (TCvSubst, [CoVar])
tcInstInvisibleTyBindersN :: Int -> TcKind -> TcM ([TcType], TcKind)

-- | Given ty::forall k1 k2. k, instantiate all the invisible
--   forall-binders returning ty <tt>kk1 </tt>kk2 :: k[kk1<i>k1, kk2</i>k1]
tcInstInvisibleTyBinders :: TcType -> TcKind -> TcM (TcType, TcKind)

-- | Used only in *types*
tcInstInvisibleTyBinder :: TCvSubst -> TyBinder -> TcM (TCvSubst, TcType)
newOverloadedLit :: HsOverLit GhcRn -> ExpRhoType -> TcM (HsOverLit GhcTc)
mkOverLit :: OverLitVal -> TcM (HsLit GhcTc)
newClsInst :: Maybe OverlapMode -> Name -> [TyVar] -> ThetaType -> Class -> [Type] -> TcM ClsInst
tcGetInsts :: TcM [ClsInst]
tcGetInstEnvs :: TcM InstEnvs
getOverlapFlag :: Maybe OverlapMode -> TcM OverlapFlag
tcExtendLocalInstEnv :: [ClsInst] -> TcM a -> TcM a
instCallConstraints :: CtOrigin -> TcThetaType -> TcM HsWrapper

-- | Used when <a>Name</a> is the wired-in name for a wired-in class
--   method, so the caller knows its type for sure, which should be of form
--   
--   <pre>
--   forall a. C a =&gt; &lt;blah&gt;
--   </pre>
--   
--   <a>newMethodFromName</a> is supposed to instantiate just the outer
--   type variable and constraint
newMethodFromName :: CtOrigin -> Name -> [TcRhoType] -> TcM (HsExpr GhcTc)
tcSyntaxName :: CtOrigin -> TcType -> (Name, HsExpr GhcRn) -> TcM (Name, HsExpr GhcTc)

-- | Returns free variables of WantedConstraints as a non-deterministic
--   set. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfWC :: WantedConstraints -> TyCoVarSet

-- | Returns free variables of constraints as a non-deterministic set
tyCoVarsOfCt :: Ct -> TcTyCoVarSet

-- | Returns free variables of a bag of constraints as a non-deterministic
--   set. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfCts :: Cts -> TcTyCoVarSet

module GHC.Tc.Gen.Expr
tcCheckPolyExpr :: LHsExpr GhcRn -> TcSigmaType -> TcM (LHsExpr GhcTc)
tcCheckPolyExprNC :: LHsExpr GhcRn -> TcSigmaType -> TcM (LHsExpr GhcTc)
tcCheckMonoExpr :: LHsExpr GhcRn -> TcRhoType -> TcM (LHsExpr GhcTc)
tcCheckMonoExprNC :: LHsExpr GhcRn -> TcRhoType -> TcM (LHsExpr GhcTc)
tcMonoExpr :: LHsExpr GhcRn -> ExpRhoType -> TcM (LHsExpr GhcTc)
tcMonoExprNC :: LHsExpr GhcRn -> ExpRhoType -> TcM (LHsExpr GhcTc)
tcInferRho :: LHsExpr GhcRn -> TcM (LHsExpr GhcTc, TcRhoType)
tcInferRhoNC :: LHsExpr GhcRn -> TcM (LHsExpr GhcTc, TcRhoType)
tcPolyExpr :: HsExpr GhcRn -> ExpSigmaType -> TcM (HsExpr GhcTc)
tcExpr :: HsExpr GhcRn -> ExpRhoType -> TcM (HsExpr GhcTc)

-- | Typecheck a syntax operator The operator is a variable or a lambda at
--   this stage (i.e. renamer output)t
tcSyntaxOp :: CtOrigin -> SyntaxExprRn -> [SyntaxOpType] -> ExpRhoType -> ([TcSigmaType] -> [Mult] -> TcM a) -> TcM (a, SyntaxExprTc)

-- | Slightly more general version of <a>tcSyntaxOp</a> that allows the
--   caller to specify the shape of the result of the syntax operator
tcSyntaxOpGen :: CtOrigin -> SyntaxExprRn -> [SyntaxOpType] -> SyntaxOpType -> ([TcSigmaType] -> [Mult] -> TcM a) -> TcM (a, SyntaxExprTc)

-- | What to expect for an argument to a rebindable-syntax operator. Quite
--   like <a>Type</a>, but allows for holes to be filled in by tcSyntaxOp.
--   The callback called from tcSyntaxOp gets a list of types; the meaning
--   of these types is determined by a left-to-right depth-first traversal
--   of the <a>SyntaxOpType</a> tree. So if you pass in
--   
--   <pre>
--   SynAny `SynFun` (SynList `SynFun` SynType Int) `SynFun` SynAny
--   </pre>
--   
--   you'll get three types back: one for the first <a>SynAny</a>, the
--   <i>element</i> type of the list, and one for the last <a>SynAny</a>.
--   You don't get anything for the <a>SynType</a>, because you've said
--   positively that it should be an Int, and so it shall be.
--   
--   You'll also get three multiplicities back: one for each function
--   arrow. See also Note [Linear types] in Multiplicity.
--   
--   This is defined here to avoid defining it in <a>GHC.Tc.Gen.Expr</a>
--   boot file.
data SyntaxOpType

-- | Any type
SynAny :: SyntaxOpType

-- | A rho type, skolemised or instantiated as appropriate
SynRho :: SyntaxOpType

-- | A list type. You get back the element type of the list
SynList :: SyntaxOpType

-- | A function.
SynFun :: SyntaxOpType -> SyntaxOpType -> SyntaxOpType

-- | A known type.
SynType :: ExpType -> SyntaxOpType
infixr 0 `SynFun`

-- | Like <a>SynType</a> but accepts a regular TcType
synKnownType :: TcType -> SyntaxOpType
tcCheckId :: Name -> ExpRhoType -> TcM (HsExpr GhcTc)

-- | This name really is ambiguous, so add a suitable "ambiguous
--   occurrence" error, then continue
addAmbiguousNameErr :: RdrName -> TcM ()
getFixedTyVars :: [FieldLabelString] -> [TyVar] -> [ConLike] -> TyVarSet


-- | The <tt>FamInst</tt> type: family instance heads
module GHC.Tc.Instance.Family
type FamInstEnvs = (FamInstEnv, FamInstEnv)
tcGetFamInstEnvs :: TcM FamInstEnvs
checkFamInstConsistency :: [Module] -> TcM ()
tcExtendLocalFamInstEnv :: [FamInst] -> TcM a -> TcM a

-- | Like <a>tcLookupDataFamInst_maybe</a>, but returns the arguments back
--   if there is no data family to unwrap. Returns a Representational
--   coercion
tcLookupDataFamInst :: FamInstEnvs -> TyCon -> [TcType] -> (TyCon, [TcType], Coercion)

-- | Converts a data family type (eg F [a]) to its representation type (eg
--   FList a) and returns a coercion between the two: co :: F [a] ~R FList
--   a.
tcLookupDataFamInst_maybe :: FamInstEnvs -> TyCon -> [TcType] -> Maybe (TyCon, [TcType], Coercion)

-- | If <tt>co :: T ts ~ rep_ty</tt> then:
--   
--   <pre>
--   instNewTyCon_maybe T ts = Just (rep_ty, co)
--   </pre>
--   
--   Checks for a newtype, and for being saturated Just like
--   Coercion.instNewTyCon_maybe, but returns a TcCoercion
tcInstNewTyCon_maybe :: TyCon -> [TcType] -> Maybe (TcType, TcCoercion)

-- | <a>tcTopNormaliseNewTypeTF_maybe</a> gets rid of top-level newtypes,
--   potentially looking through newtype <i>instances</i>.
--   
--   It is only used by the type inference engine (specifically, when
--   solving representational equality), and hence it is careful to unwrap
--   only if the relevant data constructor is in scope. That's why it gets
--   a GlobalRdrEnv argument.
--   
--   It is careful not to unwrap data/newtype instances if it can't
--   continue unwrapping. Such care is necessary for proper error messages.
--   
--   It does not look through type families. It does not normalise
--   arguments to a tycon.
--   
--   If the result is Just (rep_ty, (co, gres), rep_ty), then co : ty ~R
--   rep_ty gres are the GREs for the data constructors that had to be in
--   scope
tcTopNormaliseNewTypeTF_maybe :: FamInstEnvs -> GlobalRdrEnv -> Type -> Maybe ((Bag GlobalRdrElt, TcCoercion), Type)
newFamInst :: FamFlavor -> CoAxiom Unbranched -> TcM FamInst

-- | Report a list of injectivity errors together with their source
--   locations. Looks only at one equation; does not look for conflicts
--   *among* equations.
reportInjectivityErrors :: DynFlags -> CoAxiom br -> CoAxBranch -> [Bool] -> TcM ()

-- | Report error message for a pair of equations violating an injectivity
--   annotation. No error message if there are no branches.
reportConflictingInjectivityErrs :: TyCon -> [CoAxBranch] -> CoAxBranch -> TcM ()


-- | Template Haskell splices
module GHC.Tc.Gen.Splice
tcSpliceExpr :: HsSplice GhcRn -> ExpRhoType -> TcM (HsExpr GhcTc)
tcTypedBracket :: HsExpr GhcRn -> HsBracket GhcRn -> ExpRhoType -> TcM (HsExpr GhcTc)
tcUntypedBracket :: HsExpr GhcRn -> HsBracket GhcRn -> [PendingRnSplice] -> ExpRhoType -> TcM (HsExpr GhcTc)
runAnnotation :: CoreAnnTarget -> LHsExpr GhcRn -> TcM Annotation
runMetaE :: LHsExpr GhcTc -> TcM (LHsExpr GhcPs)
runMetaP :: LHsExpr GhcTc -> TcM (LPat GhcPs)
runMetaT :: LHsExpr GhcTc -> TcM (LHsType GhcPs)
runMetaD :: LHsExpr GhcTc -> TcM [LHsDecl GhcPs]
runQuasi :: Q a -> TcM a
tcTopSpliceExpr :: SpliceType -> TcM (LHsExpr GhcTc) -> TcM (LHsExpr GhcTc)
lookupThName_maybe :: Name -> TcM (Maybe Name)
defaultRunMeta :: MetaHook TcM
runMeta' :: Bool -> (hs_syn -> SDoc) -> (SrcSpan -> ForeignHValue -> TcM (Either SDoc hs_syn)) -> LHsExpr GhcTc -> TcM hs_syn
runRemoteModFinalizers :: ThModFinalizers -> TcM ()

-- | Releases the external interpreter state.
finishTH :: TcM ()
runTopSplice :: DelayedSplice -> TcM (HsExpr GhcTc)
instance GHC.Tc.Gen.Splice.ReifyFlag () ()
instance GHC.Tc.Gen.Splice.ReifyFlag GHC.Types.Var.Specificity Language.Haskell.TH.Syntax.Specificity
instance Language.Haskell.TH.Syntax.Quasi GHC.Tc.Types.TcM

module GHC.Tc.Solver

-- | How should we choose which constraints to quantify over?
data InferMode

-- | Apply the monomorphism restriction, never quantifying over any
--   constraints
ApplyMR :: InferMode

-- | See Note [TcRnExprMode] in <a>GHC.Tc.Module</a>, the :type +d case;
--   this mode refuses to quantify over any defaultable constraint
EagerDefaulting :: InferMode

-- | Quantify over any constraint that satisfies
--   <a>pickQuantifiablePreds</a>
NoRestrictions :: InferMode
simplifyInfer :: TcLevel -> InferMode -> [TcIdSigInst] -> [(Name, TcTauType)] -> WantedConstraints -> TcM ([TcTyVar], [EvVar], TcEvBinds, Bool)
findInferredDiff :: TcThetaType -> TcThetaType -> TcM TcThetaType
growThetaTyVars :: ThetaType -> TyCoVarSet -> TyCoVarSet
simplifyAmbiguityCheck :: Type -> WantedConstraints -> TcM ()
simplifyDefault :: ThetaType -> TcM Bool
simplifyTop :: WantedConstraints -> TcM (Bag EvBind)
simplifyTopImplic :: Bag Implication -> TcM ()
simplifyInteractive :: WantedConstraints -> TcM (Bag EvBind)

-- | Type-check a thing that emits only equality constraints, solving any
--   constraints we can and re-emitting constraints that we can't. Use this
--   variant only when we'll get another crack at it later See Note
--   [Failure in local type signatures]
--   
--   Panics if we solve any non-equality constraints. (In runTCSEqualities
--   we use an error thunk for the evidence bindings.)
solveEqualities :: String -> TcM a -> TcM a
pushLevelAndSolveEqualities :: SkolemInfo -> [TcTyVar] -> TcM a -> TcM a
pushLevelAndSolveEqualitiesX :: String -> TcM a -> TcM (TcLevel, WantedConstraints, a)
reportUnsolvedEqualities :: SkolemInfo -> [TcTyVar] -> TcLevel -> WantedConstraints -> TcM ()
simplifyWantedsTcM :: [CtEvidence] -> TcM WantedConstraints

-- | Return (Just new_inerts) if the Givens are satisfiable, Nothing if
--   definitely contradictory
tcCheckGivens :: InertSet -> Bag EvVar -> TcM (Maybe InertSet)

-- | Return True if the Wanteds are soluble, False if not
tcCheckWanteds :: InertSet -> ThetaType -> TcM Bool

-- | Normalise a type as much as possible using the given constraints. See
--   <tt>Note [tcNormalise]</tt>.
tcNormalise :: InertSet -> Type -> TcM Type
captureTopConstraints :: TcM a -> TcM (a, WantedConstraints)

-- | Simplify top-level constraints, but without reporting any unsolved
--   constraints nor unsafe overlapping.
simplifyTopWanteds :: WantedConstraints -> TcS WantedConstraints
promoteTyVarSet :: TcTyVarSet -> TcM Bool
simplifyAndEmitFlatConstraints :: WantedConstraints -> TcM ()
solveWanteds :: WantedConstraints -> TcS WantedConstraints
solveWantedsAndDrop :: WantedConstraints -> TcS WantedConstraints
approximateWC :: Bool -> WantedConstraints -> Cts

-- | This variant of <a>runTcS</a> will keep solving, even when only
--   Deriveds are left around. It also doesn't return any evidence, as
--   callers won't need it.
runTcSDeriveds :: TcS a -> TcM a
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.InferMode

module GHC.Tc.Solver.Rewrite

-- | See Note [Rewriting]. If (xi, co) &lt;- rewrite mode ev ty, then co ::
--   xi ~r ty where r is the role in <tt>ev</tt>.
rewrite :: CtEvidence -> TcType -> TcS (Xi, TcCoercion)
rewriteKind :: CtLoc -> CtFlavour -> TcType -> TcS (Xi, TcCoercionN)
rewriteArgsNom :: CtEvidence -> TyCon -> [TcType] -> TcS ([Xi], [TcCoercion])

-- | Rewrite a type w.r.t. nominal equality. This is useful to rewrite a
--   type w.r.t. any givens. It does not do type-family reduction. This
--   will never emit new constraints. Call this when the inert set contains
--   only givens.
rewriteType :: CtLoc -> TcType -> TcS TcType
instance GHC.Base.Functor GHC.Tc.Solver.Rewrite.RewriteM
instance GHC.Base.Monad GHC.Tc.Solver.Rewrite.RewriteM
instance GHC.Base.Applicative GHC.Tc.Solver.Rewrite.RewriteM
instance GHC.Driver.Session.HasDynFlags GHC.Tc.Solver.Rewrite.RewriteM


-- | Type definitions for the constraint solver
module GHC.Tc.Solver.Monad
data WorkList
WL :: [Ct] -> [Ct] -> Bag Implication -> WorkList
[wl_eqs] :: WorkList -> [Ct]
[wl_rest] :: WorkList -> [Ct]
[wl_implics] :: WorkList -> Bag Implication
isEmptyWorkList :: WorkList -> Bool
emptyWorkList :: WorkList
extendWorkListNonEq :: Ct -> WorkList -> WorkList
extendWorkListCt :: Ct -> WorkList -> WorkList
extendWorkListCts :: [Ct] -> WorkList -> WorkList
extendWorkListEq :: Ct -> WorkList -> WorkList
appendWorkList :: WorkList -> WorkList -> WorkList
selectNextWorkItem :: TcS (Maybe Ct)
workListSize :: WorkList -> Int
getWorkList :: TcS WorkList
updWorkListTcS :: (WorkList -> WorkList) -> TcS ()
pushLevelNoWorkList :: SDoc -> TcS a -> TcS (TcLevel, a)
data TcS a
runTcS :: TcS a -> TcM (a, EvBindMap)

-- | This variant of <a>runTcS</a> will keep solving, even when only
--   Deriveds are left around. It also doesn't return any evidence, as
--   callers won't need it.
runTcSDeriveds :: TcS a -> TcM a
runTcSWithEvBinds :: EvBindsVar -> TcS a -> TcM a

-- | A variant of <a>runTcS</a> that takes and returns an <a>InertSet</a>
--   for later resumption of the <a>TcS</a> session.
runTcSInerts :: InertSet -> TcS a -> TcM (a, InertSet)
failTcS :: SDoc -> TcS a
warnTcS :: WarningFlag -> SDoc -> TcS ()
addErrTcS :: SDoc -> TcS ()
wrapTcS :: TcM a -> TcS a

-- | This can deal only with equality constraints.
runTcSEqualities :: TcS a -> TcM a
nestTcS :: TcS a -> TcS a
nestImplicTcS :: EvBindsVar -> TcLevel -> TcS a -> TcS a
setEvBindsTcS :: EvBindsVar -> TcS a -> TcS a
emitImplicationTcS :: TcLevel -> SkolemInfo -> [TcTyVar] -> [EvVar] -> Cts -> TcS TcEvBinds
emitTvImplicationTcS :: TcLevel -> SkolemInfo -> [TcTyVar] -> Cts -> TcS ()
runTcPluginTcS :: TcPluginM a -> TcS a
addUsedGRE :: Bool -> GlobalRdrElt -> TcS ()
addUsedGREs :: [GlobalRdrElt] -> TcS ()
keepAlive :: Name -> TcS ()
matchGlobalInst :: DynFlags -> Bool -> Class -> [Type] -> TcS ClsInstResult
data ClsInstResult
NoInstance :: ClsInstResult
OneInst :: [TcPredType] -> ([EvExpr] -> EvTerm) -> InstanceWhat -> ClsInstResult
[cir_new_theta] :: ClsInstResult -> [TcPredType]
[cir_mk_ev] :: ClsInstResult -> [EvExpr] -> EvTerm
[cir_what] :: ClsInstResult -> InstanceWhat
NotSure :: ClsInstResult
data QCInst
QCI :: CtEvidence -> [TcTyVar] -> TcPredType -> Bool -> QCInst
[qci_ev] :: QCInst -> CtEvidence
[qci_tvs] :: QCInst -> [TcTyVar]
[qci_pred] :: QCInst -> TcPredType
[qci_pend_sc] :: QCInst -> Bool
panicTcS :: SDoc -> TcS a
traceTcS :: String -> SDoc -> TcS ()
traceFireTcS :: CtEvidence -> SDoc -> TcS ()
bumpStepCountTcS :: TcS ()
csTraceTcS :: SDoc -> TcS ()
wrapErrTcS :: TcM a -> TcS a
wrapWarnTcS :: TcM a -> TcS a
resetUnificationFlag :: TcS Bool
setUnificationFlag :: TcLevel -> TcS ()
data MaybeNew
Fresh :: CtEvidence -> MaybeNew
Cached :: EvExpr -> MaybeNew
freshGoals :: [MaybeNew] -> [CtEvidence]
isFresh :: MaybeNew -> Bool
getEvExpr :: MaybeNew -> EvExpr
newTcEvBinds :: TcS EvBindsVar
newNoTcEvBinds :: TcS EvBindsVar

-- | Make a new equality CtEvidence
newWantedEq :: CtLoc -> Role -> TcType -> TcType -> TcS (CtEvidence, Coercion)
newWantedEq_SI :: ShadowInfo -> CtLoc -> Role -> TcType -> TcType -> TcS (CtEvidence, Coercion)

-- | Emit a new Wanted equality into the work-list
emitNewWantedEq :: CtLoc -> Role -> TcType -> TcType -> TcS Coercion
newWanted :: CtLoc -> PredType -> TcS MaybeNew
newWanted_SI :: ShadowInfo -> CtLoc -> PredType -> TcS MaybeNew
newWantedEvVar :: CtLoc -> TcPredType -> TcS MaybeNew
newWantedNC :: CtLoc -> PredType -> TcS CtEvidence
newWantedEvVarNC :: CtLoc -> TcPredType -> TcS CtEvidence
newDerivedNC :: CtLoc -> TcPredType -> TcS CtEvidence

-- | Make a new <a>Id</a> of the given type, bound (in the monad's EvBinds)
--   to the given term
newBoundEvVarId :: TcPredType -> EvTerm -> TcS EvVar
unifyTyVar :: TcTyVar -> TcType -> TcS ()
reportUnifications :: TcS a -> TcS (Int, a)
touchabilityTest :: CtFlavour -> TcTyVar -> TcType -> TcS TouchabilityTestResult
data TouchabilityTestResult
TouchableSameLevel :: TouchabilityTestResult
TouchableOuterLevel :: [TcTyVar] -> TcLevel -> TouchabilityTestResult
Untouchable :: TouchabilityTestResult
setEvBind :: EvBind -> TcS ()

-- | Equalities only
setWantedEq :: TcEvDest -> Coercion -> TcS ()

-- | Good for both equalities and non-equalities
setWantedEvTerm :: TcEvDest -> EvTerm -> TcS ()
setEvBindIfWanted :: CtEvidence -> EvTerm -> TcS ()
newEvVar :: TcPredType -> TcS EvVar
newGivenEvVar :: CtLoc -> (TcPredType, EvTerm) -> TcS CtEvidence
newGivenEvVars :: CtLoc -> [(TcPredType, EvTerm)] -> TcS [CtEvidence]
emitNewDeriveds :: CtLoc -> [TcPredType] -> TcS ()
emitNewDerivedEq :: CtLoc -> Role -> TcType -> TcType -> TcS ()

-- | Checks if the depth of the given location is too much. Fails if it's
--   too big, with an appropriate error message.
checkReductionDepth :: CtLoc -> TcType -> TcS ()
getSolvedDicts :: TcS (DictMap CtEvidence)
setSolvedDicts :: DictMap CtEvidence -> TcS ()
getInstEnvs :: TcS InstEnvs
getFamInstEnvs :: TcS (FamInstEnv, FamInstEnv)
getTopEnv :: TcS HscEnv
getGblEnv :: TcS TcGblEnv
getLclEnv :: TcS TcLclEnv
getTcEvBindsVar :: TcS EvBindsVar
getTcLevel :: TcS TcLevel
getTcEvTyCoVars :: EvBindsVar -> TcS TyCoVarSet
getTcEvBindsMap :: EvBindsVar -> TcS EvBindMap
setTcEvBindsMap :: EvBindsVar -> EvBindMap -> TcS ()
tcLookupClass :: Name -> TcS Class
tcLookupId :: Name -> TcS Id
data InertSet
IS :: InertCans -> CycleBreakerVarStack -> FunEqMap (TcCoercion, TcType) -> DictMap CtEvidence -> InertSet
[inert_cans] :: InertSet -> InertCans
[inert_cycle_breakers] :: InertSet -> CycleBreakerVarStack
[inert_famapp_cache] :: InertSet -> FunEqMap (TcCoercion, TcType)
[inert_solved_dicts] :: InertSet -> DictMap CtEvidence
data InertCans
IC :: InertEqs -> FunEqMap EqualCtList -> DictMap Ct -> [QCInst] -> DictMap Ct -> Cts -> Cts -> TcLevel -> Bool -> InertCans
[inert_eqs] :: InertCans -> InertEqs
[inert_funeqs] :: InertCans -> FunEqMap EqualCtList
[inert_dicts] :: InertCans -> DictMap Ct
[inert_insts] :: InertCans -> [QCInst]

-- | See Note [Safe Haskell Overlapping Instances Implementation] in
--   <a>GHC.Tc.Solver</a>
[inert_safehask] :: InertCans -> DictMap Ct
[inert_irreds] :: InertCans -> Cts
[inert_blocked] :: InertCans -> Cts
[inert_given_eq_lvl] :: InertCans -> TcLevel
[inert_given_eqs] :: InertCans -> Bool
emptyInert :: InertSet
updInertTcS :: (InertSet -> InertSet) -> TcS ()
updInertCans :: (InertCans -> InertCans) -> TcS ()
updInertDicts :: (DictMap Ct -> DictMap Ct) -> TcS ()
updInertIrreds :: (Cts -> Cts) -> TcS ()
getHasGivenEqs :: TcLevel -> TcS (HasGivenEqs, Cts)
setInertCans :: InertCans -> TcS ()
getInertEqs :: TcS (DTyVarEnv EqualCtList)
getInertCans :: TcS InertCans
getInertGivens :: TcS [Ct]
getInertInsols :: TcS Cts
getInnermostGivenEqLevel :: TcS TcLevel
getTcSInerts :: TcS InertSet
setTcSInerts :: InertSet -> TcS ()

-- | Returns Given constraints that might, potentially, match the given
--   pred. This is used when checking to see if a Given might overlap with
--   an instance. See Note [Instance and Given overlap] in
--   <a>GHC.Tc.Solver.Interact</a>
matchableGivens :: CtLoc -> PredType -> InertSet -> Cts
prohibitedSuperClassSolve :: CtLoc -> CtLoc -> Bool
mightEqualLater :: InertSet -> TcPredType -> CtLoc -> TcPredType -> CtLoc -> Bool
getUnsolvedInerts :: TcS (Bag Implication, Cts)

-- | Remove inert constraints from the <a>InertCans</a>, for use when a
--   typechecker plugin wishes to discard a given.
removeInertCts :: [Ct] -> InertCans -> InertCans
getPendingGivenScs :: TcS [Ct]
addInertCan :: Ct -> TcS ()
insertFunEq :: FunEqMap a -> TyCon -> [Type] -> a -> FunEqMap a
addInertForAll :: QCInst -> TcS ()
emitWorkNC :: [CtEvidence] -> TcS ()
emitWork :: [Ct] -> TcS ()
isImprovable :: CtEvidence -> Bool
kickOutAfterUnification :: TcTyVar -> TcS Int
addInertSafehask :: InertCans -> Ct -> InertCans
insertSafeOverlapFailureTcS :: InstanceWhat -> Ct -> TcS ()
updInertSafehask :: (DictMap Ct -> DictMap Ct) -> TcS ()
getSafeOverlapFailures :: TcS Cts
type DictMap a = TcAppMap a
emptyDictMap :: DictMap a

-- | Look up a dictionary inert.
lookupInertDict :: InertCans -> CtLoc -> Class -> [Type] -> Maybe Ct
findDictsByClass :: DictMap a -> Class -> Bag a
addDict :: DictMap a -> Class -> [Type] -> a -> DictMap a
addDictsByClass :: DictMap Ct -> Class -> Bag Ct -> DictMap Ct
delDict :: DictMap a -> Class -> [Type] -> DictMap a
foldDicts :: (a -> b -> b) -> DictMap a -> b -> b
filterDicts :: (Ct -> Bool) -> DictMap Ct -> DictMap Ct
findDict :: DictMap a -> CtLoc -> Class -> [Type] -> Maybe a
newtype EqualCtList
EqualCtList :: NonEmpty Ct -> EqualCtList
findTyEqs :: InertCans -> TyVar -> [Ct]
foldTyEqs :: (Ct -> b -> b) -> InertEqs -> b -> b
findEq :: InertCans -> CanEqLHS -> [Ct]
addSolvedDict :: InstanceWhat -> CtEvidence -> Class -> [Type] -> TcS ()

-- | Look up a solved inert.
lookupSolvedDict :: InertSet -> CtLoc -> Class -> [Type] -> Maybe CtEvidence
foldIrreds :: (Ct -> b -> b) -> Cts -> b -> b

-- | Looks up a family application in the inerts; returned coercion is
--   oriented input ~ output
lookupFamAppInert :: TyCon -> [Type] -> TcS (Maybe (TcCoercion, TcType, CtFlavourRole))
lookupFamAppCache :: TyCon -> [Type] -> TcS (Maybe (TcCoercion, TcType))
extendFamAppCache :: TyCon -> [Type] -> (TcCoercion, TcType) -> TcS ()
pprKicked :: Int -> SDoc
findFunEq :: FunEqMap a -> TyCon -> [Type] -> Maybe a
findFunEqsByTyCon :: FunEqMap a -> TyCon -> [a]
instDFunType :: DFunId -> [DFunInstType] -> TcS ([TcType], TcThetaType)
newFlexiTcSTy :: Kind -> TcS TcType
instFlexi :: [TKVar] -> TcS TCvSubst
instFlexiX :: TCvSubst -> [TKVar] -> TcS TCvSubst
cloneMetaTyVar :: TcTyVar -> TcS TcTyVar
tcInstSkolTyVarsX :: TCvSubst -> [TyVar] -> TcS (TCvSubst, [TcTyVar])
data TcLevel
isFilledMetaTyVar_maybe :: TcTyVar -> TcS (Maybe Type)
isFilledMetaTyVar :: TcTyVar -> TcS Bool
zonkTyCoVarsAndFV :: TcTyCoVarSet -> TcS TcTyCoVarSet
zonkTcType :: TcType -> TcS TcType
zonkTcTypes :: [TcType] -> TcS [TcType]
zonkTcTyVar :: TcTyVar -> TcS TcType
zonkCo :: Coercion -> TcS Coercion
zonkTyCoVarsAndFVList :: [TcTyCoVar] -> TcS [TcTyCoVar]
zonkSimples :: Cts -> TcS Cts
zonkWC :: WantedConstraints -> TcS WantedConstraints
zonkTyCoVarKind :: TcTyCoVar -> TcS TcTyCoVar
newTcRef :: a -> TcS (TcRef a)
readTcRef :: TcRef a -> TcS a
writeTcRef :: TcRef a -> a -> TcS ()
updTcRef :: TcRef a -> (a -> a) -> TcS ()
getDefaultInfo :: TcS ([Type], (Bool, Bool))
getDynFlags :: HasDynFlags m => m DynFlags
getGlobalRdrEnvTcS :: TcS GlobalRdrEnv
matchFam :: TyCon -> [Type] -> TcS (Maybe (CoercionN, TcType))
matchFamTcM :: TyCon -> [Type] -> TcM (Maybe (CoercionN, TcType))
checkWellStagedDFun :: CtLoc -> InstanceWhat -> PredType -> TcS ()
pprEq :: TcType -> TcType -> SDoc

-- | Conditionally replace all type family applications in the RHS with
--   fresh variables, emitting givens that relate the type family
--   application to the variable. See Note [Type equality cycles] in
--   GHC.Tc.Solver.Canonical. This only works under conditions as described
--   in the Note; otherwise, returns Nothing.
breakTyEqCycle_maybe :: CtEvidence -> CheckTyEqResult -> CanEqLHS -> TcType -> TcS (Maybe (CoercionN, TcType))
rewriterView :: TcType -> Maybe TcType
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.Monad.EqualCtList
instance GHC.Base.Functor GHC.Tc.Solver.Monad.TcS
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.Monad.TouchabilityTestResult
instance GHC.Base.Applicative GHC.Tc.Solver.Monad.TcS
instance GHC.Base.Monad GHC.Tc.Solver.Monad.TcS
instance Control.Monad.Fail.MonadFail GHC.Tc.Solver.Monad.TcS
instance GHC.Types.Unique.Supply.MonadUnique GHC.Tc.Solver.Monad.TcS
instance GHC.Unit.Module.HasModule GHC.Tc.Solver.Monad.TcS
instance GHC.Types.TyThing.MonadThings GHC.Tc.Solver.Monad.TcS
instance GHC.Driver.Session.HasDynFlags GHC.Tc.Solver.Monad.TcS
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.Monad.InertSet
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.Monad.InertCans
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.Monad.WorkList

module GHC.Tc.Instance.Class
matchGlobalInst :: DynFlags -> Bool -> Class -> [Type] -> TcM ClsInstResult
data ClsInstResult
NoInstance :: ClsInstResult
OneInst :: [TcPredType] -> ([EvExpr] -> EvTerm) -> InstanceWhat -> ClsInstResult
[cir_new_theta] :: ClsInstResult -> [TcPredType]
[cir_mk_ev] :: ClsInstResult -> [EvExpr] -> EvTerm
[cir_what] :: ClsInstResult -> InstanceWhat
NotSure :: ClsInstResult
data InstanceWhat
BuiltinInstance :: InstanceWhat
BuiltinEqInstance :: InstanceWhat
LocalInstance :: InstanceWhat
TopLevInstance :: DFunId -> SafeOverlapping -> InstanceWhat
[iw_dfun_id] :: InstanceWhat -> DFunId
[iw_safe_over] :: InstanceWhat -> SafeOverlapping
safeOverlap :: InstanceWhat -> Bool
instanceReturnsDictCon :: InstanceWhat -> Bool

-- | Extra information about the parent instance declaration, needed when
--   type-checking associated types. The <a>Class</a> is the enclosing
--   class, the [TyVar] are the <i>scoped</i> type variable of the instance
--   decl. The <tt>VarEnv Type</tt> maps class variables to their instance
--   types.
data AssocInstInfo
NotAssociated :: AssocInstInfo
InClsInst :: Class -> [TyVar] -> VarEnv Type -> AssocInstInfo
[ai_class] :: AssocInstInfo -> Class

-- | The <i>scoped</i> tyvars of the instance Why scoped? See bind_me in
--   <a>checkConsistentFamInst</a>
[ai_tyvars] :: AssocInstInfo -> [TyVar]

-- | Maps <i>class</i> tyvars to their instance types See Note [Matching in
--   the consistent-instantiation check]
[ai_inst_env] :: AssocInstInfo -> VarEnv Type
isNotAssociated :: AssocInstInfo -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Tc.Instance.Class.ClsInstResult
instance GHC.Utils.Outputable.Outputable GHC.Tc.Instance.Class.InstanceWhat

module GHC.Tc.Instance.Typeable

-- | Generate the Typeable bindings for a module. This is the only
--   entry-point of this module and is invoked by the typechecker driver in
--   <tt>tcRnSrcDecls</tt>.
--   
--   See Note [Grand plan for Typeable] in <a>GHC.Tc.Instance.Typeable</a>.
mkTypeableBinds :: TcM TcGblEnv

-- | Is a particular <a>TyCon</a> representable by <tt>Typeable</tt>?.
--   These exclude type families and polytypes.
tyConIsTypeable :: TyCon -> Bool
instance GHC.Base.Monad GHC.Tc.Instance.Typeable.KindRepM
instance GHC.Base.Applicative GHC.Tc.Instance.Typeable.KindRepM
instance GHC.Base.Functor GHC.Tc.Instance.Typeable.KindRepM

module GHC.Rename.Env
newTopSrcBinder :: LocatedN RdrName -> RnM Name
lookupLocatedTopBndrRn :: Located RdrName -> RnM (Located Name)
lookupLocatedTopBndrRnN :: LocatedN RdrName -> RnM (LocatedN Name)
lookupTopBndrRn :: RdrName -> RnM Name
lookupLocatedOccRn :: GenLocated (SrcSpanAnn' ann) RdrName -> TcRn (GenLocated (SrcSpanAnn' ann) Name)
lookupOccRn :: RdrName -> RnM Name
lookupOccRn_maybe :: RdrName -> RnM (Maybe Name)
lookupLocalOccRn_maybe :: RdrName -> RnM (Maybe Name)
lookupInfoOccRn :: RdrName -> RnM [Name]
lookupLocalOccThLvl_maybe :: Name -> RnM (Maybe (TopLevelFlag, ThLevel))
lookupLocalOccRn :: RdrName -> RnM Name
lookupTypeOccRn :: RdrName -> RnM Name
lookupGlobalOccRn :: RdrName -> RnM Name
lookupGlobalOccRn_maybe :: RdrName -> RnM (Maybe Name)

-- | Result of looking up an occurrence that might be an ambiguous field.
data AmbiguousResult

-- | Occurrence picked out a single name, which may or may not belong to a
--   field (or might be unbound, if an error has been reported already, per
--   Note [ Unbound vs Ambiguous Names ]).
UnambiguousGre :: GreName -> AmbiguousResult

-- | Occurrence picked out two or more fields, and no non-fields. For now
--   this is allowed by DuplicateRecordFields in certain circumstances, as
--   the type-checker may be able to disambiguate later.
AmbiguousFields :: AmbiguousResult

-- | Look up a <a>RdrName</a> used as a variable in an expression.
--   
--   This may be a local variable, global variable, or one or more record
--   selector functions. It will not return record fields created with the
--   <tt>NoFieldSelectors</tt> extension (see Note [NoFieldSelectors]). The
--   <a>DuplicateRecordFields</a> argument controls whether ambiguous
--   fields will be allowed (resulting in an <a>AmbiguousFields</a> result
--   being returned).
--   
--   If the name is not in scope at the term level, but its promoted
--   equivalent is in scope at the type level, the lookup will succeed (so
--   that the type-checker can report a more informative error later). See
--   Note [Promotion].
lookupExprOccRn :: DuplicateRecordFields -> RdrName -> RnM (Maybe AmbiguousResult)

-- | Look up an occurrence of a field in record construction or pattern
--   matching (but not update). When the -XDisambiguateRecordFields flag is
--   on, take account of the data constructor name to disambiguate which
--   field to use.
--   
--   See Note [DisambiguateRecordFields] and Note [NoFieldSelectors].
lookupRecFieldOcc :: Maybe Name -> RdrName -> RnM Name

-- | Look up an occurrence of a field in a record update, returning the
--   selector name.
--   
--   Unlike construction and pattern matching with
--   <tt>-XDisambiguateRecordFields</tt> (see <a>lookupRecFieldOcc</a>),
--   there is no data constructor to help disambiguate, so this may be
--   ambiguous if the field is in scope multiple times. However we ignore
--   non-fields in scope with the same name if
--   <tt>-XDisambiguateRecordFields</tt> is on (see Note
--   [DisambiguateRecordFields for updates]).
--   
--   Here a field is in scope even if <tt>NoFieldSelectors</tt> was enabled
--   at its definition site (see Note [NoFieldSelectors]).
lookupRecFieldOcc_update :: DuplicateRecordFields -> RdrName -> RnM AmbiguousResult
data ChildLookupResult
NameNotFound :: ChildLookupResult
IncorrectParent :: Name -> GreName -> [Name] -> ChildLookupResult
FoundChild :: Parent -> GreName -> ChildLookupResult

-- | Used in export lists to lookup the children.
lookupSubBndrOcc_helper :: Bool -> Bool -> Name -> RdrName -> RnM ChildLookupResult

-- | Specialised version of msum for RnM ChildLookupResult
combineChildLookupResult :: [RnM ChildLookupResult] -> RnM ChildLookupResult
data HsSigCtxt
TopSigCtxt :: NameSet -> HsSigCtxt
LocalBindCtxt :: NameSet -> HsSigCtxt
ClsDeclCtxt :: Name -> HsSigCtxt
InstDeclCtxt :: NameSet -> HsSigCtxt
HsBootCtxt :: NameSet -> HsSigCtxt
RoleAnnotCtxt :: NameSet -> HsSigCtxt
lookupLocalTcNames :: HsSigCtxt -> SDoc -> RdrName -> RnM [(RdrName, Name)]
lookupSigOccRn :: HsSigCtxt -> Sig GhcPs -> LocatedA RdrName -> RnM (LocatedA Name)
lookupSigOccRnN :: HsSigCtxt -> Sig GhcPs -> LocatedN RdrName -> RnM (LocatedN Name)

-- | Lookup a name in relation to the names in a <a>HsSigCtxt</a>
lookupSigCtxtOccRn :: HsSigCtxt -> SDoc -> LocatedA RdrName -> RnM (LocatedA Name)

-- | Lookup a name in relation to the names in a <a>HsSigCtxt</a>
lookupSigCtxtOccRnN :: HsSigCtxt -> SDoc -> LocatedN RdrName -> RnM (LocatedN Name)
lookupInstDeclBndr :: Name -> SDoc -> RdrName -> RnM Name
lookupFamInstName :: Maybe Name -> LocatedN RdrName -> RnM (LocatedN Name)
lookupConstructorFields :: Name -> RnM [FieldLabel]
lookupGreAvailRn :: RdrName -> RnM (Name, AvailInfo)
lookupSyntax :: Name -> RnM (SyntaxExpr GhcRn, FreeVars)
lookupSyntaxExpr :: Name -> RnM (HsExpr GhcRn, FreeVars)
lookupSyntaxNames :: [Name] -> RnM ([HsExpr GhcRn], FreeVars)
lookupSyntaxName :: Name -> RnM (Name, FreeVars)
lookupIfThenElse :: RnM (Maybe Name)
lookupQualifiedDoExpr :: HsStmtContext p -> Name -> RnM (HsExpr GhcRn, FreeVars)
lookupQualifiedDo :: HsStmtContext p -> Name -> RnM (SyntaxExpr GhcRn, FreeVars)
lookupQualifiedDoName :: HsStmtContext p -> Name -> RnM (Name, FreeVars)
lookupNameWithQualifier :: Name -> ModuleName -> RnM (Name, FreeVars)
addUsedGRE :: Bool -> GlobalRdrElt -> RnM ()
addUsedGREs :: [GlobalRdrElt] -> RnM ()
addUsedDataCons :: GlobalRdrEnv -> TyCon -> RnM ()
dataTcOccs :: RdrName -> [RdrName]
instance GHC.Classes.Eq GHC.Rename.Env.FieldsOrSelectors
instance GHC.Utils.Outputable.Outputable GHC.Rename.Env.HsSigCtxt
instance GHC.Utils.Outputable.Outputable GHC.Rename.Env.ChildLookupResult
instance GHC.Utils.Outputable.Outputable GHC.Rename.Env.DisambigInfo
instance GHC.Base.Semigroup GHC.Rename.Env.DisambigInfo
instance GHC.Base.Monoid GHC.Rename.Env.DisambigInfo

module GHC.Rename.Utils
checkDupRdrNames :: [LocatedN RdrName] -> RnM ()
checkDupRdrNamesN :: [LocatedN RdrName] -> RnM ()
checkShadowedRdrNames :: [LocatedN RdrName] -> RnM ()
checkDupNames :: [Name] -> RnM ()
checkDupAndShadowedNames :: (GlobalRdrEnv, LocalRdrEnv) -> [Name] -> RnM ()
dupNamesErr :: Outputable n => (n -> SrcSpan) -> NonEmpty n -> RnM ()

-- | Ensure that a boxed or unboxed tuple has arity no larger than
--   <a>mAX_TUPLE_SIZE</a>.
checkTupSize :: Int -> TcM ()

-- | Ensure that a constraint tuple has arity no larger than
--   <a>mAX_CTUPLE_SIZE</a>.
checkCTupSize :: Int -> TcM ()
addFvRn :: FreeVars -> RnM (thing, FreeVars) -> RnM (thing, FreeVars)
mapFvRn :: (a -> RnM (b, FreeVars)) -> [a] -> RnM ([b], FreeVars)
mapMaybeFvRn :: (a -> RnM (b, FreeVars)) -> Maybe a -> RnM (Maybe b, FreeVars)
warnUnusedMatches :: [Name] -> FreeVars -> RnM ()
warnUnusedTypePatterns :: [Name] -> FreeVars -> RnM ()
warnUnusedTopBinds :: [GlobalRdrElt] -> RnM ()
warnUnusedLocalBinds :: [Name] -> FreeVars -> RnM ()

-- | Checks to see if we need to warn for -Wunused-record-wildcards or
--   -Wredundant-record-wildcards
checkUnusedRecordWildcard :: SrcSpan -> FreeVars -> Maybe [Name] -> RnM ()

-- | Make a map from selector names to field labels and parent tycon names,
--   to be used when reporting unused record fields.
mkFieldEnv :: GlobalRdrEnv -> NameEnv (FieldLabelString, Parent)
unknownSubordinateErr :: SDoc -> RdrName -> SDoc
badQualBndrErr :: RdrName -> SDoc
typeAppErr :: String -> LHsType GhcPs -> SDoc
data HsDocContext
TypeSigCtx :: SDoc -> HsDocContext
StandaloneKindSigCtx :: SDoc -> HsDocContext
PatCtx :: HsDocContext
SpecInstSigCtx :: HsDocContext
DefaultDeclCtx :: HsDocContext
ForeignDeclCtx :: LocatedN RdrName -> HsDocContext
DerivDeclCtx :: HsDocContext
RuleCtx :: FastString -> HsDocContext
TyDataCtx :: LocatedN RdrName -> HsDocContext
TySynCtx :: LocatedN RdrName -> HsDocContext
TyFamilyCtx :: LocatedN RdrName -> HsDocContext
FamPatCtx :: LocatedN RdrName -> HsDocContext
ConDeclCtx :: [LocatedN Name] -> HsDocContext
ClassDeclCtx :: LocatedN RdrName -> HsDocContext
ExprWithTySigCtx :: HsDocContext
TypBrCtx :: HsDocContext
HsTypeCtx :: HsDocContext
HsTypePatCtx :: HsDocContext
GHCiCtx :: HsDocContext
SpliceTypeCtx :: LHsType GhcPs -> HsDocContext
ClassInstanceCtx :: HsDocContext
GenericCtx :: SDoc -> HsDocContext
pprHsDocContext :: HsDocContext -> SDoc
inHsDocContext :: HsDocContext -> SDoc
withHsDocContext :: HsDocContext -> SDoc -> SDoc
newLocalBndrRn :: LocatedN RdrName -> RnM Name
newLocalBndrsRn :: [LocatedN RdrName] -> RnM [Name]
bindLocalNames :: [Name] -> RnM a -> RnM a
bindLocalNamesFV :: [Name] -> RnM (a, FreeVars) -> RnM (a, FreeVars)
addNameClashErrRn :: RdrName -> NonEmpty GlobalRdrElt -> RnM ()

-- | Throw an error message if a user attempts to quantify an inferred type
--   variable in a place where specificity cannot be observed. For example,
--   <tt>forall {a}. [a] -&gt; [a]</tt> would be rejected to the inferred
--   type variable <tt>{a}</tt>, but <tt>forall a. [a] -&gt; [a]</tt> would
--   be accepted. See <tt>Note [Unobservably inferred type variables]</tt>.
checkInferredVars :: HsDocContext -> Maybe SDoc -> LHsSigType GhcPs -> RnM ()

-- | Examines a non-outermost type for <tt>forall</tt>s or contexts, which
--   are assumed to be nested. For example, in the following declaration:
--   
--   <pre>
--   instance forall a. forall b. C (Either a b)
--   </pre>
--   
--   The outermost <tt>forall a</tt> is fine, but the nested <tt>forall
--   b</tt> is not. We invoke <a>noNestedForallsContextsErr</a> on the type
--   <tt>forall b. C (Either a b)</tt> to catch the nested <tt>forall</tt>
--   and create a suitable error message. <a>noNestedForallsContextsErr</a>
--   returns <tt><a>Just</a> err_msg</tt> if such a <tt>forall</tt> or
--   context is found, and returns <tt>Nothing</tt> otherwise.
--   
--   This is currently used in the following places:
--   
--   <ul>
--   <li>In GADT constructor types (in <tt>rnConDecl</tt>). See <tt>Note
--   [GADT abstract syntax] (Wrinkle: No nested foralls or contexts)</tt>
--   in <a>GHC.Hs.Type</a>.</li>
--   <li>In instance declaration types (in <tt>rnClsIntDecl</tt> and
--   <tt>rnSrcDerivDecl</tt> in <a>GHC.Rename.Module</a> and
--   <tt>renameSig</tt> in <a>GHC.Rename.Bind</a>). See <tt>Note [No nested
--   foralls or contexts in instance types]</tt> in
--   <a>GHC.Hs.Type</a>.</li>
--   </ul>
noNestedForallsContextsErr :: SDoc -> LHsType GhcRn -> Maybe (SrcSpan, SDoc)

-- | A common way to invoke <a>noNestedForallsContextsErr</a>.
addNoNestedForallsContextsErr :: HsDocContext -> SDoc -> LHsType GhcRn -> RnM ()

module GHC.Rename.Unbound
mkUnboundName :: OccName -> Name
mkUnboundNameRdr :: RdrName -> Name
isUnboundName :: Name -> Bool
reportUnboundName :: RdrName -> RnM Name

-- | Called from the typechecker (<a>GHC.Tc.Errors</a>) when we find an
--   unbound variable
unknownNameSuggestions :: DynFlags -> HomePackageTable -> Module -> GlobalRdrEnv -> LocalRdrEnv -> ImportAvails -> RdrName -> SDoc
data WhereLooking
WL_Any :: WhereLooking
WL_Global :: WhereLooking
WL_LocalTop :: WhereLooking
WL_LocalOnly :: WhereLooking
unboundName :: WhereLooking -> RdrName -> RnM Name
unboundNameX :: WhereLooking -> RdrName -> SDoc -> RnM Name
notInScopeErr :: RdrName -> SDoc
exactNameErr :: Name -> SDoc

module GHC.Tc.Errors

-- | Report unsolved goals as errors or warnings. We may also turn some
--   into deferred run-time errors if `-fdefer-type-errors` is on.
reportUnsolved :: WantedConstraints -> TcM (Bag EvBind)

-- | Report *all* unsolved goals as errors, even if -fdefer-type-errors is
--   on However, do not make any evidence bindings, because we don't have
--   any convenient place to put them. NB: Type-level holes are OK, because
--   there are no bindings. See Note [Deferring coercion errors to runtime]
--   Used by solveEqualities for kind equalities (see Note [Fail fast on
--   kind errors] in <a>GHC.Tc.Solver</a>)
reportAllUnsolved :: WantedConstraints -> TcM ()

-- | Report all unsolved goals as warnings (but without deferring any
--   errors to run-time). See Note [Safe Haskell Overlapping Instances
--   Implementation] in <a>GHC.Tc.Solver</a>
warnAllUnsolved :: WantedConstraints -> TcM ()
warnDefaulting :: [Ct] -> Type -> TcM ()
solverDepthErrorTcS :: CtLoc -> TcType -> TcM a
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.ReportErrCtxt
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.HoleChoice
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.TypeErrorChoice
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Report
instance GHC.Base.Semigroup GHC.Tc.Errors.Report
instance GHC.Base.Monoid GHC.Tc.Errors.Report

module GHC.Tc.Errors.Hole
findValidHoleFits :: TidyEnv -> [Implication] -> [Ct] -> Hole -> TcM (TidyEnv, SDoc)

-- | A tcSubsumes which takes into account relevant constraints, to fix
--   trac #14273. This makes sure that when checking whether a type fits
--   the hole, the type has to be subsumed by type of the hole as well as
--   fulfill all constraints on the type of the hole.
tcCheckHoleFit :: TypedHole -> TcSigmaType -> TcSigmaType -> TcM (Bool, HsWrapper)

-- | Takes a list of free variables and restores any Flexi type variables
--   in free_vars after the action is run.
withoutUnification :: FV -> TcM a -> TcM a

-- | Reports whether first type (ty_a) subsumes the second type (ty_b),
--   discarding any errors. Subsumption here means that the ty_b can fit
--   into the ty_a, i.e. `tcSubsumes a b == True` if b is a subtype of a.
tcSubsumes :: TcSigmaType -> TcSigmaType -> TcM Bool

-- | Checks whether a MetaTyVar is flexible or not.
isFlexiTyVar :: TcTyVar -> TcM Bool

-- | tcFilterHoleFits filters the candidates by whether, given the
--   implications and the relevant constraints, they can be made to match
--   the type by running the type checker. Stops after finding limit
--   matches.
tcFilterHoleFits :: Maybe Int -> TypedHole -> (TcType, [TcTyVar]) -> [HoleFitCandidate] -> TcM (Bool, [HoleFit])
getLocalBindings :: TidyEnv -> CtLoc -> TcM [Id]
pprHoleFit :: HoleFitDispConfig -> HoleFit -> SDoc
addHoleFitDocs :: [HoleFit] -> TcM [HoleFit]
getHoleFitSortingAlg :: TcM HoleFitSortingAlg
getHoleFitDispConfig :: TcM HoleFitDispConfig
data HoleFitDispConfig
HFDC :: Bool -> Bool -> Bool -> Bool -> Bool -> HoleFitDispConfig
[showWrap] :: HoleFitDispConfig -> Bool
[showWrapVars] :: HoleFitDispConfig -> Bool
[showType] :: HoleFitDispConfig -> Bool
[showProv] :: HoleFitDispConfig -> Bool
[showMatches] :: HoleFitDispConfig -> Bool
data HoleFitSortingAlg
HFSNoSorting :: HoleFitSortingAlg
HFSBySize :: HoleFitSortingAlg
HFSBySubsumption :: HoleFitSortingAlg
relevantCts :: Type -> [Ct] -> [Ct]
zonkSubs :: TidyEnv -> [HoleFit] -> TcM (TidyEnv, [HoleFit])
sortHoleFitsByGraph :: [HoleFit] -> TcM [HoleFit]

-- | Sort by size uses as a measure for relevance the sizes of the
--   different types needed to instantiate the fit to the type of the hole.
--   This is much quicker than sorting by subsumption, and gives reasonable
--   results in most cases.
sortHoleFitsBySize :: [HoleFit] -> TcM [HoleFit]

-- | A HoleFitPlugin is a pair of candidate and fit plugins.
data HoleFitPlugin
HoleFitPlugin :: CandPlugin -> FitPlugin -> HoleFitPlugin
[candPlugin] :: HoleFitPlugin -> CandPlugin
[fitPlugin] :: HoleFitPlugin -> FitPlugin

-- | HoleFitPluginR adds a TcRef to hole fit plugins so that plugins can
--   track internal state. Note the existential quantification, ensuring
--   that the state cannot be modified from outside the plugin.
data HoleFitPluginR
HoleFitPluginR :: TcM (TcRef s) -> (TcRef s -> HoleFitPlugin) -> (TcRef s -> TcM ()) -> HoleFitPluginR

-- | Initializes the TcRef to be passed to the plugin
[hfPluginInit] :: HoleFitPluginR -> TcM (TcRef s)

-- | The function defining the plugin itself
[hfPluginRun] :: HoleFitPluginR -> TcRef s -> HoleFitPlugin

-- | Cleanup of state, guaranteed to be called even on error
[hfPluginStop] :: HoleFitPluginR -> TcRef s -> TcM ()
instance GHC.Classes.Ord GHC.Tc.Errors.Hole.HoleFitSortingAlg
instance GHC.Classes.Eq GHC.Tc.Errors.Hole.HoleFitSortingAlg

module GHC.Tc.Solver.Interact
solveSimpleGivens :: [Ct] -> TcS ()
solveSimpleWanteds :: Cts -> TcS WantedConstraints
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.Interact.InteractResult

module GHC.Tc.Solver.Canonical
canonicalize :: Ct -> TcS (StopOrContinue Ct)
unifyDerived :: CtLoc -> Role -> Pair TcType -> TcS ()
makeSuperClasses :: [Ct] -> TcS [Ct]
data StopOrContinue a
ContinueWith :: a -> StopOrContinue a
Stop :: CtEvidence -> SDoc -> StopOrContinue a
stopWith :: CtEvidence -> String -> TcS (StopOrContinue a)
continueWith :: a -> TcS (StopOrContinue a)
andWhenContinue :: TcS (StopOrContinue a) -> (a -> TcS (StopOrContinue b)) -> TcS (StopOrContinue b)
infixr 0 `andWhenContinue`
solveCallStack :: CtEvidence -> EvCallStack -> TcS ()
instance GHC.Base.Functor GHC.Tc.Solver.Canonical.StopOrContinue
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Tc.Solver.Canonical.StopOrContinue a)


-- | Typechecking user-specified <tt>MonoTypes</tt>
module GHC.Tc.Gen.HsType
kcClassSigType :: [LocatedN Name] -> LHsSigType GhcRn -> TcM ()
tcClassSigType :: [LocatedN Name] -> LHsSigType GhcRn -> TcM Type
tcHsSigType :: UserTypeCtxt -> LHsSigType GhcRn -> TcM Type
tcHsSigWcType :: UserTypeCtxt -> LHsSigWcType GhcRn -> TcM Type
tcHsPartialSigType :: UserTypeCtxt -> LHsSigWcType GhcRn -> TcM ([(Name, TcTyVar)], Maybe TcType, [(Name, InvisTVBinder)], TcThetaType, TcType)
tcStandaloneKindSig :: LStandaloneKindSig GhcRn -> TcM (Name, Kind)
funsSigCtxt :: [LocatedN Name] -> UserTypeCtxt
addSigCtxt :: Outputable hs_ty => UserTypeCtxt -> LocatedA hs_ty -> TcM a -> TcM a
pprSigCtxt :: Outputable hs_ty => UserTypeCtxt -> LocatedA hs_ty -> SDoc
tcHsClsInstType :: UserTypeCtxt -> LHsSigType GhcRn -> TcM Type
tcHsDeriv :: LHsSigType GhcRn -> TcM ([TyVar], Class, [Type], [Kind])

-- | Typecheck a deriving strategy. For most deriving strategies, this is a
--   no-op, but for the <tt>via</tt> strategy, this requires typechecking
--   the <tt>via</tt> type.
tcDerivStrategy :: Maybe (LDerivStrategy GhcRn) -> TcM (Maybe (LDerivStrategy GhcTc), [TyVar])

-- | Type-check a visible type application
tcHsTypeApp :: LHsWcType GhcRn -> Kind -> TcM Type

-- | UserTypeCtxt describes the origin of the polymorphic type in the
--   places where we need an expression to have that type
data UserTypeCtxt
FunSigCtxt :: Name -> Bool -> UserTypeCtxt
InfSigCtxt :: Name -> UserTypeCtxt
ExprSigCtxt :: UserTypeCtxt
KindSigCtxt :: UserTypeCtxt
StandaloneKindSigCtxt :: Name -> UserTypeCtxt
TypeAppCtxt :: UserTypeCtxt
ConArgCtxt :: Name -> UserTypeCtxt
TySynCtxt :: Name -> UserTypeCtxt
PatSynCtxt :: Name -> UserTypeCtxt
PatSigCtxt :: UserTypeCtxt
RuleSigCtxt :: Name -> UserTypeCtxt
ForSigCtxt :: Name -> UserTypeCtxt
DefaultDeclCtxt :: UserTypeCtxt
InstDeclCtxt :: Bool -> UserTypeCtxt
SpecInstCtxt :: UserTypeCtxt
GenSigCtxt :: UserTypeCtxt
GhciCtxt :: Bool -> UserTypeCtxt
ClassSCCtxt :: Name -> UserTypeCtxt
SigmaCtxt :: UserTypeCtxt
DataTyCtxt :: Name -> UserTypeCtxt
DerivClauseCtxt :: UserTypeCtxt
TyVarBndrKindCtxt :: Name -> UserTypeCtxt
DataKindCtxt :: Name -> UserTypeCtxt
TySynKindCtxt :: Name -> UserTypeCtxt
TyFamResKindCtxt :: Name -> UserTypeCtxt
bindImplicitTKBndrs_Tv :: [Name] -> TcM a -> TcM ([TcTyVar], a)
bindImplicitTKBndrs_Skol :: [Name] -> TcM a -> TcM ([TcTyVar], a)
bindImplicitTKBndrs_Q_Tv :: [Name] -> TcM a -> TcM ([TcTyVar], a)
bindImplicitTKBndrs_Q_Skol :: [Name] -> TcM a -> TcM ([TcTyVar], a)

-- | Skolemise the <a>HsTyVarBndr</a>s in an <a>HsForAllTelescope</a> with
--   the supplied <a>TcTyMode</a>.
bindExplicitTKBndrs_Tv :: OutputableBndrFlag flag 'Renamed => [LHsTyVarBndr flag GhcRn] -> TcM a -> TcM ([VarBndr TyVar flag], a)

-- | Skolemise the <a>HsTyVarBndr</a>s in an <a>HsForAllTelescope</a> with
--   the supplied <a>TcTyMode</a>.
bindExplicitTKBndrs_Skol :: OutputableBndrFlag flag 'Renamed => [LHsTyVarBndr flag GhcRn] -> TcM a -> TcM ([VarBndr TyVar flag], a)
bindExplicitTKBndrs_Q_Tv :: ContextKind -> [LHsTyVarBndr () GhcRn] -> TcM a -> TcM ([TcTyVar], a)
bindExplicitTKBndrs_Q_Skol :: ContextKind -> [LHsTyVarBndr () GhcRn] -> TcM a -> TcM ([TcTyVar], a)
bindOuterFamEqnTKBndrs :: HsOuterFamEqnTyVarBndrs GhcRn -> TcM a -> TcM ([TcTyVar], a)
bindOuterFamEqnTKBndrs_Q_Tv :: HsOuterFamEqnTyVarBndrs GhcRn -> TcM a -> TcM ([TcTyVar], a)
tcOuterTKBndrs :: OutputableBndrFlag flag 'Renamed => SkolemInfo -> HsOuterTyVarBndrs flag GhcRn -> TcM a -> TcM (HsOuterTyVarBndrs flag GhcTc, a)
scopedSortOuter :: HsOuterTyVarBndrs Specificity GhcTc -> TcM [InvisTVBinder]
bindOuterSigTKBndrs_Tv :: HsOuterSigTyVarBndrs GhcRn -> TcM a -> TcM (HsOuterSigTyVarBndrs GhcTc, a)
tcExplicitTKBndrs :: OutputableBndrFlag flag 'Renamed => [LHsTyVarBndr flag GhcRn] -> TcM a -> TcM ([VarBndr TyVar flag], a)
bindNamedWildCardBinders :: [Name] -> ([(Name, TcTyVar)] -> TcM a) -> TcM a

-- | Used for the type variables of a type or class decl in the "kind
--   checking" and "type checking" pass, but not in the initial-kind run.
bindTyClTyVars :: Name -> (TcTyCon -> [TyConBinder] -> Kind -> TcM a) -> TcM a
tcFamTyPats :: TyCon -> HsTyPats GhcRn -> TcM (TcType, TcKind)
etaExpandAlgTyCon :: [TyConBinder] -> Kind -> TcM ([TyConBinder], Kind)
tcbVisibilities :: TyCon -> [Type] -> [TyConBndrVis]
zonkAndScopedSort :: [TcTyVar] -> TcM [TcTyVar]
data InitialKindStrategy
InitialKindCheck :: SAKS_or_CUSK -> InitialKindStrategy
InitialKindInfer :: InitialKindStrategy
data SAKS_or_CUSK
SAKS :: Kind -> SAKS_or_CUSK
CUSK :: SAKS_or_CUSK

-- | Describes the kind expected in a certain context.
data ContextKind

-- | a specific kind
TheKind :: Kind -> ContextKind

-- | any kind will do
AnyKind :: ContextKind

-- | something of the form <tt>TYPE _</tt>
OpenKind :: ContextKind
kcDeclHeader :: InitialKindStrategy -> Name -> TyConFlavour -> LHsQTyVars GhcRn -> TcM ContextKind -> TcM TcTyCon
tcHsLiftedType :: LHsType GhcRn -> TcM TcType
tcHsOpenType :: LHsType GhcRn -> TcM TcType
tcHsLiftedTypeNC :: LHsType GhcRn -> TcM TcType
tcHsOpenTypeNC :: LHsType GhcRn -> TcM TcType
tcInferLHsType :: LHsType GhcRn -> TcM TcType
tcInferLHsTypeKind :: LHsType GhcRn -> TcM (TcType, TcKind)
tcInferLHsTypeUnsaturated :: LHsType GhcRn -> TcM (TcType, TcKind)
tcCheckLHsType :: LHsType GhcRn -> ContextKind -> TcM TcType
tcHsContext :: Maybe (LHsContext GhcRn) -> TcM [PredType]
tcLHsPredType :: LHsType GhcRn -> TcM PredType

-- | <ul>
--   <li>Specialised version of <a>kindGeneralizeSome</a>, but with empty
--   WantedConstraints, so no filtering is needed i.e. kindGeneraliseAll =
--   kindGeneralizeSome emptyWC</li>
--   </ul>
kindGeneralizeAll :: TcType -> TcM [KindVar]

-- | Generalize some of the free variables in the given type. All such
--   variables should be *kind* variables; any type variables should be
--   explicitly quantified (with a <tt>forall</tt>) before now.
--   
--   The WantedConstraints are un-solved kind constraints. Generally
--   they'll be reported as errors later, but meanwhile we refrain from
--   quantifying over any variable free in these unsolved constraints. See
--   Note [Failure in local type signatures].
--   
--   But in all cases, generalize only those variables whose TcLevel is
--   strictly greater than the ambient level. This "strictly greater than"
--   means that you likely need to push the level before creating whatever
--   type gets passed here.
--   
--   Any variable whose level is greater than the ambient level but is not
--   selected to be generalized will be promoted. (See [Promoting
--   unification variables] in <a>GHC.Tc.Solver</a> and Note [Recipe for
--   checking a signature].)
--   
--   The resulting KindVar are the variables to quantify over, in the
--   correct, well-scoped order. They should generally be Inferred, not
--   Specified, but that's really up to the caller of this function.
kindGeneralizeSome :: WantedConstraints -> TcType -> TcM [KindVar]

-- | Specialized version of <a>kindGeneralizeSome</a>, but where no
--   variables can be generalized, but perhaps some may need to be
--   promoted. Use this variant when it is unknowable whether metavariables
--   might later be constrained.
--   
--   To see why this promotion is needed, see Note [Recipe for checking a
--   signature], and especially Note [Promotion in signatures].
kindGeneralizeNone :: TcType -> TcM ()
tcLHsKindSig :: UserTypeCtxt -> LHsKind GhcRn -> TcM Kind

-- | Checks that the return kind in a data declaration's kind signature is
--   permissible. There are three cases:
--   
--   If dealing with a <tt>data</tt>, <tt>newtype</tt>, <tt>data
--   instance</tt>, or <tt>newtype instance</tt> declaration, check that
--   the return kind is <tt>Type</tt>.
--   
--   If the declaration is a <tt>newtype</tt> or <tt>newtype instance</tt>
--   and the <tt>UnliftedNewtypes</tt> extension is enabled, this check is
--   slightly relaxed so that a return kind of the form <tt>TYPE r</tt>
--   (for some <tt>r</tt>) is permitted. See <tt>Note [Implementation of
--   UnliftedNewtypes]</tt> in <a>GHC.Tc.TyCl</a>.
--   
--   If dealing with a <tt>data family</tt> declaration, check that the
--   return kind is either of the form:
--   
--   <ol>
--   <li><tt>TYPE r</tt> (for some <tt>r</tt>), or</li>
--   <li><tt>k</tt> (where <tt>k</tt> is a bare kind variable; see
--   #12369)</li>
--   </ol>
--   
--   See also Note [Datatype return kinds] in <a>GHC.Tc.TyCl</a>
checkDataKindSig :: DataSort -> Kind -> TcM ()

-- | A description of whether something is a
--   
--   <ul>
--   <li><tt>data</tt> or <tt>newtype</tt> (<a>DataDeclSort</a>)</li>
--   <li><tt>data instance</tt> or <tt>newtype instance</tt>
--   (<a>DataInstanceSort</a>)</li>
--   <li><tt>data family</tt> (<a>DataFamilySort</a>)</li>
--   </ul>
--   
--   At present, this data type is only consumed by
--   <a>checkDataKindSig</a>.
data DataSort
DataDeclSort :: NewOrData -> DataSort
DataInstanceSort :: NewOrData -> DataSort
DataFamilySort :: DataSort

-- | Checks that the result kind of a class is exactly <tt>Constraint</tt>,
--   rejecting type synonyms and type families that reduce to
--   <tt>Constraint</tt>. See #16826.
checkClassKindSig :: Kind -> TcM ()
tcMult :: HsArrow GhcRn -> TcM Mult
tcHsPatSigType :: UserTypeCtxt -> HoleMode -> HsPatSigType GhcRn -> ContextKind -> TcM ([(Name, TcTyVar)], [(Name, TcTyVar)], TcType)
data HoleMode
HM_Sig :: HoleMode
HM_FamPat :: HoleMode
HM_VTA :: HoleMode
HM_TyAppPat :: HoleMode

-- | Make an appropriate message for an error in a function argument. Used
--   for both expressions and types.
funAppCtxt :: (Outputable fun, Outputable arg) => fun -> arg -> Int -> SDoc

-- | Add a "In the data declaration for T" or some such.
addTyConFlavCtxt :: Name -> TyConFlavour -> TcM a -> TcM a
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.HsType.SAKS_or_CUSK
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.HsType.TcTyMode
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.HsType.HoleMode

module GHC.Tc.Validity
data Rank

-- | UserTypeCtxt describes the origin of the polymorphic type in the
--   places where we need an expression to have that type
data UserTypeCtxt
FunSigCtxt :: Name -> Bool -> UserTypeCtxt
InfSigCtxt :: Name -> UserTypeCtxt
ExprSigCtxt :: UserTypeCtxt
KindSigCtxt :: UserTypeCtxt
StandaloneKindSigCtxt :: Name -> UserTypeCtxt
TypeAppCtxt :: UserTypeCtxt
ConArgCtxt :: Name -> UserTypeCtxt
TySynCtxt :: Name -> UserTypeCtxt
PatSynCtxt :: Name -> UserTypeCtxt
PatSigCtxt :: UserTypeCtxt
RuleSigCtxt :: Name -> UserTypeCtxt
ForSigCtxt :: Name -> UserTypeCtxt
DefaultDeclCtxt :: UserTypeCtxt
InstDeclCtxt :: Bool -> UserTypeCtxt
SpecInstCtxt :: UserTypeCtxt
GenSigCtxt :: UserTypeCtxt
GhciCtxt :: Bool -> UserTypeCtxt
ClassSCCtxt :: Name -> UserTypeCtxt
SigmaCtxt :: UserTypeCtxt
DataTyCtxt :: Name -> UserTypeCtxt
DerivClauseCtxt :: UserTypeCtxt
TyVarBndrKindCtxt :: Name -> UserTypeCtxt
DataKindCtxt :: Name -> UserTypeCtxt
TySynKindCtxt :: Name -> UserTypeCtxt
TyFamResKindCtxt :: Name -> UserTypeCtxt
checkValidType :: UserTypeCtxt -> Type -> TcM ()
checkValidMonoType :: Type -> TcM ()
checkValidTheta :: UserTypeCtxt -> ThetaType -> TcM ()
checkValidInstance :: UserTypeCtxt -> LHsSigType GhcRn -> Type -> TcM ()
checkValidInstHead :: UserTypeCtxt -> Class -> [Type] -> TcM ()
validDerivPred :: TyVarSet -> PredType -> Bool
checkTySynRhs :: UserTypeCtxt -> TcType -> TcM ()
checkValidCoAxiom :: CoAxiom Branched -> TcM ()
checkValidCoAxBranch :: TyCon -> CoAxBranch -> TcM ()

-- | Do validity checks on a type family equation, including consistency
--   with any enclosing class instance head, termination, and lack of
--   polytypes.
checkValidTyFamEqn :: TyCon -> [Var] -> [Type] -> Type -> TcM ()

-- | Checks that an associated type family default:
--   
--   <ol>
--   <li>Only consists of arguments that are bare type variables, and</li>
--   <li>Has a distinct type variable in each argument.</li>
--   </ol>
--   
--   See <tt>Note [Type-checking default assoc decls]</tt> in
--   <a>GHC.Tc.TyCl</a>.
checkValidAssocTyFamDeflt :: TyCon -> [Type] -> TcM ()
checkConsistentFamInst :: AssocInstInfo -> TyCon -> CoAxBranch -> TcM ()
badATErr :: Name -> Name -> SDoc
arityErr :: Outputable a => SDoc -> a -> Int -> Int -> SDoc
checkTyConTelescope :: TyCon -> TcM ()
allDistinctTyVars :: TyVarSet -> [KindOrType] -> Bool
instance GHC.Classes.Eq GHC.Tc.Validity.TypeOrKindCtxt
instance GHC.Utils.Outputable.Outputable GHC.Tc.Validity.ValidityEnv
instance GHC.Utils.Outputable.Outputable GHC.Tc.Validity.ExpandMode
instance GHC.Utils.Outputable.Outputable GHC.Tc.Validity.TypeOrKindCtxt
instance GHC.Utils.Outputable.Outputable GHC.Tc.Validity.Rank

module GHC.Rename.Splice
rnTopSpliceDecls :: HsSplice GhcPs -> RnM ([LHsDecl GhcPs], FreeVars)
rnSpliceType :: HsSplice GhcPs -> RnM (HsType GhcRn, FreeVars)
rnSpliceExpr :: HsSplice GhcPs -> RnM (HsExpr GhcRn, FreeVars)

-- | Rename a splice pattern. See Note [rnSplicePat]
rnSplicePat :: HsSplice GhcPs -> RnM (Either (Pat GhcPs) (Pat GhcRn), FreeVars)
rnSpliceDecl :: SpliceDecl GhcPs -> RnM (SpliceDecl GhcRn, FreeVars)
rnBracket :: HsExpr GhcPs -> HsBracket GhcPs -> RnM (HsExpr GhcRn, FreeVars)
checkThLocalName :: Name -> RnM ()

-- | outputs splice information for 2 flags which have different output
--   formats: `-ddump-splices` and `-dth-dec-file`
traceSplice :: SpliceInfo -> TcM ()

-- | The splice data to be logged
data SpliceInfo
SpliceInfo :: String -> Maybe (LHsExpr GhcRn) -> Bool -> SDoc -> SpliceInfo
[spliceDescription] :: SpliceInfo -> String
[spliceSource] :: SpliceInfo -> Maybe (LHsExpr GhcRn)
[spliceIsDecl] :: SpliceInfo -> Bool
[spliceGenerated] :: SpliceInfo -> SDoc

module GHC.Rename.Pat
rnPat :: HsMatchContext GhcRn -> LPat GhcPs -> (LPat GhcRn -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
rnPats :: HsMatchContext GhcRn -> [LPat GhcPs] -> ([LPat GhcRn] -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
rnBindPat :: NameMaker -> LPat GhcPs -> RnM (LPat GhcRn, FreeVars)
rnPatAndThen :: NameMaker -> Pat GhcPs -> CpsRn (Pat GhcRn)
data NameMaker
applyNameMaker :: NameMaker -> LocatedN RdrName -> RnM (LocatedN Name)
localRecNameMaker :: MiniFixityEnv -> NameMaker
topRecNameMaker :: MiniFixityEnv -> NameMaker
isTopRecNameMaker :: NameMaker -> Bool
rnHsRecFields :: forall arg. HsRecFieldContext -> (SrcSpan -> RdrName -> arg) -> HsRecFields GhcPs (LocatedA arg) -> RnM ([LHsRecField GhcRn (LocatedA arg)], FreeVars)
data HsRecFieldContext
HsRecFieldCon :: Name -> HsRecFieldContext
HsRecFieldPat :: Name -> HsRecFieldContext
HsRecFieldUpd :: HsRecFieldContext
rnHsRecUpdFields :: [LHsRecUpdField GhcPs] -> RnM ([LHsRecUpdField GhcRn], FreeVars)
data CpsRn b
liftCps :: RnM a -> CpsRn a
liftCpsWithCont :: (forall r. (b -> RnM (r, FreeVars)) -> RnM (r, FreeVars)) -> CpsRn b
rnLit :: HsLit p -> RnM ()
rnOverLit :: HsOverLit t -> RnM ((HsOverLit GhcRn, Maybe (HsExpr GhcRn)), FreeVars)
patSigErr :: Outputable a => a -> SDoc
instance GHC.Base.Functor GHC.Rename.Pat.CpsRn
instance GHC.Base.Applicative GHC.Rename.Pat.CpsRn
instance GHC.Base.Monad GHC.Rename.Pat.CpsRn

module GHC.Rename.HsType
rnHsType :: HsDocContext -> HsType GhcPs -> RnM (HsType GhcRn, FreeVars)
rnLHsType :: HsDocContext -> LHsType GhcPs -> RnM (LHsType GhcRn, FreeVars)
rnLHsTypes :: HsDocContext -> [LHsType GhcPs] -> RnM ([LHsType GhcRn], FreeVars)
rnContext :: HsDocContext -> Maybe (LHsContext GhcPs) -> RnM (Maybe (LHsContext GhcRn), FreeVars)
rnHsKind :: HsDocContext -> HsKind GhcPs -> RnM (HsKind GhcRn, FreeVars)
rnLHsKind :: HsDocContext -> LHsKind GhcPs -> RnM (LHsKind GhcRn, FreeVars)
rnLHsTypeArgs :: HsDocContext -> [LHsTypeArg GhcPs] -> RnM ([LHsTypeArg GhcRn], FreeVars)
rnHsSigType :: HsDocContext -> TypeOrKind -> LHsSigType GhcPs -> RnM (LHsSigType GhcRn, FreeVars)
rnHsWcType :: HsDocContext -> LHsWcType GhcPs -> RnM (LHsWcType GhcRn, FreeVars)
rnHsPatSigTypeBindingVars :: HsDocContext -> HsPatSigType GhcPs -> (HsPatSigType GhcRn -> RnM (r, FreeVars)) -> RnM (r, FreeVars)
data HsPatSigTypeScoping

-- | Always bind any free tyvars of the given type, regardless of whether
--   we have a forall at the top.
--   
--   For pattern type sigs, we <i>do</i> want to bring those type variables
--   into scope, even if there's a forall at the top which usually stops
--   that happening, e.g:
--   
--   <pre>
--   \ (x :: forall a. a -&gt; b) -&gt; e
--   </pre>
--   
--   Here we do bring <tt>b</tt> into scope.
--   
--   RULES can also use <a>AlwaysBind</a>, such as in the following
--   example:
--   
--   <pre>
--   {-# RULES \"f\" forall (x :: forall a. a -&gt; b). f x = ... b ... #-}
--   </pre>
--   
--   This only applies to RULES that do not explicitly bind their type
--   variables. If a RULE explicitly quantifies its type variables, then
--   <a>NeverBind</a> is used instead. See also <tt>Note [Pattern signature
--   binders and scoping]</tt> in <a>GHC.Hs.Type</a>.
AlwaysBind :: HsPatSigTypeScoping

-- | Never bind any free tyvars. This is used for RULES that have both
--   explicit type and term variable binders, e.g.:
--   
--   <pre>
--   {-# RULES \"const\" forall a. forall (x :: a) y. const x y = x #-}
--   </pre>
--   
--   The presence of the type variable binder <tt>forall a.</tt> implies
--   that the free variables in the types of the term variable binders
--   <tt>x</tt> and <tt>y</tt> are <i>not</i> bound. In the example above,
--   there are no such free variables, but if the user had written <tt>(y
--   :: b)</tt> instead of <tt>y</tt> in the term variable binders, then
--   <tt>b</tt> would be rejected for being out of scope. See also <tt>Note
--   [Pattern signature binders and scoping]</tt> in <a>GHC.Hs.Type</a>.
NeverBind :: HsPatSigTypeScoping
rnHsSigWcType :: HsDocContext -> LHsSigWcType GhcPs -> RnM (LHsSigWcType GhcRn, FreeVars)
rnHsPatSigType :: HsPatSigTypeScoping -> HsDocContext -> HsPatSigType GhcPs -> (HsPatSigType GhcRn -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
newTyVarNameRn :: Maybe a -> LocatedN RdrName -> RnM Name
rnConDeclFields :: HsDocContext -> [FieldLabel] -> [LConDeclField GhcPs] -> RnM ([LConDeclField GhcRn], FreeVars)
lookupField :: FastStringEnv FieldLabel -> FieldOcc GhcPs -> FieldOcc GhcRn
rnLTyVar :: LocatedN RdrName -> RnM (LocatedN Name)
rnScaledLHsType :: HsDocContext -> HsScaled GhcPs (LHsType GhcPs) -> RnM (HsScaled GhcRn (LHsType GhcRn), FreeVars)
data NegationHandling
ReassociateNegation :: NegationHandling
KeepNegationIntact :: NegationHandling
mkOpAppRn :: NegationHandling -> LHsExpr GhcRn -> LHsExpr GhcRn -> Fixity -> LHsExpr GhcRn -> RnM (HsExpr GhcRn)
mkNegAppRn :: LHsExpr GhcRn -> SyntaxExpr GhcRn -> RnM (HsExpr GhcRn)
mkOpFormRn :: LHsCmdTop GhcRn -> LHsExpr GhcRn -> Fixity -> LHsCmdTop GhcRn -> RnM (HsCmd GhcRn)
mkConOpPatRn :: LocatedN Name -> Fixity -> LPat GhcRn -> LPat GhcRn -> RnM (Pat GhcRn)
checkPrecMatch :: Name -> MatchGroup GhcRn body -> RnM ()
checkSectionPrec :: FixityDirection -> HsExpr GhcPs -> LHsExpr GhcRn -> LHsExpr GhcRn -> RnM ()
bindHsOuterTyVarBndrs :: OutputableBndrFlag flag 'Renamed => HsDocContext -> Maybe assoc -> FreeKiTyVars -> HsOuterTyVarBndrs flag GhcPs -> (HsOuterTyVarBndrs flag GhcRn -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
bindHsForAllTelescope :: HsDocContext -> HsForAllTelescope GhcPs -> (HsForAllTelescope GhcRn -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
bindLHsTyVarBndr :: HsDocContext -> Maybe a -> LHsTyVarBndr flag GhcPs -> (LHsTyVarBndr flag GhcRn -> RnM (b, FreeVars)) -> RnM (b, FreeVars)
bindLHsTyVarBndrs :: OutputableBndrFlag flag 'Renamed => HsDocContext -> WarnUnusedForalls -> Maybe a -> [LHsTyVarBndr flag GhcPs] -> ([LHsTyVarBndr flag GhcRn] -> RnM (b, FreeVars)) -> RnM (b, FreeVars)

-- | Should GHC warn if a quantified type variable goes unused? Usually,
--   the answer is "yes", but in the particular case of binding
--   <a>LHsQTyVars</a>, we avoid emitting warnings. See <tt>Note [Suppress
--   -Wunused-foralls when binding LHsQTyVars]</tt>.
data WarnUnusedForalls
WarnUnusedForalls :: WarnUnusedForalls
NoWarnUnusedForalls :: WarnUnusedForalls

-- | Create new renamed type variables corresponding to source-level ones.
--   Duplicates are permitted, but will be removed. This is intended
--   especially for the case of handling the implicitly bound free
--   variables of a type signature.
rnImplicitTvOccs :: Maybe assoc -> FreeKiTyVars -> ([Name] -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
bindSigTyVarsFV :: [Name] -> RnM (a, FreeVars) -> RnM (a, FreeVars)
bindHsQTyVars :: forall a b. HsDocContext -> Maybe a -> FreeKiTyVars -> LHsQTyVars GhcPs -> (LHsQTyVars GhcRn -> Bool -> RnM (b, FreeVars)) -> RnM (b, FreeVars)
type FreeKiTyVars = [LocatedN RdrName]

-- | <a>extractHsTyRdrTyVars</a> finds the type/kind variables of a
--   HsType/HsKind. It's used when making the <tt>forall</tt>s explicit.
--   See Note [Kind and type-variable binders]
extractHsTyRdrTyVars :: LHsType GhcPs -> FreeKiTyVars

-- | Extracts the free type/kind variables from the kind signature of a
--   HsType. This is used to implicitly quantify over <tt>k</tt> in
--   <tt>type T = Nothing :: Maybe k</tt>. The left-to-right order of
--   variables is preserved. See Note [Kind and type-variable binders] and
--   Note [Ordering of implicit variables] and Note [Implicit
--   quantification in type synonyms].
extractHsTyRdrTyVarsKindVars :: LHsType GhcPs -> FreeKiTyVars

-- | Extracts free type and kind variables from types in a list. When the
--   same name occurs multiple times in the types, all occurrences are
--   returned.
extractHsTysRdrTyVars :: [LHsType GhcPs] -> FreeKiTyVars -> FreeKiTyVars
extractRdrKindSigVars :: LFamilyResultSig GhcPs -> FreeKiTyVars

-- | Extracts free type and kind variables from an argument in a GADT
--   constructor, returning variable occurrences in left-to-right order.
--   See <tt>Note [Ordering of implicit variables]</tt>.
extractConDeclGADTDetailsTyVars :: HsConDeclGADTDetails GhcPs -> FreeKiTyVars -> FreeKiTyVars

-- | Get type/kind variables mentioned in the kind signature, preserving
--   left-to-right order:
--   
--   <ul>
--   <li>data T a (b :: k1) :: k2 -&gt; k1 -&gt; k2 -&gt; Type -- result:
--   [k2,k1]</li>
--   <li>data T a (b :: k1) -- result: []</li>
--   </ul>
--   
--   See Note [Ordering of implicit variables].
extractDataDefnKindVars :: HsDataDefn GhcPs -> FreeKiTyVars
extractHsOuterTvBndrs :: HsOuterTyVarBndrs flag GhcPs -> FreeKiTyVars -> FreeKiTyVars
extractHsTyArgRdrKiTyVars :: [LHsTypeArg GhcPs] -> FreeKiTyVars
nubL :: Eq a => [GenLocated l a] -> [GenLocated l a]
nubN :: Eq a => [LocatedN a] -> [LocatedN a]
instance GHC.Utils.Outputable.Outputable GHC.Rename.HsType.OpName
instance GHC.Utils.Outputable.Outputable GHC.Rename.HsType.WarnUnusedForalls
instance GHC.Utils.Outputable.Outputable GHC.Rename.HsType.RnTyKiEnv
instance GHC.Utils.Outputable.Outputable GHC.Rename.HsType.RnTyKiWhat

module GHC.Rename.Fixity
type MiniFixityEnv = FastStringEnv (Located Fixity)
addLocalFixities :: MiniFixityEnv -> [Name] -> RnM a -> RnM a
lookupFixityRn :: Name -> RnM Fixity

-- | <a>lookupFixityRn_help</a> returns <tt>(True, fixity)</tt> if it finds
--   a <a>Fixity</a> in a local environment or from an interface file.
--   Otherwise, it returns <tt>(False, fixity)</tt> (e.g., for unbound
--   <a>Name</a>s or <a>Name</a>s without user-supplied fixity
--   declarations).
lookupFixityRn_help :: Name -> RnM (Bool, Fixity)

-- | Look up the fixity of a (possibly ambiguous) occurrence of a record
--   field selector. We use <a>lookupFixityRn'</a> so that we can specify
--   the <a>OccName</a> as the field label, which might be different to the
--   <a>OccName</a> of the selector <a>Name</a> if
--   <tt>DuplicateRecordFields</tt> is in use (#1173). If there are
--   multiple possible selectors with different fixities, generate an
--   error.
lookupFieldFixityRn :: AmbiguousFieldOcc GhcRn -> RnM Fixity
lookupTyFixityRn :: LocatedN Name -> RnM Fixity

module GHC.Rename.Expr
rnLExpr :: LHsExpr GhcPs -> RnM (LHsExpr GhcRn, FreeVars)
rnExpr :: HsExpr GhcPs -> RnM (HsExpr GhcRn, FreeVars)

-- | Rename some Stmts
rnStmts :: AnnoBody body => HsStmtContext GhcRn -> (body GhcPs -> RnM (body GhcRn, FreeVars)) -> [LStmt GhcPs (LocatedA (body GhcPs))] -> ([Name] -> RnM (thing, FreeVars)) -> RnM (([LStmt GhcRn (LocatedA (body GhcRn))], thing), FreeVars)
type AnnoBody body = (Outputable (body GhcPs), Anno (StmtLR GhcPs GhcPs (LocatedA (body GhcPs))) ~ SrcSpanAnnA, Anno (StmtLR GhcRn GhcPs (LocatedA (body GhcPs))) ~ SrcSpanAnnA, Anno (StmtLR GhcRn GhcRn (LocatedA (body GhcRn))) ~ SrcSpanAnnA)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Rename.Expr.StmtTree a)
instance GHC.Utils.Outputable.Outputable GHC.Rename.Expr.MonadNames

module GHC.Rename.Bind
rnTopBindsLHS :: MiniFixityEnv -> HsValBinds GhcPs -> RnM (HsValBindsLR GhcRn GhcPs)
rnTopBindsBoot :: NameSet -> HsValBindsLR GhcRn GhcPs -> RnM (HsValBinds GhcRn, DefUses)
rnValBindsRHS :: HsSigCtxt -> HsValBindsLR GhcRn GhcPs -> RnM (HsValBinds GhcRn, DefUses)
rnLocalBindsAndThen :: HsLocalBinds GhcPs -> (HsLocalBinds GhcRn -> FreeVars -> RnM (result, FreeVars)) -> RnM (result, FreeVars)
rnLocalValBindsLHS :: MiniFixityEnv -> HsValBinds GhcPs -> RnM ([Name], HsValBindsLR GhcRn GhcPs)
rnLocalValBindsRHS :: NameSet -> HsValBindsLR GhcRn GhcPs -> RnM (HsValBinds GhcRn, DefUses)
rnMethodBinds :: Bool -> Name -> [Name] -> LHsBinds GhcPs -> [LSig GhcPs] -> RnM (LHsBinds GhcRn, [LSig GhcRn], FreeVars)
renameSigs :: HsSigCtxt -> [LSig GhcPs] -> RnM ([LSig GhcRn], FreeVars)
rnMatchGroup :: (Outputable (body GhcPs), AnnoBody body) => HsMatchContext GhcRn -> (LocatedA (body GhcPs) -> RnM (LocatedA (body GhcRn), FreeVars)) -> MatchGroup GhcPs (LocatedA (body GhcPs)) -> RnM (MatchGroup GhcRn (LocatedA (body GhcRn)), FreeVars)
rnGRHSs :: AnnoBody body => HsMatchContext GhcRn -> (LocatedA (body GhcPs) -> RnM (LocatedA (body GhcRn), FreeVars)) -> GRHSs GhcPs (LocatedA (body GhcPs)) -> RnM (GRHSs GhcRn (LocatedA (body GhcRn)), FreeVars)
rnGRHS :: AnnoBody body => HsMatchContext GhcRn -> (LocatedA (body GhcPs) -> RnM (LocatedA (body GhcRn), FreeVars)) -> LGRHS GhcPs (LocatedA (body GhcPs)) -> RnM (LGRHS GhcRn (LocatedA (body GhcRn)), FreeVars)
rnSrcFixityDecl :: HsSigCtxt -> FixitySig GhcPs -> RnM (FixitySig GhcRn)
makeMiniFixityEnv :: [LFixitySig GhcPs] -> RnM MiniFixityEnv
type MiniFixityEnv = FastStringEnv (Located Fixity)
data HsSigCtxt
TopSigCtxt :: NameSet -> HsSigCtxt
LocalBindCtxt :: NameSet -> HsSigCtxt
ClsDeclCtxt :: Name -> HsSigCtxt
InstDeclCtxt :: NameSet -> HsSigCtxt
HsBootCtxt :: NameSet -> HsSigCtxt
RoleAnnotCtxt :: NameSet -> HsSigCtxt

module GHC.Rename.Names

-- | Process Import Decls. See <a>rnImportDecl</a> for a description of
--   what the return types represent. Note: Do the non SOURCE ones first,
--   so that we get a helpful warning for SOURCE ones that are unnecessary
rnImports :: [LImportDecl GhcPs] -> RnM ([LImportDecl GhcRn], GlobalRdrEnv, ImportAvails, AnyHpcUsage)
getLocalNonValBinders :: MiniFixityEnv -> HsGroup GhcPs -> RnM ((TcGblEnv, TcLclEnv), NameSet)
newRecordSelector :: DuplicateRecordFields -> FieldSelectors -> [Name] -> LFieldOcc GhcPs -> RnM FieldLabel
extendGlobalRdrEnvRn :: [AvailInfo] -> MiniFixityEnv -> RnM (TcGblEnv, TcLclEnv)

-- | make a <a>GlobalRdrEnv</a> where all the elements point to the same
--   Provenance (useful for "hiding" imports, or imports with no details).
gresFromAvails :: Maybe ImportSpec -> [AvailInfo] -> [GlobalRdrElt]

-- | Calculate the <a>ImportAvails</a> induced by an import of a particular
--   interface, but without <a>imp_mods</a>.
calculateAvails :: HomeUnit -> ModIface -> IsSafeImport -> IsBootInterface -> ImportedBy -> ImportAvails
reportUnusedNames :: TcGblEnv -> HscSource -> RnM ()
checkConName :: RdrName -> TcRn ()
mkChildEnv :: [GlobalRdrElt] -> NameEnv [GlobalRdrElt]
findChildren :: NameEnv [a] -> Name -> [a]
dodgyMsg :: (Outputable a, Outputable b) => SDoc -> a -> b -> SDoc
dodgyMsgInsert :: forall p. IdP (GhcPass p) -> IE (GhcPass p)
findImportUsage :: [LImportDecl GhcRn] -> [GlobalRdrElt] -> [ImportDeclUsage]
getMinimalImports :: [ImportDeclUsage] -> RnM [LImportDecl GhcRn]
printMinimalImports :: HscSource -> [ImportDeclUsage] -> RnM ()
type ImportDeclUsage = (LImportDecl GhcRn, [GlobalRdrElt], [Name])

module GHC.Rename.Module

-- | <tt>rnSourceDecl</tt> "renames" declarations. It simultaneously
--   performs dependency analysis and precedence parsing. It also does the
--   following error checks:
--   
--   <ul>
--   <li>Checks that tyvars are used properly. This includes checking for
--   undefined tyvars, and tyvars in contexts that are ambiguous. (Some of
--   this checking has now been moved to module <tt>TcMonoType</tt>, since
--   we don't have functional dependency information at this point.)</li>
--   <li>Checks that all variable occurrences are defined.</li>
--   <li>Checks the <tt>(..)</tt> etc constraints in the export list.</li>
--   </ul>
--   
--   Brings the binders of the group into scope in the appropriate places;
--   does NOT assume that anything is in scope already
rnSrcDecls :: HsGroup GhcPs -> RnM (TcGblEnv, HsGroup GhcRn)
addTcgDUs :: TcGblEnv -> DefUses -> TcGblEnv
findSplice :: [LHsDecl GhcPs] -> RnM (HsGroup GhcPs, Maybe (SpliceDecl GhcPs, [LHsDecl GhcPs]))


-- | Typechecking annotations
module GHC.Tc.Gen.Annotation
tcAnnotations :: [LAnnDecl GhcRn] -> TcM [Annotation]
annCtxt :: OutputableBndrId p => AnnDecl (GhcPass p) -> SDoc

module GHC.HsToCore.Monad

-- | Desugaring monad. See also <tt>TcM</tt>.
type DsM = TcRnIf DsGblEnv DsLclEnv

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | Run a <a>DsM</a> action inside the <a>IO</a> monad.
initDs :: HscEnv -> TcGblEnv -> DsM a -> IO (Messages DecoratedSDoc, Maybe a)

-- | Run a <a>DsM</a> action inside the <a>TcM</a> monad.
initDsTc :: DsM a -> TcM a
initTcDsForSolver :: TcM a -> DsM a

-- | Run a <a>DsM</a> action in the context of an existing <a>ModGuts</a>
initDsWithModGuts :: HscEnv -> ModGuts -> DsM a -> IO (Messages DecoratedSDoc, Maybe a)
fixDs :: (a -> DsM a) -> DsM a

-- | Left-to-right monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, ..., w, x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldlM f z t = do
--       aa &lt;- f z a
--       bb &lt;- f aa b
--       ...
--       xx &lt;- f ww x
--       yy &lt;- f xx y
--       return yy -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldlM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldlM f z t =
--       flip f a &gt;=&gt; flip f b &gt;=&gt; ... &gt;=&gt; flip f x &gt;=&gt; flip f y $ z
--   </pre>
--   
--   The monadic effects of <tt>foldlM</tt> are sequenced from left to
--   right.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from an initial segment of the element
--   sequence. If you want to evaluate the monadic effects in right-to-left
--   order, or perhaps be able to short-circuit after processing a tail of
--   the sequence of elements, you'll need to use <a>foldrM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the rightmost element <tt>y</tt>, so that,
--   ignoring effects, the result looks like a left fold:
--   
--   <pre>
--   ((((z `f` a) `f` b) ... `f` w) `f` x) `f` y
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f a e = do { print e ; return $ e : a }
--   
--   &gt;&gt;&gt; foldlM f [] [0..3]
--   0
--   1
--   2
--   3
--   [3,2,1,0]
--   </pre>
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Right-to-left monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, c, ..., x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldrM f z t = do
--       yy &lt;- f y z
--       xx &lt;- f x yy
--       ...
--       bb &lt;- f b cc
--       aa &lt;- f a bb
--       return aa -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldrM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldrM f z t = f y &gt;=&gt; f x &gt;=&gt; ... &gt;=&gt; f b &gt;=&gt; f a $ z
--   </pre>
--   
--   The monadic effects of <tt>foldrM</tt> are sequenced from right to
--   left, and e.g. folds of infinite lists will diverge.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from a tail of the element sequence. If
--   you want to evaluate the monadic effects in left-to-right order, or
--   perhaps be able to short-circuit after an initial sequence of
--   elements, you'll need to use <a>foldlM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the leftmost element <tt>a</tt>, so that, ignoring
--   effects, the result looks like a right fold:
--   
--   <pre>
--   a `f` (b `f` (c `f` (... (x `f` (y `f` z))))).
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f i acc = do { print i ; return $ i : acc }
--   
--   &gt;&gt;&gt; foldrM f [] [0..3]
--   3
--   2
--   1
--   0
--   [0,1,2,3]
--   </pre>
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
whenGOptM :: GeneralFlag -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
unsetGOptM :: GeneralFlag -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
unsetWOptM :: WarningFlag -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
xoptM :: Extension -> TcRnIf gbl lcl Bool

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>
duplicateLocalDs :: Id -> DsM Id
newSysLocalDsNoLP :: Mult -> Type -> DsM Id
newSysLocalDs :: Mult -> Type -> DsM Id
newSysLocalsDsNoLP :: [Scaled Type] -> DsM [Id]
newSysLocalsDs :: [Scaled Type] -> DsM [Id]
newUniqueId :: Id -> Mult -> Type -> DsM Id
newFailLocalDs :: Mult -> Type -> DsM Id
newPredVarDs :: PredType -> DsM Var
getSrcSpanDs :: DsM SrcSpan
putSrcSpanDs :: SrcSpan -> DsM a -> DsM a
putSrcSpanDsA :: SrcSpanAnn' ann -> DsM a -> DsM a
mkPrintUnqualifiedDs :: DsM PrintUnqualified
newUnique :: TcRnIf gbl lcl Unique

-- | Unique Supply
--   
--   A value of type <a>UniqSupply</a> is unique, and it can supply
--   <i>one</i> distinct <a>Unique</a>. Also, from the supply, one can also
--   manufacture an arbitrary number of further <tt>UniqueSupply</tt>
--   values, which will be distinct from the first and from all others.
data UniqSupply
newUniqueSupply :: TcRnIf gbl lcl UniqSupply
getGhcModeDs :: DsM GhcMode
dsGetFamInstEnvs :: DsM FamInstEnvs
dsLookupGlobal :: Name -> DsM TyThing
dsLookupGlobalId :: Name -> DsM Id
dsLookupTyCon :: Name -> DsM TyCon
dsLookupDataCon :: Name -> DsM DataCon
dsLookupConLike :: Name -> DsM ConLike

-- | See <a>getCCIndexM</a>.
getCCIndexDsM :: FastString -> DsM CostCentreIndex
type DsMetaEnv = NameEnv DsMetaVal
data DsMetaVal
DsBound :: Id -> DsMetaVal
DsSplice :: HsExpr GhcTc -> DsMetaVal
dsGetMetaEnv :: DsM (NameEnv DsMetaVal)
dsLookupMetaEnv :: Name -> DsM (Maybe DsMetaVal)
dsExtendMetaEnv :: DsMetaEnv -> DsM a -> DsM a

-- | Get the current pattern match oracle state. See <a>dsl_nablas</a>.
getPmNablas :: DsM Nablas

-- | Set the pattern match oracle state within the scope of the given
--   action. See <a>dsl_nablas</a>.
updPmNablas :: Nablas -> DsM a -> DsM a

-- | The <tt>COMPLETE</tt> pragmas that are in scope.
dsGetCompleteMatches :: DsM CompleteMatches
type DsWarning = (SrcSpan, SDoc)

-- | Emit a warning for the current source location NB: Warns whether or
--   not -Wxyz is set
warnDs :: WarnReason -> SDoc -> DsM ()

-- | Emit a warning only if the correct WarnReason is set in the DynFlags
warnIfSetDs :: WarningFlag -> SDoc -> DsM ()
errDs :: SDoc -> DsM ()

-- | Issue an error, but return the expression for (), so that we can
--   continue reporting errors.
errDsCoreExpr :: SDoc -> DsM CoreExpr
failWithDs :: SDoc -> DsM a
failDs :: DsM a
discardWarningsDs :: DsM a -> DsM a
askNoErrsDs :: DsM a -> DsM (a, Bool)
data DsMatchContext
DsMatchContext :: HsMatchContext GhcRn -> SrcSpan -> DsMatchContext
data EquationInfo
EqnInfo :: [Pat GhcTc] -> Origin -> MatchResult CoreExpr -> EquationInfo

-- | The patterns for an equation
--   
--   NB: We have <i>already</i> applied <tt>decideBangHood</tt> to these
--   patterns. See Note [decideBangHood] in <a>GHC.HsToCore.Utils</a>
[eqn_pats] :: EquationInfo -> [Pat GhcTc]

-- | Was this equation present in the user source?
--   
--   This helps us avoid warnings on patterns that GHC elaborated.
--   
--   For instance, the pattern <tt>-1 :: Word</tt> gets desugared into
--   <tt>W# -1## :: Word</tt>, but we shouldn't warn about an overflowed
--   literal for <i>both</i> of these cases.
[eqn_orig] :: EquationInfo -> Origin

-- | What to do after match
[eqn_rhs] :: EquationInfo -> MatchResult CoreExpr

-- | This is a value of type a with potentially a CoreExpr-shaped hole in
--   it. This is used to deal with cases where we are potentially handling
--   pattern match failure, and want to later specify how failure is
--   handled.
data MatchResult a

-- | We represent the case where there is no hole without a function from
--   <a>CoreExpr</a>, like this, because sometimes we have nothing to put
--   in the hole and so want to be sure there is in fact no hole.
MR_Infallible :: DsM a -> MatchResult a
MR_Fallible :: (CoreExpr -> DsM a) -> MatchResult a
runMatchResult :: CoreExpr -> MatchResult a -> DsM a
type DsWrapper = CoreExpr -> CoreExpr
idDsWrapper :: DsWrapper

-- | Fail with an error message if the type is levity polymorphic.
dsNoLevPoly :: Type -> SDoc -> DsM ()

-- | Check an expression for levity polymorphism, failing if it is levity
--   polymorphic.
dsNoLevPolyExpr :: CoreExpr -> SDoc -> DsM ()

-- | Runs the thing_inside. If there are no errors, then returns the expr
--   given. Otherwise, returns unitExpr. This is useful for doing a bunch
--   of levity polymorphism checks and then avoiding making a core App. (If
--   we make a core App on a levity polymorphic argument, detecting how to
--   handle the let/app invariant might call isUnliftedType, which panics
--   on a levity polymorphic type.) See #12709 for an example of why this
--   machinery is necessary.
dsWhenNoErrs :: DsM a -> (a -> CoreExpr) -> DsM CoreExpr

-- | Inject a trace message into the compiled program. Whereas pprTrace
--   prints out information *while compiling*, pprRuntimeTrace captures
--   that information and causes it to be printed *at runtime* using
--   Debug.Trace.trace.
--   
--   pprRuntimeTrace hdr doc expr
--   
--   will produce an expression that looks like
--   
--   trace (hdr + doc) expr
--   
--   When using this to debug a module that Debug.Trace depends on, it is
--   necessary to import {-# SOURCE #-} Debug.Trace () in that module. We
--   could avoid this inconvenience by wiring in Debug.Trace.trace, but
--   that doesn't seem worth the effort and maintenance cost.
pprRuntimeTrace :: String -> SDoc -> CoreExpr -> DsM CoreExpr
instance GHC.Base.Functor GHC.HsToCore.Monad.MatchResult
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Monad.EquationInfo
instance GHC.Base.Applicative GHC.HsToCore.Monad.MatchResult
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Monad.DsMatchContext
instance GHC.Types.TyThing.MonadThings (GHC.Data.IOEnv.IOEnv (GHC.Tc.Types.Env GHC.HsToCore.Types.DsGblEnv GHC.HsToCore.Types.DsLclEnv))


-- | Various types used during desugaring.
module GHC.HsToCore.Types

-- | Desugaring monad. See also <tt>TcM</tt>.
type DsM = TcRnIf DsGblEnv DsLclEnv

-- | Local state of the desugarer, extended as we lexically descend
data DsLclEnv
DsLclEnv :: DsMetaEnv -> RealSrcSpan -> Nablas -> DsLclEnv

-- | Template Haskell bindings
[dsl_meta] :: DsLclEnv -> DsMetaEnv

-- | To put in pattern-matching error msgs
[dsl_loc] :: DsLclEnv -> RealSrcSpan

-- | See Note [Note [Long-distance information] in <a>GHC.HsToCore.Pmc</a>.
--   The set of reaching values Nablas is augmented as we walk inwards,
--   refined through each pattern match in turn
[dsl_nablas] :: DsLclEnv -> Nablas

-- | Global read-only context and state of the desugarer. The statefulness
--   is implemented through <a>IORef</a>s.
data DsGblEnv
DsGblEnv :: Module -> FamInstEnv -> GlobalRdrEnv -> PrintUnqualified -> IORef (Messages DecoratedSDoc) -> (IfGblEnv, IfLclEnv) -> CompleteMatches -> IORef CostCentreState -> DsGblEnv
[ds_mod] :: DsGblEnv -> Module
[ds_fam_inst_env] :: DsGblEnv -> FamInstEnv
[ds_gbl_rdr_env] :: DsGblEnv -> GlobalRdrEnv
[ds_unqual] :: DsGblEnv -> PrintUnqualified
[ds_msgs] :: DsGblEnv -> IORef (Messages DecoratedSDoc)
[ds_if_env] :: DsGblEnv -> (IfGblEnv, IfLclEnv)
[ds_complete_matches] :: DsGblEnv -> CompleteMatches
[ds_cc_st] :: DsGblEnv -> IORef CostCentreState
type DsMetaEnv = NameEnv DsMetaVal
data DsMetaVal
DsBound :: Id -> DsMetaVal
DsSplice :: HsExpr GhcTc -> DsMetaVal
type CompleteMatches = [CompleteMatch]
instance GHC.Unit.Module.ContainsModule GHC.HsToCore.Types.DsGblEnv


-- | Types used through-out pattern match checking. This module is mostly
--   there to be imported from <a>GHC.HsToCore.Types</a>. The exposed API
--   is that of <a>GHC.HsToCore.Pmc</a>.
--   
--   These types model the paper <a>Lower Your Guards: A Compositional
--   Pattern-Match Coverage Checker"</a>.
module GHC.HsToCore.Pmc.Types

-- | Means by which we identify a source construct for later
--   pretty-printing in a warning message. <a>SDoc</a> for the equation to
--   show, <a>Located</a> for the location.
newtype SrcInfo
SrcInfo :: Located SDoc -> SrcInfo

-- | A very simple language for pattern guards. Let bindings, bang
--   patterns, and matching variables against flat constructor patterns.
--   The LYG guard language.
data PmGrd

-- | <tt>PmCon x K dicts args</tt> corresponds to a <tt>K dicts args &lt;-
--   x</tt> guard. The <tt>args</tt> are bound in this construct, the
--   <tt>x</tt> is just a use. For the arguments' meaning see
--   <a>ConPatOut</a>.
PmCon :: !Id -> !PmAltCon -> ![TyVar] -> ![EvVar] -> ![Id] -> PmGrd
[pm_id] :: PmGrd -> !Id
[pm_con_con] :: PmGrd -> !PmAltCon
[pm_con_tvs] :: PmGrd -> ![TyVar]
[pm_con_dicts] :: PmGrd -> ![EvVar]
[pm_con_args] :: PmGrd -> ![Id]

-- | <tt>PmBang x</tt> corresponds to a <tt>seq x True</tt> guard. If the
--   extra <a>SrcInfo</a> is present, the bang guard came from a source
--   bang pattern, in which case we might want to report it as redundant.
--   See Note [Dead bang patterns] in GHC.HsToCore.Pmc.Check.
PmBang :: !Id -> !Maybe SrcInfo -> PmGrd
[pm_id] :: PmGrd -> !Id
[_pm_loc] :: PmGrd -> !Maybe SrcInfo

-- | <tt>PmLet x expr</tt> corresponds to a <tt>let x = expr</tt> guard.
--   This actually <i>binds</i> <tt>x</tt>.
PmLet :: !Id -> !CoreExpr -> PmGrd
[pm_id] :: PmGrd -> !Id
[_pm_let_expr] :: PmGrd -> !CoreExpr

-- | A sequence of <a>PmGrd</a>s.
newtype GrdVec
GrdVec :: [PmGrd] -> GrdVec

-- | A guard tree denoting <tt>MatchGroup</tt>.
newtype PmMatchGroup p
PmMatchGroup :: NonEmpty (PmMatch p) -> PmMatchGroup p

-- | A guard tree denoting <tt>Match</tt>: A payload describing the pats
--   and a bunch of GRHS.
data PmMatch p
PmMatch :: !p -> !PmGRHSs p -> PmMatch p
[pm_pats] :: PmMatch p -> !p
[pm_grhss] :: PmMatch p -> !PmGRHSs p

-- | A guard tree denoting <tt>GRHSs</tt>: A bunch of <a>PmLet</a> guards
--   for local bindings from the <tt>GRHSs</tt>s <tt>where</tt> clauses and
--   the actual list of <tt>GRHS</tt>. See Note [Long-distance information
--   for HsLocalBinds] in <a>GHC.HsToCore.Pmc.Desugar</a>.
data PmGRHSs p
PmGRHSs :: !p -> !NonEmpty (PmGRHS p) -> PmGRHSs p
[pgs_lcls] :: PmGRHSs p -> !p
[pgs_grhss] :: PmGRHSs p -> !NonEmpty (PmGRHS p)

-- | A guard tree denoting <tt>GRHS</tt>: A payload describing the grds and
--   a <a>SrcInfo</a> useful for printing out in warnings messages.
data PmGRHS p
PmGRHS :: !p -> !SrcInfo -> PmGRHS p
[pg_grds] :: PmGRHS p -> !p
[pg_rhs] :: PmGRHS p -> !SrcInfo

-- | A guard tree denoting a pattern binding.
newtype PmPatBind p
PmPatBind :: PmGRHS p -> PmPatBind p

-- | A guard tree denoting an -XEmptyCase.
newtype PmEmptyCase
PmEmptyCase :: Id -> PmEmptyCase
[pe_var] :: PmEmptyCase -> Id

-- | Redundancy sets, used to determine redundancy of RHSs and bang
--   patterns (later digested into a <tt>CIRB</tt>).
data RedSets
RedSets :: !Nablas -> !Nablas -> !OrdList (Nablas, SrcInfo) -> RedSets

-- | The <i>Covered</i> set; the set of values reaching a particular
--   program point.
[rs_cov] :: RedSets -> !Nablas

-- | The <i>Diverging</i> set; empty if no match can lead to divergence. If
--   it wasn't empty, we have to turn redundancy warnings into
--   inaccessibility warnings for any subclauses.
[rs_div] :: RedSets -> !Nablas

-- | If any of the <a>Nablas</a> is empty, the corresponding <a>SrcInfo</a>
--   pin-points a bang pattern in source that is redundant. See Note [Dead
--   bang patterns].
[rs_bangs] :: RedSets -> !OrdList (Nablas, SrcInfo)
data Precision
Approximate :: Precision
Precise :: Precision

-- | Pattern-match coverage check result
data CheckResult a
CheckResult :: !a -> !Nablas -> !Precision -> CheckResult a

-- | A hole for redundancy info and covered sets.
[cr_ret] :: CheckResult a -> !a

-- | The set of uncovered values falling out at the bottom. (for
--   -Wincomplete-patterns, but also important state for the algorithm)
[cr_uncov] :: CheckResult a -> !Nablas

-- | A flag saying whether we ran into the <tt>maxPmCheckModels</tt> limit
--   for the purpose of suggesting to crank it up in the warning message.
--   Writer state.
[cr_approx] :: CheckResult a -> !Precision

-- | Used as tree payload pre-checking. The LYG guards to check.
type Pre = GrdVec

-- | Used as tree payload post-checking. The redundancy info we elaborated.
type Post = RedSets
instance GHC.Show.Show GHC.HsToCore.Pmc.Types.Precision
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Types.Precision
instance GHC.Base.Functor GHC.HsToCore.Pmc.Types.CheckResult
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.CheckResult a)
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.RedSets
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.Precision
instance GHC.Base.Semigroup GHC.HsToCore.Pmc.Types.Precision
instance GHC.Base.Monoid GHC.HsToCore.Pmc.Types.Precision
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmPatBind p)
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.PmEmptyCase
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmMatchGroup p)
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmMatch p)
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmGRHSs p)
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmGRHS p)
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.GrdVec
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.PmGrd
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.SrcInfo


-- | Domain types used in <a>GHC.HsToCore.Pmc.Solver</a>. The ultimate goal
--   is to define <a>Nabla</a>, which models normalised refinement types
--   from the paper <a>Lower Your Guards: A Compositional Pattern-Match
--   Coverage Checker"</a>.
module GHC.HsToCore.Pmc.Solver.Types

-- | See <a>vi_bot</a>.
data BotInfo
IsBot :: BotInfo
IsNotBot :: BotInfo
MaybeBot :: BotInfo
data PmAltConApp
PACA :: !PmAltCon -> ![TyVar] -> ![Id] -> PmAltConApp
[paca_con] :: PmAltConApp -> !PmAltCon
[paca_tvs] :: PmAltConApp -> ![TyVar]
[paca_ids] :: PmAltConApp -> ![Id]

-- | Information about an <a>Id</a>. Stores positive (<a>vi_pos</a>) facts,
--   like <tt>x ~ Just 42</tt>, and negative (<a>vi_neg</a>) facts, like "x
--   is not (:)". Also caches the type (<tt>vi_ty</tt>), the
--   <a>ResidualCompleteMatches</a> of a COMPLETE set (<a>vi_rcm</a>).
--   
--   Subject to Note [The Pos/Neg invariant] in
--   <a>GHC.HsToCore.Pmc.Solver</a>.
data VarInfo
VI :: !Id -> ![PmAltConApp] -> !PmAltConSet -> BotInfo -> !ResidualCompleteMatches -> VarInfo

-- | The <a>Id</a> in question. Important for adding new constraints
--   relative to this <a>VarInfo</a> when we don't easily have the
--   <a>Id</a> available.
[vi_id] :: VarInfo -> !Id

-- | Positive info: <a>PmAltCon</a> apps it is (i.e. <tt>x ~ [Just y,
--   PatSyn z]</tt>), all at the same time (i.e. conjunctive). We need a
--   list because of nested pattern matches involving pattern synonym case
--   x of { Just y -&gt; case x of PatSyn z -&gt; ... } However, no more
--   than one RealDataCon in the list, otherwise contradiction because of
--   generativity.
[vi_pos] :: VarInfo -> ![PmAltConApp]

-- | Negative info: A list of <a>PmAltCon</a>s that it cannot match.
--   Example, assuming
--   
--   <pre>
--   data T = Leaf Int | Branch T T | Node Int T
--   </pre>
--   
--   then <tt>x â [Leaf, Node]</tt> means that <tt>x</tt> cannot match a
--   <tt>Leaf</tt> or <tt>Node</tt>, and hence can only match
--   <tt>Branch</tt>. Is orthogonal to anything from <a>vi_pos</a>, in the
--   sense that <a>eqPmAltCon</a> returns <tt>PossiblyOverlap</tt> for any
--   pairing between <a>vi_pos</a> and <a>vi_neg</a>.
[vi_neg] :: VarInfo -> !PmAltConSet

-- | Can this variable be â¥? Models (mutually contradicting) <tt>x ~ â¥</tt>
--   and <tt>x â â¥</tt> constraints. E.g. * <a>MaybeBot</a>: Don't know;
--   Neither <tt>x ~ â¥</tt> nor <tt>x â â¥</tt>. * <a>IsBot</a>: <tt>x ~
--   â¥</tt> * <a>IsNotBot</a>: <tt>x â â¥</tt>
[vi_bot] :: VarInfo -> BotInfo

-- | A cache of the associated COMPLETE sets. At any time a superset of
--   possible constructors of each COMPLETE set. So, if it's not in here,
--   we can't possibly match on it. Complementary to <a>vi_neg</a>. We
--   still need it to recognise completion of a COMPLETE set efficiently
--   for large enums.
[vi_rcm] :: VarInfo -> !ResidualCompleteMatches

-- | The term oracle state. Stores <a>VarInfo</a> for encountered
--   <a>Id</a>s. These entries are possibly shared when we figure out that
--   two variables must be equal, thus represent the same set of values.
--   
--   See Note [TmState invariants] in <a>GHC.HsToCore.Pmc.Solver</a>.
data TmState
TmSt :: !UniqSDFM Id VarInfo -> !CoreMap Id -> !DIdSet -> TmState

-- | Facts about term variables. Deterministic env, so that we generate
--   deterministic error messages.
[ts_facts] :: TmState -> !UniqSDFM Id VarInfo

-- | An environment for looking up whether we already encountered
--   semantically equivalent expressions that we want to represent by the
--   same <a>Id</a> representative.
[ts_reps] :: TmState -> !CoreMap Id

-- | Which <a>VarInfo</a> needs to be checked for inhabitants because of
--   new negative constraints (e.g. <tt>x â â¥</tt> or <tt>x â K</tt>).
[ts_dirty] :: TmState -> !DIdSet

-- | The type oracle state. An <a>InertSet</a> that we incrementally add
--   local type constraints to, together with a sequence number that counts
--   the number of times we extended it with new facts.
data TyState
TySt :: !Int -> !InertSet -> TyState
[ty_st_n] :: TyState -> !Int
[ty_st_inert] :: TyState -> !InertSet

-- | A normalised refinement type â ("nabla"), comprised of an inert set of
--   canonical (i.e. mutually compatible) term and type constraints that
--   form the refinement type's predicate.
data Nabla
MkNabla :: !TyState -> !TmState -> Nabla

-- | Type oracle; things like a~Int
[nabla_ty_st] :: Nabla -> !TyState

-- | Term oracle; things like x~Nothing
[nabla_tm_st] :: Nabla -> !TmState

-- | A disjunctive bag of <a>Nabla</a>s, representing a refinement type.
newtype Nablas
MkNablas :: Bag Nabla -> Nablas
initNablas :: Nablas

-- | A list of conlikes which represents a complete pattern match. These
--   arise from <tt>COMPLETE</tt> signatures. See also Note [Implementation
--   of COMPLETE pragmas].
data CompleteMatch

-- | A data type that caches for the <a>VarInfo</a> of <tt>x</tt> the
--   results of querying <tt>dsGetCompleteMatches</tt> and then striking
--   out all occurrences of <tt>K</tt> for which we already know <tt>x â
--   K</tt> from these sets.
--   
--   For motivation, see Section 5.3 in Lower Your Guards. See also Note
--   [Implementation of COMPLETE pragmas]
data ResidualCompleteMatches
RCM :: !Maybe CompleteMatch -> !Maybe [CompleteMatch] -> ResidualCompleteMatches

-- | The residual set for the vanilla COMPLETE set from the data defn.
--   Tracked separately from <a>rcm_pragmas</a>, because it might only be
--   known much later (when we have enough type information to see the
--   <a>TyCon</a> of the match), or not at all even. Until that happens, it
--   is <a>Nothing</a>.
[rcm_vanilla] :: ResidualCompleteMatches -> !Maybe CompleteMatch

-- | The residual sets for <i>all</i> COMPLETE sets from pragmas that are
--   visible when compiling this module. Querying that set with
--   <tt>dsGetCompleteMatches</tt> requires <tt>DsM</tt>, so we initialise
--   it with <a>Nothing</a> until first needed in a <tt>DsM</tt> context.
[rcm_pragmas] :: ResidualCompleteMatches -> !Maybe [CompleteMatch]
getRcm :: ResidualCompleteMatches -> [CompleteMatch]
isRcmInitialised :: ResidualCompleteMatches -> Bool

-- | Literals (simple and overloaded ones) for pattern match checking.
--   
--   See Note [Undecidable Equality for PmAltCons]
data PmLit
PmLit :: Type -> PmLitValue -> PmLit
[pm_lit_ty] :: PmLit -> Type
[pm_lit_val] :: PmLit -> PmLitValue
data PmLitValue
PmLitInt :: Integer -> PmLitValue
PmLitRat :: Rational -> PmLitValue
PmLitChar :: Char -> PmLitValue
PmLitString :: FastString -> PmLitValue
PmLitOverInt :: Int -> Integer -> PmLitValue
PmLitOverRat :: Int -> FractionalLit -> PmLitValue
PmLitOverString :: FastString -> PmLitValue

-- | Represents the head of a match against a <a>ConLike</a> or literal.
--   Really similar to <a>AltCon</a>.
data PmAltCon
PmAltConLike :: ConLike -> PmAltCon
PmAltLit :: PmLit -> PmAltCon

-- | Type of a <a>PmLit</a>
pmLitType :: PmLit -> Type

-- | Type of a <a>PmAltCon</a>
pmAltConType :: PmAltCon -> [Type] -> Type

-- | Is a match on this constructor forcing the match variable? True of
--   data constructors, literals and pattern synonyms (#17357), but not of
--   newtypes. See Note [Coverage checking Newtype matches] in
--   <a>GHC.HsToCore.Pmc.Solver</a>.
isPmAltConMatchStrict :: PmAltCon -> Bool
pmAltConImplBangs :: PmAltCon -> [HsImplBang]
data PmAltConSet
emptyPmAltConSet :: PmAltConSet
isEmptyPmAltConSet :: PmAltConSet -> Bool

-- | Whether there is a <a>PmAltCon</a> in the <a>PmAltConSet</a> that
--   compares <a>Equal</a> to the given <a>PmAltCon</a> according to
--   <a>eqPmAltCon</a>.
elemPmAltConSet :: PmAltCon -> PmAltConSet -> Bool
extendPmAltConSet :: PmAltConSet -> PmAltCon -> PmAltConSet
pmAltConSetElems :: PmAltConSet -> [PmAltCon]

-- | Undecidable semantic equality result. See Note [Undecidable Equality
--   for PmAltCons]
data PmEquality
Equal :: PmEquality
Disjoint :: PmEquality
PossiblyOverlap :: PmEquality

-- | We can't in general decide whether two <a>PmAltCon</a>s match the same
--   set of values. In addition to the reasons in <a>eqPmLit</a> and
--   <a>eqConLike</a>, a <a>PmAltConLike</a> might or might not represent
--   the same value as a <a>PmAltLit</a>. See Note [Undecidable Equality
--   for PmAltCons].
--   
--   <ul>
--   <li><tt>Just True</tt> ==&gt; Surely equal</li>
--   <li><tt>Just False</tt> ==&gt; Surely different (non-overlapping,
--   even!)</li>
--   <li><tt>Nothing</tt> ==&gt; Equality relation undecidable</li>
--   </ul>
--   
--   Examples (omitting some constructor wrapping):
--   
--   <ul>
--   <li><tt>eqPmAltCon (LitInt 42) (LitInt 1) == Just False</tt>: Lit
--   equality is decidable</li>
--   <li><tt>eqPmAltCon (DataCon A) (DataCon B) == Just False</tt>: DataCon
--   equality is decidable</li>
--   <li><tt>eqPmAltCon (LitOverInt 42) (LitOverInt 1) == Nothing</tt>:
--   OverLit equality is undecidable</li>
--   <li><tt>eqPmAltCon (PatSyn PA) (PatSyn PB) == Nothing</tt>: PatSyn
--   equality is undecidable</li>
--   <li><tt>eqPmAltCon (DataCon I#) (LitInt 1) == Nothing</tt>: DataCon to
--   Lit comparisons are undecidable without reasoning about the wrapped
--   <tt>Int#</tt></li>
--   <li><tt>eqPmAltCon (LitOverInt 1) (LitOverInt 1) == Just True</tt>: We
--   assume reflexivity for overloaded literals</li>
--   <li><tt>eqPmAltCon (PatSyn PA) (PatSyn PA) == Just True</tt>: We
--   assume reflexivity for Pattern Synonyms</li>
--   </ul>
eqPmAltCon :: PmAltCon -> PmAltCon -> PmEquality
literalToPmLit :: Type -> Literal -> Maybe PmLit
negatePmLit :: PmLit -> Maybe PmLit
overloadPmLit :: Type -> PmLit -> Maybe PmLit
pmLitAsStringLit :: PmLit -> Maybe FastString
coreExprAsPmLit :: CoreExpr -> Maybe PmLit
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.Types.BotInfo
instance GHC.Show.Show GHC.HsToCore.Pmc.Solver.Types.PmEquality
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.Types.PmEquality
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.Nablas
instance GHC.Base.Semigroup GHC.HsToCore.Pmc.Solver.Types.Nablas
instance GHC.Base.Monoid GHC.HsToCore.Pmc.Solver.Types.Nablas
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.Nabla
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.TmState
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.VarInfo
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmAltConSet
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmAltConApp
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.Types.PmAltCon
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmAltCon
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.Types.PmLit
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmEquality
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmLit
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmLitValue
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.ResidualCompleteMatches
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.BotInfo
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.TyState

module GHC.HsToCore.Expr
dsExpr :: HsExpr GhcTc -> DsM CoreExpr

-- | Replace the body of the function with this block to test the
--   hsExprType function in GHC.Tc.Utils.Zonk: putSrcSpanDs loc $ do {
--   core_expr &lt;- dsExpr e ; if debugIsOn &amp;&amp; not ( exprType
--   core_expr <a>eqType</a> hsExprType e -- ) then (assertPprPanic
--   "compiler<i>.</i>GHC<i>HsToCore</i>Expr.hs" 249 ( ppr e <a>+</a>
--   dcolon <a>+</a> ppr (hsExprType e) $$ -- ppr core_expr <a>+</a> dcolon
--   <a>+</a> ppr (exprType core_expr) )) else return ()
dsLExpr :: LHsExpr GhcTc -> DsM CoreExpr

-- | Variant of <a>dsLExpr</a> that ensures that the result is not levity
--   polymorphic. This should be used when the resulting expression will be
--   an argument to some other function. See Note [Levity polymorphism
--   checking] in <a>GHC.HsToCore.Monad</a> See Note [Levity polymorphism
--   invariants] in <a>GHC.Core</a>
dsLExprNoLP :: LHsExpr GhcTc -> DsM CoreExpr
dsLocalBinds :: HsLocalBinds GhcTc -> CoreExpr -> DsM CoreExpr
dsValBinds :: HsValBinds GhcTc -> CoreExpr -> DsM CoreExpr
dsLit :: HsLit GhcRn -> DsM CoreExpr
dsSyntaxExpr :: SyntaxExpr GhcTc -> [CoreExpr] -> DsM CoreExpr


-- | Utility functions for constructing Core syntax, principally for
--   desugaring
module GHC.HsToCore.Utils
data EquationInfo
EqnInfo :: [Pat GhcTc] -> Origin -> MatchResult CoreExpr -> EquationInfo

-- | The patterns for an equation
--   
--   NB: We have <i>already</i> applied <tt>decideBangHood</tt> to these
--   patterns. See Note [decideBangHood] in <a>GHC.HsToCore.Utils</a>
[eqn_pats] :: EquationInfo -> [Pat GhcTc]

-- | Was this equation present in the user source?
--   
--   This helps us avoid warnings on patterns that GHC elaborated.
--   
--   For instance, the pattern <tt>-1 :: Word</tt> gets desugared into
--   <tt>W# -1## :: Word</tt>, but we shouldn't warn about an overflowed
--   literal for <i>both</i> of these cases.
[eqn_orig] :: EquationInfo -> Origin

-- | What to do after match
[eqn_rhs] :: EquationInfo -> MatchResult CoreExpr
firstPat :: EquationInfo -> Pat GhcTc
shiftEqns :: Functor f => f EquationInfo -> f EquationInfo

-- | This is a value of type a with potentially a CoreExpr-shaped hole in
--   it. This is used to deal with cases where we are potentially handling
--   pattern match failure, and want to later specify how failure is
--   handled.
data MatchResult a

-- | We represent the case where there is no hole without a function from
--   <a>CoreExpr</a>, like this, because sometimes we have nothing to put
--   in the hole and so want to be sure there is in fact no hole.
MR_Infallible :: DsM a -> MatchResult a
MR_Fallible :: (CoreExpr -> DsM a) -> MatchResult a
data CaseAlt a
MkCaseAlt :: a -> [Var] -> HsWrapper -> MatchResult CoreExpr -> CaseAlt a
[alt_pat] :: CaseAlt a -> a
[alt_bndrs] :: CaseAlt a -> [Var]
[alt_wrapper] :: CaseAlt a -> HsWrapper
[alt_result] :: CaseAlt a -> MatchResult CoreExpr
cantFailMatchResult :: CoreExpr -> MatchResult CoreExpr
alwaysFailMatchResult :: MatchResult CoreExpr
extractMatchResult :: MatchResult CoreExpr -> CoreExpr -> DsM CoreExpr
combineMatchResults :: MatchResult CoreExpr -> MatchResult CoreExpr -> MatchResult CoreExpr
adjustMatchResultDs :: (a -> DsM b) -> MatchResult a -> MatchResult b
shareFailureHandler :: MatchResult CoreExpr -> MatchResult CoreExpr
dsHandleMonadicFailure :: HsStmtContext GhcRn -> LPat GhcTc -> MatchResult CoreExpr -> FailOperator GhcTc -> DsM CoreExpr
mkCoLetMatchResult :: CoreBind -> MatchResult CoreExpr -> MatchResult CoreExpr
mkViewMatchResult :: Id -> CoreExpr -> MatchResult CoreExpr -> MatchResult CoreExpr
mkGuardedMatchResult :: CoreExpr -> MatchResult CoreExpr -> MatchResult CoreExpr
matchCanFail :: MatchResult a -> Bool
mkEvalMatchResult :: Id -> Type -> MatchResult CoreExpr -> MatchResult CoreExpr
mkCoPrimCaseMatchResult :: Id -> Type -> [(Literal, MatchResult CoreExpr)] -> MatchResult CoreExpr
mkCoAlgCaseMatchResult :: Id -> Type -> NonEmpty (CaseAlt DataCon) -> MatchResult CoreExpr
mkCoSynCaseMatchResult :: Id -> Type -> CaseAlt PatSyn -> MatchResult CoreExpr
wrapBind :: Var -> Var -> CoreExpr -> CoreExpr
wrapBinds :: [(Var, Var)] -> CoreExpr -> CoreExpr
mkErrorAppDs :: Id -> Type -> SDoc -> DsM CoreExpr
mkCoreAppDs :: SDoc -> CoreExpr -> CoreExpr -> CoreExpr
mkCoreAppsDs :: SDoc -> CoreExpr -> [CoreExpr] -> CoreExpr
mkCastDs :: CoreExpr -> Coercion -> CoreExpr
mkFailExpr :: HsMatchContext GhcRn -> Type -> DsM CoreExpr
seqVar :: Var -> CoreExpr -> CoreExpr
mkLHsPatTup :: [LPat GhcTc] -> LPat GhcTc
mkVanillaTuplePat :: [LPat GhcTc] -> Boxity -> Pat GhcTc
mkBigLHsVarTupId :: [Id] -> LHsExpr GhcTc
mkBigLHsTupId :: [LHsExpr GhcTc] -> LHsExpr GhcTc
mkBigLHsVarPatTupId :: [Id] -> LPat GhcTc
mkBigLHsPatTupId :: [LPat GhcTc] -> LPat GhcTc
mkSelectorBinds :: [[CoreTickish]] -> LPat GhcTc -> CoreExpr -> DsM (Id, [(Id, CoreExpr)])
selectSimpleMatchVarL :: Mult -> LPat GhcTc -> DsM Id
selectMatchVars :: [(Mult, Pat GhcTc)] -> DsM [Id]
selectMatchVar :: Mult -> Pat GhcTc -> DsM Id
mkOptTickBox :: [CoreTickish] -> CoreExpr -> CoreExpr
mkBinaryTickBox :: Int -> Int -> CoreExpr -> DsM CoreExpr

-- | Use -XStrict to add a ! or remove a ~ See Note [decideBangHood]
decideBangHood :: DynFlags -> LPat GhcTc -> LPat GhcTc
isTrueLHsExpr :: LHsExpr GhcTc -> Maybe (CoreExpr -> DsM CoreExpr)

module GHC.HsToCore.Match
match :: [MatchId] -> Type -> [EquationInfo] -> DsM (MatchResult CoreExpr)
matchEquations :: HsMatchContext GhcRn -> [MatchId] -> [EquationInfo] -> Type -> DsM CoreExpr
matchWrapper :: HsMatchContext GhcRn -> Maybe (LHsExpr GhcTc) -> MatchGroup GhcTc (LHsExpr GhcTc) -> DsM ([Id], CoreExpr)

-- | <tt>matchSimply</tt> is a wrapper for <a>match</a> which deals with
--   the situation where we want to match a single expression against a
--   single pattern. It returns an expression.
matchSimply :: CoreExpr -> HsMatchContext GhcRn -> LPat GhcTc -> CoreExpr -> CoreExpr -> DsM CoreExpr
matchSinglePat :: CoreExpr -> HsMatchContext GhcRn -> LPat GhcTc -> Type -> MatchResult CoreExpr -> DsM (MatchResult CoreExpr)
matchSinglePatVar :: Id -> Maybe CoreExpr -> HsMatchContext GhcRn -> LPat GhcTc -> Type -> MatchResult CoreExpr -> DsM (MatchResult CoreExpr)


-- | This module coverage checks pattern matches. It finds
--   
--   <ul>
--   <li>Uncovered patterns, certifying non-exhaustivity</li>
--   <li>Redundant equations</li>
--   <li>Equations with an inaccessible right-hand-side</li>
--   </ul>
--   
--   The algorithm is based on the paper <a>Lower Your Guards: A
--   Compositional Pattern-Match Coverage Checker"</a>
--   
--   There is an overview Figure 2 in there that's probably helpful. Here
--   is an overview of how it's implemented, which follows the structure of
--   the entry points such as <a>pmcMatches</a>:
--   
--   <ol>
--   <li>Desugar source syntax (like <a>LMatch</a>) to guard tree variants
--   (like <tt>GrdMatch</tt>), with one of the desugaring functions (like
--   <tt>desugarMatch</tt>). See <a>GHC.HsToCore.Pmc.Desugar</a>. Follows
--   Section 3.1 in the paper.</li>
--   <li>Coverage check guard trees (with a function like
--   <tt>checkMatch</tt>) to get a <a>CheckResult</a>. See
--   <a>GHC.HsToCore.Pmc.Check</a>. The normalised refinement types
--   <a>Nabla</a> are tested for inhabitants by
--   <a>GHC.HsToCore.Pmc.Solver</a>.</li>
--   <li>Collect redundancy information into a <a>CIRB</a> with a function
--   such as <a>cirbsMatch</a>. Follows the R function from Figure 6 of the
--   paper.</li>
--   <li>Format and report uncovered patterns and redundant equations
--   (<a>CIRB</a>) with <a>formatReportWarnings</a>. Basically job of the G
--   function, plus proper pretty printing of the warnings (Section 5.4 of
--   the paper).</li>
--   <li>Return <a>Nablas</a> reaching syntactic sub-components for Note
--   [Long-distance information]. Collected by functions such as
--   <a>ldiMatch</a>. See Section 4.1 of the paper.</li>
--   </ol>
module GHC.HsToCore.Pmc

-- | Check a pattern binding (let, where) for exhaustiveness.
pmcPatBind :: DsMatchContext -> Id -> Pat GhcTc -> DsM ()

-- | Check a list of syntactic <a>Match</a>es (part of case, functions,
--   etc.), each with a <a>Pat</a> and one or more <a>GRHSs</a>:
--   
--   <pre>
--   f x y | x == y    = 1   -- match on x and y with two guarded RHSs
--         | otherwise = 2
--   f _ _             = 3   -- clause with a single, un-guarded RHS
--   </pre>
--   
--   Returns one non-empty <a>Nablas</a> for 1.) each pattern of a
--   <a>Match</a> and 2.) each of a <a>Match</a>es <a>GRHS</a> for Note
--   [Long-distance information].
--   
--   Special case: When there are <i>no matches</i>, then the
--   functionassumes it checks and <tt>-XEmptyCase</tt> with only a single
--   match variable. See Note [Checking EmptyCase].
pmcMatches :: DsMatchContext -> [Id] -> [LMatch GhcTc (LHsExpr GhcTc)] -> DsM [(Nablas, NonEmpty Nablas)]

-- | Exhaustive for guard matches, is used for guards in pattern bindings
--   and in <tt>MultiIf</tt> expressions. Returns the <a>Nablas</a> covered
--   by the RHSs.
pmcGRHSs :: HsMatchContext GhcRn -> GRHSs GhcTc (LHsExpr GhcTc) -> DsM (NonEmpty Nablas)

-- | Check whether any part of pattern match checking is enabled for this
--   <a>HsMatchContext</a> (does not matter whether it is the redundancy
--   check or the exhaustiveness check).
isMatchContextPmChecked :: DynFlags -> Origin -> HsMatchContext id -> Bool

-- | Add in-scope type constraints if the coverage checker might run and
--   then run the given action.
addTyCs :: Origin -> Bag EvVar -> DsM a -> DsM a

-- | Add equalities for the <a>CoreExpr</a> scrutinee to the local
--   <a>DsM</a> environment when checking a case expression: case e of x {
--   matches } When checking matches we record that (x ~ e) where x is the
--   initial uncovered. All matches will have to satisfy this equality.
addCoreScrutTmCs :: Maybe CoreExpr -> [Id] -> DsM a -> DsM a

-- | <a>addCoreScrutTmCs</a>, but desugars the <a>LHsExpr</a> first.
addHsScrutTmCs :: Maybe (LHsExpr GhcTc) -> [Id] -> DsM a -> DsM a
instance GHC.Base.Semigroup GHC.HsToCore.Pmc.CIRB
instance GHC.Base.Monoid GHC.HsToCore.Pmc.CIRB


-- | Utility module for the pattern-match coverage checker.
module GHC.HsToCore.Pmc.Utils
tracePm :: String -> SDoc -> DsM ()

-- | Generate a fresh <a>Id</a> of a given type
mkPmId :: Type -> DsM Id

-- | All warning flags that need to run the pattern match checker.
allPmCheckWarnings :: [WarningFlag]

-- | Check whether the redundancy checker should run (redundancy only)
overlapping :: DynFlags -> HsMatchContext id -> Bool

-- | Check whether the exhaustiveness checker should run (exhaustiveness
--   only)
exhaustive :: DynFlags -> HsMatchContext id -> Bool

-- | Check whether unnecessary bangs should be warned about
redundantBang :: DynFlags -> Bool

-- | Denotes whether an exhaustiveness check is supported, and if so, via
--   which <a>WarningFlag</a> it's controlled. Returns <a>Nothing</a> if
--   check is not supported.
exhaustiveWarningFlag :: HsMatchContext id -> Maybe WarningFlag

-- | Check whether any part of pattern match checking is enabled for this
--   <a>HsMatchContext</a> (does not matter whether it is the redundancy
--   check or the exhaustiveness check).
isMatchContextPmChecked :: DynFlags -> Origin -> HsMatchContext id -> Bool

-- | Return True when any of the pattern match warnings
--   (<a>allPmCheckWarnings</a>) are enabled, in which case we need to run
--   the pattern match checker.
needToRunPmCheck :: DynFlags -> Origin -> Bool


-- | Model refinements type as per the <a>Lower Your Guards paper</a>. The
--   main export of the module are the functions <a>addPhiCtsNablas</a> for
--   adding facts to the oracle, <a>isInhabited</a> to check if a
--   refinement type is inhabited and <a>generateInhabitingPatterns</a> to
--   turn a <a>Nabla</a> into a concrete pattern for an equation.
--   
--   In terms of the LYG paper, this module is concerned with Sections 3.4,
--   3.6 and 3.7. E.g., it represents refinement types directly as a bunch
--   of normalised refinement types <a>Nabla</a>.
module GHC.HsToCore.Pmc.Solver

-- | A normalised refinement type â ("nabla"), comprised of an inert set of
--   canonical (i.e. mutually compatible) term and type constraints that
--   form the refinement type's predicate.
data Nabla

-- | A disjunctive bag of <a>Nabla</a>s, representing a refinement type.
newtype Nablas
MkNablas :: Bag Nabla -> Nablas
initNablas :: Nablas
lookupRefuts :: Nabla -> Id -> [PmAltCon]
lookupSolution :: Nabla -> Id -> Maybe PmAltConApp

-- | A high-level pattern-match constraint. Corresponds to Ï from Figure 3
--   of the LYG paper.
data PhiCt

-- | A type constraint "T ~ U".
PhiTyCt :: !PredType -> PhiCt

-- | <tt>PhiCoreCt x e</tt> encodes "x ~ e", equating <tt>x</tt> with the
--   <a>CoreExpr</a> <tt>e</tt>.
PhiCoreCt :: !Id -> !CoreExpr -> PhiCt

-- | <tt>PhiConCt x K tvs dicts ys</tt> encodes <tt>K @tvs dicts ys &lt;-
--   x</tt>, matching <tt>x</tt> against the <a>PmAltCon</a> application
--   <tt>K @tvs dicts ys</tt>, binding <tt>tvs</tt>, <tt>dicts</tt> and
--   possibly unlifted fields <tt>ys</tt> in the process. See Note [Strict
--   fields and variables of unlifted type].
PhiConCt :: !Id -> !PmAltCon -> ![TyVar] -> ![PredType] -> ![Id] -> PhiCt

-- | <tt>PhiNotConCt x K</tt> encodes "x â K", asserting that <tt>x</tt>
--   can't be headed by <tt>K</tt>.
PhiNotConCt :: !Id -> !PmAltCon -> PhiCt

-- | <tt>PhiBotCt x</tt> encodes "x ~ â¥", equating <tt>x</tt> to â¥. by
--   <tt>K</tt>.
PhiBotCt :: !Id -> PhiCt

-- | <tt>PhiNotBotCt x y</tt> encodes "x â â¥", asserting that <tt>x</tt>
--   can't be â¥.
PhiNotBotCt :: !Id -> PhiCt
type PhiCts = Bag PhiCt

-- | <tt>addPmCtsNablas</tt> for a single <tt>PmCt</tt>.
addPhiCtNablas :: Nablas -> PhiCt -> DsM Nablas

-- | Add a bunch of <a>PhiCt</a>s to all the <a>Nabla</a>s. Lifts
--   <a>addPhiCts</a> over many <a>Nablas</a>.
addPhiCtsNablas :: Nablas -> PhiCts -> DsM Nablas

-- | Test if any of the <a>Nabla</a>s is inhabited. Currently this is pure,
--   because we preserve the invariant that there are no uninhabited
--   <a>Nabla</a>s. But that could change in the future, for example by
--   implementing this function in terms of <tt>notNull <a>$</a>
--   generateInhabitingPatterns 1 ds</tt>.
isInhabited :: Nablas -> DsM Bool

-- | <tt>generateInhabitingPatterns vs n nabla</tt> returns a list of at
--   most <tt>n</tt> (but perhaps empty) refinements of <tt>nabla</tt> that
--   represent inhabited patterns. Negative information is only retained if
--   literals are involved or for recursive GADTs.
generateInhabitingPatterns :: [Id] -> Int -> Nabla -> DsM [Nabla]
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.PhiCt
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.TopNormaliseTypeResult


-- | Provides factilities for pretty-printing <a>Nabla</a>s in a way
--   appropriate for user facing pattern match warnings.
module GHC.HsToCore.Pmc.Ppr

-- | Pretty-print the guts of an uncovered value vector abstraction, i.e.,
--   its components and refutable shapes associated to any mentioned
--   variables.
--   
--   Example for <tt>([Just p, q], [p :-&gt; [3,4], q :-&gt; [0,5]])</tt>:
--   
--   <pre>
--   (Just p) q
--       where p is not one of {3, 4}
--             q is not one of {0, 5}
--   </pre>
--   
--   When the set of refutable shapes contains more than 3 elements, the
--   additional elements are indicated by "...".
pprUncovered :: Nabla -> [Id] -> SDoc


-- | Desugaring step of the <a>Lower Your Guards paper</a>.
--   
--   Desugars Haskell source syntax into guard tree variants Pm*. In terms
--   of the paper, this module is concerned with Sections 3.1, Figure 4, in
--   particular.
module GHC.HsToCore.Pmc.Desugar
desugarPatBind :: SrcSpan -> Id -> Pat GhcTc -> DsM (PmPatBind Pre)
desugarGRHSs :: SrcSpan -> SDoc -> GRHSs GhcTc (LHsExpr GhcTc) -> DsM (PmGRHSs Pre)

-- | Desugar the non-empty <a>Match</a>es of a <a>MatchGroup</a>.
desugarMatches :: [Id] -> NonEmpty (LMatch GhcTc (LHsExpr GhcTc)) -> DsM (PmMatchGroup Pre)
desugarEmptyCase :: Id -> DsM PmEmptyCase

module GHC.HsToCore.Match.Literal
dsLit :: HsLit GhcRn -> DsM CoreExpr

-- | Post-typechecker, the <a>HsExpr</a> field of an <a>OverLit</a>
--   contains (an expression for) the literal value itself.
dsOverLit :: HsOverLit GhcTc -> DsM CoreExpr
hsLitKey :: Platform -> HsLit GhcTc -> Literal
tidyLitPat :: HsLit GhcTc -> Pat GhcTc
tidyNPat :: HsOverLit GhcTc -> Maybe (SyntaxExpr GhcTc) -> SyntaxExpr GhcTc -> Type -> Pat GhcTc
matchLiterals :: NonEmpty Id -> Type -> NonEmpty (NonEmpty EquationInfo) -> DsM (MatchResult CoreExpr)
matchNPlusKPats :: NonEmpty Id -> Type -> NonEmpty EquationInfo -> DsM (MatchResult CoreExpr)
matchNPats :: NonEmpty Id -> Type -> NonEmpty EquationInfo -> DsM (MatchResult CoreExpr)
warnAboutIdentities :: DynFlags -> Id -> Type -> DsM ()

-- | Emit warnings on overloaded integral literals which overflow the
--   bounds implied by their type.
warnAboutOverflowedOverLit :: HsOverLit GhcTc -> DsM ()

-- | Emit warnings on integral literals which overflow the bounds implied
--   by their type.
warnAboutOverflowedLit :: HsLit GhcTc -> DsM ()

-- | Warns about <tt>[2,3 .. 1]</tt> or <tt>[<tt>b</tt> .. <tt>a</tt>]</tt>
--   which return the empty list. For numeric literals, only works for
--   integral types, not floating point.
warnAboutEmptyEnumerations :: FamInstEnvs -> DynFlags -> LHsExpr GhcTc -> Maybe (LHsExpr GhcTc) -> LHsExpr GhcTc -> DsM ()

module GHC.HsToCore.Binds

-- | Desugar top level binds, strict binds are treated like normal binds
--   since there is no good time to force before first usage.
dsTopLHsBinds :: LHsBinds GhcTc -> DsM (OrdList (Id, CoreExpr))

-- | Desugar all other kind of bindings, Ids of strict binds are returned
--   to later be forced in the binding group body, see Note [Desugar Strict
--   binds]
dsLHsBinds :: LHsBinds GhcTc -> DsM ([Id], [(Id, CoreExpr)])
decomposeRuleLhs :: DynFlags -> [Var] -> CoreExpr -> Either SDoc ([Var], Id, [CoreExpr])
dsSpec :: Maybe CoreExpr -> Located TcSpecPrag -> DsM (Maybe (OrdList (Id, CoreExpr), CoreRule))
dsHsWrapper :: HsWrapper -> DsM (CoreExpr -> CoreExpr)
dsEvTerm :: EvTerm -> DsM CoreExpr
dsTcEvBinds :: TcEvBinds -> DsM [CoreBind]
dsTcEvBinds_s :: [TcEvBinds] -> DsM [CoreBind]
dsEvBinds :: Bag EvBind -> DsM [CoreBind]
dsMkUserRule :: Module -> Bool -> RuleName -> Activation -> Name -> [CoreBndr] -> [CoreExpr] -> CoreExpr -> DsM CoreRule

module GHC.HsToCore.GuardedRHSs
dsGuarded :: GRHSs GhcTc (LHsExpr GhcTc) -> Type -> NonEmpty Nablas -> DsM CoreExpr
dsGRHSs :: HsMatchContext GhcRn -> GRHSs GhcTc (LHsExpr GhcTc) -> Type -> NonEmpty Nablas -> DsM (MatchResult CoreExpr)
isTrueLHsExpr :: LHsExpr GhcTc -> Maybe (CoreExpr -> DsM CoreExpr)


-- | Coverage checking step of the <a>Lower Your Guards paper</a>.
--   
--   Coverage check guard trees (like <tt><a>PmMatch</a> <a>Pre</a></tt>)
--   to get a <a>CheckResult</a>, containing
--   
--   <ol>
--   <li>The set of uncovered values, <a>cr_uncov</a></li>
--   <li>And an annotated tree variant (like <tt><a>PmMatch</a>
--   <a>Post</a></tt>) that captures redundancy and inaccessibility
--   information as <a>RedSets</a> annotations</li>
--   </ol>
--   
--   Basically the UA function from Section 5.1, which is an optimised
--   interleaving of U and A from Section 3.2 (Figure 5). The Normalised
--   Refinement Types <a>Nablas</a> are maintained in
--   <a>GHC.HsToCore.Pmc.Solver</a>.
module GHC.HsToCore.Pmc.Check

-- | Coverage checking action. Can be composed <a>leftToRight</a> or
--   <a>topToBottom</a>.
newtype CheckAction a
CA :: (Nablas -> DsM (CheckResult a)) -> CheckAction a
[unCA] :: CheckAction a -> Nablas -> DsM (CheckResult a)
checkMatchGroup :: PmMatchGroup Pre -> CheckAction (PmMatchGroup Post)
checkGRHSs :: PmGRHSs Pre -> CheckAction (PmGRHSs Post)
checkPatBind :: PmPatBind Pre -> CheckAction (PmPatBind Post)
checkEmptyCase :: PmEmptyCase -> CheckAction PmEmptyCase
instance GHC.Base.Functor GHC.HsToCore.Pmc.Check.CheckAction

module GHC.HsToCore.Match.Constructor
matchConFamily :: NonEmpty Id -> Type -> NonEmpty (NonEmpty EquationInfo) -> DsM (MatchResult CoreExpr)
matchPatSyn :: NonEmpty Id -> Type -> NonEmpty EquationInfo -> DsM (MatchResult CoreExpr)

module GHC.HsToCore.Quote
dsBracket :: Maybe QuoteWrapper -> HsBracket GhcRn -> [PendingTcSplice] -> DsM CoreExpr
instance GHC.HsToCore.Quote.RepTV () ()
instance GHC.HsToCore.Quote.RepTV GHC.Types.Var.Specificity Language.Haskell.TH.Syntax.Specificity

module GHC.HsToCore.ListComp
dsListComp :: [ExprLStmt GhcTc] -> Type -> DsM CoreExpr
dsMonadComp :: [ExprLStmt GhcTc] -> DsM CoreExpr

module GHC.HsToCore.Arrows
dsProcExpr :: LPat GhcTc -> LHsCmdTop GhcTc -> DsM CoreExpr


-- | Typechecking patterns
module GHC.Tc.Gen.Pat
tcLetPat :: (Name -> Maybe TcId) -> LetBndrSpec -> LPat GhcRn -> Scaled ExpSigmaType -> TcM a -> TcM (LPat GhcTc, a)
newLetBndr :: LetBndrSpec -> Name -> Mult -> TcType -> TcM TcId
data LetBndrSpec
LetLclBndr :: LetBndrSpec
LetGblBndr :: TcPragEnv -> LetBndrSpec
tcCheckPat :: HsMatchContext GhcRn -> LPat GhcRn -> Scaled TcSigmaType -> TcM a -> TcM (LPat GhcTc, a)

-- | A variant of <tt>tcPat</tt> that takes a custom origin
tcCheckPat_O :: HsMatchContext GhcRn -> CtOrigin -> LPat GhcRn -> Scaled TcSigmaType -> TcM a -> TcM (LPat GhcTc, a)
tcInferPat :: HsMatchContext GhcRn -> LPat GhcRn -> TcM a -> TcM ((LPat GhcTc, a), TcSigmaType)
tcPats :: HsMatchContext GhcRn -> [LPat GhcRn] -> [Scaled ExpSigmaType] -> TcM a -> TcM ([LPat GhcTc], a)
addDataConStupidTheta :: DataCon -> [TcType] -> TcM ()
badFieldCon :: ConLike -> FieldLabelString -> SDoc
polyPatSig :: TcType -> SDoc
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.Pat.LetBndrSpec

module GHC.Tc.Gen.Sig
data TcSigInfo
TcIdSig :: TcIdSigInfo -> TcSigInfo
TcPatSynSig :: TcPatSynInfo -> TcSigInfo
data TcIdSigInfo
CompleteSig :: TcId -> UserTypeCtxt -> SrcSpan -> TcIdSigInfo
[sig_bndr] :: TcIdSigInfo -> TcId
[sig_ctxt] :: TcIdSigInfo -> UserTypeCtxt
[sig_loc] :: TcIdSigInfo -> SrcSpan
PartialSig :: Name -> LHsSigWcType GhcRn -> UserTypeCtxt -> SrcSpan -> TcIdSigInfo
[psig_name] :: TcIdSigInfo -> Name
[psig_hs_ty] :: TcIdSigInfo -> LHsSigWcType GhcRn
[sig_ctxt] :: TcIdSigInfo -> UserTypeCtxt
[sig_loc] :: TcIdSigInfo -> SrcSpan
data TcIdSigInst
data TcPatSynInfo
TPSI :: Name -> [InvisTVBinder] -> [InvisTVBinder] -> TcThetaType -> [InvisTVBinder] -> TcThetaType -> TcSigmaType -> TcPatSynInfo
[patsig_name] :: TcPatSynInfo -> Name
[patsig_implicit_bndrs] :: TcPatSynInfo -> [InvisTVBinder]
[patsig_univ_bndrs] :: TcPatSynInfo -> [InvisTVBinder]
[patsig_req] :: TcPatSynInfo -> TcThetaType
[patsig_ex_bndrs] :: TcPatSynInfo -> [InvisTVBinder]
[patsig_prov] :: TcPatSynInfo -> TcThetaType
[patsig_body_ty] :: TcPatSynInfo -> TcSigmaType
type TcSigFun = Name -> Maybe TcSigInfo
isPartialSig :: TcIdSigInst -> Bool

-- | No signature or a partial signature
hasCompleteSig :: TcSigFun -> Name -> Bool
tcIdSigName :: TcIdSigInfo -> Name
tcSigInfoName :: TcSigInfo -> Name
completeSigPolyId_maybe :: TcSigInfo -> Maybe TcId

-- | If there are no wildcards, return a LHsSigWcType
isCompleteHsSig :: LHsSigWcType GhcRn -> Bool
tcTySigs :: [LSig GhcRn] -> TcM ([TcId], TcSigFun)
tcUserTypeSig :: SrcSpan -> LHsSigWcType GhcRn -> Maybe Name -> TcM TcIdSigInfo
completeSigFromId :: UserTypeCtxt -> Id -> TcIdSigInfo
tcInstSig :: TcIdSigInfo -> TcM TcIdSigInst
type TcPragEnv = NameEnv [LSig GhcRn]
emptyPragEnv :: TcPragEnv
lookupPragEnv :: TcPragEnv -> Name -> [LSig GhcRn]
extendPragEnv :: TcPragEnv -> (Name, LSig GhcRn) -> TcPragEnv
mkPragEnv :: [LSig GhcRn] -> LHsBinds GhcRn -> TcPragEnv
tcSpecPrags :: Id -> [LSig GhcRn] -> TcM [LTcSpecPrag]
tcSpecWrapper :: UserTypeCtxt -> TcType -> TcType -> TcM HsWrapper
tcImpPrags :: [LSig GhcRn] -> TcM [LTcSpecPrag]
addInlinePrags :: TcId -> [LSig GhcRn] -> TcM TcId
addInlinePragArity :: Arity -> LSig GhcRn -> LSig GhcRn


-- | Typecheck some <tt>Matches</tt>
module GHC.Tc.Gen.Match
tcMatchesFun :: LocatedN Name -> MatchGroup GhcRn (LHsExpr GhcRn) -> ExpRhoType -> TcM (HsWrapper, MatchGroup GhcTc (LHsExpr GhcTc))
tcGRHS :: TcMatchCtxt body -> ExpRhoType -> GRHS GhcRn (LocatedA (body GhcRn)) -> TcM (GRHS GhcTc (LocatedA (body GhcTc)))
tcGRHSsPat :: GRHSs GhcRn (LHsExpr GhcRn) -> ExpRhoType -> TcM (GRHSs GhcTc (LHsExpr GhcTc))
tcMatchesCase :: AnnoBody body => TcMatchCtxt body -> Scaled TcSigmaType -> MatchGroup GhcRn (LocatedA (body GhcRn)) -> ExpRhoType -> TcM (MatchGroup GhcTc (LocatedA (body GhcTc)))
tcMatchLambda :: SDoc -> TcMatchCtxt HsExpr -> MatchGroup GhcRn (LHsExpr GhcRn) -> ExpRhoType -> TcM (HsWrapper, MatchGroup GhcTc (LHsExpr GhcTc))
data TcMatchCtxt body
MC :: HsMatchContext GhcRn -> (LocatedA (body GhcRn) -> ExpRhoType -> TcM (LocatedA (body GhcTc))) -> TcMatchCtxt body
[mc_what] :: TcMatchCtxt body -> HsMatchContext GhcRn
[mc_body] :: TcMatchCtxt body -> LocatedA (body GhcRn) -> ExpRhoType -> TcM (LocatedA (body GhcTc))
type TcStmtChecker body rho_type = forall thing. HsStmtContext GhcRn -> Stmt GhcRn (LocatedA (body GhcRn)) -> rho_type -> (rho_type -> TcM thing) -> TcM (Stmt GhcTc (LocatedA (body GhcTc)), thing)
type TcExprStmtChecker = TcStmtChecker HsExpr ExpRhoType
type TcCmdStmtChecker = TcStmtChecker HsCmd TcRhoType
tcStmts :: AnnoBody body => HsStmtContext GhcRn -> TcStmtChecker body rho_type -> [LStmt GhcRn (LocatedA (body GhcRn))] -> rho_type -> TcM [LStmt GhcTc (LocatedA (body GhcTc))]
tcStmtsAndThen :: AnnoBody body => HsStmtContext GhcRn -> TcStmtChecker body rho_type -> [LStmt GhcRn (LocatedA (body GhcRn))] -> rho_type -> (rho_type -> TcM thing) -> TcM ([LStmt GhcTc (LocatedA (body GhcTc))], thing)
tcDoStmts :: HsStmtContext GhcRn -> LocatedL [LStmt GhcRn (LHsExpr GhcRn)] -> ExpRhoType -> TcM (HsExpr GhcTc)
tcBody :: LHsExpr GhcRn -> ExpRhoType -> TcM (LHsExpr GhcTc)
tcDoStmt :: TcExprStmtChecker
tcGuardStmt :: TcExprStmtChecker

module GHC.Tc.Gen.Head
data HsExprArg (p :: TcPass)
EValArg :: AppCtxt -> EValArg p -> !XEVAType p -> HsExprArg (p :: TcPass)
[eva_ctxt] :: HsExprArg (p :: TcPass) -> AppCtxt
[eva_arg] :: HsExprArg (p :: TcPass) -> EValArg p
[eva_arg_ty] :: HsExprArg (p :: TcPass) -> !XEVAType p
ETypeArg :: AppCtxt -> LHsWcType GhcRn -> !XETAType p -> HsExprArg (p :: TcPass)
[eva_ctxt] :: HsExprArg (p :: TcPass) -> AppCtxt
[eva_hs_ty] :: HsExprArg (p :: TcPass) -> LHsWcType GhcRn
[eva_ty] :: HsExprArg (p :: TcPass) -> !XETAType p
EPrag :: AppCtxt -> HsPragE (GhcPass (XPass p)) -> HsExprArg (p :: TcPass)
EWrap :: EWrap -> HsExprArg (p :: TcPass)
data EValArg (p :: TcPass)
[ValArg] :: LHsExpr (GhcPass (XPass p)) -> EValArg p
[ValArgQL] :: LHsExpr GhcRn -> (HsExpr GhcTc, AppCtxt) -> [HsExprArg 'TcpInst] -> TcRhoType -> EValArg 'TcpInst
data TcPass
TcpRn :: TcPass
TcpInst :: TcPass
TcpTc :: TcPass
data AppCtxt
VAExpansion :: HsExpr GhcRn -> SrcSpan -> AppCtxt
VACall :: HsExpr GhcRn -> Int -> SrcSpan -> AppCtxt
appCtxtLoc :: AppCtxt -> SrcSpan
insideExpansion :: AppCtxt -> Bool
splitHsApps :: HsExpr GhcRn -> ((HsExpr GhcRn, AppCtxt), [HsExprArg 'TcpRn])
rebuildHsApps :: HsExpr GhcTc -> AppCtxt -> [HsExprArg 'TcpTc] -> HsExpr GhcTc
addArgWrap :: HsWrapper -> [HsExprArg 'TcpInst] -> [HsExprArg 'TcpInst]
isHsValArg :: HsExprArg id -> Bool
countLeadingValArgs :: [HsExprArg id] -> Int
isVisibleArg :: HsExprArg id -> Bool
pprHsExprArgTc :: HsExprArg 'TcpInst -> SDoc
tcInferAppHead :: (HsExpr GhcRn, AppCtxt) -> [HsExprArg 'TcpRn] -> Maybe TcRhoType -> TcM (HsExpr GhcTc, TcSigmaType)
tcInferAppHead_maybe :: HsExpr GhcRn -> [HsExprArg 'TcpRn] -> Maybe TcRhoType -> TcM (Maybe (HsExpr GhcTc, TcSigmaType))
tcInferId :: Name -> TcM (HsExpr GhcTc, TcSigmaType)
tcCheckId :: Name -> ExpRhoType -> TcM (HsExpr GhcTc)
obviousSig :: HsExpr GhcRn -> Maybe (LHsSigWcType GhcRn)

-- | This name really is ambiguous, so add a suitable "ambiguous
--   occurrence" error, then continue
addAmbiguousNameErr :: RdrName -> TcM ()
tyConOf :: FamInstEnvs -> TcSigmaType -> Maybe TyCon
tyConOfET :: FamInstEnvs -> ExpRhoType -> Maybe TyCon
lookupParents :: Bool -> RdrName -> RnM [(RecSelParent, GlobalRdrElt)]
fieldNotInType :: RecSelParent -> RdrName -> SDoc
notSelector :: Name -> SDoc
nonBidirectionalErr :: Outputable name => name -> SDoc
addExprCtxt :: HsExpr GhcRn -> TcRn a -> TcRn a
addFunResCtxt :: HsExpr GhcRn -> [HsExprArg 'TcpRn] -> TcType -> ExpRhoType -> TcM a -> TcM a
instance GHC.Hs.Extension.OutputableBndrId (GHC.Tc.Gen.Head.XPass p) => GHC.Utils.Outputable.Outputable (GHC.Tc.Gen.Head.HsExprArg p)
instance GHC.Hs.Extension.OutputableBndrId (GHC.Tc.Gen.Head.XPass p) => GHC.Utils.Outputable.Outputable (GHC.Tc.Gen.Head.EValArg p)
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.Head.EWrap
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.Head.AppCtxt


-- | Typechecking pattern synonym declarations
module GHC.Tc.TyCl.PatSyn
tcPatSynDecl :: LocatedA (PatSynBind GhcRn GhcRn) -> TcSigFun -> TcPragEnv -> TcM (LHsBinds GhcTc, TcGblEnv)
tcPatSynBuilderBind :: TcPragEnv -> PatSynBind GhcRn GhcRn -> TcM (LHsBinds GhcTc)
patSynBuilderOcc :: PatSyn -> Maybe (HsExpr GhcTc, TcSigmaType)


-- | Analysis functions over data types. Specifically, detecting recursive
--   types.
--   
--   This stuff is only used for source-code decls; it's recorded in
--   interface files for imported data types.
module GHC.Tc.TyCl.Utils
type RolesInfo = Name -> [Role]
inferRoles :: HscSource -> RoleAnnotEnv -> [TyCon] -> Name -> [Role]

-- | Checks if any of the passed in <a>TyCon</a>s have cycles. Takes the
--   <a>Unit</a> of the home package (as we can avoid checking those
--   TyCons: cycles never go through foreign packages) and the
--   corresponding <tt>LTyClDecl Name</tt> for each <a>TyCon</a>, so we can
--   give better error messages.
checkSynCycles :: Unit -> [TyCon] -> [LTyClDecl GhcRn] -> TcM ()
checkClassCycles :: Class -> Maybe SDoc
addTyConsToGblEnv :: [TyCon] -> TcM TcGblEnv
mkDefaultMethodType :: Class -> Id -> DefMethSpec Type -> Type
tcRecSelBinds :: [(Id, LHsBind GhcRn)] -> TcM TcGblEnv
mkRecSelBinds :: [TyCon] -> [(Id, LHsBind GhcRn)]
mkOneRecordSelector :: [ConLike] -> RecSelParent -> FieldLabel -> FieldSelectors -> (Id, LHsBind GhcRn)
instance GHC.Base.Functor GHC.Tc.TyCl.Utils.SynCycleM
instance GHC.Base.Functor GHC.Tc.TyCl.Utils.RoleM
instance GHC.Base.Applicative GHC.Tc.TyCl.Utils.RoleM
instance GHC.Base.Monad GHC.Tc.TyCl.Utils.RoleM
instance GHC.Base.Applicative GHC.Tc.TyCl.Utils.SynCycleM
instance GHC.Base.Monad GHC.Tc.TyCl.Utils.SynCycleM

module GHC.Tc.Gen.Bind
tcLocalBinds :: HsLocalBinds GhcRn -> TcM thing -> TcM (HsLocalBinds GhcTc, thing)
tcTopBinds :: [(RecFlag, LHsBinds GhcRn)] -> [LSig GhcRn] -> TcM (TcGblEnv, TcLclEnv)
tcValBinds :: TopLevelFlag -> [(RecFlag, LHsBinds GhcRn)] -> [LSig GhcRn] -> TcM thing -> TcM ([(RecFlag, LHsBinds GhcTc)], thing)
tcHsBootSigs :: [(RecFlag, LHsBinds GhcRn)] -> [LSig GhcRn] -> TcM [Id]
tcPolyCheck :: TcPragEnv -> TcIdSigInfo -> LHsBind GhcRn -> TcM (LHsBinds GhcTc, [TcId])
chooseInferredQuantifiers :: TcThetaType -> TcTyVarSet -> [TcTyVar] -> Maybe TcIdSigInst -> TcM ([InvisTVBinder], TcThetaType)
badBootDeclErr :: SDoc
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.Bind.GeneralisationPlan


-- | Typecheck arrow notation
module GHC.Tc.Gen.Arrow
tcProc :: LPat GhcRn -> LHsCmdTop GhcRn -> ExpRhoType -> TcM (LPat GhcTc, LHsCmdTop GhcTc, TcCoercion)

module GHC.Tc.Gen.App
tcApp :: HsExpr GhcRn -> ExpRhoType -> TcM (HsExpr GhcTc)
tcInferSigma :: Bool -> LHsExpr GhcRn -> TcM TcSigmaType
tcExprPrag :: HsPragE GhcRn -> HsPragE GhcTc


-- | Typechecking a whole module
--   
--   
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/type-checker</a>
module GHC.Tc.Module

-- | The returned [Id] is the list of new Ids bound by this statement. It
--   can be used to extend the InteractiveContext via
--   extendInteractiveContext.
--   
--   The returned TypecheckedHsExpr is of type IO [ () ], a list of the
--   bound values, coerced to ().
tcRnStmt :: HscEnv -> GhciLStmt GhcPs -> IO (Messages DecoratedSDoc, Maybe ([Id], LHsExpr GhcTc, FixityEnv))

-- | tcRnExpr just finds the type of an expression for :type
tcRnExpr :: HscEnv -> TcRnExprMode -> LHsExpr GhcPs -> IO (Messages DecoratedSDoc, Maybe Type)

-- | How should we infer a type? See Note [TcRnExprMode]
data TcRnExprMode

-- | Instantiate inferred quantifiers only (:type)
TM_Inst :: TcRnExprMode

-- | Instantiate all quantifiers, and do eager defaulting (:type +d)
TM_Default :: TcRnExprMode
tcRnType :: HscEnv -> ZonkFlexi -> Bool -> LHsType GhcPs -> IO (Messages DecoratedSDoc, Maybe (Type, Kind))
tcRnImportDecls :: HscEnv -> [LImportDecl GhcPs] -> IO (Messages DecoratedSDoc, Maybe GlobalRdrEnv)

-- | Find all the Names that this RdrName could mean, in GHCi
tcRnLookupRdrName :: HscEnv -> LocatedN RdrName -> IO (Messages DecoratedSDoc, Maybe [Name])

-- | ASSUMES that the module is either in the <tt>HomePackageTable</tt> or
--   is a package module with an interface on disk. If neither of these is
--   true, then the result will be an error indicating the interface could
--   not be found.
getModuleInterface :: HscEnv -> Module -> IO (Messages DecoratedSDoc, Maybe ModIface)
tcRnDeclsi :: HscEnv -> [LHsDecl GhcPs] -> IO (Messages DecoratedSDoc, Maybe TcGblEnv)
isGHCiMonad :: HscEnv -> String -> IO (Messages DecoratedSDoc, Maybe Name)
runTcInteractive :: HscEnv -> TcRn a -> IO (Messages DecoratedSDoc, Maybe a)
tcRnLookupName :: HscEnv -> Name -> IO (Messages DecoratedSDoc, Maybe TyThing)
tcRnGetInfo :: HscEnv -> Name -> IO (Messages DecoratedSDoc, Maybe (TyThing, Fixity, [ClsInst], [FamInst], SDoc))

-- | Top level entry point for typechecker and renamer
tcRnModule :: HscEnv -> ModSummary -> Bool -> HsParsedModule -> IO (Messages DecoratedSDoc, Maybe TcGblEnv)
tcRnModuleTcRnM :: HscEnv -> ModSummary -> HsParsedModule -> (Module, SrcSpan) -> TcRn TcGblEnv
tcTopSrcDecls :: HsGroup GhcRn -> TcM (TcGblEnv, TcLclEnv)
rnTopSrcDecls :: HsGroup GhcPs -> TcM (TcGblEnv, HsGroup GhcRn)

-- | Compares the two things for equivalence between boot-file and normal
--   code. Returns <tt>Nothing</tt> on success or <tt>Just "some helpful
--   info for user"</tt> failure. If the difference will be apparent to the
--   user, <tt>Just empty</tt> is perfectly suitable.
checkBootDecl :: Bool -> TyThing -> TyThing -> Maybe SDoc
checkHiBootIface' :: [ClsInst] -> TypeEnv -> [AvailInfo] -> ModDetails -> TcM [(Id, Id)]

-- | <a>findExtraSigImports</a>, but in a convenient form for
--   <a>GHC.Driver.Make</a> and <a>GHC.Tc.Module</a>.
findExtraSigImports :: HscEnv -> HscSource -> ModuleName -> IO [(Maybe FastString, Located ModuleName)]
implicitRequirements :: HscEnv -> [(Maybe FastString, Located ModuleName)] -> IO [(Maybe FastString, Located ModuleName)]

-- | Given a <a>Unit</a>, make sure it is well typed. This is because unit
--   IDs come from Cabal, which does not know if things are well-typed or
--   not; a component may have been filled with implementations for the
--   holes that don't actually fulfill the requirements.
checkUnit :: Unit -> TcM ()

-- | Given a local <a>ModIface_</a>, merge all inherited requirements from
--   <a>requirementMerges</a> into this signature, producing a final
--   <a>TcGblEnv</a> that matches the local signature and all required
--   signatures.
mergeSignatures :: HsParsedModule -> TcGblEnv -> ModIface -> TcRn TcGblEnv

-- | Top-level driver for signature merging (run after typechecking an
--   <tt>hsig</tt> file).
tcRnMergeSignatures :: HscEnv -> HsParsedModule -> TcGblEnv -> ModIface -> IO (Messages DecoratedSDoc, Maybe TcGblEnv)

-- | Given <a>tcg_mod</a>, instantiate a <a>ModIface_</a> from the
--   indefinite library to use the actual implementations of the relevant
--   entities, checking that the implementation matches the signature.
instantiateSignature :: TcRn TcGblEnv

-- | Top-level driver for signature instantiation (run when compiling an
--   <tt>hsig</tt> file.)
tcRnInstantiateSignature :: HscEnv -> Module -> RealSrcSpan -> IO (Messages DecoratedSDoc, Maybe TcGblEnv)
loadUnqualIfaces :: HscEnv -> InteractiveContext -> TcM ()
badReexportedBootThing :: Bool -> Name -> Name -> SDoc

-- | Compares two things for equivalence between boot-file and normal code,
--   reporting an error if they don't match up.
checkBootDeclM :: Bool -> TyThing -> TyThing -> TcM ()
missingBootThing :: Bool -> Name -> String -> SDoc

-- | Extract the renamed information from TcGblEnv.
getRenamedStuff :: TcGblEnv -> RenamedStuff
type RenamedStuff = (Maybe (HsGroup GhcRn, [LImportDecl GhcRn], Maybe [(LIE GhcRn, Avails)], Maybe LHsDocString))

module GHC.Types.TyThing.Ppr

-- | Pretty-prints a <a>TyThing</a>.
pprTyThing :: ShowSub -> TyThing -> SDoc

-- | Pretty-prints a <a>TyThing</a> in context: that is, if the entity is a
--   data constructor, record selector, or class method, then the entity's
--   parent declaration is pretty-printed with irrelevant parts omitted.
pprTyThingInContext :: ShowSub -> TyThing -> SDoc

-- | Pretty-prints a <a>TyThing</a> with its defining location.
pprTyThingLoc :: TyThing -> SDoc

-- | Like <a>pprTyThingInContext</a>, but adds the defining location.
pprTyThingInContextLoc :: TyThing -> SDoc

-- | Pretty-prints the <a>TyThing</a> header. For functions and data
--   constructors the function is equivalent to <a>pprTyThing</a> but for
--   type constructors and classes it prints only the header part of the
--   declaration.
pprTyThingHdr :: TyThing -> SDoc
pprTypeForUser :: Type -> SDoc

-- | Pretty-prints a <a>FamInst</a> (type/data family instance) with its
--   defining location.
pprFamInst :: FamInst -> SDoc


-- | Module for constructing <tt>ModIface</tt> values (interface files),
--   writing them to disk and comparing two versions to see if
--   recompilation is required.
module GHC.Iface.Make
mkPartialIface :: HscEnv -> ModDetails -> ModGuts -> PartialModIface

-- | Fully instantiate an interface. Adds fingerprints and potentially code
--   generator produced information.
--   
--   CgInfos is not available when not generating code (-fno-code), or when
--   not generating interface pragmas (-fomit-interface-pragmas). See also
--   Note [Conveying CAF-info and LFInfo between modules] in
--   GHC.StgToCmm.Types.
mkFullIface :: HscEnv -> PartialModIface -> Maybe CgInfos -> IO ModIface

-- | Make an interface from the results of typechecking only. Useful for
--   non-optimising compilation, or where we aren't generating any object
--   code at all (<a>NoBackend</a>).
mkIfaceTc :: HscEnv -> SafeHaskellMode -> ModDetails -> TcGblEnv -> IO ModIface
mkIfaceExports :: [AvailInfo] -> [IfaceExport]
coAxiomToIfaceDecl :: CoAxiom br -> IfaceDecl
tyThingToIfaceDecl :: Bool -> TyThing -> IfaceDecl


-- | Module for detecting if recompilation is required
module GHC.Iface.Recomp

-- | Top level function to check if the version of an old interface file is
--   equivalent to the current source file the user asked us to compile. If
--   the same, we can avoid recompilation. We return a tuple where the
--   first element is a bool saying if we should recompile the object file
--   and the second is maybe the interface file, where Nothing means to
--   rebuild the interface file and not use the existing one.
checkOldIface :: HscEnv -> ModSummary -> SourceModified -> Maybe ModIface -> IO (RecompileRequired, Maybe ModIface)
data RecompileRequired

-- | everything is up to date, recompilation is not required
UpToDate :: RecompileRequired

-- | The .hs file has been touched, or the .o/.hi file does not exist
MustCompile :: RecompileRequired

-- | The .o/.hi files are up to date, but something else has changed to
--   force recompilation; the String says what (one-line summary)
RecompBecause :: String -> RecompileRequired
recompileRequired :: RecompileRequired -> Bool

-- | Add fingerprints for top-level declarations to a <a>ModIface_</a>.
--   
--   See Note [Fingerprinting IfaceDecls]
addFingerprints :: HscEnv -> PartialModIface -> IO ModIface
instance GHC.Classes.Eq GHC.Iface.Recomp.RecompileRequired
instance GHC.Utils.Outputable.Outputable GHC.Iface.Recomp.IfaceDeclExtras
instance GHC.Utils.Binary.Binary GHC.Iface.Recomp.IfaceDeclExtras
instance GHC.Utils.Binary.Binary GHC.Iface.Recomp.IfaceIdExtras
instance GHC.Base.Semigroup GHC.Iface.Recomp.RecompileRequired
instance GHC.Base.Monoid GHC.Iface.Recomp.RecompileRequired

module GHC.Tc.Utils.Backpack

-- | For a module <tt>modname</tt> of type <a>HscSource</a>, determine the
--   list of extra "imports" of other requirements which should be
--   considered part of the import of the requirement, because it
--   transitively depends on those requirements by imports of modules from
--   other packages. The situation is something like this:
--   
--   unit p where signature X signature Y import X
--   
--   unit q where dependency p[X=&lt;A&gt;,Y=&lt;B&gt;] signature A
--   signature B
--   
--   Although q's B does not directly import A, we still have to make sure
--   we process A first, because the merging process will cause B to
--   indirectly import A. This function finds the TRANSITIVE closure of all
--   such imports we need to make.
findExtraSigImports' :: HscEnv -> HscSource -> ModuleName -> IO (UniqDSet ModuleName)

-- | <a>findExtraSigImports</a>, but in a convenient form for
--   <a>GHC.Driver.Make</a> and <a>GHC.Tc.Module</a>.
findExtraSigImports :: HscEnv -> HscSource -> ModuleName -> IO [(Maybe FastString, Located ModuleName)]
implicitRequirements' :: HscEnv -> [(Maybe FastString, Located ModuleName)] -> IO [ModuleName]
implicitRequirements :: HscEnv -> [(Maybe FastString, Located ModuleName)] -> IO [(Maybe FastString, Located ModuleName)]

-- | Like <tt>implicitRequirements'</tt>, but returns either the module
--   name, if it is a free hole, or the instantiated unit the imported
--   module is from, so that that instantiated unit can be processed and
--   via the batch mod graph (rather than a transitive closure done here)
--   all the free holes are still reachable.
implicitRequirementsShallow :: HscEnv -> [(Maybe FastString, Located ModuleName)] -> IO ([ModuleName], [InstantiatedUnit])

-- | Given a <a>Unit</a>, make sure it is well typed. This is because unit
--   IDs come from Cabal, which does not know if things are well-typed or
--   not; a component may have been filled with implementations for the
--   holes that don't actually fulfill the requirements.
checkUnit :: Unit -> TcM ()

-- | Top-level driver for signature instantiation (run when compiling an
--   <tt>hsig</tt> file.)
tcRnCheckUnit :: HscEnv -> Unit -> IO (Messages DecoratedSDoc, Maybe ())

-- | Top-level driver for signature merging (run after typechecking an
--   <tt>hsig</tt> file).
tcRnMergeSignatures :: HscEnv -> HsParsedModule -> TcGblEnv -> ModIface -> IO (Messages DecoratedSDoc, Maybe TcGblEnv)

-- | Given a local <a>ModIface_</a>, merge all inherited requirements from
--   <a>requirementMerges</a> into this signature, producing a final
--   <a>TcGblEnv</a> that matches the local signature and all required
--   signatures.
mergeSignatures :: HsParsedModule -> TcGblEnv -> ModIface -> TcRn TcGblEnv

-- | Top-level driver for signature instantiation (run when compiling an
--   <tt>hsig</tt> file.)
tcRnInstantiateSignature :: HscEnv -> Module -> RealSrcSpan -> IO (Messages DecoratedSDoc, Maybe TcGblEnv)

-- | Given <a>tcg_mod</a>, instantiate a <a>ModIface_</a> from the
--   indefinite library to use the actual implementations of the relevant
--   entities, checking that the implementation matches the signature.
instantiateSignature :: TcRn TcGblEnv

module GHC.Tc.Gen.Export
rnExports :: Bool -> Maybe (LocatedL [LIE GhcPs]) -> RnM TcGblEnv
exports_from_avail :: Maybe (LocatedL [LIE GhcPs]) -> GlobalRdrEnv -> ImportAvails -> Module -> RnM (Maybe [(LIE GhcRn, Avails)], Avails)


-- | Typechecking instance declarations
module GHC.Tc.TyCl.Instance
tcInstDecls1 :: [LInstDecl GhcRn] -> TcM (TcGblEnv, [InstInfo GhcRn], [DerivInfo])

-- | Use DerivInfo for data family instances (produced by tcInstDecls1),
--   datatype declarations (TyClDecl), and standalone deriving declarations
--   (DerivDecl) to check and process all derived class instances.
tcInstDeclsDeriv :: [DerivInfo] -> [LDerivDecl GhcRn] -> TcM (TcGblEnv, [InstInfo GhcRn], HsValBinds GhcRn)
tcInstDecls2 :: [LTyClDecl GhcRn] -> [InstInfo GhcRn] -> TcM (LHsBinds GhcTc)


-- | Typechecking class declarations
module GHC.Tc.TyCl.Class
tcClassSigs :: Name -> [LSig GhcRn] -> LHsBinds GhcRn -> TcM [TcMethInfo]
tcClassDecl2 :: LTyClDecl GhcRn -> TcM (LHsBinds GhcTc)
findMethodBind :: Name -> LHsBinds GhcRn -> TcPragEnv -> Maybe (LHsBind GhcRn, SrcSpan, [LSig GhcRn])
instantiateMethod :: Class -> TcId -> [TcType] -> TcType
tcClassMinimalDef :: Name -> [LSig GhcRn] -> [TcMethInfo] -> TcM ClassMinimalDef
type HsSigFun = Name -> Maybe (LHsSigType GhcRn)
mkHsSigFun :: [LSig GhcRn] -> HsSigFun
badMethodErr :: Outputable a => a -> Name -> SDoc
instDeclCtxt1 :: LHsSigType GhcRn -> SDoc
instDeclCtxt2 :: Type -> SDoc
instDeclCtxt3 :: Class -> [Type] -> SDoc

-- | Construct default instances for any associated types that aren't given
--   a user definition Returns [] or singleton
tcATDefault :: SrcSpan -> TCvSubst -> NameSet -> ClassATItem -> TcM [FamInst]


-- | Typecheck type and class declarations
module GHC.Tc.TyCl
tcTyAndClassDecls :: [TyClGroup GhcRn] -> TcM (TcGblEnv, [InstInfo GhcRn], [DerivInfo])
kcConDecls :: NewOrData -> Kind -> [LConDecl GhcRn] -> TcM ()
tcConDecls :: NewOrData -> DataDeclInfo -> KnotTied TyCon -> [TyConBinder] -> TcKind -> [LConDecl GhcRn] -> TcM [DataCon]
data DataDeclInfo
DDataType :: DataDeclInfo
DDataInstance :: Type -> DataDeclInfo
dataDeclChecks :: Name -> NewOrData -> Maybe (LHsContext GhcRn) -> [LConDecl GhcRn] -> TcM Bool
checkValidTyCon :: TyCon -> TcM ()
tcFamTyPats :: TyCon -> HsTyPats GhcRn -> TcM (TcType, TcKind)
tcTyFamInstEqn :: TcTyCon -> AssocInstInfo -> LTyFamInstEqn GhcRn -> TcM (KnotTied CoAxBranch)
tcAddTyFamInstCtxt :: TyFamInstDecl GhcRn -> TcM a -> TcM a
tcMkDataFamInstCtxt :: DataFamInstDecl GhcRn -> SDoc
tcAddDataFamInstCtxt :: DataFamInstDecl GhcRn -> TcM a -> TcM a
unravelFamInstPats :: TcType -> [TcType]
addConsistencyConstraints :: AssocInstInfo -> TcType -> TcM ()
wrongKindOfFamily :: TyCon -> SDoc


-- | Handles <tt>deriving</tt> clauses on <tt>data</tt> declarations.
module GHC.Tc.Deriv
tcDeriving :: [DerivInfo] -> [LDerivDecl GhcRn] -> TcM (TcGblEnv, Bag (InstInfo GhcRn), HsValBinds GhcRn)

-- | Stuff needed to process a datatype's `deriving` clauses
data DerivInfo
DerivInfo :: TyCon -> ![(Name, TyVar)] -> [LHsDerivingClause GhcRn] -> SDoc -> DerivInfo

-- | The data tycon for normal datatypes, or the *representation* tycon for
--   data families
[di_rep_tc] :: DerivInfo -> TyCon

-- | Variables that scope over the deriving clause.
[di_scoped_tvs] :: DerivInfo -> ![(Name, TyVar)]
[di_clauses] :: DerivInfo -> [LHsDerivingClause GhcRn]

-- | error context
[di_ctxt] :: DerivInfo -> SDoc
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.EarlyDerivSpec


-- | Error-checking and other utilities for <tt>deriving</tt> clauses or
--   declarations.
module GHC.Tc.Deriv.Utils

-- | To avoid having to manually plumb everything in <a>DerivEnv</a>
--   throughout various functions in <a>GHC.Tc.Deriv</a> and
--   <a>GHC.Tc.Deriv.Infer</a>, we use <a>DerivM</a>, which is a simple
--   reader around <a>TcRn</a>.
type DerivM = ReaderT DerivEnv TcRn

-- | Contains all of the information known about a derived instance when
--   determining what its <tt>EarlyDerivSpec</tt> should be. See <tt>Note
--   [DerivEnv and DerivSpecMechanism]</tt>.
data DerivEnv
DerivEnv :: Maybe OverlapMode -> [TyVar] -> Class -> [Type] -> DerivContext -> Maybe (DerivStrategy GhcTc) -> DerivEnv

-- | Is this an overlapping instance?
[denv_overlap_mode] :: DerivEnv -> Maybe OverlapMode

-- | Universally quantified type variables in the instance
[denv_tvs] :: DerivEnv -> [TyVar]

-- | Class for which we need to derive an instance
[denv_cls] :: DerivEnv -> Class

-- | All arguments to <a>denv_cls</a> in the derived instance.
[denv_inst_tys] :: DerivEnv -> [Type]

-- | <tt><a>SupplyContext</a> theta</tt> for standalone deriving (where
--   <tt>theta</tt> is the context of the instance). <a>InferContext</a>
--   for <tt>deriving</tt> clauses, or for standalone deriving that uses a
--   wildcard constraint. See <tt>Note [Inferring the instance
--   context]</tt>.
[denv_ctxt] :: DerivEnv -> DerivContext

-- | <a>Just</a> if user requests a particular deriving strategy.
--   Otherwise, <a>Nothing</a>.
[denv_strat] :: DerivEnv -> Maybe (DerivStrategy GhcTc)
data DerivSpec theta
DS :: SrcSpan -> Name -> [TyVar] -> theta -> Class -> [Type] -> Maybe OverlapMode -> Maybe SrcSpan -> DerivSpecMechanism -> DerivSpec theta
[ds_loc] :: DerivSpec theta -> SrcSpan
[ds_name] :: DerivSpec theta -> Name
[ds_tvs] :: DerivSpec theta -> [TyVar]
[ds_theta] :: DerivSpec theta -> theta
[ds_cls] :: DerivSpec theta -> Class
[ds_tys] :: DerivSpec theta -> [Type]
[ds_overlap] :: DerivSpec theta -> Maybe OverlapMode
[ds_standalone_wildcard] :: DerivSpec theta -> Maybe SrcSpan
[ds_mechanism] :: DerivSpec theta -> DerivSpecMechanism
pprDerivSpec :: Outputable theta => DerivSpec theta -> SDoc

-- | Information about the arguments to the class in a stock- or
--   newtype-derived instance. See <tt>Note [DerivEnv and
--   DerivSpecMechanism]</tt>.
data DerivInstTys
DerivInstTys :: [Type] -> TyCon -> [Type] -> TyCon -> [Type] -> DerivInstTys

-- | Other arguments to the class except the last
[dit_cls_tys] :: DerivInstTys -> [Type]

-- | Type constructor for which the instance is requested (last arguments
--   to the type class)
[dit_tc] :: DerivInstTys -> TyCon

-- | Arguments to the type constructor
[dit_tc_args] :: DerivInstTys -> [Type]

-- | The representation tycon for <a>dit_tc</a> (for data family
--   instances). Otherwise the same as <a>dit_tc</a>.
[dit_rep_tc] :: DerivInstTys -> TyCon

-- | The representation types for <a>dit_tc_args</a> (for data family
--   instances). Otherwise the same as <a>dit_tc_args</a>.
[dit_rep_tc_args] :: DerivInstTys -> [Type]

-- | What action to take in order to derive a class instance. See <tt>Note
--   [DerivEnv and DerivSpecMechanism]</tt>, as well as <tt>Note [Deriving
--   strategies]</tt> in <a>GHC.Tc.Deriv</a>.
data DerivSpecMechanism

-- | "Standard" classes
DerivSpecStock :: DerivInstTys -> (SrcSpan -> TyCon -> [Type] -> [Type] -> TcM (LHsBinds GhcPs, [LSig GhcPs], BagDerivStuff, [Name])) -> DerivSpecMechanism

-- | Information about the arguments to the class in the derived instance,
--   including what type constructor the last argument is headed by. See
--   <tt>Note [DerivEnv and DerivSpecMechanism]</tt>.
[dsm_stock_dit] :: DerivSpecMechanism -> DerivInstTys

-- | This function returns four things:
--   
--   <ol>
--   <li><tt>LHsBinds GhcPs</tt>: The derived instance's function bindings
--   (e.g., <tt>compare (T x) (T y) = compare x y</tt>)</li>
--   <li><tt>[LSig GhcPs]</tt>: A list of instance specific
--   signatures/pragmas. Most likely INLINE pragmas for class methods.</li>
--   <li><tt>BagDerivStuff</tt>: Auxiliary bindings needed to support the
--   derived instance. As examples, derived <tt>Generic</tt> instances
--   require associated type family instances, and derived <a>Eq</a> and
--   <a>Ord</a> instances require top-level <tt>con2tag</tt> functions. See
--   <tt>Note [Auxiliary binders]</tt> in
--   <a>GHC.Tc.Deriv.Generate</a>.</li>
--   <li><tt>[Name]</tt>: A list of Names for which <tt>-Wunused-binds</tt>
--   should be suppressed. This is used to suppress unused warnings for
--   record selectors when deriving <a>Read</a>, <a>Show</a>, or
--   <tt>Generic</tt>. See <tt>Note [Deriving and unused record
--   selectors]</tt>.</li>
--   </ol>
[dsm_stock_gen_fn] :: DerivSpecMechanism -> SrcSpan -> TyCon -> [Type] -> [Type] -> TcM (LHsBinds GhcPs, [LSig GhcPs], BagDerivStuff, [Name])

-- | <pre>
--   GeneralizedNewtypeDeriving
--   </pre>
DerivSpecNewtype :: DerivInstTys -> Type -> DerivSpecMechanism

-- | Information about the arguments to the class in the derived instance,
--   including what type constructor the last argument is headed by. See
--   <tt>Note [DerivEnv and DerivSpecMechanism]</tt>.
[dsm_newtype_dit] :: DerivSpecMechanism -> DerivInstTys

-- | The newtype rep type.
[dsm_newtype_rep_ty] :: DerivSpecMechanism -> Type

-- | <pre>
--   DeriveAnyClass
--   </pre>
DerivSpecAnyClass :: DerivSpecMechanism

-- | <pre>
--   DerivingVia
--   </pre>
DerivSpecVia :: [Type] -> Type -> Type -> DerivSpecMechanism

-- | All arguments to the class besides the last one.
[dsm_via_cls_tys] :: DerivSpecMechanism -> [Type]

-- | The last argument to the class.
[dsm_via_inst_ty] :: DerivSpecMechanism -> Type

-- | The <tt>via</tt> type
[dsm_via_ty] :: DerivSpecMechanism -> Type

-- | Convert a <a>DerivSpecMechanism</a> to its corresponding
--   <a>DerivStrategy</a>.
derivSpecMechanismToStrategy :: DerivSpecMechanism -> DerivStrategy GhcTc
isDerivSpecStock :: DerivSpecMechanism -> Bool
isDerivSpecNewtype :: DerivSpecMechanism -> Bool
isDerivSpecAnyClass :: DerivSpecMechanism -> Bool
isDerivSpecVia :: DerivSpecMechanism -> Bool

-- | Whether GHC is processing a <tt>deriving</tt> clause or a standalone
--   deriving declaration.
data DerivContext

-- | <tt>'InferContext mb_wildcard</tt> is either:
--   
--   <ul>
--   <li>A <tt>deriving</tt> clause (in which case <tt>mb_wildcard</tt> is
--   <a>Nothing</a>).</li>
--   <li>A standalone deriving declaration with an extra-constraints
--   wildcard as the context (in which case <tt>mb_wildcard</tt> is
--   <tt><a>Just</a> loc</tt>, where <tt>loc</tt> is the location of the
--   wildcard.</li>
--   </ul>
--   
--   GHC should infer the context.
InferContext :: Maybe SrcSpan -> DerivContext

-- | <tt><a>SupplyContext</a> theta</tt> is a standalone deriving
--   declaration, where <tt>theta</tt> is the context supplied by the user.
SupplyContext :: ThetaType -> DerivContext

-- | Records whether a particular class can be derived by way of an
--   <i>originative</i> deriving strategy (i.e., <tt>stock</tt> or
--   <tt>anyclass</tt>).
--   
--   See <tt>Note [Deriving strategies]</tt> in <a>GHC.Tc.Deriv</a>.
data OriginativeDerivStatus
CanDeriveStock :: (SrcSpan -> TyCon -> [Type] -> [Type] -> TcM (LHsBinds GhcPs, [LSig GhcPs], BagDerivStuff, [Name])) -> OriginativeDerivStatus
StockClassError :: SDoc -> OriginativeDerivStatus
CanDeriveAnyClass :: OriginativeDerivStatus
NonDerivableClass :: SDoc -> OriginativeDerivStatus

-- | Is GHC processing a standalone deriving declaration?
isStandaloneDeriv :: DerivM Bool

-- | Is GHC processing a standalone deriving declaration with an
--   extra-constraints wildcard as the context? (e.g., <tt>deriving
--   instance _ =&gt; Eq (Foo a)</tt>)
isStandaloneWildcardDeriv :: DerivM Bool

-- | <tt><a>mkDerivOrigin</a> wc</tt> returns <a>StandAloneDerivOrigin</a>
--   if <tt>wc</tt> is <a>True</a>, and <a>DerivClauseOrigin</a> if
--   <tt>wc</tt> is <a>False</a>. Useful for error-reporting.
mkDerivOrigin :: Bool -> CtOrigin

-- | A <a>PredType</a> annotated with the origin of the constraint
--   <a>CtOrigin</a>, and whether or the constraint deals in types or
--   kinds.
data PredOrigin
PredOrigin :: PredType -> CtOrigin -> TypeOrKind -> PredOrigin

-- | A list of wanted <a>PredOrigin</a> constraints
--   (<a>to_wanted_origins</a>) to simplify when inferring a derived
--   instance's context. These are used in all deriving strategies, but in
--   the particular case of <tt>DeriveAnyClass</tt>, we need extra
--   information. In particular, we need:
--   
--   <ul>
--   <li><a>to_anyclass_skols</a>, the list of type variables bound by a
--   class method's regular type signature, which should be rigid.</li>
--   <li><a>to_anyclass_metas</a>, the list of type variables bound by a
--   class method's default type signature. These can be unified as
--   necessary.</li>
--   <li><a>to_anyclass_givens</a>, the list of constraints from a class
--   method's regular type signature, which can be used to help solve
--   constraints in the <a>to_wanted_origins</a>.</li>
--   </ul>
--   
--   (Note that <a>to_wanted_origins</a> will likely contain type variables
--   from the derived type class or data type, neither of which will appear
--   in <a>to_anyclass_skols</a> or <a>to_anyclass_metas</a>.)
--   
--   For all other deriving strategies, it is always the case that
--   <a>to_anyclass_skols</a>, <a>to_anyclass_metas</a>, and
--   <a>to_anyclass_givens</a> are empty.
--   
--   Here is an example to illustrate this:
--   
--   <pre>
--   class Foo a where
--     bar :: forall b. Ix b =&gt; a -&gt; b -&gt; String
--     default bar :: forall y. (Show a, Ix y) =&gt; a -&gt; y -&gt; String
--     bar x y = show x ++ show (range (y, y))
--   
--     baz :: Eq a =&gt; a -&gt; a -&gt; Bool
--     default baz :: Ord a =&gt; a -&gt; a -&gt; Bool
--     baz x y = compare x y == EQ
--   
--   data Quux q = Quux deriving anyclass Foo
--   </pre>
--   
--   Then it would generate two <a>ThetaOrigin</a>s, one for each method:
--   
--   <pre>
--   [ ThetaOrigin { to_anyclass_skols  = [b]
--                 , to_anyclass_metas  = [y]
--                 , to_anyclass_givens = [Ix b]
--                 , to_wanted_origins  = [ Show (Quux q), Ix y
--                                        , (Quux q -&gt; b -&gt; String) ~
--                                          (Quux q -&gt; y -&gt; String)
--                                        ] }
--   , ThetaOrigin { to_anyclass_skols  = []
--                 , to_anyclass_metas  = []
--                 , to_anyclass_givens = [Eq (Quux q)]
--                 , to_wanted_origins  = [ Ord (Quux q)
--                                        , (Quux q -&gt; Quux q -&gt; Bool) ~
--                                          (Quux q -&gt; Quux q -&gt; Bool)
--                                        ] }
--   ]
--   </pre>
--   
--   (Note that the type variable <tt>q</tt> is bound by the data type
--   <tt>Quux</tt>, and thus it appears in neither <a>to_anyclass_skols</a>
--   nor <a>to_anyclass_metas</a>.)
--   
--   See <tt>Note [Gathering and simplifying constraints for
--   DeriveAnyClass]</tt> in <a>GHC.Tc.Deriv.Infer</a> for an explanation
--   of how <a>to_wanted_origins</a> are determined in
--   <tt>DeriveAnyClass</tt>, as well as how <a>to_anyclass_skols</a>,
--   <a>to_anyclass_metas</a>, and <a>to_anyclass_givens</a> are used.
data ThetaOrigin
ThetaOrigin :: [TyVar] -> [TyVar] -> ThetaType -> [PredOrigin] -> ThetaOrigin
[to_anyclass_skols] :: ThetaOrigin -> [TyVar]
[to_anyclass_metas] :: ThetaOrigin -> [TyVar]
[to_anyclass_givens] :: ThetaOrigin -> ThetaType
[to_wanted_origins] :: ThetaOrigin -> [PredOrigin]
mkPredOrigin :: CtOrigin -> TypeOrKind -> PredType -> PredOrigin
mkThetaOrigin :: CtOrigin -> TypeOrKind -> [TyVar] -> [TyVar] -> ThetaType -> ThetaType -> ThetaOrigin
mkThetaOriginFromPreds :: [PredOrigin] -> ThetaOrigin
substPredOrigin :: HasCallStack => TCvSubst -> PredOrigin -> PredOrigin
checkOriginativeSideConditions :: DynFlags -> DerivContext -> Class -> [TcType] -> TyCon -> TyCon -> OriginativeDerivStatus
hasStockDeriving :: Class -> Maybe (SrcSpan -> TyCon -> [Type] -> [Type] -> TcM (LHsBinds GhcPs, [LSig GhcPs], BagDerivStuff, [Name]))
canDeriveAnyClass :: DynFlags -> Validity
std_class_via_coercible :: Class -> Bool
non_coercible_class :: Class -> Bool
newDerivClsInst :: ThetaType -> DerivSpec theta -> TcM ClsInst
extendLocalInstEnv :: [ClsInst] -> TcM a -> TcM a
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.ThetaOrigin
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.PredOrigin
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.DerivEnv
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.DerivContext
instance GHC.Utils.Outputable.Outputable theta => GHC.Utils.Outputable.Outputable (GHC.Tc.Deriv.Utils.DerivSpec theta)
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.DerivSpecMechanism
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.DerivInstTys


-- | The deriving code for the Generic class
module GHC.Tc.Deriv.Generics
canDoGenerics :: TyCon -> Validity
canDoGenerics1 :: TyCon -> Validity
data GenericKind
Gen0 :: GenericKind
Gen1 :: GenericKind
gen_Generic_binds :: GenericKind -> TyCon -> [Type] -> TcM (LHsBinds GhcPs, [LSig GhcPs], FamInst)
get_gen1_constrained_tys :: TyVar -> Type -> [Type]


-- | Generating derived instance declarations
--   
--   This module is nominally `<tt>subordinate'</tt> to
--   <a>GHC.Tc.Deriv</a>, which is the `<tt>official'</tt> interface to
--   deriving-related things.
--   
--   This is where we do all the grimy bindings' generation.
module GHC.Tc.Deriv.Generate
type BagDerivStuff = Bag DerivStuff
data DerivStuff

-- | A new, top-level auxiliary binding. Used for deriving <a>Eq</a>,
--   <a>Ord</a>, <a>Enum</a>, <tt>Ix</tt>, and <tt>Data</tt>. See Note
--   [Auxiliary binders].
DerivAuxBind :: AuxBindSpec -> DerivStuff

-- | A new type family instance. Used for:
--   
--   <ul>
--   <li><tt>DeriveGeneric</tt>, which generates instances of
--   <tt>Rep(1)</tt></li>
--   <li><tt>DeriveAnyClass</tt>, which can fill in associated type family
--   defaults</li>
--   <li><tt>GeneralizedNewtypeDeriving</tt>, which generates instances of
--   associated type families for newtypes</li>
--   </ul>
DerivFamInst :: FamInst -> DerivStuff
gen_Eq_binds :: SrcSpan -> TyCon -> [Type] -> TcM (LHsBinds GhcPs, BagDerivStuff)
gen_Ord_binds :: SrcSpan -> TyCon -> [Type] -> TcM (LHsBinds GhcPs, BagDerivStuff)
gen_Enum_binds :: SrcSpan -> TyCon -> [Type] -> TcM (LHsBinds GhcPs, BagDerivStuff)
gen_Bounded_binds :: SrcSpan -> TyCon -> [Type] -> (LHsBinds GhcPs, BagDerivStuff)
gen_Ix_binds :: SrcSpan -> TyCon -> [Type] -> TcM (LHsBinds GhcPs, BagDerivStuff)
gen_Show_binds :: (Name -> Fixity) -> SrcSpan -> TyCon -> [Type] -> (LHsBinds GhcPs, BagDerivStuff)
gen_Read_binds :: (Name -> Fixity) -> SrcSpan -> TyCon -> [Type] -> (LHsBinds GhcPs, BagDerivStuff)
gen_Data_binds :: SrcSpan -> TyCon -> [Type] -> TcM (LHsBinds GhcPs, BagDerivStuff)
gen_Lift_binds :: SrcSpan -> TyCon -> [Type] -> (LHsBinds GhcPs, BagDerivStuff)
gen_Newtype_binds :: SrcSpan -> Class -> [TyVar] -> [Type] -> Type -> TcM (LHsBinds GhcPs, [LSig GhcPs], BagDerivStuff)
mkCoerceClassMethEqn :: Class -> [TyVar] -> [Type] -> Type -> Id -> Pair Type

-- | Take a <a>BagDerivStuff</a> and partition it into
--   <a>SeparateBagsDerivStuff</a>. Also generate the code for auxiliary
--   bindings based on the declarative descriptions in the supplied
--   <a>AuxBindSpec</a>s. See <tt>Note [Auxiliary binders]</tt>.
genAuxBinds :: DynFlags -> SrcSpan -> BagDerivStuff -> SeparateBagsDerivStuff
ordOpTbl :: [(Type, (RdrName, RdrName, RdrName, RdrName, RdrName))]
boxConTbl :: [(Type, LHsExpr GhcPs -> LHsExpr GhcPs)]
litConTbl :: [(Type, LHsExpr GhcPs -> LHsExpr GhcPs)]
mkRdrFunBind :: LocatedN RdrName -> [LMatch GhcPs (LHsExpr GhcPs)] -> LHsBind GhcPs

-- | Produces a function binding. When no equations are given, it generates
--   a binding of the given arity and an empty case expression for the last
--   argument that it passes to the given function to produce the
--   right-hand side.
mkRdrFunBindEC :: Arity -> (LHsExpr GhcPs -> LHsExpr GhcPs) -> LocatedN RdrName -> [LMatch GhcPs (LHsExpr GhcPs)] -> LHsBind GhcPs

-- | Produces a function binding. When there are no equations, it generates
--   a binding with the given arity that produces an error based on the
--   name of the type of the last argument.
mkRdrFunBindSE :: Arity -> LocatedN RdrName -> [LMatch GhcPs (LHsExpr GhcPs)] -> LHsBind GhcPs
error_Expr :: String -> LHsExpr GhcPs

-- | <tt>getPossibleDataCons tycon tycon_args</tt> returns the constructors
--   of <tt>tycon</tt> whose return types match when checked against
--   <tt>tycon_args</tt>.
--   
--   See Note [Filter out impossible GADT data constructors]
getPossibleDataCons :: TyCon -> [Type] -> [DataCon]

-- | Given a type constructor <tt>tycon</tt> of arity <i>n</i> and a list
--   of argument types <tt>tycon_args</tt> of length <i>m</i>,
--   
--   <pre>
--   tyConInstArgTys tycon tycon_args
--   </pre>
--   
--   returns
--   
--   <pre>
--   [tycon_arg_{1}, tycon_arg_{2}, ..., tycon_arg_{m}, extra_arg_{m+1}, ..., extra_arg_{n}]
--   </pre>
--   
--   where <tt>extra_args</tt> are distinct type variables.
--   
--   Examples:
--   
--   <ul>
--   <li>Given <tt>tycon: Foo a b</tt> and <tt>tycon_args: [Int,
--   Bool]</tt>, return <tt>[Int, Bool]</tt>.</li>
--   <li>Given <tt>tycon: Foo a b</tt> and <tt>tycon_args: [Int]</tt>,
--   return <tt>[Int, b]</tt>.</li>
--   </ul>
tyConInstArgTys :: TyCon -> [Type] -> [Type]


-- | The deriving code for the Functor, Foldable, and Traversable classes
module GHC.Tc.Deriv.Functor
data FFoldType a
FT :: a -> a -> a -> (a -> a -> a) -> (TyCon -> [a] -> a) -> (Type -> Type -> a -> a) -> a -> (TcTyVar -> a -> a) -> FFoldType a

-- | Does not contain variable
[ft_triv] :: FFoldType a -> a

-- | The variable itself
[ft_var] :: FFoldType a -> a

-- | The variable itself, contravariantly
[ft_co_var] :: FFoldType a -> a

-- | Function type
[ft_fun] :: FFoldType a -> a -> a -> a

-- | Tuple type. The <tt>[a]</tt> is the result of folding over the
--   arguments of the tuple.
[ft_tup] :: FFoldType a -> TyCon -> [a] -> a

-- | Type app, variable only in last argument. The two <a>Type</a>s are the
--   function and argument parts of <tt>fun_ty arg_ty</tt>, respectively.
[ft_ty_app] :: FFoldType a -> Type -> Type -> a -> a

-- | Type app, variable other than in last argument
[ft_bad_app] :: FFoldType a -> a

-- | Forall type
[ft_forall] :: FFoldType a -> TcTyVar -> a -> a
functorLikeTraverse :: forall a. TyVar -> FFoldType a -> Type -> a
deepSubtypesContaining :: TyVar -> Type -> [TcType]
foldDataConArgs :: FFoldType a -> DataCon -> [a]
gen_Functor_binds :: SrcSpan -> TyCon -> [Type] -> (LHsBinds GhcPs, BagDerivStuff)
gen_Foldable_binds :: SrcSpan -> TyCon -> [Type] -> (LHsBinds GhcPs, BagDerivStuff)
gen_Traversable_binds :: SrcSpan -> TyCon -> [Type] -> (LHsBinds GhcPs, BagDerivStuff)


-- | Functions for inferring (and simplifying) the context for derived
--   instances.
module GHC.Tc.Deriv.Infer
inferConstraints :: DerivSpecMechanism -> DerivM ([ThetaOrigin], [TyVar], [TcType])
simplifyInstanceContexts :: [DerivSpec [ThetaOrigin]] -> TcM [DerivSpec ThetaType]


-- | Typechecking rewrite rules
module GHC.Tc.Gen.Rule
tcRules :: [LRuleDecls GhcRn] -> TcM [LRuleDecls GhcTc]


-- | Typechecking <tt>foreign</tt> declarations
--   
--   A foreign declaration is used to either give an externally implemented
--   function a Haskell type (and calling interface) or give a Haskell
--   function an external calling interface. Either way, the range of
--   argument and result types these functions can accommodate is
--   restricted to what the outside world understands (read C), and this
--   module checks to see if a foreign declaration has got a legal type.
module GHC.Tc.Gen.Foreign
tcForeignImports :: [LForeignDecl GhcRn] -> TcM ([Id], [LForeignDecl GhcTc], Bag GlobalRdrElt)
tcForeignExports :: [LForeignDecl GhcRn] -> TcM (LHsBinds GhcTc, [LForeignDecl GhcTc], Bag GlobalRdrElt)
isForeignImport :: forall name. UnXRec name => LForeignDecl name -> Bool
isForeignExport :: forall name. UnXRec name => LForeignDecl name -> Bool
tcFImport :: LForeignDecl GhcRn -> TcM (Id, LForeignDecl GhcTc, Bag GlobalRdrElt)
tcFExport :: ForeignDecl GhcRn -> TcM (LHsBind GhcTc, ForeignDecl GhcTc, Bag GlobalRdrElt)
tcForeignImports' :: [LForeignDecl GhcRn] -> TcM ([Id], [LForeignDecl GhcTc], Bag GlobalRdrElt)
tcCheckFIType :: [Scaled Type] -> Type -> ForeignImport -> TcM ForeignImport
checkCTarget :: CCallTarget -> TcM ()
checkForeignArgs :: (Type -> Validity) -> [Scaled Type] -> TcM ()

-- | Check that the type has the form (IO t) or (t) , and that t satisfies
--   the given predicate. When calling this function, any newtype wrappers
--   (should) have been already dealt with by normaliseFfiType.
--   
--   We also check that the Safe Haskell condition of FFI imports having
--   results in the IO monad holds.
checkForeignRes :: Bool -> Bool -> (Type -> Validity) -> Type -> TcM ()
normaliseFfiType :: Type -> TcM (Coercion, Type, Bag GlobalRdrElt)
nonIOok :: Bool
mustBeIO :: Bool
checkSafe :: Bool
noCheckSafe :: Bool
tcForeignExports' :: [LForeignDecl GhcRn] -> TcM (LHsBinds GhcTc, [LForeignDecl GhcTc], Bag GlobalRdrElt)
tcCheckFEType :: Type -> ForeignExport -> TcM ForeignExport


-- | Typechecking <tt>default</tt> declarations
module GHC.Tc.Gen.Default
tcDefaults :: [LDefaultDecl GhcRn] -> TcM (Maybe [Type])


-- | Dynamically lookup up values from modules and loading them.
module GHC.Runtime.Loader

-- | Loads the plugins specified in the pluginModNames field of the dynamic
--   flags. Should be called after command line arguments are parsed, but
--   before actual compilation starts. Idempotent operation. Should be
--   re-called if pluginModNames or pluginModNameOpts changes.
initializePlugins :: HscEnv -> IO HscEnv
loadFrontendPlugin :: HscEnv -> ModuleName -> IO FrontendPlugin

-- | Force the interfaces for the given modules to be loaded. The
--   <a>SDoc</a> parameter is used for debugging (<tt>-ddump-if-trace</tt>)
--   only: it is shown as the reason why the module is being loaded.
forceLoadModuleInterfaces :: HscEnv -> SDoc -> [Module] -> IO ()

-- | Force the interface for the module containing the name to be loaded.
--   The <a>SDoc</a> parameter is used for debugging
--   (<tt>-ddump-if-trace</tt>) only: it is shown as the reason why the
--   module is being loaded.
forceLoadNameModuleInterface :: HscEnv -> SDoc -> Name -> IO ()

-- | Load the <a>TyCon</a> associated with the given name, come hell or
--   high water. Fails if:
--   
--   <ul>
--   <li>The interface could not be loaded</li>
--   <li>The name is not that of a <a>TyCon</a></li>
--   <li>The name did not exist in the loaded module</li>
--   </ul>
forceLoadTyCon :: HscEnv -> Name -> IO TyCon

-- | Finds the <a>Name</a> corresponding to the given <a>RdrName</a> in the
--   context of the <a>ModuleName</a>. Returns <tt>Nothing</tt> if no such
--   <a>Name</a> could be found. Any other condition results in an
--   exception:
--   
--   <ul>
--   <li>If the module could not be found</li>
--   <li>If we could not determine the imports of the module</li>
--   </ul>
--   
--   Can only be used for looking up names while loading plugins (and is
--   *not* suitable for use within plugins). The interface file is loaded
--   very partially: just enough that it can be used, without its rules and
--   instances affecting (and being linked from!) the module being
--   compiled. This was introduced by 57d6798.
--   
--   Need the module as well to record information in the interface file
lookupRdrNameInModuleForPlugins :: HscEnv -> ModuleName -> RdrName -> IO (Maybe (Name, ModIface))

-- | Loads the value corresponding to a <a>Name</a> if that value has the
--   given <a>Type</a>. This only provides limited safety in that it is up
--   to the user to ensure that that type corresponds to the type you try
--   to use the return value at!
--   
--   If the value found was not of the correct type, returns
--   <tt>Nothing</tt>. Any other condition results in an exception:
--   
--   <ul>
--   <li>If we could not load the names module</li>
--   <li>If the thing being loaded is not a value</li>
--   <li>If the Name does not exist in the module</li>
--   <li>If the link failed</li>
--   </ul>
getValueSafely :: HscEnv -> Name -> Type -> IO (Maybe a)
getHValueSafely :: Interp -> HscEnv -> Name -> Type -> IO (Maybe HValue)

-- | Coerce a value as usual, but:
--   
--   1) Evaluate it immediately to get a segfault early if the coercion was
--   wrong
--   
--   2) Wrap it in some debug messages at verbosity 3 or higher so we can
--   see what happened if it <i>does</i> segfault
lessUnsafeCoerce :: Logger -> DynFlags -> String -> a -> IO b


-- | The loader
--   
--   This module deals with the top-level issues of dynamic linking
--   (loading), calling the object-code linker and the byte-code linker
--   where necessary.
module GHC.Linker.Loader
newtype Loader
Loader :: MVar (Maybe LoaderState) -> Loader
[loader_state] :: Loader -> MVar (Maybe LoaderState)
data LoaderState
LoaderState :: ClosureEnv -> !ItblEnv -> ![Linkable] -> ![Linkable] -> ![UnitId] -> ![(FilePath, String)] -> LoaderState

-- | Current global mapping from Names to their true values
[closure_env] :: LoaderState -> ClosureEnv

-- | The current global mapping from RdrNames of DataCons to info table
--   addresses. When a new Unlinked is linked into the running image, or an
--   existing module in the image is replaced, the itbl_env must be updated
--   appropriately.
[itbl_env] :: LoaderState -> !ItblEnv

-- | The currently loaded interpreted modules (home package)
[bcos_loaded] :: LoaderState -> ![Linkable]

-- | And the currently-loaded compiled modules (home package)
[objs_loaded] :: LoaderState -> ![Linkable]

-- | The currently-loaded packages; always object code Held, as usual, in
--   dependency order; though I am not sure if that is really important
[pkgs_loaded] :: LoaderState -> ![UnitId]

-- | We need to remember the name of previous temporary DLL/.so libraries
--   so we can link them (see #10322)
[temp_sos] :: LoaderState -> ![(FilePath, String)]

-- | Initialise the dynamic linker. This entails
--   
--   a) Calling the C initialisation procedure,
--   
--   b) Loading any packages specified on the command line,
--   
--   c) Loading any packages specified on the command line, now held in the
--   <tt>-l</tt> options in <tt>v_Opt_l</tt>,
--   
--   d) Loading any <tt>.o/.dll</tt> files specified on the command line,
--   now held in <tt>ldInputs</tt>,
--   
--   e) Loading any MacOS frameworks.
--   
--   NOTE: This function is idempotent; if called more than once, it does
--   nothing. This is useful in Template Haskell, where we call it before
--   trying to link.
initLoaderState :: Interp -> HscEnv -> IO ()
uninitializedLoader :: IO Loader

-- | Display the loader state.
showLoaderState :: Interp -> IO SDoc

-- | Load a single expression, <i>including</i> first loading packages and
--   modules that this expression depends on.
--   
--   Raises an IO exception (<a>ProgramError</a>) if it can't find a
--   compiled version of the dependents to load.
loadExpr :: Interp -> HscEnv -> SrcSpan -> UnlinkedBCO -> IO ForeignHValue
loadDecls :: Interp -> HscEnv -> SrcSpan -> CompiledByteCode -> IO [(Name, ForeignHValue)]

-- | Load exactly the specified packages, and their dependents (unless of
--   course they are already loaded). The dependents are loaded
--   automatically, and it doesn't matter what order you specify the input
--   packages.
loadPackages :: Interp -> HscEnv -> [UnitId] -> IO ()
loadModule :: Interp -> HscEnv -> Module -> IO ()
loadCmdLineLibs :: Interp -> HscEnv -> IO ()

-- | Load the module containing the given Name and get its associated
--   <a>HValue</a>.
--   
--   Throws a <a>ProgramError</a> if loading fails or the name cannot be
--   found.
loadName :: Interp -> HscEnv -> Name -> IO ForeignHValue

-- | Unloading old objects ready for a new compilation sweep.
--   
--   The compilation manager provides us with a list of linkables that it
--   considers "stable", i.e. won't be recompiled this time around. For
--   each of the modules current linked in memory,
--   
--   <ul>
--   <li>if the linkable is stable (and it's the same one -- the user may
--   have recompiled the module on the side), we keep it,</li>
--   <li>otherwise, we unload it.</li>
--   <li>we also implicitly unload all temporary bindings at this
--   point.</li>
--   </ul>
unload :: Interp -> HscEnv -> [Linkable] -> IO ()

-- | Temporarily extend the loaded env.
withExtendedLoadedEnv :: ExceptionMonad m => Interp -> [(Name, ForeignHValue)] -> m a -> m a
extendLoadedEnv :: Interp -> [(Name, ForeignHValue)] -> IO ()
deleteFromLoadedEnv :: Interp -> [Name] -> IO ()
extendLoadedPkgs :: Interp -> [UnitId] -> IO ()
instance GHC.Utils.Outputable.Outputable GHC.Linker.Loader.LibrarySpec

module GHC.Iface.Tidy
mkBootModDetailsTc :: HscEnv -> TcGblEnv -> IO ModDetails
tidyProgram :: HscEnv -> ModGuts -> IO (CgGuts, ModDetails)
instance GHC.Base.Functor GHC.Iface.Tidy.DFFV
instance GHC.Base.Applicative GHC.Iface.Tidy.DFFV
instance GHC.Base.Monad GHC.Iface.Tidy.DFFV


-- | Code generation for the Static Pointer Table
--   
--   (c) 2014 I/O Tweag
--   
--   Each module that uses <tt>static</tt> keyword declares an
--   initialization function of the form hs_spt_init_&lt;module&gt;() which
--   is emitted into the _stub.c file and annotated with
--   <b>attribute</b>((constructor)) so that it gets executed at startup
--   time.
--   
--   The function's purpose is to call hs_spt_insert to insert the static
--   pointers of this module in the hashtable of the RTS, and it looks
--   something like this:
--   
--   <pre>
--   static void hs_hpc_init_Main(void) __attribute__((constructor));
--   static void hs_hpc_init_Main(void) {
--   
--     static StgWord64 k0[2] = {16252233372134256ULL,7370534374096082ULL};
--     extern StgPtr Main_r2wb_closure;
--     hs_spt_insert(k0, &amp;Main_r2wb_closure);
--   
--     static StgWord64 k1[2] = {12545634534567898ULL,5409674567544151ULL};
--     extern StgPtr Main_r2wc_closure;
--     hs_spt_insert(k1, &amp;Main_r2wc_closure);
--   
--   }
--   </pre>
--   
--   where the constants are fingerprints produced from the static forms.
--   
--   The linker must find the definitions matching the <tt>extern StgPtr
--   <a>name</a></tt> declarations. For this to work, the identifiers of
--   static pointers need to be exported. This is done in <a>newLvlVar</a>.
--   
--   There is also a finalization function for the time when the module is
--   unloaded.
--   
--   <pre>
--   static void hs_hpc_fini_Main(void) __attribute__((destructor));
--   static void hs_hpc_fini_Main(void) {
--   
--     static StgWord64 k0[2] = {16252233372134256ULL,7370534374096082ULL};
--     hs_spt_remove(k0);
--   
--     static StgWord64 k1[2] = {12545634534567898ULL,5409674567544151ULL};
--     hs_spt_remove(k1);
--   
--   }
--   </pre>
module GHC.Iface.Tidy.StaticPtrTable

-- | Replaces all bindings of the form
--   
--   <pre>
--   b = /\ ... -&gt; makeStatic location value
--   </pre>
--   
--   with
--   
--   <pre>
--   b = /\ ... -&gt;
--     StaticPtr key (StaticPtrInfo "pkg key" "module" location) value
--   </pre>
--   
--   where a distinct key is generated for each binding.
--   
--   It also yields the C stub that inserts these bindings into the static
--   pointer table.
sptCreateStaticBinds :: HscEnv -> Module -> CoreProgram -> IO ([SptEntry], CoreProgram)

-- | <tt>sptModuleInitCode module fps</tt> is a C stub to insert the static
--   entries of <tt>module</tt> into the static pointer table.
--   
--   <tt>fps</tt> is a list associating each binding corresponding to a
--   static entry with its fingerprint.
sptModuleInitCode :: Platform -> Module -> [SptEntry] -> CStub

module GHC.Iface.Ext.Binary

-- | Read a <a>HieFile</a> from a <a>FilePath</a>. Can use an existing
--   <a>NameCache</a>.
readHieFile :: NameCacheUpdater -> FilePath -> IO HieFileResult

-- | Read a <a>HieFile</a> from a <a>FilePath</a>. Can use an existing
--   <a>NameCache</a>. Allows you to specify which versions of hieFile to
--   attempt to read. <a>Left</a> case returns the failing header versions.
readHieFileWithVersion :: (HieHeader -> Bool) -> NameCacheUpdater -> FilePath -> IO (Either HieHeader HieFileResult)
type HieHeader = (Integer, ByteString)

-- | Write a <a>HieFile</a> to the given <a>FilePath</a>, with a proper
--   header and symbol tables for <a>Name</a>s and <a>FastString</a>s
writeHieFile :: FilePath -> HieFile -> IO ()

-- | <a>Name</a>'s get converted into <a>HieName</a>'s before being written
--   into <tt>.hie</tt> files. See <a>toHieName</a> and
--   <tt>fromHieName</tt> for logic on how to convert between these two
--   types.
data HieName
ExternalName :: !Module -> !OccName -> !SrcSpan -> HieName
LocalName :: !OccName -> !SrcSpan -> HieName
KnownKeyName :: !Unique -> HieName
toHieName :: Name -> HieName
data HieFileResult
HieFileResult :: Integer -> ByteString -> HieFile -> HieFileResult
[hie_file_result_version] :: HieFileResult -> Integer
[hie_file_result_ghc_version] :: HieFileResult -> ByteString
[hie_file_result] :: HieFileResult -> HieFile

-- | The header for HIE files - Capital ASCII letters "HIE".
hieMagic :: [Word8]
hieNameOcc :: HieName -> OccName

-- | A function that atomically updates the name cache given a modifier
--   function. The second result of the modifier function will be the
--   result of the IO action.
newtype NameCacheUpdater
NCU :: (forall c. (NameCache -> (NameCache, c)) -> IO c) -> NameCacheUpdater
[updateNameCache] :: NameCacheUpdater -> forall c. (NameCache -> (NameCache, c)) -> IO c

module GHC.Iface.Ext.Ast

-- | Construct an <a>HieFile</a> from the outputs of the typechecker.
mkHieFile :: ModSummary -> TcGblEnv -> RenamedSource -> Hsc HieFile

-- | Construct an <a>HieFile</a> from the outputs of the typechecker but
--   don't read the source file again from disk.
mkHieFileWithSource :: FilePath -> ByteString -> ModSummary -> TcGblEnv -> RenamedSource -> Hsc HieFile
getCompressedAsts :: TypecheckedSource -> RenamedSource -> Bag EvBind -> [ClsInst] -> [TyCon] -> DsM (HieASTs TypeIndex, Array TypeIndex HieTypeFlat)
enrichHie :: TypecheckedSource -> RenamedSource -> Bag EvBind -> [ClsInst] -> [TyCon] -> DsM (HieASTs Type)
instance Data.Data.Data a => Data.Data.Data (GHC.Iface.Ext.Ast.PScoped a)
instance (GHC.Iface.Ext.Ast.HiePass p, GHC.Iface.Ext.Ast.AnnoBody p body, GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p)))) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.MatchGroup (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))))
instance (GHC.Iface.Ext.Ast.HiePass p, Data.Data.Data (body (GHC.Hs.Extension.GhcPass p)), GHC.Iface.Ext.Ast.AnnoBody p body, GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p)))) => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.Match (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p)))))
instance (GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))), GHC.Iface.Ext.Ast.HiePass p, GHC.Iface.Ext.Ast.AnnoBody p body) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.GRHSs (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))))
instance (GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))), GHC.Iface.Ext.Ast.HiePass p, GHC.Iface.Ext.Ast.AnnoBody p body) => GHC.Iface.Ext.Ast.ToHie (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Expr.GRHS (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p)))))
instance (GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))), GHC.Iface.Ext.Ast.AnnoBody p body, GHC.Iface.Ext.Ast.HiePass p) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.Stmt (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))))))
instance (GHC.Iface.Ext.Ast.HasLoc a, GHC.Iface.Ext.Ast.HiePass p) => GHC.Iface.Ext.Ast.HasLoc (Language.Haskell.Syntax.Decls.FamEqn (GHC.Hs.Extension.GhcPass p) a)
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.HasType (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.HsBind (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.HasType (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Pat.Pat (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.HasType (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass 'GHC.Hs.Extension.Renamed
instance GHC.Iface.Ext.Ast.HiePass 'GHC.Hs.Extension.Typechecked
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.BindContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.HsBind (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Binds.PatSynBind (GHC.Hs.Extension.GhcPass p) (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Binds.HsPatSynDir (GHC.Hs.Extension.GhcPass p))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.HsMatchContext (GHC.Hs.Extension.GhcPass p))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.HsStmtContext (GHC.Hs.Extension.GhcPass p))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.PScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Pat.Pat (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.HsTupArg (GHC.Hs.Extension.GhcPass p))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (Language.Haskell.Syntax.Binds.HsLocalBinds (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.IPBind (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (Language.Haskell.Syntax.Binds.HsValBindsLR (GHC.Hs.Extension.GhcPass p) (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Hs.Binds.NHsValBindsLR (GHC.Hs.Extension.GhcPass p)))
instance (GHC.Iface.Ext.Ast.ToHie arg, GHC.Iface.Ext.Ast.HasLoc arg, Data.Data.Data arg, GHC.Iface.Ext.Ast.HiePass p) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RContext (Language.Haskell.Syntax.Pat.HsRecFields (GHC.Hs.Extension.GhcPass p) arg))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (Language.Haskell.Syntax.Expr.ApplicativeArg (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Expr.HsCmdTop (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.SigContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.Sig (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsSplice (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (Language.Haskell.Syntax.Type.FieldOcc (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.PatSynFieldContext (Language.Haskell.Syntax.Binds.RecordPatSynField (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.ToHie Data.Void.Void
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie [a]
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie (GHC.Data.Bag.Bag a)
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie (GHC.Maybe.Maybe a)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.IEContext (GHC.Parser.Annotation.LocatedA GHC.Unit.Module.Name.ModuleName))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located a)) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Parser.Annotation.LocatedN a))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located a)) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Parser.Annotation.LocatedA a))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located GHC.Types.Var.Var))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located GHC.Types.Name.Name))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.EvBindContext (GHC.Parser.Annotation.LocatedA GHC.Tc.Types.Evidence.TcEvBinds))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA GHC.Tc.Types.Evidence.HsWrapper)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located Language.Haskell.Syntax.Extension.NoExtField))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Type.HsPatSigType GHC.Hs.Extension.GhcRn))
instance (GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RFContext (GHC.Types.SrcLoc.Located label)), GHC.Iface.Ext.Ast.ToHie arg, GHC.Iface.Ext.Ast.HasLoc arg, Data.Data.Data arg, Data.Data.Data label) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Pat.HsRecField' label arg)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RFContext (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Type.FieldOcc GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RFContext (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Type.FieldOcc GHC.Hs.Extension.GhcTc)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RFContext (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Type.AmbiguousFieldOcc GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RFContext (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Type.AmbiguousFieldOcc GHC.Hs.Extension.GhcTc)))
instance (GHC.Iface.Ext.Ast.ToHie tyarg, GHC.Iface.Ext.Ast.ToHie arg, GHC.Iface.Ext.Ast.ToHie rec) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Type.HsConDetails tyarg arg rec)
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.HsConDeclGADTDetails GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.TyClGroup GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.TyClDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.FamilyDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.FamilyInfo GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Decls.FamilyResultSig GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.FunDep GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcRn (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn))))
instance (GHC.Iface.Ext.Ast.ToHie rhs, GHC.Iface.Ext.Ast.HasLoc rhs) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcRn rhs)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Decls.InjectivityAnn GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Types.SrcLoc.Located [GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcRn)])
instance GHC.Iface.Ext.Ast.ToHie (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedC (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Decls.DerivStrategy GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedP GHC.Types.Basic.OverlapMode)
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcRn a)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedL [GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcRn)])
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcRn))))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn))))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data flag => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TVScoped (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn))
instance (GHC.Iface.Ext.Ast.ToHie tm, GHC.Iface.Ext.Ast.ToHie ty) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Type.HsArg tm ty)
instance Data.Data.Data flag => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TVScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Type.LHsQTyVars GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedC [GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn)])
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.LHsExpr a) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.ArithSeqInfo a)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.SpliceDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.HsBracket a)
instance GHC.Iface.Ext.Ast.ToHie GHC.Hs.Expr.PendingRnSplice
instance GHC.Iface.Ext.Ast.ToHie GHC.Hs.Expr.PendingTcSplice
instance GHC.Iface.Ext.Ast.ToHie (GHC.Data.BooleanFormula.LBooleanFormula (GHC.Parser.Annotation.LocatedN GHC.Types.Name.Name))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Types.SrcLoc.Located Language.Haskell.Syntax.Type.HsIPName)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.RoleAnnotDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.InstDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.ClsInstDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.DataFamInstDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.TyFamInstDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.DerivDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.FixitySig GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.DefaultDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.ForeignDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie Language.Haskell.Syntax.Decls.ForeignImport
instance GHC.Iface.Ext.Ast.ToHie Language.Haskell.Syntax.Decls.ForeignExport
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.WarnDecls GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.WarnDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.AnnDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.AnnProvenance GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.RuleDecls GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.RuleDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Decls.RuleBndr GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (GHC.Hs.ImpExp.ImportDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.IEContext (GHC.Parser.Annotation.LocatedA (GHC.Hs.ImpExp.IE GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.IEContext (GHC.Hs.ImpExp.LIEWrappedName GHC.Types.Name.Name))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.IEContext (GHC.Types.SrcLoc.Located GHC.Types.FieldLabel.FieldLabel))
instance GHC.Iface.Ext.Ast.HasLoc thing => GHC.Iface.Ext.Ast.HasLoc (GHC.Iface.Ext.Ast.PScoped thing)
instance GHC.Iface.Ext.Ast.HasLoc (GHC.Types.SrcLoc.Located a)
instance GHC.Iface.Ext.Ast.HasLoc (GHC.Parser.Annotation.LocatedA a)
instance GHC.Iface.Ext.Ast.HasLoc (GHC.Parser.Annotation.LocatedN a)
instance GHC.Iface.Ext.Ast.HasLoc a => GHC.Iface.Ext.Ast.HasLoc [a]
instance (GHC.Iface.Ext.Ast.HasLoc tm, GHC.Iface.Ext.Ast.HasLoc ty) => GHC.Iface.Ext.Ast.HasLoc (Language.Haskell.Syntax.Type.HsArg tm ty)
instance GHC.Iface.Ext.Ast.HasLoc (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ModifyState GHC.Types.Name.Name
instance GHC.Iface.Ext.Ast.ModifyState GHC.Types.Var.Id

module GHC.HsToCore

-- | Main entry point to the desugarer.
deSugar :: HscEnv -> ModLocation -> TcGblEnv -> IO (Messages DecoratedSDoc, Maybe ModGuts)
deSugarExpr :: HscEnv -> LHsExpr GhcTc -> IO (Messages DecoratedSDoc, Maybe CoreExpr)

module GHC.HsToCore.Foreign.Decl
dsForeigns :: [LForeignDecl GhcTc] -> DsM (ForeignStubs, OrdList Binding)

module GHC.HsToCore.Foreign.Call
dsCCall :: CLabelString -> [CoreExpr] -> Safety -> Type -> DsM CoreExpr
mkFCall :: DynFlags -> Unique -> ForeignCall -> [CoreExpr] -> Type -> CoreExpr
unboxArg :: CoreExpr -> DsM (CoreExpr, CoreExpr -> CoreExpr)
boxResult :: Type -> DsM (Type, CoreExpr -> CoreExpr)
resultWrapper :: Type -> DsM (Maybe Type, CoreExpr -> CoreExpr)

module GHC.CoreToStg.Prep
corePrepPgm :: HscEnv -> Module -> ModLocation -> CoreProgram -> [TyCon] -> IO (CoreProgram, Set CostCentre)
corePrepExpr :: HscEnv -> CoreExpr -> IO CoreExpr

-- | Create a function that converts Bignum literals into their final
--   CoreExpr
mkConvertNumLiteral :: HscEnv -> IO (LitNumType -> Integer -> Maybe CoreExpr)
instance GHC.Utils.Outputable.Outputable GHC.CoreToStg.Prep.Floats
instance GHC.Utils.Outputable.Outputable GHC.CoreToStg.Prep.OkToSpec
instance GHC.Utils.Outputable.Outputable GHC.CoreToStg.Prep.FloatingBind
instance GHC.Utils.Outputable.Outputable GHC.CoreToStg.Prep.ArgInfo


-- | This module is not used by GHC itself. Rather, it exports all of the
--   functions and types you are likely to need when writing a plugin for
--   GHC. So authors of plugins can probably get away simply with saying
--   "import GHC.Plugins".
--   
--   Particularly interesting modules for plugin writers include
--   <a>GHC.Core</a> and <a>GHC.Core.Opt.Monad</a>.
module GHC.Plugins
mkRecFldSelOcc :: String -> OccName
mkVarOccFS :: FastString -> OccName
occNameString :: OccName -> String

-- | Other names in the compiler add additional information to an OccName.
--   This class provides a consistent way to access the underlying OccName.
class HasOccName name
occName :: HasOccName name => name -> OccName

-- | Occurrence Name
--   
--   In this context that means: "classified (i.e. as a type name, value
--   name, etc) but not qualified and not yet resolved"
data OccName
emptyFsEnv :: FastStringEnv a
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
mkFsEnv :: [(FastString, a)] -> FastStringEnv a

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DFastStringEnv if the set
--   eventually gets converted into a list or folded over in a way where
--   the order changes the generated code.
type FastStringEnv a = UniqFM FastString a
alterOccEnv :: (Maybe elt -> Maybe elt) -> OccEnv elt -> OccName -> OccEnv elt
avoidClashesOccEnv :: TidyOccEnv -> [OccName] -> TidyOccEnv
clsName :: NameSpace
dataName :: NameSpace
delFromOccEnv :: OccEnv a -> OccName -> OccEnv a
delListFromOccEnv :: OccEnv a -> [OccName] -> OccEnv a
delTidyOccEnvList :: TidyOccEnv -> [FastString] -> TidyOccEnv
demoteOccName :: OccName -> Maybe OccName
elemOccEnv :: OccName -> OccEnv a -> Bool
elemOccSet :: OccName -> OccSet -> Bool
emptyOccEnv :: OccEnv a
emptyOccSet :: OccSet
emptyTidyOccEnv :: TidyOccEnv
extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a
extendOccEnvList :: OccEnv a -> [(OccName, a)] -> OccEnv a
extendOccEnv_Acc :: (a -> b -> b) -> (a -> b) -> OccEnv b -> OccName -> a -> OccEnv b
extendOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccName -> a -> OccEnv a
extendOccSet :: OccSet -> OccName -> OccSet
extendOccSetList :: OccSet -> [OccName] -> OccSet
filterOccEnv :: (elt -> Bool) -> OccEnv elt -> OccEnv elt
filterOccSet :: (OccName -> Bool) -> OccSet -> OccSet
foldOccEnv :: (a -> b -> b) -> b -> OccEnv a -> b
initTidyOccEnv :: [OccName] -> TidyOccEnv
intersectOccSet :: OccSet -> OccSet -> OccSet
isDataConNameSpace :: NameSpace -> Bool
isDataOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is a data constructor that starts with a
--   symbol (e.g. <tt>:</tt>, or <tt>[]</tt>)
isDataSymOcc :: OccName -> Bool
isDefaultMethodOcc :: OccName -> Bool

-- | Test for definitions internally generated by GHC. This predicate is
--   used to suppress printing of internal definitions in some debug prints
isDerivedOccName :: OccName -> Bool
isEmptyOccSet :: OccSet -> Bool

-- | Test if the <a>OccName</a> is that for any operator (whether it is a
--   data constructor or variable or whatever)
isSymOcc :: OccName -> Bool
isTcClsNameSpace :: NameSpace -> Bool
isTcOcc :: OccName -> Bool
isTvNameSpace :: NameSpace -> Bool
isTvOcc :: OccName -> Bool

-- | Is an <a>OccName</a> one of a Typeable <tt>TyCon</tt> or
--   <tt>Module</tt> binding? This is needed as these bindings are renamed
--   differently. See Note [Grand plan for Typeable] in
--   <a>GHC.Tc.Instance.Typeable</a>.
isTypeableBindOcc :: OccName -> Bool
isValNameSpace :: NameSpace -> Bool

-- | <i>Value</i> <tt>OccNames</tt>s are those that are either in the
--   variable or data constructor namespaces
isValOcc :: OccName -> Bool
isVarNameSpace :: NameSpace -> Bool
isVarOcc :: OccName -> Bool
lookupOccEnv :: OccEnv a -> OccName -> Maybe a
mapOccEnv :: (a -> b) -> OccEnv a -> OccEnv b
minusOccSet :: OccSet -> OccSet -> OccSet
mkBuilderOcc :: OccName -> OccName
mkClassDataConOcc :: OccName -> OccName
mkClassOpAuxOcc :: OccName -> OccName
mkClsOcc :: String -> OccName
mkClsOccFS :: FastString -> OccName
mkCon2TagOcc :: OccName -> OccName
mkDFunOcc :: String -> Bool -> OccSet -> OccName
mkDataCOcc :: OccName -> OccName
mkDataConWorkerOcc :: OccName -> OccName
mkDataConWrapperOcc :: OccName -> OccName
mkDataOcc :: String -> OccName
mkDataOccFS :: FastString -> OccName
mkDataTOcc :: OccName -> OccName
mkDefaultMethodOcc :: OccName -> OccName
mkDictOcc :: OccName -> OccName
mkEqPredCoOcc :: OccName -> OccName
mkForeignExportOcc :: OccName -> OccName
mkGen1R :: OccName -> OccName
mkGenR :: OccName -> OccName
mkIPOcc :: OccName -> OccName
mkInstTyCoOcc :: OccName -> OccName

-- | Derive a name for the representation type constructor of a
--   <tt>data</tt>/<tt>newtype</tt> instance.
mkInstTyTcOcc :: String -> OccSet -> OccName
mkLocalOcc :: Unique -> OccName -> OccName
mkMatcherOcc :: OccName -> OccName
mkMaxTagOcc :: OccName -> OccName
mkMethodOcc :: OccName -> OccName
mkNewTyCoOcc :: OccName -> OccName
mkOccEnv :: [(OccName, a)] -> OccEnv a
mkOccEnv_C :: (a -> a -> a) -> [(OccName, a)] -> OccEnv a
mkOccName :: NameSpace -> String -> OccName
mkOccNameFS :: NameSpace -> FastString -> OccName
mkOccSet :: [OccName] -> OccSet
mkRepEqOcc :: OccName -> OccName
mkSpecOcc :: OccName -> OccName
mkSuperDictAuxOcc :: Int -> OccName -> OccName
mkSuperDictSelOcc :: Int -> OccName -> OccName
mkTag2ConOcc :: OccName -> OccName
mkTcOcc :: String -> OccName
mkTcOccFS :: FastString -> OccName
mkTyConRepOcc :: OccName -> OccName
mkTyVarOcc :: String -> OccName
mkTyVarOccFS :: FastString -> OccName
mkVarOcc :: String -> OccName
mkWorkerOcc :: OccName -> OccName
nameSpacesRelated :: NameSpace -> NameSpace -> Bool
occEnvElts :: OccEnv a -> [a]

-- | Wrap parens around an operator
parenSymOcc :: OccName -> SDoc -> SDoc
plusOccEnv :: OccEnv a -> OccEnv a -> OccEnv a
plusOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccEnv a -> OccEnv a
pprNameSpace :: NameSpace -> SDoc
pprNameSpaceBrief :: NameSpace -> SDoc
pprNonVarNameSpace :: NameSpace -> SDoc
pprOccEnv :: (a -> SDoc) -> OccEnv a -> SDoc
pprOccName :: OccName -> SDoc
promoteOccName :: OccName -> Maybe OccName
setOccNameSpace :: NameSpace -> OccName -> OccName
srcDataName :: NameSpace

-- | Haskell 98 encourages compilers to suppress warnings about unused
--   names in a pattern if they start with <tt>_</tt>: this implements that
--   test
startsWithUnderscore :: OccName -> Bool
tcClsName :: NameSpace
tcName :: NameSpace
tidyOccName :: TidyOccEnv -> OccName -> (TidyOccEnv, OccName)
tvName :: NameSpace
unionManyOccSets :: [OccSet] -> OccSet
unionOccSets :: OccSet -> OccSet -> OccSet
unitOccEnv :: OccName -> a -> OccEnv a
unitOccSet :: OccName -> OccSet
data NameSpace
data OccEnv a
type OccSet = UniqSet OccName
type TidyOccEnv = UniqFM FastString Int
mkRecFldSelOcc :: String -> OccName
mkVarOccFS :: FastString -> OccName
occNameString :: OccName -> String

-- | Other names in the compiler add additional information to an OccName.
--   This class provides a consistent way to access the underlying OccName.
class HasOccName name
occName :: HasOccName name => name -> OccName

-- | Occurrence Name
--   
--   In this context that means: "classified (i.e. as a type name, value
--   name, etc) but not qualified and not yet resolved"
data OccName
emptyFsEnv :: FastStringEnv a
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
mkFsEnv :: [(FastString, a)] -> FastStringEnv a

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DFastStringEnv if the set
--   eventually gets converted into a list or folded over in a way where
--   the order changes the generated code.
type FastStringEnv a = UniqFM FastString a
nameOccName :: Name -> OccName
nameUnique :: Name -> Unique
setNameUnique :: Name -> Unique -> Name
tidyNameOcc :: Name -> OccName -> Name

-- | A unique, unambiguous name for something, containing information about
--   where that thing originated.
data Name

-- | A class allowing convenient access to the <a>Name</a> of various
--   datatypes
class NamedThing a
getOccName :: NamedThing a => a -> OccName
getName :: NamedThing a => a -> Name
alterOccEnv :: (Maybe elt -> Maybe elt) -> OccEnv elt -> OccName -> OccEnv elt
avoidClashesOccEnv :: TidyOccEnv -> [OccName] -> TidyOccEnv
clsName :: NameSpace
dataName :: NameSpace
delFromOccEnv :: OccEnv a -> OccName -> OccEnv a
delListFromOccEnv :: OccEnv a -> [OccName] -> OccEnv a
delTidyOccEnvList :: TidyOccEnv -> [FastString] -> TidyOccEnv
demoteOccName :: OccName -> Maybe OccName
elemOccEnv :: OccName -> OccEnv a -> Bool
elemOccSet :: OccName -> OccSet -> Bool
emptyOccEnv :: OccEnv a
emptyOccSet :: OccSet
emptyTidyOccEnv :: TidyOccEnv
extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a
extendOccEnvList :: OccEnv a -> [(OccName, a)] -> OccEnv a
extendOccEnv_Acc :: (a -> b -> b) -> (a -> b) -> OccEnv b -> OccName -> a -> OccEnv b
extendOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccName -> a -> OccEnv a
extendOccSet :: OccSet -> OccName -> OccSet
extendOccSetList :: OccSet -> [OccName] -> OccSet
filterOccEnv :: (elt -> Bool) -> OccEnv elt -> OccEnv elt
filterOccSet :: (OccName -> Bool) -> OccSet -> OccSet
foldOccEnv :: (a -> b -> b) -> b -> OccEnv a -> b
initTidyOccEnv :: [OccName] -> TidyOccEnv
intersectOccSet :: OccSet -> OccSet -> OccSet
isDataConNameSpace :: NameSpace -> Bool
isDataOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is a data constructor that starts with a
--   symbol (e.g. <tt>:</tt>, or <tt>[]</tt>)
isDataSymOcc :: OccName -> Bool
isDefaultMethodOcc :: OccName -> Bool

-- | Test for definitions internally generated by GHC. This predicate is
--   used to suppress printing of internal definitions in some debug prints
isDerivedOccName :: OccName -> Bool
isEmptyOccSet :: OccSet -> Bool

-- | Test if the <a>OccName</a> is that for any operator (whether it is a
--   data constructor or variable or whatever)
isSymOcc :: OccName -> Bool
isTcClsNameSpace :: NameSpace -> Bool
isTcOcc :: OccName -> Bool
isTvNameSpace :: NameSpace -> Bool
isTvOcc :: OccName -> Bool

-- | Is an <a>OccName</a> one of a Typeable <tt>TyCon</tt> or
--   <tt>Module</tt> binding? This is needed as these bindings are renamed
--   differently. See Note [Grand plan for Typeable] in
--   <a>GHC.Tc.Instance.Typeable</a>.
isTypeableBindOcc :: OccName -> Bool
isValNameSpace :: NameSpace -> Bool

-- | <i>Value</i> <tt>OccNames</tt>s are those that are either in the
--   variable or data constructor namespaces
isValOcc :: OccName -> Bool
isVarNameSpace :: NameSpace -> Bool
isVarOcc :: OccName -> Bool
lookupOccEnv :: OccEnv a -> OccName -> Maybe a
mapOccEnv :: (a -> b) -> OccEnv a -> OccEnv b
minusOccSet :: OccSet -> OccSet -> OccSet
mkBuilderOcc :: OccName -> OccName
mkClassDataConOcc :: OccName -> OccName
mkClassOpAuxOcc :: OccName -> OccName
mkClsOcc :: String -> OccName
mkClsOccFS :: FastString -> OccName
mkCon2TagOcc :: OccName -> OccName
mkDFunOcc :: String -> Bool -> OccSet -> OccName
mkDataCOcc :: OccName -> OccName
mkDataConWorkerOcc :: OccName -> OccName
mkDataConWrapperOcc :: OccName -> OccName
mkDataOcc :: String -> OccName
mkDataOccFS :: FastString -> OccName
mkDataTOcc :: OccName -> OccName
mkDefaultMethodOcc :: OccName -> OccName
mkDictOcc :: OccName -> OccName
mkEqPredCoOcc :: OccName -> OccName
mkForeignExportOcc :: OccName -> OccName
mkGen1R :: OccName -> OccName
mkGenR :: OccName -> OccName
mkIPOcc :: OccName -> OccName
mkInstTyCoOcc :: OccName -> OccName

-- | Derive a name for the representation type constructor of a
--   <tt>data</tt>/<tt>newtype</tt> instance.
mkInstTyTcOcc :: String -> OccSet -> OccName
mkLocalOcc :: Unique -> OccName -> OccName
mkMatcherOcc :: OccName -> OccName
mkMaxTagOcc :: OccName -> OccName
mkMethodOcc :: OccName -> OccName
mkNewTyCoOcc :: OccName -> OccName
mkOccEnv :: [(OccName, a)] -> OccEnv a
mkOccEnv_C :: (a -> a -> a) -> [(OccName, a)] -> OccEnv a
mkOccName :: NameSpace -> String -> OccName
mkOccNameFS :: NameSpace -> FastString -> OccName
mkOccSet :: [OccName] -> OccSet
mkRepEqOcc :: OccName -> OccName
mkSpecOcc :: OccName -> OccName
mkSuperDictAuxOcc :: Int -> OccName -> OccName
mkSuperDictSelOcc :: Int -> OccName -> OccName
mkTag2ConOcc :: OccName -> OccName
mkTcOcc :: String -> OccName
mkTcOccFS :: FastString -> OccName
mkTyConRepOcc :: OccName -> OccName
mkTyVarOcc :: String -> OccName
mkTyVarOccFS :: FastString -> OccName
mkVarOcc :: String -> OccName
mkWorkerOcc :: OccName -> OccName
nameSpacesRelated :: NameSpace -> NameSpace -> Bool
occEnvElts :: OccEnv a -> [a]

-- | Wrap parens around an operator
parenSymOcc :: OccName -> SDoc -> SDoc
plusOccEnv :: OccEnv a -> OccEnv a -> OccEnv a
plusOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccEnv a -> OccEnv a
pprNameSpace :: NameSpace -> SDoc
pprNameSpaceBrief :: NameSpace -> SDoc
pprNonVarNameSpace :: NameSpace -> SDoc
pprOccEnv :: (a -> SDoc) -> OccEnv a -> SDoc
pprOccName :: OccName -> SDoc
promoteOccName :: OccName -> Maybe OccName
setOccNameSpace :: NameSpace -> OccName -> OccName
srcDataName :: NameSpace

-- | Haskell 98 encourages compilers to suppress warnings about unused
--   names in a pattern if they start with <tt>_</tt>: this implements that
--   test
startsWithUnderscore :: OccName -> Bool
tcClsName :: NameSpace
tcName :: NameSpace
tidyOccName :: TidyOccEnv -> OccName -> (TidyOccEnv, OccName)
tvName :: NameSpace
unionManyOccSets :: [OccSet] -> OccSet
unionOccSets :: OccSet -> OccSet -> OccSet
unitOccEnv :: OccName -> a -> OccEnv a
unitOccSet :: OccName -> OccSet
data NameSpace
data OccEnv a
type OccSet = UniqSet OccName
type TidyOccEnv = UniqFM FastString Int
getOccFS :: NamedThing a => a -> FastString
getOccString :: NamedThing a => a -> String
getSrcLoc :: NamedThing a => a -> SrcLoc
getSrcSpan :: NamedThing a => a -> SrcSpan
isBuiltInSyntax :: Name -> Bool
isDataConName :: Name -> Bool

-- | Will the <a>Name</a> come from a dynamically linked package?
isDynLinkName :: Platform -> Module -> Name -> Bool
isExternalName :: Name -> Bool
isHoleName :: Name -> Bool
isInternalName :: Name -> Bool
isSystemName :: Name -> Bool
isTyConName :: Name -> Bool
isTyVarName :: Name -> Bool
isValName :: Name -> Bool
isVarName :: Name -> Bool
isWiredIn :: NamedThing thing => thing -> Bool
isWiredInName :: Name -> Bool

-- | Make the <a>Name</a> into an internal name, regardless of what it was
--   to begin with
localiseName :: Name -> Name
mkClonedInternalName :: Unique -> Name -> Name
mkDerivedInternalName :: (OccName -> OccName) -> Unique -> Name -> Name

-- | Create a name which definitely originates in the given module
mkExternalName :: Unique -> Module -> OccName -> SrcSpan -> Name

-- | Make a name for a foreign call
mkFCallName :: Unique -> String -> Name

-- | Create a name which is (for now at least) local to the current module
--   and hence does not need a <a>Module</a> to disambiguate it from other
--   <a>Name</a>s
mkInternalName :: Unique -> OccName -> SrcSpan -> Name
mkSysTvName :: Unique -> FastString -> Name

-- | Create a name brought into being by the compiler
mkSystemName :: Unique -> OccName -> Name
mkSystemNameAt :: Unique -> OccName -> SrcSpan -> Name
mkSystemVarName :: Unique -> FastString -> Name

-- | Create a name which is actually defined by the compiler itself
mkWiredInName :: Module -> OccName -> Unique -> TyThing -> BuiltInSyntax -> Name

-- | Returns True if the Name comes from some other package: neither this
--   package nor the interactive package.
nameIsFromExternalPackage :: HomeUnit -> Name -> Bool
nameIsHomePackage :: Module -> Name -> Bool
nameIsHomePackageImport :: Module -> Name -> Bool

-- | Returns True if the name is (a) Internal (b) External but from the
--   specified module (c) External but from the <tt>interactive</tt>
--   package
--   
--   The key idea is that False means: the entity is defined in some other
--   module you can find the details (type, fixity, instances) in some
--   interface file those details will be stored in the EPT or HPT
--   
--   True means: the entity is defined in this module or earlier in the
--   GHCi session you can find details (type, fixity, instances) in the
--   TcGblEnv or TcLclEnv
--   
--   The isInteractiveModule part is because successive interactions of a
--   GHCi session each give rise to a fresh module (Ghci1, Ghci2, etc), but
--   they all come from the magic <tt>interactive</tt> package; and all the
--   details are kept in the TcLclEnv, TcGblEnv, NOT in the HPT or EPT. See
--   Note [The interactive package] in <a>GHC.Runtime.Context</a>
nameIsLocalOrFrom :: Module -> Name -> Bool
nameModule :: HasDebugCallStack => Name -> Module
nameModule_maybe :: Name -> Maybe Module
nameNameSpace :: Name -> NameSpace
nameSrcLoc :: Name -> SrcLoc
nameSrcSpan :: Name -> SrcSpan

-- | Get a string representation of a <a>Name</a> that's unique and stable
--   across recompilations. Used for deterministic generation of binds for
--   derived instances. eg.
--   "$aeson_70dylHtv1FFGeai1IoxcQr$Data.Aeson.Types.Internal$String"
nameStableString :: Name -> String
pprDefinedAt :: Name -> SDoc
pprInfixName :: (Outputable a, NamedThing a) => a -> SDoc
pprModulePrefix :: PprStyle -> Module -> OccName -> SDoc
pprNameDefnLoc :: Name -> SDoc

-- | Print the string of Name unqualifiedly directly.
pprNameUnqualified :: Name -> SDoc
pprPrefixName :: NamedThing a => a -> SDoc
setNameLoc :: Name -> SrcSpan -> Name

-- | Compare Names lexicographically This only works for Names that
--   originate in the source code or have been tidied.
stableNameCmp :: Name -> Name -> Ordering
wiredInNameTyThing_maybe :: Name -> Maybe TyThing

-- | BuiltInSyntax is for things like <tt>(:)</tt>, <tt>[]</tt> and tuples,
--   which have special syntactic forms. They aren't in scope as such.
data BuiltInSyntax
BuiltInSyntax :: BuiltInSyntax
UserSyntax :: BuiltInSyntax

-- | Identifier
type Id = Var

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var
idName :: Id -> Name

-- | If it's a local, make it global
globaliseId :: Id -> Id
idDetails :: Id -> IdDetails
idInfo :: HasDebugCallStack => Id -> IdInfo

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool
isGlobalId :: Var -> Bool

-- | Is this a value-level (i.e., computationally relevant)
--   <a>Var</a>entifier? Satisfies <tt>isId = not . isTyVar</tt>.
isId :: Var -> Bool
isLocalId :: Var -> Bool
setIdMult :: Id -> Mult -> Id
updateIdTypeAndMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMultM :: Monad m => (Type -> m Type) -> Id -> m Id
updateIdTypeButNotMult :: (Type -> Type) -> Id -> Id
type InId = Id
type InVar = Var
type JoinId = Id
type OutId = Id
type OutVar = Var
asJoinId :: Id -> JoinArity -> JoinId
infixl 1 `asJoinId`
asJoinId_maybe :: Id -> Maybe JoinArity -> Id
infixl 1 `asJoinId_maybe`
clearOneShotLambda :: Id -> Id

-- | Returns <tt>True</tt> of an <a>Id</a> which may not have a binding,
--   even though it is defined in this module.
hasNoBinding :: Id -> Bool
idArity :: Id -> Arity
idCafInfo :: Id -> CafInfo
infixl 1 `idCafInfo`
idCallArity :: Id -> Arity
idCoreRules :: Id -> [CoreRule]
idCprInfo :: Id -> CprSig

-- | Get from either the worker or the wrapper <a>Id</a> to the
--   <a>DataCon</a>. Currently used only in the desugarer.
--   
--   INVARIANT: <tt>idDataCon (dataConWrapId d) = d</tt>: remember,
--   <a>dataConWrapId</a> can return either the wrapper or the worker
idDataCon :: Id -> DataCon
idDemandInfo :: Id -> Demand
idFunRepArity :: Id -> RepArity
idHasRules :: Id -> Bool
idInlineActivation :: Id -> Activation
idInlinePragma :: Id -> InlinePragma
idIsFrom :: Module -> Id -> Bool
idJoinArity :: JoinId -> JoinArity
idLFInfo_maybe :: Id -> Maybe LambdaFormInfo
idMult :: Id -> Mult
idOccInfo :: Id -> OccInfo
idOneShotInfo :: Id -> OneShotInfo
idRuleMatchInfo :: Id -> RuleMatchInfo
idScaledType :: Id -> Scaled Type
idSpecialisation :: Id -> RuleInfo

-- | Like <a>idOneShotInfo</a>, but taking the Horrible State Hack in to
--   account See Note [The state-transformer hack] in
--   <a>GHC.Core.Opt.Arity</a>
idStateHackOneShotInfo :: Id -> OneShotInfo

-- | Accesses the <tt>Id'</tt>s <a>strictnessInfo</a>.
idStrictness :: Id -> StrictSig
idType :: Id -> Kind
idUnfolding :: Id -> Unfolding
idUnique :: Id -> Unique
isClassOpId :: Id -> Bool
isClassOpId_maybe :: Id -> Maybe Class
isConLikeId :: Id -> Bool
isDFunId :: Id -> Bool
isDataConId_maybe :: Id -> Maybe DataCon
isDataConRecordSelector :: Id -> Bool
isDataConWorkId :: Id -> Bool
isDataConWorkId_maybe :: Id -> Maybe DataCon
isDataConWrapId :: Id -> Bool
isDataConWrapId_maybe :: Id -> Maybe DataCon
isDeadBinder :: Id -> Bool

-- | Returns true if an application to n args diverges or throws an
--   exception See Note [Dead ends] in <a>GHC.Types.Demand</a>.
isDeadEndId :: Var -> Bool
isFCallId :: Id -> Bool
isFCallId_maybe :: Id -> Maybe ForeignCall

-- | <a>isImplicitId</a> tells whether an <a>Id</a>s info is implied by
--   other declarations, so we don't need to put its signature in an
--   interface file, even if it's mentioned in some other interface
--   unfolding.
isImplicitId :: Id -> Bool
isJoinId :: Var -> Bool
isJoinId_maybe :: Var -> Maybe JoinArity
isNaughtyRecordSelector :: Id -> Bool
isNeverLevPolyId :: Id -> Bool

-- | Returns whether the lambda associated with the <a>Id</a> is certainly
--   applied at most once This one is the "business end", called
--   externally. It works on type variables as well as Ids, returning True
--   Its main purpose is to encapsulate the Horrible State Hack See Note
--   [The state-transformer hack] in <a>GHC.Core.Opt.Arity</a>
isOneShotBndr :: Var -> Bool
isPatSynRecordSelector :: Id -> Bool
isPrimOpId :: Id -> Bool
isPrimOpId_maybe :: Id -> Maybe PrimOp
isProbablyOneShotLambda :: Id -> Bool
isRecordSelector :: Id -> Bool
isStateHackType :: Type -> Bool

-- | This predicate says whether the <a>Id</a> has a strict demand placed
--   on it or has a type such that it can always be evaluated strictly (i.e
--   an unlifted type, as of GHC 7.6). We need to check separately whether
--   the <a>Id</a> has a so-called "strict type" because if the demand for
--   the given <tt>id</tt> hasn't been computed yet but <tt>id</tt> has a
--   strict type, we still want <tt>isStrictId id</tt> to be <tt>True</tt>.
isStrictId :: Id -> Bool
localiseId :: Id -> Id
maybeModifyIdInfo :: Maybe IdInfo -> Id -> Id

-- | Create a local <a>Id</a> that is marked as exported. This prevents
--   things attached to it from being removed as dead code. See Note
--   [Exported LocalIds]
mkExportedLocalId :: IdDetails -> Name -> Type -> Id
mkExportedVanillaId :: Name -> Type -> Id

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>GHC.Types.Var.Var#globalvslocal</a>
mkGlobalId :: IdDetails -> Name -> Type -> IdInfo -> Id

-- | Make a local CoVar
mkLocalCoVar :: Name -> Type -> CoVar

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>GHC.Types.Var#globalvslocal</a>
mkLocalId :: HasDebugCallStack => Name -> Mult -> Type -> Id

-- | Like <a>mkLocalId</a>, but checks the type to see if it should make a
--   covar
mkLocalIdOrCoVar :: Name -> Mult -> Type -> Id
mkLocalIdWithInfo :: HasDebugCallStack => Name -> Mult -> Type -> IdInfo -> Id
mkScaledTemplateLocal :: Int -> Scaled Type -> Id

-- | Create a system local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>Var#globalvslocal</a>) that are created by the compiler out of thin
--   air
mkSysLocal :: FastString -> Unique -> Mult -> Type -> Id
mkSysLocalM :: MonadUnique m => FastString -> Mult -> Type -> m Id

-- | Like <a>mkSysLocal</a>, but checks to see if we have a covar type
mkSysLocalOrCoVar :: FastString -> Unique -> Mult -> Type -> Id
mkSysLocalOrCoVarM :: MonadUnique m => FastString -> Mult -> Type -> m Id

-- | Create a <i>template local</i>: a family of system local <a>Id</a>s in
--   bijection with <tt>Int</tt>s, typically used in unfoldings
mkTemplateLocal :: Int -> Type -> Id

-- | Create a template local for a series of types
mkTemplateLocals :: [Type] -> [Id]

-- | Create a template local for a series of type, but start from a
--   specified template local
mkTemplateLocalsNum :: Int -> [Type] -> [Id]

-- | Create a user local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>GHC.Types.Var#globalvslocal</a>) with a name and location that the
--   user might recognize
mkUserLocal :: OccName -> Unique -> Mult -> Type -> SrcSpan -> Id

-- | Like <a>mkUserLocal</a>, but checks if we have a coercion type
mkUserLocalOrCoVar :: OccName -> Unique -> Mult -> Type -> SrcSpan -> Id

-- | Make a global <a>Id</a> without any extra information at all
mkVanillaGlobal :: Name -> Type -> Id

-- | Make a global <a>Id</a> with no global information but some generic
--   <a>IdInfo</a>
mkVanillaGlobalWithInfo :: Name -> Type -> IdInfo -> Id

-- | Workers get local names. <a>CoreTidy</a> will externalise these if
--   necessary
mkWorkerId :: Unique -> Id -> Type -> Id
modifyIdInfo :: HasDebugCallStack => (IdInfo -> IdInfo) -> Id -> Id
modifyInlinePragma :: Id -> (InlinePragma -> InlinePragma) -> Id
realIdUnfolding :: Id -> Unfolding

-- | If the <a>Id</a> is that for a record selector, extract the
--   <a>sel_tycon</a>. Panic otherwise.
recordSelectorTyCon :: Id -> RecSelParent
recordSelectorTyCon_maybe :: Id -> Maybe RecSelParent
scaleIdBy :: Mult -> Id -> Id

-- | Like <a>scaleIdBy</a>, but skips non-Ids. Useful for scaling a mixed
--   list of ids and tyvars.
scaleVarBy :: Mult -> Var -> Var
setCaseBndrEvald :: StrictnessMark -> Id -> Id
setIdArity :: Id -> Arity -> Id
infixl 1 `setIdArity`
setIdCafInfo :: Id -> CafInfo -> Id
setIdCallArity :: Id -> Arity -> Id
infixl 1 `setIdCallArity`
setIdCprInfo :: Id -> CprSig -> Id
infixl 1 `setIdCprInfo`
setIdDemandInfo :: Id -> Demand -> Id
infixl 1 `setIdDemandInfo`
setIdInfo :: Id -> IdInfo -> Id
setIdLFInfo :: Id -> LambdaFormInfo -> Id
setIdName :: Id -> Name -> Id
setIdOccInfo :: Id -> OccInfo -> Id
infixl 1 `setIdOccInfo`
setIdOneShotInfo :: Id -> OneShotInfo -> Id
infixl 1 `setIdOneShotInfo`
setIdSpecialisation :: Id -> RuleInfo -> Id
infixl 1 `setIdSpecialisation`
setIdStrictness :: Id -> StrictSig -> Id
infixl 1 `setIdStrictness`

-- | Not only does this set the <a>Id</a> <a>Type</a>, it also evaluates
--   the type to try and reduce space usage
setIdType :: Id -> Type -> Id
setIdUnfolding :: Id -> Unfolding -> Id
infixl 1 `setIdUnfolding`
setIdUnique :: Id -> Unique -> Id
setInlineActivation :: Id -> Activation -> Id
infixl 1 `setInlineActivation`
setInlinePragma :: Id -> InlinePragma -> Id
infixl 1 `setInlinePragma`
setOneShotLambda :: Id -> Id

-- | Should we apply the state hack to values of this <a>Type</a>?
stateHackOneShot :: OneShotInfo
transferPolyIdInfo :: Id -> [Var] -> Id -> Id
typeOneShot :: Type -> OneShotInfo
updOneShotInfo :: Id -> OneShotInfo -> Id
zapFragileIdInfo :: Id -> Id
zapIdDemandInfo :: Id -> Id
zapIdOccInfo :: Id -> Id
zapIdStrictness :: Id -> Id
zapIdTailCallInfo :: Id -> Id
zapIdUsageEnvInfo :: Id -> Id
zapIdUsageInfo :: Id -> Id
zapIdUsedOnceInfo :: Id -> Id
zapJoinId :: Id -> Id
zapLamIdInfo :: Id -> Id
zapStableUnfolding :: Id -> Id

-- | A set of variables that are in scope at some point "Secrets of the
--   Glasgow Haskell Compiler inliner" Section 3.2 provides the motivation
--   for this abstraction.
data InScopeSet
extendTCvSubst :: TCvSubst -> TyCoVar -> Type -> TCvSubst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type
cloneBndr :: Subst -> Unique -> Var -> (Subst, Var)
cloneBndrs :: Subst -> UniqSupply -> [Var] -> (Subst, [Var])

-- | Very similar to <a>substBndr</a>, but it always allocates a new
--   <a>Unique</a> for each variable in its output. It substitutes the
--   IdInfo though.
cloneIdBndr :: Subst -> UniqSupply -> Id -> (Subst, Id)

-- | Applies <a>cloneIdBndr</a> to a number of <a>Id</a>s, accumulating a
--   final substitution from left to right
cloneIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])

-- | Clone a mutually recursive group of <a>Id</a>s
cloneRecIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])

-- | De-shadowing the program is sometimes a useful pre-pass. It can be
--   done simply by running over the bindings with an empty substitution,
--   because substitution returns a result that has no-shadowing
--   guaranteed.
--   
--   (Actually, within a single <i>type</i> there might still be shadowing,
--   because <a>substTy</a> is a no-op for the empty substitution, but
--   that's probably OK.)
--   
--   <ul>
--   <li><i>Aug 09</i> This function is not used in GHC at the moment, but
--   seems so short and simple that I'm going to leave it here</li>
--   </ul>
deShadowBinds :: CoreProgram -> CoreProgram
delBndr :: Subst -> Var -> Subst
delBndrs :: Subst -> [Var] -> Subst
emptySubst :: Subst

-- | Add a substitution for an <a>Id</a> to the <a>Subst</a>: you must
--   ensure that the in-scope set is such that TyCoSubst Note [The
--   substitution invariant] holds after extending the substitution like
--   this
extendIdSubst :: Subst -> Id -> CoreExpr -> Subst

-- | Adds multiple <a>Id</a> substitutions to the <a>Subst</a>: see also
--   <a>extendIdSubst</a>
extendIdSubstList :: Subst -> [(Id, CoreExpr)] -> Subst

-- | Add the <a>Expr</a> to the in-scope set: as a side effect, and remove
--   any existing substitutions for it
extendInScope :: Subst -> Var -> Subst

-- | Optimized version of <a>extendInScopeList</a> that can be used if you
--   are certain all the things being added are <a>Id</a>s and hence none
--   are <a>TyVar</a>s or <a>CoVar</a>s
extendInScopeIds :: Subst -> [Id] -> Subst

-- | Add the <a>Expr</a>s to the in-scope set: see also
--   <a>extendInScope</a>
extendInScopeList :: Subst -> [Var] -> Subst

-- | Add a substitution appropriate to the thing being substituted (whether
--   an expression, type, or coercion). See also <a>extendIdSubst</a>,
--   <a>extendTvSubst</a>, <a>extendCvSubst</a>
extendSubst :: Subst -> Var -> CoreArg -> Subst

-- | Add a substitution as appropriate to each of the terms being
--   substituted (whether expressions, types, or coercions). See also
--   <a>extendSubst</a>.
extendSubstList :: Subst -> [(Var, CoreArg)] -> Subst
extendSubstWithVar :: Subst -> Var -> Var -> Subst

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a> The
--   <a>TyVar</a> *must* be a real TyVar, and not a CoVar You must ensure
--   that the in-scope set is such that <a>GHC.Core.TyCo.Subst</a> Note
--   [The substitution invariant] holds after extending the substitution
--   like this.
extendTvSubst :: Subst -> TyVar -> Type -> Subst

-- | Adds multiple <a>TyVar</a> substitutions to the <a>Subst</a>: see also
--   <a>extendTvSubst</a>
extendTvSubstList :: Subst -> [(TyVar, Type)] -> Subst
getTCvSubst :: Subst -> TCvSubst
isEmptySubst :: Subst -> Bool
isInScope :: Var -> Subst -> Bool

-- | Find the substitution for an <a>Id</a> in the <a>Subst</a>
lookupIdSubst :: HasDebugCallStack => Subst -> Id -> CoreExpr

-- | Find the substitution for a <a>TyVar</a> in the <a>Subst</a>
lookupTCvSubst :: Subst -> TyVar -> Type
mkEmptySubst :: InScopeSet -> Subst

-- | Simultaneously substitute for a bunch of variables No left-right
--   shadowing ie the substitution for (x y. e) a1 a2 so neither x nor y
--   scope over a1 a2
mkOpenSubst :: InScopeSet -> [(Var, CoreArg)] -> Subst
mkSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> IdSubstEnv -> Subst
setInScope :: Subst -> InScopeSet -> Subst

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBind :: HasDebugCallStack => Subst -> CoreBind -> (Subst, CoreBind)

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBindSC :: HasDebugCallStack => Subst -> CoreBind -> (Subst, CoreBind)

-- | Substitutes a <a>Expr</a> for another one according to the
--   <a>Subst</a> given, returning the result and an updated <a>Subst</a>
--   that should be used by subsequent substitutions. <a>IdInfo</a> is
--   preserved by this process, although it is substituted into
--   appropriately.
substBndr :: Subst -> Var -> (Subst, Var)

-- | Applies <a>substBndr</a> to a number of <a>Expr</a>s, accumulating a
--   new <a>Subst</a> left-to-right
substBndrs :: Subst -> [Var] -> (Subst, [Var])

-- | See <a>substCo</a>
substCo :: HasCallStack => Subst -> Coercion -> Coercion
substDVarSet :: Subst -> DVarSet -> DVarSet

-- | substExpr applies a substitution to an entire <a>CoreExpr</a>.
--   Remember, you may only apply the substitution <i>once</i>: See Note
--   [Substitutions apply only once] in <a>GHC.Core.TyCo.Subst</a>
--   
--   Do *not* attempt to short-cut in the case of an empty substitution!
--   See Note [Extending the Subst]
substExpr :: HasDebugCallStack => Subst -> CoreExpr -> CoreExpr
substExprSC :: HasDebugCallStack => Subst -> CoreExpr -> CoreExpr

-- | Substitute into some <a>IdInfo</a> with regard to the supplied new
--   <a>Id</a>.
substIdInfo :: Subst -> Id -> IdInfo -> Maybe IdInfo
substIdOcc :: Subst -> Id -> Id
substIdType :: Subst -> Id -> Id

-- | Find the in-scope set: see <a>GHC.Core.TyCo.Subst</a> Note [The
--   substitution invariant]
substInScope :: Subst -> InScopeSet

-- | Substitute in a mutually recursive group of <a>Id</a>s
substRecBndrs :: Subst -> [Id] -> (Subst, [Id])

-- | Substitutes for the <a>Id</a>s within the <a>RuleInfo</a> given the
--   new function <a>Id</a>
substRuleInfo :: Subst -> Id -> RuleInfo -> RuleInfo
substRulesForImportedIds :: Subst -> [CoreRule] -> [CoreRule]
substTickish :: Subst -> CoreTickish -> CoreTickish

-- | See <a>substTy</a>.
substTy :: Subst -> Type -> Type

-- | Substitutes for the <a>Id</a>s within an unfolding NB: substUnfolding
--   <i>discards</i> any unfolding without without a Stable source. This is
--   usually what we want, but it may be a bit unexpected
substUnfolding :: Subst -> Unfolding -> Unfolding

-- | Substitutes for the <a>Id</a>s within an unfolding NB: substUnfolding
--   <i>discards</i> any unfolding without without a Stable source. This is
--   usually what we want, but it may be a bit unexpected
substUnfoldingSC :: Subst -> Unfolding -> Unfolding

-- | Remove all substitutions for <a>Id</a>s and <a>Expr</a>s that might
--   have been built up while preserving the in-scope set
zapSubstEnv :: Subst -> Subst

-- | An environment for substituting for <a>Id</a>s
type IdSubstEnv = IdEnv CoreExpr

-- | A substitution environment, containing <a>Id</a>, <a>TyVar</a>, and
--   <a>CoVar</a> substitutions.
--   
--   Some invariants apply to how you use the substitution:
--   
--   <ol>
--   <li>Note [The substitution invariant] in
--   <a>GHC.Core.TyCo.Subst</a></li>
--   <li>Note [Substitutions apply only once] in
--   <a>GHC.Core.TyCo.Subst</a></li>
--   </ol>
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | The non-dependent version of <a>ArgFlag</a>. See Note [AnonArgFlag]
--   Appears here partly so that it's together with its friends ArgFlag and
--   ForallVisFlag, but also because it is used in IfaceType, rather early
--   in the compilation chain
data AnonArgFlag

-- | Used for <tt>(-&gt;)</tt>: an ordinary non-dependent arrow. The
--   argument is visible in source code.
VisArg :: AnonArgFlag

-- | Used for <tt>(=&gt;)</tt>: a non-dependent predicate arrow. The
--   argument is invisible in source code.
InvisArg :: AnonArgFlag

-- | Argument Flag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, TyCoVarBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ArgFlag
Invisible :: Specificity -> ArgFlag
Required :: ArgFlag
pattern Inferred :: ArgFlag
pattern Specified :: ArgFlag

-- | Whether an <a>Invisible</a> argument may appear in source Haskell.
data Specificity

-- | the argument may not appear in source Haskell, it is only inferred.
InferredSpec :: Specificity

-- | the argument may appear in source Haskell, but isn't required.
SpecifiedSpec :: Specificity

-- | Type or Coercion Variable
type TyCoVar = Id

-- | Type or kind Variable
type TyVar = Var

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Like <tt>mkTyCoForAllTy</tt>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: TyCoVar -> ArgFlag -> Type -> Type

-- | The key type representing kinds in the compiler.
type Kind = Type

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A shorthand for data with an attached <a>Mult</a> element (the
--   multiplicity).
data Scaled a

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]

-- | A <a>TyCoBinder</a> represents an argument to a function. TyCoBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [TyCoBinders]
data TyCoBinder
data Type

-- | This function strips off the <i>top layer only</i> of a type synonym
--   application (if any) its underlying representation type. Returns
--   <a>Nothing</a> if there is nothing to look through. This function
--   considers <tt>Constraint</tt> to be a synonym of <tt>Type</tt>.
--   
--   By being non-recursive and inlined, this case analysis gets
--   efficiently joined onto the case analysis that the caller is already
--   doing
coreView :: Type -> Maybe Type
isCoercionTy :: Type -> Bool

-- | This version considers Constraint to be the same as *. Returns True if
--   the argument is equivalent to Type/Constraint and False otherwise. See
--   Note [Kind Constraint and kind Type]
isLiftedTypeKind :: Kind -> Bool

-- | Is this the type <tt>Multiplicity</tt>?
isMultiplicityTy :: Type -> Bool
isPredTy :: HasDebugCallStack => Type -> Bool

-- | Is this the type <a>RuntimeRep</a>?
isRuntimeRepTy :: Type -> Bool

-- | Applies a type to another, as in e.g. <tt>k a</tt>
mkAppTy :: Type -> Type -> Type

-- | Make a <a>CastTy</a>. The Coercion must be nominal. Checks the
--   Coercion for reflexivity, dropping it if it's reflexive. See Note
--   [Respecting definitional equality] in <a>GHC.Core.TyCo.Rep</a>
mkCastTy :: Type -> Coercion -> Type

-- | A key function: builds a <a>TyConApp</a> or <a>FunTy</a> as
--   appropriate to its arguments. Applies its arguments to the constructor
--   from left to right.
mkTyConApp :: TyCon -> [Type] -> Type

-- | Create the plain type constructor type which has been applied to no
--   type arguments at all.
mkTyConTy :: TyCon -> Type

-- | Given a <a>TyCon</a> and a list of argument types, partition the
--   arguments into:
--   
--   <ol>
--   <li><a>Inferred</a> or <a>Specified</a> (i.e., invisible) arguments
--   and</li>
--   <li><a>Required</a> (i.e., visible) arguments</li>
--   </ol>
partitionInvisibleTypes :: TyCon -> [Type] -> ([Type], [Type])
piResultTy :: HasDebugCallStack => Type -> Type -> Type

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor
splitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])

-- | Given a <tt>RuntimeRep</tt>, applies <tt>TYPE</tt> to it. See Note
--   [TYPE and RuntimeRep] in GHC.Builtin.Types.Prim.
tYPE :: Type -> Type

-- | Gives the typechecker view of a type. This unwraps synonyms but leaves
--   <tt>Constraint</tt> alone. c.f. <a>coreView</a>, which turns
--   <tt>Constraint</tt> into <a>Type</a>. Returns <a>Nothing</a> if no
--   unwrapping happens. See also Note [coreView vs tcView]
tcView :: Type -> Maybe Type

-- | The same as <tt>fst . splitTyConApp</tt>
tyConAppTyCon_maybe :: Type -> Maybe TyCon
liftedTypeKind :: Kind
unliftedTypeKind :: Kind
unrestrictedFunTyCon :: TyCon
binderArgFlag :: VarBndr tv argf -> argf
binderType :: VarBndr TyCoVar argf -> Type
binderVar :: VarBndr tv argf -> tv
binderVars :: [VarBndr tv argf] -> [tv]

-- | Does this <a>ArgFlag</a> classify an argument that is not written in
--   Haskell?
isInvisibleArgFlag :: ArgFlag -> Bool

-- | Is this a type-level (i.e., computationally irrelevant, thus erasable)
--   variable? Satisfies <tt>isTyVar = not . isId</tt>.
isTyVar :: Var -> Bool

-- | Does this <a>ArgFlag</a> classify an argument that is written in
--   Haskell?
isVisibleArgFlag :: ArgFlag -> Bool

-- | Make a named binder
mkTyCoVarBinder :: vis -> TyCoVar -> VarBndr TyCoVar vis

-- | Make many named binders
mkTyCoVarBinders :: vis -> [TyCoVar] -> [VarBndr TyCoVar vis]

-- | Make a named binder <tt>var</tt> should be a type variable
mkTyVarBinder :: vis -> TyVar -> VarBndr TyVar vis

-- | Make many named binders Input vars should be type variables
mkTyVarBinders :: vis -> [TyVar] -> [VarBndr TyVar vis]

-- | Do these denote the same level of visibility? <a>Required</a>
--   arguments are visible, others are not. So this function equates
--   <a>Specified</a> and <a>Inferred</a>. Used for printing.
sameVis :: ArgFlag -> ArgFlag -> Bool
tyVarKind :: TyVar -> Kind
tyVarSpecToBinders :: [VarBndr a Specificity] -> [VarBndr a ArgFlag]

-- | Variable Binder
--   
--   A <a>TyCoVarBinder</a> is the binder of a ForAllTy It's convenient to
--   define this synonym here rather its natural home in
--   <a>GHC.Core.TyCo.Rep</a>, because it's used in
--   GHC.Core.DataCon.hs-boot
--   
--   A <a>TyVarBinder</a> is a binder with only TyVar
type TyCoVarBinder = VarBndr TyCoVar ArgFlag
type TyVarBinder = VarBndr TyVar ArgFlag

-- | Returns <tt>True</tt> for the <a>TyCon</a> of the <tt>Constraint</tt>
--   kind.
isConstraintKindCon :: TyCon -> Bool
foldTyCo :: Monoid a => TyCoFolder env a -> env -> (Type -> a, [Type] -> a, Coercion -> a, [Coercion] -> a)

-- | Does this binder bind an invisible argument?
isInvisibleBinder :: TyCoBinder -> Bool
isNamedBinder :: TyCoBinder -> Bool

-- | Does this binder bind a visible argument?
isVisibleBinder :: TyCoBinder -> Bool

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [TyCoVarBinder] -> Type -> Type
mkFunTy :: AnonArgFlag -> Mult -> Type -> Type -> Type
infixr 3 `mkFunTy`

-- | Wraps foralls over the type using the provided <a>InvisTVBinder</a>s
--   from left to right
mkInvisForAllTys :: [InvisTVBinder] -> Type -> Type
mkInvisFunTy :: Mult -> Type -> Type -> Type
infixr 3 `mkInvisFunTy`
mkInvisFunTyMany :: Type -> Type -> Type
infixr 3 `mkInvisFunTyMany`
mkInvisFunTysMany :: [Type] -> Type -> Type
mkPiTy :: TyCoBinder -> Type -> Type
mkPiTys :: [TyCoBinder] -> Type -> Type
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]
mkVisFunTy :: Mult -> Type -> Type -> Type
infixr 3 `mkVisFunTy`

-- | Special, common, case: Arrow type with mult Many
mkVisFunTyMany :: Type -> Type -> Type
infixr 3 `mkVisFunTyMany`

-- | Make nested arrow types
mkVisFunTys :: [Scaled Type] -> Type -> Type
mkVisFunTysMany :: [Type] -> Type -> Type
typeSize :: Type -> Int

-- | The key representation of types within the compiler
type KindOrType = Type

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   <a>GHC.Tc.TyCl</a>
type KnotTied ty = ty
data TyCoFolder env a
TyCoFolder :: (Type -> Maybe Type) -> (env -> TyVar -> a) -> (env -> CoVar -> a) -> (env -> CoercionHole -> a) -> (env -> TyCoVar -> ArgFlag -> env) -> TyCoFolder env a
[tcf_view] :: TyCoFolder env a -> Type -> Maybe Type
[tcf_tyvar] :: TyCoFolder env a -> env -> TyVar -> a
[tcf_covar] :: TyCoFolder env a -> env -> CoVar -> a

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcf_hole] :: TyCoFolder env a -> env -> CoercionHole -> a

-- | The returned env is used in the extended scope
[tcf_tycobinder] :: TyCoFolder env a -> env -> TyCoVar -> ArgFlag -> env
anyFreeVarsOfType :: (TyCoVar -> Bool) -> Type -> Bool
anyFreeVarsOfTypes :: (TyCoVar -> Bool) -> [Type] -> Bool
closeOverKinds :: TyCoVarSet -> TyCoVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministically ordered list.
closeOverKindsList :: [TyVar] -> [TyVar]
coVarsOfType :: Type -> CoVarSet
coVarsOfTypes :: [Type] -> CoVarSet
noFreeVarsOfType :: Type -> Bool

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in <a>GHC.Rename.HsType</a>
scopedSort :: [TyCoVar] -> [TyCoVar]
tyCoFVsBndr :: TyCoVarBinder -> FV -> FV

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in <a>GHC.Utils.FV</a>.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in <a>GHC.Utils.FV</a> for explanation.
tyCoFVsOfType :: Type -> FV
tyCoFVsVarBndr :: Var -> FV -> FV
tyCoFVsVarBndrs :: [Var] -> FV -> FV
tyCoVarsOfType :: Type -> TyCoVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet

-- | Get the free vars of a type in scoped order
tyCoVarsOfTypeWellScoped :: Type -> [TyVar]
tyCoVarsOfTypes :: [Type] -> TyCoVarSet

-- | Get the free vars of types in scoped order
tyCoVarsOfTypesWellScoped :: [Type] -> [TyVar]

-- | Add the free <a>TyVar</a>s to the env in tidy form, so that we can
--   tidy the type they are free in
tidyFreeTyCoVars :: TidyEnv -> [TyCoVar] -> TidyEnv
tidyKind :: TidyEnv -> Kind -> Kind
tidyOpenKind :: TidyEnv -> Kind -> (TidyEnv, Kind)

-- | Treat a new <a>TyCoVar</a> as a binder, and give it a fresh tidy name
--   using the environment if one has not already been allocated. See also
--   <a>tidyVarBndr</a>
tidyOpenTyCoVar :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)
tidyOpenTyCoVars :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])
tidyOpenType :: TidyEnv -> Type -> (TidyEnv, Type)

-- | Grabs the free type variables, tidies them and then uses
--   <a>tidyType</a> to work over the type itself
tidyOpenTypes :: TidyEnv -> [Type] -> (TidyEnv, [Type])

-- | Calls <a>tidyType</a> on a top-level type (i.e. with an empty tidying
--   environment)
tidyTopType :: Type -> Type
tidyTyCoVarBinder :: TidyEnv -> VarBndr TyCoVar vis -> (TidyEnv, VarBndr TyCoVar vis)
tidyTyCoVarBinders :: TidyEnv -> [VarBndr TyCoVar vis] -> (TidyEnv, [VarBndr TyCoVar vis])
tidyTyCoVarOcc :: TidyEnv -> TyCoVar -> TyCoVar

-- | Tidy a Type
--   
--   See Note [Strictness in tidyType and friends]
tidyType :: TidyEnv -> Type -> Type

-- | Tidy a list of Types
--   
--   See Note [Strictness in tidyType and friends]
tidyTypes :: TidyEnv -> [Type] -> [Type]
tidyVarBndr :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)

-- | This tidies up a type for printing in an error message, or in an
--   interface file.
--   
--   It doesn't change the uniques at all, just the print names.
tidyVarBndrs :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])
cloneTyVarBndr :: TCvSubst -> TyVar -> Unique -> (TCvSubst, TyVar)
cloneTyVarBndrs :: TCvSubst -> [TyVar] -> UniqSupply -> (TCvSubst, [TyVar])

-- | Composes two substitutions, applying the second one provided first,
--   like in function composition.
composeTCvSubst :: TCvSubst -> TCvSubst -> TCvSubst

-- | <tt>(compose env1 env2)(x)</tt> is <tt>env1(env2(x))</tt>; i.e. apply
--   <tt>env2</tt> then <tt>env1</tt>. It assumes that both are idempotent.
--   Typically, <tt>env1</tt> is the refinement to a base substitution
--   <tt>env2</tt>
composeTCvSubstEnv :: InScopeSet -> (TvSubstEnv, CvSubstEnv) -> (TvSubstEnv, CvSubstEnv) -> (TvSubstEnv, CvSubstEnv)
emptyTCvSubst :: TCvSubst
emptyTvSubstEnv :: TvSubstEnv
extendCvSubst :: TCvSubst -> CoVar -> Coercion -> TCvSubst
extendTCvInScope :: TCvSubst -> Var -> TCvSubst
extendTCvInScopeList :: TCvSubst -> [Var] -> TCvSubst
extendTCvInScopeSet :: TCvSubst -> VarSet -> TCvSubst
extendTCvSubst :: TCvSubst -> TyCoVar -> Type -> TCvSubst
extendTCvSubstList :: TCvSubst -> [Var] -> [Type] -> TCvSubst
extendTCvSubstWithClone :: TCvSubst -> TyCoVar -> TyCoVar -> TCvSubst
extendTvSubstAndInScope :: TCvSubst -> TyVar -> Type -> TCvSubst
extendTvSubstBinderAndInScope :: TCvSubst -> TyCoBinder -> Type -> TCvSubst
extendTvSubstWithClone :: TCvSubst -> TyVar -> TyVar -> TCvSubst
getTCvInScope :: TCvSubst -> InScopeSet

-- | Returns the free variables of the types in the range of a substitution
--   as a non-deterministic set.
getTCvSubstRangeFVs :: TCvSubst -> VarSet
getTvSubstEnv :: TCvSubst -> TvSubstEnv
isEmptyTCvSubst :: TCvSubst -> Bool
lookupTyVar :: TCvSubst -> TyVar -> Maybe Type
mkEmptyTCvSubst :: InScopeSet -> TCvSubst
mkTCvSubst :: InScopeSet -> (TvSubstEnv, CvSubstEnv) -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
mkTvSubstPrs :: [(TyVar, Type)] -> TCvSubst
notElemTCvSubst :: Var -> TCvSubst -> Bool
setTvSubstEnv :: TCvSubst -> TvSubstEnv -> TCvSubst

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: TCvSubst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion
substScaledTy :: HasCallStack => TCvSubst -> Scaled Type -> Scaled Type
substScaledTyUnchecked :: HasCallStack => TCvSubst -> Scaled Type -> Scaled Type
substScaledTys :: HasCallStack => TCvSubst -> [Scaled Type] -> [Scaled Type]
substScaledTysUnchecked :: TCvSubst -> [Scaled Type] -> [Scaled Type]

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasCallStack => TCvSubst -> ThetaType -> ThetaType

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: TCvSubst -> ThetaType -> ThetaType

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: TCvSubst -> Type -> Type
substTyCoBndr :: TCvSubst -> TyCoBinder -> (TCvSubst, TyCoBinder)

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: TCvSubst -> Type -> Type
substTyVar :: TCvSubst -> TyVar -> Type
substTyVarBndr :: HasCallStack => TCvSubst -> TyVar -> (TCvSubst, TyVar)
substTyVarBndrs :: HasCallStack => TCvSubst -> [TyVar] -> (TCvSubst, [TyVar])
substTyVars :: TCvSubst -> [TyVar] -> [Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasCallStack => TCvSubst -> [Type] -> [Type]

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: TCvSubst -> [Type] -> [Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTysWith :: [TyVar] -> [Type] -> [Type] -> [Type]
substVarBndr :: HasCallStack => TCvSubst -> TyCoVar -> (TCvSubst, TyCoVar)
substVarBndrs :: HasCallStack => TCvSubst -> [TyCoVar] -> (TCvSubst, [TyCoVar])
unionTCvSubst :: TCvSubst -> TCvSubst -> TCvSubst
zapTCvSubst :: TCvSubst -> TCvSubst
zipCoEnv :: HasDebugCallStack => [CoVar] -> [Coercion] -> CvSubstEnv
zipTCvSubst :: HasDebugCallStack => [TyCoVar] -> [Type] -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
zipTvSubst :: HasDebugCallStack => [TyVar] -> [Type] -> TCvSubst
zipTyEnv :: HasDebugCallStack => [TyVar] -> [Type] -> TvSubstEnv

-- | Type &amp; coercion substitution
--   
--   The following invariants must hold of a <a>TCvSubst</a>:
--   
--   <ol>
--   <li>The in-scope set is needed <i>only</i> to guide the generation of
--   fresh uniques</li>
--   <li>In particular, the <i>kind</i> of the type variables in the
--   in-scope set is not relevant</li>
--   <li>The substitution is only applied ONCE! This is because in general
--   such application will not reach a fixed point.</li>
--   </ol>
data TCvSubst
TCvSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> TCvSubst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | The <tt>FUN</tt> type constructor.
--   
--   <pre>
--   FUN :: forall (m :: Multiplicity) -&gt;
--          forall {rep1 :: RuntimeRep} {rep2 :: RuntimeRep}.
--          TYPE rep1 -&gt; TYPE rep2 -&gt; *
--   </pre>
--   
--   The runtime representations quantification is left inferred. This
--   means they cannot be specified with <tt>-XTypeApplications</tt>.
--   
--   This is a deliberate choice to allow future extensions to the function
--   arrow. To allow visible application a type synonym can be defined:
--   
--   <pre>
--   type Arr :: forall (rep1 :: RuntimeRep) (rep2 :: RuntimeRep).
--               TYPE rep1 -&gt; TYPE rep2 -&gt; Type
--   type Arr = FUN 'Many
--   </pre>
funTyCon :: TyCon
pattern Many :: Mult
pattern One :: Mult

-- | Given a <a>Type</a> and a list of argument types to which the
--   <a>Type</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Most of the time, the arguments will be <a>Required</a>, but not
--   always. Consider <tt>f :: forall a. a -&gt; Type</tt>. In <tt>f Type
--   Bool</tt>, the first argument (<tt>Type</tt>) is <a>Specified</a> and
--   the second argument (<tt>Bool</tt>) is <a>Required</a>. It is
--   precisely this sort of higher-rank situation in which
--   <a>appTyArgFlags</a> comes in handy, since <tt>f Type Bool</tt> would
--   be represented in Core using <a>AppTy</a>s. (See also #15792).
appTyArgFlags :: Type -> [Type] -> [ArgFlag]
applyTysX :: [TyVar] -> Type -> [Type] -> Type

-- | Extract a relevant type, if there is one.
binderRelevantType_maybe :: TyCoBinder -> Maybe Type
buildSynTyCon :: Name -> [KnotTied TyConBinder] -> Kind -> [Role] -> KnotTied Type -> TyCon

-- | Does this classify a type allowed to have values? Responds True to
--   things like *, #, TYPE Lifted, TYPE v, Constraint.
--   
--   True of any sub-kind of OpenTypeKind
classifiesTypeWithValues :: Kind -> Bool

-- | Get the type on the LHS of a coercion induced by a type/data family
--   instance.
coAxNthLHS :: CoAxiom br -> Int -> Type

-- | Drops all ForAllTys
dropForAlls :: Type -> Type

-- | Drops prefix of RuntimeRep constructors in <a>TyConApp</a>s. Useful
--   for e.g. dropping 'LiftedRep arguments of unboxed tuple TyCon
--   applications:
--   
--   dropRuntimeRepArgs [ 'LiftedRep, 'IntRep , String, Int# ] == [String,
--   Int#]
dropRuntimeRepArgs :: [Type] -> [Type]

-- | Type equality on source types. Does not look through <tt>newtypes</tt>
--   or <a>PredType</a>s, but it does look through type synonyms. This
--   first checks that the kinds of the types are equal and then checks
--   whether the types are equal, ignoring casts and coercions. (The kind
--   check is a recursive call, but since all kinds have type
--   <tt>Type</tt>, there is no need to check the types of kinds.) See also
--   Note [Non-trivial definitional equality] in <a>GHC.Core.TyCo.Rep</a>.
eqType :: Type -> Type -> Bool

-- | Compare types with respect to a (presumably) non-empty <a>RnEnv2</a>.
eqTypeX :: RnEnv2 -> Type -> Type -> Bool

-- | Type equality on lists of types, looking through type synonyms but not
--   newtypes.
eqTypes :: [Type] -> [Type] -> Bool
eqVarBndrs :: RnEnv2 -> [Var] -> [Var] -> Maybe RnEnv2

-- | Expand out all type synonyms. Actually, it'd suffice to expand out
--   just the ones that discard type variables (e.g. type Funny a = Int)
--   But we don't know which those are currently, so we just expand all.
--   
--   <a>expandTypeSynonyms</a> only expands out type synonyms mentioned in
--   the type, not in the kinds of any TyCon or TyVar mentioned in the
--   type.
--   
--   Keep this synchronized with <tt>synonymTyConsOfType</tt>
expandTypeSynonyms :: Type -> Type

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   <a>Inferred</a> arguments.
filterOutInferredTypes :: TyCon -> [Type] -> [Type]

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   invisible (i.e., <a>Inferred</a> or <a>Specified</a>) arguments.
filterOutInvisibleTypes :: TyCon -> [Type] -> [Type]

-- | Just like <a>piResultTys</a> but for a single argument Try not to
--   iterate <a>piResultTy</a>, because it's inefficient to substitute one
--   variable at a time; instead use 'piResultTys"
--   
--   Extract the function argument type and panic if that is not possible
funArgTy :: Type -> Type

-- | Extract the function result type and panic if that is not possible
funResultTy :: Type -> Type

-- | If the type is a tyvar, possibly under a cast, returns it, along with
--   the coercion. Thus, the co is :: kind tv ~N kind ty
getCastedTyVar_maybe :: Type -> Maybe (TyVar, CoercionN)

-- | Extract the RuntimeRep classifier of a type. For instance,
--   <tt>getRuntimeRep_maybe Int = LiftedRep</tt>. Panics if this is not
--   possible.
getRuntimeRep :: HasDebugCallStack => Type -> Type

-- | Extract the RuntimeRep classifier of a type. For instance,
--   <tt>getRuntimeRep_maybe Int = LiftedRep</tt>. Returns <a>Nothing</a>
--   if this is not possible.
getRuntimeRep_maybe :: HasDebugCallStack => Type -> Maybe Type

-- | Attempts to obtain the type variable underlying a <a>Type</a>, and
--   panics with the given message if this is not a type variable type. See
--   also <a>getTyVar_maybe</a>
getTyVar :: String -> Type -> TyVar

-- | Attempts to obtain the type variable underlying a <a>Type</a>
getTyVar_maybe :: Type -> Maybe TyVar
invisibleTyBndrCount :: Type -> Int
irrelevantMult :: Scaled a -> a

-- | See <a>Type#type_classification</a> for what an algebraic type is.
--   Should only be applied to <i>types</i>, as opposed to e.g. partially
--   saturated type constructors
isAlgType :: Type -> Bool

-- | Does this binder bind a variable that is <i>not</i> erased? Returns
--   <a>True</a> for anonymous binders.
isAnonTyCoBinder :: TyCoBinder -> Bool
isAtomicTy :: Type -> Bool

-- | See <a>isBoxedRuntimeRep_maybe</a>.
isBoxedRuntimeRep :: Type -> Bool

-- | See <a>Type#type_classification</a> for what a boxed type is. Panics
--   on levity polymorphic types; See <a>mightBeUnliftedType</a> for a more
--   approximate predicate that behaves better in the presence of levity
--   polymorphism.
isBoxedType :: Type -> Bool

-- | Returns True if the kind classifies types which are allocated on the
--   GC'd heap and False otherwise. Note that this returns False for
--   levity-polymorphic kinds, which may be specialized to a kind that
--   classifies AddrRep or even unboxed kinds.
isBoxedTypeKind :: Kind -> Bool

-- | Is this a char literal? We also look through type synonyms.
isCharLitTy :: Type -> Maybe Char

-- | Does this type classify a core (unlifted) Coercion? At either role
--   nominal or representational (t1 ~# t2) or (t1 ~R# t2) See Note [Types
--   for coercions, predicates, and evidence] in <a>GHC.Core.TyCo.Rep</a>
isCoVarType :: Type -> Bool
isCoercionTy_maybe :: Type -> Maybe Coercion

-- | Check whether a type is a data family type
isDataFamilyAppType :: Type -> Bool
isFamFreeTy :: Type -> Bool

-- | Checks whether this is a proper forall (with a named binder)
isForAllTy :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a covar binder
isForAllTy_co :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a tyvar binder
isForAllTy_ty :: Type -> Bool

-- | Is this a function?
isFunTy :: Type -> Bool

-- | Tests whether the given kind (which should look like <tt>TYPE x</tt>)
--   is something other than a constructor tree (that is, constructors at
--   every node). E.g. True of TYPE k, TYPE (F Int) False of TYPE
--   'LiftedRep
isKindLevPoly :: Kind -> Bool

-- | Is this the type <tt>Levity</tt>?
isLevityTy :: Type -> Bool

-- | Is a tyvar of type <tt>Levity</tt>?
isLevityVar :: TyVar -> Bool
isLiftedLevity :: Type -> Bool
isLiftedRuntimeRep :: Type -> Bool

-- | Returns Just True if this type is surely lifted, Just False if it is
--   surely unlifted, Nothing if we can't be sure (i.e., it is levity
--   polymorphic), and panics if the kind does not have the shape TYPE r.
isLiftedType_maybe :: HasDebugCallStack => Type -> Maybe Bool

-- | <tt>isLinear t</tt> returns <tt>True</tt> of a if <tt>t</tt> is a type
--   of (curried) function where at least one argument is linear (or
--   otherwise non-unrestricted). We use this function to check whether it
--   is safe to eta reduce an Id in CorePrep. It is always safe to return
--   <a>True</a>, because <a>True</a> deactivates the optimisation.
isLinearType :: Type -> Bool

-- | Is this a type literal (symbol, numeric, or char)?
isLitTy :: Type -> Maybe TyLit
isManyDataConTy :: Mult -> Bool

-- | Is a tyvar of type <tt>Multiplicity</tt>?
isMultiplicityVar :: TyVar -> Bool

-- | Is this a numeric literal. We also look through type synonyms.
isNumLitTy :: Type -> Maybe Integer
isOneDataConTy :: Mult -> Bool

-- | Is this a function or forall?
isPiTy :: Type -> Bool

-- | Returns true of types that are opaque to Haskell.
isPrimitiveType :: Type -> Bool

-- | Is this a type of kind RuntimeRep? (e.g. LiftedRep)
isRuntimeRepKindedTy :: Type -> Bool

-- | Is a tyvar of type <a>RuntimeRep</a>?
isRuntimeRepVar :: TyVar -> Bool

-- | Is this a symbol literal. We also look through type synonyms.
isStrLitTy :: Type -> Maybe FastString

-- | Computes whether an argument (or let right hand side) should be
--   computed strictly or lazily, based only on its type. Currently, it's
--   just <a>isUnliftedType</a>. Panics on levity-polymorphic types.
isStrictType :: HasDebugCallStack => Type -> Bool
isTauTy :: Type -> Bool
isTyVarTy :: Type -> Bool

-- | Returns True if a type is levity polymorphic. Should be the same as
--   (isKindLevPoly . typeKind) but much faster. Precondition: The type has
--   kind (TYPE blah)
isTypeLevPoly :: Type -> Bool
isUnboxedSumType :: Type -> Bool
isUnboxedTupleType :: Type -> Bool
isUnliftedLevity :: Type -> Bool
isUnliftedRuntimeRep :: Type -> Bool

-- | See <a>Type#type_classification</a> for what an unlifted type is.
--   Panics on levity polymorphic types; See <a>mightBeUnliftedType</a> for
--   a more approximate predicate that behaves better in the presence of
--   levity polymorphism.
isUnliftedType :: HasDebugCallStack => Type -> Bool

-- | Returns True if the kind classifies unlifted types (like 'Int#') and
--   False otherwise. Note that this returns False for levity-polymorphic
--   kinds, which may be specialized to a kind that classifies unlifted
--   types.
isUnliftedTypeKind :: Kind -> Bool

-- | Determine whether a type could be the type of a join point of given
--   total arity, according to the polymorphism rule. A join point cannot
--   be polymorphic in its return type, since given join j <tt>a </tt>b x y
--   z = e1 in e2, the types of e1 and e2 must be the same, and a and b are
--   not in scope for e2. (See Note [The polymorphism rule of join points]
--   in <a>GHC.Core</a>.) Returns False also if the type simply doesn't
--   have enough arguments.
--   
--   Note that we need to know how many arguments (type *and* value) the
--   putative join point takes; for instance, if j :: forall a. a -&gt; Int
--   then j could be a binary join point returning an Int, but it could
--   *not* be a unary join point returning a -&gt; Int.
--   
--   TODO: See Note [Excess polymorphism and join points]
isValidJoinPointType :: JoinArity -> Type -> Bool

-- | Extract the RuntimeRep classifier of a type from its kind. For
--   example, <tt>kindRep * = LiftedRep</tt>; Panics if this is not
--   possible. Treats * and Constraint as the same
kindRep :: HasDebugCallStack => Kind -> Type

-- | Given a kind (TYPE rr), extract its RuntimeRep classifier rr. For
--   example, <tt>kindRep_maybe * = Just LiftedRep</tt> Returns
--   <a>Nothing</a> if the kind is not of form (TYPE rr) Treats * and
--   Constraint as the same
kindRep_maybe :: HasDebugCallStack => Kind -> Maybe Type

-- | Scale a payload by One
linear :: a -> Scaled a
mapTyCo :: Monad m => TyCoMapper () m -> (Type -> m Type, [Type] -> m [Type], Coercion -> m Coercion, [Coercion] -> m [Coercion])
mapTyCoX :: Monad m => TyCoMapper env m -> (env -> Type -> m Type, env -> [Type] -> m [Type], env -> Coercion -> m Coercion, env -> [Coercion] -> m [Coercion])

-- | Returns:
--   
--   <ul>
--   <li><a>False</a> if the type is <i>guaranteed</i> lifted or</li>
--   <li><a>True</a> if it is unlifted, OR we aren't sure (e.g. in a
--   levity-polymorphic case)</li>
--   </ul>
mightBeUnliftedType :: Type -> Bool

-- | Make an anonymous binder
mkAnonBinder :: AnonArgFlag -> Scaled Type -> TyCoBinder
mkAppTys :: Type -> [Type] -> Type
mkCharLitTy :: Char -> Type
mkCoercionTy :: Coercion -> Type

-- | Given a family instance TyCon and its arg types, return the
--   corresponding family type. E.g:
--   
--   <pre>
--   data family T a
--   data instance T (Maybe b) = MkT b
--   </pre>
--   
--   Where the instance tycon is :RTL, so:
--   
--   <pre>
--   mkFamilyTyConApp :RTL Int  =  T (Maybe Int)
--   </pre>
mkFamilyTyConApp :: TyCon -> [Type] -> Type

-- | Like <a>mkTyCoInvForAllTy</a>, but tv should be a tyvar
mkInfForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTys</a>, but tvs should be a list of tyvar
mkInfForAllTys :: [TyVar] -> Type -> Type
mkNumLitTy :: Integer -> Type
mkScaled :: Mult -> a -> Scaled a

-- | Like <a>mkForAllTy</a>, but assumes the variable is dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTys :: [TyVar] -> Type -> Type
mkStrLitTy :: FastString -> Type

-- | Make a dependent forall over an <a>Inferred</a> variable
mkTyCoInvForAllTy :: TyCoVar -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Inferred</a>, a common case
mkTyCoInvForAllTys :: [TyCoVar] -> Type -> Type

-- | Given a list of type-level vars and the free vars of a result kind,
--   makes TyCoBinders, preferring anonymous binders if the variable is, in
--   fact, not dependent. e.g. mkTyConBindersPreferAnon
--   <a>(k:*),(b:k),(c:k)</a> We want (k:*) Named, (b:k) Anon, (c:k) Anon
--   
--   All non-coercion binders are <i>visible</i>.
mkTyConBindersPreferAnon :: [TyVar] -> TyCoVarSet -> [TyConBinder]

-- | Like mkForAllTys, but assumes all variables are dependent and visible
mkVisForAllTys :: [TyVar] -> Type -> Type

-- | Unwrap one <tt>layer</tt> of newtype on a type constructor and its
--   arguments, using an eta-reduced version of the <tt>newtype</tt> if
--   possible. This requires tys to have at least <tt>newTyConInstArity
--   tycon</tt> elements.
newTyConInstRhs :: TyCon -> [Type] -> Type

-- | Compare two <a>TyCon</a>s. NB: This should <i>never</i> see
--   <tt>Constraint</tt> (as recognized by Kind.isConstraintKindCon) which
--   is considered a synonym for <a>Type</a> in Core. See Note [Kind
--   Constraint and kind Type] in <a>GHC.Core.Type</a>. See Note
--   [nonDetCmpType nondeterminism]
nonDetCmpTc :: TyCon -> TyCon -> Ordering
nonDetCmpType :: Type -> Type -> Ordering
nonDetCmpTypeX :: RnEnv2 -> Type -> Type -> Ordering
nonDetCmpTypes :: [Type] -> [Type] -> Ordering
nonDetCmpTypesX :: RnEnv2 -> [Type] -> [Type] -> Ordering
occCheckExpand :: [Var] -> Type -> Maybe Type

-- | Given a list of things paired with their visibilities, partition the
--   things into (invisible things, visible things).
partitionInvisibles :: [(a, ArgFlag)] -> ([a], [a])

-- | (piResultTys f_ty [ty1, .., tyn]) gives the type of (f ty1 .. tyn)
--   where f :: f_ty <a>piResultTys</a> is interesting because: 1.
--   <tt>f_ty</tt> may have more for-alls than there are args 2. Less
--   obviously, it may have fewer for-alls For case 2. think of:
--   piResultTys (forall a.a) [forall b.b, Int] This really can happen, but
--   only (I think) in situations involving undefined. For example:
--   undefined :: forall a. a Term: undefined <tt>(forall b. b-&gt;b)
--   </tt>Int This term should have type (Int -&gt; Int), but notice that
--   there are more type args than foralls in <a>undefined</a>s type.
piResultTys :: HasDebugCallStack => Type -> [Type] -> Type
pickyIsLiftedTypeKind :: Kind -> Bool

-- | Render a type corresponding to a user type error into a SDoc.
pprUserTypeErrorTy :: Type -> SDoc

-- | Attempts to obtain the type variable underlying a <a>Type</a>, without
--   any expansion
repGetTyVar_maybe :: Type -> Maybe TyVar

-- | Does the AppTy split as in <a>splitAppTy_maybe</a>, but assumes that
--   any Core view stuff is already done
repSplitAppTy_maybe :: HasDebugCallStack => Type -> Maybe (Type, Type)

-- | Like <a>splitAppTys</a>, but doesn't look through type synonyms
repSplitAppTys :: HasDebugCallStack => Type -> (Type, [Type])

-- | Like <a>splitTyConApp_maybe</a>, but doesn't look through synonyms.
--   This assumes the synonyms have already been dealt with.
repSplitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])

-- | Looking past all pi-types, is the end result potentially levity
--   polymorphic? Example: True for (forall r (a :: TYPE r). String -&gt;
--   a) Example: False for (forall r1 r2 (a :: TYPE r1) (b :: TYPE r2). a
--   -&gt; b -&gt; Type)
resultIsLevPoly :: Type -> Bool
scaledSet :: Scaled a -> b -> Scaled b
seqType :: Type -> ()
seqTypes :: [Type] -> ()

-- | Attempts to take a type application apart, as in
--   <a>splitAppTy_maybe</a>, and panics if this is not possible
splitAppTy :: Type -> (Type, Type)

-- | Attempt to take a type application apart, whether it is a function,
--   type constructor, or plain type application. Note that type family
--   applications are NEVER unsaturated by this!
splitAppTy_maybe :: Type -> Maybe (Type, Type)

-- | Recursively splits a type as far as is possible, leaving a residual
--   type being applied to and the type arguments applied to it. Never
--   fails, even if that means returning an empty list of type
--   applications.
splitAppTys :: Type -> (Type, [Type])
splitCastTy_maybe :: Type -> Maybe (Type, Coercion)

-- | Like <a>splitForAllTyCoVar_maybe</a>, but only returns Just if it is a
--   covar binder.
splitForAllCoVar_maybe :: Type -> Maybe (TyCoVar, Type)

-- | Like <a>splitForAllTyCoVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Invisible</a> type variable binders. Furthermore, each returned
--   tyvar is annotated with its <a>Specificity</a>.
splitForAllInvisTVBinders :: Type -> ([InvisTVBinder], Type)

-- | Like <a>splitForAllTyCoVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Required</a> type variable binders. Furthermore, each returned
--   tyvar is annotated with <tt>()</tt>.
splitForAllReqTVBinders :: Type -> ([ReqTVBinder], Type)

-- | Take a forall type apart, or panics if that is not possible.
splitForAllTyCoVar :: Type -> (TyCoVar, Type)

-- | Like <a>splitPiTys</a> but split off only <i>named</i> binders and
--   returns <a>TyCoVarBinder</a>s rather than <a>TyCoBinder</a>s
splitForAllTyCoVarBinders :: Type -> ([TyCoVarBinder], Type)

-- | Attempts to take a forall type apart, but only if it's a proper
--   forall, with a named binder
splitForAllTyCoVar_maybe :: Type -> Maybe (TyCoVar, Type)

-- | Take a ForAllTy apart, returning the list of tycovars and the result
--   type. This always succeeds, even if it returns only an empty list.
--   Note that the result type returned may have free variables that were
--   bound by a forall.
splitForAllTyCoVars :: Type -> ([TyCoVar], Type)

-- | Like <a>splitForAllTyCoVar_maybe</a>, but only returns Just if it is a
--   tyvar binder.
splitForAllTyVar_maybe :: Type -> Maybe (TyCoVar, Type)

-- | Attempts to extract the multiplicity, argument and result types from a
--   type, and panics if that is not possible. See also
--   <a>splitFunTy_maybe</a>
splitFunTy :: Type -> (Mult, Type, Type)

-- | Attempts to extract the multiplicity, argument and result types from a
--   type
splitFunTy_maybe :: Type -> Maybe (Mult, Type, Type)
splitFunTys :: Type -> ([Scaled Type], Type)

-- | Like <a>splitPiTys</a>, but returns only *invisible* binders,
--   including constraints. Stops at the first visible binder.
splitInvisPiTys :: Type -> ([TyCoBinder], Type)

-- | Same as <a>splitInvisPiTys</a>, but stop when - you have found
--   <tt>n</tt> <a>TyCoBinder</a>s, - or you run out of invisible binders
splitInvisPiTysN :: Int -> Type -> ([TyCoBinder], Type)

-- | Attempts to tease a list type apart and gives the type of the elements
--   if successful (looks through type synonyms)
splitListTyConApp_maybe :: Type -> Maybe Type

-- | Takes a forall type apart, or panics
splitPiTy :: Type -> (TyCoBinder, Type)

-- | Attempts to take a forall type apart; works with proper foralls and
--   functions
splitPiTy_maybe :: Type -> Maybe (TyCoBinder, Type)

-- | Split off all TyCoBinders to a type, splitting both proper foralls and
--   functions
splitPiTys :: Type -> ([TyCoBinder], Type)

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor. Panics if
--   that is not possible. See also <a>splitTyConApp_maybe</a>
splitTyConApp :: Type -> (TyCon, [Type])

-- | Retrieve the free variables in this type, splitting them based on
--   whether they are used visibly or invisibly. Invisible ones come first.
splitVisVarsOfType :: Type -> Pair TyCoVarSet
splitVisVarsOfTypes :: [Type] -> Pair TyCoVarSet
stripCoercionTy :: Type -> Coercion

-- | Is this kind equivalent to <tt>TYPE (BoxedRep l)</tt> for some <tt>l
--   :: Levity</tt>?
--   
--   This considers <tt>Constraint</tt> to be distinct from <a>Type</a>.
--   For a version that treats them as the same type, see
--   <a>isLiftedTypeKind</a>.
tcIsBoxedTypeKind :: Kind -> Bool
tcIsConstraintKind :: Kind -> Bool

-- | Is this kind equivalent to <a>Type</a>?
--   
--   This considers <tt>Constraint</tt> to be distinct from <a>Type</a>.
--   For a version that treats them as the same type, see
--   <a>isLiftedTypeKind</a>.
tcIsLiftedTypeKind :: Kind -> Bool

-- | Is this kind equivalent to <tt>TYPE r</tt> (for some unknown r)?
--   
--   This considers <tt>Constraint</tt> to be distinct from <tt>*</tt>.
tcIsRuntimeTypeKind :: Kind -> Bool

-- | Does the AppTy split as in <tt>tcSplitAppTy_maybe</tt>, but assumes
--   that any coreView stuff is already done. Refuses to look through (c
--   =&gt; t)
tcRepSplitAppTy_maybe :: Type -> Maybe (Type, Type)

-- | Like <a>tcSplitTyConApp_maybe</a>, but doesn't look through synonyms.
--   This assumes the synonyms have already been dealt with.
--   
--   Moreover, for a FunTy, it only succeeds if the argument types have
--   enough info to extract the runtime-rep arguments that the funTyCon
--   requires. This will usually be true; but may be temporarily false
--   during canonicalization: see Note [Decomposing FunTy] in
--   GHC.Tc.Solver.Canonical and Note [The Purely Kinded Type Invariant
--   (PKTI)] in GHC.Tc.Gen.HsType, Wrinkle around FunTy
tcRepSplitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])
tcReturnsConstraintKind :: Kind -> Bool

-- | Split a type constructor application into its type constructor and
--   applied types. Note that this may fail in the case of a <a>FunTy</a>
--   with an argument of unknown kind <a>FunTy</a> (e.g. <tt>FunTy (a :: k)
--   Int</tt>. since the kind of <tt>a</tt> isn't of the form <tt>TYPE
--   rep</tt>). Consequently, you may need to zonk your type before using
--   this function.
--   
--   This does *not* split types headed with (=&gt;), as that's not a TyCon
--   in the type-checker.
--   
--   If you only need the <a>TyCon</a>, consider using
--   <tt>tcTyConAppTyCon_maybe</tt>.
tcSplitTyConApp_maybe :: HasCallStack => Type -> Maybe (TyCon, [Type])
tcTypeKind :: HasDebugCallStack => Type -> Kind
tyBinderType :: TyBinder -> Type
tyCoBinderType :: TyCoBinder -> Type
tyCoBinderVar_maybe :: TyCoBinder -> Maybe TyCoVar
tyConAppArgN :: Int -> Type -> Type
tyConAppArgs :: Type -> [Type]

-- | The same as <tt>snd . splitTyConApp</tt>
tyConAppArgs_maybe :: Type -> Maybe [Type]

-- | Does a <a>TyCon</a> (that is applied to some number of arguments) need
--   to be ascribed with an explicit kind signature to resolve ambiguity if
--   rendered as a source-syntax type? (See <tt>Note [When does a tycon
--   application need an explicit kind signature?]</tt> for a full
--   explanation of what this function checks for.)
tyConAppNeedsKindSig :: Bool -> TyCon -> Int -> Bool
tyConAppTyCon :: Type -> TyCon

-- | Retrieve the tycon heading this type, if there is one. Does <i>not</i>
--   look through synonyms.
tyConAppTyConPicky_maybe :: Type -> Maybe TyCon

-- | Given a <a>TyCon</a> and a list of argument types to which the
--   <a>TyCon</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Wrinkle: consider the following scenario:
--   
--   <pre>
--   T :: forall k. k -&gt; k
--   tyConArgFlags T [forall m. m -&gt; m -&gt; m, S, R, Q]
--   </pre>
--   
--   After substituting, we get
--   
--   <pre>
--   T (forall m. m -&gt; m -&gt; m) :: (forall m. m -&gt; m -&gt; m) -&gt; forall n. n -&gt; n -&gt; n
--   </pre>
--   
--   Thus, the first argument is invisible, <tt>S</tt> is visible,
--   <tt>R</tt> is invisible again, and <tt>Q</tt> is visible.
tyConArgFlags :: TyCon -> [Type] -> [ArgFlag]
tyConBindersTyCoBinders :: [TyConBinder] -> [TyCoBinder]

-- | All type constructors occurring in the type; looking through type
--   synonyms, but not newtypes. When it finds a Class, it returns the
--   class TyCon.
tyConsOfType :: Type -> UniqSet TyCon

-- | Scale a payload by Many; used for type arguments in core
tymult :: a -> Scaled a
typeKind :: HasDebugCallStack => Type -> Kind

-- | Scale a payload by Many
unrestricted :: a -> Scaled a

-- | Is this type a custom user error? If so, give us the kind and the
--   error message.
userTypeError_maybe :: Type -> Maybe Type

-- | This describes how a "map" operation over a type/coercion should
--   behave
data TyCoMapper env m
TyCoMapper :: (env -> TyVar -> m Type) -> (env -> CoVar -> m Coercion) -> (env -> CoercionHole -> m Coercion) -> (env -> TyCoVar -> ArgFlag -> m (env, TyCoVar)) -> (TyCon -> m TyCon) -> TyCoMapper env m
[tcm_tyvar] :: TyCoMapper env m -> env -> TyVar -> m Type
[tcm_covar] :: TyCoMapper env m -> env -> CoVar -> m Coercion

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcm_hole] :: TyCoMapper env m -> env -> CoercionHole -> m Coercion

-- | The returned env is used in the extended scope
[tcm_tycobinder] :: TyCoMapper env m -> env -> TyCoVar -> ArgFlag -> m (env, TyCoVar)

-- | This is used only for TcTyCons a) To zonk TcTyCons b) To turn TcTyCons
--   into TyCons. See Note [Type checking recursive type and class
--   declarations] in <a>GHC.Tc.TyCl</a>
[tcm_tycon] :: TyCoMapper env m -> TyCon -> m TyCon

-- | Type or Coercion Variable
type TyCoVar = Id

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var
pickLR :: LeftOrRight -> (a, a) -> a
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight

-- | A <a>Coercion</a> is concrete evidence of the equality/convertibility
--   of two types.
data Coercion
type CoercionN = Coercion

-- | A semantically more meaningful type to represent what may or may not
--   be a useful <a>Coercion</a>.
data MCoercion
MRefl :: MCoercion
MCo :: Coercion -> MCoercion
type MCoercionN = MCoercion

-- | For simplicity, we have just one UnivCo that represents a coercion
--   from some type to some other type, with (in general) no restrictions
--   on the type. The UnivCoProvenance specifies more exactly what the
--   coercion really is and why a program should (or shouldn't!) trust the
--   coercion. It is reasonable to consider each constructor of
--   <a>UnivCoProvenance</a> as a totally independent coercion form; their
--   only commonality is that they don't tell you what types they coercion
--   between. (That info is in the <a>UnivCo</a> constructor of
--   <a>Coercion</a>.
data UnivCoProvenance
pprCo :: Coercion -> SDoc

-- | Is this a coercion variable? Satisfies <tt><a>isId</a> v ==&gt;
--   <a>isCoVar</a> v == not (<a>isNonCoVarId</a> v)</tt>.
isCoVar :: Var -> Bool
mkCoVar :: Name -> Type -> CoVar

-- | Coercion Variable
type CoVar = Id
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
coVarKindsTypesRole :: HasDebugCallStack => CoVar -> (Kind, Kind, Type, Type, Role)
coVarRole :: CoVar -> Role

-- | If it is the case that
--   
--   <pre>
--   c :: (t1 ~ t2)
--   </pre>
--   
--   i.e. the kind of <tt>c</tt> relates <tt>t1</tt> and <tt>t2</tt>, then
--   <tt>coercionKind c = Pair t1 t2</tt>.
coercionKind :: Coercion -> Pair Type
coercionLKind :: Coercion -> Type
coercionRKind :: Coercion -> Type
coercionType :: Coercion -> Type
decomposePiCos :: HasDebugCallStack => CoercionN -> Pair Type -> [Type] -> ([CoercionN], CoercionN)

-- | Tests if this coercion is obviously a generalized reflexive coercion.
--   Guaranteed to work very quickly.
isGReflCo :: Coercion -> Bool

-- | Tests if this coercion is obviously reflexive. Guaranteed to work very
--   quickly. Sometimes a coercion can be reflexive, but not obviously so.
--   c.f. <a>isReflexiveCo</a>
isReflCo :: Coercion -> Bool

-- | Slowly checks if the coercion is reflexive. Don't call this in a loop,
--   as it walks over the entire coercion.
isReflexiveCo :: Coercion -> Bool

-- | <tt>liftCoSubst role lc ty</tt> produces a coercion (at role
--   <tt>role</tt>) that coerces between <tt>lc_left(ty)</tt> and
--   <tt>lc_right(ty)</tt>, where <tt>lc_left</tt> is a substitution
--   mapping type variables to the left-hand types of the mapped coercions
--   in <tt>lc</tt>, and similar for <tt>lc_right</tt>.
liftCoSubst :: HasDebugCallStack => Role -> LiftingContext -> Type -> Coercion

-- | Apply a <a>Coercion</a> to another <a>Coercion</a>. The second
--   coercion must be Nominal, unless the first is Phantom. If the first is
--   Phantom, then the second can be either Phantom or Nominal.
mkAppCo :: Coercion -> Coercion -> Coercion
mkAxiomInstCo :: CoAxiom Branched -> BranchIndex -> [Coercion] -> Coercion
mkAxiomRuleCo :: CoAxiomRule -> [Coercion] -> Coercion
mkCoVarCo :: CoVar -> Coercion

-- | Makes a coercion type from two types: the types whose equality is
--   proven by the relevant <a>Coercion</a>
mkCoercionType :: Role -> Type -> Type -> Type

-- | Make a Coercion from a tycovar, a kind coercion, and a body coercion.
--   The kind of the tycovar should be the left-hand kind of the kind
--   coercion. See Note [Unused coercion variable in ForAllCo]
mkForAllCo :: TyCoVar -> CoercionN -> Coercion -> Coercion

-- | Build a function <a>Coercion</a> from two other <a>Coercion</a>s. That
--   is, given <tt>co1 :: a ~ b</tt> and <tt>co2 :: x ~ y</tt> produce
--   <tt>co :: (a -&gt; x) ~ (b -&gt; y)</tt>.
mkFunCo :: Role -> CoercionN -> Coercion -> Coercion -> Coercion

-- | Make a generalized reflexive coercion
mkGReflCo :: Role -> Type -> MCoercionN -> Coercion

-- | Instantiates a <a>Coercion</a>.
mkInstCo :: Coercion -> Coercion -> Coercion

-- | Given <tt>co :: (a :: k) ~ (b :: k')</tt> produce <tt>co' :: k ~
--   k'</tt>.
mkKindCo :: Coercion -> Coercion
mkLRCo :: LeftOrRight -> Coercion -> Coercion

-- | Make a nominal reflexive coercion
mkNomReflCo :: Type -> Coercion
mkNthCo :: HasDebugCallStack => Role -> Int -> Coercion -> Coercion

-- | Make a phantom coercion between two types. The coercion passed in must
--   be a nominal coercion between the kinds of the types.
mkPhantomCo :: Coercion -> Type -> Type -> Coercion

-- | Make a "coercion between coercions".
mkProofIrrelCo :: Role -> Coercion -> Coercion -> Coercion -> Coercion

-- | Make a reflexive coercion
mkReflCo :: Role -> Type -> Coercion
mkSubCo :: HasDebugCallStack => Coercion -> Coercion

-- | Create a symmetric version of the given <a>Coercion</a> that asserts
--   equality between the same types but in the other "direction", so a
--   kind of <tt>t1 ~ t2</tt> becomes the kind <tt>t2 ~ t1</tt>.
mkSymCo :: Coercion -> Coercion

-- | Create a new <a>Coercion</a> by composing the two given
--   <a>Coercion</a>s transitively. (co1 ; co2)
mkTransCo :: Coercion -> Coercion -> Coercion

-- | Apply a type constructor to a list of coercions. It is the caller's
--   responsibility to get the roles correct on argument coercions.
mkTyConAppCo :: HasDebugCallStack => Role -> TyCon -> [Coercion] -> Coercion

-- | Make a universal coercion between two arbitrary types.
mkUnivCo :: UnivCoProvenance -> Role -> Type -> Type -> Coercion
seqCo :: Coercion -> ()
data LiftingContext
LC :: TCvSubst -> LiftCoEnv -> LiftingContext
coHoleCoVar :: CoercionHole -> CoVar
coercionSize :: Coercion -> Int
setCoHoleCoVar :: CoercionHole -> CoVar -> CoercionHole

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
CoercionHole :: CoVar -> IORef (Maybe Coercion) -> CoercionHole
[ch_co_var] :: CoercionHole -> CoVar
[ch_ref] :: CoercionHole -> IORef (Maybe Coercion)
type CoercionP = Coercion
type CoercionR = Coercion
type MCoercionR = MCoercion
anyFreeVarsOfCo :: (TyCoVar -> Bool) -> Coercion -> Bool
coVarsOfCo :: Coercion -> CoVarSet
tyCoFVsOfCo :: Coercion -> FV
tyCoFVsOfCos :: [Coercion] -> FV
tyCoVarsOfCo :: Coercion -> TyCoVarSet

-- | Get a deterministic set of the vars free in a coercion
tyCoVarsOfCoDSet :: Coercion -> DTyCoVarSet
tyCoVarsOfCos :: [Coercion] -> TyCoVarSet

-- | Tidy a Coercion
--   
--   See Note [Strictness in tidyType and friends]
tidyCo :: TidyEnv -> Coercion -> Coercion
tidyCos :: TidyEnv -> [Coercion] -> [Coercion]
emptyCvSubstEnv :: CvSubstEnv
extendTvSubstAndInScope :: TCvSubst -> TyVar -> Type -> TCvSubst
getCvSubstEnv :: TCvSubst -> CvSubstEnv
lookupCoVar :: TCvSubst -> Var -> Maybe Coercion
substCoVar :: TCvSubst -> CoVar -> Coercion
substCoVarBndr :: HasCallStack => TCvSubst -> CoVar -> (TCvSubst, CoVar)
substCoVars :: TCvSubst -> [CoVar] -> [Coercion]

-- | Coercion substitution, see <a>zipTvSubst</a>
substCoWith :: HasCallStack => [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute within several <a>Coercion</a>s The substitution has to
--   satisfy the invariants described in Note [The substitution invariant].
substCos :: HasCallStack => TCvSubst -> [Coercion] -> [Coercion]

-- | A substitution of <a>Coercion</a>s for <a>CoVar</a>s
type CvSubstEnv = CoVarEnv Coercion
pprParendCo :: Coercion -> SDoc

-- | Assuming that two types are the same, ignoring coercions, find a
--   nominal coercion between the types. This is useful when optimizing
--   transitivity over coercion applications, where splitting two AppCos
--   might yield different kinds. See Note [EtaAppCo] in
--   <a>GHC.Core.Coercion.Opt</a>.
buildCoercion :: Type -> Type -> CoercionN

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind g h1 h2</tt>, where <tt>g :: t1 ~r t2</tt>,
--   has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt> and
--   <tt>h2</tt> must be nominal. It calls <tt>coercionKindRole</tt>, so
--   it's quite inefficient (which <tt>I</tt> stands for) Use
--   <tt>castCoercionKind2</tt> instead if <tt>t1</tt>, <tt>t2</tt>, and
--   <tt>r</tt> are known beforehand.
castCoercionKind :: Coercion -> CoercionN -> CoercionN -> Coercion

-- | <tt>castCoercionKind1 g r t1 t2 h</tt> = <tt>coercionKind g r t1 t2 h
--   h</tt> That is, it's a specialised form of castCoercionKind, where the
--   two kind coercions are identical <tt>castCoercionKind1 g r t1 t2
--   h</tt>, where <tt>g :: t1 ~r t2</tt>, has type <tt>(t1 |&gt; h) ~r (t2
--   |&gt; h)</tt>. <tt>h</tt> must be nominal. See Note
--   [castCoercionKind1]
castCoercionKind1 :: Coercion -> Role -> Type -> Type -> CoercionN -> Coercion

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind2 g r t1 t2 h1 h2</tt>, where <tt>g :: t1 ~r
--   t2</tt>, has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt>
--   and <tt>h2</tt> must be nominal.
castCoercionKind2 :: Coercion -> Role -> Type -> Type -> CoercionN -> CoercionN -> Coercion
checkReflexiveMCo :: MCoercion -> MCoercion
coToMCo :: Coercion -> MCoercion
coVarKind :: CoVar -> Type
coVarName :: CoVar -> Name
coVarTypes :: HasDebugCallStack => CoVar -> Pair Type
coercionHolesOfCo :: Coercion -> UniqSet CoercionHole

-- | Extract out all the coercion holes from a given type
coercionHolesOfType :: Type -> UniqSet CoercionHole

-- | Get a coercion's kind and role.
coercionKindRole :: Coercion -> (Pair Type, Role)

-- | Apply <a>coercionKind</a> to multiple <a>Coercion</a>s
coercionKinds :: [Coercion] -> Pair [Type]

-- | Retrieve the role from a coercion.
coercionRole :: Coercion -> Role

-- | Try one stepper and then try the next, if the first doesn't make
--   progress. So if it returns NS_Done, it means that both steppers are
--   satisfied
composeSteppers :: NormaliseStepper ev -> NormaliseStepper ev -> NormaliseStepper ev

-- | This breaks a <a>Coercion</a> with type <tt>T A B C ~ T D E F</tt>
--   into a list of <a>Coercion</a>s of kinds <tt>A ~ D</tt>, <tt>B ~
--   E</tt> and <tt>E ~ F</tt>. Hence:
--   
--   <pre>
--   decomposeCo 3 c [r1, r2, r3] = [nth r1 0 c, nth r2 1 c, nth r3 2 c]
--   </pre>
decomposeCo :: Arity -> Coercion -> [Role] -> [Coercion]
decomposeFunCo :: HasDebugCallStack => Role -> Coercion -> (CoercionN, Coercion, Coercion)

-- | Like <a>downgradeRole_maybe</a>, but panics if the change isn't a
--   downgrade. See Note [Role twiddling functions]
downgradeRole :: Role -> Role -> Coercion -> Coercion
emptyLiftingContext :: InScopeSet -> LiftingContext

-- | Syntactic equality of coercions
eqCoercion :: Coercion -> Coercion -> Bool

-- | Compare two <a>Coercion</a>s, with respect to an RnEnv2
eqCoercionX :: RnEnv2 -> Coercion -> Coercion -> Bool
etaExpandCoAxBranch :: CoAxBranch -> ([TyVar], [Type], Type)

-- | Extend a lifting context with a new mapping.
extendLiftingContext :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext

-- | Extend a lifting context with a new mapping, and extend the in-scope
--   set
extendLiftingContextAndInScope :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext

-- | Attempts to obtain the type variable underlying a <a>Coercion</a>
getCoVar_maybe :: Coercion -> Maybe CoVar

-- | Is there a coercion hole in this coercion?
hasCoercionHoleCo :: Coercion -> Bool

-- | Is there a coercion hole in this type?
hasCoercionHoleTy :: Type -> Bool

-- | If <tt>co :: T ts ~ rep_ty</tt> then:
--   
--   <pre>
--   instNewTyCon_maybe T ts = Just (rep_ty, co)
--   </pre>
--   
--   Checks for a newtype, and for being saturated
instNewTyCon_maybe :: TyCon -> [Type] -> Maybe (Type, Coercion)

-- | Extract a covar, if possible. This check is dirty. Be ashamed of
--   yourself. (It's dirty because it cares about the structure of a
--   coercion, which is morally reprehensible.)
isCoVar_maybe :: Coercion -> Maybe CoVar

-- | Returns the type coerced if this coercion is a generalized reflexive
--   coercion. Guaranteed to work very quickly.
isGReflCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Tests if this MCoercion is obviously generalized reflexive Guaranteed
--   to work very quickly.
isGReflMCo :: MCoercion -> Bool

-- | Is a var in the domain of a lifting context?
isMappedByLC :: TyCoVar -> LiftingContext -> Bool
isReflCoVar_maybe :: Var -> Maybe Coercion

-- | Returns the type coerced if this coercion is reflexive. Guaranteed to
--   work very quickly. Sometimes a coercion can be reflexive, but not
--   obviously so. c.f. <a>isReflexiveCo_maybe</a>
isReflCo_maybe :: Coercion -> Maybe (Type, Role)
isReflMCo :: MCoercion -> Bool

-- | Extracts the coerced type from a reflexive coercion. This potentially
--   walks over the entire coercion, so avoid doing this in a loop.
isReflexiveCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Get the <a>InScopeSet</a> from a <a>LiftingContext</a>
lcInScopeSet :: LiftingContext -> InScopeSet
lcSubstLeft :: LiftingContext -> TCvSubst
lcSubstRight :: LiftingContext -> TCvSubst

-- | Extract the underlying substitution from the LiftingContext
lcTCvSubst :: LiftingContext -> TCvSubst
liftCoSubstTyVar :: LiftingContext -> Role -> TyVar -> Maybe Coercion
liftCoSubstVarBndrUsing :: (LiftingContext -> Type -> (CoercionN, a)) -> LiftingContext -> TyCoVar -> (LiftingContext, TyCoVar, CoercionN, a)
liftCoSubstWith :: Role -> [TyCoVar] -> [Coercion] -> Type -> Coercion
liftCoSubstWithEx :: Role -> [TyVar] -> [Coercion] -> [TyCoVar] -> [Type] -> (Type -> Coercion, [Type])
liftEnvSubstLeft :: TCvSubst -> LiftCoEnv -> TCvSubst
liftEnvSubstRight :: TCvSubst -> LiftCoEnv -> TCvSubst
ltRole :: Role -> Role -> Bool
mapStepResult :: (ev1 -> ev2) -> NormaliseStepResult ev1 -> NormaliseStepResult ev2

-- | Applies multiple <a>Coercion</a>s to another <a>Coercion</a>, from
--   left to right. See also <a>mkAppCo</a>.
mkAppCos :: Coercion -> [Coercion] -> Coercion
mkAxInstCo :: Role -> CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Coercion

-- | Return the left-hand type of the axiom, when the axiom is instantiated
--   at the types given.
mkAxInstLHS :: CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type
mkAxInstRHS :: CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type

-- | Cast a type by an <a>MCoercion</a>
mkCastTyMCo :: Type -> MCoercion -> Type
mkCoCast :: Coercion -> CoercionR -> Coercion
mkCoVarCos :: [CoVar] -> [Coercion]

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty ~r
--   ty'</tt>, produces @co' :: (ty |&gt; co) ~r ty' It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceLeftCo :: Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty' ~r
--   ty</tt>, produces @co' :: ty' ~r (ty |&gt; co) It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceRightCo :: Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Like <a>mkCoherenceRightCo</a>, but with an <a>MCoercion</a>
mkCoherenceRightMCo :: Role -> Type -> MCoercionN -> Coercion -> Coercion

-- | Given a family instance <a>TyCon</a> and its arg <a>Coercion</a>s,
--   return the corresponding family <a>Coercion</a>. E.g:
--   
--   <pre>
--   data family T a
--   data instance T (Maybe b) = MkT b
--   </pre>
--   
--   Where the instance <a>TyCon</a> is :RTL, so:
--   
--   <pre>
--   mkFamilyTyConAppCo :RTL (co :: a ~# Int) = T (Maybe a) ~# T (Maybe Int)
--   </pre>
--   
--   cf. <a>mkFamilyTyConApp</a>
mkFamilyTyConAppCo :: TyCon -> [CoercionN] -> CoercionN

-- | Make nested ForAllCos
mkForAllCos :: [(TyCoVar, CoercionN)] -> Coercion -> Coercion
mkFunResCo :: Role -> Scaled Type -> Coercion -> Coercion
mkFunResMCo :: Scaled Type -> MCoercionR -> MCoercionR

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, produces <tt>co' ::
--   (ty |&gt; co) ~r ty</tt>
mkGReflLeftCo :: Role -> Type -> CoercionN -> Coercion
mkGReflLeftMCo :: Role -> Type -> MCoercionN -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, produces <tt>co' ::
--   ty ~r (ty |&gt; co)</tt>
mkGReflRightCo :: Role -> Type -> CoercionN -> Coercion
mkGReflRightMCo :: Role -> Type -> MCoercionN -> Coercion
mkHeteroCoercionType :: Role -> Kind -> Kind -> Type -> Type -> Type

-- | Creates a primitive type equality predicate with explicit kinds
mkHeteroPrimEqPred :: Kind -> Kind -> Type -> Type -> Type

-- | Creates a primitive representational type equality predicate with
--   explicit kinds
mkHeteroReprPrimEqPred :: Kind -> Kind -> Type -> Type -> Type

-- | Make a coercion from a coercion hole
mkHoleCo :: CoercionHole -> Coercion

-- | Make a Coercion quantified over a type/coercion variable; the variable
--   has the same type in both sides of the coercion
mkHomoForAllCos :: [TyCoVar] -> Coercion -> Coercion
mkHomoForAllMCo :: TyCoVar -> MCoercion -> MCoercion

-- | Extract the nth field of a FunCo
mkNthCoFunCo :: Int -> CoercionN -> Coercion -> Coercion -> Coercion

-- | Make a forall <a>Coercion</a>, where both types related by the
--   coercion are quantified over the same variable.
mkPiCo :: Role -> Var -> Coercion -> Coercion
mkPiCos :: Role -> [Var] -> Coercion -> Coercion
mkPiMCos :: [Var] -> MCoercion -> MCoercion

-- | Creates a primitive type equality predicate. Invariant: the types are
--   not Coercions
mkPrimEqPred :: Type -> Type -> Type

-- | Makes a lifted equality predicate at the given role
mkPrimEqPredRole :: Role -> Type -> Type -> PredType

-- | Make a representational reflexive coercion
mkRepReflCo :: Type -> Coercion
mkReprPrimEqPred :: Type -> Type -> Type
mkSubstLiftingContext :: TCvSubst -> LiftingContext

-- | Get the reverse of an <a>MCoercion</a>
mkSymMCo :: MCoercion -> MCoercion

-- | Compose two MCoercions via transitivity
mkTransMCo :: MCoercion -> MCoercion -> MCoercion
mkTransMCoL :: MCoercion -> Coercion -> MCoercion
mkTransMCoR :: Coercion -> MCoercion -> MCoercion
mkUnbranchedAxInstCo :: Role -> CoAxiom Unbranched -> [Type] -> [Coercion] -> Coercion

-- | Instantiate the left-hand side of an unbranched axiom
mkUnbranchedAxInstLHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type
mkUnbranchedAxInstRHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type
multToCo :: Mult -> Coercion

-- | If you're about to call <tt>mkNthCo r n co</tt>, then <tt>r</tt>
--   should be whatever <tt>nthCoRole n co</tt> returns.
nthCoRole :: Int -> Coercion -> Role
nthRole :: Role -> TyCon -> Int -> Role
pprCoAxBranch :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchLHS :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchUser :: TyCon -> CoAxBranch -> SDoc
pprCoAxiom :: CoAxiom br -> SDoc

-- | like mkKindCo, but aggressively &amp; recursively optimizes to avoid
--   using a KindCo constructor. The output role is nominal.
promoteCoercion :: Coercion -> CoercionN
setCoVarName :: CoVar -> Name -> CoVar
setCoVarUnique :: CoVar -> Unique -> CoVar

-- | Converts a coercion to be nominal, if possible. See Note [Role
--   twiddling functions]
setNominalRole_maybe :: Role -> Coercion -> Maybe Coercion
simplifyArgsWorker :: [TyCoBinder] -> Kind -> TyCoVarSet -> [Role] -> [(Type, Coercion)] -> ([Type], [Coercion], MCoercionN)

-- | Attempt to take a coercion application apart.
splitAppCo_maybe :: Coercion -> Maybe (Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for covar
--   binder
splitForAllCo_co_maybe :: Coercion -> Maybe (CoVar, Coercion, Coercion)
splitForAllCo_maybe :: Coercion -> Maybe (TyCoVar, Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for tyvar
--   binder
splitForAllCo_ty_maybe :: Coercion -> Maybe (TyVar, Coercion, Coercion)
splitFunCo_maybe :: Coercion -> Maybe (Coercion, Coercion)

-- | Attempts to tease a coercion apart into a type constructor and the
--   application of a number of coercion arguments to that constructor
splitTyConAppCo_maybe :: Coercion -> Maybe (TyCon, [Coercion])

-- | Like <a>substForAllCoBndr</a>, but works on a lifting context
substForAllCoBndrUsingLC :: Bool -> (Coercion -> Coercion) -> LiftingContext -> TyCoVar -> Coercion -> (LiftingContext, TyCoVar, Coercion)
substLeftCo :: LiftingContext -> Coercion -> Coercion
substRightCo :: LiftingContext -> Coercion -> Coercion

-- | Apply "sym" to all coercions in a <a>LiftCoEnv</a>
swapLiftCoEnv :: LiftCoEnv -> LiftCoEnv
tidyCoAxBndrsForUser :: TidyEnv -> [Var] -> (TidyEnv, [Var])

-- | Sometimes we want to look through a <tt>newtype</tt> and get its
--   associated coercion. This function strips off <tt>newtype</tt> layers
--   enough to reveal something that isn't a <tt>newtype</tt>.
--   Specifically, here's the invariant:
--   
--   <pre>
--   topNormaliseNewType_maybe rec_nts ty = Just (co, ty')
--   </pre>
--   
--   then (a) <tt>co : ty ~ ty'</tt>. (b) ty' is not a newtype.
--   
--   The function returns <tt>Nothing</tt> for non-<tt>newtypes</tt>, or
--   unsaturated applications
--   
--   This function does *not* look through type families, because it has no
--   access to the type family environment. If you do have that at hand,
--   consider to use topNormaliseType_maybe, which should be a drop-in
--   replacement for topNormaliseNewType_maybe If topNormliseNewType_maybe
--   ty = Just (co, ty'), then co : ty ~R ty'
topNormaliseNewType_maybe :: Type -> Maybe (Coercion, Type)

-- | A general function for normalising the top-level of a type. It
--   continues to use the provided <a>NormaliseStepper</a> until that
--   function fails, and then this function returns. The roles of the
--   coercions produced by the <a>NormaliseStepper</a> must all be the
--   same, which is the role returned from the call to
--   <a>topNormaliseTypeX</a>.
--   
--   Typically ev is Coercion.
--   
--   If topNormaliseTypeX step plus ty = Just (ev, ty') then ty ~ev1~ t1
--   ~ev2~ t2 ... ~evn~ ty' and ev = ev1 <tt>plus</tt> ev2 <tt>plus</tt>
--   ... <tt>plus</tt> evn If it returns Nothing then no newtype unwrapping
--   could happen
topNormaliseTypeX :: NormaliseStepper ev -> (ev -> ev -> ev) -> Type -> Maybe (ev, Type)
tyConRolesRepresentational :: TyCon -> [Role]
tyConRolesX :: Role -> TyCon -> [Role]

-- | A <a>NormaliseStepper</a> that unwraps newtypes, careful not to fall
--   into a loop. If it would fall into a loop, it produces
--   <a>NS_Abort</a>.
unwrapNewTypeStepper :: NormaliseStepper Coercion

-- | Erase the environments in a lifting context
zapLiftingContext :: LiftingContext -> LiftingContext

-- | A set of <a>CoercionHole</a>s
type HoleSet = UniqSet CoercionHole
type LiftCoEnv = VarEnv Coercion

-- | The result of stepping in a normalisation function. See
--   <a>topNormaliseTypeX</a>.
data NormaliseStepResult ev

-- | Nothing more to do
NS_Done :: NormaliseStepResult ev

-- | Utter failure. The outer function should fail too.
NS_Abort :: NormaliseStepResult ev

-- | We stepped, yielding new bits; ^ ev is evidence; Usually a co :: old
--   type ~ new type
NS_Step :: RecTcChecker -> Type -> ev -> NormaliseStepResult ev

-- | A function to check if we can reduce a type by one step. Used with
--   <a>topNormaliseTypeX</a>.
type NormaliseStepper ev = RecTcChecker -> TyCon -> [Type] -> NormaliseStepResult ev

-- | Class of things that we can obtain a <a>Unique</a> from
class Uniquable a
getUnique :: Uniquable a => a -> Unique

-- | Unique identifier.
--   
--   The type of unique identifiers that are used in many places in GHC for
--   fast ordering and equality tests. You should generate these with the
--   functions from the <tt>UniqSupply</tt> module
--   
--   These are sometimes also referred to as "keys" in comments in GHC.
data Unique

-- | Attempt to convert a Template Haskell name to one that GHC can
--   understand. Original TH names such as those you get when you use the
--   <tt>'foo</tt> syntax will be translated to their equivalent GHC name
--   exactly. Qualified or unqualified TH names will be dynamically bound
--   to names in the module being compiled, if possible. Exact TH names
--   will be bound to the name they represent, exactly.
thNameToGhcName :: Name -> CoreM (Maybe Name)
instance GHC.Types.TyThing.MonadThings GHC.Core.Opt.Monad.CoreM

module GHC.Runtime.Heap.Inspect

-- | Term reconstruction
--   
--   Given a pointer to a heap object (<a>HValue</a>) and its type, build a
--   <a>Term</a> representation of the object. Subterms (objects in the
--   payload) are also built up to the given <tt>max_depth</tt>. After
--   <tt>max_depth</tt> any subterms will appear as <a>Suspension</a>s. Any
--   thunks found while traversing the object will be forced based on
--   <tt>force</tt> parameter.
--   
--   Types of terms will be refined based on constructors we find during
--   term reconstruction. See <a>cvReconstructType</a> for an overview of
--   how type reconstruction works.
cvObtainTerm :: HscEnv -> Int -> Bool -> RttiType -> ForeignHValue -> IO Term

-- | Fast, breadth-first Type reconstruction
--   
--   Given a heap object (<a>HValue</a>) and its (possibly polymorphic)
--   type (usually obtained in GHCi), try to reconstruct a more monomorphic
--   type of the object. This is used for improving type information in
--   debugger. For example, if we have a polymorphic function:
--   
--   sumNumList :: Num a =&gt; [a] -&gt; a sumNumList [] = 0 sumNumList (x
--   : xs) = x + sumList xs
--   
--   and add a breakpoint to it:
--   
--   ghci&gt; break sumNumList ghci&gt; sumNumList ([0 .. 9] :: [Int])
--   
--   ghci shows us more precise types than just <tt>a</tt>s:
--   
--   Stopped in Main.sumNumList, debugger.hs:3:23-39 _result :: Int = _ x
--   :: Int = 0 xs :: [Int] = _
cvReconstructType :: HscEnv -> Int -> GhciType -> ForeignHValue -> IO (Maybe Type)
improveRTTIType :: HscEnv -> RttiType -> RttiType -> Maybe TCvSubst
data Term
Term :: RttiType -> Either String DataCon -> ForeignHValue -> [Term] -> Term
[ty] :: Term -> RttiType
[dc] :: Term -> Either String DataCon
[val] :: Term -> ForeignHValue
[subTerms] :: Term -> [Term]
Prim :: RttiType -> [Word] -> Term
[ty] :: Term -> RttiType
[valRaw] :: Term -> [Word]
Suspension :: ClosureType -> RttiType -> ForeignHValue -> Maybe Name -> Term
[ctype] :: Term -> ClosureType
[ty] :: Term -> RttiType
[val] :: Term -> ForeignHValue
[bound_to] :: Term -> Maybe Name
NewtypeWrap :: RttiType -> Either String DataCon -> Term -> Term
[ty] :: Term -> RttiType
[dc] :: Term -> Either String DataCon
[wrapped_term] :: Term -> Term
RefWrap :: RttiType -> Term -> Term
[ty] :: Term -> RttiType
[wrapped_term] :: Term -> Term
isFullyEvaluatedTerm :: Term -> Bool
termType :: Term -> RttiType
mapTermType :: (RttiType -> Type) -> Term -> Term
termTyCoVars :: Term -> TyCoVarSet
foldTerm :: TermFold a -> Term -> a
data TermFold a
TermFold :: TermProcessor a a -> (RttiType -> [Word] -> a) -> (ClosureType -> RttiType -> ForeignHValue -> Maybe Name -> a) -> (RttiType -> Either String DataCon -> a -> a) -> (RttiType -> a -> a) -> TermFold a
[fTerm] :: TermFold a -> TermProcessor a a
[fPrim] :: TermFold a -> RttiType -> [Word] -> a
[fSuspension] :: TermFold a -> ClosureType -> RttiType -> ForeignHValue -> Maybe Name -> a
[fNewtypeWrap] :: TermFold a -> RttiType -> Either String DataCon -> a -> a
[fRefWrap] :: TermFold a -> RttiType -> a -> a

-- | Takes a list of custom printers with a explicit recursion knot and a
--   term, and returns the output of the first successful printer, or the
--   default printer
cPprTerm :: Monad m => CustomTermPrinter m -> Term -> m SDoc
cPprTermBase :: forall m. Monad m => CustomTermPrinter m
constrClosToName :: HscEnv -> GenClosure a -> IO (Either String Name)
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Inspect.Term


-- | This module provides an interface for typechecker plugins to access
--   select functions of the <tt>TcM</tt>, principally those to do with
--   reading parts of the state.
module GHC.Tc.Plugin
data TcPluginM a

-- | Perform some IO, typically to interact with an external tool.
tcPluginIO :: IO a -> TcPluginM a

-- | Output useful for debugging the compiler.
tcPluginTrace :: String -> SDoc -> TcPluginM ()

-- | This function provides an escape for direct access to the <a>TcM</a>
--   monad. It should not be used lightly, and the provided
--   <a>TcPluginM</a> API should be favoured instead.
unsafeTcPluginTcM :: TcM a -> TcPluginM a

-- | The result of searching for an imported module.
--   
--   NB: FindResult manages both user source-import lookups (which can
--   result in <a>Module</a>) as well as direct imports for interfaces
--   (which always result in <a>InstalledModule</a>).
data FindResult

-- | The module was found
Found :: ModLocation -> Module -> FindResult

-- | The requested unit was not found
NoPackage :: Unit -> FindResult

-- | _Error_: both in multiple packages
FoundMultiple :: [(Module, ModuleOrigin)] -> FindResult

-- | Not found
NotFound :: [FilePath] -> Maybe Unit -> [Unit] -> [Unit] -> [(Unit, UnusableUnitReason)] -> [ModuleSuggestion] -> FindResult

-- | Places where I looked
[fr_paths] :: FindResult -> [FilePath]

-- | Just p =&gt; module is in this unit's manifest, but couldn't find the
--   .hi file
[fr_pkg] :: FindResult -> Maybe Unit

-- | Module is in these units, but the *module* is hidden
[fr_mods_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but the *unit* is hidden
[fr_pkgs_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but it is unusable
[fr_unusables] :: FindResult -> [(Unit, UnusableUnitReason)]

-- | Possible mis-spelled modules
[fr_suggestions] :: FindResult -> [ModuleSuggestion]
findImportedModule :: ModuleName -> Maybe FastString -> TcPluginM FindResult
lookupOrig :: Module -> OccName -> TcPluginM Name
tcLookupGlobal :: Name -> TcPluginM TyThing
tcLookupTyCon :: Name -> TcPluginM TyCon
tcLookupDataCon :: Name -> TcPluginM DataCon
tcLookupClass :: Name -> TcPluginM Class
tcLookup :: Name -> TcPluginM TcTyThing
tcLookupId :: Name -> TcPluginM Id
getTopEnv :: TcPluginM HscEnv
getEnvs :: TcPluginM (TcGblEnv, TcLclEnv)
getInstEnvs :: TcPluginM InstEnvs
getFamInstEnvs :: TcPluginM (FamInstEnv, FamInstEnv)
matchFam :: TyCon -> [Type] -> TcPluginM (Maybe (TcCoercion, TcType))
newUnique :: TcPluginM Unique
newFlexiTyVar :: Kind -> TcPluginM TcTyVar
isTouchableTcPluginM :: TcTyVar -> TcPluginM Bool
zonkTcType :: TcType -> TcPluginM TcType
zonkCt :: Ct -> TcPluginM Ct

-- | Create a new wanted constraint.
newWanted :: CtLoc -> PredType -> TcPluginM CtEvidence

-- | Create a new derived constraint.
newDerived :: CtLoc -> PredType -> TcPluginM CtEvidence

-- | Create a new given constraint, with the supplied evidence. This must
--   not be invoked from <tt>tcPluginInit</tt> or <tt>tcPluginStop</tt>, or
--   it will panic.
newGiven :: CtLoc -> PredType -> EvExpr -> TcPluginM CtEvidence

-- | Create a fresh coercion hole.
newCoercionHole :: PredType -> TcPluginM CoercionHole

-- | Create a fresh evidence variable.
newEvVar :: PredType -> TcPluginM EvVar

-- | Bind an evidence variable. This must not be invoked from
--   <tt>tcPluginInit</tt> or <tt>tcPluginStop</tt>, or it will panic.
setEvBind :: EvBind -> TcPluginM ()

-- | Access the <a>EvBindsVar</a> carried by the <a>TcPluginM</a> during
--   constraint solving. Returns <a>Nothing</a> if invoked during
--   <a>tcPluginInit</a> or <a>tcPluginStop</a>.
getEvBindsTcPluginM :: TcPluginM EvBindsVar

module GHC.Runtime.Eval
data Resume
Resume :: String -> ForeignRef (ResumeContext [HValueRef]) -> ([TyThing], GlobalRdrEnv) -> [Id] -> ForeignHValue -> Maybe BreakInfo -> SrcSpan -> String -> RemotePtr CostCentreStack -> [History] -> Int -> Resume
[resumeStmt] :: Resume -> String
[resumeContext] :: Resume -> ForeignRef (ResumeContext [HValueRef])
[resumeBindings] :: Resume -> ([TyThing], GlobalRdrEnv)
[resumeFinalIds] :: Resume -> [Id]
[resumeApStack] :: Resume -> ForeignHValue
[resumeBreakInfo] :: Resume -> Maybe BreakInfo
[resumeSpan] :: Resume -> SrcSpan
[resumeDecl] :: Resume -> String
[resumeCCS] :: Resume -> RemotePtr CostCentreStack
[resumeHistory] :: Resume -> [History]
[resumeHistoryIx] :: Resume -> Int
data History
History :: ForeignHValue -> BreakInfo -> [String] -> History
[historyApStack] :: History -> ForeignHValue
[historyBreakInfo] :: History -> BreakInfo
[historyEnclosingDecls] :: History -> [String]

-- | Run a statement in the current interactive context.
execStmt :: GhcMonad m => String -> ExecOptions -> m ExecResult

-- | Like <a>execStmt</a>, but takes a parsed statement as argument. Useful
--   when doing preprocessing on the AST before execution, e.g. in GHCi
--   (see GHCi.UI.runStmt).
execStmt' :: GhcMonad m => GhciLStmt GhcPs -> String -> ExecOptions -> m ExecResult
data ExecOptions
ExecOptions :: SingleStep -> String -> Int -> (ForeignHValue -> EvalExpr ForeignHValue) -> ExecOptions

-- | stepping mode
[execSingleStep] :: ExecOptions -> SingleStep

-- | filename (for errors)
[execSourceFile] :: ExecOptions -> String

-- | line number (for errors)
[execLineNumber] :: ExecOptions -> Int
[execWrap] :: ExecOptions -> ForeignHValue -> EvalExpr ForeignHValue

-- | default ExecOptions
execOptions :: ExecOptions
data ExecResult
ExecComplete :: Either SomeException [Name] -> Word64 -> ExecResult
[execResult] :: ExecResult -> Either SomeException [Name]
[execAllocation] :: ExecResult -> Word64
ExecBreak :: [Name] -> Maybe BreakInfo -> ExecResult
[breakNames] :: ExecResult -> [Name]
[breakInfo] :: ExecResult -> Maybe BreakInfo
resumeExec :: GhcMonad m => (SrcSpan -> Bool) -> SingleStep -> Maybe Int -> m ExecResult
runDecls :: GhcMonad m => String -> m [Name]

-- | Run some declarations and return any user-visible names that were
--   brought into scope.
runDeclsWithLocation :: GhcMonad m => String -> Int -> String -> m [Name]

-- | Like <a>runDeclsWithLocation</a>, but takes parsed declarations as
--   argument. Useful when doing preprocessing on the AST before execution,
--   e.g. in GHCi (see GHCi.UI.runStmt).
runParsedDecls :: GhcMonad m => [LHsDecl GhcPs] -> m [Name]
parseImportDecl :: GhcMonad m => String -> m (ImportDecl GhcPs)
data SingleStep
RunToCompletion :: SingleStep
SingleStep :: SingleStep
RunAndLogSteps :: SingleStep
abandon :: GhcMonad m => m Bool
abandonAll :: GhcMonad m => m Bool
getResumeContext :: GhcMonad m => m [Resume]
getHistorySpan :: HscEnv -> History -> SrcSpan
getModBreaks :: HomeModInfo -> ModBreaks
getHistoryModule :: History -> Module
setupBreakpoint :: GhcMonad m => HscEnv -> BreakInfo -> Int -> m ()
back :: GhcMonad m => Int -> m ([Name], Int, SrcSpan, String)
forward :: GhcMonad m => Int -> m ([Name], Int, SrcSpan, String)

-- | Set the interactive evaluation context.
--   
--   (setContext imports) sets the ic_imports field (which in turn
--   determines what is in scope at the prompt) to <tt>imports</tt>, and
--   constructs the ic_rn_glb_env environment to reflect it.
--   
--   We retain in scope all the things defined at the prompt, and kept in
--   ic_tythings. (Indeed, they shadow stuff from ic_imports.)
setContext :: GhcMonad m => [InteractiveImport] -> m ()

-- | Get the interactive evaluation context, consisting of a pair of the
--   set of modules from which we take the full top-level scope, and the
--   set of modules from which we take just the exports respectively.
getContext :: GhcMonad m => m [InteractiveImport]

-- | Returns all names in scope in the current interactive context
getNamesInScope :: GhcMonad m => m [Name]

-- | Returns all <a>RdrName</a>s in scope in the current interactive
--   context, excluding any that are internally-generated.
getRdrNamesInScope :: GhcMonad m => m [RdrName]

-- | Returns <tt>True</tt> if the specified module is interpreted, and
--   hence has its full top-level scope available.
moduleIsInterpreted :: GhcMonad m => Module -> m Bool

-- | Looks up an identifier in the current interactive context (for :info)
--   Filter the instances by the ones whose tycons (or clases resp) are in
--   scope (qualified or otherwise). Otherwise we list a whole lot too
--   many! The exact choice of which ones to show, and which to hide, is a
--   judgement call. (see #1581)
getInfo :: GhcMonad m => Bool -> Name -> m (Maybe (TyThing, Fixity, [ClsInst], [FamInst], SDoc))

-- | Get the type of an expression Returns the type as described by
--   <a>TcRnExprMode</a>
exprType :: GhcMonad m => TcRnExprMode -> String -> m Type

-- | Get the kind of a type
typeKind :: GhcMonad m => Bool -> String -> m (Type, Kind)

-- | Parses a string as an identifier, and returns the list of <a>Name</a>s
--   that the identifier can refer to in the current interactive context.
parseName :: GhcMonad m => String -> m [Name]
parseInstanceHead :: GhcMonad m => String -> m Type
getInstancesForType :: GhcMonad m => Type -> m [ClsInst]
getDocs :: GhcMonad m => Name -> m (Either GetDocsFailure (Maybe HsDocString, IntMap HsDocString))

-- | Failure modes for <a>getDocs</a>.
data GetDocsFailure

-- | <a>nameModule_maybe</a> returned <a>Nothing</a>.
NameHasNoModule :: Name -> GetDocsFailure

-- | This is probably because the module was loaded without
--   <tt>-haddock</tt>, but it's also possible that the entire module
--   contains no documentation.
NoDocsInIface :: Module -> Bool -> GetDocsFailure

-- | The <a>Name</a> was defined interactively.
InteractiveName :: GetDocsFailure
showModule :: GhcMonad m => ModSummary -> m String
moduleIsBootOrNotObjectLinkable :: GhcMonad m => ModSummary -> m Bool

-- | Parse an expression, the parsed expression can be further processed
--   and passed to compileParsedExpr.
parseExpr :: GhcMonad m => String -> m (LHsExpr GhcPs)
compileParsedExpr :: GhcMonad m => LHsExpr GhcPs -> m HValue

-- | Compile an expression, run it, and deliver the resulting HValue.
compileExpr :: GhcMonad m => String -> m HValue

-- | Compile an expression, run it and return the result as a Dynamic.
dynCompileExpr :: GhcMonad m => String -> m Dynamic

-- | Compile an expression, run it, and deliver the resulting HValue.
compileExprRemote :: GhcMonad m => String -> m ForeignHValue

-- | Compile a parsed expression (before renaming), run it, and deliver the
--   resulting HValue.
compileParsedExprRemote :: GhcMonad m => LHsExpr GhcPs -> m ForeignHValue
data Term
Term :: RttiType -> Either String DataCon -> ForeignHValue -> [Term] -> Term
[ty] :: Term -> RttiType
[dc] :: Term -> Either String DataCon
[val] :: Term -> ForeignHValue
[subTerms] :: Term -> [Term]
Prim :: RttiType -> [Word] -> Term
[ty] :: Term -> RttiType
[valRaw] :: Term -> [Word]
Suspension :: ClosureType -> RttiType -> ForeignHValue -> Maybe Name -> Term
[ctype] :: Term -> ClosureType
[ty] :: Term -> RttiType
[val] :: Term -> ForeignHValue
[bound_to] :: Term -> Maybe Name
NewtypeWrap :: RttiType -> Either String DataCon -> Term -> Term
[ty] :: Term -> RttiType
[dc] :: Term -> Either String DataCon
[wrapped_term] :: Term -> Term
RefWrap :: RttiType -> Term -> Term
[ty] :: Term -> RttiType
[wrapped_term] :: Term -> Term
obtainTermFromId :: HscEnv -> Int -> Bool -> Id -> IO Term
obtainTermFromVal :: HscEnv -> Int -> Bool -> Type -> a -> IO Term
reconstructType :: HscEnv -> Int -> Id -> IO (Maybe Type)
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Eval.GetDocsFailure

module GHC.Driver.Pipeline
oneShot :: HscEnv -> Phase -> [(String, Maybe Phase)] -> IO ()
compileFile :: HscEnv -> Phase -> (FilePath, Maybe Phase) -> IO FilePath

-- | Just preprocess a file, put the result in a temp. file (used by the
--   compilation manager during the summary phase).
--   
--   We return the augmented DynFlags, because they contain the result of
--   slurping in the OPTIONS pragmas
preprocess :: HscEnv -> FilePath -> Maybe InputFileBuffer -> Maybe Phase -> IO (Either ErrorMessages (DynFlags, FilePath))

-- | Compile
--   
--   Compile a single module, under the control of the compilation manager.
--   
--   This is the interface between the compilation manager and the compiler
--   proper (hsc), where we deal with tedious details like reading the
--   OPTIONS pragma from the source file, converting the C or assembly that
--   GHC produces into an object file, and compiling FFI stub files.
--   
--   NB. No old interface can also mean that the source has changed.
compileOne :: HscEnv -> ModSummary -> Int -> Int -> Maybe ModIface -> Maybe Linkable -> SourceModified -> IO HomeModInfo
compileOne' :: Maybe TcGblEnv -> Maybe Messager -> HscEnv -> ModSummary -> Int -> Int -> Maybe ModIface -> Maybe Linkable -> SourceModified -> IO HomeModInfo
link :: GhcLink -> Logger -> TmpFs -> Hooks -> DynFlags -> UnitEnv -> Bool -> HomePackageTable -> IO SuccessFlag
data PhasePlus
RealPhase :: Phase -> PhasePlus
HscOut :: HscSource -> ModuleName -> HscStatus -> PhasePlus
newtype CompPipeline a
P :: (PipeEnv -> PipeState -> IO (PipeState, a)) -> CompPipeline a
[unP] :: CompPipeline a -> PipeEnv -> PipeState -> IO (PipeState, a)
data PipeEnv
PipeEnv :: Phase -> String -> String -> String -> PipelineOutput -> PipeEnv

-- | Stop just before this phase
[stop_phase] :: PipeEnv -> Phase

-- | basename of original input source
[src_filename] :: PipeEnv -> String

-- | basename of original input source
[src_basename] :: PipeEnv -> String

-- | its extension
[src_suffix] :: PipeEnv -> String

-- | says where to put the pipeline output
[output_spec] :: PipeEnv -> PipelineOutput
data PipeState
PipeState :: HscEnv -> Maybe ModLocation -> [FilePath] -> Maybe ModIface -> PipeState

-- | only the DynFlags and the Plugins change in the HscEnv. The DynFlags
--   change at various points, for example when we read the OPTIONS_GHC
--   pragmas in the Cpp phase.
[hsc_env] :: PipeState -> HscEnv

-- | the ModLocation. This is discovered during compilation, in the Hsc
--   phase where we read the module header.
[maybe_loc] :: PipeState -> Maybe ModLocation

-- | additional object files resulting from compiling foreign code. They
--   come from two sources: foreign stubs, and add{C,Cxx,Objc,Objcxx}File
--   from template haskell
[foreign_os] :: PipeState -> [FilePath]

-- | Interface generated by HscOut phase. Only available after the phase
--   runs.
[iface] :: PipeState -> Maybe ModIface

-- | Computes the next output filename after we run <tt>next_phase</tt>.
--   Like <a>getOutputFilename</a>, but it operates in the
--   <a>CompPipeline</a> monad (which specifies all of the ambient
--   information.)
phaseOutputFilename :: Phase -> CompPipeline FilePath

-- | Computes the next output filename for something in the compilation
--   pipeline. This is controlled by several variables:
--   
--   <ol>
--   <li><a>Phase</a>: the last phase to be run (e.g. <tt>stopPhase</tt>).
--   This is used to tell if we're in the last phase or not, because in
--   that case flags like <tt>-o</tt> may be important.</li>
--   <li><a>PipelineOutput</a>: is this intended to be a <a>Temporary</a>
--   or <a>Persistent</a> build output? Temporary files just go in a fresh
--   temporary name.</li>
--   <li><a>String</a>: what was the basename of the original input
--   file?</li>
--   <li><a>DynFlags</a>: the obvious thing</li>
--   <li><a>Phase</a>: the phase we want to determine the output filename
--   of.</li>
--   <li><tt>Maybe ModLocation</tt>: the <a>ModLocation</a> of the module
--   we're compiling; this can be used to override the default output of an
--   object file. (TODO: do we actually need this?)</li>
--   </ol>
getOutputFilename :: Logger -> TmpFs -> Phase -> PipelineOutput -> String -> DynFlags -> Phase -> Maybe ModLocation -> IO FilePath
getPipeState :: CompPipeline PipeState
getPipeEnv :: CompPipeline PipeEnv

-- | What phase to run after one of the backend code generators has run
hscPostBackendPhase :: HscSource -> Backend -> Phase
getLocation :: HscSource -> ModuleName -> CompPipeline ModLocation
setModLocation :: ModLocation -> CompPipeline ()
setDynFlags :: DynFlags -> CompPipeline ()

-- | Each phase in the pipeline returns the next phase to execute, and the
--   name of the file in which the output was placed.
--   
--   We must do things dynamically this way, because we often don't know
--   what the rest of the phases will be until part-way through the
--   compilation: for example, an {-# OPTIONS -fasm #-} at the beginning of
--   a source file can change the latter stages of the pipeline from taking
--   the LLVM route to using the native code generator.
runPhase :: PhasePlus -> FilePath -> CompPipeline (PhasePlus, FilePath)

-- | Run CPP
--   
--   UnitState is needed to compute MIN_VERSION macros
doCpp :: Logger -> TmpFs -> DynFlags -> UnitEnv -> Bool -> FilePath -> FilePath -> IO ()
linkingNeeded :: Logger -> DynFlags -> UnitEnv -> Bool -> [Linkable] -> [UnitId] -> IO Bool
checkLinkInfo :: Logger -> DynFlags -> UnitEnv -> [UnitId] -> FilePath -> IO Bool
writeInterfaceOnlyMode :: DynFlags -> Bool

module GHC.Driver.Make

-- | Perform a dependency analysis starting from the current targets and
--   update the session with the new module graph.
--   
--   Dependency analysis entails parsing the <tt>import</tt> directives and
--   may therefore require running certain preprocessors.
--   
--   Note that each <a>ModSummary</a> in the module graph caches its
--   <a>DynFlags</a>. These <a>DynFlags</a> are determined by the
--   <i>current</i> session <a>DynFlags</a> and the <tt>OPTIONS</tt> and
--   <tt>LANGUAGE</tt> pragmas of the parsed module. Thus if you want
--   changes to the <a>DynFlags</a> to take effect you need to call this
--   function again. In case of errors, just throw them.
depanal :: GhcMonad m => [ModuleName] -> Bool -> m ModuleGraph

-- | Perform dependency analysis like in <a>depanal</a>. In case of errors,
--   the errors and an empty module graph are returned.
depanalE :: GhcMonad m => [ModuleName] -> Bool -> m (ErrorMessages, ModuleGraph)

-- | Perform dependency analysis like <a>depanal</a> but return a partial
--   module graph even in the face of problems with some modules.
--   
--   Modules which have parse errors in the module header, failing
--   preprocessors or other issues preventing them from being summarised
--   will simply be absent from the returned module graph.
--   
--   Unlike <a>depanal</a> this function will not update
--   <a>hsc_mod_graph</a> with the new module graph.
depanalPartial :: GhcMonad m => [ModuleName] -> Bool -> m (ErrorMessages, ModuleGraph)

-- | Try to load the program. See <a>LoadHowMuch</a> for the different
--   modes.
--   
--   This function implements the core of GHC's <tt>--make</tt> mode. It
--   preprocesses, compiles and loads the specified modules, avoiding
--   re-compilation wherever possible. Depending on the backend (see
--   <a>backend</a> field) compiling and loading may result in files being
--   created on disk.
--   
--   Calls the <a>defaultWarnErrLogger</a> after each compiling each
--   module, whether successful or not.
--   
--   If errors are encountered during dependency analysis, the module
--   <a>depanalE</a> returns together with the errors an empty ModuleGraph.
--   After processing this empty ModuleGraph, the errors of depanalE are
--   thrown. All other errors are reported using the
--   <a>defaultWarnErrLogger</a>.
load :: GhcMonad m => LoadHowMuch -> m SuccessFlag

-- | Generalized version of <a>load</a> which also supports a custom
--   <a>Messager</a> (for reporting progress) and <a>ModuleGraph</a>
--   (generally produced by calling <a>depanal</a>.
load' :: GhcMonad m => LoadHowMuch -> Maybe Messager -> ModuleGraph -> m SuccessFlag

-- | Describes which modules of the module graph need to be loaded.
data LoadHowMuch

-- | Load all targets and its dependencies.
LoadAllTargets :: LoadHowMuch

-- | Load only the given module and its dependencies.
LoadUpTo :: ModuleName -> LoadHowMuch

-- | Load only the dependencies of the given module, but not the module
--   itself.
LoadDependenciesOf :: ModuleName -> LoadHowMuch

-- | Collect the instantiations of dependencies to create
--   <a>InstantiationNode</a> work graph nodes. These are used to represent
--   the type checking that is done after all the free holes (sigs in
--   current package) relevant to that instantiation are compiled. This is
--   necessary to catch some instantiation errors.
--   
--   In the future, perhaps more of the work of instantiation could be
--   moved here, instead of shoved in with the module compilation nodes.
--   That could simplify backpack, and maybe hs-boot too.
instantiationNodes :: UnitState -> [ModuleGraphNode]

-- | Downsweep (dependency analysis)
--   
--   Chase downwards from the specified root set, returning summaries for
--   all home modules encountered. Only follow source-import links.
--   
--   We pass in the previous collection of summaries, which is used as a
--   cache to avoid recalculating a module summary if the source is
--   unchanged.
--   
--   The returned list of [ModSummary] nodes has one node for each
--   home-package module, plus one for any hs-boot files. The imports of
--   these nodes are all there, including the imports of non-home-package
--   modules.
downsweep :: HscEnv -> [ExtendedModSummary] -> [ModuleName] -> Bool -> IO [Either ErrorMessages ExtendedModSummary]

-- | Topological sort of the module graph
--   
--   Calculate SCCs of the module graph, possibly dropping the hi-boot
--   nodes The resulting list of strongly-connected-components is in
--   topologically sorted order, starting with the module(s) at the bottom
--   of the dependency graph (ie compile them first) and ending with the
--   ones at the top.
--   
--   Drop hi-boot nodes (first boolean arg)?
--   
--   <ul>
--   <li><tt>False</tt>: treat the hi-boot summaries as nodes of the graph,
--   so the graph must be acyclic</li>
--   <li><tt>True</tt>: eliminate the hi-boot nodes, and instead pretend
--   the a source-import of Foo is an import of Foo The resulting graph has
--   no hi-boot nodes, but can be cyclic</li>
--   </ul>
topSortModuleGraph :: Bool -> ModuleGraph -> Maybe ModuleName -> [SCC ModuleGraphNode]

-- | Like <a>ms_home_imps</a>, but for SOURCE imports.
ms_home_srcimps :: ModSummary -> [Located ModuleName]

-- | All of the (possibly) home module imports from a <a>ModSummary</a>;
--   that is to say, each of these module names could be a home import if
--   an appropriately named file existed. (This is in contrast to package
--   qualified imports, which are guaranteed not to be home imports.)
ms_home_imps :: ModSummary -> [Located ModuleName]
summariseModule :: HscEnv -> ModNodeMap ExtendedModSummary -> IsBootInterface -> Located ModuleName -> Bool -> Maybe (StringBuffer, UTCTime) -> [ModuleName] -> IO (Maybe (Either ErrorMessages ExtendedModSummary))

-- | Tests if an <a>HscSource</a> is a boot file, primarily for
--   constructing elements of <a>BuildModule</a>. We conflate signatures
--   and modules because they are bound in the same namespace; only boot
--   interfaces can be disambiguated with `import {-# SOURCE #-}`.
hscSourceToIsBoot :: HscSource -> IsBootInterface

-- | <a>findExtraSigImports</a>, but in a convenient form for
--   <a>GHC.Driver.Make</a> and <a>GHC.Tc.Module</a>.
findExtraSigImports :: HscEnv -> HscSource -> ModuleName -> IO [(Maybe FastString, Located ModuleName)]

-- | Like <tt>implicitRequirements'</tt>, but returns either the module
--   name, if it is a free hole, or the instantiated unit the imported
--   module is from, so that that instantiated unit can be processed and
--   via the batch mod graph (rather than a transitive closure done here)
--   all the free holes are still reachable.
implicitRequirementsShallow :: HscEnv -> [(Maybe FastString, Located ModuleName)] -> IO ([ModuleName], [InstantiatedUnit])
noModError :: HscEnv -> SrcSpan -> ModuleName -> FindResult -> MsgEnvelope DecoratedSDoc
cyclicModuleErr :: [ModuleGraphNode] -> SDoc
moduleGraphNodes :: Bool -> [ModuleGraphNode] -> (Graph SummaryNode, NodeKey -> Maybe SummaryNode)
type SummaryNode = Node Int ModuleGraphNode

-- | Indicates whether a module name is referring to a boot interface
--   (hs-boot file) or regular module (hs file). We need to treat boot
--   modules specially when building compilation graphs, since they break
--   cycles. Regular source files and signature files are treated
--   equivalently.
data IsBootInterface
NotBoot :: IsBootInterface
IsBoot :: IsBootInterface
newtype ModNodeMap a
ModNodeMap :: Map ModNodeKey a -> ModNodeMap a
[unModNodeMap] :: ModNodeMap a -> Map ModNodeKey a
emptyModNodeMap :: ModNodeMap a
modNodeMapElems :: ModNodeMap a -> [a]
modNodeMapLookup :: ModNodeKey -> ModNodeMap a -> Maybe a
modNodeMapInsert :: ModNodeKey -> a -> ModNodeMap a -> ModNodeMap a
instance GHC.Classes.Ord GHC.Driver.Make.BuildModule
instance GHC.Classes.Eq GHC.Driver.Make.BuildModule
instance Data.Foldable.Foldable GHC.Driver.Make.ModNodeMap
instance Data.Traversable.Traversable GHC.Driver.Make.ModNodeMap
instance GHC.Base.Functor GHC.Driver.Make.ModNodeMap
instance GHC.Classes.Ord GHC.Driver.Make.NodeKey
instance GHC.Classes.Eq GHC.Driver.Make.NodeKey
instance Data.Foldable.Foldable GHC.Driver.Make.NodeMap
instance Data.Traversable.Traversable GHC.Driver.Make.NodeMap
instance GHC.Base.Functor GHC.Driver.Make.NodeMap

module GHC

-- | Install some default exception handlers and run the inner computation.
--   Unless you want to handle exceptions yourself, you should wrap this
--   around the top level of your program. The default handlers output the
--   error message(s) to stderr and exit cleanly.
defaultErrorHandler :: ExceptionMonad m => FatalMessager -> FlushOut -> m a -> m a

-- | This function is no longer necessary, cleanup is now done by
--   runGhc/runGhcT.

-- | <i>Deprecated: Cleanup is now done by runGhc/runGhcT</i>
defaultCleanupHandler :: ExceptionMonad m => DynFlags -> m a -> m a
prettyPrintGhcErrors :: ExceptionMonad m => DynFlags -> m a -> m a

-- | Temporarily install standard signal handlers for catching ^C, which
--   just throw an exception in the current thread.
withSignalHandlers :: ExceptionMonad m => m a -> m a
withCleanupSession :: GhcMonad m => m a -> m a

-- | A minimal implementation of a <a>GhcMonad</a>. If you need a custom
--   monad, e.g., to maintain additional state consider wrapping this monad
--   or using <a>GhcT</a>.
data Ghc a

-- | A monad transformer to add GHC specific features to another monad.
--   
--   Note that the wrapped monad must support IO and handling of
--   exceptions.
data GhcT m a

-- | A monad that has all the features needed by GHC API calls.
--   
--   In short, a GHC monad
--   
--   <ul>
--   <li>allows embedding of IO actions,</li>
--   <li>can log warnings,</li>
--   <li>allows handling of (extensible) exceptions, and</li>
--   <li>maintains a current session.</li>
--   </ul>
--   
--   If you do not use <a>Ghc</a> or <a>GhcT</a>, make sure to call
--   <a>initGhcMonad</a> before any call to the GHC API functions can
--   occur.
class (Functor m, ExceptionMonad m, HasDynFlags m, HasLogger m) => GhcMonad m
getSession :: GhcMonad m => m HscEnv
setSession :: GhcMonad m => HscEnv -> m ()

-- | HscEnv is like <a>Session</a>, except that some of the fields are
--   immutable. An HscEnv is used to compile a single module from plain
--   Haskell source code (after preprocessing) to either C, assembly or
--   C--. It's also used to store the dynamic linker state to allow for
--   multiple linkers in the same address space. Things like the module
--   graph don't change during a single compilation.
--   
--   Historical note: "hsc" used to be the name of the compiler binary,
--   when there was a separate driver and compiler. To compile a single
--   module, the driver would invoke hsc on the source code... so nowadays
--   we think of hsc as the layer of the compiler that deals with compiling
--   a single module.
data HscEnv

-- | Run function for the <a>Ghc</a> monad.
--   
--   It initialises the GHC session and warnings via <a>initGhcMonad</a>.
--   Each call to this function will create a new session which should not
--   be shared among several threads.
--   
--   Any errors not handled inside the <a>Ghc</a> action are propagated as
--   IO exceptions.
runGhc :: Maybe FilePath -> Ghc a -> IO a

-- | Run function for <a>GhcT</a> monad transformer.
--   
--   It initialises the GHC session and warnings via <a>initGhcMonad</a>.
--   Each call to this function will create a new session which should not
--   be shared among several threads.
runGhcT :: ExceptionMonad m => Maybe FilePath -> GhcT m a -> m a

-- | Initialise a GHC session.
--   
--   If you implement a custom <a>GhcMonad</a> you must call this function
--   in the monad run function. It will initialise the session variable and
--   clear all warnings.
--   
--   The first argument should point to the directory where GHC's library
--   files reside. More precisely, this should be the output of <tt>ghc
--   --print-libdir</tt> of the version of GHC the module using this API is
--   compiled with. For portability, you should use the <tt>ghc-paths</tt>
--   package, available at
--   <a>http://hackage.haskell.org/package/ghc-paths</a>.
initGhcMonad :: GhcMonad m => Maybe FilePath -> m ()

-- | Print the error message and all warnings. Useful inside exception
--   handlers. Clears warnings after printing.
printException :: GhcMonad m => SourceError -> m ()

-- | Perform the given action and call the exception handler if the action
--   throws a <a>SourceError</a>. See <a>SourceError</a> for more
--   information.
handleSourceError :: MonadCatch m => (SourceError -> m a) -> m a -> m a

-- | Determines whether a set of modules requires Template Haskell or Quasi
--   Quotes
--   
--   Note that if the session's <a>DynFlags</a> enabled Template Haskell
--   when <tt>depanal</tt> was called, then each module in the returned
--   module graph will have Template Haskell enabled whether it is actually
--   needed or not.
needsTemplateHaskellOrQQ :: ModuleGraph -> Bool

-- | Contains not only a collection of <a>GeneralFlag</a>s but also a
--   plethora of information relating to the compilation of a single file
--   or GHC session
data DynFlags
DynFlags :: GhcMode -> GhcLink -> !Backend -> {-# UNPACK #-} !GhcNameVersion -> {-# UNPACK #-} !FileSettings -> Platform -> {-# UNPACK #-} !ToolSettings -> {-# UNPACK #-} !PlatformMisc -> [(String, String)] -> LlvmConfig -> Int -> Int -> Int -> Int -> Int -> Maybe String -> Maybe String -> [Int] -> Maybe Int -> Bool -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Int -> Int -> Int -> Maybe Int -> Maybe Int -> Int -> Word -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Bool -> Maybe Int -> Int -> [FilePath] -> ModuleName -> Maybe String -> IntWithInf -> IntWithInf -> UnitId -> Maybe UnitId -> [(ModuleName, Module)] -> Ways -> Maybe (String, Int) -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> String -> String -> String -> String -> IORef Bool -> String -> String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> DynLibLoader -> !Bool -> Maybe FilePath -> Maybe FilePath -> [Option] -> IncludeSpecs -> [String] -> [String] -> [String] -> Maybe String -> RtsOptsEnabled -> Bool -> String -> [ModuleName] -> [(ModuleName, String)] -> [String] -> FilePath -> Bool -> Bool -> [ModuleName] -> [String] -> [PackageDBFlag] -> [IgnorePackageFlag] -> [PackageFlag] -> [PackageFlag] -> [TrustFlag] -> Maybe FilePath -> EnumSet DumpFlag -> EnumSet GeneralFlag -> EnumSet WarningFlag -> EnumSet WarningFlag -> Maybe Language -> SafeHaskellMode -> Bool -> Bool -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> [OnOff Extension] -> EnumSet Extension -> !UnfoldingOpts -> Int -> Int -> FlushOut -> FlushErr -> Maybe FilePath -> Maybe String -> [String] -> Int -> Int -> Bool -> OverridingBool -> Bool -> Scheme -> ProfAuto -> [CallerCcFilter] -> Maybe String -> IORef (ModuleEnv Int) -> Maybe SseVersion -> Maybe BmiVersion -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> IORef (Maybe LinkerInfo) -> IORef (Maybe CompilerInfo) -> Int -> Int -> Int -> Bool -> Maybe Int -> Word -> Int -> Weights -> DynFlags
[ghcMode] :: DynFlags -> GhcMode
[ghcLink] :: DynFlags -> GhcLink

-- | The backend to use (if any).
--   
--   Whenever you change the backend, also make sure to set <a>ghcLink</a>
--   to something sensible.
--   
--   <a>NoBackend</a> can be used to avoid generating any output, however,
--   note that:
--   
--   <ul>
--   <li>If a program uses Template Haskell the typechecker may need to run
--   code from an imported module. To facilitate this, code generation is
--   enabled for modules imported by modules that use template haskell,
--   using the default backend for the platform. See Note [-fno-code
--   mode].</li>
--   </ul>
[backend] :: DynFlags -> !Backend
[ghcNameVersion] :: DynFlags -> {-# UNPACK #-} !GhcNameVersion
[fileSettings] :: DynFlags -> {-# UNPACK #-} !FileSettings
[targetPlatform] :: DynFlags -> Platform
[toolSettings] :: DynFlags -> {-# UNPACK #-} !ToolSettings
[platformMisc] :: DynFlags -> {-# UNPACK #-} !PlatformMisc
[rawSettings] :: DynFlags -> [(String, String)]

-- | N.B. It's important that this field is lazy since we load the LLVM
--   configuration lazily. See Note [LLVM Configuration] in
--   <a>GHC.SysTools</a>.
[llvmConfig] :: DynFlags -> LlvmConfig

-- | Verbosity level: see Note [Verbosity levels]
[verbosity] :: DynFlags -> Int

-- | Optimisation level
[optLevel] :: DynFlags -> Int

-- | How much debug information to produce
[debugLevel] :: DynFlags -> Int

-- | Number of simplifier phases
[simplPhases] :: DynFlags -> Int

-- | Max simplifier iterations
[maxSimplIterations] :: DynFlags -> Int
[ruleCheck] :: DynFlags -> Maybe String

-- | A prefix to report inlining decisions about
[inlineCheck] :: DynFlags -> Maybe String

-- | Additional demand analysis
[strictnessBefore] :: DynFlags -> [Int]

-- | The number of modules to compile in parallel in --make mode, where
--   Nothing ==&gt; compile as many in parallel as there are CPUs.
[parMakeCount] :: DynFlags -> Maybe Int

-- | Enable RTS timing statistics?
[enableTimeStats] :: DynFlags -> Bool

-- | The heap size to set.
[ghcHeapSize] :: DynFlags -> Maybe Int

-- | Maximum number of bindings from the type envt to show in type error
--   messages
[maxRelevantBinds] :: DynFlags -> Maybe Int

-- | Maximum number of hole fits to show in typed hole error messages
[maxValidHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of refinement hole fits to show in typed hole error
--   messages
[maxRefHoleFits] :: DynFlags -> Maybe Int

-- | Maximum level of refinement for refinement hole fits in typed hole
--   error messages
[refLevelHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of unmatched patterns to show in non-exhaustiveness
--   warnings
[maxUncoveredPatterns] :: DynFlags -> Int

-- | Soft limit on the number of models the pattern match checker checks a
--   pattern against. A safe guard against exponential blow-up.
[maxPmCheckModels] :: DynFlags -> Int

-- | Multiplier for simplifier ticks
[simplTickFactor] :: DynFlags -> Int

-- | Threshold for SpecConstr
[specConstrThreshold] :: DynFlags -> Maybe Int

-- | Max number of specialisations for any one function
[specConstrCount] :: DynFlags -> Maybe Int

-- | Max number of specialisations for recursive types Not optional;
--   otherwise ForceSpecConstr can diverge.
[specConstrRecursive] :: DynFlags -> Int

-- | Binary literals (e.g. strings) whose size is above this threshold will
--   be dumped in a binary file by the assembler code generator (0 to
--   disable)
[binBlobThreshold] :: DynFlags -> Word

-- | Threshold for LiberateCase
[liberateCaseThreshold] :: DynFlags -> Maybe Int

-- | Arg count for lambda floating See <a>FloatOutSwitches</a>
[floatLamArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a recursive function.
[liftLamsRecArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a non-recursive
--   function.
[liftLamsNonRecArgs] :: DynFlags -> Maybe Int

-- | Lambda lift even when this turns a known call into an unknown call.
[liftLamsKnown] :: DynFlags -> Bool

-- | Align Cmm functions at this boundary or use default.
[cmmProcAlignment] :: DynFlags -> Maybe Int

-- | Simplification history size
[historySize] :: DynFlags -> Int
[importPaths] :: DynFlags -> [FilePath]
[mainModuleNameIs] :: DynFlags -> ModuleName
[mainFunIs] :: DynFlags -> Maybe String

-- | Typechecker maximum stack depth
[reductionDepth] :: DynFlags -> IntWithInf

-- | Number of iterations in the constraints solver Typically only 1 is
--   needed
[solverIterations] :: DynFlags -> IntWithInf

-- | Target home unit-id
[homeUnitId_] :: DynFlags -> UnitId

-- | Id of the unit to instantiate
[homeUnitInstanceOf_] :: DynFlags -> Maybe UnitId

-- | Module instantiations
[homeUnitInstantiations_] :: DynFlags -> [(ModuleName, Module)]

-- | Target way flags from the command line
[targetWays_] :: DynFlags -> Ways
[splitInfo] :: DynFlags -> Maybe (String, Int)
[objectDir] :: DynFlags -> Maybe String
[dylibInstallName] :: DynFlags -> Maybe String
[hiDir] :: DynFlags -> Maybe String
[hieDir] :: DynFlags -> Maybe String
[stubDir] :: DynFlags -> Maybe String
[dumpDir] :: DynFlags -> Maybe String
[objectSuf_] :: DynFlags -> String
[hcSuf] :: DynFlags -> String
[hiSuf_] :: DynFlags -> String
[hieSuf] :: DynFlags -> String
[dynamicTooFailed] :: DynFlags -> IORef Bool
[dynObjectSuf_] :: DynFlags -> String
[dynHiSuf_] :: DynFlags -> String
[outputFile_] :: DynFlags -> Maybe String
[dynOutputFile_] :: DynFlags -> Maybe String
[outputHi] :: DynFlags -> Maybe String
[dynOutputHi] :: DynFlags -> Maybe String
[dynLibLoader] :: DynFlags -> DynLibLoader

-- | Indicate if we are now generating dynamic output because of
--   -dynamic-too. This predicate is used to query the appropriate fields
--   (outputFile/dynOutputFile, ways, etc.)
[dynamicNow] :: DynFlags -> !Bool

-- | This is set by <a>runPipeline</a> or 'ghc.GHCi.UI.runStmt' based on
--   where its output is going.
[dumpPrefix] :: DynFlags -> Maybe FilePath

-- | Override the <a>dumpPrefix</a> set by <a>runPipeline</a> or
--   'ghc.GHCi.UI.runStmt'. Set by <tt>-ddump-file-prefix</tt>
[dumpPrefixForce] :: DynFlags -> Maybe FilePath
[ldInputs] :: DynFlags -> [Option]
[includePaths] :: DynFlags -> IncludeSpecs
[libraryPaths] :: DynFlags -> [String]
[frameworkPaths] :: DynFlags -> [String]
[cmdlineFrameworks] :: DynFlags -> [String]
[rtsOpts] :: DynFlags -> Maybe String
[rtsOptsEnabled] :: DynFlags -> RtsOptsEnabled
[rtsOptsSuggestions] :: DynFlags -> Bool

-- | Path to store the .mix files
[hpcDir] :: DynFlags -> String
[pluginModNames] :: DynFlags -> [ModuleName]
[pluginModNameOpts] :: DynFlags -> [(ModuleName, String)]

-- | the <tt>-ffrontend-opt</tt> flags given on the command line, in
--   *reverse* order that they're specified on the command line.
[frontendPluginOpts] :: DynFlags -> [String]
[depMakefile] :: DynFlags -> FilePath
[depIncludePkgDeps] :: DynFlags -> Bool
[depIncludeCppDeps] :: DynFlags -> Bool
[depExcludeMods] :: DynFlags -> [ModuleName]
[depSuffixes] :: DynFlags -> [String]

-- | The <tt>-package-db</tt> flags given on the command line, In *reverse*
--   order that they're specified on the command line. This is intended to
--   be applied with the list of "initial" package databases derived from
--   <tt>GHC_PACKAGE_PATH</tt>; see <tt>getUnitDbRefs</tt>.
[packageDBFlags] :: DynFlags -> [PackageDBFlag]

-- | The <tt>-ignore-package</tt> flags from the command line. In *reverse*
--   order that they're specified on the command line.
[ignorePackageFlags] :: DynFlags -> [IgnorePackageFlag]

-- | The <tt>-package</tt> and <tt>-hide-package</tt> flags from the
--   command-line. In *reverse* order that they're specified on the command
--   line.
[packageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-plugin-package-id</tt> flags from command line. In *reverse*
--   order that they're specified on the command line.
[pluginPackageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-trust</tt> and <tt>-distrust</tt> flags. In *reverse* order
--   that they're specified on the command line.
[trustFlags] :: DynFlags -> [TrustFlag]

-- | Filepath to the package environment file (if overriding default)
[packageEnv] :: DynFlags -> Maybe FilePath
[dumpFlags] :: DynFlags -> EnumSet DumpFlag
[generalFlags] :: DynFlags -> EnumSet GeneralFlag
[warningFlags] :: DynFlags -> EnumSet WarningFlag
[fatalWarningFlags] :: DynFlags -> EnumSet WarningFlag
[language] :: DynFlags -> Maybe Language

-- | Safe Haskell mode
[safeHaskell] :: DynFlags -> SafeHaskellMode
[safeInfer] :: DynFlags -> Bool
[safeInferred] :: DynFlags -> Bool
[thOnLoc] :: DynFlags -> SrcSpan
[newDerivOnLoc] :: DynFlags -> SrcSpan
[deriveViaOnLoc] :: DynFlags -> SrcSpan
[overlapInstLoc] :: DynFlags -> SrcSpan
[incoherentOnLoc] :: DynFlags -> SrcSpan
[pkgTrustOnLoc] :: DynFlags -> SrcSpan
[warnSafeOnLoc] :: DynFlags -> SrcSpan
[warnUnsafeOnLoc] :: DynFlags -> SrcSpan
[trustworthyOnLoc] :: DynFlags -> SrcSpan
[extensions] :: DynFlags -> [OnOff Extension]
[extensionFlags] :: DynFlags -> EnumSet Extension

-- | Unfolding control See Note [Discounts and thresholds] in
--   GHC.Core.Unfold
[unfoldingOpts] :: DynFlags -> !UnfoldingOpts
[maxWorkerArgs] :: DynFlags -> Int
[ghciHistSize] :: DynFlags -> Int
[flushOut] :: DynFlags -> FlushOut
[flushErr] :: DynFlags -> FlushErr
[ghcVersionFile] :: DynFlags -> Maybe FilePath
[haddockOptions] :: DynFlags -> Maybe String

-- | GHCi scripts specified by -ghci-script, in reverse order
[ghciScripts] :: DynFlags -> [String]
[pprUserLength] :: DynFlags -> Int
[pprCols] :: DynFlags -> Int
[useUnicode] :: DynFlags -> Bool
[useColor] :: DynFlags -> OverridingBool
[canUseColor] :: DynFlags -> Bool
[colScheme] :: DynFlags -> Scheme

-- | what kind of {-# SCC #-} to add automatically
[profAuto] :: DynFlags -> ProfAuto
[callerCcFilters] :: DynFlags -> [CallerCcFilter]
[interactivePrint] :: DynFlags -> Maybe String
[nextWrapperNum] :: DynFlags -> IORef (ModuleEnv Int)

-- | Machine dependent flags (-m&lt;blah&gt; stuff)
[sseVersion] :: DynFlags -> Maybe SseVersion
[bmiVersion] :: DynFlags -> Maybe BmiVersion
[avx] :: DynFlags -> Bool
[avx2] :: DynFlags -> Bool
[avx512cd] :: DynFlags -> Bool
[avx512er] :: DynFlags -> Bool
[avx512f] :: DynFlags -> Bool
[avx512pf] :: DynFlags -> Bool

-- | Run-time linker information (what options we need, etc.)
[rtldInfo] :: DynFlags -> IORef (Maybe LinkerInfo)

-- | Run-time compiler information
[rtccInfo] :: DynFlags -> IORef (Maybe CompilerInfo)

-- | Max size, in bytes, of inline array allocations.
[maxInlineAllocSize] :: DynFlags -> Int

-- | Only inline memcpy if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemcpyInsns] :: DynFlags -> Int

-- | Only inline memset if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemsetInsns] :: DynFlags -> Int

-- | Reverse the order of error messages in GHC/GHCi
[reverseErrors] :: DynFlags -> Bool

-- | Limit the maximum number of errors to show
[maxErrors] :: DynFlags -> Maybe Int

-- | Unique supply configuration for testing build determinism
[initialUnique] :: DynFlags -> Word
[uniqueIncrement] :: DynFlags -> Int

-- | Temporary: CFG Edge weights for fast iterations
[cfgWeights] :: DynFlags -> Weights

-- | Enumerates the simple on-or-off dynamic flags
data GeneralFlag

-- | Append dump output to files instead of stdout.
Opt_DumpToFile :: GeneralFlag
Opt_D_faststring_stats :: GeneralFlag
Opt_D_dump_minimal_imports :: GeneralFlag
Opt_DoCoreLinting :: GeneralFlag
Opt_DoLinearCoreLinting :: GeneralFlag
Opt_DoStgLinting :: GeneralFlag
Opt_DoCmmLinting :: GeneralFlag
Opt_DoAsmLinting :: GeneralFlag
Opt_DoAnnotationLinting :: GeneralFlag
Opt_DoBoundsChecking :: GeneralFlag
Opt_NoLlvmMangler :: GeneralFlag
Opt_FastLlvm :: GeneralFlag
Opt_NoTypeableBinds :: GeneralFlag
Opt_DistinctConstructorTables :: GeneralFlag
Opt_InfoTableMap :: GeneralFlag
Opt_WarnIsError :: GeneralFlag
Opt_ShowWarnGroups :: GeneralFlag
Opt_HideSourcePaths :: GeneralFlag
Opt_PrintExplicitForalls :: GeneralFlag
Opt_PrintExplicitKinds :: GeneralFlag
Opt_PrintExplicitCoercions :: GeneralFlag
Opt_PrintExplicitRuntimeReps :: GeneralFlag
Opt_PrintEqualityRelations :: GeneralFlag
Opt_PrintAxiomIncomps :: GeneralFlag
Opt_PrintUnicodeSyntax :: GeneralFlag
Opt_PrintExpandedSynonyms :: GeneralFlag
Opt_PrintPotentialInstances :: GeneralFlag
Opt_PrintTypecheckerElaboration :: GeneralFlag
Opt_CallArity :: GeneralFlag
Opt_Exitification :: GeneralFlag
Opt_Strictness :: GeneralFlag
Opt_LateDmdAnal :: GeneralFlag
Opt_KillAbsence :: GeneralFlag
Opt_KillOneShot :: GeneralFlag
Opt_FullLaziness :: GeneralFlag
Opt_FloatIn :: GeneralFlag
Opt_LateSpecialise :: GeneralFlag
Opt_Specialise :: GeneralFlag
Opt_SpecialiseAggressively :: GeneralFlag
Opt_CrossModuleSpecialise :: GeneralFlag
Opt_InlineGenerics :: GeneralFlag
Opt_InlineGenericsAggressively :: GeneralFlag
Opt_StaticArgumentTransformation :: GeneralFlag
Opt_CSE :: GeneralFlag
Opt_StgCSE :: GeneralFlag
Opt_StgLiftLams :: GeneralFlag
Opt_LiberateCase :: GeneralFlag
Opt_SpecConstr :: GeneralFlag
Opt_SpecConstrKeen :: GeneralFlag
Opt_DoLambdaEtaExpansion :: GeneralFlag
Opt_IgnoreAsserts :: GeneralFlag
Opt_DoEtaReduction :: GeneralFlag
Opt_CaseMerge :: GeneralFlag
Opt_CaseFolding :: GeneralFlag
Opt_UnboxStrictFields :: GeneralFlag
Opt_UnboxSmallStrictFields :: GeneralFlag
Opt_DictsCheap :: GeneralFlag
Opt_EnableRewriteRules :: GeneralFlag
Opt_EnableThSpliceWarnings :: GeneralFlag
Opt_RegsGraph :: GeneralFlag
Opt_RegsIterative :: GeneralFlag
Opt_PedanticBottoms :: GeneralFlag
Opt_LlvmTBAA :: GeneralFlag
Opt_LlvmFillUndefWithGarbage :: GeneralFlag
Opt_IrrefutableTuples :: GeneralFlag
Opt_CmmSink :: GeneralFlag
Opt_CmmStaticPred :: GeneralFlag
Opt_CmmElimCommonBlocks :: GeneralFlag
Opt_AsmShortcutting :: GeneralFlag
Opt_OmitYields :: GeneralFlag
Opt_FunToThunk :: GeneralFlag
Opt_DictsStrict :: GeneralFlag

-- | deprecated, no effect and behaviour is now default. Allowed switching
--   of a special demand transformer for dictionary selectors
Opt_DmdTxDictSel :: GeneralFlag
Opt_Loopification :: GeneralFlag

-- | Use the cfg based block layout algorithm.
Opt_CfgBlocklayout :: GeneralFlag

-- | Layout based on last instruction per block.
Opt_WeightlessBlocklayout :: GeneralFlag
Opt_CprAnal :: GeneralFlag
Opt_WorkerWrapper :: GeneralFlag
Opt_SolveConstantDicts :: GeneralFlag
Opt_AlignmentSanitisation :: GeneralFlag
Opt_CatchBottoms :: GeneralFlag
Opt_NumConstantFolding :: GeneralFlag
Opt_SimplPreInlining :: GeneralFlag
Opt_IgnoreInterfacePragmas :: GeneralFlag
Opt_OmitInterfacePragmas :: GeneralFlag
Opt_ExposeAllUnfoldings :: GeneralFlag
Opt_WriteInterface :: GeneralFlag
Opt_WriteHie :: GeneralFlag
Opt_AutoSccsOnIndividualCafs :: GeneralFlag
Opt_ProfCountEntries :: GeneralFlag
Opt_Pp :: GeneralFlag
Opt_ForceRecomp :: GeneralFlag
Opt_IgnoreOptimChanges :: GeneralFlag
Opt_IgnoreHpcChanges :: GeneralFlag
Opt_ExcessPrecision :: GeneralFlag
Opt_EagerBlackHoling :: GeneralFlag
Opt_NoHsMain :: GeneralFlag
Opt_SplitSections :: GeneralFlag
Opt_StgStats :: GeneralFlag
Opt_HideAllPackages :: GeneralFlag
Opt_HideAllPluginPackages :: GeneralFlag
Opt_PrintBindResult :: GeneralFlag
Opt_Haddock :: GeneralFlag
Opt_HaddockOptions :: GeneralFlag
Opt_BreakOnException :: GeneralFlag
Opt_BreakOnError :: GeneralFlag
Opt_PrintEvldWithShow :: GeneralFlag
Opt_PrintBindContents :: GeneralFlag
Opt_GenManifest :: GeneralFlag
Opt_EmbedManifest :: GeneralFlag
Opt_SharedImplib :: GeneralFlag
Opt_BuildingCabalPackage :: GeneralFlag
Opt_IgnoreDotGhci :: GeneralFlag
Opt_GhciSandbox :: GeneralFlag
Opt_GhciHistory :: GeneralFlag
Opt_GhciLeakCheck :: GeneralFlag
Opt_ValidateHie :: GeneralFlag
Opt_LocalGhciHistory :: GeneralFlag
Opt_NoIt :: GeneralFlag
Opt_HelpfulErrors :: GeneralFlag
Opt_DeferTypeErrors :: GeneralFlag
Opt_DeferTypedHoles :: GeneralFlag
Opt_DeferOutOfScopeVariables :: GeneralFlag

-- | <pre>
--   -fPIC
--   </pre>
Opt_PIC :: GeneralFlag

-- | <pre>
--   -fPIE
--   </pre>
Opt_PIE :: GeneralFlag

-- | <pre>
--   -pie
--   </pre>
Opt_PICExecutable :: GeneralFlag
Opt_ExternalDynamicRefs :: GeneralFlag
Opt_Ticky :: GeneralFlag
Opt_Ticky_Allocd :: GeneralFlag
Opt_Ticky_LNE :: GeneralFlag
Opt_Ticky_Dyn_Thunk :: GeneralFlag
Opt_RPath :: GeneralFlag
Opt_RelativeDynlibPaths :: GeneralFlag

-- | <pre>
--   -fcompact-unwind
--   </pre>
Opt_CompactUnwind :: GeneralFlag
Opt_Hpc :: GeneralFlag
Opt_FamAppCache :: GeneralFlag
Opt_ExternalInterpreter :: GeneralFlag
Opt_OptimalApplicativeDo :: GeneralFlag
Opt_VersionMacros :: GeneralFlag
Opt_WholeArchiveHsLibs :: GeneralFlag
Opt_SingleLibFolder :: GeneralFlag
Opt_ExposeInternalSymbols :: GeneralFlag
Opt_KeepCAFs :: GeneralFlag
Opt_KeepGoing :: GeneralFlag
Opt_ByteCode :: GeneralFlag
Opt_LinkRts :: GeneralFlag
Opt_ErrorSpans :: GeneralFlag
Opt_DeferDiagnostics :: GeneralFlag
Opt_DiagnosticsShowCaret :: GeneralFlag
Opt_PprCaseAsLet :: GeneralFlag
Opt_PprShowTicks :: GeneralFlag
Opt_ShowHoleConstraints :: GeneralFlag
Opt_ShowValidHoleFits :: GeneralFlag
Opt_SortValidHoleFits :: GeneralFlag
Opt_SortBySizeHoleFits :: GeneralFlag
Opt_SortBySubsumHoleFits :: GeneralFlag
Opt_AbstractRefHoleFits :: GeneralFlag
Opt_UnclutterValidHoleFits :: GeneralFlag
Opt_ShowTypeAppOfHoleFits :: GeneralFlag
Opt_ShowTypeAppVarsOfHoleFits :: GeneralFlag
Opt_ShowDocsOfHoleFits :: GeneralFlag
Opt_ShowTypeOfHoleFits :: GeneralFlag
Opt_ShowProvOfHoleFits :: GeneralFlag
Opt_ShowMatchesOfHoleFits :: GeneralFlag
Opt_ShowLoadedModules :: GeneralFlag
Opt_HexWordLiterals :: GeneralFlag
Opt_SuppressCoercions :: GeneralFlag
Opt_SuppressVarKinds :: GeneralFlag
Opt_SuppressModulePrefixes :: GeneralFlag
Opt_SuppressTypeApplications :: GeneralFlag
Opt_SuppressIdInfo :: GeneralFlag
Opt_SuppressUnfoldings :: GeneralFlag
Opt_SuppressTypeSignatures :: GeneralFlag
Opt_SuppressUniques :: GeneralFlag
Opt_SuppressStgExts :: GeneralFlag
Opt_SuppressTicks :: GeneralFlag

-- | Suppress timestamps in dumps
Opt_SuppressTimestamps :: GeneralFlag
Opt_AutoLinkPackages :: GeneralFlag
Opt_ImplicitImportQualified :: GeneralFlag
Opt_KeepHscppFiles :: GeneralFlag
Opt_KeepHiDiffs :: GeneralFlag
Opt_KeepHcFiles :: GeneralFlag
Opt_KeepSFiles :: GeneralFlag
Opt_KeepTmpFiles :: GeneralFlag
Opt_KeepRawTokenStream :: GeneralFlag
Opt_KeepLlvmFiles :: GeneralFlag
Opt_KeepHiFiles :: GeneralFlag
Opt_KeepOFiles :: GeneralFlag
Opt_BuildDynamicToo :: GeneralFlag
Opt_DistrustAllPackages :: GeneralFlag
Opt_PackageTrust :: GeneralFlag
Opt_PluginTrustworthy :: GeneralFlag
Opt_G_NoStateHack :: GeneralFlag
Opt_G_NoOptCoercion :: GeneralFlag
data Severity
SevOutput :: Severity
SevFatal :: Severity
SevInteractive :: Severity

-- | Log message intended for compiler developers No file/line/column stuff
SevDump :: Severity

-- | Log messages intended for end users. No file/line/column stuff.
SevInfo :: Severity
SevWarning :: Severity

-- | SevWarning and SevError are used for warnings and errors o The message
--   has a file/line/column heading, plus "warning:" or "error:", added by
--   mkLocMessags o Output is intended for end users
SevError :: Severity

-- | Code generation backends.
--   
--   GHC supports several code generation backends serving different
--   purposes (producing machine code, producing ByteCode for the
--   interpreter) and supporting different platforms.
data Backend

-- | Native code generator backend.
--   
--   Compiles Cmm code into textual assembler, then relies on an external
--   assembler toolchain to produce machine code.
--   
--   Only supports a few platforms (X86, PowerPC, SPARC).
--   
--   See <a>GHC.CmmToAsm</a>.
NCG :: Backend

-- | LLVM backend.
--   
--   Compiles Cmm code into LLVM textual IR, then relies on LLVM toolchain
--   to produce machine code.
--   
--   It relies on LLVM support for the calling convention used by the NCG
--   backend to produce code objects ABI compatible with it (see "cc 10" or
--   "ghccc" calling convention in
--   <a>https://llvm.org/docs/LangRef.html#calling-conventions)</a>.
--   
--   Support a few platforms (X86, AArch64, s390x, ARM).
--   
--   See <a>GHC.CmmToLlvm</a>
LLVM :: Backend

-- | Via-C backend.
--   
--   Compiles Cmm code into C code, then relies on a C compiler to produce
--   machine code.
--   
--   It produces code objects that are *not* ABI compatible with those
--   produced by NCG and LLVM backends.
--   
--   Produced code is expected to be less efficient than the one produced
--   by NCG and LLVM backends because STG registers are not pinned into
--   real registers. On the other hand, it supports more target platforms
--   (those having a valid C toolchain).
--   
--   See <a>GHC.CmmToC</a>
ViaC :: Backend

-- | ByteCode interpreter.
--   
--   Produce ByteCode objects (BCO, see <a>GHC.ByteCode</a>) that can be
--   interpreted. It is used by GHCi.
--   
--   Currently some extensions are not supported (foreign primops).
--   
--   See <a>GHC.StgToByteCode</a>
Interpreter :: Backend

-- | No code generated.
--   
--   Use this to disable code generation. It is particularly useful when
--   GHC is used as a library for other purpose than generating code (e.g.
--   to generate documentation with Haddock) or when the user requested it
--   (via -fno-code) for some reason.
NoBackend :: Backend

-- | Test whether a <a>GeneralFlag</a> is set
--   
--   Note that <a>dynamicNow</a> (i.e., dynamic objects built with
--   `-dynamic-too`) always implicitly enables Opt_PIC,
--   Opt_ExternalDynamicRefs, and disables Opt_SplitSections.
gopt :: GeneralFlag -> DynFlags -> Bool

-- | The <a>GhcMode</a> tells us whether we're doing multi-module
--   compilation (controlled via the <a>GHC</a> API) or one-shot
--   (single-module) compilation. This makes a difference primarily to the
--   <a>GHC.Unit.Finder</a>: in one-shot mode we look for interface files
--   for imported modules, but in multi-module mode we look for source
--   files in order to check whether they need to be recompiled.
data GhcMode

-- | <tt>--make</tt>, GHCi, etc.
CompManager :: GhcMode

-- | <pre>
--   ghc -c Foo.hs
--   </pre>
OneShot :: GhcMode

-- | <tt>ghc -M</tt>, see <a>GHC.Unit.Finder</a> for why we need this
MkDepend :: GhcMode

-- | What to do in the link step, if there is one.
data GhcLink

-- | Don't link at all
NoLink :: GhcLink

-- | Link object code into a binary
LinkBinary :: GhcLink

-- | Use the in-memory dynamic linker (works for both bytecode and object
--   code).
LinkInMemory :: GhcLink

-- | Link objects into a dynamic lib (DLL on Windows, DSO on ELF platforms)
LinkDynLib :: GhcLink

-- | Link objects into a static lib
LinkStaticLib :: GhcLink
parseDynamicFlags :: MonadIO m => Logger -> DynFlags -> [Located String] -> m (DynFlags, [Located String], [Warn])

-- | Parse command line arguments that look like files. First normalises
--   its arguments and then splits them into source files and object files.
--   A source file can be turned into a <a>Target</a> via
--   <a>guessTarget</a>
parseTargetFiles :: DynFlags -> [String] -> (DynFlags, [(String, Maybe Phase)], [String])

-- | Grabs the DynFlags from the Session
getSessionDynFlags :: GhcMonad m => m DynFlags

-- | Updates both the interactive and program DynFlags in a Session. This
--   also reads the package database (unless it has already been read), and
--   prepares the compilers knowledge about packages. It can be called
--   again to load new packages: just add new package flags to
--   (packageFlags dflags).
setSessionDynFlags :: GhcMonad m => DynFlags -> m ()

-- | Returns the program <a>DynFlags</a>.
getProgramDynFlags :: GhcMonad m => m DynFlags

-- | Sets the program <a>DynFlags</a>. Note: this invalidates the internal
--   cached module graph, causing more work to be done the next time
--   <a>load</a> is called.
--   
--   Returns a boolean indicating if preload units have changed and need to
--   be reloaded.
setProgramDynFlags :: GhcMonad m => DynFlags -> m Bool

-- | Get the <a>DynFlags</a> used to evaluate interactive expressions.
getInteractiveDynFlags :: GhcMonad m => m DynFlags

-- | Set the <a>DynFlags</a> used to evaluate interactive expressions. Also
--   initialise (load) plugins.
--   
--   Note: this cannot be used for changes to packages. Use
--   <a>setSessionDynFlags</a>, or <a>setProgramDynFlags</a> and then copy
--   the <tt>unitState</tt> into the interactive <tt>DynFlags</tt>.
setInteractiveDynFlags :: GhcMonad m => DynFlags -> m ()

-- | Find the package environment (if one exists)
--   
--   We interpret the package environment as a set of package flags; to be
--   specific, if we find a package environment file like
--   
--   <pre>
--   clear-package-db
--   global-package-db
--   package-db blah/package.conf.d
--   package-id id1
--   package-id id2
--   </pre>
--   
--   we interpret this as
--   
--   <pre>
--   [ -hide-all-packages
--   , -clear-package-db
--   , -global-package-db
--   , -package-db blah/package.conf.d
--   , -package-id id1
--   , -package-id id2
--   ]
--   </pre>
--   
--   There's also an older syntax alias for package-id, which is just an
--   unadorned package id
--   
--   <pre>
--   id1
--   id2
--   </pre>
interpretPackageEnv :: Logger -> DynFlags -> IO DynFlags
data Logger
getLogger :: HasLogger m => m Logger

-- | Push a log hook
pushLogHook :: (LogAction -> LogAction) -> Logger -> Logger

-- | Pop a log hook
popLogHook :: Logger -> Logger

-- | Push a log hook on the stack
pushLogHookM :: GhcMonad m => (LogAction -> LogAction) -> m ()

-- | Pop a log hook from the stack
popLogHookM :: GhcMonad m => m ()

-- | Modify the logger
modifyLogger :: GhcMonad m => (Logger -> Logger) -> m ()

-- | Put a log message
putMsgM :: GhcMonad m => SDoc -> m ()

-- | Put a log message
putLogMsgM :: GhcMonad m => WarnReason -> Severity -> SrcSpan -> SDoc -> m ()

-- | A compilation target.
--   
--   A target may be supplied with the actual text of the module. If so,
--   use this instead of the file contents (this is for use in an IDE where
--   the file hasn't been saved by the user yet).
data Target
Target :: !TargetId -> !Bool -> !Maybe (InputFileBuffer, UTCTime) -> Target

-- | module or filename
[targetId] :: Target -> !TargetId

-- | object code allowed?
[targetAllowObjCode] :: Target -> !Bool

-- | Optional in-memory buffer containing the source code GHC should use
--   for this target instead of reading it from disk.
--   
--   Since GHC version 8.10 modules which require preprocessors such as
--   Literate Haskell or CPP to run are also supported.
--   
--   If a corresponding source file does not exist on disk this will result
--   in a <tt>SourceError</tt> exception if <tt>targetId = TargetModule
--   _</tt> is used. However together with <tt>targetId = TargetFile _</tt>
--   GHC will not complain about the file missing.
[targetContents] :: Target -> !Maybe (InputFileBuffer, UTCTime)
data TargetId

-- | A module name: search for the file
TargetModule :: !ModuleName -> TargetId

-- | A filename: preprocess &amp; parse it to find the module name. If
--   specified, the Phase indicates how to compile this file (which phase
--   to start from). Nothing indicates the starting phase should be
--   determined from the suffix of the filename.
TargetFile :: !FilePath -> !Maybe Phase -> TargetId
data Phase

-- | Sets the targets for this session. Each target may be a module name or
--   a filename. The targets correspond to the set of root modules for the
--   program/library. Unloading the current program is achieved by setting
--   the current set of targets to be empty, followed by <a>load</a>.
setTargets :: GhcMonad m => [Target] -> m ()

-- | Returns the current set of targets
getTargets :: GhcMonad m => m [Target]

-- | Add another target.
addTarget :: GhcMonad m => Target -> m ()

-- | Remove a target
removeTarget :: GhcMonad m => TargetId -> m ()

-- | Attempts to guess what Target a string refers to. This function
--   implements the <tt>--make</tt>/GHCi command-line syntax for filenames:
--   
--   <ul>
--   <li>if the string looks like a Haskell source filename, then interpret
--   it as such</li>
--   <li>if adding a .hs or .lhs suffix yields the name of an existing
--   file, then use that</li>
--   <li>otherwise interpret the string as a module name</li>
--   </ul>
guessTarget :: GhcMonad m => String -> Maybe Phase -> m Target

-- | Perform a dependency analysis starting from the current targets and
--   update the session with the new module graph.
--   
--   Dependency analysis entails parsing the <tt>import</tt> directives and
--   may therefore require running certain preprocessors.
--   
--   Note that each <a>ModSummary</a> in the module graph caches its
--   <a>DynFlags</a>. These <a>DynFlags</a> are determined by the
--   <i>current</i> session <a>DynFlags</a> and the <tt>OPTIONS</tt> and
--   <tt>LANGUAGE</tt> pragmas of the parsed module. Thus if you want
--   changes to the <a>DynFlags</a> to take effect you need to call this
--   function again. In case of errors, just throw them.
depanal :: GhcMonad m => [ModuleName] -> Bool -> m ModuleGraph

-- | Perform dependency analysis like in <a>depanal</a>. In case of errors,
--   the errors and an empty module graph are returned.
depanalE :: GhcMonad m => [ModuleName] -> Bool -> m (ErrorMessages, ModuleGraph)

-- | Try to load the program. See <a>LoadHowMuch</a> for the different
--   modes.
--   
--   This function implements the core of GHC's <tt>--make</tt> mode. It
--   preprocesses, compiles and loads the specified modules, avoiding
--   re-compilation wherever possible. Depending on the backend (see
--   <a>backend</a> field) compiling and loading may result in files being
--   created on disk.
--   
--   Calls the <a>defaultWarnErrLogger</a> after each compiling each
--   module, whether successful or not.
--   
--   If errors are encountered during dependency analysis, the module
--   <a>depanalE</a> returns together with the errors an empty ModuleGraph.
--   After processing this empty ModuleGraph, the errors of depanalE are
--   thrown. All other errors are reported using the
--   <a>defaultWarnErrLogger</a>.
load :: GhcMonad m => LoadHowMuch -> m SuccessFlag

-- | Describes which modules of the module graph need to be loaded.
data LoadHowMuch

-- | Load all targets and its dependencies.
LoadAllTargets :: LoadHowMuch

-- | Load only the given module and its dependencies.
LoadUpTo :: ModuleName -> LoadHowMuch

-- | Load only the dependencies of the given module, but not the module
--   itself.
LoadDependenciesOf :: ModuleName -> LoadHowMuch
data InteractiveImport

-- | Bring the exports of a particular module (filtered by an import decl)
--   into scope
IIDecl :: ImportDecl GhcPs -> InteractiveImport

-- | Bring into scope the entire top-level envt of of this module,
--   including the things imported into it.
IIModule :: ModuleName -> InteractiveImport
data SuccessFlag
Succeeded :: SuccessFlag
Failed :: SuccessFlag
succeeded :: SuccessFlag -> Bool
failed :: SuccessFlag -> Bool
defaultWarnErrLogger :: WarnErrLogger

-- | A function called to log warnings and errors.
type WarnErrLogger = forall m. GhcMonad m => Maybe SourceError -> m ()

-- | Inform GHC that the working directory has changed. GHC will flush its
--   cache of module locations, since it may no longer be valid.
--   
--   Note: Before changing the working directory make sure all threads
--   running in the same session have stopped. If you change the working
--   directory, you should also unload the current program (set targets to
--   empty, followed by load).
workingDirectoryChanged :: GhcMonad m => m ()

-- | Parse a module.
--   
--   Throws a <a>SourceError</a> on parse error.
parseModule :: GhcMonad m => ModSummary -> m ParsedModule

-- | Typecheck and rename a parsed module.
--   
--   Throws a <a>SourceError</a> if either fails.
typecheckModule :: GhcMonad m => ParsedModule -> m TypecheckedModule

-- | Desugar a typechecked module.
desugarModule :: GhcMonad m => TypecheckedModule -> m DesugaredModule

-- | Load a module. Input doesn't need to be desugared.
--   
--   A module must be loaded before dependent modules can be typechecked.
--   This always includes generating a <a>ModIface_</a> and, depending on
--   the <tt>DynFlags</tt>'s <a>backend</a>, may also include code
--   generation.
--   
--   This function will always cause recompilation and will always
--   overwrite previous compilation results (potentially files on disk).
loadModule :: (TypecheckedMod mod, GhcMonad m) => mod -> m mod

-- | The result of successful parsing.
data ParsedModule
ParsedModule :: ModSummary -> ParsedSource -> [FilePath] -> ParsedModule
[pm_mod_summary] :: ParsedModule -> ModSummary
[pm_parsed_source] :: ParsedModule -> ParsedSource
[pm_extra_src_files] :: ParsedModule -> [FilePath]

-- | The result of successful typechecking. It also contains the parser
--   result.
data TypecheckedModule
TypecheckedModule :: ParsedModule -> Maybe RenamedSource -> TypecheckedSource -> ModuleInfo -> (TcGblEnv, ModDetails) -> TypecheckedModule
[tm_parsed_module] :: TypecheckedModule -> ParsedModule
[tm_renamed_source] :: TypecheckedModule -> Maybe RenamedSource
[tm_typechecked_source] :: TypecheckedModule -> TypecheckedSource
[tm_checked_module_info] :: TypecheckedModule -> ModuleInfo
[tm_internals_] :: TypecheckedModule -> (TcGblEnv, ModDetails)

-- | The result of successful desugaring (i.e., translation to core). Also
--   contains all the information of a typechecked module.
data DesugaredModule
DesugaredModule :: TypecheckedModule -> ModGuts -> DesugaredModule
[dm_typechecked_module] :: DesugaredModule -> TypecheckedModule
[dm_core_module] :: DesugaredModule -> ModGuts
type TypecheckedSource = LHsBinds GhcTc
type ParsedSource = Located HsModule
type RenamedSource = (HsGroup GhcRn, [LImportDecl GhcRn], Maybe [(LIE GhcRn, Avails)], Maybe LHsDocString)
class ParsedMod m => TypecheckedMod m
class ParsedMod m
moduleInfo :: TypecheckedMod m => m -> ModuleInfo
renamedSource :: TypecheckedMod m => m -> Maybe RenamedSource
typecheckedSource :: TypecheckedMod m => m -> TypecheckedSource
parsedSource :: ParsedMod m => m -> ParsedSource
coreModule :: DesugaredMod m => m -> ModGuts

-- | A CoreModule consists of just the fields of a <a>ModGuts</a> that are
--   needed for the <a>compileToCoreModule</a> interface.
data CoreModule
CoreModule :: !Module -> !TypeEnv -> CoreProgram -> SafeHaskellMode -> CoreModule

-- | Module name
[cm_module] :: CoreModule -> !Module

-- | Type environment for types declared in this module
[cm_types] :: CoreModule -> !TypeEnv

-- | Declarations
[cm_binds] :: CoreModule -> CoreProgram

-- | Safe Haskell mode
[cm_safe] :: CoreModule -> SafeHaskellMode

-- | This is the way to get access to the Core bindings corresponding to a
--   module. <tt>compileToCore</tt> parses, typechecks, and desugars the
--   module, then returns the resulting Core module (consisting of the
--   module name, type declarations, and function declarations) if
--   successful.
compileToCoreModule :: GhcMonad m => FilePath -> m CoreModule

-- | Like compileToCoreModule, but invokes the simplifier, so as to return
--   simplified and tidied Core.
compileToCoreSimplified :: GhcMonad m => FilePath -> m CoreModule

-- | A '<tt>ModuleGraph</tt>' contains all the nodes from the home package
--   (only). See '<tt>ModuleGraphNode</tt>' for information about the
--   nodes.
--   
--   Modules need to be compiled. hs-boots need to be typechecked before
--   the associated "real" module so modules with {-# SOURCE #-} imports
--   can be built. Instantiations also need to be typechecked to ensure
--   that the module fits the signature. Substantiation typechecking is
--   roughly comparable to the check that the module and its hs-boot agree.
--   
--   The graph is not necessarily stored in topologically-sorted order. Use
--   <a>topSortModuleGraph</a> and <a>flattenSCC</a> to achieve this.
data ModuleGraph
emptyMG :: ModuleGraph

-- | Map a function <tt>f</tt> over all the <tt>ModSummaries</tt>. To
--   preserve invariants <tt>f</tt> can't change the isBoot status.
mapMG :: (ModSummary -> ModSummary) -> ModuleGraph -> ModuleGraph
mkModuleGraph :: [ExtendedModSummary] -> ModuleGraph
mgModSummaries :: ModuleGraph -> [ModSummary]

-- | Look up a ModSummary in the ModuleGraph
mgLookupModule :: ModuleGraph -> Module -> Maybe ModSummary

-- | Data for a module node in a <tt>ModuleGraph</tt>. Module nodes of the
--   module graph are one of:
--   
--   <ul>
--   <li>A regular Haskell source module</li>
--   <li>A hi-boot source module</li>
--   </ul>
data ModSummary
ModSummary :: Module -> HscSource -> ModLocation -> UTCTime -> Maybe UTCTime -> Maybe UTCTime -> Maybe UTCTime -> [(Maybe FastString, Located ModuleName)] -> [(Maybe FastString, Located ModuleName)] -> Maybe HsParsedModule -> FilePath -> DynFlags -> Maybe StringBuffer -> ModSummary

-- | Identity of the module
[ms_mod] :: ModSummary -> Module

-- | The module source either plain Haskell, hs-boot, or hsig
[ms_hsc_src] :: ModSummary -> HscSource

-- | Location of the various files belonging to the module
[ms_location] :: ModSummary -> ModLocation

-- | Timestamp of source file
[ms_hs_date] :: ModSummary -> UTCTime

-- | Timestamp of object, if we have one
[ms_obj_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of hi file, if we *only* are typechecking (it is
--   <a>Nothing</a> otherwise. See Note [Recompilation checking in
--   -fno-code mode] and #9243
[ms_iface_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of hie file, if we have one
[ms_hie_date] :: ModSummary -> Maybe UTCTime

-- | Source imports of the module
[ms_srcimps] :: ModSummary -> [(Maybe FastString, Located ModuleName)]

-- | Non-source imports of the module from the module *text*
[ms_textual_imps] :: ModSummary -> [(Maybe FastString, Located ModuleName)]

-- | The parsed, nonrenamed source, if we have it. This is also used to
--   support "inline module syntax" in Backpack files.
[ms_parsed_mod] :: ModSummary -> Maybe HsParsedModule

-- | Filename of preprocessed source file
[ms_hspp_file] :: ModSummary -> FilePath

-- | Cached flags from <tt>OPTIONS</tt>, <tt>INCLUDE</tt> and
--   <tt>LANGUAGE</tt> pragmas in the modules source code
[ms_hspp_opts] :: ModSummary -> DynFlags

-- | The actual preprocessed source, if we have it
[ms_hspp_buf] :: ModSummary -> Maybe StringBuffer
ms_mod_name :: ModSummary -> ModuleName

-- | Module Location
--   
--   Where a module lives on the file system: the actual locations of the
--   .hs, .hi and .o files, if we have them.
--   
--   For a module in another unit, the ml_hs_file and ml_obj_file
--   components of ModLocation are undefined.
--   
--   The locations specified by a ModLocation may or may not correspond to
--   actual files yet: for example, even if the object file doesn't exist,
--   the ModLocation still contains the path to where the object file will
--   reside if/when it is created.
data ModLocation
ModLocation :: Maybe FilePath -> FilePath -> FilePath -> FilePath -> ModLocation

-- | The source file, if we have one. Package modules probably don't have
--   source files.
[ml_hs_file] :: ModLocation -> Maybe FilePath

-- | Where the .hi file is, whether or not it exists yet. Always of form
--   foo.hi, even if there is an hi-boot file (we add the -boot suffix
--   later)
[ml_hi_file] :: ModLocation -> FilePath

-- | Where the .o file is, whether or not it exists yet. (might not exist
--   either because the module hasn't been compiled yet, or because it is
--   part of a unit with a .a file)
[ml_obj_file] :: ModLocation -> FilePath

-- | Where the .hie file is, whether or not it exists yet.
[ml_hie_file] :: ModLocation -> FilePath

-- | Return the <a>ModSummary</a> of a module with the given name.
--   
--   The module must be part of the module graph (see <a>hsc_mod_graph</a>
--   and <a>ModuleGraph</a>). If this is not the case, this function will
--   throw a <a>GhcApiError</a>.
--   
--   This function ignores boot modules and requires that there is only one
--   non-boot module with the given name.
getModSummary :: GhcMonad m => ModuleName -> m ModSummary

-- | Get the module dependency graph.
getModuleGraph :: GhcMonad m => m ModuleGraph

-- | Return <tt>True</tt> &lt;==&gt; module is loaded.
isLoaded :: GhcMonad m => ModuleName -> m Bool

-- | Topological sort of the module graph
--   
--   Calculate SCCs of the module graph, possibly dropping the hi-boot
--   nodes The resulting list of strongly-connected-components is in
--   topologically sorted order, starting with the module(s) at the bottom
--   of the dependency graph (ie compile them first) and ending with the
--   ones at the top.
--   
--   Drop hi-boot nodes (first boolean arg)?
--   
--   <ul>
--   <li><tt>False</tt>: treat the hi-boot summaries as nodes of the graph,
--   so the graph must be acyclic</li>
--   <li><tt>True</tt>: eliminate the hi-boot nodes, and instead pretend
--   the a source-import of Foo is an import of Foo The resulting graph has
--   no hi-boot nodes, but can be cyclic</li>
--   </ul>
topSortModuleGraph :: Bool -> ModuleGraph -> Maybe ModuleName -> [SCC ModuleGraphNode]

-- | Container for information about a <a>Module</a>.
data ModuleInfo

-- | Request information about a loaded <a>Module</a>
getModuleInfo :: GhcMonad m => Module -> m (Maybe ModuleInfo)

-- | The list of top-level entities defined in a module
modInfoTyThings :: ModuleInfo -> [TyThing]
modInfoTopLevelScope :: ModuleInfo -> Maybe [Name]
modInfoExports :: ModuleInfo -> [Name]
modInfoExportsWithSelectors :: ModuleInfo -> [Name]

-- | Returns the instances defined by the specified module. Warning:
--   currently unimplemented for package modules.
modInfoInstances :: ModuleInfo -> [ClsInst]
modInfoIsExportedName :: ModuleInfo -> Name -> Bool
modInfoLookupName :: GhcMonad m => ModuleInfo -> Name -> m (Maybe TyThing)
modInfoIface :: ModuleInfo -> Maybe ModIface
modInfoRdrEnv :: ModuleInfo -> Maybe GlobalRdrEnv

-- | Retrieve module safe haskell mode
modInfoSafe :: ModuleInfo -> SafeHaskellMode

-- | Looks up a global name: that is, any top-level name in any visible
--   module. Unlike <a>lookupName</a>, lookupGlobalName does not use the
--   interactive context, and therefore does not require a preceding
--   <a>setContext</a>.
lookupGlobalName :: GhcMonad m => Name -> m (Maybe TyThing)
findGlobalAnns :: (GhcMonad m, Typeable a) => ([Word8] -> a) -> AnnTarget Name -> m [a]
mkPrintUnqualifiedForModule :: GhcMonad m => ModuleInfo -> m (Maybe PrintUnqualified)
type ModIface = ModIface_ 'ModIfaceFinal

-- | A <a>ModIface_</a> plus a <tt>ModDetails</tt> summarises everything we
--   know about a compiled module. The <a>ModIface_</a> is the stuff
--   *before* linking, and can be written out to an interface file. The
--   'ModDetails is after linking and can be completely recovered from just
--   the <a>ModIface_</a>.
--   
--   When we read an interface file, we also construct a <a>ModIface_</a>
--   from it, except that we explicitly make the <a>mi_decls</a> and a few
--   other fields empty; as when reading we consolidate the declarations
--   etc. into a number of indexed maps and environments in the
--   <tt>ExternalPackageState</tt>.
data ModIface_ (phase :: ModIfacePhase)
ModIface :: !Module -> !Maybe Module -> !HscSource -> Dependencies -> [Usage] -> ![IfaceExport] -> !Bool -> [(OccName, Fixity)] -> Warnings -> [IfaceAnnotation] -> [IfaceDeclExts phase] -> !Maybe GlobalRdrEnv -> [IfaceClsInst] -> [IfaceFamInst] -> [IfaceRule] -> !AnyHpcUsage -> !IfaceTrustInfo -> !Bool -> [IfaceCompleteMatch] -> Maybe HsDocString -> DeclDocMap -> ArgDocMap -> !IfaceBackendExts phase -> ExtensibleFields -> ModIface_ (phase :: ModIfacePhase)

-- | Name of the module we are for
[mi_module] :: ModIface_ (phase :: ModIfacePhase) -> !Module

-- | Are we a sig of another mod?
[mi_sig_of] :: ModIface_ (phase :: ModIfacePhase) -> !Maybe Module

-- | Boot? Signature?
[mi_hsc_src] :: ModIface_ (phase :: ModIfacePhase) -> !HscSource

-- | The dependencies of the module. This is consulted for
--   directly-imported modules, but not for anything else (hence lazy)
[mi_deps] :: ModIface_ (phase :: ModIfacePhase) -> Dependencies

-- | Usages; kept sorted so that it's easy to decide whether to write a new
--   iface file (changing usages doesn't affect the hash of this module)
--   NOT STRICT! we read this field lazily from the interface file It is
--   *only* consulted by the recompilation checker
[mi_usages] :: ModIface_ (phase :: ModIfacePhase) -> [Usage]

-- | Exports Kept sorted by (mod,occ), to make version comparisons easier
--   Records the modules that are the declaration points for things
--   exported by this module, and the <a>OccName</a>s of those things
[mi_exports] :: ModIface_ (phase :: ModIfacePhase) -> ![IfaceExport]

-- | Module required TH splices when it was compiled. This disables
--   recompilation avoidance (see #481).
[mi_used_th] :: ModIface_ (phase :: ModIfacePhase) -> !Bool

-- | Fixities NOT STRICT! we read this field lazily from the interface file
[mi_fixities] :: ModIface_ (phase :: ModIfacePhase) -> [(OccName, Fixity)]

-- | Warnings NOT STRICT! we read this field lazily from the interface file
[mi_warns] :: ModIface_ (phase :: ModIfacePhase) -> Warnings

-- | Annotations NOT STRICT! we read this field lazily from the interface
--   file
[mi_anns] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceAnnotation]

-- | Type, class and variable declarations The hash of an Id changes if its
--   fixity or deprecations change (as well as its type of course) Ditto
--   data constructors, class operations, except that the hash of the
--   parent class/tycon changes
[mi_decls] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceDeclExts phase]

-- | Binds all the things defined at the top level in the <i>original
--   source</i> code for this module. which is NOT the same as mi_exports,
--   nor mi_decls (which may contains declarations for things not actually
--   defined by the user). Used for GHCi and for inspecting the contents of
--   modules via the GHC API only.
--   
--   (We need the source file to figure out the top-level environment, if
--   we didn't compile this module from source then this field contains
--   <tt>Nothing</tt>).
--   
--   Strictly speaking this field should live in the <tt>HomeModInfo</tt>,
--   but that leads to more plumbing.
[mi_globals] :: ModIface_ (phase :: ModIfacePhase) -> !Maybe GlobalRdrEnv

-- | Sorted class instance
[mi_insts] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceClsInst]

-- | Sorted family instances
[mi_fam_insts] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceFamInst]

-- | Sorted rules
[mi_rules] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceRule]

-- | True if this program uses Hpc at any point in the program.
[mi_hpc] :: ModIface_ (phase :: ModIfacePhase) -> !AnyHpcUsage

-- | Safe Haskell Trust information for this module.
[mi_trust] :: ModIface_ (phase :: ModIfacePhase) -> !IfaceTrustInfo

-- | Do we require the package this module resides in be trusted to trust
--   this module? This is used for the situation where a module is Safe (so
--   doesn't require the package be trusted itself) but imports some
--   trustworthy modules from its own package (which does require its own
--   package be trusted). See Note [Trust Own Package] in GHC.Rename.Names
[mi_trust_pkg] :: ModIface_ (phase :: ModIfacePhase) -> !Bool
[mi_complete_matches] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceCompleteMatch]

-- | Module header.
[mi_doc_hdr] :: ModIface_ (phase :: ModIfacePhase) -> Maybe HsDocString

-- | Docs on declarations.
[mi_decl_docs] :: ModIface_ (phase :: ModIfacePhase) -> DeclDocMap

-- | Docs on arguments.
[mi_arg_docs] :: ModIface_ (phase :: ModIfacePhase) -> ArgDocMap

-- | Either <tt>()</tt> or <a>ModIfaceBackend</a> for a fully instantiated
--   interface.
[mi_final_exts] :: ModIface_ (phase :: ModIfacePhase) -> !IfaceBackendExts phase

-- | Additional optional fields, where the Map key represents the field
--   name, resulting in a (size, serialized data) pair. Because the data is
--   intended to be serialized through the internal <a>Binary</a> class
--   (increasing compatibility with types using <a>Name</a> and
--   <tt>FastString</tt>, such as HIE), this format is chosen over
--   <tt>ByteString</tt>s.
[mi_ext_fields] :: ModIface_ (phase :: ModIfacePhase) -> ExtensibleFields

-- | The various Safe Haskell modes
data SafeHaskellMode

-- | inferred unsafe
Sf_None :: SafeHaskellMode

-- | declared and checked
Sf_Unsafe :: SafeHaskellMode

-- | declared and checked
Sf_Trustworthy :: SafeHaskellMode

-- | declared and checked
Sf_Safe :: SafeHaskellMode

-- | inferred as safe
Sf_SafeInferred :: SafeHaskellMode

-- | <tt>-fno-safe-haskell</tt> state
Sf_Ignore :: SafeHaskellMode

-- | When printing code that contains original names, we need to map the
--   original names back to something the user understands. This is the
--   purpose of the triple of functions that gets passed around when
--   rendering <a>SDoc</a>.
data PrintUnqualified
alwaysQualify :: PrintUnqualified

-- | Run a statement in the current interactive context.
execStmt :: GhcMonad m => String -> ExecOptions -> m ExecResult

-- | Like <a>execStmt</a>, but takes a parsed statement as argument. Useful
--   when doing preprocessing on the AST before execution, e.g. in GHCi
--   (see GHCi.UI.runStmt).
execStmt' :: GhcMonad m => GhciLStmt GhcPs -> String -> ExecOptions -> m ExecResult
data ExecOptions
ExecOptions :: SingleStep -> String -> Int -> (ForeignHValue -> EvalExpr ForeignHValue) -> ExecOptions

-- | stepping mode
[execSingleStep] :: ExecOptions -> SingleStep

-- | filename (for errors)
[execSourceFile] :: ExecOptions -> String

-- | line number (for errors)
[execLineNumber] :: ExecOptions -> Int
[execWrap] :: ExecOptions -> ForeignHValue -> EvalExpr ForeignHValue

-- | default ExecOptions
execOptions :: ExecOptions
data ExecResult
ExecComplete :: Either SomeException [Name] -> Word64 -> ExecResult
[execResult] :: ExecResult -> Either SomeException [Name]
[execAllocation] :: ExecResult -> Word64
ExecBreak :: [Name] -> Maybe BreakInfo -> ExecResult
[breakNames] :: ExecResult -> [Name]
[breakInfo] :: ExecResult -> Maybe BreakInfo
resumeExec :: GhcMonad m => (SrcSpan -> Bool) -> SingleStep -> Maybe Int -> m ExecResult
runDecls :: GhcMonad m => String -> m [Name]

-- | Run some declarations and return any user-visible names that were
--   brought into scope.
runDeclsWithLocation :: GhcMonad m => String -> Int -> String -> m [Name]

-- | Like <a>runDeclsWithLocation</a>, but takes parsed declarations as
--   argument. Useful when doing preprocessing on the AST before execution,
--   e.g. in GHCi (see GHCi.UI.runStmt).
runParsedDecls :: GhcMonad m => [LHsDecl GhcPs] -> m [Name]
parseImportDecl :: GhcMonad m => String -> m (ImportDecl GhcPs)

-- | Set the interactive evaluation context.
--   
--   (setContext imports) sets the ic_imports field (which in turn
--   determines what is in scope at the prompt) to <tt>imports</tt>, and
--   constructs the ic_rn_glb_env environment to reflect it.
--   
--   We retain in scope all the things defined at the prompt, and kept in
--   ic_tythings. (Indeed, they shadow stuff from ic_imports.)
setContext :: GhcMonad m => [InteractiveImport] -> m ()

-- | Get the interactive evaluation context, consisting of a pair of the
--   set of modules from which we take the full top-level scope, and the
--   set of modules from which we take just the exports respectively.
getContext :: GhcMonad m => m [InteractiveImport]

-- | Set the monad GHCi lifts user statements into.
--   
--   Checks that a type (in string form) is an instance of the
--   <tt>GHC.GHCi.GHCiSandboxIO</tt> type class. Sets it to be the GHCi
--   monad if it is, throws an error otherwise.
setGHCiMonad :: GhcMonad m => String -> m ()

-- | Get the monad GHCi lifts user statements into.
getGHCiMonad :: GhcMonad m => m Name

-- | Return the bindings for the current interactive session.
getBindings :: GhcMonad m => m [TyThing]

-- | Return the instances for the current interactive session.
getInsts :: GhcMonad m => m ([ClsInst], [FamInst])
getPrintUnqual :: GhcMonad m => m PrintUnqualified

-- | Takes a <a>ModuleName</a> and possibly a <a>UnitId</a>, and consults
--   the filesystem and package database to find the corresponding
--   <a>Module</a>, using the algorithm that is used for an <tt>import</tt>
--   declaration.
findModule :: GhcMonad m => ModuleName -> Maybe FastString -> m Module

-- | Like <a>findModule</a>, but differs slightly when the module refers to
--   a source file, and the file has not been loaded via <a>load</a>. In
--   this case, <a>findModule</a> will throw an error (module not loaded),
--   but <a>lookupModule</a> will check to see whether the module can also
--   be found in a package, and if so, that package <a>Module</a> will be
--   returned. If not, the usual module-not-found error will be thrown.
lookupModule :: GhcMonad m => ModuleName -> Maybe FastString -> m Module

-- | Check that a module is safe to import (according to Safe Haskell).
--   
--   We return True to indicate the import is safe and False otherwise
--   although in the False case an error may be thrown first.
isModuleTrusted :: GhcMonad m => Module -> m Bool

-- | Return if a module is trusted and the pkgs it depends on to be
--   trusted.
moduleTrustReqs :: GhcMonad m => Module -> m (Bool, Set UnitId)

-- | Returns all names in scope in the current interactive context
getNamesInScope :: GhcMonad m => m [Name]

-- | Returns all <a>RdrName</a>s in scope in the current interactive
--   context, excluding any that are internally-generated.
getRdrNamesInScope :: GhcMonad m => m [RdrName]

-- | get the GlobalRdrEnv for a session
getGRE :: GhcMonad m => m GlobalRdrEnv

-- | Returns <tt>True</tt> if the specified module is interpreted, and
--   hence has its full top-level scope available.
moduleIsInterpreted :: GhcMonad m => Module -> m Bool

-- | Looks up an identifier in the current interactive context (for :info)
--   Filter the instances by the ones whose tycons (or clases resp) are in
--   scope (qualified or otherwise). Otherwise we list a whole lot too
--   many! The exact choice of which ones to show, and which to hide, is a
--   judgement call. (see #1581)
getInfo :: GhcMonad m => Bool -> Name -> m (Maybe (TyThing, Fixity, [ClsInst], [FamInst], SDoc))
showModule :: GhcMonad m => ModSummary -> m String
moduleIsBootOrNotObjectLinkable :: GhcMonad m => ModSummary -> m Bool

-- | Retrieve all type and family instances in the environment, indexed by
--   <a>Name</a>. Each name's lists will contain every instance in which
--   that name is mentioned in the instance head.
getNameToInstancesIndex :: GhcMonad m => [Module] -> Maybe [Module] -> m (Messages DecoratedSDoc, Maybe (NameEnv ([ClsInst], [FamInst])))

-- | Get the type of an expression Returns the type as described by
--   <a>TcRnExprMode</a>
exprType :: GhcMonad m => TcRnExprMode -> String -> m Type

-- | How should we infer a type? See Note [TcRnExprMode]
data TcRnExprMode

-- | Instantiate inferred quantifiers only (:type)
TM_Inst :: TcRnExprMode

-- | Instantiate all quantifiers, and do eager defaulting (:type +d)
TM_Default :: TcRnExprMode

-- | Get the kind of a type
typeKind :: GhcMonad m => Bool -> String -> m (Type, Kind)

-- | Parses a string as an identifier, and returns the list of <a>Name</a>s
--   that the identifier can refer to in the current interactive context.
parseName :: GhcMonad m => String -> m [Name]

-- | Returns the <a>TyThing</a> for a <a>Name</a>. The <a>Name</a> may
--   refer to any entity known to GHC, including <a>Name</a>s defined using
--   <tt>runStmt</tt>.
lookupName :: GhcMonad m => Name -> m (Maybe TyThing)
data HValue

-- | Parse an expression, the parsed expression can be further processed
--   and passed to compileParsedExpr.
parseExpr :: GhcMonad m => String -> m (LHsExpr GhcPs)
compileParsedExpr :: GhcMonad m => LHsExpr GhcPs -> m HValue

-- | Compile an expression, run it, and deliver the resulting HValue.
compileExpr :: GhcMonad m => String -> m HValue

-- | Compile an expression, run it and return the result as a Dynamic.
dynCompileExpr :: GhcMonad m => String -> m Dynamic
type ForeignHValue = ForeignRef HValue

-- | Compile an expression, run it, and deliver the resulting HValue.
compileExprRemote :: GhcMonad m => String -> m ForeignHValue

-- | Compile a parsed expression (before renaming), run it, and deliver the
--   resulting HValue.
compileParsedExprRemote :: GhcMonad m => LHsExpr GhcPs -> m ForeignHValue
getDocs :: GhcMonad m => Name -> m (Either GetDocsFailure (Maybe HsDocString, IntMap HsDocString))

-- | Failure modes for <a>getDocs</a>.
data GetDocsFailure

-- | <a>nameModule_maybe</a> returned <a>Nothing</a>.
NameHasNoModule :: Name -> GetDocsFailure

-- | This is probably because the module was loaded without
--   <tt>-haddock</tt>, but it's also possible that the entire module
--   contains no documentation.
NoDocsInIface :: Module -> Bool -> GetDocsFailure

-- | The <a>Name</a> was defined interactively.
InteractiveName :: GetDocsFailure
runTcInteractive :: HscEnv -> TcRn a -> IO (Messages DecoratedSDoc, Maybe a)

-- | Returns <tt>True</tt> if passed string is a statement.
isStmt :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string has an import declaration.
hasImport :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string is an import declaration.
isImport :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string is a declaration but <b><i>not
--   a splice</i></b>.
isDecl :: ParserOpts -> String -> Bool
data SingleStep
RunToCompletion :: SingleStep
SingleStep :: SingleStep
RunAndLogSteps :: SingleStep
data Resume
Resume :: String -> ForeignRef (ResumeContext [HValueRef]) -> ([TyThing], GlobalRdrEnv) -> [Id] -> ForeignHValue -> Maybe BreakInfo -> SrcSpan -> String -> RemotePtr CostCentreStack -> [History] -> Int -> Resume
[resumeStmt] :: Resume -> String
[resumeContext] :: Resume -> ForeignRef (ResumeContext [HValueRef])
[resumeBindings] :: Resume -> ([TyThing], GlobalRdrEnv)
[resumeFinalIds] :: Resume -> [Id]
[resumeApStack] :: Resume -> ForeignHValue
[resumeBreakInfo] :: Resume -> Maybe BreakInfo
[resumeSpan] :: Resume -> SrcSpan
[resumeDecl] :: Resume -> String
[resumeCCS] :: Resume -> RemotePtr CostCentreStack
[resumeHistory] :: Resume -> [History]
[resumeHistoryIx] :: Resume -> Int
data History
getHistorySpan :: GhcMonad m => History -> m SrcSpan
getHistoryModule :: History -> Module
abandon :: GhcMonad m => m Bool
abandonAll :: GhcMonad m => m Bool
getResumeContext :: GhcMonad m => m [Resume]
obtainTermFromId :: GhcMonad m => Int -> Bool -> Id -> m Term
obtainTermFromVal :: GhcMonad m => Int -> Bool -> Type -> a -> m Term
reconstructType :: HscEnv -> Int -> Id -> IO (Maybe Type)
modInfoModBreaks :: ModuleInfo -> ModBreaks

-- | All the information about the breakpoints for a module
data ModBreaks
ModBreaks :: ForeignRef BreakArray -> !Array BreakIndex SrcSpan -> !Array BreakIndex [OccName] -> !Array BreakIndex [String] -> !Array BreakIndex (RemotePtr CostCentre) -> IntMap CgBreakInfo -> ModBreaks

-- | The array of flags, one per breakpoint, indicating which breakpoints
--   are enabled.
[modBreaks_flags] :: ModBreaks -> ForeignRef BreakArray

-- | An array giving the source span of each breakpoint.
[modBreaks_locs] :: ModBreaks -> !Array BreakIndex SrcSpan

-- | An array giving the names of the free variables at each breakpoint.
[modBreaks_vars] :: ModBreaks -> !Array BreakIndex [OccName]

-- | An array giving the names of the declarations enclosing each
--   breakpoint. See Note [Field modBreaks_decls]
[modBreaks_decls] :: ModBreaks -> !Array BreakIndex [String]

-- | Array pointing to cost centre for each breakpoint
[modBreaks_ccs] :: ModBreaks -> !Array BreakIndex (RemotePtr CostCentre)

-- | info about each breakpoint from the bytecode generator
[modBreaks_breakInfo] :: ModBreaks -> IntMap CgBreakInfo

-- | Breakpoint index
type BreakIndex = Int
data BreakInfo
BreakInfo :: Module -> Int -> BreakInfo
[breakInfo_module] :: BreakInfo -> Module
[breakInfo_number] :: BreakInfo -> Int
back :: GhcMonad m => Int -> m ([Name], Int, SrcSpan, String)
forward :: GhcMonad m => Int -> m ([Name], Int, SrcSpan, String)
setupBreakpoint :: GhcMonad m => HscEnv -> BreakInfo -> Int -> m ()
type Unit = GenUnit UnitId

-- | A Module is a pair of a <a>Unit</a> and a <a>ModuleName</a>.
type Module = GenModule Unit
mkModule :: u -> ModuleName -> GenModule u
pprModule :: Module -> SDoc

-- | Module name (e.g. A.B.C)
moduleName :: GenModule unit -> ModuleName

-- | Unit the module belongs to
moduleUnit :: GenModule unit -> unit

-- | A ModuleName is essentially a simple string, e.g. <tt>Data.List</tt>.
data ModuleName
mkModuleName :: String -> ModuleName
moduleNameString :: ModuleName -> String

-- | A unique, unambiguous name for something, containing information about
--   where that thing originated.
data Name
isExternalName :: Name -> Bool
nameModule :: HasDebugCallStack => Name -> Module

-- | print a <a>NamedThing</a>, adding parentheses if the name is an
--   operator.
pprParenSymName :: NamedThing a => a -> SDoc
nameSrcSpan :: Name -> SrcSpan

-- | A class allowing convenient access to the <a>Name</a> of various
--   datatypes
class NamedThing a
getOccName :: NamedThing a => a -> OccName
getName :: NamedThing a => a -> Name

-- | Reader Name
--   
--   Do not use the data constructors of RdrName directly: prefer the
--   family of functions that creates them, such as <a>mkRdrUnqual</a>
--   
--   <ul>
--   <li>Note: A Located RdrName will only have API Annotations if it is a
--   compound one, e.g.</li>
--   </ul>
--   
--   <pre>
--   `bar`
--   ( ~ )
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnOpen</a> <tt>'('</tt>
--   or <tt>'['</tt> or <tt>'[:'</tt>, <a>AnnClose</a> <tt>')'</tt> or
--   <tt>']'</tt> or <tt>':]'</tt>,, <a>AnnBackquote</a> <tt>'`'</tt>,
--   <a>AnnVal</a> <a>AnnTilde</a>,</li>
--   </ul>
data RdrName

-- | Unqualified name
--   
--   Used for ordinary, unqualified occurrences, e.g. <tt>x</tt>,
--   <tt>y</tt> or <tt>Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrUnqual</a>
Unqual :: OccName -> RdrName

-- | Qualified name
--   
--   A qualified name written by the user in <i>source</i> code. The module
--   isn't necessarily the module where the thing is defined; just the one
--   from which it is imported. Examples are <tt>Bar.x</tt>, <tt>Bar.y</tt>
--   or <tt>Bar.Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrQual</a>
Qual :: ModuleName -> OccName -> RdrName

-- | Identifier
type Id = Var
idType :: Id -> Kind

-- | <a>isImplicitId</a> tells whether an <a>Id</a>s info is implied by
--   other declarations, so we don't need to put its signature in an
--   interface file, even if it's mentioned in some other interface
--   unfolding.
isImplicitId :: Id -> Bool
isDeadBinder :: Id -> Bool

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool
isLocalId :: Var -> Bool
isGlobalId :: Var -> Bool
isRecordSelector :: Id -> Bool
isPrimOpId :: Id -> Bool
isFCallId :: Id -> Bool
isClassOpId_maybe :: Id -> Maybe Class
isDataConWorkId :: Id -> Bool

-- | Get from either the worker or the wrapper <a>Id</a> to the
--   <a>DataCon</a>. Currently used only in the desugarer.
--   
--   INVARIANT: <tt>idDataCon (dataConWrapId d) = d</tt>: remember,
--   <a>dataConWrapId</a> can return either the wrapper or the worker
idDataCon :: Id -> DataCon

-- | Returns true if an application to n args diverges or throws an
--   exception See Note [Dead ends] in <a>GHC.Types.Demand</a>.
isDeadEndId :: Var -> Bool
isDictonaryId :: Id -> Bool

-- | If the <a>Id</a> is that for a record selector, extract the
--   <a>sel_tycon</a>. Panic otherwise.
recordSelectorTyCon :: Id -> RecSelParent

-- | TyCons represent type constructors. Type constructors are introduced
--   by things such as:
--   
--   1) Data declarations: <tt>data Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor of kind <tt>*</tt>
--   
--   2) Type synonyms: <tt>type Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor
--   
--   3) Newtypes: <tt>newtype Foo a = MkFoo ...</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>* -&gt; *</tt>
--   
--   4) Class declarations: <tt>class Foo where</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>*</tt>
--   
--   This data type also encodes a number of primitive, built in type
--   constructors such as those for function and tuple types.
data TyCon

-- | TyVar binders
tyConTyVars :: TyCon -> [TyVar]

-- | As <a>tyConDataCons_maybe</a>, but returns the empty list of
--   constructors if no constructors could be found
tyConDataCons :: TyCon -> [DataCon]

-- | Arity
tyConArity :: TyCon -> Arity

-- | Is this <a>TyCon</a> that for a class instance?
isClassTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a> representing a regular H98 type synonym
--   (<tt>type</tt>)?
isTypeSynonymTyCon :: TyCon -> Bool

-- | Is this a synonym <a>TyCon</a> that can have may have further
--   instances appear?
isTypeFamilyTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a <tt>newtype</tt>
isNewTyCon :: TyCon -> Bool

-- | Does this <a>TyCon</a> represent something that cannot be defined in
--   Haskell?
isPrimTyCon :: TyCon -> Bool
isFunTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family?
isFamilyTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family
--   with instances?
isOpenFamilyTyCon :: TyCon -> Bool

-- | Is this an open type family TyCon?
isOpenTypeFamilyTyCon :: TyCon -> Bool

-- | If this <a>TyCon</a> is that for a class instance, return the class it
--   is for. Otherwise returns <tt>Nothing</tt>
tyConClass_maybe :: TyCon -> Maybe Class

-- | Extract the information pertaining to the right hand side of a type
--   synonym (<tt>type</tt>) declaration.
synTyConRhs_maybe :: TyCon -> Maybe Type

-- | Extract the <a>TyVar</a>s bound by a vanilla type synonym and the
--   corresponding (unsubstituted) right hand side.
synTyConDefn_maybe :: TyCon -> Maybe ([TyVar], Type)

-- | Kind of this TyCon
tyConKind :: TyCon -> Kind

-- | Type or kind Variable
type TyVar = Var
alphaTyVars :: [TyVar]

-- | A data constructor
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnClose</a>,<a>AnnComma</a></li>
--   </ul>
data DataCon
dataConType :: DataCon -> Type

-- | The type constructor that we are building via this data constructor
dataConTyCon :: DataCon -> TyCon

-- | The labels for the fields of this particular <a>DataCon</a>
dataConFieldLabels :: DataCon -> [FieldLabel]

-- | Should the <a>DataCon</a> be presented infix?
dataConIsInfix :: DataCon -> Bool

-- | Vanilla <a>DataCon</a>s are those that are nice boring Haskell 98
--   constructors
isVanillaDataCon :: DataCon -> Bool

-- | The user-declared type of the data constructor in the nice-to-read
--   form:
--   
--   <pre>
--   T :: forall a b. a -&gt; b -&gt; T [a]
--   </pre>
--   
--   rather than:
--   
--   <pre>
--   T :: forall a c. forall b. (c~[a]) =&gt; a -&gt; b -&gt; T c
--   </pre>
--   
--   The type variables are quantified in the order that the user wrote
--   them. See <tt>Note [DataCon user type variable binders]</tt>.
--   
--   NB: If the constructor is part of a data instance, the result type
--   mentions the family tycon, not the internal one.
dataConWrapperType :: DataCon -> Type

-- | Strictness/unpack annotations, from user; or, for imported DataCons,
--   from the interface file The list is in one-to-one correspondence with
--   the arity of the <a>DataCon</a>
dataConSrcBangs :: DataCon -> [HsSrcBang]
data StrictnessMark
MarkedStrict :: StrictnessMark
NotMarkedStrict :: StrictnessMark
isMarkedStrict :: StrictnessMark -> Bool
data Class
classMethods :: Class -> [Id]
classSCTheta :: Class -> [PredType]
classTvsFds :: Class -> ([TyVar], [FunDep TyVar])
classATs :: Class -> [TyCon]
pprFundeps :: Outputable a => [FunDep a] -> SDoc

-- | A type-class instance. Note that there is some tricky laziness at work
--   here. See Note [ClsInst laziness and the rough-match fields] for more
--   details.
data ClsInst
instanceDFunId :: ClsInst -> DFunId
pprInstance :: ClsInst -> SDoc
pprInstanceHdr :: ClsInst -> SDoc

-- | Pretty-prints a <a>FamInst</a> (type/data family instance) with its
--   defining location.
pprFamInst :: FamInst -> SDoc
data FamInst
data Type

-- | Take a ForAllTy apart, returning the list of tycovars and the result
--   type. This always succeeds, even if it returns only an empty list.
--   Note that the result type returned may have free variables that were
--   bound by a forall.
splitForAllTyCoVars :: Type -> ([TyCoVar], Type)

-- | Extract the function result type and panic if that is not possible
funResultTy :: Type -> Type
pprParendType :: Type -> SDoc
pprTypeApp :: TyCon -> [Type] -> SDoc

-- | The key type representing kinds in the compiler.
type Kind = Type

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]
pprForAll :: [TyCoVarBinder] -> SDoc
pprThetaArrowTy :: ThetaType -> SDoc
parseInstanceHead :: GhcMonad m => String -> m Type
getInstancesForType :: GhcMonad m => Type -> m [ClsInst]

-- | A global typecheckable-thing, essentially anything that has a name.
--   Not to be confused with a <tt>TcTyThing</tt>, which is also a
--   typecheckable thing but in the *local* context. See
--   <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a> given a
--   <a>Name</a>.
data TyThing
AnId :: Id -> TyThing
AConLike :: ConLike -> TyThing
ATyCon :: TyCon -> TyThing
ACoAxiom :: CoAxiom Branched -> TyThing
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection
defaultFixity :: Fixity
maxPrecedence :: Int
negateFixity :: Fixity
compareFixity :: Fixity -> Fixity -> (Bool, Bool)

-- | Captures the fixity of declarations as they are parsed. This is not
--   necessarily the same as the fixity declaration, as the normal fixity
--   may be overridden using parens or backticks.
data LexicalFixity
Prefix :: LexicalFixity
Infix :: LexicalFixity

-- | Source Location
data SrcLoc
RealSrcLoc :: !RealSrcLoc -> !Maybe BufPos -> SrcLoc
UnhelpfulLoc :: FastString -> SrcLoc

-- | Real Source Location
--   
--   Represents a single point within a file
data RealSrcLoc
mkSrcLoc :: FastString -> Int -> Int -> SrcLoc

-- | Built-in "bad" <a>SrcLoc</a> values for particular locations
noSrcLoc :: SrcLoc

-- | Gives the filename of the <a>SrcLoc</a>
srcLocFile :: RealSrcLoc -> FastString

-- | Raises an error when used on a "bad" <a>SrcLoc</a>
srcLocLine :: RealSrcLoc -> Int

-- | Raises an error when used on a "bad" <a>SrcLoc</a>
srcLocCol :: RealSrcLoc -> Int

-- | Source Span
--   
--   A <a>SrcSpan</a> identifies either a specific portion of a text file
--   or a human-readable description of a location.
data SrcSpan
RealSrcSpan :: !RealSrcSpan -> !Maybe BufSpan -> SrcSpan
UnhelpfulSpan :: !UnhelpfulSpanReason -> SrcSpan

-- | A <a>SrcSpan</a> delimits a portion of a text file. It could be
--   represented by a pair of (line,column) coordinates, but in fact we
--   optimise slightly by using more compact representations for
--   single-line and zero-length spans, both of which are quite common.
--   
--   The end position is defined to be the column <i>after</i> the end of
--   the span. That is, a span of (1,1)-(1,2) is one character long, and a
--   span of (1,1)-(1,1) is zero characters long.
--   
--   Real Source Span
data RealSrcSpan

-- | Create a <a>SrcSpan</a> between two points in a file
mkSrcSpan :: SrcLoc -> SrcLoc -> SrcSpan

-- | Create a <a>SrcSpan</a> corresponding to a single point
srcLocSpan :: SrcLoc -> SrcSpan

-- | Test if a <a>SrcSpan</a> is "good", i.e. has precise location
--   information
isGoodSrcSpan :: SrcSpan -> Bool

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
noSrcSpan :: SrcSpan

-- | Returns the location at the start of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanStart :: SrcSpan -> SrcLoc

-- | Returns the location at the end of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanEnd :: SrcSpan -> SrcLoc
srcSpanFile :: RealSrcSpan -> FastString
srcSpanStartLine :: RealSrcSpan -> Int
srcSpanEndLine :: RealSrcSpan -> Int
srcSpanStartCol :: RealSrcSpan -> Int
srcSpanEndCol :: RealSrcSpan -> Int

-- | We attach SrcSpans to lots of things, so let's have a datatype for it.
data GenLocated l e
L :: l -> e -> GenLocated l e
type Located = GenLocated SrcSpan
type RealLocated = GenLocated RealSrcSpan
noLoc :: e -> Located e
mkGeneralLocated :: String -> e -> Located e
getLoc :: GenLocated l e -> l
unLoc :: GenLocated l e -> e
getRealSrcSpan :: RealLocated a -> RealSrcSpan
unRealSrcSpan :: RealLocated a -> a

-- | Tests whether the two located things are equal
eqLocated :: Eq a => GenLocated l a -> GenLocated l a -> Bool

-- | Tests the ordering of the two located things
cmpLocated :: Ord a => GenLocated l a -> GenLocated l a -> Ordering
combineLocs :: Located a -> Located b -> SrcSpan

-- | Combine locations from two <a>Located</a> things and add them to a
--   third thing
addCLoc :: Located a -> Located b -> c -> Located c

-- | Strategies for ordering <a>SrcSpan</a>s
leftmost_smallest :: SrcSpan -> SrcSpan -> Ordering

-- | Strategies for ordering <a>SrcSpan</a>s
leftmost_largest :: SrcSpan -> SrcSpan -> Ordering

-- | Strategies for ordering <a>SrcSpan</a>s
rightmost_smallest :: SrcSpan -> SrcSpan -> Ordering

-- | Determines whether a span encloses a given line and column index
spans :: SrcSpan -> (Int, Int) -> Bool

-- | Determines whether a span is enclosed by another one
isSubspanOf :: SrcSpan -> SrcSpan -> Bool

-- | GHC's own exception type error messages all take the form:
--   
--   <pre>
--   &lt;location&gt;: &lt;error&gt;
--   
--   </pre>
--   
--   If the location is on the command line, or in GHC itself, then
--   &lt;location&gt;="ghc". All of the error types below correspond to a
--   &lt;location&gt; of "ghc", except for ProgramError (where the string
--   is assumed to contain a location already, so we don't print one).
data GhcException

-- | Some other fatal signal (SIGHUP,SIGTERM)
Signal :: Int -> GhcException

-- | Prints the short usage msg after the error
UsageError :: String -> GhcException

-- | A problem with the command line arguments, but don't print usage.
CmdLineError :: String -> GhcException

-- | The <tt>impossible</tt> happened.
Panic :: String -> GhcException
PprPanic :: String -> SDoc -> GhcException

-- | The user tickled something that's known not to work yet, but we're not
--   counting it as a bug.
Sorry :: String -> GhcException
PprSorry :: String -> SDoc -> GhcException

-- | An installation problem.
InstallationError :: String -> GhcException

-- | An error in the user's code, probably.
ProgramError :: String -> GhcException
PprProgramError :: String -> SDoc -> GhcException

-- | Append a description of the given exception to this string.
showGhcException :: SDocContext -> GhcException -> ShowS

-- | An error thrown if the GHC API is used in an incorrect fashion.
newtype GhcApiError
GhcApiError :: String -> GhcApiError
data Token

-- | Return module source as token stream, including comments.
--   
--   The module must be in the module graph and its source must be
--   available. Throws a <a>SourceError</a> on parse error.
getTokenStream :: GhcMonad m => Module -> m [Located Token]

-- | Give even more information on the source than <a>getTokenStream</a>
--   This function allows reconstructing the source completely with
--   <a>showRichTokenStream</a>.
getRichTokenStream :: GhcMonad m => Module -> m [(Located Token, String)]

-- | Take a rich token stream such as produced from
--   <a>getRichTokenStream</a> and return source code almost identical to
--   the original code (except for insignificant whitespace.)
showRichTokenStream :: [(Located Token, String)] -> String

-- | Given a source location and a StringBuffer corresponding to this
--   location, return a rich token stream with the source associated to the
--   tokens.
addSourceToTokens :: RealSrcLoc -> StringBuffer -> [Located Token] -> [(Located Token, String)]

-- | A pure interface to the module parser.
parser :: String -> DynFlags -> FilePath -> (WarningMessages, Either ErrorMessages (Located HsModule))

-- | Exact print annotations exist so that tools can perform source to
--   source conversions of Haskell code. They are used to keep track of the
--   various syntactic keywords that are not otherwise captured in the AST.
--   
--   The wiki page describing this feature is
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/api-annotations</a>
--   <a>https://gitlab.haskell.org/ghc/ghc/-/wikis/implementing-trees-that-grow/in-tree-api-annotations</a>
--   
--   Note: in general the names of these are taken from the corresponding
--   token, unless otherwise noted See note [exact print annotations] above
--   for details of the usage
data AnnKeywordId
AnnAnyclass :: AnnKeywordId
AnnAs :: AnnKeywordId
AnnAt :: AnnKeywordId

-- | <tt>!</tt>
AnnBang :: AnnKeywordId

-- | '`'
AnnBackquote :: AnnKeywordId
AnnBy :: AnnKeywordId

-- | case or lambda case
AnnCase :: AnnKeywordId
AnnClass :: AnnKeywordId

-- | '#)' or '#-}' etc
AnnClose :: AnnKeywordId

-- | '|)'
AnnCloseB :: AnnKeywordId

-- | '|)', unicode variant
AnnCloseBU :: AnnKeywordId

-- | '}'
AnnCloseC :: AnnKeywordId

-- | '|]'
AnnCloseQ :: AnnKeywordId

-- | '|]', unicode variant
AnnCloseQU :: AnnKeywordId

-- | ')'
AnnCloseP :: AnnKeywordId

-- | '#)'
AnnClosePH :: AnnKeywordId

-- | ']'
AnnCloseS :: AnnKeywordId
AnnColon :: AnnKeywordId

-- | as a list separator
AnnComma :: AnnKeywordId

-- | in a RdrName for a tuple
AnnCommaTuple :: AnnKeywordId

-- | '=&gt;'
AnnDarrow :: AnnKeywordId

-- | '=&gt;', unicode variant
AnnDarrowU :: AnnKeywordId
AnnData :: AnnKeywordId

-- | '::'
AnnDcolon :: AnnKeywordId

-- | '::', unicode variant
AnnDcolonU :: AnnKeywordId
AnnDefault :: AnnKeywordId
AnnDeriving :: AnnKeywordId
AnnDo :: AnnKeywordId

-- | <a>.</a>
AnnDot :: AnnKeywordId

-- | '..'
AnnDotdot :: AnnKeywordId
AnnElse :: AnnKeywordId
AnnEqual :: AnnKeywordId
AnnExport :: AnnKeywordId
AnnFamily :: AnnKeywordId
AnnForall :: AnnKeywordId

-- | Unicode variant
AnnForallU :: AnnKeywordId
AnnForeign :: AnnKeywordId

-- | for function name in matches where there are multiple equations for
--   the function.
AnnFunId :: AnnKeywordId
AnnGroup :: AnnKeywordId

-- | for CType
AnnHeader :: AnnKeywordId
AnnHiding :: AnnKeywordId
AnnIf :: AnnKeywordId
AnnImport :: AnnKeywordId
AnnIn :: AnnKeywordId

-- | 'infix' or 'infixl' or 'infixr'
AnnInfix :: AnnKeywordId
AnnInstance :: AnnKeywordId
AnnLam :: AnnKeywordId

-- | '&lt;-'
AnnLarrow :: AnnKeywordId

-- | '&lt;-', unicode variant
AnnLarrowU :: AnnKeywordId
AnnLet :: AnnKeywordId

-- | The <tt>â¸</tt> unicode arrow
AnnLollyU :: AnnKeywordId
AnnMdo :: AnnKeywordId

-- | <a>-</a>
AnnMinus :: AnnKeywordId
AnnModule :: AnnKeywordId
AnnNewtype :: AnnKeywordId

-- | where a name loses its location in the AST, this carries it
AnnName :: AnnKeywordId
AnnOf :: AnnKeywordId

-- | '{-# DEPRECATED' etc. Opening of pragmas where the capitalisation of
--   the string can be changed by the user. The actual text used is stored
--   in a <tt>SourceText</tt> on the relevant pragma item.
AnnOpen :: AnnKeywordId

-- | '(|'
AnnOpenB :: AnnKeywordId

-- | '(|', unicode variant
AnnOpenBU :: AnnKeywordId

-- | '{'
AnnOpenC :: AnnKeywordId

-- | '[e|' or '[e||'
AnnOpenE :: AnnKeywordId

-- | '[|'
AnnOpenEQ :: AnnKeywordId

-- | '[|', unicode variant
AnnOpenEQU :: AnnKeywordId

-- | '('
AnnOpenP :: AnnKeywordId

-- | '['
AnnOpenS :: AnnKeywordId

-- | '(#'
AnnOpenPH :: AnnKeywordId

-- | prefix <a>$</a> -- TemplateHaskell
AnnDollar :: AnnKeywordId

-- | prefix <a>$$</a> -- TemplateHaskell
AnnDollarDollar :: AnnKeywordId
AnnPackageName :: AnnKeywordId
AnnPattern :: AnnKeywordId

-- | <tt>%</tt> -- for HsExplicitMult
AnnPercent :: AnnKeywordId

-- | '%1' -- for HsLinearArrow
AnnPercentOne :: AnnKeywordId
AnnProc :: AnnKeywordId
AnnQualified :: AnnKeywordId

-- | <tt>-&gt;</tt>
AnnRarrow :: AnnKeywordId

-- | <tt>-&gt;</tt>, unicode variant
AnnRarrowU :: AnnKeywordId
AnnRec :: AnnKeywordId
AnnRole :: AnnKeywordId
AnnSafe :: AnnKeywordId

-- | ';'
AnnSemi :: AnnKeywordId

-- | '''
AnnSimpleQuote :: AnnKeywordId
AnnSignature :: AnnKeywordId

-- | <tt>static</tt>
AnnStatic :: AnnKeywordId
AnnStock :: AnnKeywordId
AnnThen :: AnnKeywordId

-- | double '''
AnnThTyQuote :: AnnKeywordId

-- | <tt>~</tt>
AnnTilde :: AnnKeywordId
AnnType :: AnnKeywordId

-- | <tt>()</tt> for types
AnnUnit :: AnnKeywordId
AnnUsing :: AnnKeywordId

-- | e.g. INTEGER
AnnVal :: AnnKeywordId

-- | String value, will need quotes when output
AnnValStr :: AnnKeywordId

-- | '|'
AnnVbar :: AnnKeywordId

-- | <tt>via</tt>
AnnVia :: AnnKeywordId
AnnWhere :: AnnKeywordId

-- | <tt>-&lt;</tt>
Annlarrowtail :: AnnKeywordId

-- | <tt>-&lt;</tt>, unicode variant
AnnlarrowtailU :: AnnKeywordId

-- | <tt>-&gt;</tt>
Annrarrowtail :: AnnKeywordId

-- | <tt>-&gt;</tt>, unicode variant
AnnrarrowtailU :: AnnKeywordId

-- | <tt>-&lt;&lt;</tt>
AnnLarrowtail :: AnnKeywordId

-- | <tt>-&lt;&lt;</tt>, unicode variant
AnnLarrowtailU :: AnnKeywordId

-- | <tt>&gt;&gt;-</tt>
AnnRarrowtail :: AnnKeywordId

-- | <tt>&gt;&gt;-</tt>, unicode variant
AnnRarrowtailU :: AnnKeywordId
data EpaComment
EpaComment :: EpaCommentTok -> RealSrcSpan -> EpaComment
[ac_tok] :: EpaComment -> EpaCommentTok

-- | The location of the prior token, used in exact printing. The
--   <a>EpaComment</a> appears as an <a>LEpaComment</a> containing its
--   location. The difference between the end of the prior token and the
--   start of this location is used for the spacing when exact printing the
--   comment.
[ac_prior_tok] :: EpaComment -> RealSrcSpan
cyclicModuleErr :: [ModuleGraphNode] -> SDoc
instance GHC.Show.Show GHC.GhcApiError
instance GHC.Exception.Type.Exception GHC.GhcApiError
instance GHC.DesugaredMod GHC.DesugaredModule
instance GHC.TypecheckedMod GHC.TypecheckedModule
instance GHC.TypecheckedMod GHC.DesugaredModule
instance GHC.ParsedMod GHC.DesugaredModule
instance GHC.ParsedMod GHC.TypecheckedModule
instance GHC.Utils.Outputable.Outputable GHC.CoreModule
instance GHC.ParsedMod GHC.ParsedModule

module GHC.Runtime.Debugger

-- | The :print &amp; friends commands
pprintClosureCommand :: GhcMonad m => Bool -> Bool -> String -> m ()
showTerm :: GhcMonad m => Term -> m SDoc
pprTypeAndContents :: GhcMonad m => Id -> m SDoc

module GHC.Driver.MakeFile
doMkDependHS :: GhcMonad m => [FilePath] -> m ()


-- | This is the driver for the 'ghc --backpack' mode, which is a
--   reimplementation of the "package manager" bits of Backpack directly in
--   GHC. The basic method of operation is to compile packages and then
--   directly insert them into GHC's in memory database.
--   
--   The compilation products of this mode aren't really suitable for
--   Cabal, because GHC makes up component IDs for the things it builds and
--   doesn't serialize out the database contents. But it's still handy for
--   constructing tests.
module GHC.Driver.Backpack

-- | Entry point to compile a Backpack file.
doBackpack :: [FilePath] -> Ghc ()
instance GHC.Classes.Eq GHC.Driver.Backpack.SessionType
instance GHC.Driver.Session.HasDynFlags GHC.Driver.Backpack.BkpM
instance GHC.Utils.Logger.HasLogger GHC.Driver.Backpack.BkpM
instance GHC.Driver.Monad.GhcMonad GHC.Driver.Backpack.BkpM

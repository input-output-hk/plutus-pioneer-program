<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core/Opt/DmdAnal.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The GRASP/AQUA Project, Glasgow University, 1993-1998
<a name="line-3"></a>
<a name="line-4"></a>
<a name="line-5"></a>                        -----------------
<a name="line-6"></a>                        A demand analysis
<a name="line-7"></a>                        -----------------
<a name="line-8"></a>-}</span>
<a name="line-9"></a>
<a name="line-10"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-11"></a>
<a name="line-12"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.Opt.DmdAnal</span>
<a name="line-13"></a>   <span class='hs-layout'>(</span> <span class='hs-conid'>DmdAnalOpts</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span>
<a name="line-14"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>dmdAnalProgram</span>
<a name="line-15"></a>   <span class='hs-layout'>)</span>
<a name="line-16"></a><span class='hs-keyword'>where</span>
<a name="line-17"></a>
<a name="line-18"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-19"></a>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-21"></a>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.WorkWrap.Utils</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Demand</span>   <span class='hs-comment'>-- All of it</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Multiplicity</span> <span class='hs-layout'>(</span> <span class='hs-varid'>scaledThing</span> <span class='hs-layout'>)</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Env</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Set</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List</span>        <span class='hs-layout'>(</span> <span class='hs-varid'>mapAccumL</span> <span class='hs-layout'>)</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.DataCon</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.ForeignCall</span> <span class='hs-layout'>(</span> <span class='hs-varid'>isSafeForeignCall</span> <span class='hs-layout'>)</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Utils</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCon</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FVs</span>      <span class='hs-layout'>(</span> <span class='hs-varid'>rulesRhsFreeIds</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrRuleAndUnfoldingIds</span> <span class='hs-layout'>)</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>,</span> <span class='hs-varid'>coVarsOfCo</span> <span class='hs-layout'>)</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FamInstEnv</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.Arity</span> <span class='hs-layout'>(</span> <span class='hs-varid'>typeArity</span> <span class='hs-layout'>)</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Maybe</span>         <span class='hs-layout'>(</span> <span class='hs-varid'>isJust</span> <span class='hs-layout'>)</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.PrimOps</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Types.Prim</span> <span class='hs-layout'>(</span> <span class='hs-varid'>realWorldStatePrimTy</span> <span class='hs-layout'>)</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique.Set</span>
<a name="line-47"></a>
<a name="line-48"></a><span class='hs-comment'>-- import GHC.Driver.Ppr</span>
<a name="line-49"></a>
<a name="line-50"></a><span class='hs-comment'>{-
<a name="line-51"></a>************************************************************************
<a name="line-52"></a>*                                                                      *
<a name="line-53"></a>\subsection{Top level stuff}
<a name="line-54"></a>*                                                                      *
<a name="line-55"></a>************************************************************************
<a name="line-56"></a>-}</span>
<a name="line-57"></a>
<a name="line-58"></a><a name="DmdAnalOpts"></a><span class='hs-comment'>-- | Options for the demand analysis</span>
<a name="line-59"></a><a name="DmdAnalOpts"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>DmdAnalOpts</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DmdAnalOpts</span>
<a name="line-60"></a>   <span class='hs-layout'>{</span> <span class='hs-varid'>dmd_strict_dicts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-comment'>-- ^ Use strict dictionaries</span>
<a name="line-61"></a>   <span class='hs-layout'>}</span>
<a name="line-62"></a>
<a name="line-63"></a><a name="WithDmdType"></a><span class='hs-comment'>-- This is a strict alternative to (,)</span>
<a name="line-64"></a><a name="WithDmdType"></a><span class='hs-comment'>-- See Note [Space Leaks in Demand Analysis]</span>
<a name="line-65"></a><a name="WithDmdType"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varop'>!</span><span class='hs-conid'>DmdType</span> <span class='hs-varop'>!</span><span class='hs-varid'>a</span>
<a name="line-66"></a>
<a name="line-67"></a><a name="getAnnotated"></a><span class='hs-definition'>getAnnotated</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-68"></a><span class='hs-definition'>getAnnotated</span> <span class='hs-layout'>(</span><span class='hs-conid'>WithDmdType</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span>
<a name="line-69"></a>
<a name="line-70"></a><a name="DmdResult"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>DmdResult</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>R</span> <span class='hs-varop'>!</span><span class='hs-varid'>a</span> <span class='hs-varop'>!</span><span class='hs-varid'>b</span>
<a name="line-71"></a>
<a name="line-72"></a><a name="dmdAnalProgram"></a><span class='hs-comment'>-- | Outputs a new copy of the Core program in which binders have been annotated</span>
<a name="line-73"></a><span class='hs-comment'>-- with demand and strictness information.</span>
<a name="line-74"></a><span class='hs-comment'>--</span>
<a name="line-75"></a><span class='hs-comment'>-- Note: use `seqBinds` on the result to avoid leaks due to lazyness (cf Note</span>
<a name="line-76"></a><span class='hs-comment'>-- [Stamp out space leaks in demand analysis])</span>
<a name="line-77"></a><span class='hs-definition'>dmdAnalProgram</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DmdAnalOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreProgram</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreProgram</span>
<a name="line-78"></a><span class='hs-definition'>dmdAnalProgram</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>rules</span> <span class='hs-varid'>binds</span>
<a name="line-79"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getAnnotated</span> <span class='hs-varop'>$</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyAnalEnv</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>fam_envs</span><span class='hs-layout'>)</span> <span class='hs-varid'>binds</span>
<a name="line-80"></a>  <span class='hs-keyword'>where</span>
<a name="line-81"></a>    <span class='hs-comment'>-- See Note [Analysing top-level bindings]</span>
<a name="line-82"></a>    <span class='hs-comment'>-- and Note [Why care for top-level demand annotations?]</span>
<a name="line-83"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>   <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>nopDmdType</span> <span class='hs-conid'>[]</span>
<a name="line-84"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cons_up</span> <span class='hs-varop'>$</span> <span class='hs-varid'>dmdAnalBind</span> <span class='hs-conid'>TopLevel</span> <span class='hs-varid'>env</span> <span class='hs-varid'>topSubDmd</span> <span class='hs-varid'>b</span> <span class='hs-varid'>anal_body</span>
<a name="line-85"></a>      <span class='hs-keyword'>where</span>
<a name="line-86"></a>        <span class='hs-varid'>anal_body</span> <span class='hs-varid'>env'</span>
<a name="line-87"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>bs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>bs</span>
<a name="line-88"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-layout'>(</span><span class='hs-varid'>add_exported_uses</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>body_ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>bindersOf</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>bs'</span>
<a name="line-89"></a>
<a name="line-90"></a>    <span class='hs-varid'>cons_up</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdResult</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-91"></a>    <span class='hs-varid'>cons_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>R</span> <span class='hs-varid'>b'</span> <span class='hs-varid'>bs'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>b'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs'</span><span class='hs-layout'>)</span>
<a name="line-92"></a>
<a name="line-93"></a>    <span class='hs-varid'>add_exported_uses</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span>
<a name="line-94"></a>    <span class='hs-varid'>add_exported_uses</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-layout'>(</span><span class='hs-varid'>add_exported_use</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-95"></a>
<a name="line-96"></a>    <span class='hs-comment'>-- | If @e@ is denoted by @dmd_ty@, then @add_exported_use _ dmd_ty id@</span>
<a name="line-97"></a>    <span class='hs-comment'>-- corresponds to the demand type of @(id, e)@, but is a lot more direct.</span>
<a name="line-98"></a>    <span class='hs-comment'>-- See Note [Analysing top-level bindings].</span>
<a name="line-99"></a>    <span class='hs-varid'>add_exported_use</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span>
<a name="line-100"></a>    <span class='hs-varid'>add_exported_use</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>id</span>
<a name="line-101"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isExportedId</span> <span class='hs-varid'>id</span> <span class='hs-varop'>||</span> <span class='hs-varid'>elemVarSet</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rule_fvs</span>
<a name="line-102"></a>      <span class='hs-comment'>-- See Note [Absence analysis for stable unfoldings and RULES]</span>
<a name="line-103"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varop'>`plusDmdType`</span> <span class='hs-varid'>fst</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmdAnalStar</span> <span class='hs-varid'>env</span> <span class='hs-varid'>topDmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-104"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-105"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd_ty</span>
<a name="line-106"></a>
<a name="line-107"></a>    <span class='hs-varid'>rule_fvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IdSet</span>
<a name="line-108"></a>    <span class='hs-varid'>rule_fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rulesRhsFreeIds</span> <span class='hs-varid'>rules</span>
<a name="line-109"></a>
<a name="line-110"></a><a name="isInterestingTopLevelFn"></a><span class='hs-comment'>-- | We attach useful (e.g. not 'topDmd') 'idDemandInfo' to top-level bindings</span>
<a name="line-111"></a><span class='hs-comment'>-- that satisfy this function.</span>
<a name="line-112"></a><span class='hs-comment'>--</span>
<a name="line-113"></a><span class='hs-comment'>-- Basically, we want to know how top-level *functions* are *used*</span>
<a name="line-114"></a><span class='hs-comment'>-- (e.g. called). The information will always be lazy.</span>
<a name="line-115"></a><span class='hs-comment'>-- Any other top-level bindings are boring.</span>
<a name="line-116"></a><span class='hs-comment'>--</span>
<a name="line-117"></a><span class='hs-comment'>-- See also Note [Why care for top-level demand annotations?].</span>
<a name="line-118"></a><span class='hs-definition'>isInterestingTopLevelFn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-119"></a><span class='hs-comment'>-- SG tried to set this to True and got a +2% ghc/alloc regression in T5642</span>
<a name="line-120"></a><span class='hs-comment'>-- (which is dominated by the Simplifier) at no gain in analysis precision.</span>
<a name="line-121"></a><span class='hs-comment'>-- If there was a gain, that regression might be acceptable.</span>
<a name="line-122"></a><span class='hs-comment'>-- Plus, we could use LetUp for thunks and share some code with local let</span>
<a name="line-123"></a><span class='hs-comment'>-- bindings.</span>
<a name="line-124"></a><span class='hs-definition'>isInterestingTopLevelFn</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span>
<a name="line-125"></a>  <span class='hs-varid'>typeArity</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-varop'>`lengthExceeds`</span> <span class='hs-num'>0</span>
<a name="line-126"></a>
<a name="line-127"></a><span class='hs-comment'>{- Note [Stamp out space leaks in demand analysis]
<a name="line-128"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-129"></a>The demand analysis pass outputs a new copy of the Core program in
<a name="line-130"></a>which binders have been annotated with demand and strictness
<a name="line-131"></a>information. It's tiresome to ensure that this information is fully
<a name="line-132"></a>evaluated everywhere that we produce it, so we just run a single
<a name="line-133"></a>seqBinds over the output before returning it, to ensure that there are
<a name="line-134"></a>no references holding on to the input Core program.
<a name="line-135"></a>
<a name="line-136"></a>This makes a ~30% reduction in peak memory usage when compiling
<a name="line-137"></a>DynFlags (cf #9675 and #13426).
<a name="line-138"></a>
<a name="line-139"></a>This is particularly important when we are doing late demand analysis,
<a name="line-140"></a>since we don't do a seqBinds at any point thereafter. Hence code
<a name="line-141"></a>generation would hold on to an extra copy of the Core program, via
<a name="line-142"></a>unforced thunks in demand or strictness information; and it is the
<a name="line-143"></a>most memory-intensive part of the compilation process, so this added
<a name="line-144"></a>seqBinds makes a big difference in peak memory usage.
<a name="line-145"></a>
<a name="line-146"></a>Note [Analysing top-level bindings]
<a name="line-147"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-148"></a>Consider a CoreProgram like
<a name="line-149"></a>  e1 = ...
<a name="line-150"></a>  n1 = ...
<a name="line-151"></a>  e2 = \a b -&gt; ... fst (n1 a b) ...
<a name="line-152"></a>  n2 = \c d -&gt; ... snd (e2 c d) ...
<a name="line-153"></a>  ...
<a name="line-154"></a>where e* are exported, but n* are not.
<a name="line-155"></a>Intuitively, we can see that @n1@ is only ever called with two arguments
<a name="line-156"></a>and in every call site, the first component of the result of the call
<a name="line-157"></a>is evaluated. Thus, we'd like it to have idDemandInfo @LCL(CM(P(1L,A))@.
<a name="line-158"></a>NB: We may *not* give e2 a similar annotation, because it is exported and
<a name="line-159"></a>external callers might use it in arbitrary ways, expressed by 'topDmd'.
<a name="line-160"></a>This can then be exploited by Nested CPR and eta-expansion,
<a name="line-161"></a>see Note [Why care for top-level demand annotations?].
<a name="line-162"></a>
<a name="line-163"></a>How do we get this result? Answer: By analysing the program as if it was a let
<a name="line-164"></a>expression of this form:
<a name="line-165"></a>  let e1 = ... in
<a name="line-166"></a>  let n1 = ... in
<a name="line-167"></a>  let e2 = ... in
<a name="line-168"></a>  let n2 = ... in
<a name="line-169"></a>  (e1,e2, ...)
<a name="line-170"></a>E.g. putting all bindings in nested lets and returning all exported binders in a tuple.
<a name="line-171"></a>Of course, we will not actually build that CoreExpr! Instead we faithfully
<a name="line-172"></a>simulate analysis of said expression by adding the free variable 'DmdEnv'
<a name="line-173"></a>of @e*@'s strictness signatures to the 'DmdType' we get from analysing the
<a name="line-174"></a>nested bindings.
<a name="line-175"></a>
<a name="line-176"></a>And even then the above form blows up analysis performance in T10370:
<a name="line-177"></a>If @e1@ uses many free variables, we'll unnecessarily carry their demands around
<a name="line-178"></a>with us from the moment we analyse the pair to the moment we bubble back up to
<a name="line-179"></a>the binding for @e1@. So instead we analyse as if we had
<a name="line-180"></a>  let e1 = ... in
<a name="line-181"></a>  (e1, let n1 = ... in
<a name="line-182"></a>  (    let e2 = ... in
<a name="line-183"></a>  (e2, let n2 = ... in
<a name="line-184"></a>  (    ...))))
<a name="line-185"></a>That is, a series of right-nested pairs, where the @fst@ are the exported
<a name="line-186"></a>binders of the last enclosing let binding and @snd@ continues the nested
<a name="line-187"></a>lets.
<a name="line-188"></a>
<a name="line-189"></a>Variables occurring free in RULE RHSs are to be handled the same as exported Ids.
<a name="line-190"></a>See also Note [Absence analysis for stable unfoldings and RULES].
<a name="line-191"></a>
<a name="line-192"></a>Note [Why care for top-level demand annotations?]
<a name="line-193"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-194"></a>Reading Note [Analysing top-level bindings], you might think that we go through
<a name="line-195"></a>quite some trouble to get useful demands for top-level bindings. They can never
<a name="line-196"></a>be strict, for example, so why bother?
<a name="line-197"></a>
<a name="line-198"></a>First, we get to eta-expand top-level bindings that we weren't able to
<a name="line-199"></a>eta-expand before without Call Arity. From T18894b:
<a name="line-200"></a>  module T18894b (f) where
<a name="line-201"></a>  eta :: Int -&gt; Int -&gt; Int
<a name="line-202"></a>  eta x = if fst (expensive x) == 13 then \y -&gt; ... else \y -&gt; ...
<a name="line-203"></a>  f m = ... eta m 2 ... eta 2 m ...
<a name="line-204"></a>Since only @f@ is exported, we see all call sites of @eta@ and can eta-expand to
<a name="line-205"></a>arity 2.
<a name="line-206"></a>
<a name="line-207"></a>The call demands we get for some top-level bindings will also allow Nested CPR
<a name="line-208"></a>to unbox deeper. From T18894:
<a name="line-209"></a>  module T18894 (h) where
<a name="line-210"></a>  g m n = (2 * m, 2 `div` n)
<a name="line-211"></a>  {-# NOINLINE g #-}
<a name="line-212"></a>  h :: Int -&gt; Int
<a name="line-213"></a>  h m = ... snd (g m 2) ... uncurry (+) (g 2 m) ...
<a name="line-214"></a>Only @h@ is exported, hence we see that @g@ is always called in contexts were we
<a name="line-215"></a>also force the division in the second component of the pair returned by @g@.
<a name="line-216"></a>This allows Nested CPR to evaluate the division eagerly and return an I# in its
<a name="line-217"></a>position.
<a name="line-218"></a>-}</span>
<a name="line-219"></a>
<a name="line-220"></a><span class='hs-comment'>{-
<a name="line-221"></a>************************************************************************
<a name="line-222"></a>*                                                                      *
<a name="line-223"></a>\subsection{The analyser itself}
<a name="line-224"></a>*                                                                      *
<a name="line-225"></a>************************************************************************
<a name="line-226"></a>-}</span>
<a name="line-227"></a>
<a name="line-228"></a><a name="dmdAnalBind"></a><span class='hs-comment'>-- | Analyse a binding group and its \"body\", e.g. where it is in scope.</span>
<a name="line-229"></a><span class='hs-comment'>--</span>
<a name="line-230"></a><span class='hs-comment'>-- It calls a function that knows how to analyse this \"body\" given</span>
<a name="line-231"></a><span class='hs-comment'>-- an 'AnalEnv' with updated demand signatures for the binding group</span>
<a name="line-232"></a><span class='hs-comment'>-- (reflecting their 'idStrictnessInfo') and expects to receive a</span>
<a name="line-233"></a><span class='hs-comment'>-- 'DmdType' in return, which it uses to annotate the binding group with their</span>
<a name="line-234"></a><span class='hs-comment'>-- 'idDemandInfo'.</span>
<a name="line-235"></a><span class='hs-definition'>dmdAnalBind</span>
<a name="line-236"></a>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-237"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-238"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SubDemand</span>                 <span class='hs-comment'>-- ^ Demand put on the "body"</span>
<a name="line-239"></a>                               <span class='hs-comment'>--   (important for join points)</span>
<a name="line-240"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span>
<a name="line-241"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- ^ How to analyse the "body", e.g.</span>
<a name="line-242"></a>                               <span class='hs-comment'>--   where the binding is in scope</span>
<a name="line-243"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdResult</span> <span class='hs-conid'>CoreBind</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-244"></a><span class='hs-definition'>dmdAnalBind</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>bind</span> <span class='hs-varid'>anal_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>bind</span> <span class='hs-keyword'>of</span>
<a name="line-245"></a>  <span class='hs-conid'>NonRec</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-246"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>useLetUp</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>id</span>
<a name="line-247"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>dmdAnalBindLetUp</span>   <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span>     <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>anal_body</span>
<a name="line-248"></a>  <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>dmdAnalBindLetDown</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>bind</span>   <span class='hs-varid'>anal_body</span>
<a name="line-249"></a>
<a name="line-250"></a><a name="setBindIdDemandInfo"></a><span class='hs-comment'>-- | Annotates uninteresting top level functions ('isInterestingTopLevelFn')</span>
<a name="line-251"></a><span class='hs-comment'>-- with 'topDmd', the rest with the given demand.</span>
<a name="line-252"></a><span class='hs-definition'>setBindIdDemandInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-253"></a><span class='hs-definition'>setBindIdDemandInfo</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>id</span> <span class='hs-varid'>dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdDemandInfo</span> <span class='hs-varid'>id</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>top_lvl</span> <span class='hs-keyword'>of</span>
<a name="line-254"></a>  <span class='hs-conid'>TopLevel</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isInterestingTopLevelFn</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>topDmd</span>
<a name="line-255"></a>  <span class='hs-keyword'>_</span>                                           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>dmd</span>
<a name="line-256"></a>
<a name="line-257"></a><a name="dmdAnalBindLetUp"></a><span class='hs-comment'>-- | Let bindings can be processed in two ways:</span>
<a name="line-258"></a><span class='hs-comment'>-- Down (RHS before body) or Up (body before RHS).</span>
<a name="line-259"></a><span class='hs-comment'>-- This function handles the up variant.</span>
<a name="line-260"></a><span class='hs-comment'>--</span>
<a name="line-261"></a><span class='hs-comment'>-- It is very simple. For  let x = rhs in body</span>
<a name="line-262"></a><span class='hs-comment'>--   * Demand-analyse 'body' in the current environment</span>
<a name="line-263"></a><span class='hs-comment'>--   * Find the demand, 'rhs_dmd' placed on 'x' by 'body'</span>
<a name="line-264"></a><span class='hs-comment'>--   * Demand-analyse 'rhs' in 'rhs_dmd'</span>
<a name="line-265"></a><span class='hs-comment'>--</span>
<a name="line-266"></a><span class='hs-comment'>-- This is used for a non-recursive local let without manifest lambdas (see</span>
<a name="line-267"></a><span class='hs-comment'>-- 'useLetUp').</span>
<a name="line-268"></a><span class='hs-comment'>--</span>
<a name="line-269"></a><span class='hs-comment'>-- This is the LetUp rule in the paper “Higher-Order Cardinality Analysis”.</span>
<a name="line-270"></a><span class='hs-definition'>dmdAnalBindLetUp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-271"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-272"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-273"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-274"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-275"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdResult</span> <span class='hs-conid'>CoreBind</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-276"></a><span class='hs-definition'>dmdAnalBindLetUp</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>anal_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>final_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>R</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>id'</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>body'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-277"></a>  <span class='hs-keyword'>where</span>
<a name="line-278"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>body'</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>anal_body</span> <span class='hs-varid'>env</span>
<a name="line-279"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>body_ty'</span> <span class='hs-varid'>id_dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findBndrDmd</span> <span class='hs-varid'>env</span> <span class='hs-varid'>notArgOfDfun</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>id</span>
<a name="line-280"></a>    <span class='hs-varop'>!</span><span class='hs-varid'>id'</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setBindIdDemandInfo</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>id</span> <span class='hs-varid'>id_dmd</span>
<a name="line-281"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalStar</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmdTransformThunkDmd</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>id_dmd</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span>
<a name="line-282"></a>
<a name="line-283"></a>    <span class='hs-comment'>-- See Note [Absence analysis for stable unfoldings and RULES]</span>
<a name="line-284"></a>    <span class='hs-varid'>rule_fvs</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrRuleAndUnfoldingIds</span> <span class='hs-varid'>id</span>
<a name="line-285"></a>    <span class='hs-varid'>final_ty</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body_ty'</span> <span class='hs-varop'>`plusDmdType`</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varop'>`keepAliveDmdType`</span> <span class='hs-varid'>rule_fvs</span>
<a name="line-286"></a>
<a name="line-287"></a><a name="dmdAnalBindLetDown"></a><span class='hs-comment'>-- | Let bindings can be processed in two ways:</span>
<a name="line-288"></a><span class='hs-comment'>-- Down (RHS before body) or Up (body before RHS).</span>
<a name="line-289"></a><span class='hs-comment'>-- This function handles the down variant.</span>
<a name="line-290"></a><span class='hs-comment'>--</span>
<a name="line-291"></a><span class='hs-comment'>-- It computes a demand signature (by means of 'dmdAnalRhsSig') and uses</span>
<a name="line-292"></a><span class='hs-comment'>-- that at call sites in the body.</span>
<a name="line-293"></a><span class='hs-comment'>--</span>
<a name="line-294"></a><span class='hs-comment'>-- It is used for toplevel definitions, recursive definitions and local</span>
<a name="line-295"></a><span class='hs-comment'>-- non-recursive definitions that have manifest lambdas (cf. 'useLetUp').</span>
<a name="line-296"></a><span class='hs-comment'>-- Local non-recursive definitions without a lambda are handled with LetUp.</span>
<a name="line-297"></a><span class='hs-comment'>--</span>
<a name="line-298"></a><span class='hs-comment'>-- This is the LetDown rule in the paper “Higher-Order Cardinality Analysis”.</span>
<a name="line-299"></a><span class='hs-definition'>dmdAnalBindLetDown</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SubDemand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdResult</span> <span class='hs-conid'>CoreBind</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-300"></a><span class='hs-definition'>dmdAnalBindLetDown</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>bind</span> <span class='hs-varid'>anal_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>bind</span> <span class='hs-keyword'>of</span>
<a name="line-301"></a>  <span class='hs-conid'>NonRec</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-302"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>id1</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span>
<a name="line-303"></a>        <span class='hs-varid'>dmdAnalRhsSig</span> <span class='hs-varid'>top_lvl</span> <span class='hs-conid'>NonRecursive</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-304"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>do_rest</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>lazy_fv</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>id1</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs1</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>uncurry</span> <span class='hs-conid'>NonRec</span> <span class='hs-varop'>.</span> <span class='hs-varid'>only</span><span class='hs-layout'>)</span>
<a name="line-305"></a>  <span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span>
<a name="line-306"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dmdFix</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>pairs</span>
<a name="line-307"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>do_rest</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>lazy_fv</span> <span class='hs-varid'>pairs'</span> <span class='hs-conid'>Rec</span>
<a name="line-308"></a>  <span class='hs-keyword'>where</span>
<a name="line-309"></a>    <span class='hs-varid'>do_rest</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>lazy_fv</span> <span class='hs-varid'>pairs1</span> <span class='hs-varid'>build_bind</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>final_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>R</span> <span class='hs-layout'>(</span><span class='hs-varid'>build_bind</span> <span class='hs-varid'>pairs2</span><span class='hs-layout'>)</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-310"></a>      <span class='hs-keyword'>where</span>
<a name="line-311"></a>        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>body'</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>anal_body</span> <span class='hs-varid'>env'</span>
<a name="line-312"></a>        <span class='hs-comment'>-- see Note [Lazy and unleashable free variables]</span>
<a name="line-313"></a>        <span class='hs-varid'>dmd_ty</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addLazyFVs</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>lazy_fv</span>
<a name="line-314"></a>        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>final_ty</span> <span class='hs-varid'>id_dmds</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findBndrsDmds</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>strictMap</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>pairs1</span><span class='hs-layout'>)</span>
<a name="line-315"></a>        <span class='hs-comment'>-- Important to force this as build_bind might not force it.</span>
<a name="line-316"></a>        <span class='hs-varop'>!</span><span class='hs-varid'>pairs2</span>                         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>strictZipWith</span> <span class='hs-varid'>do_one</span> <span class='hs-varid'>pairs1</span> <span class='hs-varid'>id_dmds</span>
<a name="line-317"></a>        <span class='hs-varid'>do_one</span> <span class='hs-layout'>(</span><span class='hs-varid'>id'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-varid'>dmd</span>          <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,)</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>setBindIdDemandInfo</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>id'</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>rhs'</span>
<a name="line-318"></a>        <span class='hs-comment'>-- If the actual demand is better than the vanilla call</span>
<a name="line-319"></a>        <span class='hs-comment'>-- demand, you might think that we might do better to re-analyse</span>
<a name="line-320"></a>        <span class='hs-comment'>-- the RHS with the stronger demand.</span>
<a name="line-321"></a>        <span class='hs-comment'>-- But (a) That seldom happens, because it means that *every* path in</span>
<a name="line-322"></a>        <span class='hs-comment'>--         the body of the let has to use that stronger demand</span>
<a name="line-323"></a>        <span class='hs-comment'>-- (b) It often happens temporarily in when fixpointing, because</span>
<a name="line-324"></a>        <span class='hs-comment'>--     the recursive function at first seems to place a massive demand.</span>
<a name="line-325"></a>        <span class='hs-comment'>--     But we don't want to go to extra work when the function will</span>
<a name="line-326"></a>        <span class='hs-comment'>--     probably iterate to something less demanding.</span>
<a name="line-327"></a>        <span class='hs-comment'>-- In practice, all the times the actual demand on id2 is more than</span>
<a name="line-328"></a>        <span class='hs-comment'>-- the vanilla call demand seem to be due to (b).  So we don't</span>
<a name="line-329"></a>        <span class='hs-comment'>-- bother to re-analyse the RHS.</span>
<a name="line-330"></a>
<a name="line-331"></a><a name="dmdTransformThunkDmd"></a><span class='hs-comment'>-- If e is complicated enough to become a thunk, its contents will be evaluated</span>
<a name="line-332"></a><span class='hs-comment'>-- at most once, so oneify it.</span>
<a name="line-333"></a><span class='hs-definition'>dmdTransformThunkDmd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span>
<a name="line-334"></a><span class='hs-definition'>dmdTransformThunkDmd</span> <span class='hs-varid'>e</span>
<a name="line-335"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span>
<a name="line-336"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>oneifyDmd</span>
<a name="line-337"></a>
<a name="line-338"></a><a name="dmdAnalStar"></a><span class='hs-comment'>-- Do not process absent demands</span>
<a name="line-339"></a><span class='hs-comment'>-- Otherwise act like in a normal demand analysis</span>
<a name="line-340"></a><span class='hs-comment'>-- See ↦* relation in the Cardinality Analysis paper</span>
<a name="line-341"></a><span class='hs-definition'>dmdAnalStar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-342"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span>   <span class='hs-comment'>-- This one takes a *Demand*</span>
<a name="line-343"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-comment'>-- Should obey the let/app invariant</span>
<a name="line-344"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>PlusDmdArg</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-345"></a><span class='hs-definition'>dmdAnalStar</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span> <span class='hs-conop'>:*</span> <span class='hs-varid'>cd</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-346"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>e'</span>    <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cd</span> <span class='hs-varid'>e</span>
<a name="line-347"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isUnliftedType</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>exprOkForSpeculation</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>e</span> <span class='hs-layout'>)</span>
<a name="line-348"></a>    <span class='hs-comment'>-- The argument 'e' should satisfy the let/app invariant</span>
<a name="line-349"></a>    <span class='hs-comment'>-- See Note [Analysing with absent demand] in GHC.Types.Demand</span>
<a name="line-350"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>toPlusDmdArg</span> <span class='hs-varop'>$</span> <span class='hs-varid'>multDmdType</span> <span class='hs-varid'>n</span> <span class='hs-varid'>dmd_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span>
<a name="line-351"></a>
<a name="line-352"></a><a name="dmdAnal"></a><span class='hs-comment'>-- Main Demand Analsysis machinery</span>
<a name="line-353"></a><span class='hs-definition'>dmdAnal</span><span class='hs-layout'>,</span> <span class='hs-varid'>dmdAnal'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-354"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SubDemand</span>         <span class='hs-comment'>-- The main one takes a *SubDemand*</span>
<a name="line-355"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-356"></a>
<a name="line-357"></a><span class='hs-definition'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>d</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "dmdAnal" (ppr d &lt;+&gt; ppr e) $</span>
<a name="line-358"></a>                  <span class='hs-varid'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>d</span> <span class='hs-varid'>e</span>
<a name="line-359"></a>
<a name="line-360"></a><a name="dmdAnal'"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>nopDmdType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>
<a name="line-361"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>nopDmdType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Doesn't happen, in fact</span>
<a name="line-362"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-363"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitDmdType</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionDmdEnv</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-364"></a>
<a name="line-365"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span>
<a name="line-366"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmdTransform</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span>
<a name="line-367"></a>
<a name="line-368"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-369"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty</span> <span class='hs-varop'>`plusDmdType`</span> <span class='hs-varid'>mkPlusDmdArg</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionDmdEnv</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e'</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-370"></a>  <span class='hs-keyword'>where</span>
<a name="line-371"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>e'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>e</span>
<a name="line-372"></a>
<a name="line-373"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-374"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span>
<a name="line-375"></a>  <span class='hs-keyword'>where</span>
<a name="line-376"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>e'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>e</span>
<a name="line-377"></a>
<a name="line-378"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-379"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>fun_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fun'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-380"></a>  <span class='hs-keyword'>where</span>
<a name="line-381"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>fun'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>fun</span>
<a name="line-382"></a>
<a name="line-383"></a><span class='hs-comment'>-- Lots of the other code is there to make this</span>
<a name="line-384"></a><span class='hs-comment'>-- beautiful, compositional, application rule :-)</span>
<a name="line-385"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-386"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- This case handles value arguments (type args handled above)</span>
<a name="line-387"></a>    <span class='hs-comment'>-- Crucially, coercions /are/ handled here, because they are</span>
<a name="line-388"></a>    <span class='hs-comment'>-- value arguments (#10288)</span>
<a name="line-389"></a>    <span class='hs-keyword'>let</span>
<a name="line-390"></a>        <span class='hs-varid'>call_dmd</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCalledOnceDmd</span> <span class='hs-varid'>dmd</span>
<a name="line-391"></a>        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>fun'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>call_dmd</span> <span class='hs-varid'>fun</span>
<a name="line-392"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>arg_dmd</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitDmdTy</span> <span class='hs-varid'>fun_ty</span>
<a name="line-393"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalStar</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmdTransformThunkDmd</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>arg_dmd</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg</span>
<a name="line-394"></a>    <span class='hs-keyword'>in</span>
<a name="line-395"></a><span class='hs-comment'>--    pprTrace "dmdAnal:app" (vcat</span>
<a name="line-396"></a><span class='hs-comment'>--         [ text "dmd =" &lt;+&gt; ppr dmd</span>
<a name="line-397"></a><span class='hs-comment'>--         , text "expr =" &lt;+&gt; ppr (App fun arg)</span>
<a name="line-398"></a><span class='hs-comment'>--         , text "fun dmd_ty =" &lt;+&gt; ppr fun_ty</span>
<a name="line-399"></a><span class='hs-comment'>--         , text "arg dmd =" &lt;+&gt; ppr arg_dmd</span>
<a name="line-400"></a><span class='hs-comment'>--         , text "arg dmd_ty =" &lt;+&gt; ppr arg_ty</span>
<a name="line-401"></a><span class='hs-comment'>--         , text "res dmd_ty =" &lt;+&gt; ppr res_ty</span>
<a name="line-402"></a><span class='hs-comment'>--         , text "overall res dmd_ty =" &lt;+&gt; ppr (res_ty `bothDmdType` arg_ty) ])</span>
<a name="line-403"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-layout'>(</span><span class='hs-varid'>res_ty</span> <span class='hs-varop'>`plusDmdType`</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fun'</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span>
<a name="line-404"></a>
<a name="line-405"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>var</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-406"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>var</span>
<a name="line-407"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>
<a name="line-408"></a>        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>body'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>body</span>
<a name="line-409"></a>    <span class='hs-keyword'>in</span>
<a name="line-410"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>body_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>var</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-411"></a>
<a name="line-412"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-413"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-layout'>,</span> <span class='hs-varid'>body_dmd</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>peelCallDmd</span> <span class='hs-varid'>dmd</span>
<a name="line-414"></a>          <span class='hs-comment'>-- body_dmd: a demand to analyze the body</span>
<a name="line-415"></a>
<a name="line-416"></a>        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>body'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body_dmd</span> <span class='hs-varid'>body</span>
<a name="line-417"></a>        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>lam_ty</span> <span class='hs-varid'>var'</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>annotateLamIdBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>notArgOfDfun</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>var</span>
<a name="line-418"></a>        <span class='hs-varid'>new_dmd_type</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>multDmdType</span> <span class='hs-varid'>n</span> <span class='hs-varid'>lam_ty</span>
<a name="line-419"></a>    <span class='hs-keyword'>in</span>
<a name="line-420"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>new_dmd_type</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>var'</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-421"></a>
<a name="line-422"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>alt</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>rhs</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-423"></a>  <span class='hs-comment'>-- Only one alternative.</span>
<a name="line-424"></a>  <span class='hs-comment'>-- If it's a DataAlt, it should be the only constructor of the type.</span>
<a name="line-425"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_single_data_alt</span> <span class='hs-varid'>alt</span>
<a name="line-426"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>
<a name="line-427"></a>        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varid'>rhs'</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>rhs</span>
<a name="line-428"></a>        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>alt_ty1</span> <span class='hs-varid'>dmds</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findBndrsDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varid'>bndrs</span>
<a name="line-429"></a>        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>alt_ty2</span> <span class='hs-varid'>case_bndr_dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findBndrDmd</span> <span class='hs-varid'>env</span> <span class='hs-conid'>False</span> <span class='hs-varid'>alt_ty1</span> <span class='hs-varid'>case_bndr</span>
<a name="line-430"></a>        <span class='hs-comment'>-- Evaluation cardinality on the case binder is irrelevant and a no-op.</span>
<a name="line-431"></a>        <span class='hs-comment'>-- What matters is its nested sub-demand!</span>
<a name="line-432"></a>        <span class='hs-layout'>(</span><span class='hs-keyword'>_</span> <span class='hs-conop'>:*</span> <span class='hs-varid'>case_bndr_sd</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>case_bndr_dmd</span>
<a name="line-433"></a>        <span class='hs-comment'>-- Compute demand on the scrutinee</span>
<a name="line-434"></a>        <span class='hs-comment'>-- FORCE the result, otherwise thunks will end up retaining the</span>
<a name="line-435"></a>        <span class='hs-comment'>-- whole DmdEnv</span>
<a name="line-436"></a>        <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-varop'>!</span><span class='hs-varid'>bndrs'</span><span class='hs-layout'>,</span> <span class='hs-varop'>!</span><span class='hs-varid'>scrut_sd</span><span class='hs-layout'>)</span>
<a name="line-437"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DataAlt</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>alt</span>
<a name="line-438"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>id_dmds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addCaseBndrDmd</span> <span class='hs-varid'>case_bndr_sd</span> <span class='hs-varid'>dmds</span>
<a name="line-439"></a>          <span class='hs-comment'>-- See Note [Demand on scrutinee of a product case]</span>
<a name="line-440"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>new_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setBndrsDemandInfo</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>id_dmds</span>
<a name="line-441"></a>                <span class='hs-varop'>!</span><span class='hs-varid'>new_prod</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkProd</span> <span class='hs-varid'>id_dmds</span>
<a name="line-442"></a>            <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_info</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_prod</span><span class='hs-layout'>)</span>
<a name="line-443"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-444"></a>          <span class='hs-comment'>-- __DEFAULT and literal alts. Simply add demands and discard the</span>
<a name="line-445"></a>          <span class='hs-comment'>-- evaluation cardinality, as we evaluate the scrutinee exactly once.</span>
<a name="line-446"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>null</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>case_bndr_sd</span><span class='hs-layout'>)</span>
<a name="line-447"></a>        <span class='hs-varid'>fam_envs</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ae_fam_envs</span> <span class='hs-varid'>env</span>
<a name="line-448"></a>        <span class='hs-varid'>alt_ty3</span>
<a name="line-449"></a>          <span class='hs-comment'>-- See Note [Precise exceptions and strictness analysis] in "GHC.Types.Demand"</span>
<a name="line-450"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprMayThrowPreciseException</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>scrut</span>
<a name="line-451"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>deferAfterPreciseException</span> <span class='hs-varid'>alt_ty2</span>
<a name="line-452"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-453"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alt_ty2</span>
<a name="line-454"></a>
<a name="line-455"></a>        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>scrut_ty</span> <span class='hs-varid'>scrut'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut_sd</span> <span class='hs-varid'>scrut</span>
<a name="line-456"></a>        <span class='hs-varid'>res_ty</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alt_ty3</span> <span class='hs-varop'>`plusDmdType`</span> <span class='hs-varid'>toPlusDmdArg</span> <span class='hs-varid'>scrut_ty</span>
<a name="line-457"></a>        <span class='hs-varop'>!</span><span class='hs-varid'>case_bndr'</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdDemandInfo</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>case_bndr_dmd</span>
<a name="line-458"></a>    <span class='hs-keyword'>in</span>
<a name="line-459"></a><span class='hs-comment'>--    pprTrace "dmdAnal:Case1" (vcat [ text "scrut" &lt;+&gt; ppr scrut</span>
<a name="line-460"></a><span class='hs-comment'>--                                   , text "dmd" &lt;+&gt; ppr dmd</span>
<a name="line-461"></a><span class='hs-comment'>--                                   , text "case_bndr_dmd" &lt;+&gt; ppr (idDemandInfo case_bndr')</span>
<a name="line-462"></a><span class='hs-comment'>--                                   , text "scrut_sd" &lt;+&gt; ppr scrut_sd</span>
<a name="line-463"></a><span class='hs-comment'>--                                   , text "scrut_ty" &lt;+&gt; ppr scrut_ty</span>
<a name="line-464"></a><span class='hs-comment'>--                                   , text "alt_ty" &lt;+&gt; ppr alt_ty2</span>
<a name="line-465"></a><span class='hs-comment'>--                                   , text "res_ty" &lt;+&gt; ppr res_ty ]) $</span>
<a name="line-466"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>res_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>alt</span> <span class='hs-varid'>bndrs'</span> <span class='hs-varid'>rhs'</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-467"></a>    <span class='hs-keyword'>where</span>
<a name="line-468"></a>      <span class='hs-varid'>is_single_data_alt</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isJust</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tyConSingleAlgDataCon_maybe</span> <span class='hs-varop'>$</span> <span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>dc</span>
<a name="line-469"></a>      <span class='hs-varid'>is_single_data_alt</span> <span class='hs-keyword'>_</span>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-470"></a>
<a name="line-471"></a>
<a name="line-472"></a>
<a name="line-473"></a>
<a name="line-474"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-475"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>      <span class='hs-comment'>-- Case expression with multiple alternatives</span>
<a name="line-476"></a>        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>alt_ty</span> <span class='hs-varid'>alts'</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>combineAltDmds</span> <span class='hs-varid'>alts</span>
<a name="line-477"></a>
<a name="line-478"></a>        <span class='hs-varid'>combineAltDmds</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>botDmdType</span> <span class='hs-conid'>[]</span>
<a name="line-479"></a>        <span class='hs-varid'>combineAltDmds</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-conop'>:</span><span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-480"></a>          <span class='hs-keyword'>let</span>
<a name="line-481"></a>            <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>cur_ty</span> <span class='hs-varid'>a'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalSumAlt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>a</span>
<a name="line-482"></a>            <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>rest_ty</span> <span class='hs-varid'>as'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>combineAltDmds</span> <span class='hs-keyword'>as</span>
<a name="line-483"></a>          <span class='hs-keyword'>in</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-layout'>(</span><span class='hs-varid'>lubDmdType</span> <span class='hs-varid'>cur_ty</span> <span class='hs-varid'>rest_ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-conop'>:</span><span class='hs-varid'>as'</span><span class='hs-layout'>)</span>
<a name="line-484"></a>
<a name="line-485"></a>        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>scrut_ty</span> <span class='hs-varid'>scrut'</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>topSubDmd</span> <span class='hs-varid'>scrut</span>
<a name="line-486"></a>        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>alt_ty1</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>annotateBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>alt_ty</span> <span class='hs-varid'>case_bndr</span>
<a name="line-487"></a>                               <span class='hs-comment'>-- NB: Base case is botDmdType, for empty case alternatives</span>
<a name="line-488"></a>                               <span class='hs-comment'>--     This is a unit for lubDmdType, and the right result</span>
<a name="line-489"></a>                               <span class='hs-comment'>--     when there really are no alternatives</span>
<a name="line-490"></a>        <span class='hs-varid'>fam_envs</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ae_fam_envs</span> <span class='hs-varid'>env</span>
<a name="line-491"></a>        <span class='hs-varid'>alt_ty2</span>
<a name="line-492"></a>          <span class='hs-comment'>-- See Note [Precise exceptions and strictness analysis] in "GHC.Types.Demand"</span>
<a name="line-493"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprMayThrowPreciseException</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>scrut</span>
<a name="line-494"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>deferAfterPreciseException</span> <span class='hs-varid'>alt_ty1</span>
<a name="line-495"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-496"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alt_ty1</span>
<a name="line-497"></a>        <span class='hs-varid'>res_ty</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alt_ty2</span> <span class='hs-varop'>`plusDmdType`</span> <span class='hs-varid'>toPlusDmdArg</span> <span class='hs-varid'>scrut_ty</span>
<a name="line-498"></a>
<a name="line-499"></a>    <span class='hs-keyword'>in</span>
<a name="line-500"></a><span class='hs-comment'>--    pprTrace "dmdAnal:Case2" (vcat [ text "scrut" &lt;+&gt; ppr scrut</span>
<a name="line-501"></a><span class='hs-comment'>--                                   , text "scrut_ty" &lt;+&gt; ppr scrut_ty</span>
<a name="line-502"></a><span class='hs-comment'>--                                   , text "alt_tys" &lt;+&gt; ppr alt_tys</span>
<a name="line-503"></a><span class='hs-comment'>--                                   , text "alt_ty2" &lt;+&gt; ppr alt_ty2</span>
<a name="line-504"></a><span class='hs-comment'>--                                   , text "res_ty" &lt;+&gt; ppr res_ty ]) $</span>
<a name="line-505"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>res_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts'</span><span class='hs-layout'>)</span>
<a name="line-506"></a>
<a name="line-507"></a><span class='hs-definition'>dmdAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>bind</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-508"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>final_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>bind'</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-509"></a>  <span class='hs-keyword'>where</span>
<a name="line-510"></a>    <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>final_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>R</span> <span class='hs-varid'>bind'</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalBind</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>bind</span> <span class='hs-varid'>go'</span>
<a name="line-511"></a>    <span class='hs-varid'>go'</span> <span class='hs-varop'>!</span><span class='hs-varid'>env'</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>body</span>
<a name="line-512"></a>
<a name="line-513"></a><a name="exprMayThrowPreciseException"></a><span class='hs-comment'>-- | A simple, syntactic analysis of whether an expression MAY throw a precise</span>
<a name="line-514"></a><span class='hs-comment'>-- exception when evaluated. It's always sound to return 'True'.</span>
<a name="line-515"></a><span class='hs-comment'>-- See Note [Which scrutinees may throw precise exceptions].</span>
<a name="line-516"></a><span class='hs-definition'>exprMayThrowPreciseException</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-517"></a><span class='hs-definition'>exprMayThrowPreciseException</span> <span class='hs-varid'>envs</span> <span class='hs-varid'>e</span>
<a name="line-518"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>forcesRealWorld</span> <span class='hs-varid'>envs</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-519"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- 1. in the Note</span>
<a name="line-520"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>collectArgs</span> <span class='hs-varid'>e</span>
<a name="line-521"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>op</span>    <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isPrimOpId_maybe</span> <span class='hs-varid'>f</span>
<a name="line-522"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>op</span> <span class='hs-varop'>/=</span> <span class='hs-conid'>RaiseIOOp</span>
<a name="line-523"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- 2. in the Note</span>
<a name="line-524"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>collectArgs</span> <span class='hs-varid'>e</span>
<a name="line-525"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>fcall</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isFCallId_maybe</span> <span class='hs-varid'>f</span>
<a name="line-526"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isSafeForeignCall</span> <span class='hs-varid'>fcall</span><span class='hs-layout'>)</span>
<a name="line-527"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- 3. in the Note</span>
<a name="line-528"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-529"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>  <span class='hs-comment'>-- _. in the Note</span>
<a name="line-530"></a>
<a name="line-531"></a><a name="forcesRealWorld"></a><span class='hs-comment'>-- | Recognises types that are</span>
<a name="line-532"></a><span class='hs-comment'>--    * @State# RealWorld@</span>
<a name="line-533"></a><span class='hs-comment'>--    * Unboxed tuples with a @State# RealWorld@ field</span>
<a name="line-534"></a><span class='hs-comment'>-- modulo coercions. This will detect 'IO' actions (even post Nested CPR! See</span>
<a name="line-535"></a><span class='hs-comment'>-- T13380e) and user-written variants thereof by their type.</span>
<a name="line-536"></a><span class='hs-definition'>forcesRealWorld</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-537"></a><span class='hs-definition'>forcesRealWorld</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-538"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>realWorldStatePrimTy</span>
<a name="line-539"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-540"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>DataConPatContext</span><span class='hs-layout'>{</span> <span class='hs-varid'>dcpc_dc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dc</span><span class='hs-layout'>,</span> <span class='hs-varid'>dcpc_tc_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc_args</span> <span class='hs-layout'>}</span>
<a name="line-541"></a>      <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitArgType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-542"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isUnboxedTupleDataCon</span> <span class='hs-varid'>dc</span>
<a name="line-543"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>field_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConInstArgTys</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>tc_args</span>
<a name="line-544"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqType</span> <span class='hs-varid'>realWorldStatePrimTy</span> <span class='hs-varop'>.</span> <span class='hs-varid'>scaledThing</span><span class='hs-layout'>)</span> <span class='hs-varid'>field_tys</span>
<a name="line-545"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-546"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-547"></a>
<a name="line-548"></a><a name="dmdAnalSumAlt"></a><span class='hs-definition'>dmdAnalSumAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SubDemand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Alt</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-conid'>Var</span><span class='hs-layout'>)</span>
<a name="line-549"></a><span class='hs-definition'>dmdAnalSumAlt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>case_bndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-550"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>rhs</span>
<a name="line-551"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>alt_ty</span> <span class='hs-varid'>dmds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>findBndrsDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varid'>bndrs</span>
<a name="line-552"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span> <span class='hs-conop'>:*</span> <span class='hs-varid'>case_bndr_sd</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findIdDemand</span> <span class='hs-varid'>alt_ty</span> <span class='hs-varid'>case_bndr</span>
<a name="line-553"></a>        <span class='hs-comment'>-- See Note [Demand on scrutinee of a product case]</span>
<a name="line-554"></a>        <span class='hs-varid'>id_dmds</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addCaseBndrDmd</span> <span class='hs-varid'>case_bndr_sd</span> <span class='hs-varid'>dmds</span>
<a name="line-555"></a>        <span class='hs-comment'>-- Do not put a thunk into the Alt</span>
<a name="line-556"></a>        <span class='hs-varop'>!</span><span class='hs-varid'>new_ids</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setBndrsDemandInfo</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>id_dmds</span>
<a name="line-557"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>alt_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>new_ids</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span>
<a name="line-558"></a>
<a name="line-559"></a><span class='hs-comment'>{-
<a name="line-560"></a>Note [Analysing with absent demand]
<a name="line-561"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-562"></a>Suppose we analyse an expression with demand A.  The "A" means
<a name="line-563"></a>"absent", so this expression will never be needed.  What should happen?
<a name="line-564"></a>There are several wrinkles:
<a name="line-565"></a>
<a name="line-566"></a>* We *do* want to analyse the expression regardless.
<a name="line-567"></a>  Reason: Note [Always analyse in virgin pass]
<a name="line-568"></a>
<a name="line-569"></a>  But we can post-process the results to ignore all the usage
<a name="line-570"></a>  demands coming back. This is done by multDmdType.
<a name="line-571"></a>
<a name="line-572"></a>* In a previous incarnation of GHC we needed to be extra careful in the
<a name="line-573"></a>  case of an *unlifted type*, because unlifted values are evaluated
<a name="line-574"></a>  even if they are not used.  Example (see #9254):
<a name="line-575"></a>     f :: (() -&gt; (# Int#, () #)) -&gt; ()
<a name="line-576"></a>          -- Strictness signature is
<a name="line-577"></a>          --    &lt;CS(S(A,SU))&gt;
<a name="line-578"></a>          -- I.e. calls k, but discards first component of result
<a name="line-579"></a>     f k = case k () of (# _, r #) -&gt; r
<a name="line-580"></a>
<a name="line-581"></a>     g :: Int -&gt; ()
<a name="line-582"></a>     g y = f (\n -&gt; (# case y of I# y2 -&gt; y2, n #))
<a name="line-583"></a>
<a name="line-584"></a>  Here f's strictness signature says (correctly) that it calls its
<a name="line-585"></a>  argument function and ignores the first component of its result.
<a name="line-586"></a>  This is correct in the sense that it'd be fine to (say) modify the
<a name="line-587"></a>  function so that always returned 0# in the first component.
<a name="line-588"></a>
<a name="line-589"></a>  But in function g, we *will* evaluate the 'case y of ...', because
<a name="line-590"></a>  it has type Int#.  So 'y' will be evaluated.  So we must record this
<a name="line-591"></a>  usage of 'y', else 'g' will say 'y' is absent, and will w/w so that
<a name="line-592"></a>  'y' is bound to an aBSENT_ERROR thunk.
<a name="line-593"></a>
<a name="line-594"></a>  However, the argument of toSubDmd always satisfies the let/app
<a name="line-595"></a>  invariant; so if it is unlifted it is also okForSpeculation, and so
<a name="line-596"></a>  can be evaluated in a short finite time -- and that rules out nasty
<a name="line-597"></a>  cases like the one above.  (I'm not quite sure why this was a
<a name="line-598"></a>  problem in an earlier version of GHC, but it isn't now.)
<a name="line-599"></a>
<a name="line-600"></a>Note [Always analyse in virgin pass]
<a name="line-601"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-602"></a>Tricky point: make sure that we analyse in the 'virgin' pass. Consider
<a name="line-603"></a>   rec { f acc x True  = f (...rec { g y = ...g... }...)
<a name="line-604"></a>         f acc x False = acc }
<a name="line-605"></a>In the virgin pass for 'f' we'll give 'f' a very strict (bottom) type.
<a name="line-606"></a>That might mean that we analyse the sub-expression containing the
<a name="line-607"></a>E = "...rec g..." stuff in a bottom demand.  Suppose we *didn't analyse*
<a name="line-608"></a>E, but just returned botType.
<a name="line-609"></a>
<a name="line-610"></a>Then in the *next* (non-virgin) iteration for 'f', we might analyse E
<a name="line-611"></a>in a weaker demand, and that will trigger doing a fixpoint iteration
<a name="line-612"></a>for g.  But *because it's not the virgin pass* we won't start g's
<a name="line-613"></a>iteration at bottom.  Disaster.  (This happened in $sfibToList' of
<a name="line-614"></a>nofib/spectral/fibheaps.)
<a name="line-615"></a>
<a name="line-616"></a>So in the virgin pass we make sure that we do analyse the expression
<a name="line-617"></a>at least once, to initialise its signatures.
<a name="line-618"></a>
<a name="line-619"></a>Note [Which scrutinees may throw precise exceptions]
<a name="line-620"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-621"></a>This is the specification of 'exprMayThrowPreciseExceptions',
<a name="line-622"></a>which is important for Scenario 2 of
<a name="line-623"></a>Note [Precise exceptions and strictness analysis] in GHC.Types.Demand.
<a name="line-624"></a>
<a name="line-625"></a>For an expression @f a1 ... an :: ty@ we determine that
<a name="line-626"></a>  1. False  If ty is *not* @State# RealWorld@ or an unboxed tuple thereof.
<a name="line-627"></a>            This check is done by 'forcesRealWorld'.
<a name="line-628"></a>            (Why not simply unboxed pairs as above? This is motivated by
<a name="line-629"></a>            T13380{d,e}.)
<a name="line-630"></a>  2. False  If f is a PrimOp, and it is *not* raiseIO#
<a name="line-631"></a>  3. False  If f is an unsafe FFI call ('PlayRisky')
<a name="line-632"></a>  _. True   Otherwise "give up".
<a name="line-633"></a>
<a name="line-634"></a>It is sound to return False in those cases, because
<a name="line-635"></a>  1. We don't give any guarantees for unsafePerformIO, so no precise exceptions
<a name="line-636"></a>     from pure code.
<a name="line-637"></a>  2. raiseIO# is the only primop that may throw a precise exception.
<a name="line-638"></a>  3. Unsafe FFI calls may not interact with the RTS (to throw, for example).
<a name="line-639"></a>     See haddock on GHC.Types.ForeignCall.PlayRisky.
<a name="line-640"></a>
<a name="line-641"></a>We *need* to return False in those cases, because
<a name="line-642"></a>  1. We would lose too much strictness in pure code, all over the place.
<a name="line-643"></a>  2. We would lose strictness for primops like getMaskingState#, which
<a name="line-644"></a>     introduces a substantial regression in
<a name="line-645"></a>     GHC.IO.Handle.Internals.wantReadableHandle.
<a name="line-646"></a>  3. We would lose strictness for code like GHC.Fingerprint.fingerprintData,
<a name="line-647"></a>     where an intermittent FFI call to c_MD5Init would otherwise lose
<a name="line-648"></a>     strictness on the arguments len and buf, leading to regressions in T9203
<a name="line-649"></a>     (2%) and i386's haddock.base (5%). Tested by T13380f.
<a name="line-650"></a>
<a name="line-651"></a>In !3014 we tried a more sophisticated analysis by introducing ConOrDiv (nic)
<a name="line-652"></a>to the Divergence lattice, but in practice it turned out to be hard to untaint
<a name="line-653"></a>from 'topDiv' to 'conDiv', leading to bugs, performance regressions and
<a name="line-654"></a>complexity that didn't justify the single fixed testcase T13380c.
<a name="line-655"></a>
<a name="line-656"></a>Note [Demand on the scrutinee of a product case]
<a name="line-657"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-658"></a>When figuring out the demand on the scrutinee of a product case,
<a name="line-659"></a>we use the demands of the case alternative, i.e. id_dmds.
<a name="line-660"></a>But note that these include the demand on the case binder;
<a name="line-661"></a>see Note [Demand on case-alternative binders] in GHC.Types.Demand.
<a name="line-662"></a>This is crucial. Example:
<a name="line-663"></a>   f x = case x of y { (a,b) -&gt; k y a }
<a name="line-664"></a>If we just take scrut_demand = 1P(L,A), then we won't pass x to the
<a name="line-665"></a>worker, so the worker will rebuild
<a name="line-666"></a>     x = (a, absent-error)
<a name="line-667"></a>and that'll crash.
<a name="line-668"></a>
<a name="line-669"></a>Note [Aggregated demand for cardinality]
<a name="line-670"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-671"></a>FIXME: This Note should be named [LetUp vs. LetDown] and probably predates
<a name="line-672"></a>said separation. SG
<a name="line-673"></a>
<a name="line-674"></a>We use different strategies for strictness and usage/cardinality to
<a name="line-675"></a>"unleash" demands captured on free variables by bindings. Let us
<a name="line-676"></a>consider the example:
<a name="line-677"></a>
<a name="line-678"></a>f1 y = let {-# NOINLINE h #-}
<a name="line-679"></a>           h = y
<a name="line-680"></a>       in  (h, h)
<a name="line-681"></a>
<a name="line-682"></a>We are interested in obtaining cardinality demand U1 on |y|, as it is
<a name="line-683"></a>used only in a thunk, and, therefore, is not going to be updated any
<a name="line-684"></a>more. Therefore, the demand on |y|, captured and unleashed by usage of
<a name="line-685"></a>|h| is U1. However, if we unleash this demand every time |h| is used,
<a name="line-686"></a>and then sum up the effects, the ultimate demand on |y| will be U1 +
<a name="line-687"></a>U1 = U. In order to avoid it, we *first* collect the aggregate demand
<a name="line-688"></a>on |h| in the body of let-expression, and only then apply the demand
<a name="line-689"></a>transformer:
<a name="line-690"></a>
<a name="line-691"></a>transf[x](U) = {y |-&gt; U1}
<a name="line-692"></a>
<a name="line-693"></a>so the resulting demand on |y| is U1.
<a name="line-694"></a>
<a name="line-695"></a>The situation is, however, different for strictness, where this
<a name="line-696"></a>aggregating approach exhibits worse results because of the nature of
<a name="line-697"></a>|both| operation for strictness. Consider the example:
<a name="line-698"></a>
<a name="line-699"></a>f y c =
<a name="line-700"></a>  let h x = y |seq| x
<a name="line-701"></a>   in case of
<a name="line-702"></a>        True  -&gt; h True
<a name="line-703"></a>        False -&gt; y
<a name="line-704"></a>
<a name="line-705"></a>It is clear that |f| is strict in |y|, however, the suggested analysis
<a name="line-706"></a>will infer from the body of |let| that |h| is used lazily (as it is
<a name="line-707"></a>used in one branch only), therefore lazy demand will be put on its
<a name="line-708"></a>free variable |y|. Conversely, if the demand on |h| is unleashed right
<a name="line-709"></a>on the spot, we will get the desired result, namely, that |f| is
<a name="line-710"></a>strict in |y|.
<a name="line-711"></a>
<a name="line-712"></a>
<a name="line-713"></a>************************************************************************
<a name="line-714"></a>*                                                                      *
<a name="line-715"></a>                    Demand transformer
<a name="line-716"></a>*                                                                      *
<a name="line-717"></a>************************************************************************
<a name="line-718"></a>-}</span>
<a name="line-719"></a>
<a name="line-720"></a><a name="dmdTransform"></a><span class='hs-definition'>dmdTransform</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span>         <span class='hs-comment'>-- ^ The strictness environment</span>
<a name="line-721"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>              <span class='hs-comment'>-- ^ The function</span>
<a name="line-722"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SubDemand</span>       <span class='hs-comment'>-- ^ The demand on the function</span>
<a name="line-723"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span>         <span class='hs-comment'>-- ^ The demand type of the function in this context</span>
<a name="line-724"></a>                                <span class='hs-comment'>-- Returned DmdEnv includes the demand on</span>
<a name="line-725"></a>                                <span class='hs-comment'>-- this function plus demand on its free variables</span>
<a name="line-726"></a>
<a name="line-727"></a><span class='hs-comment'>-- See Note [What are demand signatures?] in "GHC.Types.Demand"</span>
<a name="line-728"></a><span class='hs-definition'>dmdTransform</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span> <span class='hs-varid'>dmd</span>
<a name="line-729"></a>  <span class='hs-comment'>-- Data constructors</span>
<a name="line-730"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDataConWorkId</span> <span class='hs-varid'>var</span>
<a name="line-731"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdTransformDataConSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>idArity</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span> <span class='hs-varid'>dmd</span>
<a name="line-732"></a>  <span class='hs-comment'>-- Dictionary component selectors</span>
<a name="line-733"></a>  <span class='hs-comment'>-- Used to be controlled by a flag.</span>
<a name="line-734"></a>  <span class='hs-comment'>-- See #18429 for some perf measurements.</span>
<a name="line-735"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isClassOpId_maybe</span> <span class='hs-varid'>var</span>
<a name="line-736"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "dmdTransform:DictSel" (ppr var $$ ppr dmd) $</span>
<a name="line-737"></a>    <span class='hs-varid'>dmdTransformDictSelSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span> <span class='hs-varid'>dmd</span>
<a name="line-738"></a>  <span class='hs-comment'>-- Imported functions</span>
<a name="line-739"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isGlobalId</span> <span class='hs-varid'>var</span>
<a name="line-740"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdTransformSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span> <span class='hs-varid'>dmd</span>
<a name="line-741"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "dmdTransform:import" (vcat [ppr var, ppr (idStrictness var), ppr dmd, ppr res])</span>
<a name="line-742"></a>    <span class='hs-varid'>res</span>
<a name="line-743"></a>  <span class='hs-comment'>-- Top-level or local let-bound thing for which we use LetDown ('useLetUp').</span>
<a name="line-744"></a>  <span class='hs-comment'>-- In that case, we have a strictness signature to unleash in our AnalEnv.</span>
<a name="line-745"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>sig</span><span class='hs-layout'>,</span> <span class='hs-varid'>top_lvl</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span>
<a name="line-746"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fn_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdTransformSig</span> <span class='hs-varid'>sig</span> <span class='hs-varid'>dmd</span>
<a name="line-747"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "dmdTransform:LetDown" (vcat [ppr var, ppr sig, ppr dmd, ppr fn_ty]) $</span>
<a name="line-748"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>top_lvl</span> <span class='hs-keyword'>of</span>
<a name="line-749"></a>      <span class='hs-conid'>NotTopLevel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addVarDmd</span> <span class='hs-varid'>fn_ty</span> <span class='hs-varid'>var</span> <span class='hs-layout'>(</span><span class='hs-conid'>C_11</span> <span class='hs-conop'>:*</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span>
<a name="line-750"></a>      <span class='hs-conid'>TopLevel</span>
<a name="line-751"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isInterestingTopLevelFn</span> <span class='hs-varid'>var</span>
<a name="line-752"></a>        <span class='hs-comment'>-- Top-level things will be used multiple times or not at</span>
<a name="line-753"></a>        <span class='hs-comment'>-- all anyway, hence the multDmd below: It means we don't</span>
<a name="line-754"></a>        <span class='hs-comment'>-- have to track whether @var@ is used strictly or at most</span>
<a name="line-755"></a>        <span class='hs-comment'>-- once, because ultimately it never will.</span>
<a name="line-756"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addVarDmd</span> <span class='hs-varid'>fn_ty</span> <span class='hs-varid'>var</span> <span class='hs-layout'>(</span><span class='hs-conid'>C_0N</span> <span class='hs-varop'>`multDmd`</span> <span class='hs-layout'>(</span><span class='hs-conid'>C_11</span> <span class='hs-conop'>:*</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- discard strictness</span>
<a name="line-757"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-758"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>fn_ty</span> <span class='hs-comment'>-- don't bother tracking; just annotate with 'topDmd' later</span>
<a name="line-759"></a>  <span class='hs-comment'>-- Everything else:</span>
<a name="line-760"></a>  <span class='hs-comment'>--   * Local let binders for which we use LetUp (cf. 'useLetUp')</span>
<a name="line-761"></a>  <span class='hs-comment'>--   * Lambda binders</span>
<a name="line-762"></a>  <span class='hs-comment'>--   * Case and constructor field binders</span>
<a name="line-763"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-764"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "dmdTransform:other" (vcat [ppr var, ppr sig, ppr dmd, ppr res]) $</span>
<a name="line-765"></a>    <span class='hs-varid'>unitDmdType</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitVarEnv</span> <span class='hs-varid'>var</span> <span class='hs-layout'>(</span><span class='hs-conid'>C_11</span> <span class='hs-conop'>:*</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-766"></a>
<a name="line-767"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-768"></a>*                                                                      *
<a name="line-769"></a>                      Binding right-hand sides
<a name="line-770"></a>*                                                                      *
<a name="line-771"></a>********************************************************************* -}</span>
<a name="line-772"></a>
<a name="line-773"></a><a name="dmdAnalRhsSig"></a><span class='hs-comment'>-- | @dmdAnalRhsSig@ analyses the given RHS to compute a demand signature</span>
<a name="line-774"></a><span class='hs-comment'>-- for the LetDown rule. It works as follows:</span>
<a name="line-775"></a><span class='hs-comment'>--</span>
<a name="line-776"></a><span class='hs-comment'>--  * assuming the weakest possible body sub-demand, L</span>
<a name="line-777"></a><span class='hs-comment'>--  * looking at the definition</span>
<a name="line-778"></a><span class='hs-comment'>--  * determining a strictness signature</span>
<a name="line-779"></a><span class='hs-comment'>--</span>
<a name="line-780"></a><span class='hs-comment'>-- Since it assumed a body sub-demand of L, the resulting signature is</span>
<a name="line-781"></a><span class='hs-comment'>-- applicable at any call site.</span>
<a name="line-782"></a><span class='hs-definition'>dmdAnalRhsSig</span>
<a name="line-783"></a>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-784"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RecFlag</span>
<a name="line-785"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SubDemand</span>
<a name="line-786"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-787"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>DmdEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-788"></a><span class='hs-comment'>-- Process the RHS of the binding, add the strictness signature</span>
<a name="line-789"></a><span class='hs-comment'>-- to the Id, and augment the environment with the signature as well.</span>
<a name="line-790"></a><span class='hs-comment'>-- See Note [NOINLINE and strictness]</span>
<a name="line-791"></a><span class='hs-definition'>dmdAnalRhsSig</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>rec_flag</span> <span class='hs-varid'>env</span> <span class='hs-varid'>let_dmd</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-792"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "dmdAnalRhsSig" (ppr id $$ ppr let_dmd $$ ppr sig $$ ppr lazy_fv) $</span>
<a name="line-793"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>id'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span>
<a name="line-794"></a>  <span class='hs-keyword'>where</span>
<a name="line-795"></a>    <span class='hs-varid'>rhs_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idArity</span> <span class='hs-varid'>id</span>
<a name="line-796"></a>    <span class='hs-comment'>-- See Note [Demand signatures are computed for a threshold demand based on idArity]</span>
<a name="line-797"></a>    <span class='hs-varid'>rhs_dmd</span> <span class='hs-comment'>-- See Note [Demand analysis for join points]</span>
<a name="line-798"></a>            <span class='hs-comment'>-- See Note [Invariants on join points] invariant 2b, in GHC.Core</span>
<a name="line-799"></a>            <span class='hs-comment'>--     rhs_arity matches the join arity of the join point</span>
<a name="line-800"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isJoinId</span> <span class='hs-varid'>id</span>
<a name="line-801"></a>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCalledOnceDmds</span> <span class='hs-varid'>rhs_arity</span> <span class='hs-varid'>let_dmd</span>
<a name="line-802"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-803"></a>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCalledOnceDmds</span> <span class='hs-varid'>rhs_arity</span> <span class='hs-varid'>topSubDmd</span>
<a name="line-804"></a>
<a name="line-805"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>rhs_dmd_ty</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rhs_dmd</span> <span class='hs-varid'>rhs</span>
<a name="line-806"></a>    <span class='hs-conid'>DmdType</span> <span class='hs-varid'>rhs_fv</span> <span class='hs-varid'>rhs_dmds</span> <span class='hs-varid'>rhs_div</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_dmd_ty</span>
<a name="line-807"></a>
<a name="line-808"></a>    <span class='hs-varid'>sig</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkStrictSigForArity</span> <span class='hs-varid'>rhs_arity</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span> <span class='hs-varid'>sig_fv</span> <span class='hs-varid'>rhs_dmds</span> <span class='hs-varid'>rhs_div</span><span class='hs-layout'>)</span>
<a name="line-809"></a>
<a name="line-810"></a>    <span class='hs-varid'>id'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span> <span class='hs-varop'>`setIdStrictness`</span> <span class='hs-varid'>sig</span>
<a name="line-811"></a>    <span class='hs-varop'>!</span><span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendAnalEnv</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id'</span> <span class='hs-varid'>sig</span>
<a name="line-812"></a>
<a name="line-813"></a>    <span class='hs-comment'>-- See Note [Aggregated demand for cardinality]</span>
<a name="line-814"></a>    <span class='hs-comment'>-- FIXME: That Note doesn't explain the following lines at all. The reason</span>
<a name="line-815"></a>    <span class='hs-comment'>--        is really much different: When we have a recursive function, we'd</span>
<a name="line-816"></a>    <span class='hs-comment'>--        have to also consider the free vars of the strictness signature</span>
<a name="line-817"></a>    <span class='hs-comment'>--        when checking whether we found a fixed-point. That is expensive;</span>
<a name="line-818"></a>    <span class='hs-comment'>--        we only want to check whether argument demands of the sig changed.</span>
<a name="line-819"></a>    <span class='hs-comment'>--        reuseEnv makes it so that the FV results are stable as long as the</span>
<a name="line-820"></a>    <span class='hs-comment'>--        last argument demands were. Strictness won't change. But used-once</span>
<a name="line-821"></a>    <span class='hs-comment'>--        might turn into used-many even if the signature was stable and</span>
<a name="line-822"></a>    <span class='hs-comment'>--        we'd have to do an additional iteration. reuseEnv makes sure that</span>
<a name="line-823"></a>    <span class='hs-comment'>--        we never get used-once info for FVs of recursive functions.</span>
<a name="line-824"></a>    <span class='hs-varid'>rhs_fv1</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>rec_flag</span> <span class='hs-keyword'>of</span>
<a name="line-825"></a>                <span class='hs-conid'>Recursive</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>reuseEnv</span> <span class='hs-varid'>rhs_fv</span>
<a name="line-826"></a>                <span class='hs-conid'>NonRecursive</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rhs_fv</span>
<a name="line-827"></a>
<a name="line-828"></a>    <span class='hs-comment'>-- See Note [Absence analysis for stable unfoldings and RULES]</span>
<a name="line-829"></a>    <span class='hs-varid'>rhs_fv2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_fv1</span> <span class='hs-varop'>`keepAliveDmdEnv`</span> <span class='hs-varid'>bndrRuleAndUnfoldingIds</span> <span class='hs-varid'>id</span>
<a name="line-830"></a>
<a name="line-831"></a>    <span class='hs-comment'>-- See Note [Lazy and unleashable free variables]</span>
<a name="line-832"></a>    <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-varop'>!</span><span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varop'>!</span><span class='hs-varid'>sig_fv</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionVarEnv</span> <span class='hs-varid'>isWeakDmd</span> <span class='hs-varid'>rhs_fv2</span>
<a name="line-833"></a>
<a name="line-834"></a><a name="useLetUp"></a><span class='hs-comment'>-- | If given the (local, non-recursive) let-bound 'Id', 'useLetUp' determines</span>
<a name="line-835"></a><span class='hs-comment'>-- whether we should process the binding up (body before rhs) or down (rhs</span>
<a name="line-836"></a><span class='hs-comment'>-- before body).</span>
<a name="line-837"></a><span class='hs-comment'>--</span>
<a name="line-838"></a><span class='hs-comment'>-- We use LetDown if there is a chance to get a useful strictness signature to</span>
<a name="line-839"></a><span class='hs-comment'>-- unleash at call sites. LetDown is generally more precise than LetUp if we can</span>
<a name="line-840"></a><span class='hs-comment'>-- correctly guess how it will be used in the body, that is, for which incoming</span>
<a name="line-841"></a><span class='hs-comment'>-- demand the strictness signature should be computed, which allows us to</span>
<a name="line-842"></a><span class='hs-comment'>-- unleash higher-order demands on arguments at call sites. This is mostly the</span>
<a name="line-843"></a><span class='hs-comment'>-- case when</span>
<a name="line-844"></a><span class='hs-comment'>--</span>
<a name="line-845"></a><span class='hs-comment'>--   * The binding takes any arguments before performing meaningful work (cf.</span>
<a name="line-846"></a><span class='hs-comment'>--     'idArity'), in which case we are interested to see how it uses them.</span>
<a name="line-847"></a><span class='hs-comment'>--   * The binding is a join point, hence acting like a function, not a value.</span>
<a name="line-848"></a><span class='hs-comment'>--     As a big plus, we know *precisely* how it will be used in the body; since</span>
<a name="line-849"></a><span class='hs-comment'>--     it's always tail-called, we can directly unleash the incoming demand of</span>
<a name="line-850"></a><span class='hs-comment'>--     the let binding on its RHS when computing a strictness signature. See</span>
<a name="line-851"></a><span class='hs-comment'>--     [Demand analysis for join points].</span>
<a name="line-852"></a><span class='hs-comment'>--</span>
<a name="line-853"></a><span class='hs-comment'>-- Thus, if the binding is not a join point and its arity is 0, we have a thunk</span>
<a name="line-854"></a><span class='hs-comment'>-- and use LetUp, implying that we have no usable demand signature available</span>
<a name="line-855"></a><span class='hs-comment'>-- when we analyse the let body.</span>
<a name="line-856"></a><span class='hs-comment'>--</span>
<a name="line-857"></a><span class='hs-comment'>-- Since thunk evaluation is memoised, we want to unleash its 'DmdEnv' of free</span>
<a name="line-858"></a><span class='hs-comment'>-- vars at most once, regardless of how many times it was forced in the body.</span>
<a name="line-859"></a><span class='hs-comment'>-- This makes a real difference wrt. usage demands. The other reason is being</span>
<a name="line-860"></a><span class='hs-comment'>-- able to unleash a more precise product demand on its RHS once we know how the</span>
<a name="line-861"></a><span class='hs-comment'>-- thunk was used in the let body.</span>
<a name="line-862"></a><span class='hs-comment'>--</span>
<a name="line-863"></a><span class='hs-comment'>-- Characteristic examples, always assuming a single evaluation:</span>
<a name="line-864"></a><span class='hs-comment'>--</span>
<a name="line-865"></a><span class='hs-comment'>--   * @let x = 2*y in x + x@ =&gt; LetUp. Compared to LetDown, we find out that</span>
<a name="line-866"></a><span class='hs-comment'>--     the expression uses @y@ at most once.</span>
<a name="line-867"></a><span class='hs-comment'>--   * @let x = (a,b) in fst x@ =&gt; LetUp. Compared to LetDown, we find out that</span>
<a name="line-868"></a><span class='hs-comment'>--     @b@ is absent.</span>
<a name="line-869"></a><span class='hs-comment'>--   * @let f x = x*2 in f y@ =&gt; LetDown. Compared to LetUp, we find out that</span>
<a name="line-870"></a><span class='hs-comment'>--     the expression uses @y@ strictly, because we have @f@'s demand signature</span>
<a name="line-871"></a><span class='hs-comment'>--     available at the call site.</span>
<a name="line-872"></a><span class='hs-comment'>--   * @join exit = 2*y in if a then exit else if b then exit else 3*y@ =&gt;</span>
<a name="line-873"></a><span class='hs-comment'>--     LetDown. Compared to LetUp, we find out that the expression uses @y@</span>
<a name="line-874"></a><span class='hs-comment'>--     strictly, because we can unleash @exit@'s signature at each call site.</span>
<a name="line-875"></a><span class='hs-comment'>--   * For a more convincing example with join points, see Note [Demand analysis</span>
<a name="line-876"></a><span class='hs-comment'>--     for join points].</span>
<a name="line-877"></a><span class='hs-comment'>--</span>
<a name="line-878"></a><span class='hs-definition'>useLetUp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-879"></a><span class='hs-definition'>useLetUp</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNotTopLevel</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>idArity</span> <span class='hs-varid'>f</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isJoinId</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span>
<a name="line-880"></a>
<a name="line-881"></a><span class='hs-comment'>{- Note [Demand analysis for join points]
<a name="line-882"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-883"></a>Consider
<a name="line-884"></a>   g :: (Int,Int) -&gt; Int
<a name="line-885"></a>   g (p,q) = p+q
<a name="line-886"></a>
<a name="line-887"></a>   f :: T -&gt; Int -&gt; Int
<a name="line-888"></a>   f x p = g (join j y = (p,y)
<a name="line-889"></a>              in case x of
<a name="line-890"></a>                   A -&gt; j 3
<a name="line-891"></a>                   B -&gt; j 4
<a name="line-892"></a>                   C -&gt; (p,7))
<a name="line-893"></a>
<a name="line-894"></a>If j was a vanilla function definition, we'd analyse its body with
<a name="line-895"></a>evalDmd, and think that it was lazy in p.  But for join points we can
<a name="line-896"></a>do better!  We know that j's body will (if called at all) be evaluated
<a name="line-897"></a>with the demand that consumes the entire join-binding, in this case
<a name="line-898"></a>the argument demand from g.  Whizzo!  g evaluates both components of
<a name="line-899"></a>its argument pair, so p will certainly be evaluated if j is called.
<a name="line-900"></a>
<a name="line-901"></a>For f to be strict in p, we need /all/ paths to evaluate p; in this
<a name="line-902"></a>case the C branch does so too, so we are fine.  So, as usual, we need
<a name="line-903"></a>to transport demands on free variables to the call site(s).  Compare
<a name="line-904"></a>Note [Lazy and unleashable free variables].
<a name="line-905"></a>
<a name="line-906"></a>The implementation is easy.  When analysing a join point, we can
<a name="line-907"></a>analyse its body with the demand from the entire join-binding (written
<a name="line-908"></a>let_dmd here).
<a name="line-909"></a>
<a name="line-910"></a>Another win for join points!  #13543.
<a name="line-911"></a>
<a name="line-912"></a>However, note that the strictness signature for a join point can
<a name="line-913"></a>look a little puzzling.  E.g.
<a name="line-914"></a>
<a name="line-915"></a>    (join j x = \y. error "urk")
<a name="line-916"></a>    (in case v of              )
<a name="line-917"></a>    (     A -&gt; j 3             )  x
<a name="line-918"></a>    (     B -&gt; j 4             )
<a name="line-919"></a>    (     C -&gt; \y. blah        )
<a name="line-920"></a>
<a name="line-921"></a>The entire thing is in a C1(L) context, so j's strictness signature
<a name="line-922"></a>will be    [A]b
<a name="line-923"></a>meaning one absent argument, returns bottom.  That seems odd because
<a name="line-924"></a>there's a \y inside.  But it's right because when consumed in a C1(L)
<a name="line-925"></a>context the RHS of the join point is indeed bottom.
<a name="line-926"></a>
<a name="line-927"></a>Note [Demand signatures are computed for a threshold demand based on idArity]
<a name="line-928"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-929"></a>We compute demand signatures assuming idArity incoming arguments to approximate
<a name="line-930"></a>behavior for when we have a call site with at least that many arguments. idArity
<a name="line-931"></a>is /at least/ the number of manifest lambdas, but might be higher for PAPs and
<a name="line-932"></a>trivial RHS (see Note [Demand analysis for trivial right-hand sides]).
<a name="line-933"></a>
<a name="line-934"></a>Because idArity of a function varies independently of its cardinality
<a name="line-935"></a>properties (cf. Note [idArity varies independently of dmdTypeDepth]), we
<a name="line-936"></a>implicitly encode the arity for when a demand signature is sound to unleash
<a name="line-937"></a>in its 'dmdTypeDepth' (cf. Note [Understanding DmdType and StrictSig] in
<a name="line-938"></a>GHC.Types.Demand). It is unsound to unleash a demand signature when the
<a name="line-939"></a>incoming number of arguments is less than that.
<a name="line-940"></a>See Note [What are demand signatures?] in GHC.Types.Demand for more details
<a name="line-941"></a>on soundness.
<a name="line-942"></a>
<a name="line-943"></a>Why idArity arguments? Because that's a conservative estimate of how many
<a name="line-944"></a>arguments we must feed a function before it does anything interesting with them.
<a name="line-945"></a>Also it elegantly subsumes the trivial RHS and PAP case.
<a name="line-946"></a>
<a name="line-947"></a>There might be functions for which we might want to analyse for more incoming
<a name="line-948"></a>arguments than idArity. Example:
<a name="line-949"></a>
<a name="line-950"></a>  f x =
<a name="line-951"></a>    if expensive
<a name="line-952"></a>      then \y -&gt; ... y ...
<a name="line-953"></a>      else \y -&gt; ... y ...
<a name="line-954"></a>
<a name="line-955"></a>We'd analyse `f` under a unary call demand C1(L), corresponding to idArity
<a name="line-956"></a>being 1. That's enough to look under the manifest lambda and find out how a
<a name="line-957"></a>unary call would use `x`, but not enough to look into the lambdas in the if
<a name="line-958"></a>branches.
<a name="line-959"></a>
<a name="line-960"></a>On the other hand, if we analysed for call demand C1(C1(L)), we'd get useful
<a name="line-961"></a>strictness info for `y` (and more precise info on `x`) and possibly CPR
<a name="line-962"></a>information, but
<a name="line-963"></a>
<a name="line-964"></a>  * We would no longer be able to unleash the signature at unary call sites
<a name="line-965"></a>  * Performing the worker/wrapper split based on this information would be
<a name="line-966"></a>    implicitly eta-expanding `f`, playing fast and loose with divergence and
<a name="line-967"></a>    even being unsound in the presence of newtypes, so we refrain from doing so.
<a name="line-968"></a>    Also see Note [Don't eta expand in w/w] in GHC.Core.Opt.WorkWrap.
<a name="line-969"></a>
<a name="line-970"></a>Since we only compute one signature, we do so for arity 1. Computing multiple
<a name="line-971"></a>signatures for different arities (i.e., polyvariance) would be entirely
<a name="line-972"></a>possible, if it weren't for the additional runtime and implementation
<a name="line-973"></a>complexity.
<a name="line-974"></a>
<a name="line-975"></a>Note [idArity varies independently of dmdTypeDepth]
<a name="line-976"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-977"></a>We used to check in GHC.Core.Lint that dmdTypeDepth &lt;= idArity for a let-bound
<a name="line-978"></a>identifier. But that means we would have to zap demand signatures every time we
<a name="line-979"></a>reset or decrease arity. That's an unnecessary dependency, because
<a name="line-980"></a>
<a name="line-981"></a>  * The demand signature captures a semantic property that is independent of
<a name="line-982"></a>    what the binding's current arity is
<a name="line-983"></a>  * idArity is analysis information itself, thus volatile
<a name="line-984"></a>  * We already *have* dmdTypeDepth, wo why not just use it to encode the
<a name="line-985"></a>    threshold for when to unleash the signature
<a name="line-986"></a>    (cf. Note [Understanding DmdType and StrictSig] in GHC.Types.Demand)
<a name="line-987"></a>
<a name="line-988"></a>Consider the following expression, for example:
<a name="line-989"></a>
<a name="line-990"></a>    (let go x y = `x` seq ... in go) |&gt; co
<a name="line-991"></a>
<a name="line-992"></a>`go` might have a strictness signature of `&lt;1L&gt;&lt;L&gt;`. The simplifier will identify
<a name="line-993"></a>`go` as a nullary join point through `joinPointBinding_maybe` and float the
<a name="line-994"></a>coercion into the binding, leading to an arity decrease:
<a name="line-995"></a>
<a name="line-996"></a>    join go = (\x y -&gt; `x` seq ...) |&gt; co in go
<a name="line-997"></a>
<a name="line-998"></a>With the CoreLint check, we would have to zap `go`'s perfectly viable strictness
<a name="line-999"></a>signature.
<a name="line-1000"></a>
<a name="line-1001"></a>Note [Demand analysis for trivial right-hand sides]
<a name="line-1002"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1003"></a>Consider
<a name="line-1004"></a>    foo = plusInt |&gt; co
<a name="line-1005"></a>where plusInt is an arity-2 function with known strictness.  Clearly
<a name="line-1006"></a>we want plusInt's strictness to propagate to foo!  But because it has
<a name="line-1007"></a>no manifest lambdas, it won't do so automatically, and indeed 'co' might
<a name="line-1008"></a>have type (Int-&gt;Int-&gt;Int) ~ T.
<a name="line-1009"></a>
<a name="line-1010"></a>Fortunately, GHC.Core.Opt.Arity gives 'foo' arity 2, which is enough for LetDown to
<a name="line-1011"></a>forward plusInt's demand signature, and all is well (see Note [Newtype arity] in
<a name="line-1012"></a>GHC.Core.Opt.Arity)! A small example is the test case NewtypeArity.
<a name="line-1013"></a>
<a name="line-1014"></a>Note [Absence analysis for stable unfoldings and RULES]
<a name="line-1015"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1016"></a>Ticket #18638 shows that it's really important to do absence analysis
<a name="line-1017"></a>for stable unfoldings. Consider
<a name="line-1018"></a>
<a name="line-1019"></a>   g = blah
<a name="line-1020"></a>
<a name="line-1021"></a>   f = \x.  ...no use of g....
<a name="line-1022"></a>   {- f's stable unfolding is f = \x. ...g... -}
<a name="line-1023"></a>
<a name="line-1024"></a>If f is ever inlined we use 'g'. But f's current RHS makes no use
<a name="line-1025"></a>of 'g', so if we don't look at the unfolding we'll mark g as Absent,
<a name="line-1026"></a>and transform to
<a name="line-1027"></a>
<a name="line-1028"></a>   g = error "Entered absent value"
<a name="line-1029"></a>   f = \x. ...
<a name="line-1030"></a>   {- f's stable unfolding is f = \x. ...g... -}
<a name="line-1031"></a>
<a name="line-1032"></a>Now if f is subsequently inlined, we'll use 'g' and ... disaster.
<a name="line-1033"></a>
<a name="line-1034"></a>SOLUTION: if f has a stable unfolding, adjust its DmdEnv (the demands
<a name="line-1035"></a>on its free variables) so that no variable mentioned in its unfolding
<a name="line-1036"></a>is Absent.  This is done by the function Demand.keepAliveDmdEnv.
<a name="line-1037"></a>
<a name="line-1038"></a>ALSO: do the same for Ids free in the RHS of any RULES for f.
<a name="line-1039"></a>
<a name="line-1040"></a>PS: You may wonder how it can be that f's optimised RHS has somehow
<a name="line-1041"></a>discarded 'g', but when f is inlined we /don't/ discard g in the same
<a name="line-1042"></a>way. I think a simple example is
<a name="line-1043"></a>   g = (a,b)
<a name="line-1044"></a>   f = \x.  fst g
<a name="line-1045"></a>   {-# INLINE f #-}
<a name="line-1046"></a>
<a name="line-1047"></a>Now f's optimised RHS will be \x.a, but if we change g to (error "..")
<a name="line-1048"></a>(since it is apparently Absent) and then inline (\x. fst g) we get
<a name="line-1049"></a>disaster.  But regardless, #18638 was a more complicated version of
<a name="line-1050"></a>this, that actually happened in practice.
<a name="line-1051"></a>
<a name="line-1052"></a>Historical Note [Product demands for function body]
<a name="line-1053"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1054"></a>In 2013 I spotted this example, in shootout/binary_trees:
<a name="line-1055"></a>
<a name="line-1056"></a>    Main.check' = \ b z ds. case z of z' { I# ip -&gt;
<a name="line-1057"></a>                                case ds_d13s of
<a name="line-1058"></a>                                  Main.Nil -&gt; z'
<a name="line-1059"></a>                                  Main.Node s14k s14l s14m -&gt;
<a name="line-1060"></a>                                    Main.check' (not b)
<a name="line-1061"></a>                                      (Main.check' b
<a name="line-1062"></a>                                         (case b {
<a name="line-1063"></a>                                            False -&gt; I# (-# s14h s14k);
<a name="line-1064"></a>                                            True  -&gt; I# (+# s14h s14k)
<a name="line-1065"></a>                                          })
<a name="line-1066"></a>                                         s14l)
<a name="line-1067"></a>                                     s14m   }   }   }
<a name="line-1068"></a>
<a name="line-1069"></a>Here we *really* want to unbox z, even though it appears to be used boxed in
<a name="line-1070"></a>the Nil case.  Partly the Nil case is not a hot path.  But more specifically,
<a name="line-1071"></a>the whole function gets the CPR property if we do.
<a name="line-1072"></a>
<a name="line-1073"></a>That motivated using a demand of C1(C1(C1(P(L,L)))) for the RHS, where
<a name="line-1074"></a>(solely because the result was a product) we used a product demand
<a name="line-1075"></a>(albeit with lazy components) for the body. But that gives very silly
<a name="line-1076"></a>behaviour -- see #17932.   Happily it turns out now to be entirely
<a name="line-1077"></a>unnecessary: we get good results with C1(C1(C1(L))).   So I simply
<a name="line-1078"></a>deleted the special case.
<a name="line-1079"></a>-}</span>
<a name="line-1080"></a>
<a name="line-1081"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-1082"></a>*                                                                      *
<a name="line-1083"></a>                      Fixpoints
<a name="line-1084"></a>*                                                                      *
<a name="line-1085"></a>********************************************************************* -}</span>
<a name="line-1086"></a>
<a name="line-1087"></a><a name="dmdFix"></a><span class='hs-comment'>-- Recursive bindings</span>
<a name="line-1088"></a><span class='hs-definition'>dmdFix</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-1089"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>                            <span class='hs-comment'>-- Does not include bindings for this binding</span>
<a name="line-1090"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SubDemand</span>
<a name="line-1091"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1092"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>DmdEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Binders annotated with strictness info</span>
<a name="line-1093"></a>
<a name="line-1094"></a><span class='hs-definition'>dmdFix</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>let_dmd</span> <span class='hs-varid'>orig_pairs</span>
<a name="line-1095"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loop</span> <span class='hs-num'>1</span> <span class='hs-varid'>initial_pairs</span>
<a name="line-1096"></a>  <span class='hs-keyword'>where</span>
<a name="line-1097"></a>    <span class='hs-comment'>-- See Note [Initialising strictness]</span>
<a name="line-1098"></a>    <span class='hs-varid'>initial_pairs</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>setIdStrictness</span> <span class='hs-varid'>id</span> <span class='hs-varid'>botSig</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>orig_pairs</span> <span class='hs-keyglyph'>]</span>
<a name="line-1099"></a>                  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>orig_pairs</span>
<a name="line-1100"></a>
<a name="line-1101"></a>    <span class='hs-comment'>-- If fixed-point iteration does not yield a result we use this instead</span>
<a name="line-1102"></a>    <span class='hs-comment'>-- See Note [Safe abortion in the fixed-point iteration]</span>
<a name="line-1103"></a>    <span class='hs-varid'>abort</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>DmdEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1104"></a>    <span class='hs-varid'>abort</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazy_fv'</span><span class='hs-layout'>,</span> <span class='hs-varid'>zapped_pairs</span><span class='hs-layout'>)</span>
<a name="line-1105"></a>      <span class='hs-keyword'>where</span> <span class='hs-layout'>(</span><span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>step</span> <span class='hs-conid'>True</span> <span class='hs-layout'>(</span><span class='hs-varid'>zapIdStrictness</span> <span class='hs-varid'>orig_pairs</span><span class='hs-layout'>)</span>
<a name="line-1106"></a>            <span class='hs-comment'>-- Note [Lazy and unleashable free variables]</span>
<a name="line-1107"></a>            <span class='hs-varid'>non_lazy_fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>plusVarEnvList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>strictSigDmdEnv</span> <span class='hs-varop'>.</span> <span class='hs-varid'>idStrictness</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs'</span>
<a name="line-1108"></a>            <span class='hs-varid'>lazy_fv'</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lazy_fv</span> <span class='hs-varop'>`plusVarEnv`</span> <span class='hs-varid'>mapVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-varid'>topDmd</span><span class='hs-layout'>)</span> <span class='hs-varid'>non_lazy_fvs</span>
<a name="line-1109"></a>            <span class='hs-varid'>zapped_pairs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapIdStrictness</span> <span class='hs-varid'>pairs'</span>
<a name="line-1110"></a>
<a name="line-1111"></a>    <span class='hs-comment'>-- The fixed-point varies the idStrictness field of the binders, and terminates if that</span>
<a name="line-1112"></a>    <span class='hs-comment'>-- annotation does not change any more.</span>
<a name="line-1113"></a>    <span class='hs-varid'>loop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>DmdEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1114"></a>    <span class='hs-varid'>loop</span> <span class='hs-varid'>n</span> <span class='hs-varid'>pairs</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "dmdFix" (ppr n &lt;+&gt; vcat [ ppr id &lt;+&gt; ppr (idStrictness id)</span>
<a name="line-1115"></a>                   <span class='hs-comment'>--                                     | (id,_)&lt;- pairs]) $</span>
<a name="line-1116"></a>                   <span class='hs-varid'>loop'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>pairs</span>
<a name="line-1117"></a>
<a name="line-1118"></a>    <span class='hs-varid'>loop'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>pairs</span>
<a name="line-1119"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>found_fixpoint</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>final_anal_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span>
<a name="line-1120"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>==</span> <span class='hs-num'>10</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>abort</span>
<a name="line-1121"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loop</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs'</span>
<a name="line-1122"></a>      <span class='hs-keyword'>where</span>
<a name="line-1123"></a>        <span class='hs-varid'>found_fixpoint</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs'</span> <span class='hs-varop'>==</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs</span>
<a name="line-1124"></a>        <span class='hs-varid'>first_round</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-varop'>==</span> <span class='hs-num'>1</span>
<a name="line-1125"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>step</span> <span class='hs-varid'>first_round</span> <span class='hs-varid'>pairs</span>
<a name="line-1126"></a>        <span class='hs-varid'>final_anal_env</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendAnalEnvs</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span>
<a name="line-1127"></a>
<a name="line-1128"></a>    <span class='hs-varid'>step</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1129"></a>    <span class='hs-varid'>step</span> <span class='hs-varid'>first_round</span> <span class='hs-varid'>pairs</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>lazy_fv</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span>
<a name="line-1130"></a>      <span class='hs-keyword'>where</span>
<a name="line-1131"></a>        <span class='hs-comment'>-- In all but the first iteration, delete the virgin flag</span>
<a name="line-1132"></a>        <span class='hs-varid'>start_env</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>first_round</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-1133"></a>                  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nonVirgin</span> <span class='hs-varid'>env</span>
<a name="line-1134"></a>
<a name="line-1135"></a>        <span class='hs-varid'>start</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendAnalEnvs</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>start_env</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyVarEnv</span><span class='hs-layout'>)</span>
<a name="line-1136"></a>
<a name="line-1137"></a>        <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varop'>!</span><span class='hs-varid'>lazy_fv</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varop'>!</span><span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapAccumL</span> <span class='hs-varid'>my_downRhs</span> <span class='hs-varid'>start</span> <span class='hs-varid'>pairs</span>
<a name="line-1138"></a>                <span class='hs-comment'>-- mapAccumL: Use the new signature to do the next pair</span>
<a name="line-1139"></a>                <span class='hs-comment'>-- The occurrence analyser has arranged them in a good order</span>
<a name="line-1140"></a>                <span class='hs-comment'>-- so this can significantly reduce the number of iterations needed</span>
<a name="line-1141"></a>
<a name="line-1142"></a>        <span class='hs-varid'>my_downRhs</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazy_fv</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span><span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1143"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "my_downRhs" (ppr id $$ ppr (idStrictness id) $$ ppr sig) $</span>
<a name="line-1144"></a>            <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazy_fv'</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>id'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1145"></a>          <span class='hs-keyword'>where</span>
<a name="line-1146"></a>            <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-varop'>!</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varop'>!</span><span class='hs-varid'>lazy_fv1</span><span class='hs-layout'>,</span> <span class='hs-varop'>!</span><span class='hs-varid'>id'</span><span class='hs-layout'>,</span> <span class='hs-varop'>!</span><span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalRhsSig</span> <span class='hs-varid'>top_lvl</span> <span class='hs-conid'>Recursive</span> <span class='hs-varid'>env</span> <span class='hs-varid'>let_dmd</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-1147"></a>            <span class='hs-varop'>!</span><span class='hs-varid'>lazy_fv'</span>                    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>plusVarEnv_C</span> <span class='hs-varid'>plusDmd</span> <span class='hs-varid'>lazy_fv</span> <span class='hs-varid'>lazy_fv1</span>
<a name="line-1148"></a>
<a name="line-1149"></a>    <span class='hs-varid'>zapIdStrictness</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1150"></a>    <span class='hs-varid'>zapIdStrictness</span> <span class='hs-varid'>pairs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>setIdStrictness</span> <span class='hs-varid'>id</span> <span class='hs-varid'>nopSig</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pairs</span> <span class='hs-keyglyph'>]</span>
<a name="line-1151"></a>
<a name="line-1152"></a><span class='hs-comment'>{- Note [Safe abortion in the fixed-point iteration]
<a name="line-1153"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1154"></a>
<a name="line-1155"></a>Fixed-point iteration may fail to terminate. But we cannot simply give up and
<a name="line-1156"></a>return the environment and code unchanged! We still need to do one additional
<a name="line-1157"></a>round, for two reasons:
<a name="line-1158"></a>
<a name="line-1159"></a> * To get information on used free variables (both lazy and strict!)
<a name="line-1160"></a>   (see Note [Lazy and unleashable free variables])
<a name="line-1161"></a> * To ensure that all expressions have been traversed at least once, and any left-over
<a name="line-1162"></a>   strictness annotations have been updated.
<a name="line-1163"></a>
<a name="line-1164"></a>This final iteration does not add the variables to the strictness signature
<a name="line-1165"></a>environment, which effectively assigns them 'nopSig' (see "getStrictness")
<a name="line-1166"></a>
<a name="line-1167"></a>Note [Trimming a demand to a type]
<a name="line-1168"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1169"></a>There are two reasons we sometimes trim a demand to match a type.
<a name="line-1170"></a>  1. GADTs
<a name="line-1171"></a>  2. Recursive products and widening
<a name="line-1172"></a>
<a name="line-1173"></a>More on both below.  But the botttom line is: we really don't want to
<a name="line-1174"></a>have a binder whose demand is more deeply-nested than its type
<a name="line-1175"></a>"allows". So in findBndrDmd we call trimToType and findTypeShape to
<a name="line-1176"></a>trim the demand on the binder to a form that matches the type
<a name="line-1177"></a>
<a name="line-1178"></a>Now to the reasons. For (1) consider
<a name="line-1179"></a>  f :: a -&gt; Bool
<a name="line-1180"></a>  f x = case ... of
<a name="line-1181"></a>          A g1 -&gt; case (x |&gt; g1) of (p,q) -&gt; ...
<a name="line-1182"></a>          B    -&gt; error "urk"
<a name="line-1183"></a>
<a name="line-1184"></a>where A,B are the constructors of a GADT.  We'll get a 1P(L,L) demand
<a name="line-1185"></a>on x from the A branch, but that's a stupid demand for x itself, which
<a name="line-1186"></a>has type 'a'. Indeed we get ASSERTs going off (notably in
<a name="line-1187"></a>splitUseProdDmd, #8569).
<a name="line-1188"></a>
<a name="line-1189"></a>For (2) consider
<a name="line-1190"></a>  data T = MkT Int T    -- A recursive product
<a name="line-1191"></a>  f :: Int -&gt; T -&gt; Int
<a name="line-1192"></a>  f 0 _         = 0
<a name="line-1193"></a>  f _ (MkT n t) = f n t
<a name="line-1194"></a>
<a name="line-1195"></a>Here f is lazy in T, but its *usage* is infinite: P(L,P(L,P(L, ...))).
<a name="line-1196"></a>Notice that this happens because T is a product type, and is recrusive.
<a name="line-1197"></a>If we are not careful, we'll fail to iterate to a fixpoint in dmdFix,
<a name="line-1198"></a>and bale out entirely, which is inefficient and over-conservative.
<a name="line-1199"></a>
<a name="line-1200"></a>Worse, as we discovered in #18304, the size of the usages we compute
<a name="line-1201"></a>can grow /exponentially/, so even 10 iterations costs far too much.
<a name="line-1202"></a>Especially since we then discard the result.
<a name="line-1203"></a>
<a name="line-1204"></a>To avoid this we use the same findTypeShape function as for (1), but
<a name="line-1205"></a>arrange that it trims the demand if it encounters the same type constructor
<a name="line-1206"></a>twice (or three times, etc).  We use our standard RecTcChecker mechanism
<a name="line-1207"></a>for this -- see GHC.Core.Opt.WorkWrap.Utils.findTypeShape.
<a name="line-1208"></a>
<a name="line-1209"></a>This is usually call "widening".  We could do it just in dmdFix, but
<a name="line-1210"></a>since are doing this findTypeShape business /anyway/ because of (1),
<a name="line-1211"></a>and it has all the right information to hand, it's extremely
<a name="line-1212"></a>convenient to do it there.
<a name="line-1213"></a>
<a name="line-1214"></a>-}</span>
<a name="line-1215"></a>
<a name="line-1216"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-1217"></a>*                                                                      *
<a name="line-1218"></a>                 Strictness signatures and types
<a name="line-1219"></a>*                                                                      *
<a name="line-1220"></a>********************************************************************* -}</span>
<a name="line-1221"></a>
<a name="line-1222"></a><a name="unitDmdType"></a><span class='hs-definition'>unitDmdType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DmdEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span>
<a name="line-1223"></a><span class='hs-definition'>unitDmdType</span> <span class='hs-varid'>dmd_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DmdType</span> <span class='hs-varid'>dmd_env</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>topDiv</span>
<a name="line-1224"></a>
<a name="line-1225"></a><a name="coercionDmdEnv"></a><span class='hs-definition'>coercionDmdEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdEnv</span>
<a name="line-1226"></a><span class='hs-definition'>coercionDmdEnv</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-varid'>topDmd</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>getUniqSet</span> <span class='hs-varop'>$</span> <span class='hs-varid'>coVarsOfCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1227"></a>                    <span class='hs-comment'>-- The VarSet from coVarsOfCo is really a VarEnv Var</span>
<a name="line-1228"></a>
<a name="line-1229"></a><a name="addVarDmd"></a><span class='hs-definition'>addVarDmd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span>
<a name="line-1230"></a><span class='hs-definition'>addVarDmd</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span> <span class='hs-varid'>fv</span> <span class='hs-varid'>ds</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-varid'>var</span> <span class='hs-varid'>dmd</span>
<a name="line-1231"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DmdType</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendVarEnv_C</span> <span class='hs-varid'>plusDmd</span> <span class='hs-varid'>fv</span> <span class='hs-varid'>var</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span> <span class='hs-varid'>ds</span> <span class='hs-varid'>res</span>
<a name="line-1232"></a>
<a name="line-1233"></a><a name="addLazyFVs"></a><span class='hs-definition'>addLazyFVs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span>
<a name="line-1234"></a><span class='hs-definition'>addLazyFVs</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>lazy_fvs</span>
<a name="line-1235"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varop'>`plusDmdType`</span> <span class='hs-varid'>mkPlusDmdArg</span> <span class='hs-varid'>lazy_fvs</span>
<a name="line-1236"></a>        <span class='hs-comment'>-- Using plusDmdType (rather than just plus'ing the envs)</span>
<a name="line-1237"></a>        <span class='hs-comment'>-- is vital.  Consider</span>
<a name="line-1238"></a>        <span class='hs-comment'>--      let f = \x -&gt; (x,y)</span>
<a name="line-1239"></a>        <span class='hs-comment'>--      in  error (f 3)</span>
<a name="line-1240"></a>        <span class='hs-comment'>-- Here, y is treated as a lazy-fv of f, but we must `plusDmd` that L</span>
<a name="line-1241"></a>        <span class='hs-comment'>-- demand with the bottom coming up from 'error'</span>
<a name="line-1242"></a>        <span class='hs-comment'>--</span>
<a name="line-1243"></a>        <span class='hs-comment'>-- I got a loop in the fixpointer without this, due to an interaction</span>
<a name="line-1244"></a>        <span class='hs-comment'>-- with the lazy_fv filtering in dmdAnalRhsSig.  Roughly, it was</span>
<a name="line-1245"></a>        <span class='hs-comment'>--      letrec f n x</span>
<a name="line-1246"></a>        <span class='hs-comment'>--          = letrec g y = x `fatbar`</span>
<a name="line-1247"></a>        <span class='hs-comment'>--                         letrec h z = z + ...g...</span>
<a name="line-1248"></a>        <span class='hs-comment'>--                         in h (f (n-1) x)</span>
<a name="line-1249"></a>        <span class='hs-comment'>--      in ...</span>
<a name="line-1250"></a>        <span class='hs-comment'>-- In the initial iteration for f, f=Bot</span>
<a name="line-1251"></a>        <span class='hs-comment'>-- Suppose h is found to be strict in z, but the occurrence of g in its RHS</span>
<a name="line-1252"></a>        <span class='hs-comment'>-- is lazy.  Now consider the fixpoint iteration for g, esp the demands it</span>
<a name="line-1253"></a>        <span class='hs-comment'>-- places on its free variables.  Suppose it places none.  Then the</span>
<a name="line-1254"></a>        <span class='hs-comment'>--      x `fatbar` ...call to h...</span>
<a name="line-1255"></a>        <span class='hs-comment'>-- will give a x-&gt;V demand for x.  That turns into a L demand for x,</span>
<a name="line-1256"></a>        <span class='hs-comment'>-- which floats out of the defn for h.  Without the modifyEnv, that</span>
<a name="line-1257"></a>        <span class='hs-comment'>-- L demand doesn't get both'd with the Bot coming up from the inner</span>
<a name="line-1258"></a>        <span class='hs-comment'>-- call to f.  So we just get an L demand for x for g.</span>
<a name="line-1259"></a>
<a name="line-1260"></a><span class='hs-comment'>{-
<a name="line-1261"></a>Note [Do not strictify the argument dictionaries of a dfun]
<a name="line-1262"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1263"></a>The typechecker can tie recursive knots involving dfuns, so we do the
<a name="line-1264"></a>conservative thing and refrain from strictifying a dfun's argument
<a name="line-1265"></a>dictionaries.
<a name="line-1266"></a>-}</span>
<a name="line-1267"></a>
<a name="line-1268"></a><a name="setBndrsDemandInfo"></a><span class='hs-definition'>setBndrsDemandInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span>
<a name="line-1269"></a><span class='hs-definition'>setBndrsDemandInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>ds</span>
<a name="line-1270"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>setBndrsDemandInfo</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>ds</span>
<a name="line-1271"></a><span class='hs-definition'>setBndrsDemandInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>d</span><span class='hs-conop'>:</span><span class='hs-varid'>ds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-1272"></a>    <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>new_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdDemandInfo</span> <span class='hs-varid'>b</span> <span class='hs-varid'>d</span>
<a name="line-1273"></a>        <span class='hs-varop'>!</span><span class='hs-varid'>vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setBndrsDemandInfo</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>ds</span>
<a name="line-1274"></a>    <span class='hs-keyword'>in</span> <span class='hs-varid'>new_info</span> <span class='hs-conop'>:</span> <span class='hs-varid'>vars</span>
<a name="line-1275"></a><span class='hs-definition'>setBndrsDemandInfo</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>ds</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>null</span> <span class='hs-varid'>ds</span> <span class='hs-layout'>)</span> <span class='hs-conid'>[]</span>
<a name="line-1276"></a><span class='hs-definition'>setBndrsDemandInfo</span> <span class='hs-varid'>bs</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"setBndrsDemandInfo"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span>
<a name="line-1277"></a>
<a name="line-1278"></a><a name="annotateBndr"></a><span class='hs-definition'>annotateBndr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-conid'>Var</span>
<a name="line-1279"></a><span class='hs-comment'>-- The returned env has the var deleted</span>
<a name="line-1280"></a><span class='hs-comment'>-- The returned var is annotated with demand info</span>
<a name="line-1281"></a><span class='hs-comment'>-- according to the result demand of the provided demand type</span>
<a name="line-1282"></a><span class='hs-comment'>-- No effect on the argument demands</span>
<a name="line-1283"></a><span class='hs-definition'>annotateBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>var</span>
<a name="line-1284"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>var</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty'</span> <span class='hs-varid'>new_id</span>
<a name="line-1285"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty</span>  <span class='hs-varid'>var</span>
<a name="line-1286"></a>  <span class='hs-keyword'>where</span>
<a name="line-1287"></a>    <span class='hs-varid'>new_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdDemandInfo</span> <span class='hs-varid'>var</span> <span class='hs-varid'>dmd</span>
<a name="line-1288"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty'</span> <span class='hs-varid'>dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findBndrDmd</span> <span class='hs-varid'>env</span> <span class='hs-conid'>False</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>var</span>
<a name="line-1289"></a>
<a name="line-1290"></a><a name="annotateLamIdBndr"></a><span class='hs-definition'>annotateLamIdBndr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-1291"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DFunFlag</span>   <span class='hs-comment'>-- is this lambda at the top of the RHS of a dfun?</span>
<a name="line-1292"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span>    <span class='hs-comment'>-- Demand type of body</span>
<a name="line-1293"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>         <span class='hs-comment'>-- Lambda binder</span>
<a name="line-1294"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-conid'>Id</span>  <span class='hs-comment'>-- Demand type of lambda</span>
<a name="line-1295"></a>                                     <span class='hs-comment'>-- and binder annotated with demand</span>
<a name="line-1296"></a>
<a name="line-1297"></a><span class='hs-definition'>annotateLamIdBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>arg_of_dfun</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>id</span>
<a name="line-1298"></a><span class='hs-comment'>-- For lambdas we add the demand to the argument demands</span>
<a name="line-1299"></a><span class='hs-comment'>-- Only called for Ids</span>
<a name="line-1300"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>id</span> <span class='hs-layout'>)</span>
<a name="line-1301"></a>    <span class='hs-comment'>-- pprTrace "annLamBndr" (vcat [ppr id, ppr dmd_ty, ppr final_ty]) $</span>
<a name="line-1302"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>final_ty</span> <span class='hs-varid'>new_id</span>
<a name="line-1303"></a>  <span class='hs-keyword'>where</span>
<a name="line-1304"></a>    <span class='hs-varid'>new_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdDemandInfo</span> <span class='hs-varid'>id</span> <span class='hs-varid'>dmd</span>
<a name="line-1305"></a>      <span class='hs-comment'>-- Watch out!  See note [Lambda-bound unfoldings]</span>
<a name="line-1306"></a>    <span class='hs-varid'>final_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>maybeUnfoldingTemplate</span> <span class='hs-layout'>(</span><span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-1307"></a>                 <span class='hs-conid'>Nothing</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>main_ty</span>
<a name="line-1308"></a>                 <span class='hs-conid'>Just</span> <span class='hs-varid'>unf</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>main_ty</span> <span class='hs-varop'>`plusDmdType`</span> <span class='hs-varid'>unf_ty</span>
<a name="line-1309"></a>                          <span class='hs-keyword'>where</span>
<a name="line-1310"></a>                             <span class='hs-layout'>(</span><span class='hs-varid'>unf_ty</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmdAnalStar</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>unf</span>
<a name="line-1311"></a>
<a name="line-1312"></a>    <span class='hs-varid'>main_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addDemand</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>dmd_ty'</span>
<a name="line-1313"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty'</span> <span class='hs-varid'>dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findBndrDmd</span> <span class='hs-varid'>env</span> <span class='hs-varid'>arg_of_dfun</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>id</span>
<a name="line-1314"></a>
<a name="line-1315"></a><span class='hs-comment'>{- Note [NOINLINE and strictness]
<a name="line-1316"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1317"></a>At one point we disabled strictness for NOINLINE functions, on the
<a name="line-1318"></a>grounds that they should be entirely opaque.  But that lost lots of
<a name="line-1319"></a>useful semantic strictness information, so now we analyse them like
<a name="line-1320"></a>any other function, and pin strictness information on them.
<a name="line-1321"></a>
<a name="line-1322"></a>That in turn forces us to worker/wrapper them; see
<a name="line-1323"></a>Note [Worker-wrapper for NOINLINE functions] in GHC.Core.Opt.WorkWrap.
<a name="line-1324"></a>
<a name="line-1325"></a>
<a name="line-1326"></a>Note [Lazy and unleashable free variables]
<a name="line-1327"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1328"></a>We put the strict and once-used FVs in the DmdType of the Id, so
<a name="line-1329"></a>that at its call sites we unleash demands on its strict fvs.
<a name="line-1330"></a>An example is 'roll' in imaginary/wheel-sieve2
<a name="line-1331"></a>Something like this:
<a name="line-1332"></a>        roll x = letrec
<a name="line-1333"></a>                     go y = if ... then roll (x-1) else x+1
<a name="line-1334"></a>                 in
<a name="line-1335"></a>                 go ms
<a name="line-1336"></a>We want to see that roll is strict in x, which is because
<a name="line-1337"></a>go is called.   So we put the DmdEnv for x in go's DmdType.
<a name="line-1338"></a>
<a name="line-1339"></a>Another example:
<a name="line-1340"></a>
<a name="line-1341"></a>        f :: Int -&gt; Int -&gt; Int
<a name="line-1342"></a>        f x y = let t = x+1
<a name="line-1343"></a>            h z = if z==0 then t else
<a name="line-1344"></a>                  if z==1 then x+1 else
<a name="line-1345"></a>                  x + h (z-1)
<a name="line-1346"></a>        in h y
<a name="line-1347"></a>
<a name="line-1348"></a>Calling h does indeed evaluate x, but we can only see
<a name="line-1349"></a>that if we unleash a demand on x at the call site for t.
<a name="line-1350"></a>
<a name="line-1351"></a>Incidentally, here's a place where lambda-lifting h would
<a name="line-1352"></a>lose the cigar --- we couldn't see the joint strictness in t/x
<a name="line-1353"></a>
<a name="line-1354"></a>        ON THE OTHER HAND
<a name="line-1355"></a>
<a name="line-1356"></a>We don't want to put *all* the fv's from the RHS into the
<a name="line-1357"></a>DmdType. Because
<a name="line-1358"></a>
<a name="line-1359"></a> * it makes the strictness signatures larger, and hence slows down fixpointing
<a name="line-1360"></a>
<a name="line-1361"></a>and
<a name="line-1362"></a>
<a name="line-1363"></a> * it is useless information at the call site anyways:
<a name="line-1364"></a>   For lazy, used-many times fv's we will never get any better result than
<a name="line-1365"></a>   that, no matter how good the actual demand on the function at the call site
<a name="line-1366"></a>   is (unless it is always absent, but then the whole binder is useless).
<a name="line-1367"></a>
<a name="line-1368"></a>Therefore we exclude lazy multiple-used fv's from the environment in the
<a name="line-1369"></a>DmdType.
<a name="line-1370"></a>
<a name="line-1371"></a>But now the signature lies! (Missing variables are assumed to be absent.) To
<a name="line-1372"></a>make up for this, the code that analyses the binding keeps the demand on those
<a name="line-1373"></a>variable separate (usually called "lazy_fv") and adds it to the demand of the
<a name="line-1374"></a>whole binding later.
<a name="line-1375"></a>
<a name="line-1376"></a>What if we decide _not_ to store a strictness signature for a binding at all, as
<a name="line-1377"></a>we do when aborting a fixed-point iteration? The we risk losing the information
<a name="line-1378"></a>that the strict variables are being used. In that case, we take all free variables
<a name="line-1379"></a>mentioned in the (unsound) strictness signature, conservatively approximate the
<a name="line-1380"></a>demand put on them (topDmd), and add that to the "lazy_fv" returned by "dmdFix".
<a name="line-1381"></a>
<a name="line-1382"></a>
<a name="line-1383"></a>Note [Lambda-bound unfoldings]
<a name="line-1384"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1385"></a>We allow a lambda-bound variable to carry an unfolding, a facility that is used
<a name="line-1386"></a>exclusively for join points; see Note [Case binders and join points].  If so,
<a name="line-1387"></a>we must be careful to demand-analyse the RHS of the unfolding!  Example
<a name="line-1388"></a>   \x. \y{=Just x}. &lt;body&gt;
<a name="line-1389"></a>Then if &lt;body&gt; uses 'y', then transitively it uses 'x', and we must not
<a name="line-1390"></a>forget that fact, otherwise we might make 'x' absent when it isn't.
<a name="line-1391"></a>
<a name="line-1392"></a>
<a name="line-1393"></a>************************************************************************
<a name="line-1394"></a>*                                                                      *
<a name="line-1395"></a>\subsection{Strictness signatures}
<a name="line-1396"></a>*                                                                      *
<a name="line-1397"></a>************************************************************************
<a name="line-1398"></a>-}</span>
<a name="line-1399"></a>
<a name="line-1400"></a><a name="DFunFlag"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>DFunFlag</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Bool</span>  <span class='hs-comment'>-- indicates if the lambda being considered is in the</span>
<a name="line-1401"></a>                      <span class='hs-comment'>-- sequence of lambdas at the top of the RHS of a dfun</span>
<a name="line-1402"></a><a name="notArgOfDfun"></a><span class='hs-definition'>notArgOfDfun</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DFunFlag</span>
<a name="line-1403"></a><span class='hs-definition'>notArgOfDfun</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1404"></a>
<a name="line-1405"></a><a name="AnalEnv"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AE</span>
<a name="line-1406"></a>   <span class='hs-layout'>{</span> <span class='hs-varid'>ae_strict_dicts</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span> <span class='hs-comment'>-- ^ Enable strict dict</span>
<a name="line-1407"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>ae_sigs</span>         <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>SigEnv</span>
<a name="line-1408"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>ae_virgin</span>       <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span> <span class='hs-comment'>-- ^ True on first iteration only</span>
<a name="line-1409"></a>                              <span class='hs-comment'>-- See Note [Initialising strictness]</span>
<a name="line-1410"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>ae_fam_envs</span>     <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>FamInstEnvs</span>
<a name="line-1411"></a>   <span class='hs-layout'>}</span>
<a name="line-1412"></a>
<a name="line-1413"></a>        <span class='hs-comment'>-- We use the se_env to tell us whether to</span>
<a name="line-1414"></a>        <span class='hs-comment'>-- record info about a variable in the DmdEnv</span>
<a name="line-1415"></a>        <span class='hs-comment'>-- We do so if it's a LocalId, but not top-level</span>
<a name="line-1416"></a>        <span class='hs-comment'>--</span>
<a name="line-1417"></a>        <span class='hs-comment'>-- The DmdEnv gives the demand on the free vars of the function</span>
<a name="line-1418"></a>        <span class='hs-comment'>-- when it is given enough args to satisfy the strictness signature</span>
<a name="line-1419"></a>
<a name="line-1420"></a><a name="SigEnv"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>SigEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>VarEnv</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictSig</span><span class='hs-layout'>,</span> <span class='hs-conid'>TopLevelFlag</span><span class='hs-layout'>)</span>
<a name="line-1421"></a>
<a name="line-1422"></a><a name="instance%20Outputable%20AnalEnv"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyword'>where</span>
<a name="line-1423"></a>  <span class='hs-varid'>ppr</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"AE"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span>
<a name="line-1424"></a>         <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ae_virgin ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_virgin</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-1425"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ae_strict_dicts ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_strict_dicts</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-1426"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ae_sigs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_sigs</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-1427"></a>         <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1428"></a>
<a name="line-1429"></a><a name="emptyAnalEnv"></a><span class='hs-definition'>emptyAnalEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DmdAnalOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-1430"></a><span class='hs-definition'>emptyAnalEnv</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>fam_envs</span>
<a name="line-1431"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_strict_dicts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd_strict_dicts</span> <span class='hs-varid'>opts</span>
<a name="line-1432"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>ae_sigs</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptySigEnv</span>
<a name="line-1433"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>ae_virgin</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1434"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>ae_fam_envs</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fam_envs</span>
<a name="line-1435"></a>         <span class='hs-layout'>}</span>
<a name="line-1436"></a>
<a name="line-1437"></a><a name="emptySigEnv"></a><span class='hs-definition'>emptySigEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SigEnv</span>
<a name="line-1438"></a><span class='hs-definition'>emptySigEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span>
<a name="line-1439"></a>
<a name="line-1440"></a><a name="extendAnalEnvs"></a><span class='hs-comment'>-- | Extend an environment with the strictness IDs attached to the id</span>
<a name="line-1441"></a><span class='hs-definition'>extendAnalEnvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-1442"></a><span class='hs-definition'>extendAnalEnvs</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>vars</span>
<a name="line-1443"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSigEnvs</span> <span class='hs-varid'>top_lvl</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_sigs</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>vars</span> <span class='hs-layout'>}</span>
<a name="line-1444"></a>
<a name="line-1445"></a><a name="extendSigEnvs"></a><span class='hs-definition'>extendSigEnvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SigEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SigEnv</span>
<a name="line-1446"></a><span class='hs-definition'>extendSigEnvs</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>vars</span>
<a name="line-1447"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendVarEnvList</span> <span class='hs-varid'>sigs</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>var</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>var</span><span class='hs-layout'>,</span> <span class='hs-varid'>top_lvl</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>vars</span><span class='hs-keyglyph'>]</span>
<a name="line-1448"></a>
<a name="line-1449"></a><a name="extendAnalEnv"></a><span class='hs-definition'>extendAnalEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StrictSig</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-1450"></a><span class='hs-definition'>extendAnalEnv</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span> <span class='hs-varid'>sig</span>
<a name="line-1451"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSigEnv</span> <span class='hs-varid'>top_lvl</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_sigs</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>var</span> <span class='hs-varid'>sig</span> <span class='hs-layout'>}</span>
<a name="line-1452"></a>
<a name="line-1453"></a><a name="extendSigEnv"></a><span class='hs-definition'>extendSigEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SigEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StrictSig</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SigEnv</span>
<a name="line-1454"></a><span class='hs-definition'>extendSigEnv</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>var</span> <span class='hs-varid'>sig</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendVarEnv</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>var</span> <span class='hs-layout'>(</span><span class='hs-varid'>sig</span><span class='hs-layout'>,</span> <span class='hs-varid'>top_lvl</span><span class='hs-layout'>)</span>
<a name="line-1455"></a>
<a name="line-1456"></a><a name="lookupSigEnv"></a><span class='hs-definition'>lookupSigEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictSig</span><span class='hs-layout'>,</span> <span class='hs-conid'>TopLevelFlag</span><span class='hs-layout'>)</span>
<a name="line-1457"></a><span class='hs-definition'>lookupSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_sigs</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>id</span>
<a name="line-1458"></a>
<a name="line-1459"></a><a name="nonVirgin"></a><span class='hs-definition'>nonVirgin</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-1460"></a><span class='hs-definition'>nonVirgin</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span>
<a name="line-1461"></a>
<a name="line-1462"></a><a name="findBndrsDmds"></a><span class='hs-definition'>findBndrsDmds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span>
<a name="line-1463"></a><span class='hs-comment'>-- Return the demands on the Ids in the [Var]</span>
<a name="line-1464"></a><span class='hs-definition'>findBndrsDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>bndrs</span>
<a name="line-1465"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>bndrs</span>
<a name="line-1466"></a>  <span class='hs-keyword'>where</span>
<a name="line-1467"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-conid'>[]</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-conid'>[]</span>
<a name="line-1468"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span>
<a name="line-1469"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>b</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty1</span> <span class='hs-varid'>dmds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>bs</span>
<a name="line-1470"></a>                        <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty2</span> <span class='hs-varid'>dmd</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findBndrDmd</span> <span class='hs-varid'>env</span> <span class='hs-conid'>False</span> <span class='hs-varid'>dmd_ty1</span> <span class='hs-varid'>b</span>
<a name="line-1471"></a>                    <span class='hs-keyword'>in</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty2</span>  <span class='hs-layout'>(</span><span class='hs-varid'>dmd</span> <span class='hs-conop'>:</span> <span class='hs-varid'>dmds</span><span class='hs-layout'>)</span>
<a name="line-1472"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>bs</span>
<a name="line-1473"></a>
<a name="line-1474"></a><a name="findBndrDmd"></a><span class='hs-definition'>findBndrDmd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WithDmdType</span> <span class='hs-conid'>Demand</span>
<a name="line-1475"></a><span class='hs-comment'>-- See Note [Trimming a demand to a type]</span>
<a name="line-1476"></a><span class='hs-definition'>findBndrDmd</span> <span class='hs-varid'>env</span> <span class='hs-varid'>arg_of_dfun</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>id</span>
<a name="line-1477"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "findBndrDmd" (ppr id $$ ppr dmd_ty $$ ppr starting_dmd $$ ppr dmd') $</span>
<a name="line-1478"></a>    <span class='hs-conid'>WithDmdType</span> <span class='hs-varid'>dmd_ty'</span> <span class='hs-varid'>dmd'</span>
<a name="line-1479"></a>  <span class='hs-keyword'>where</span>
<a name="line-1480"></a>    <span class='hs-varid'>dmd'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>strictify</span> <span class='hs-varop'>$</span>
<a name="line-1481"></a>           <span class='hs-varid'>trimToType</span> <span class='hs-varid'>starting_dmd</span> <span class='hs-layout'>(</span><span class='hs-varid'>findTypeShape</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>id_ty</span><span class='hs-layout'>)</span>
<a name="line-1482"></a>
<a name="line-1483"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>dmd_ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>starting_dmd</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>peelFV</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-varid'>id</span>
<a name="line-1484"></a>
<a name="line-1485"></a>    <span class='hs-varid'>id_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>id</span>
<a name="line-1486"></a>
<a name="line-1487"></a>    <span class='hs-varid'>strictify</span> <span class='hs-varid'>dmd</span>
<a name="line-1488"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ae_strict_dicts</span> <span class='hs-varid'>env</span>
<a name="line-1489"></a>             <span class='hs-comment'>-- We never want to strictify a recursive let. At the moment</span>
<a name="line-1490"></a>             <span class='hs-comment'>-- annotateBndr is only call for non-recursive lets; if that</span>
<a name="line-1491"></a>             <span class='hs-comment'>-- changes, we need a RecFlag parameter and another guard here.</span>
<a name="line-1492"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-varid'>arg_of_dfun</span> <span class='hs-comment'>-- See Note [Do not strictify the argument dictionaries of a dfun]</span>
<a name="line-1493"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>strictifyDictDmd</span> <span class='hs-varid'>id_ty</span> <span class='hs-varid'>dmd</span>
<a name="line-1494"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1495"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd</span>
<a name="line-1496"></a>
<a name="line-1497"></a>    <span class='hs-varid'>fam_envs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ae_fam_envs</span> <span class='hs-varid'>env</span>
<a name="line-1498"></a>
<a name="line-1499"></a><span class='hs-comment'>{- Note [Initialising strictness]
<a name="line-1500"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1501"></a>See section 9.2 (Finding fixpoints) of the paper.
<a name="line-1502"></a>
<a name="line-1503"></a>Our basic plan is to initialise the strictness of each Id in a
<a name="line-1504"></a>recursive group to "bottom", and find a fixpoint from there.  However,
<a name="line-1505"></a>this group B might be inside an *enclosing* recursive group A, in
<a name="line-1506"></a>which case we'll do the entire fixpoint shebang on for each iteration
<a name="line-1507"></a>of A. This can be illustrated by the following example:
<a name="line-1508"></a>
<a name="line-1509"></a>Example:
<a name="line-1510"></a>
<a name="line-1511"></a>  f [] = []
<a name="line-1512"></a>  f (x:xs) = let g []     = f xs
<a name="line-1513"></a>                 g (y:ys) = y+1 : g ys
<a name="line-1514"></a>              in g (h x)
<a name="line-1515"></a>
<a name="line-1516"></a>At each iteration of the fixpoint for f, the analyser has to find a
<a name="line-1517"></a>fixpoint for the enclosed function g. In the meantime, the demand
<a name="line-1518"></a>values for g at each iteration for f are *greater* than those we
<a name="line-1519"></a>encountered in the previous iteration for f. Therefore, we can begin
<a name="line-1520"></a>the fixpoint for g not with the bottom value but rather with the
<a name="line-1521"></a>result of the previous analysis. I.e., when beginning the fixpoint
<a name="line-1522"></a>process for g, we can start from the demand signature computed for g
<a name="line-1523"></a>previously and attached to the binding occurrence of g.
<a name="line-1524"></a>
<a name="line-1525"></a>To speed things up, we initialise each iteration of A (the enclosing
<a name="line-1526"></a>one) from the result of the last one, which is neatly recorded in each
<a name="line-1527"></a>binder.  That way we make use of earlier iterations of the fixpoint
<a name="line-1528"></a>algorithm. (Cunning plan.)
<a name="line-1529"></a>
<a name="line-1530"></a>But on the *first* iteration we want to *ignore* the current strictness
<a name="line-1531"></a>of the Id, and start from "bottom".  Nowadays the Id can have a current
<a name="line-1532"></a>strictness, because interface files record strictness for nested bindings.
<a name="line-1533"></a>To know when we are in the first iteration, we look at the ae_virgin
<a name="line-1534"></a>field of the AnalEnv.
<a name="line-1535"></a>
<a name="line-1536"></a>
<a name="line-1537"></a>Note [Final Demand Analyser run]
<a name="line-1538"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1539"></a>Some of the information that the demand analyser determines is not always
<a name="line-1540"></a>preserved by the simplifier.  For example, the simplifier will happily rewrite
<a name="line-1541"></a>  \y [Demand=MU] let x = y in x + x
<a name="line-1542"></a>to
<a name="line-1543"></a>  \y [Demand=MU] y + y
<a name="line-1544"></a>which is quite a lie: Now y occurs more than just once.
<a name="line-1545"></a>
<a name="line-1546"></a>The once-used information is (currently) only used by the code
<a name="line-1547"></a>generator, though.  So:
<a name="line-1548"></a>
<a name="line-1549"></a> * We zap the used-once info in the worker-wrapper;
<a name="line-1550"></a>   see Note [Zapping Used Once info in WorkWrap] in
<a name="line-1551"></a>   GHC.Core.Opt.WorkWrap.
<a name="line-1552"></a>   If it's not reliable, it's better not to have it at all.
<a name="line-1553"></a>
<a name="line-1554"></a> * Just before TidyCore, we add a pass of the demand analyser,
<a name="line-1555"></a>      but WITHOUT subsequent worker/wrapper and simplifier,
<a name="line-1556"></a>   right before TidyCore.  See SimplCore.getCoreToDo.
<a name="line-1557"></a>
<a name="line-1558"></a>   This way, correct information finds its way into the module interface
<a name="line-1559"></a>   (strictness signatures!) and the code generator (single-entry thunks!)
<a name="line-1560"></a>
<a name="line-1561"></a>Note that, in contrast, the single-call information (CM(..)) /can/ be
<a name="line-1562"></a>relied upon, as the simplifier tends to be very careful about not
<a name="line-1563"></a>duplicating actual function calls.
<a name="line-1564"></a>
<a name="line-1565"></a>Also see #11731.
<a name="line-1566"></a>
<a name="line-1567"></a>Note [Space Leaks in Demand Analysis]
<a name="line-1568"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1569"></a>Ticket: #15455
<a name="line-1570"></a>MR: !5399
<a name="line-1571"></a>
<a name="line-1572"></a>In the past the result of demand analysis was not forced until the whole module
<a name="line-1573"></a>had finished being analysed. In big programs, this led to a big build up of thunks
<a name="line-1574"></a>which were all ultimately forced at the end of the analysis.
<a name="line-1575"></a>
<a name="line-1576"></a>This was because the return type of the analysis was a lazy pair:
<a name="line-1577"></a>  dmdAnal :: AnalEnv -&gt; SubDemand -&gt; CoreExpr -&gt; (DmdType, CoreExpr)
<a name="line-1578"></a>To avoid space leaks we added extra bangs to evaluate the DmdType component eagerly; but
<a name="line-1579"></a>we were never sure we had added enough.
<a name="line-1580"></a>The easiest way to systematically fix this was to use a strict pair type for the
<a name="line-1581"></a>return value of the analysis so that we can be more confident that the result
<a name="line-1582"></a>is incrementally computed rather than all at the end.
<a name="line-1583"></a>
<a name="line-1584"></a>A second, only loosely related point is that
<a name="line-1585"></a>the updating of Ids was not forced because the result of updating
<a name="line-1586"></a>an Id was placed into a lazy field in CoreExpr. This meant that until the end of
<a name="line-1587"></a>demand analysis, the unforced Ids would retain the DmdEnv which the demand information
<a name="line-1588"></a>was fetch from. Now we are quite careful to force Ids before putting them
<a name="line-1589"></a>back into core expressions so that we can garbage-collect the environments more eagerly.
<a name="line-1590"></a>For example see the `Case` branch of `dmdAnal'` where `case_bndr'` is forced
<a name="line-1591"></a>or `dmdAnalSumAlt`.
<a name="line-1592"></a>
<a name="line-1593"></a>The net result of all these improvements is the peak live memory usage of compiling
<a name="line-1594"></a>jsaddle-dom decreases about 4GB (from 6.5G to 2.5G). A bunch of bytes allocated benchmarks also
<a name="line-1595"></a>decrease because we allocate a lot fewer thunks which we immediately overwrite and
<a name="line-1596"></a>also runtime for the pass is faster! Overall, good wins.
<a name="line-1597"></a>
<a name="line-1598"></a>-}</span>
</pre></body>
</html>

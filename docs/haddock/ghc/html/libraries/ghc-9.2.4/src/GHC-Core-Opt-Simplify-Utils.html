<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core/Opt/Simplify/Utils.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The AQUA Project, Glasgow University, 1993-1998
<a name="line-3"></a>
<a name="line-4"></a>The simplifier utilities
<a name="line-5"></a>-}</span>
<a name="line-6"></a>
<a name="line-7"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-8"></a>
<a name="line-9"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.Opt.Simplify.Utils</span> <span class='hs-layout'>(</span>
<a name="line-10"></a>        <span class='hs-comment'>-- Rebuilding</span>
<a name="line-11"></a>        <span class='hs-varid'>mkLam</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCase</span><span class='hs-layout'>,</span> <span class='hs-varid'>prepareAlts</span><span class='hs-layout'>,</span> <span class='hs-varid'>tryEtaExpandRhs</span><span class='hs-layout'>,</span>
<a name="line-12"></a>
<a name="line-13"></a>        <span class='hs-comment'>-- Inlining,</span>
<a name="line-14"></a>        <span class='hs-varid'>preInlineUnconditionally</span><span class='hs-layout'>,</span> <span class='hs-varid'>postInlineUnconditionally</span><span class='hs-layout'>,</span>
<a name="line-15"></a>        <span class='hs-varid'>activeUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>activeRule</span><span class='hs-layout'>,</span>
<a name="line-16"></a>        <span class='hs-varid'>getUnfoldingInRuleMatch</span><span class='hs-layout'>,</span>
<a name="line-17"></a>        <span class='hs-varid'>simplEnvForGHCi</span><span class='hs-layout'>,</span> <span class='hs-varid'>updModeForStableUnfoldings</span><span class='hs-layout'>,</span> <span class='hs-varid'>updModeForRules</span><span class='hs-layout'>,</span>
<a name="line-18"></a>
<a name="line-19"></a>        <span class='hs-comment'>-- The continuation type</span>
<a name="line-20"></a>        <span class='hs-conid'>SimplCont</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>DupFlag</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>StaticEnv</span><span class='hs-layout'>,</span>
<a name="line-21"></a>        <span class='hs-varid'>isSimplified</span><span class='hs-layout'>,</span> <span class='hs-varid'>contIsStop</span><span class='hs-layout'>,</span>
<a name="line-22"></a>        <span class='hs-varid'>contIsDupable</span><span class='hs-layout'>,</span> <span class='hs-varid'>contResultType</span><span class='hs-layout'>,</span> <span class='hs-varid'>contHoleType</span><span class='hs-layout'>,</span> <span class='hs-varid'>contHoleScaling</span><span class='hs-layout'>,</span>
<a name="line-23"></a>        <span class='hs-varid'>contIsTrivial</span><span class='hs-layout'>,</span> <span class='hs-varid'>contArgs</span><span class='hs-layout'>,</span>
<a name="line-24"></a>        <span class='hs-varid'>countArgs</span><span class='hs-layout'>,</span>
<a name="line-25"></a>        <span class='hs-varid'>mkBoringStop</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkRhsStop</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLazyArgStop</span><span class='hs-layout'>,</span> <span class='hs-varid'>contIsRhsOrArg</span><span class='hs-layout'>,</span>
<a name="line-26"></a>        <span class='hs-varid'>interestingCallContext</span><span class='hs-layout'>,</span>
<a name="line-27"></a>
<a name="line-28"></a>        <span class='hs-comment'>-- ArgInfo</span>
<a name="line-29"></a>        <span class='hs-conid'>ArgInfo</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>ArgSpec</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkArgInfo</span><span class='hs-layout'>,</span>
<a name="line-30"></a>        <span class='hs-varid'>addValArgTo</span><span class='hs-layout'>,</span> <span class='hs-varid'>addCastTo</span><span class='hs-layout'>,</span> <span class='hs-varid'>addTyArgTo</span><span class='hs-layout'>,</span>
<a name="line-31"></a>        <span class='hs-varid'>argInfoExpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>argInfoAppArgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>pushSimplifiedArgs</span><span class='hs-layout'>,</span>
<a name="line-32"></a>        <span class='hs-varid'>isStrictArgInfo</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazyArgContext</span><span class='hs-layout'>,</span>
<a name="line-33"></a>
<a name="line-34"></a>        <span class='hs-varid'>abstractFloats</span><span class='hs-layout'>,</span>
<a name="line-35"></a>
<a name="line-36"></a>        <span class='hs-comment'>-- Utilities</span>
<a name="line-37"></a>        <span class='hs-varid'>isExitJoinId</span>
<a name="line-38"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-39"></a>
<a name="line-40"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-41"></a>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-43"></a>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.Simplify.Env</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.Monad</span>        <span class='hs-layout'>(</span> <span class='hs-conid'>SimplMode</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Tick</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Session</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Ppr</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>GHC.Core.Subst</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Ppr</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCo.Ppr</span> <span class='hs-layout'>(</span> <span class='hs-varid'>pprParendType</span> <span class='hs-layout'>)</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FVs</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Utils</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.Arity</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Unfold</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Unfold.Make</span>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span>
<a name="line-58"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span>
<a name="line-59"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id.Info</span>
<a name="line-60"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Tickish</span>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span>
<a name="line-62"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Demand</span>
<a name="line-63"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Set</span>
<a name="line-64"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-65"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.Simplify.Monad</span>
<a name="line-66"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>     <span class='hs-varid'>hiding</span><span class='hs-layout'>(</span> <span class='hs-varid'>substTy</span> <span class='hs-layout'>)</span>
<a name="line-67"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion</span> <span class='hs-varid'>hiding</span><span class='hs-layout'>(</span> <span class='hs-varid'>substCo</span> <span class='hs-layout'>)</span>
<a name="line-68"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.DataCon</span> <span class='hs-layout'>(</span> <span class='hs-varid'>dataConWorkId</span><span class='hs-layout'>,</span> <span class='hs-varid'>isNullaryRepDataCon</span> <span class='hs-layout'>)</span>
<a name="line-69"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Multiplicity</span>
<a name="line-70"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-71"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.OrdList</span> <span class='hs-layout'>(</span> <span class='hs-varid'>isNilOL</span> <span class='hs-layout'>)</span>
<a name="line-72"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Monad</span>
<a name="line-73"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-74"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Logger</span>
<a name="line-75"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-76"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.ConstantFold</span>
<a name="line-77"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.FastString</span> <span class='hs-layout'>(</span> <span class='hs-varid'>fsLit</span> <span class='hs-layout'>)</span>
<a name="line-78"></a>
<a name="line-79"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Monad</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>when</span> <span class='hs-layout'>)</span>
<a name="line-80"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List</span>        <span class='hs-layout'>(</span> <span class='hs-varid'>sortBy</span> <span class='hs-layout'>)</span>
<a name="line-81"></a>
<a name="line-82"></a><span class='hs-comment'>{-
<a name="line-83"></a>************************************************************************
<a name="line-84"></a>*                                                                      *
<a name="line-85"></a>                The SimplCont and DupFlag types
<a name="line-86"></a>*                                                                      *
<a name="line-87"></a>************************************************************************
<a name="line-88"></a>
<a name="line-89"></a>A SimplCont allows the simplifier to traverse the expression in a
<a name="line-90"></a>zipper-like fashion.  The SimplCont represents the rest of the expression,
<a name="line-91"></a>"above" the point of interest.
<a name="line-92"></a>
<a name="line-93"></a>You can also think of a SimplCont as an "evaluation context", using
<a name="line-94"></a>that term in the way it is used for operational semantics. This is the
<a name="line-95"></a>way I usually think of it, For example you'll often see a syntax for
<a name="line-96"></a>evaluation context looking like
<a name="line-97"></a>        C ::= []  |  C e   |  case C of alts  |  C `cast` co
<a name="line-98"></a>That's the kind of thing we are doing here, and I use that syntax in
<a name="line-99"></a>the comments.
<a name="line-100"></a>
<a name="line-101"></a>
<a name="line-102"></a>Key points:
<a name="line-103"></a>  * A SimplCont describes a *strict* context (just like
<a name="line-104"></a>    evaluation contexts do).  E.g. Just [] is not a SimplCont
<a name="line-105"></a>
<a name="line-106"></a>  * A SimplCont describes a context that *does not* bind
<a name="line-107"></a>    any variables.  E.g. \x. [] is not a SimplCont
<a name="line-108"></a>-}</span>
<a name="line-109"></a>
<a name="line-110"></a><a name="SimplCont"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>SimplCont</span>
<a name="line-111"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span>                <span class='hs-comment'>-- Stop[e] = e</span>
<a name="line-112"></a>        <span class='hs-conid'>OutType</span>         <span class='hs-comment'>-- Type of the &lt;hole&gt;</span>
<a name="line-113"></a>        <span class='hs-conid'>CallCtxt</span>        <span class='hs-comment'>-- Tells if there is something interesting about</span>
<a name="line-114"></a>                        <span class='hs-comment'>--          the context, and hence the inliner</span>
<a name="line-115"></a>                        <span class='hs-comment'>--          should be a bit keener (see interestingCallContext)</span>
<a name="line-116"></a>                        <span class='hs-comment'>-- Specifically:</span>
<a name="line-117"></a>                        <span class='hs-comment'>--     This is an argument of a function that has RULES</span>
<a name="line-118"></a>                        <span class='hs-comment'>--     Inlining the call might allow the rule to fire</span>
<a name="line-119"></a>                        <span class='hs-comment'>-- Never ValAppCxt (use ApplyToVal instead)</span>
<a name="line-120"></a>                        <span class='hs-comment'>-- or CaseCtxt (use Select instead)</span>
<a name="line-121"></a>
<a name="line-122"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CastIt</span>              <span class='hs-comment'>-- (CastIt co K)[e] = K[ e `cast` co ]</span>
<a name="line-123"></a>        <span class='hs-conid'>OutCoercion</span>             <span class='hs-comment'>-- The coercion simplified</span>
<a name="line-124"></a>                                <span class='hs-comment'>-- Invariant: never an identity coercion</span>
<a name="line-125"></a>        <span class='hs-conid'>SimplCont</span>
<a name="line-126"></a>
<a name="line-127"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ApplyToVal</span>         <span class='hs-comment'>-- (ApplyToVal arg K)[e] = K[ e arg ]</span>
<a name="line-128"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DupFlag</span>   <span class='hs-comment'>-- See Note [DupFlag invariants]</span>
<a name="line-129"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span>   <span class='hs-comment'>-- Type of the function, presumably (forall a. blah)</span>
<a name="line-130"></a>                                <span class='hs-comment'>-- See Note [The hole type in ApplyToTy/Val]</span>
<a name="line-131"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_arg</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InExpr</span>       <span class='hs-comment'>-- The argument,</span>
<a name="line-132"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>StaticEnv</span>    <span class='hs-comment'>-- see Note [StaticEnv invariant]</span>
<a name="line-133"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-layout'>}</span>
<a name="line-134"></a>
<a name="line-135"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ApplyToTy</span>          <span class='hs-comment'>-- (ApplyToTy ty K)[e] = K[ e ty ]</span>
<a name="line-136"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg_ty</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span>     <span class='hs-comment'>-- Argument type</span>
<a name="line-137"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span>     <span class='hs-comment'>-- Type of the function, presumably (forall a. blah)</span>
<a name="line-138"></a>                                  <span class='hs-comment'>-- See Note [The hole type in ApplyToTy/Val]</span>
<a name="line-139"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-layout'>}</span>
<a name="line-140"></a>
<a name="line-141"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Select</span>             <span class='hs-comment'>-- (Select alts K)[e] = K[ case e of alts ]</span>
<a name="line-142"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DupFlag</span>        <span class='hs-comment'>-- See Note [DupFlag invariants]</span>
<a name="line-143"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InId</span>           <span class='hs-comment'>-- case binder</span>
<a name="line-144"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_alts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InAlt</span><span class='hs-keyglyph'>]</span>        <span class='hs-comment'>-- Alternatives</span>
<a name="line-145"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>StaticEnv</span>      <span class='hs-comment'>-- See Note [StaticEnv invariant]</span>
<a name="line-146"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-layout'>}</span>
<a name="line-147"></a>
<a name="line-148"></a>  <span class='hs-comment'>-- The two strict forms have no DupFlag, because we never duplicate them</span>
<a name="line-149"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>StrictBind</span>          <span class='hs-comment'>-- (StrictBind x xs b K)[e] = let x = e in K[\xs.b]</span>
<a name="line-150"></a>                        <span class='hs-comment'>--       or, equivalently,  = K[ (\x xs.b) e ]</span>
<a name="line-151"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DupFlag</span>        <span class='hs-comment'>-- See Note [DupFlag invariants]</span>
<a name="line-152"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndr</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InId</span>
<a name="line-153"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InBndr</span><span class='hs-keyglyph'>]</span>
<a name="line-154"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_body</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InExpr</span>
<a name="line-155"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>StaticEnv</span>      <span class='hs-comment'>-- See Note [StaticEnv invariant]</span>
<a name="line-156"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-layout'>}</span>
<a name="line-157"></a>
<a name="line-158"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>StrictArg</span>           <span class='hs-comment'>-- (StrictArg (f e1 ..en) K)[e] = K[ f e1 .. en e ]</span>
<a name="line-159"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DupFlag</span>     <span class='hs-comment'>-- Always Simplified or OkToDup</span>
<a name="line-160"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_fun</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArgInfo</span>     <span class='hs-comment'>-- Specifies f, e1..en, Whether f has rules, etc</span>
<a name="line-161"></a>                               <span class='hs-comment'>--     plus demands and discount flags for *this* arg</span>
<a name="line-162"></a>                               <span class='hs-comment'>--          and further args</span>
<a name="line-163"></a>                               <span class='hs-comment'>--     So ai_dmds and ai_discs are never empty</span>
<a name="line-164"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_fun_ty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span>   <span class='hs-comment'>-- Type of the function (f e1 .. en),</span>
<a name="line-165"></a>                               <span class='hs-comment'>-- presumably (arg_ty -&gt; res_ty)</span>
<a name="line-166"></a>                               <span class='hs-comment'>-- where res_ty is expected by sc_cont</span>
<a name="line-167"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-layout'>}</span>
<a name="line-168"></a>
<a name="line-169"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TickIt</span>              <span class='hs-comment'>-- (TickIt t K)[e] = K[ tick t e ]</span>
<a name="line-170"></a>        <span class='hs-conid'>CoreTickish</span>     <span class='hs-comment'>-- Tick tickish &lt;hole&gt;</span>
<a name="line-171"></a>        <span class='hs-conid'>SimplCont</span>
<a name="line-172"></a>
<a name="line-173"></a><a name="StaticEnv"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>StaticEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SimplEnv</span>       <span class='hs-comment'>-- Just the static part is relevant</span>
<a name="line-174"></a>
<a name="line-175"></a><a name="DupFlag"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>DupFlag</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoDup</span>       <span class='hs-comment'>-- Unsimplified, might be big</span>
<a name="line-176"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Simplified</span>  <span class='hs-comment'>-- Simplified</span>
<a name="line-177"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OkToDup</span>     <span class='hs-comment'>-- Simplified and small</span>
<a name="line-178"></a>
<a name="line-179"></a><a name="isSimplified"></a><span class='hs-definition'>isSimplified</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DupFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-180"></a><span class='hs-definition'>isSimplified</span> <span class='hs-conid'>NoDup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-181"></a><span class='hs-definition'>isSimplified</span> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>       <span class='hs-comment'>-- Invariant: the subst-env is empty</span>
<a name="line-182"></a>
<a name="line-183"></a><a name="perhapsSubstTy"></a><span class='hs-definition'>perhapsSubstTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DupFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StaticEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-184"></a><span class='hs-definition'>perhapsSubstTy</span> <span class='hs-varid'>dup</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-185"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSimplified</span> <span class='hs-varid'>dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>
<a name="line-186"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-187"></a>
<a name="line-188"></a><span class='hs-comment'>{- Note [StaticEnv invariant]
<a name="line-189"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-190"></a>We pair up an InExpr or InAlts with a StaticEnv, which establishes the
<a name="line-191"></a>lexical scope for that InExpr.  When we simplify that InExpr/InAlts, we
<a name="line-192"></a>use
<a name="line-193"></a>  - Its captured StaticEnv
<a name="line-194"></a>  - Overriding its InScopeSet with the larger one at the
<a name="line-195"></a>    simplification point.
<a name="line-196"></a>
<a name="line-197"></a>Why override the InScopeSet?  Example:
<a name="line-198"></a>      (let y = ey in f) ex
<a name="line-199"></a>By the time we simplify ex, 'y' will be in scope.
<a name="line-200"></a>
<a name="line-201"></a>However the InScopeSet in the StaticEnv is not irrelevant: it should
<a name="line-202"></a>include all the free vars of applying the substitution to the InExpr.
<a name="line-203"></a>Reason: contHoleType uses perhapsSubstTy to apply the substitution to
<a name="line-204"></a>the expression, and that (rightly) gives ASSERT failures if the InScopeSet
<a name="line-205"></a>isn't big enough.
<a name="line-206"></a>
<a name="line-207"></a>Note [DupFlag invariants]
<a name="line-208"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-209"></a>In both (ApplyToVal dup _ env k)
<a name="line-210"></a>   and  (Select dup _ _ env k)
<a name="line-211"></a>the following invariants hold
<a name="line-212"></a>
<a name="line-213"></a>  (a) if dup = OkToDup, then continuation k is also ok-to-dup
<a name="line-214"></a>  (b) if dup = OkToDup or Simplified, the subst-env is empty
<a name="line-215"></a>      (and hence no need to re-simplify)
<a name="line-216"></a>-}</span>
<a name="line-217"></a>
<a name="line-218"></a><a name="instance%20Outputable%20DupFlag"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>DupFlag</span> <span class='hs-keyword'>where</span>
<a name="line-219"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>OkToDup</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ok"</span>
<a name="line-220"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>NoDup</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"nodup"</span>
<a name="line-221"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>Simplified</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"simpl"</span>
<a name="line-222"></a>
<a name="line-223"></a><a name="instance%20Outputable%20SimplCont"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyword'>where</span>
<a name="line-224"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>interesting</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Stop"</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>brackets</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>interesting</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span>
<a name="line-225"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-varid'>co</span> <span class='hs-varid'>cont</span>  <span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"CastIt"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprOptCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-226"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-varid'>t</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"TickIt"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-227"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-228"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"ApplyToTy"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprParendType</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-229"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dup</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-230"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"ApplyToVal"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dup</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"hole"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>hole_ty</span><span class='hs-layout'>)</span>
<a name="line-231"></a>          <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprParendExpr</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-232"></a>      <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-233"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-234"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"StrictBind"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-235"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ai</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-236"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"StrictArg"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>ai_fun</span> <span class='hs-varid'>ai</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-237"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dup</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alts</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-238"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Select"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dup</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span>
<a name="line-239"></a>       <span class='hs-varid'>whenPprDebug</span> <span class='hs-layout'>(</span><span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>seTvSubst</span> <span class='hs-varid'>se</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>alts</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-240"></a>
<a name="line-241"></a>
<a name="line-242"></a><span class='hs-comment'>{- Note [The hole type in ApplyToTy]
<a name="line-243"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-244"></a>The sc_hole_ty field of ApplyToTy records the type of the "hole" in the
<a name="line-245"></a>continuation.  It is absolutely necessary to compute contHoleType, but it is
<a name="line-246"></a>not used for anything else (and hence may not be evaluated).
<a name="line-247"></a>
<a name="line-248"></a>Why is it necessary for contHoleType?  Consider the continuation
<a name="line-249"></a>     ApplyToType Int (Stop Int)
<a name="line-250"></a>corresponding to
<a name="line-251"></a>     (&lt;hole&gt; @Int) :: Int
<a name="line-252"></a>What is the type of &lt;hole&gt;?  It could be (forall a. Int) or (forall a. a),
<a name="line-253"></a>and there is no way to know which, so we must record it.
<a name="line-254"></a>
<a name="line-255"></a>In a chain of applications  (f @t1 @t2 @t3) we'll lazily compute exprType
<a name="line-256"></a>for (f @t1) and (f @t1 @t2), which is potentially non-linear; but it probably
<a name="line-257"></a>doesn't matter because we'll never compute them all.
<a name="line-258"></a>
<a name="line-259"></a>************************************************************************
<a name="line-260"></a>*                                                                      *
<a name="line-261"></a>                ArgInfo and ArgSpec
<a name="line-262"></a>*                                                                      *
<a name="line-263"></a>************************************************************************
<a name="line-264"></a>-}</span>
<a name="line-265"></a>
<a name="line-266"></a><a name="ArgInfo"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ArgInfo</span>
<a name="line-267"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span>
<a name="line-268"></a>        <span class='hs-varid'>ai_fun</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutId</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- The function</span>
<a name="line-269"></a>        <span class='hs-varid'>ai_args</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSpec</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>  <span class='hs-comment'>-- ...applied to these args (which are in *reverse* order)</span>
<a name="line-270"></a>
<a name="line-271"></a>        <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FunRules</span><span class='hs-layout'>,</span>   <span class='hs-comment'>-- Rules for this function</span>
<a name="line-272"></a>
<a name="line-273"></a>        <span class='hs-varid'>ai_encl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Flag saying whether this function</span>
<a name="line-274"></a>                                <span class='hs-comment'>-- or an enclosing one has rules (recursively)</span>
<a name="line-275"></a>                                <span class='hs-comment'>--      True =&gt; be keener to inline in all args</span>
<a name="line-276"></a>
<a name="line-277"></a>        <span class='hs-varid'>ai_dmds</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- Demands on remaining value arguments (beyond ai_args)</span>
<a name="line-278"></a>                                <span class='hs-comment'>--   Usually infinite, but if it is finite it guarantees</span>
<a name="line-279"></a>                                <span class='hs-comment'>--   that the function diverges after being given</span>
<a name="line-280"></a>                                <span class='hs-comment'>--   that number of args</span>
<a name="line-281"></a>
<a name="line-282"></a>        <span class='hs-varid'>ai_discs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Discounts for remaining value arguments (beyong ai_args)</span>
<a name="line-283"></a>                                <span class='hs-comment'>--   non-zero =&gt; be keener to inline</span>
<a name="line-284"></a>                                <span class='hs-comment'>--   Always infinite</span>
<a name="line-285"></a>    <span class='hs-layout'>}</span>
<a name="line-286"></a>
<a name="line-287"></a><a name="ArgSpec"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ArgSpec</span>
<a name="line-288"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_dmd</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Demand</span>        <span class='hs-comment'>-- Demand placed on this argument</span>
<a name="line-289"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>as_arg</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutExpr</span>       <span class='hs-comment'>-- Apply to this (coercion or value); c.f. ApplyToVal</span>
<a name="line-290"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>as_hole_ty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span> <span class='hs-layout'>}</span>  <span class='hs-comment'>-- Type of the function (presumably t1 -&gt; t2)</span>
<a name="line-291"></a>
<a name="line-292"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span>     <span class='hs-comment'>-- Apply to this type; c.f. ApplyToTy</span>
<a name="line-293"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>as_hole_ty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span> <span class='hs-layout'>}</span>   <span class='hs-comment'>-- Type of the function (presumably forall a. blah)</span>
<a name="line-294"></a>
<a name="line-295"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CastBy</span> <span class='hs-conid'>OutCoercion</span>                <span class='hs-comment'>-- Cast by this; c.f. CastIt</span>
<a name="line-296"></a>
<a name="line-297"></a><a name="instance%20Outputable%20ArgInfo"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-keyword'>where</span>
<a name="line-298"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_dmds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmds</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-299"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ArgInfo"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>braces</span>
<a name="line-300"></a>         <span class='hs-layout'>(</span><span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"fun ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fun</span>
<a name="line-301"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"dmds ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dmds</span>
<a name="line-302"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"args ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-303"></a>
<a name="line-304"></a><a name="instance%20Outputable%20ArgSpec"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>ArgSpec</span> <span class='hs-keyword'>where</span>
<a name="line-305"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ValArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ValArg"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg</span>
<a name="line-306"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"TyArg"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span>
<a name="line-307"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastBy</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"CastBy"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>c</span>
<a name="line-308"></a>
<a name="line-309"></a><a name="addValArgTo"></a><span class='hs-definition'>addValArgTo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgInfo</span>
<a name="line-310"></a><span class='hs-definition'>addValArgTo</span> <span class='hs-varid'>ai</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>hole_ty</span>
<a name="line-311"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_dmds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd</span><span class='hs-conop'>:</span><span class='hs-varid'>dmds</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_discs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>discs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rules</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ai</span>
<a name="line-312"></a>      <span class='hs-comment'>-- Pop the top demand and and discounts off</span>
<a name="line-313"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_spec</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>as_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>as_dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>}</span>
<a name="line-314"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ai</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_args</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_spec</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ai_args</span> <span class='hs-varid'>ai</span>
<a name="line-315"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ai_dmds</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmds</span>
<a name="line-316"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ai_discs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>discs</span>
<a name="line-317"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decRules</span> <span class='hs-varid'>rules</span> <span class='hs-layout'>}</span>
<a name="line-318"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-319"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"addValArgTo"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ai</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-320"></a>    <span class='hs-comment'>-- There should always be enough demands and discounts</span>
<a name="line-321"></a>
<a name="line-322"></a><a name="addTyArgTo"></a><span class='hs-definition'>addTyArgTo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgInfo</span>
<a name="line-323"></a><span class='hs-definition'>addTyArgTo</span> <span class='hs-varid'>ai</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varid'>hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ai</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_spec</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ai_args</span> <span class='hs-varid'>ai</span>
<a name="line-324"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decRules</span> <span class='hs-layout'>(</span><span class='hs-varid'>ai_rules</span> <span class='hs-varid'>ai</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-325"></a>  <span class='hs-keyword'>where</span>
<a name="line-326"></a>    <span class='hs-varid'>arg_spec</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>as_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span> <span class='hs-layout'>}</span>
<a name="line-327"></a>
<a name="line-328"></a><a name="addCastTo"></a><span class='hs-definition'>addCastTo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutCoercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgInfo</span>
<a name="line-329"></a><span class='hs-definition'>addCastTo</span> <span class='hs-varid'>ai</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ai</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CastBy</span> <span class='hs-varid'>co</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ai_args</span> <span class='hs-varid'>ai</span> <span class='hs-layout'>}</span>
<a name="line-330"></a>
<a name="line-331"></a><a name="isStrictArgInfo"></a><span class='hs-definition'>isStrictArgInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-332"></a><span class='hs-comment'>-- True if the function is strict in the next argument</span>
<a name="line-333"></a><span class='hs-definition'>isStrictArgInfo</span> <span class='hs-layout'>(</span><span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_dmds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmds</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-334"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>dmd</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dmds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isStrUsedDmd</span> <span class='hs-varid'>dmd</span>
<a name="line-335"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-336"></a>
<a name="line-337"></a><a name="argInfoAppArgs"></a><span class='hs-definition'>argInfoAppArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSpec</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutExpr</span><span class='hs-keyglyph'>]</span>
<a name="line-338"></a><span class='hs-definition'>argInfoAppArgs</span> <span class='hs-conid'>[]</span>                              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-339"></a><span class='hs-definition'>argInfoAppArgs</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastBy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>                <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>  <span class='hs-comment'>-- Stop at a cast</span>
<a name="line-340"></a><span class='hs-definition'>argInfoAppArgs</span> <span class='hs-layout'>(</span><span class='hs-conid'>ValArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>}</span>  <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span>     <span class='hs-conop'>:</span> <span class='hs-varid'>argInfoAppArgs</span> <span class='hs-keyword'>as</span>
<a name="line-341"></a><span class='hs-definition'>argInfoAppArgs</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span> <span class='hs-conop'>:</span> <span class='hs-varid'>argInfoAppArgs</span> <span class='hs-keyword'>as</span>
<a name="line-342"></a>
<a name="line-343"></a><a name="pushSimplifiedArgs"></a><span class='hs-definition'>pushSimplifiedArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSpec</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-344"></a><span class='hs-definition'>pushSimplifiedArgs</span> <span class='hs-sel'>_env</span> <span class='hs-conid'>[]</span>           <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span>
<a name="line-345"></a><span class='hs-definition'>pushSimplifiedArgs</span> <span class='hs-varid'>env</span>  <span class='hs-layout'>(</span><span class='hs-varid'>arg</span> <span class='hs-conop'>:</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-varid'>k</span>
<a name="line-346"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>arg</span> <span class='hs-keyword'>of</span>
<a name="line-347"></a>      <span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>as_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span> <span class='hs-layout'>}</span>
<a name="line-348"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rest</span> <span class='hs-layout'>}</span>
<a name="line-349"></a>      <span class='hs-conid'>ValArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>as_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span> <span class='hs-layout'>}</span>
<a name="line-350"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Simplified</span>
<a name="line-351"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rest</span> <span class='hs-layout'>}</span>
<a name="line-352"></a>      <span class='hs-conid'>CastBy</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CastIt</span> <span class='hs-varid'>c</span> <span class='hs-varid'>rest</span>
<a name="line-353"></a>  <span class='hs-keyword'>where</span>
<a name="line-354"></a>    <span class='hs-varid'>rest</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pushSimplifiedArgs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>args</span> <span class='hs-varid'>k</span>
<a name="line-355"></a>           <span class='hs-comment'>-- The env has an empty SubstEnv</span>
<a name="line-356"></a>
<a name="line-357"></a><a name="argInfoExpr"></a><span class='hs-definition'>argInfoExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSpec</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>
<a name="line-358"></a><span class='hs-comment'>-- NB: the [ArgSpec] is reversed so that the first arg</span>
<a name="line-359"></a><span class='hs-comment'>-- in the list is the last one in the application</span>
<a name="line-360"></a><span class='hs-definition'>argInfoExpr</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>rev_args</span>
<a name="line-361"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>rev_args</span>
<a name="line-362"></a>  <span class='hs-keyword'>where</span>
<a name="line-363"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span>                              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>fun</span>
<a name="line-364"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>ValArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>}</span>  <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-keyword'>as</span> <span class='hs-varop'>`App`</span> <span class='hs-varid'>arg</span>
<a name="line-365"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-keyword'>as</span> <span class='hs-varop'>`App`</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span>
<a name="line-366"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastBy</span> <span class='hs-varid'>co</span>                <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCast</span> <span class='hs-layout'>(</span><span class='hs-varid'>go</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span>
<a name="line-367"></a>
<a name="line-368"></a>
<a name="line-369"></a><a name="FunRules"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>FunRules</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Remaining rules for this function</span>
<a name="line-370"></a>     <span class='hs-comment'>-- Nothing =&gt; No rules</span>
<a name="line-371"></a>     <span class='hs-comment'>-- Just (n, rules) =&gt; some rules, requiring at least n more type/value args</span>
<a name="line-372"></a>
<a name="line-373"></a><a name="decRules"></a><span class='hs-definition'>decRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FunRules</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FunRules</span>
<a name="line-374"></a><span class='hs-definition'>decRules</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-layout'>,</span> <span class='hs-varid'>rules</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-varid'>rules</span><span class='hs-layout'>)</span>
<a name="line-375"></a><span class='hs-definition'>decRules</span> <span class='hs-conid'>Nothing</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-376"></a>
<a name="line-377"></a><a name="mkFunRules"></a><span class='hs-definition'>mkFunRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FunRules</span>
<a name="line-378"></a><span class='hs-definition'>mkFunRules</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-379"></a><span class='hs-definition'>mkFunRules</span> <span class='hs-varid'>rs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>n_required</span><span class='hs-layout'>,</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span>
<a name="line-380"></a>  <span class='hs-keyword'>where</span>
<a name="line-381"></a>    <span class='hs-varid'>n_required</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maximum</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>ruleArity</span> <span class='hs-varid'>rs</span><span class='hs-layout'>)</span>
<a name="line-382"></a>
<a name="line-383"></a><span class='hs-comment'>{-
<a name="line-384"></a>************************************************************************
<a name="line-385"></a>*                                                                      *
<a name="line-386"></a>                Functions on SimplCont
<a name="line-387"></a>*                                                                      *
<a name="line-388"></a>************************************************************************
<a name="line-389"></a>-}</span>
<a name="line-390"></a>
<a name="line-391"></a><a name="mkBoringStop"></a><span class='hs-definition'>mkBoringStop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-392"></a><span class='hs-definition'>mkBoringStop</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-varid'>ty</span> <span class='hs-conid'>BoringCtxt</span>
<a name="line-393"></a>
<a name="line-394"></a><a name="mkRhsStop"></a><span class='hs-definition'>mkRhsStop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>       <span class='hs-comment'>-- See Note [RHS of lets] in GHC.Core.Unfold</span>
<a name="line-395"></a><span class='hs-definition'>mkRhsStop</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-varid'>ty</span> <span class='hs-conid'>RhsCtxt</span>
<a name="line-396"></a>
<a name="line-397"></a><a name="mkLazyArgStop"></a><span class='hs-definition'>mkLazyArgStop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-398"></a><span class='hs-definition'>mkLazyArgStop</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>cci</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stop</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>cci</span>
<a name="line-399"></a>
<a name="line-400"></a><a name="contIsRhsOrArg"></a><span class='hs-comment'>-------------------</span>
<a name="line-401"></a><span class='hs-definition'>contIsRhsOrArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-402"></a><span class='hs-definition'>contIsRhsOrArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-403"></a><span class='hs-definition'>contIsRhsOrArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-404"></a><span class='hs-definition'>contIsRhsOrArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-405"></a><span class='hs-definition'>contIsRhsOrArg</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-406"></a>
<a name="line-407"></a><a name="contIsRhs"></a><span class='hs-definition'>contIsRhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-408"></a><span class='hs-definition'>contIsRhs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>RhsCtxt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-409"></a><span class='hs-definition'>contIsRhs</span> <span class='hs-keyword'>_</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-410"></a>
<a name="line-411"></a><a name="contIsStop"></a><span class='hs-comment'>-------------------</span>
<a name="line-412"></a><span class='hs-definition'>contIsStop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-413"></a><span class='hs-definition'>contIsStop</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-414"></a><span class='hs-definition'>contIsStop</span> <span class='hs-keyword'>_</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-415"></a>
<a name="line-416"></a><a name="contIsDupable"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-417"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>                         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-418"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contIsDupable</span> <span class='hs-varid'>k</span>
<a name="line-419"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OkToDup</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-comment'>-- See Note [DupFlag invariants]</span>
<a name="line-420"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OkToDup</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-comment'>-- ...ditto...</span>
<a name="line-421"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OkToDup</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-comment'>-- ...ditto...</span>
<a name="line-422"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contIsDupable</span> <span class='hs-varid'>k</span>
<a name="line-423"></a><span class='hs-definition'>contIsDupable</span> <span class='hs-keyword'>_</span>                                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-424"></a>
<a name="line-425"></a><a name="contIsTrivial"></a><span class='hs-comment'>-------------------</span>
<a name="line-426"></a><span class='hs-definition'>contIsTrivial</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-427"></a><span class='hs-definition'>contIsTrivial</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>                                         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-428"></a><span class='hs-definition'>contIsTrivial</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>                       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contIsTrivial</span> <span class='hs-varid'>k</span>
<a name="line-429"></a><span class='hs-definition'>contIsTrivial</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contIsTrivial</span> <span class='hs-varid'>k</span>
<a name="line-430"></a><span class='hs-definition'>contIsTrivial</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                                      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contIsTrivial</span> <span class='hs-varid'>k</span>
<a name="line-431"></a><span class='hs-definition'>contIsTrivial</span> <span class='hs-keyword'>_</span>                                                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-432"></a>
<a name="line-433"></a><a name="contResultType"></a><span class='hs-comment'>-------------------</span>
<a name="line-434"></a><span class='hs-definition'>contResultType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span>
<a name="line-435"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>
<a name="line-436"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-437"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-438"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-439"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-440"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-441"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-442"></a><span class='hs-definition'>contResultType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>k</span>
<a name="line-443"></a>
<a name="line-444"></a><a name="contHoleType"></a><span class='hs-definition'>contHoleType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span>
<a name="line-445"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>
<a name="line-446"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contHoleType</span> <span class='hs-varid'>k</span>
<a name="line-447"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-varid'>co</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionLKind</span> <span class='hs-varid'>co</span>
<a name="line-448"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dup</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-449"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>perhapsSubstTy</span> <span class='hs-varid'>dup</span> <span class='hs-varid'>se</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-450"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_fun_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>funArgTy</span> <span class='hs-varid'>ty</span>
<a name="line-451"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>  <span class='hs-comment'>-- See Note [The hole type in ApplyToTy]</span>
<a name="line-452"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>  <span class='hs-comment'>-- See Note [The hole type in ApplyToTy/Val]</span>
<a name="line-453"></a><span class='hs-definition'>contHoleType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-454"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>perhapsSubstTy</span> <span class='hs-varid'>d</span> <span class='hs-varid'>se</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-455"></a>
<a name="line-456"></a>
<a name="line-457"></a><a name="contHoleScaling"></a><span class='hs-comment'>-- Computes the multiplicity scaling factor at the hole. That is, in (case [] of</span>
<a name="line-458"></a><span class='hs-comment'>-- x ::(p) _ {  }) (respectively for arguments of functions), the scaling</span>
<a name="line-459"></a><span class='hs-comment'>-- factor is p. And in E[G[]], the scaling factor is the product of the scaling</span>
<a name="line-460"></a><span class='hs-comment'>-- factor of E and that of G.</span>
<a name="line-461"></a><span class='hs-comment'>--</span>
<a name="line-462"></a><span class='hs-comment'>-- The scaling factor at the hole of E[] is used to determine how a binder</span>
<a name="line-463"></a><span class='hs-comment'>-- should be scaled if it commutes with E. This appears, in particular, in the</span>
<a name="line-464"></a><span class='hs-comment'>-- case-of-case transformation.</span>
<a name="line-465"></a><span class='hs-definition'>contHoleScaling</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Mult</span>
<a name="line-466"></a><span class='hs-definition'>contHoleScaling</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>One</span>
<a name="line-467"></a><span class='hs-definition'>contHoleScaling</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contHoleScaling</span> <span class='hs-varid'>k</span>
<a name="line-468"></a><span class='hs-definition'>contHoleScaling</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-469"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idMult</span> <span class='hs-varid'>id</span> <span class='hs-varop'>`mkMultMul`</span> <span class='hs-varid'>contHoleScaling</span> <span class='hs-varid'>k</span>
<a name="line-470"></a><span class='hs-definition'>contHoleScaling</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-471"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idMult</span> <span class='hs-varid'>id</span> <span class='hs-varop'>`mkMultMul`</span> <span class='hs-varid'>contHoleScaling</span> <span class='hs-varid'>k</span>
<a name="line-472"></a><span class='hs-definition'>contHoleScaling</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_fun_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-473"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>w</span> <span class='hs-varop'>`mkMultMul`</span> <span class='hs-varid'>contHoleScaling</span> <span class='hs-varid'>k</span>
<a name="line-474"></a>  <span class='hs-keyword'>where</span>
<a name="line-475"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>w</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitFunTy</span> <span class='hs-varid'>fun_ty</span>
<a name="line-476"></a><span class='hs-definition'>contHoleScaling</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contHoleScaling</span> <span class='hs-varid'>k</span>
<a name="line-477"></a><span class='hs-definition'>contHoleScaling</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contHoleScaling</span> <span class='hs-varid'>k</span>
<a name="line-478"></a><span class='hs-definition'>contHoleScaling</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contHoleScaling</span> <span class='hs-varid'>k</span>
<a name="line-479"></a><a name="countArgs"></a><span class='hs-comment'>-------------------</span>
<a name="line-480"></a><span class='hs-definition'>countArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-481"></a><span class='hs-comment'>-- Count all arguments, including types, coercions, and other values</span>
<a name="line-482"></a><span class='hs-definition'>countArgs</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>countArgs</span> <span class='hs-varid'>cont</span>
<a name="line-483"></a><span class='hs-definition'>countArgs</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>countArgs</span> <span class='hs-varid'>cont</span>
<a name="line-484"></a><span class='hs-definition'>countArgs</span> <span class='hs-keyword'>_</span>                               <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-485"></a>
<a name="line-486"></a><a name="contArgs"></a><span class='hs-definition'>contArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSummary</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplCont</span><span class='hs-layout'>)</span>
<a name="line-487"></a><span class='hs-comment'>-- Summarises value args, discards type args and coercions</span>
<a name="line-488"></a><span class='hs-comment'>-- The returned continuation of the call is only used to</span>
<a name="line-489"></a><span class='hs-comment'>-- answer questions like "are you interesting?"</span>
<a name="line-490"></a><span class='hs-definition'>contArgs</span> <span class='hs-varid'>cont</span>
<a name="line-491"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>lone</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>
<a name="line-492"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>cont</span>
<a name="line-493"></a>  <span class='hs-keyword'>where</span>
<a name="line-494"></a>    <span class='hs-varid'>lone</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>  <span class='hs-comment'>-- See Note [Lone variables] in GHC.Core.Unfold</span>
<a name="line-495"></a>    <span class='hs-varid'>lone</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>  <span class='hs-comment'>-- NB: even a type application or cast</span>
<a name="line-496"></a>    <span class='hs-varid'>lone</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>  <span class='hs-comment'>--     stops it being "lone"</span>
<a name="line-497"></a>    <span class='hs-varid'>lone</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-498"></a>
<a name="line-499"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>args</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-500"></a>                                        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_interesting</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>se</span> <span class='hs-conop'>:</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-varid'>k</span>
<a name="line-501"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>args</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>args</span> <span class='hs-varid'>k</span>
<a name="line-502"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>args</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>args</span> <span class='hs-varid'>k</span>
<a name="line-503"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>args</span> <span class='hs-varid'>k</span>                           <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>
<a name="line-504"></a>
<a name="line-505"></a>    <span class='hs-varid'>is_interesting</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>se</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interestingArg</span> <span class='hs-varid'>se</span> <span class='hs-varid'>arg</span>
<a name="line-506"></a>                   <span class='hs-comment'>-- Do *not* use short-cutting substitution here</span>
<a name="line-507"></a>                   <span class='hs-comment'>-- because we want to get as much IdInfo as possible</span>
<a name="line-508"></a>
<a name="line-509"></a>
<a name="line-510"></a><a name="mkArgInfo"></a><span class='hs-comment'>-------------------</span>
<a name="line-511"></a><span class='hs-definition'>mkArgInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-512"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-513"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- Rules for function</span>
<a name="line-514"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>        <span class='hs-comment'>-- Number of value args</span>
<a name="line-515"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>  <span class='hs-comment'>-- Context of the call</span>
<a name="line-516"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgInfo</span>
<a name="line-517"></a>
<a name="line-518"></a><span class='hs-definition'>mkArgInfo</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>rules</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varid'>call_cont</span>
<a name="line-519"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>idArity</span> <span class='hs-varid'>fun</span>            <span class='hs-comment'>-- Note [Unsaturated functions]</span>
<a name="line-520"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-521"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_rules</span>
<a name="line-522"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-523"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_dmds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vanilla_dmds</span>
<a name="line-524"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_discs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vanilla_discounts</span> <span class='hs-layout'>}</span>
<a name="line-525"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-526"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_fun</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span>
<a name="line-527"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-528"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_rules</span>
<a name="line-529"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_encl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interestingArgContext</span> <span class='hs-varid'>rules</span> <span class='hs-varid'>call_cont</span>
<a name="line-530"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_dmds</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>add_type_strictness</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_dmds</span>
<a name="line-531"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ai_discs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_discounts</span> <span class='hs-layout'>}</span>
<a name="line-532"></a>  <span class='hs-keyword'>where</span>
<a name="line-533"></a>    <span class='hs-varid'>fun_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkFunRules</span> <span class='hs-varid'>rules</span>
<a name="line-534"></a>
<a name="line-535"></a>    <span class='hs-varid'>vanilla_discounts</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_discounts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>
<a name="line-536"></a>    <span class='hs-varid'>vanilla_discounts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>repeat</span> <span class='hs-num'>0</span>
<a name="line-537"></a>    <span class='hs-varid'>arg_discounts</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>fun</span> <span class='hs-keyword'>of</span>
<a name="line-538"></a>                        <span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span><span class='hs-varid'>uf_guidance</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnfIfGoodArgs</span> <span class='hs-layout'>{</span><span class='hs-varid'>ug_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>discounts</span><span class='hs-layout'>}</span><span class='hs-layout'>}</span>
<a name="line-539"></a>                              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>discounts</span> <span class='hs-varop'>++</span> <span class='hs-varid'>vanilla_discounts</span>
<a name="line-540"></a>                        <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>vanilla_discounts</span>
<a name="line-541"></a>
<a name="line-542"></a>    <span class='hs-varid'>vanilla_dmds</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_dmds</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span>
<a name="line-543"></a>    <span class='hs-varid'>vanilla_dmds</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>repeat</span> <span class='hs-varid'>topDmd</span>
<a name="line-544"></a>
<a name="line-545"></a>    <span class='hs-varid'>arg_dmds</span>
<a name="line-546"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_inline</span> <span class='hs-layout'>(</span><span class='hs-varid'>seMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-547"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vanilla_dmds</span> <span class='hs-comment'>-- See Note [Do not expose strictness if sm_inline=False]</span>
<a name="line-548"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-549"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- add_type_str fun_ty $</span>
<a name="line-550"></a>        <span class='hs-keyword'>case</span> <span class='hs-varid'>splitStrictSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-551"></a>          <span class='hs-layout'>(</span><span class='hs-varid'>demands</span><span class='hs-layout'>,</span> <span class='hs-varid'>result_info</span><span class='hs-layout'>)</span>
<a name="line-552"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>demands</span> <span class='hs-varop'>`lengthExceeds`</span> <span class='hs-varid'>n_val_args</span><span class='hs-layout'>)</span>
<a name="line-553"></a>                <span class='hs-keyglyph'>-&gt;</span>      <span class='hs-comment'>-- Enough args, use the strictness given.</span>
<a name="line-554"></a>                        <span class='hs-comment'>-- For bottoming functions we used to pretend that the arg</span>
<a name="line-555"></a>                        <span class='hs-comment'>-- is lazy, so that we don't treat the arg as an</span>
<a name="line-556"></a>                        <span class='hs-comment'>-- interesting context.  This avoids substituting</span>
<a name="line-557"></a>                        <span class='hs-comment'>-- top-level bindings for (say) strings into</span>
<a name="line-558"></a>                        <span class='hs-comment'>-- calls to error.  But now we are more careful about</span>
<a name="line-559"></a>                        <span class='hs-comment'>-- inlining lone variables, so its ok</span>
<a name="line-560"></a>                        <span class='hs-comment'>-- (see GHC.Core.Op.Simplify.Utils.analyseCont)</span>
<a name="line-561"></a>                   <span class='hs-keyword'>if</span> <span class='hs-varid'>isDeadEndDiv</span> <span class='hs-varid'>result_info</span> <span class='hs-keyword'>then</span>
<a name="line-562"></a>                        <span class='hs-varid'>demands</span>  <span class='hs-comment'>-- Finite =&gt; result is bottom</span>
<a name="line-563"></a>                   <span class='hs-keyword'>else</span>
<a name="line-564"></a>                        <span class='hs-varid'>demands</span> <span class='hs-varop'>++</span> <span class='hs-varid'>vanilla_dmds</span>
<a name="line-565"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-566"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"More demands than arity"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>idArity</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span>
<a name="line-567"></a>                                <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>demands</span> <span class='hs-layout'>)</span>
<a name="line-568"></a>                  <span class='hs-varid'>vanilla_dmds</span>      <span class='hs-comment'>-- Not enough args, or no strictness</span>
<a name="line-569"></a>
<a name="line-570"></a>    <span class='hs-varid'>add_type_strictness</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span>
<a name="line-571"></a>    <span class='hs-comment'>-- If the function arg types are strict, record that in the 'strictness bits'</span>
<a name="line-572"></a>    <span class='hs-comment'>-- No need to instantiate because unboxed types (which dominate the strict</span>
<a name="line-573"></a>    <span class='hs-comment'>--   types) can't instantiate type variables.</span>
<a name="line-574"></a>    <span class='hs-comment'>-- add_type_strictness is done repeatedly (for each call);</span>
<a name="line-575"></a>    <span class='hs-comment'>--   might be better once-for-all in the function</span>
<a name="line-576"></a>    <span class='hs-comment'>-- But beware primops/datacons with no strictness</span>
<a name="line-577"></a>
<a name="line-578"></a>    <span class='hs-varid'>add_type_strictness</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>dmds</span>
<a name="line-579"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>dmds</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-580"></a>
<a name="line-581"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitForAllTyCoVar_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-582"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>add_type_strictness</span> <span class='hs-varid'>fun_ty'</span> <span class='hs-varid'>dmds</span>     <span class='hs-comment'>-- Look through foralls</span>
<a name="line-583"></a>
<a name="line-584"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>fun_ty</span>        <span class='hs-comment'>-- Add strict-type info</span>
<a name="line-585"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>dmd</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rest_dmds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dmds</span>
<a name="line-586"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>dmd'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>isLiftedType_maybe</span> <span class='hs-varid'>arg_ty</span> <span class='hs-keyword'>of</span>
<a name="line-587"></a>                       <span class='hs-conid'>Just</span> <span class='hs-conid'>False</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>strictifyDmd</span> <span class='hs-varid'>dmd</span>
<a name="line-588"></a>                       <span class='hs-keyword'>_</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>dmd</span>
<a name="line-589"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>add_type_strictness</span> <span class='hs-varid'>fun_ty'</span> <span class='hs-varid'>rest_dmds</span>
<a name="line-590"></a>          <span class='hs-comment'>-- If the type is levity-polymorphic, we can't know whether it's</span>
<a name="line-591"></a>          <span class='hs-comment'>-- strict. isLiftedType_maybe will return Just False only when</span>
<a name="line-592"></a>          <span class='hs-comment'>-- we're sure the type is unlifted.</span>
<a name="line-593"></a>
<a name="line-594"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-595"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmds</span>
<a name="line-596"></a>
<a name="line-597"></a><span class='hs-comment'>{- Note [Unsaturated functions]
<a name="line-598"></a>  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-599"></a>Consider (test eyeball/inline4)
<a name="line-600"></a>        x = a:as
<a name="line-601"></a>        y = f x
<a name="line-602"></a>where f has arity 2.  Then we do not want to inline 'x', because
<a name="line-603"></a>it'll just be floated out again.  Even if f has lots of discounts
<a name="line-604"></a>on its first argument -- it must be saturated for these to kick in
<a name="line-605"></a>
<a name="line-606"></a>Note [Do not expose strictness if sm_inline=False]
<a name="line-607"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-608"></a>#15163 showed a case in which we had
<a name="line-609"></a>
<a name="line-610"></a>  {-# INLINE [1] zip #-}
<a name="line-611"></a>  zip = undefined
<a name="line-612"></a>
<a name="line-613"></a>  {-# RULES "foo" forall as bs. stream (zip as bs) = ..blah... #-}
<a name="line-614"></a>
<a name="line-615"></a>If we expose zip's bottoming nature when simplifying the LHS of the
<a name="line-616"></a>RULE we get
<a name="line-617"></a>  {-# RULES "foo" forall as bs.
<a name="line-618"></a>                   stream (case zip of {}) = ..blah... #-}
<a name="line-619"></a>discarding the arguments to zip.  Usually this is fine, but on the
<a name="line-620"></a>LHS of a rule it's not, because 'as' and 'bs' are now not bound on
<a name="line-621"></a>the LHS.
<a name="line-622"></a>
<a name="line-623"></a>This is a pretty pathological example, so I'm not losing sleep over
<a name="line-624"></a>it, but the simplest solution was to check sm_inline; if it is False,
<a name="line-625"></a>which it is on the LHS of a rule (see updModeForRules), then don't
<a name="line-626"></a>make use of the strictness info for the function.
<a name="line-627"></a>-}</span>
<a name="line-628"></a>
<a name="line-629"></a>
<a name="line-630"></a><span class='hs-comment'>{-
<a name="line-631"></a>************************************************************************
<a name="line-632"></a>*                                                                      *
<a name="line-633"></a>        Interesting arguments
<a name="line-634"></a>*                                                                      *
<a name="line-635"></a>************************************************************************
<a name="line-636"></a>
<a name="line-637"></a>Note [Interesting call context]
<a name="line-638"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-639"></a>We want to avoid inlining an expression where there can't possibly be
<a name="line-640"></a>any gain, such as in an argument position.  Hence, if the continuation
<a name="line-641"></a>is interesting (eg. a case scrutinee, application etc.) then we
<a name="line-642"></a>inline, otherwise we don't.
<a name="line-643"></a>
<a name="line-644"></a>Previously some_benefit used to return True only if the variable was
<a name="line-645"></a>applied to some value arguments.  This didn't work:
<a name="line-646"></a>
<a name="line-647"></a>        let x = _coerce_ (T Int) Int (I# 3) in
<a name="line-648"></a>        case _coerce_ Int (T Int) x of
<a name="line-649"></a>                I# y -&gt; ....
<a name="line-650"></a>
<a name="line-651"></a>we want to inline x, but can't see that it's a constructor in a case
<a name="line-652"></a>scrutinee position, and some_benefit is False.
<a name="line-653"></a>
<a name="line-654"></a>Another example:
<a name="line-655"></a>
<a name="line-656"></a>dMonadST = _/\_ t -&gt; :Monad (g1 _@_ t, g2 _@_ t, g3 _@_ t)
<a name="line-657"></a>
<a name="line-658"></a>....  case dMonadST _@_ x0 of (a,b,c) -&gt; ....
<a name="line-659"></a>
<a name="line-660"></a>we'd really like to inline dMonadST here, but we *don't* want to
<a name="line-661"></a>inline if the case expression is just
<a name="line-662"></a>
<a name="line-663"></a>        case x of y { DEFAULT -&gt; ... }
<a name="line-664"></a>
<a name="line-665"></a>since we can just eliminate this case instead (x is in WHNF).  Similar
<a name="line-666"></a>applies when x is bound to a lambda expression.  Hence
<a name="line-667"></a>contIsInteresting looks for case expressions with just a single
<a name="line-668"></a>default case.
<a name="line-669"></a>
<a name="line-670"></a>Note [No case of case is boring]
<a name="line-671"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-672"></a>If we see
<a name="line-673"></a>   case f x of &lt;alts&gt;
<a name="line-674"></a>
<a name="line-675"></a>we'd usually treat the context as interesting, to encourage 'f' to
<a name="line-676"></a>inline.  But if case-of-case is off, it's really not so interesting
<a name="line-677"></a>after all, because we are unlikely to be able to push the case
<a name="line-678"></a>expression into the branches of any case in f's unfolding.  So, to
<a name="line-679"></a>reduce unnecessary code expansion, we just make the context look boring.
<a name="line-680"></a>This made a small compile-time perf improvement in perf/compiler/T6048,
<a name="line-681"></a>and it looks plausible to me.
<a name="line-682"></a>-}</span>
<a name="line-683"></a>
<a name="line-684"></a><a name="lazyArgContext"></a><span class='hs-definition'>lazyArgContext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallCtxt</span>
<a name="line-685"></a><span class='hs-comment'>-- Use this for lazy arguments</span>
<a name="line-686"></a><span class='hs-definition'>lazyArgContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>encl_rules</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_discs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>discs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-687"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>encl_rules</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RuleArgCtxt</span>
<a name="line-688"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>disc</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>discs</span><span class='hs-layout'>,</span> <span class='hs-varid'>disc</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DiscArgCtxt</span>  <span class='hs-comment'>-- Be keener here</span>
<a name="line-689"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BoringCtxt</span>   <span class='hs-comment'>-- Nothing interesting</span>
<a name="line-690"></a>
<a name="line-691"></a><a name="strictArgContext"></a><span class='hs-definition'>strictArgContext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallCtxt</span>
<a name="line-692"></a><span class='hs-definition'>strictArgContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>encl_rules</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_discs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>discs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-693"></a><span class='hs-comment'>-- Use this for strict arguments</span>
<a name="line-694"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>encl_rules</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RuleArgCtxt</span>
<a name="line-695"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>disc</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>discs</span><span class='hs-layout'>,</span> <span class='hs-varid'>disc</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DiscArgCtxt</span>  <span class='hs-comment'>-- Be keener here</span>
<a name="line-696"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RhsCtxt</span>
<a name="line-697"></a>      <span class='hs-comment'>-- Why RhsCtxt?  if we see f (g x) (h x), and f is strict, we</span>
<a name="line-698"></a>      <span class='hs-comment'>-- want to be a bit more eager to inline g, because it may</span>
<a name="line-699"></a>      <span class='hs-comment'>-- expose an eval (on x perhaps) that can be eliminated or</span>
<a name="line-700"></a>      <span class='hs-comment'>-- shared. I saw this in nofib 'boyer2', RewriteFuns.onewayunify1</span>
<a name="line-701"></a>      <span class='hs-comment'>-- It's worth an 18% improvement in allocation for this</span>
<a name="line-702"></a>      <span class='hs-comment'>-- particular benchmark; 5% on 'mate' and 1.3% on 'multiplier'</span>
<a name="line-703"></a>
<a name="line-704"></a><a name="interestingCallContext"></a><span class='hs-definition'>interestingCallContext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallCtxt</span>
<a name="line-705"></a><span class='hs-comment'>-- See Note [Interesting call context]</span>
<a name="line-706"></a><span class='hs-definition'>interestingCallContext</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cont</span>
<a name="line-707"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interesting</span> <span class='hs-varid'>cont</span>
<a name="line-708"></a>  <span class='hs-keyword'>where</span>
<a name="line-709"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-710"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sm_case_case</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CaseCtxt</span>
<a name="line-711"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BoringCtxt</span>
<a name="line-712"></a>       <span class='hs-comment'>-- See Note [No case of case is boring]</span>
<a name="line-713"></a>
<a name="line-714"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValAppCtxt</span>
<a name="line-715"></a>        <span class='hs-comment'>-- Can happen if we have (f Int |&gt; co) y</span>
<a name="line-716"></a>        <span class='hs-comment'>-- If f has an INLINE prag we need to give it some</span>
<a name="line-717"></a>        <span class='hs-comment'>-- motivation to inline. See Note [Cast then apply]</span>
<a name="line-718"></a>        <span class='hs-comment'>-- in GHC.Core.Unfold</span>
<a name="line-719"></a>
<a name="line-720"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>strictArgContext</span> <span class='hs-varid'>fun</span>
<a name="line-721"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BoringCtxt</span>
<a name="line-722"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>cci</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cci</span>
<a name="line-723"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interesting</span> <span class='hs-varid'>k</span>
<a name="line-724"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interesting</span> <span class='hs-varid'>k</span>
<a name="line-725"></a>    <span class='hs-varid'>interesting</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interesting</span> <span class='hs-varid'>k</span>
<a name="line-726"></a>        <span class='hs-comment'>-- If this call is the arg of a strict function, the context</span>
<a name="line-727"></a>        <span class='hs-comment'>-- is a bit interesting.  If we inline here, we may get useful</span>
<a name="line-728"></a>        <span class='hs-comment'>-- evaluation information to avoid repeated evals: e.g.</span>
<a name="line-729"></a>        <span class='hs-comment'>--      x + (y * z)</span>
<a name="line-730"></a>        <span class='hs-comment'>-- Here the contIsInteresting makes the '*' keener to inline,</span>
<a name="line-731"></a>        <span class='hs-comment'>-- which in turn exposes a constructor which makes the '+' inline.</span>
<a name="line-732"></a>        <span class='hs-comment'>-- Assuming that +,* aren't small enough to inline regardless.</span>
<a name="line-733"></a>        <span class='hs-comment'>--</span>
<a name="line-734"></a>        <span class='hs-comment'>-- It's also very important to inline in a strict context for things</span>
<a name="line-735"></a>        <span class='hs-comment'>-- like</span>
<a name="line-736"></a>        <span class='hs-comment'>--              foldr k z (f x)</span>
<a name="line-737"></a>        <span class='hs-comment'>-- Here, the context of (f x) is strict, and if f's unfolding is</span>
<a name="line-738"></a>        <span class='hs-comment'>-- a build it's *great* to inline it here.  So we must ensure that</span>
<a name="line-739"></a>        <span class='hs-comment'>-- the context for (f x) is not totally uninteresting.</span>
<a name="line-740"></a>
<a name="line-741"></a><a name="interestingArgContext"></a><span class='hs-definition'>interestingArgContext</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-742"></a><span class='hs-comment'>-- If the argument has form (f x y), where x,y are boring,</span>
<a name="line-743"></a><span class='hs-comment'>-- and f is marked INLINE, then we don't want to inline f.</span>
<a name="line-744"></a><span class='hs-comment'>-- But if the context of the argument is</span>
<a name="line-745"></a><span class='hs-comment'>--      g (f x y)</span>
<a name="line-746"></a><span class='hs-comment'>-- where g has rules, then we *do* want to inline f, in case it</span>
<a name="line-747"></a><span class='hs-comment'>-- exposes a rule that might fire.  Similarly, if the context is</span>
<a name="line-748"></a><span class='hs-comment'>--      h (g (f x x))</span>
<a name="line-749"></a><span class='hs-comment'>-- where h has rules, then we do want to inline f; hence the</span>
<a name="line-750"></a><span class='hs-comment'>-- call_cont argument to interestingArgContext</span>
<a name="line-751"></a><span class='hs-comment'>--</span>
<a name="line-752"></a><span class='hs-comment'>-- The ai-rules flag makes this happen; if it's</span>
<a name="line-753"></a><span class='hs-comment'>-- set, the inliner gets just enough keener to inline f</span>
<a name="line-754"></a><span class='hs-comment'>-- regardless of how boring f's arguments are, if it's marked INLINE</span>
<a name="line-755"></a><span class='hs-comment'>--</span>
<a name="line-756"></a><span class='hs-comment'>-- The alternative would be to *always* inline an INLINE function,</span>
<a name="line-757"></a><span class='hs-comment'>-- regardless of how boring its context is; but that seems overkill</span>
<a name="line-758"></a><span class='hs-comment'>-- For example, it'd mean that wrapper functions were always inlined</span>
<a name="line-759"></a><span class='hs-comment'>--</span>
<a name="line-760"></a><span class='hs-comment'>-- The call_cont passed to interestingArgContext is the context of</span>
<a name="line-761"></a><span class='hs-comment'>-- the call itself, e.g. g &lt;hole&gt; in the example above</span>
<a name="line-762"></a><span class='hs-definition'>interestingArgContext</span> <span class='hs-varid'>rules</span> <span class='hs-varid'>call_cont</span>
<a name="line-763"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>notNull</span> <span class='hs-varid'>rules</span> <span class='hs-varop'>||</span> <span class='hs-varid'>enclosing_fn_has_rules</span>
<a name="line-764"></a>  <span class='hs-keyword'>where</span>
<a name="line-765"></a>    <span class='hs-varid'>enclosing_fn_has_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>call_cont</span>
<a name="line-766"></a>
<a name="line-767"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-768"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>  <span class='hs-comment'>-- Shouldn't really happen</span>
<a name="line-769"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>  <span class='hs-comment'>-- Ditto</span>
<a name="line-770"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ai_encl</span> <span class='hs-varid'>fun</span>
<a name="line-771"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>      <span class='hs-comment'>-- ??</span>
<a name="line-772"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>c</span>
<a name="line-773"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>RuleArgCtxt</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-774"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-775"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>c</span>
<a name="line-776"></a>
<a name="line-777"></a><span class='hs-comment'>{- Note [Interesting arguments]
<a name="line-778"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-779"></a>An argument is interesting if it deserves a discount for unfoldings
<a name="line-780"></a>with a discount in that argument position.  The idea is to avoid
<a name="line-781"></a>unfolding a function that is applied only to variables that have no
<a name="line-782"></a>unfolding (i.e. they are probably lambda bound): f x y z There is
<a name="line-783"></a>little point in inlining f here.
<a name="line-784"></a>
<a name="line-785"></a>Generally, *values* (like (C a b) and (\x.e)) deserve discounts.  But
<a name="line-786"></a>we must look through lets, eg (let x = e in C a b), because the let will
<a name="line-787"></a>float, exposing the value, if we inline.  That makes it different to
<a name="line-788"></a>exprIsHNF.
<a name="line-789"></a>
<a name="line-790"></a>Before 2009 we said it was interesting if the argument had *any* structure
<a name="line-791"></a>at all; i.e. (hasSomeUnfolding v).  But does too much inlining; see #3016.
<a name="line-792"></a>
<a name="line-793"></a>But we don't regard (f x y) as interesting, unless f is unsaturated.
<a name="line-794"></a>If it's saturated and f hasn't inlined, then it's probably not going
<a name="line-795"></a>to now!
<a name="line-796"></a>
<a name="line-797"></a>Note [Conlike is interesting]
<a name="line-798"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-799"></a>Consider
<a name="line-800"></a>        f d = ...((*) d x y)...
<a name="line-801"></a>        ... f (df d')...
<a name="line-802"></a>where df is con-like. Then we'd really like to inline 'f' so that the
<a name="line-803"></a>rule for (*) (df d) can fire.  To do this
<a name="line-804"></a>  a) we give a discount for being an argument of a class-op (eg (*) d)
<a name="line-805"></a>  b) we say that a con-like argument (eg (df d)) is interesting
<a name="line-806"></a>-}</span>
<a name="line-807"></a>
<a name="line-808"></a><a name="interestingArg"></a><span class='hs-definition'>interestingArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgSummary</span>
<a name="line-809"></a><span class='hs-comment'>-- See Note [Interesting arguments]</span>
<a name="line-810"></a><span class='hs-definition'>interestingArg</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-num'>0</span> <span class='hs-varid'>e</span>
<a name="line-811"></a>  <span class='hs-keyword'>where</span>
<a name="line-812"></a>    <span class='hs-comment'>-- n is # value args to which the expression is applied</span>
<a name="line-813"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-814"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>substId</span> <span class='hs-varid'>env</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>of</span>
<a name="line-815"></a>           <span class='hs-conid'>DoneId</span> <span class='hs-varid'>v'</span>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go_var</span> <span class='hs-varid'>n</span> <span class='hs-varid'>v'</span>
<a name="line-816"></a>           <span class='hs-conid'>DoneEx</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>zapSubstEnv</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>             <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-817"></a>           <span class='hs-conid'>ContEx</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>cvs</span> <span class='hs-varid'>ids</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>setSubstEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>cvs</span> <span class='hs-varid'>ids</span><span class='hs-layout'>)</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-818"></a>
<a name="line-819"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>   <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValueArg</span>
<a name="line-820"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>   <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TrivArg</span>
<a name="line-821"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>   <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TrivArg</span>
<a name="line-822"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fn</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-varid'>fn</span>
<a name="line-823"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fn</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>fn</span>
<a name="line-824"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span>
<a name="line-825"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-826"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>v</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-827"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>v</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-828"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span><span class='hs-varop'>&gt;</span><span class='hs-num'>0</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonTrivArg</span>     <span class='hs-comment'>-- (\x.b) e   is NonTriv</span>
<a name="line-829"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValueArg</span>
<a name="line-830"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonTrivArg</span>
<a name="line-831"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>of</span>
<a name="line-832"></a>                                   <span class='hs-conid'>ValueArg</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ValueArg</span>
<a name="line-833"></a>                                   <span class='hs-keyword'>_</span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NonTrivArg</span>
<a name="line-834"></a>                               <span class='hs-keyword'>where</span>
<a name="line-835"></a>                                 <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-varop'>`addNewInScopeIds`</span> <span class='hs-varid'>bindersOf</span> <span class='hs-varid'>b</span>
<a name="line-836"></a>
<a name="line-837"></a>    <span class='hs-varid'>go_var</span> <span class='hs-varid'>n</span> <span class='hs-varid'>v</span>
<a name="line-838"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isConLikeId</span> <span class='hs-varid'>v</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValueArg</span>   <span class='hs-comment'>-- Experimenting with 'conlike' rather that</span>
<a name="line-839"></a>                                        <span class='hs-comment'>--    data constructors here</span>
<a name="line-840"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>idArity</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>n</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValueArg</span>   <span class='hs-comment'>-- Catches (eg) primops with arity but no unfolding</span>
<a name="line-841"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonTrivArg</span> <span class='hs-comment'>-- Saturated or unknown call</span>
<a name="line-842"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>conlike_unfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValueArg</span>   <span class='hs-comment'>-- n==0; look for an interesting unfolding</span>
<a name="line-843"></a>                                        <span class='hs-comment'>-- See Note [Conlike is interesting]</span>
<a name="line-844"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TrivArg</span>    <span class='hs-comment'>-- n==0, no useful unfolding</span>
<a name="line-845"></a>       <span class='hs-keyword'>where</span>
<a name="line-846"></a>         <span class='hs-varid'>conlike_unfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isConLikeUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-847"></a>
<a name="line-848"></a><span class='hs-comment'>{-
<a name="line-849"></a>************************************************************************
<a name="line-850"></a>*                                                                      *
<a name="line-851"></a>                  SimplMode
<a name="line-852"></a>*                                                                      *
<a name="line-853"></a>************************************************************************
<a name="line-854"></a>
<a name="line-855"></a>The SimplMode controls several switches; see its definition in
<a name="line-856"></a>GHC.Core.Opt.Monad
<a name="line-857"></a>        sm_rules      :: Bool     -- Whether RULES are enabled
<a name="line-858"></a>        sm_inline     :: Bool     -- Whether inlining is enabled
<a name="line-859"></a>        sm_case_case  :: Bool     -- Whether case-of-case is enabled
<a name="line-860"></a>        sm_eta_expand :: Bool     -- Whether eta-expansion is enabled
<a name="line-861"></a>-}</span>
<a name="line-862"></a>
<a name="line-863"></a><a name="simplEnvForGHCi"></a><span class='hs-definition'>simplEnvForGHCi</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Logger</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-864"></a><span class='hs-definition'>simplEnvForGHCi</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span>
<a name="line-865"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSimplEnv</span> <span class='hs-varop'>$</span> <span class='hs-conid'>SimplMode</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sm_names</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"GHCi"</span><span class='hs-keyglyph'>]</span>
<a name="line-866"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_phase</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InitialPhase</span>
<a name="line-867"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_logger</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>logger</span>
<a name="line-868"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_dflags</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dflags</span>
<a name="line-869"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_uf_opts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>uf_opts</span>
<a name="line-870"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_rules</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rules_on</span>
<a name="line-871"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_inline</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-872"></a>                              <span class='hs-comment'>-- Do not do any inlining, in case we expose some</span>
<a name="line-873"></a>                              <span class='hs-comment'>-- unboxed tuple stuff that confuses the bytecode</span>
<a name="line-874"></a>                              <span class='hs-comment'>-- interpreter</span>
<a name="line-875"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_eta_expand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eta_expand_on</span>
<a name="line-876"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_cast_swizzle</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-877"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_case_case</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-878"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sm_pre_inline</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pre_inline_on</span>
<a name="line-879"></a>                           <span class='hs-layout'>}</span>
<a name="line-880"></a>  <span class='hs-keyword'>where</span>
<a name="line-881"></a>    <span class='hs-varid'>rules_on</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_EnableRewriteRules</span>   <span class='hs-varid'>dflags</span>
<a name="line-882"></a>    <span class='hs-varid'>eta_expand_on</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_DoLambdaEtaExpansion</span> <span class='hs-varid'>dflags</span>
<a name="line-883"></a>    <span class='hs-varid'>pre_inline_on</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_SimplPreInlining</span>     <span class='hs-varid'>dflags</span>
<a name="line-884"></a>    <span class='hs-varid'>uf_opts</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unfoldingOpts</span>                 <span class='hs-varid'>dflags</span>
<a name="line-885"></a>
<a name="line-886"></a><a name="updModeForStableUnfoldings"></a><span class='hs-definition'>updModeForStableUnfoldings</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Activation</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplMode</span>
<a name="line-887"></a><span class='hs-definition'>updModeForStableUnfoldings</span> <span class='hs-varid'>unf_act</span> <span class='hs-varid'>current_mode</span>
<a name="line-888"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>current_mode</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sm_phase</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>phaseFromActivation</span> <span class='hs-varid'>unf_act</span>
<a name="line-889"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>sm_eta_expand</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-890"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>sm_inline</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span>
<a name="line-891"></a>    <span class='hs-comment'>-- sm_phase: see Note [Simplifying inside stable unfoldings]</span>
<a name="line-892"></a>    <span class='hs-comment'>-- sm_eta_expand: see Note [Eta-expansion in stable unfoldings]</span>
<a name="line-893"></a>    <span class='hs-comment'>-- sm_rules: just inherit; sm_rules might be "off"</span>
<a name="line-894"></a>    <span class='hs-comment'>--           because of -fno-enable-rewrite-rules</span>
<a name="line-895"></a>  <span class='hs-keyword'>where</span>
<a name="line-896"></a>    <span class='hs-varid'>phaseFromActivation</span> <span class='hs-layout'>(</span><span class='hs-conid'>ActiveAfter</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Phase</span> <span class='hs-varid'>n</span>
<a name="line-897"></a>    <span class='hs-varid'>phaseFromActivation</span> <span class='hs-keyword'>_</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InitialPhase</span>
<a name="line-898"></a>
<a name="line-899"></a><a name="updModeForRules"></a><span class='hs-definition'>updModeForRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplMode</span>
<a name="line-900"></a><span class='hs-comment'>-- See Note [Simplifying rules]</span>
<a name="line-901"></a><span class='hs-definition'>updModeForRules</span> <span class='hs-varid'>current_mode</span>
<a name="line-902"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>current_mode</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sm_phase</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InitialPhase</span>
<a name="line-903"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>sm_inline</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-904"></a>                      <span class='hs-comment'>-- See Note [Do not expose strictness if sm_inline=False]</span>
<a name="line-905"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>sm_rules</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-906"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>sm_cast_swizzle</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-907"></a>                      <span class='hs-comment'>-- See Note [Cast swizzling on rule LHSs]</span>
<a name="line-908"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>sm_eta_expand</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span>
<a name="line-909"></a>
<a name="line-910"></a><span class='hs-comment'>{- Note [Simplifying rules]
<a name="line-911"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-912"></a>When simplifying a rule LHS, refrain from /any/ inlining or applying
<a name="line-913"></a>of other RULES.
<a name="line-914"></a>
<a name="line-915"></a>Doing anything to the LHS is plain confusing, because it means that what the
<a name="line-916"></a>rule matches is not what the user wrote. c.f. #10595, and #10528.
<a name="line-917"></a>Moreover, inlining (or applying rules) on rule LHSs risks introducing
<a name="line-918"></a>Ticks into the LHS, which makes matching trickier. #10665, #10745.
<a name="line-919"></a>
<a name="line-920"></a>Doing this to either side confounds tools like HERMIT, which seek to reason
<a name="line-921"></a>about and apply the RULES as originally written. See #10829.
<a name="line-922"></a>
<a name="line-923"></a>There is, however, one case where we are pretty much /forced/ to transform the
<a name="line-924"></a>LHS of a rule: postInlineUnconditionally. For instance, in the case of
<a name="line-925"></a>
<a name="line-926"></a>    let f = g @Int in f
<a name="line-927"></a>
<a name="line-928"></a>We very much want to inline f into the body of the let. However, to do so (and
<a name="line-929"></a>be able to safely drop f's binding) we must inline into all occurrences of f,
<a name="line-930"></a>including those in the LHS of rules.
<a name="line-931"></a>
<a name="line-932"></a>This can cause somewhat surprising results; for instance, in #18162 we found
<a name="line-933"></a>that a rule template contained ticks in its arguments, because
<a name="line-934"></a>postInlineUnconditionally substituted in a trivial expression that contains
<a name="line-935"></a>ticks. See Note [Tick annotations in RULE matching] in GHC.Core.Rules for
<a name="line-936"></a>details.
<a name="line-937"></a>
<a name="line-938"></a>Note [Cast swizzling on rule LHSs]
<a name="line-939"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-940"></a>In the LHS of a RULE we may have
<a name="line-941"></a>       (\x. blah |&gt; CoVar cv)
<a name="line-942"></a>where `cv` is a coercion variable.  Critically, we really only want
<a name="line-943"></a>coercion /variables/, not general coercions, on the LHS of a RULE.  So
<a name="line-944"></a>we don't want to swizzle this to
<a name="line-945"></a>      (\x. blah) |&gt; (Refl xty `FunCo` CoVar cv)
<a name="line-946"></a>So we switch off cast swizzling in updModeForRules.
<a name="line-947"></a>
<a name="line-948"></a>Note [Eta-expansion in stable unfoldings]
<a name="line-949"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-950"></a>We don't do eta-expansion inside stable unfoldings.  It's extra work,
<a name="line-951"></a>and can be expensive (the bizarre T18223 is a case in point).
<a name="line-952"></a>
<a name="line-953"></a>See Note [Occurrence analysis for lambda binders] in GHC.Core.Opt.OccurAnal.
<a name="line-954"></a>
<a name="line-955"></a>Historical note. There was /previously/ another reason not to do eta
<a name="line-956"></a>expansion in stable unfoldings.  If we have a stable unfolding
<a name="line-957"></a>
<a name="line-958"></a>  f :: Ord a =&gt; a -&gt; IO ()
<a name="line-959"></a>  -- Unfolding template
<a name="line-960"></a>  --    = /\a \(d:Ord a) (x:a). bla
<a name="line-961"></a>
<a name="line-962"></a>we previously did not want to eta-expand to
<a name="line-963"></a>
<a name="line-964"></a>  f :: Ord a =&gt; a -&gt; IO ()
<a name="line-965"></a>  -- Unfolding template
<a name="line-966"></a>  --    = (/\a \(d:Ord a) (x:a) (eta:State#). bla eta) |&gt; co
<a name="line-967"></a>
<a name="line-968"></a>because not specialisation of the overloading didn't work properly (#9509).
<a name="line-969"></a>But now it does: see Note [Account for casts in binding] in GHC.Core.Opt.Specialise
<a name="line-970"></a>
<a name="line-971"></a>
<a name="line-972"></a>Note [Inlining in gentle mode]
<a name="line-973"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-974"></a>Something is inlined if
<a name="line-975"></a>   (i)   the sm_inline flag is on, AND
<a name="line-976"></a>   (ii)  the thing has an INLINE pragma, AND
<a name="line-977"></a>   (iii) the thing is inlinable in the earliest phase.
<a name="line-978"></a>
<a name="line-979"></a>Example of why (iii) is important:
<a name="line-980"></a>  {-# INLINE [~1] g #-}
<a name="line-981"></a>  g = ...
<a name="line-982"></a>
<a name="line-983"></a>  {-# INLINE f #-}
<a name="line-984"></a>  f x = g (g x)
<a name="line-985"></a>
<a name="line-986"></a>If we were to inline g into f's inlining, then an importing module would
<a name="line-987"></a>never be able to do
<a name="line-988"></a>        f e --&gt; g (g e) ---&gt; RULE fires
<a name="line-989"></a>because the stable unfolding for f has had g inlined into it.
<a name="line-990"></a>
<a name="line-991"></a>On the other hand, it is bad not to do ANY inlining into an
<a name="line-992"></a>stable unfolding, because then recursive knots in instance declarations
<a name="line-993"></a>don't get unravelled.
<a name="line-994"></a>
<a name="line-995"></a>However, *sometimes* SimplGently must do no call-site inlining at all
<a name="line-996"></a>(hence sm_inline = False).  Before full laziness we must be careful
<a name="line-997"></a>not to inline wrappers, because doing so inhibits floating
<a name="line-998"></a>    e.g. ...(case f x of ...)...
<a name="line-999"></a>    ==&gt; ...(case (case x of I# x# -&gt; fw x#) of ...)...
<a name="line-1000"></a>    ==&gt; ...(case x of I# x# -&gt; case fw x# of ...)...
<a name="line-1001"></a>and now the redex (f x) isn't floatable any more.
<a name="line-1002"></a>
<a name="line-1003"></a>The no-inlining thing is also important for Template Haskell.  You might be
<a name="line-1004"></a>compiling in one-shot mode with -O2; but when TH compiles a splice before
<a name="line-1005"></a>running it, we don't want to use -O2.  Indeed, we don't want to inline
<a name="line-1006"></a>anything, because the byte-code interpreter might get confused about
<a name="line-1007"></a>unboxed tuples and suchlike.
<a name="line-1008"></a>
<a name="line-1009"></a>Note [Simplifying inside stable unfoldings]
<a name="line-1010"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1011"></a>We must take care with simplification inside stable unfoldings (which come from
<a name="line-1012"></a>INLINE pragmas).
<a name="line-1013"></a>
<a name="line-1014"></a>First, consider the following example
<a name="line-1015"></a>        let f = \pq -&gt; BIG
<a name="line-1016"></a>        in
<a name="line-1017"></a>        let g = \y -&gt; f y y
<a name="line-1018"></a>            {-# INLINE g #-}
<a name="line-1019"></a>        in ...g...g...g...g...g...
<a name="line-1020"></a>Now, if that's the ONLY occurrence of f, it might be inlined inside g,
<a name="line-1021"></a>and thence copied multiple times when g is inlined. HENCE we treat
<a name="line-1022"></a>any occurrence in a stable unfolding as a multiple occurrence, not a single
<a name="line-1023"></a>one; see OccurAnal.addRuleUsage.
<a name="line-1024"></a>
<a name="line-1025"></a>Second, we do want *do* to some modest rules/inlining stuff in stable
<a name="line-1026"></a>unfoldings, partly to eliminate senseless crap, and partly to break
<a name="line-1027"></a>the recursive knots generated by instance declarations.
<a name="line-1028"></a>
<a name="line-1029"></a>However, suppose we have
<a name="line-1030"></a>        {-# INLINE &lt;act&gt; f #-}
<a name="line-1031"></a>        f = &lt;rhs&gt;
<a name="line-1032"></a>meaning "inline f in phases p where activation &lt;act&gt;(p) holds".
<a name="line-1033"></a>Then what inlinings/rules can we apply to the copy of &lt;rhs&gt; captured in
<a name="line-1034"></a>f's stable unfolding?  Our model is that literally &lt;rhs&gt; is substituted for
<a name="line-1035"></a>f when it is inlined.  So our conservative plan (implemented by
<a name="line-1036"></a>updModeForStableUnfoldings) is this:
<a name="line-1037"></a>
<a name="line-1038"></a>  -------------------------------------------------------------
<a name="line-1039"></a>  When simplifying the RHS of a stable unfolding, set the phase
<a name="line-1040"></a>  to the phase in which the stable unfolding first becomes active
<a name="line-1041"></a>  -------------------------------------------------------------
<a name="line-1042"></a>
<a name="line-1043"></a>That ensures that
<a name="line-1044"></a>
<a name="line-1045"></a>  a) Rules/inlinings that *cease* being active before p will
<a name="line-1046"></a>     not apply to the stable unfolding, consistent with it being
<a name="line-1047"></a>     inlined in its *original* form in phase p.
<a name="line-1048"></a>
<a name="line-1049"></a>  b) Rules/inlinings that only become active *after* p will
<a name="line-1050"></a>     not apply to the stable unfolding, again to be consistent with
<a name="line-1051"></a>     inlining the *original* rhs in phase p.
<a name="line-1052"></a>
<a name="line-1053"></a>For example,
<a name="line-1054"></a>        {-# INLINE f #-}
<a name="line-1055"></a>        f x = ...g...
<a name="line-1056"></a>
<a name="line-1057"></a>        {-# NOINLINE [1] g #-}
<a name="line-1058"></a>        g y = ...
<a name="line-1059"></a>
<a name="line-1060"></a>        {-# RULE h g = ... #-}
<a name="line-1061"></a>Here we must not inline g into f's RHS, even when we get to phase 0,
<a name="line-1062"></a>because when f is later inlined into some other module we want the
<a name="line-1063"></a>rule for h to fire.
<a name="line-1064"></a>
<a name="line-1065"></a>Similarly, consider
<a name="line-1066"></a>        {-# INLINE f #-}
<a name="line-1067"></a>        f x = ...g...
<a name="line-1068"></a>
<a name="line-1069"></a>        g y = ...
<a name="line-1070"></a>and suppose that there are auto-generated specialisations and a strictness
<a name="line-1071"></a>wrapper for g.  The specialisations get activation AlwaysActive, and the
<a name="line-1072"></a>strictness wrapper get activation (ActiveAfter 0).  So the strictness
<a name="line-1073"></a>wrepper fails the test and won't be inlined into f's stable unfolding. That
<a name="line-1074"></a>means f can inline, expose the specialised call to g, so the specialisation
<a name="line-1075"></a>rules can fire.
<a name="line-1076"></a>
<a name="line-1077"></a>A note about wrappers
<a name="line-1078"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-1079"></a>It's also important not to inline a worker back into a wrapper.
<a name="line-1080"></a>A wrapper looks like
<a name="line-1081"></a>        wraper = inline_me (\x -&gt; ...worker... )
<a name="line-1082"></a>Normally, the inline_me prevents the worker getting inlined into
<a name="line-1083"></a>the wrapper (initially, the worker's only call site!).  But,
<a name="line-1084"></a>if the wrapper is sure to be called, the strictness analyser will
<a name="line-1085"></a>mark it 'demanded', so when the RHS is simplified, it'll get an ArgOf
<a name="line-1086"></a>continuation.
<a name="line-1087"></a>-}</span>
<a name="line-1088"></a>
<a name="line-1089"></a><a name="activeUnfolding"></a><span class='hs-definition'>activeUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1090"></a><span class='hs-definition'>activeUnfolding</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>id</span>
<a name="line-1091"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCompulsoryUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>realIdUnfolding</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1092"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>   <span class='hs-comment'>-- Even sm_inline can't override compulsory unfoldings</span>
<a name="line-1093"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1094"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isActive</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_phase</span> <span class='hs-varid'>mode</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>idInlineActivation</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1095"></a>  <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>sm_inline</span> <span class='hs-varid'>mode</span>
<a name="line-1096"></a>      <span class='hs-comment'>-- `or` isStableUnfolding (realIdUnfolding id)</span>
<a name="line-1097"></a>      <span class='hs-comment'>-- Inline things when</span>
<a name="line-1098"></a>      <span class='hs-comment'>--  (a) they are active</span>
<a name="line-1099"></a>      <span class='hs-comment'>--  (b) sm_inline says so, except that for stable unfoldings</span>
<a name="line-1100"></a>      <span class='hs-comment'>--                         (ie pragmas) we inline anyway</span>
<a name="line-1101"></a>
<a name="line-1102"></a><a name="getUnfoldingInRuleMatch"></a><span class='hs-definition'>getUnfoldingInRuleMatch</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InScopeEnv</span>
<a name="line-1103"></a><span class='hs-comment'>-- When matching in RULE, we want to "look through" an unfolding</span>
<a name="line-1104"></a><span class='hs-comment'>-- (to see a constructor) if *rules* are on, even if *inlinings*</span>
<a name="line-1105"></a><span class='hs-comment'>-- are not.  A notable example is DFuns, which really we want to</span>
<a name="line-1106"></a><span class='hs-comment'>-- match in rules like (op dfun) in gentle mode. Another example</span>
<a name="line-1107"></a><span class='hs-comment'>-- is 'otherwise' which we want exprIsConApp_maybe to be able to</span>
<a name="line-1108"></a><span class='hs-comment'>-- see very early on</span>
<a name="line-1109"></a><span class='hs-definition'>getUnfoldingInRuleMatch</span> <span class='hs-varid'>env</span>
<a name="line-1110"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>in_scope</span><span class='hs-layout'>,</span> <span class='hs-varid'>id_unf</span><span class='hs-layout'>)</span>
<a name="line-1111"></a>  <span class='hs-keyword'>where</span>
<a name="line-1112"></a>    <span class='hs-varid'>in_scope</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seInScope</span> <span class='hs-varid'>env</span>
<a name="line-1113"></a>    <span class='hs-varid'>mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span>
<a name="line-1114"></a>    <span class='hs-varid'>id_unf</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>unf_is_active</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>id</span>
<a name="line-1115"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoUnfolding</span>
<a name="line-1116"></a>    <span class='hs-varid'>unf_is_active</span> <span class='hs-varid'>id</span>
<a name="line-1117"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_rules</span> <span class='hs-varid'>mode</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- active_unfolding_minimal id</span>
<a name="line-1118"></a>                             <span class='hs-varid'>isStableUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>realIdUnfolding</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1119"></a>        <span class='hs-comment'>-- Do we even need to test this?  I think this InScopeEnv</span>
<a name="line-1120"></a>        <span class='hs-comment'>-- is only consulted if activeRule returns True, which</span>
<a name="line-1121"></a>        <span class='hs-comment'>-- never happens if sm_rules is False</span>
<a name="line-1122"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isActive</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_phase</span> <span class='hs-varid'>mode</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>idInlineActivation</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1123"></a>
<a name="line-1124"></a><a name="activeRule"></a><span class='hs-comment'>----------------------</span>
<a name="line-1125"></a><span class='hs-definition'>activeRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Activation</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1126"></a><span class='hs-comment'>-- Nothing =&gt; No rules at all</span>
<a name="line-1127"></a><span class='hs-definition'>activeRule</span> <span class='hs-varid'>mode</span>
<a name="line-1128"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_rules</span> <span class='hs-varid'>mode</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>     <span class='hs-comment'>-- Rewriting is off</span>
<a name="line-1129"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isActive</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_phase</span> <span class='hs-varid'>mode</span><span class='hs-layout'>)</span>
<a name="line-1130"></a>
<a name="line-1131"></a><span class='hs-comment'>{-
<a name="line-1132"></a>************************************************************************
<a name="line-1133"></a>*                                                                      *
<a name="line-1134"></a>                  preInlineUnconditionally
<a name="line-1135"></a>*                                                                      *
<a name="line-1136"></a>************************************************************************
<a name="line-1137"></a>
<a name="line-1138"></a>preInlineUnconditionally
<a name="line-1139"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1140"></a>@preInlineUnconditionally@ examines a bndr to see if it is used just
<a name="line-1141"></a>once in a completely safe way, so that it is safe to discard the
<a name="line-1142"></a>binding inline its RHS at the (unique) usage site, REGARDLESS of how
<a name="line-1143"></a>big the RHS might be.  If this is the case we don't simplify the RHS
<a name="line-1144"></a>first, but just inline it un-simplified.
<a name="line-1145"></a>
<a name="line-1146"></a>This is much better than first simplifying a perhaps-huge RHS and then
<a name="line-1147"></a>inlining and re-simplifying it.  Indeed, it can be at least quadratically
<a name="line-1148"></a>better.  Consider
<a name="line-1149"></a>
<a name="line-1150"></a>        x1 = e1
<a name="line-1151"></a>        x2 = e2[x1]
<a name="line-1152"></a>        x3 = e3[x2]
<a name="line-1153"></a>        ...etc...
<a name="line-1154"></a>        xN = eN[xN-1]
<a name="line-1155"></a>
<a name="line-1156"></a>We may end up simplifying e1 N times, e2 N-1 times, e3 N-3 times etc.
<a name="line-1157"></a>This can happen with cascades of functions too:
<a name="line-1158"></a>
<a name="line-1159"></a>        f1 = \x1.e1
<a name="line-1160"></a>        f2 = \xs.e2[f1]
<a name="line-1161"></a>        f3 = \xs.e3[f3]
<a name="line-1162"></a>        ...etc...
<a name="line-1163"></a>
<a name="line-1164"></a>THE MAIN INVARIANT is this:
<a name="line-1165"></a>
<a name="line-1166"></a>        ----  preInlineUnconditionally invariant -----
<a name="line-1167"></a>   IF preInlineUnconditionally chooses to inline x = &lt;rhs&gt;
<a name="line-1168"></a>   THEN doing the inlining should not change the occurrence
<a name="line-1169"></a>        info for the free vars of &lt;rhs&gt;
<a name="line-1170"></a>        ----------------------------------------------
<a name="line-1171"></a>
<a name="line-1172"></a>For example, it's tempting to look at trivial binding like
<a name="line-1173"></a>        x = y
<a name="line-1174"></a>and inline it unconditionally.  But suppose x is used many times,
<a name="line-1175"></a>but this is the unique occurrence of y.  Then inlining x would change
<a name="line-1176"></a>y's occurrence info, which breaks the invariant.  It matters: y
<a name="line-1177"></a>might have a BIG rhs, which will now be dup'd at every occurrence of x.
<a name="line-1178"></a>
<a name="line-1179"></a>
<a name="line-1180"></a>Even RHSs labelled InlineMe aren't caught here, because there might be
<a name="line-1181"></a>no benefit from inlining at the call site.
<a name="line-1182"></a>
<a name="line-1183"></a>[Sept 01] Don't unconditionally inline a top-level thing, because that
<a name="line-1184"></a>can simply make a static thing into something built dynamically.  E.g.
<a name="line-1185"></a>        x = (a,b)
<a name="line-1186"></a>        main = \s -&gt; h x
<a name="line-1187"></a>
<a name="line-1188"></a>[Remember that we treat \s as a one-shot lambda.]  No point in
<a name="line-1189"></a>inlining x unless there is something interesting about the call site.
<a name="line-1190"></a>
<a name="line-1191"></a>But watch out: if you aren't careful, some useful foldr/build fusion
<a name="line-1192"></a>can be lost (most notably in spectral/hartel/parstof) because the
<a name="line-1193"></a>foldr didn't see the build.  Doing the dynamic allocation isn't a big
<a name="line-1194"></a>deal, in fact, but losing the fusion can be.  But the right thing here
<a name="line-1195"></a>seems to be to do a callSiteInline based on the fact that there is
<a name="line-1196"></a>something interesting about the call site (it's strict).  Hmm.  That
<a name="line-1197"></a>seems a bit fragile.
<a name="line-1198"></a>
<a name="line-1199"></a>Conclusion: inline top level things gaily until FinalPhase (the last
<a name="line-1200"></a>phase), at which point don't.
<a name="line-1201"></a>
<a name="line-1202"></a>Note [pre/postInlineUnconditionally in gentle mode]
<a name="line-1203"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1204"></a>Even in gentle mode we want to do preInlineUnconditionally.  The
<a name="line-1205"></a>reason is that too little clean-up happens if you don't inline
<a name="line-1206"></a>use-once things.  Also a bit of inlining is *good* for full laziness;
<a name="line-1207"></a>it can expose constant sub-expressions.  Example in
<a name="line-1208"></a>spectral/mandel/Mandel.hs, where the mandelset function gets a useful
<a name="line-1209"></a>let-float if you inline windowToViewport
<a name="line-1210"></a>
<a name="line-1211"></a>However, as usual for Gentle mode, do not inline things that are
<a name="line-1212"></a>inactive in the initial stages.  See Note [Gentle mode].
<a name="line-1213"></a>
<a name="line-1214"></a>Note [Stable unfoldings and preInlineUnconditionally]
<a name="line-1215"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1216"></a>Surprisingly, do not pre-inline-unconditionally Ids with INLINE pragmas!
<a name="line-1217"></a>Example
<a name="line-1218"></a>
<a name="line-1219"></a>   {-# INLINE f #-}
<a name="line-1220"></a>   f :: Eq a =&gt; a -&gt; a
<a name="line-1221"></a>   f x = ...
<a name="line-1222"></a>
<a name="line-1223"></a>   fInt :: Int -&gt; Int
<a name="line-1224"></a>   fInt = f Int dEqInt
<a name="line-1225"></a>
<a name="line-1226"></a>   ...fInt...fInt...fInt...
<a name="line-1227"></a>
<a name="line-1228"></a>Here f occurs just once, in the RHS of fInt. But if we inline it there
<a name="line-1229"></a>it might make fInt look big, and we'll lose the opportunity to inline f
<a name="line-1230"></a>at each of fInt's call sites.  The INLINE pragma will only inline when
<a name="line-1231"></a>the application is saturated for exactly this reason; and we don't
<a name="line-1232"></a>want PreInlineUnconditionally to second-guess it. A live example is #3736.
<a name="line-1233"></a>    c.f. Note [Stable unfoldings and postInlineUnconditionally]
<a name="line-1234"></a>
<a name="line-1235"></a>NB: this only applies for INLINE things. Do /not/ switch off
<a name="line-1236"></a>preInlineUnconditionally for
<a name="line-1237"></a>
<a name="line-1238"></a>* INLINABLE. It just says to GHC "inline this if you like".  If there
<a name="line-1239"></a>  is a unique occurrence, we want to inline the stable unfolding, not
<a name="line-1240"></a>  the RHS.
<a name="line-1241"></a>
<a name="line-1242"></a>* NONLINE[n] just switches off inlining until phase n.  We should
<a name="line-1243"></a>  respect that, but after phase n, just behave as usual.
<a name="line-1244"></a>
<a name="line-1245"></a>* NoUserInlinePrag.  There is no pragma at all. This ends up on wrappers.
<a name="line-1246"></a>  (See #18815.)
<a name="line-1247"></a>
<a name="line-1248"></a>Note [Top-level bottoming Ids]
<a name="line-1249"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1250"></a>Don't inline top-level Ids that are bottoming, even if they are used just
<a name="line-1251"></a>once, because FloatOut has gone to some trouble to extract them out.
<a name="line-1252"></a>Inlining them won't make the program run faster!
<a name="line-1253"></a>
<a name="line-1254"></a>Note [Do not inline CoVars unconditionally]
<a name="line-1255"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1256"></a>Coercion variables appear inside coercions, and the RHS of a let-binding
<a name="line-1257"></a>is a term (not a coercion) so we can't necessarily inline the latter in
<a name="line-1258"></a>the former.
<a name="line-1259"></a>-}</span>
<a name="line-1260"></a>
<a name="line-1261"></a><a name="preInlineUnconditionally"></a><span class='hs-definition'>preInlineUnconditionally</span>
<a name="line-1262"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span>
<a name="line-1263"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StaticEnv</span>  <span class='hs-comment'>-- These two go together</span>
<a name="line-1264"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>SimplEnv</span>       <span class='hs-comment'>-- Returned env has extended substitution</span>
<a name="line-1265"></a><span class='hs-comment'>-- Precondition: rhs satisfies the let/app invariant</span>
<a name="line-1266"></a><span class='hs-comment'>-- See Note [Core let/app invariant] in GHC.Core</span>
<a name="line-1267"></a><span class='hs-comment'>-- Reason: we don't want to inline single uses, or discard dead bindings,</span>
<a name="line-1268"></a><span class='hs-comment'>--         for unlifted, side-effect-ful bindings</span>
<a name="line-1269"></a><span class='hs-definition'>preInlineUnconditionally</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>rhs_env</span>
<a name="line-1270"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>pre_inline_unconditionally</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1271"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>active</span>                               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1272"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isDeadEndId</span> <span class='hs-varid'>bndr</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span> <span class='hs-comment'>-- Note [Top-level bottoming Ids]</span>
<a name="line-1273"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCoVar</span> <span class='hs-varid'>bndr</span>                             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span> <span class='hs-comment'>-- Note [Do not inline CoVars unconditionally]</span>
<a name="line-1274"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isExitJoinId</span> <span class='hs-varid'>bndr</span>                        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span> <span class='hs-comment'>-- Note [Do not inline exit join points]</span>
<a name="line-1275"></a>                                                       <span class='hs-comment'>-- in module Exitify</span>
<a name="line-1276"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>one_occ</span> <span class='hs-layout'>(</span><span class='hs-varid'>idOccInfo</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1277"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isStableUnfolding</span> <span class='hs-varid'>unf</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varop'>$!</span> <span class='hs-layout'>(</span><span class='hs-varid'>extend_subst_with</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1278"></a>
<a name="line-1279"></a>  <span class='hs-comment'>-- Note [Stable unfoldings and preInlineUnconditionally]</span>
<a name="line-1280"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isInlinePragma</span> <span class='hs-varid'>inline_prag</span><span class='hs-layout'>)</span>
<a name="line-1281"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>inl</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>maybeUnfoldingTemplate</span> <span class='hs-varid'>unf</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varop'>$!</span> <span class='hs-layout'>(</span><span class='hs-varid'>extend_subst_with</span> <span class='hs-varid'>inl</span><span class='hs-layout'>)</span>
<a name="line-1282"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1283"></a>  <span class='hs-keyword'>where</span>
<a name="line-1284"></a>    <span class='hs-varid'>unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>bndr</span>
<a name="line-1285"></a>    <span class='hs-varid'>extend_subst_with</span> <span class='hs-varid'>inl_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendIdSubst</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>$!</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkContEx</span> <span class='hs-varid'>rhs_env</span> <span class='hs-varid'>inl_rhs</span><span class='hs-layout'>)</span>
<a name="line-1286"></a>
<a name="line-1287"></a>    <span class='hs-varid'>one_occ</span> <span class='hs-conid'>IAmDead</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-comment'>-- Happens in ((\x.1) v)</span>
<a name="line-1288"></a>    <span class='hs-varid'>one_occ</span> <span class='hs-conid'>OneOcc</span><span class='hs-layout'>{</span> <span class='hs-varid'>occ_n_br</span>   <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-1289"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>occ_in_lam</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NotInsideLam</span> <span class='hs-layout'>}</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNotTopLevel</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varop'>||</span> <span class='hs-varid'>early_phase</span>
<a name="line-1290"></a>    <span class='hs-varid'>one_occ</span> <span class='hs-conid'>OneOcc</span><span class='hs-layout'>{</span> <span class='hs-varid'>occ_n_br</span>   <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-1291"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>occ_in_lam</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IsInsideLam</span>
<a name="line-1292"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>occ_int_cxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IsInteresting</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canInlineInLam</span> <span class='hs-varid'>rhs</span>
<a name="line-1293"></a>    <span class='hs-varid'>one_occ</span> <span class='hs-keyword'>_</span>                                     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1294"></a>
<a name="line-1295"></a>    <span class='hs-varid'>pre_inline_unconditionally</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sm_pre_inline</span> <span class='hs-varid'>mode</span>
<a name="line-1296"></a>    <span class='hs-varid'>mode</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span>
<a name="line-1297"></a>    <span class='hs-varid'>active</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isActive</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_phase</span> <span class='hs-varid'>mode</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>inlinePragmaActivation</span> <span class='hs-varid'>inline_prag</span><span class='hs-layout'>)</span>
<a name="line-1298"></a>             <span class='hs-comment'>-- See Note [pre/postInlineUnconditionally in gentle mode]</span>
<a name="line-1299"></a>    <span class='hs-varid'>inline_prag</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idInlinePragma</span> <span class='hs-varid'>bndr</span>
<a name="line-1300"></a>
<a name="line-1301"></a><span class='hs-comment'>-- Be very careful before inlining inside a lambda, because (a) we must not</span>
<a name="line-1302"></a><span class='hs-comment'>-- invalidate occurrence information, and (b) we want to avoid pushing a</span>
<a name="line-1303"></a><span class='hs-comment'>-- single allocation (here) into multiple allocations (inside lambda).</span>
<a name="line-1304"></a><span class='hs-comment'>-- Inlining a *function* with a single *saturated* call would be ok, mind you.</span>
<a name="line-1305"></a><span class='hs-comment'>--      || (if is_cheap &amp;&amp; not (canInlineInLam rhs) then pprTrace "preinline" (ppr bndr &lt;+&gt; ppr rhs) ok else ok)</span>
<a name="line-1306"></a><span class='hs-comment'>--      where</span>
<a name="line-1307"></a><span class='hs-comment'>--              is_cheap = exprIsCheap rhs</span>
<a name="line-1308"></a><span class='hs-comment'>--              ok = is_cheap &amp;&amp; int_cxt</span>
<a name="line-1309"></a>
<a name="line-1310"></a>        <span class='hs-comment'>--      int_cxt         The context isn't totally boring</span>
<a name="line-1311"></a>        <span class='hs-comment'>-- E.g. let f = \ab.BIG in \y. map f xs</span>
<a name="line-1312"></a>        <span class='hs-comment'>--      Don't want to substitute for f, because then we allocate</span>
<a name="line-1313"></a>        <span class='hs-comment'>--      its closure every time the \y is called</span>
<a name="line-1314"></a>        <span class='hs-comment'>-- But: let f = \ab.BIG in \y. map (f y) xs</span>
<a name="line-1315"></a>        <span class='hs-comment'>--      Now we do want to substitute for f, even though it's not</span>
<a name="line-1316"></a>        <span class='hs-comment'>--      saturated, because we're going to allocate a closure for</span>
<a name="line-1317"></a>        <span class='hs-comment'>--      (f y) every time round the loop anyhow.</span>
<a name="line-1318"></a>
<a name="line-1319"></a>        <span class='hs-comment'>-- canInlineInLam =&gt; free vars of rhs are (Once in_lam) or Many,</span>
<a name="line-1320"></a>        <span class='hs-comment'>-- so substituting rhs inside a lambda doesn't change the occ info.</span>
<a name="line-1321"></a>        <span class='hs-comment'>-- Sadly, not quite the same as exprIsHNF.</span>
<a name="line-1322"></a>    <span class='hs-varid'>canInlineInLam</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1323"></a>    <span class='hs-varid'>canInlineInLam</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isRuntimeVar</span> <span class='hs-varid'>b</span> <span class='hs-varop'>||</span> <span class='hs-varid'>canInlineInLam</span> <span class='hs-varid'>e</span>
<a name="line-1324"></a>    <span class='hs-varid'>canInlineInLam</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishIsCode</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>canInlineInLam</span> <span class='hs-varid'>e</span>
<a name="line-1325"></a>    <span class='hs-varid'>canInlineInLam</span> <span class='hs-keyword'>_</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1326"></a>      <span class='hs-comment'>-- not ticks.  Counting ticks cannot be duplicated, and non-counting</span>
<a name="line-1327"></a>      <span class='hs-comment'>-- ticks around a Lam will disappear anyway.</span>
<a name="line-1328"></a>
<a name="line-1329"></a>    <span class='hs-varid'>early_phase</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sm_phase</span> <span class='hs-varid'>mode</span> <span class='hs-varop'>/=</span> <span class='hs-conid'>FinalPhase</span>
<a name="line-1330"></a>    <span class='hs-comment'>-- If we don't have this early_phase test, consider</span>
<a name="line-1331"></a>    <span class='hs-comment'>--      x = length [1,2,3]</span>
<a name="line-1332"></a>    <span class='hs-comment'>-- The full laziness pass carefully floats all the cons cells to</span>
<a name="line-1333"></a>    <span class='hs-comment'>-- top level, and preInlineUnconditionally floats them all back in.</span>
<a name="line-1334"></a>    <span class='hs-comment'>-- Result is (a) static allocation replaced by dynamic allocation</span>
<a name="line-1335"></a>    <span class='hs-comment'>--           (b) many simplifier iterations because this tickles</span>
<a name="line-1336"></a>    <span class='hs-comment'>--               a related problem; only one inlining per pass</span>
<a name="line-1337"></a>    <span class='hs-comment'>--</span>
<a name="line-1338"></a>    <span class='hs-comment'>-- On the other hand, I have seen cases where top-level fusion is</span>
<a name="line-1339"></a>    <span class='hs-comment'>-- lost if we don't inline top level thing (e.g. string constants)</span>
<a name="line-1340"></a>    <span class='hs-comment'>-- Hence the test for phase zero (which is the phase for all the final</span>
<a name="line-1341"></a>    <span class='hs-comment'>-- simplifications).  Until phase zero we take no special notice of</span>
<a name="line-1342"></a>    <span class='hs-comment'>-- top level things, but then we become more leery about inlining</span>
<a name="line-1343"></a>    <span class='hs-comment'>-- them.</span>
<a name="line-1344"></a>
<a name="line-1345"></a><span class='hs-comment'>{-
<a name="line-1346"></a>************************************************************************
<a name="line-1347"></a>*                                                                      *
<a name="line-1348"></a>                  postInlineUnconditionally
<a name="line-1349"></a>*                                                                      *
<a name="line-1350"></a>************************************************************************
<a name="line-1351"></a>
<a name="line-1352"></a>postInlineUnconditionally
<a name="line-1353"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1354"></a>@postInlineUnconditionally@ decides whether to unconditionally inline
<a name="line-1355"></a>a thing based on the form of its RHS; in particular if it has a
<a name="line-1356"></a>trivial RHS.  If so, we can inline and discard the binding altogether.
<a name="line-1357"></a>
<a name="line-1358"></a>NB: a loop breaker has must_keep_binding = True and non-loop-breakers
<a name="line-1359"></a>only have *forward* references. Hence, it's safe to discard the binding
<a name="line-1360"></a>
<a name="line-1361"></a>NOTE: This isn't our last opportunity to inline.  We're at the binding
<a name="line-1362"></a>site right now, and we'll get another opportunity when we get to the
<a name="line-1363"></a>occurrence(s)
<a name="line-1364"></a>
<a name="line-1365"></a>Note that we do this unconditional inlining only for trivial RHSs.
<a name="line-1366"></a>Don't inline even WHNFs inside lambdas; doing so may simply increase
<a name="line-1367"></a>allocation when the function is called. This isn't the last chance; see
<a name="line-1368"></a>NOTE above.
<a name="line-1369"></a>
<a name="line-1370"></a>NB: Even inline pragmas (e.g. IMustBeINLINEd) are ignored here Why?
<a name="line-1371"></a>Because we don't even want to inline them into the RHS of constructor
<a name="line-1372"></a>arguments. See NOTE above
<a name="line-1373"></a>
<a name="line-1374"></a>NB: At one time even NOINLINE was ignored here: if the rhs is trivial
<a name="line-1375"></a>it's best to inline it anyway.  We often get a=E; b=a from desugaring,
<a name="line-1376"></a>with both a and b marked NOINLINE.  But that seems incompatible with
<a name="line-1377"></a>our new view that inlining is like a RULE, so I'm sticking to the 'active'
<a name="line-1378"></a>story for now.
<a name="line-1379"></a>
<a name="line-1380"></a>NB: unconditional inlining of this sort can introduce ticks in places that
<a name="line-1381"></a>may seem surprising; for instance, the LHS of rules. See Note [Simplfying
<a name="line-1382"></a>rules] for details.
<a name="line-1383"></a>-}</span>
<a name="line-1384"></a>
<a name="line-1385"></a><a name="postInlineUnconditionally"></a><span class='hs-definition'>postInlineUnconditionally</span>
<a name="line-1386"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-1387"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span>            <span class='hs-comment'>-- The binder (*not* a CoVar), including its unfolding</span>
<a name="line-1388"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfo</span>          <span class='hs-comment'>-- From the InId</span>
<a name="line-1389"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>
<a name="line-1390"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1391"></a><span class='hs-comment'>-- Precondition: rhs satisfies the let/app invariant</span>
<a name="line-1392"></a><span class='hs-comment'>-- See Note [Core let/app invariant] in GHC.Core</span>
<a name="line-1393"></a><span class='hs-comment'>-- Reason: we don't want to inline single uses, or discard dead bindings,</span>
<a name="line-1394"></a><span class='hs-comment'>--         for unlifted, side-effect-ful bindings</span>
<a name="line-1395"></a><span class='hs-definition'>postInlineUnconditionally</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>occ_info</span> <span class='hs-varid'>rhs</span>
<a name="line-1396"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>active</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1397"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isWeakLoopBreaker</span> <span class='hs-varid'>occ_info</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- If it's a loop-breaker of any kind, don't inline</span>
<a name="line-1398"></a>                                        <span class='hs-comment'>-- because it might be referred to "earlier"</span>
<a name="line-1399"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStableUnfolding</span> <span class='hs-varid'>unfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- Note [Stable unfoldings and postInlineUnconditionally]</span>
<a name="line-1400"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- Note [Top level and postInlineUnconditionally]</span>
<a name="line-1401"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>rhs</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1402"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isJoinId</span> <span class='hs-varid'>bndr</span>                       <span class='hs-comment'>-- See point (1) of Note [Duplicating join points]</span>
<a name="line-1403"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>phase</span> <span class='hs-varop'>==</span> <span class='hs-conid'>FinalPhase</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- in Simplify.hs</span>
<a name="line-1404"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1405"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occ_info</span> <span class='hs-keyword'>of</span>
<a name="line-1406"></a>      <span class='hs-conid'>OneOcc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_in_lam</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>in_lam</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_int_cxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>int_cxt</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_n_br</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n_br</span> <span class='hs-layout'>}</span>
<a name="line-1407"></a>        <span class='hs-comment'>-- See Note [Inline small things to avoid creating a thunk]</span>
<a name="line-1408"></a>
<a name="line-1409"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>n_br</span> <span class='hs-varop'>&lt;</span> <span class='hs-num'>100</span>  <span class='hs-comment'>-- See Note [Suppress exponential blowup]</span>
<a name="line-1410"></a>
<a name="line-1411"></a>           <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>smallEnoughToInline</span> <span class='hs-varid'>uf_opts</span> <span class='hs-varid'>unfolding</span>     <span class='hs-comment'>-- Small enough to dup</span>
<a name="line-1412"></a>                        <span class='hs-comment'>-- ToDo: consider discount on smallEnoughToInline if int_cxt is true</span>
<a name="line-1413"></a>                        <span class='hs-comment'>--</span>
<a name="line-1414"></a>                        <span class='hs-comment'>-- NB: Do NOT inline arbitrarily big things, even if occ_n_br=1</span>
<a name="line-1415"></a>                        <span class='hs-comment'>-- Reason: doing so risks exponential behaviour.  We simplify a big</span>
<a name="line-1416"></a>                        <span class='hs-comment'>--         expression, inline it, and simplify it again.  But if the</span>
<a name="line-1417"></a>                        <span class='hs-comment'>--         very same thing happens in the big expression, we get</span>
<a name="line-1418"></a>                        <span class='hs-comment'>--         exponential cost!</span>
<a name="line-1419"></a>                        <span class='hs-comment'>-- PRINCIPLE: when we've already simplified an expression once,</span>
<a name="line-1420"></a>                        <span class='hs-comment'>-- make sure that we only inline it if it's reasonably small.</span>
<a name="line-1421"></a>
<a name="line-1422"></a>           <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>in_lam</span> <span class='hs-varop'>==</span> <span class='hs-conid'>NotInsideLam</span> <span class='hs-varop'>||</span>
<a name="line-1423"></a>                        <span class='hs-comment'>-- Outside a lambda, we want to be reasonably aggressive</span>
<a name="line-1424"></a>                        <span class='hs-comment'>-- about inlining into multiple branches of case</span>
<a name="line-1425"></a>                        <span class='hs-comment'>-- e.g. let x = &lt;non-value&gt;</span>
<a name="line-1426"></a>                        <span class='hs-comment'>--      in case y of { C1 -&gt; ..x..; C2 -&gt; ..x..; C3 -&gt; ... }</span>
<a name="line-1427"></a>                        <span class='hs-comment'>-- Inlining can be a big win if C3 is the hot-spot, even if</span>
<a name="line-1428"></a>                        <span class='hs-comment'>-- the uses in C1, C2 are not 'interesting'</span>
<a name="line-1429"></a>                        <span class='hs-comment'>-- An example that gets worse if you add int_cxt here is 'clausify'</span>
<a name="line-1430"></a>
<a name="line-1431"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>isCheapUnfolding</span> <span class='hs-varid'>unfolding</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>int_cxt</span> <span class='hs-varop'>==</span> <span class='hs-conid'>IsInteresting</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1432"></a>                        <span class='hs-comment'>-- isCheap =&gt; acceptable work duplication; in_lam may be true</span>
<a name="line-1433"></a>                        <span class='hs-comment'>-- int_cxt to prevent us inlining inside a lambda without some</span>
<a name="line-1434"></a>                        <span class='hs-comment'>-- good reason.  See the notes on int_cxt in preInlineUnconditionally</span>
<a name="line-1435"></a>
<a name="line-1436"></a>      <span class='hs-conid'>IAmDead</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>   <span class='hs-comment'>-- This happens; for example, the case_bndr during case of</span>
<a name="line-1437"></a>                        <span class='hs-comment'>-- known constructor:  case (a,b) of x { (p,q) -&gt; ... }</span>
<a name="line-1438"></a>                        <span class='hs-comment'>-- Here x isn't mentioned in the RHS, so we don't want to</span>
<a name="line-1439"></a>                        <span class='hs-comment'>-- create the (dead) let-binding  let x = (a,b) in ...</span>
<a name="line-1440"></a>
<a name="line-1441"></a>      <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1442"></a>
<a name="line-1443"></a><span class='hs-comment'>-- Here's an example that we don't handle well:</span>
<a name="line-1444"></a><span class='hs-comment'>--      let f = if b then Left (\x.BIG) else Right (\y.BIG)</span>
<a name="line-1445"></a><span class='hs-comment'>--      in \y. ....case f of {...} ....</span>
<a name="line-1446"></a><span class='hs-comment'>-- Here f is used just once, and duplicating the case work is fine (exprIsCheap).</span>
<a name="line-1447"></a><span class='hs-comment'>-- But</span>
<a name="line-1448"></a><span class='hs-comment'>--  - We can't preInlineUnconditionally because that would invalidate</span>
<a name="line-1449"></a><span class='hs-comment'>--    the occ info for b.</span>
<a name="line-1450"></a><span class='hs-comment'>--  - We can't postInlineUnconditionally because the RHS is big, and</span>
<a name="line-1451"></a><span class='hs-comment'>--    that risks exponential behaviour</span>
<a name="line-1452"></a><span class='hs-comment'>--  - We can't call-site inline, because the rhs is big</span>
<a name="line-1453"></a><span class='hs-comment'>-- Alas!</span>
<a name="line-1454"></a>
<a name="line-1455"></a>  <span class='hs-keyword'>where</span>
<a name="line-1456"></a>    <span class='hs-varid'>unfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>bndr</span>
<a name="line-1457"></a>    <span class='hs-varid'>uf_opts</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seUnfoldingOpts</span> <span class='hs-varid'>env</span>
<a name="line-1458"></a>    <span class='hs-varid'>phase</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sm_phase</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-1459"></a>    <span class='hs-varid'>active</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isActive</span> <span class='hs-varid'>phase</span> <span class='hs-layout'>(</span><span class='hs-varid'>idInlineActivation</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-1460"></a>        <span class='hs-comment'>-- See Note [pre/postInlineUnconditionally in gentle mode]</span>
<a name="line-1461"></a>
<a name="line-1462"></a><span class='hs-comment'>{- Note [Inline small things to avoid creating a thunk]
<a name="line-1463"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1464"></a>The point of examining occ_info here is that for *non-values* that
<a name="line-1465"></a>occur outside a lambda, the call-site inliner won't have a chance
<a name="line-1466"></a>(because it doesn't know that the thing only occurs once).  The
<a name="line-1467"></a>pre-inliner won't have gotten it either, if the thing occurs in more
<a name="line-1468"></a>than one branch So the main target is things like
<a name="line-1469"></a>
<a name="line-1470"></a>     let x = f y in
<a name="line-1471"></a>     case v of
<a name="line-1472"></a>        True  -&gt; case x of ...
<a name="line-1473"></a>        False -&gt; case x of ...
<a name="line-1474"></a>
<a name="line-1475"></a>This is very important in practice; e.g. wheel-seive1 doubles
<a name="line-1476"></a>in allocation if you miss this out.  And bits of GHC itself start
<a name="line-1477"></a>to allocate more.  An egregious example is test perf/compiler/T14697,
<a name="line-1478"></a>where GHC.Driver.CmdLine.$wprocessArgs allocated hugely more.
<a name="line-1479"></a>
<a name="line-1480"></a>Note [Suppress exponential blowup]
<a name="line-1481"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1482"></a>In #13253, and several related tickets, we got an exponential blowup
<a name="line-1483"></a>in code size from postInlineUnconditionally.  The trouble comes when
<a name="line-1484"></a>we have
<a name="line-1485"></a>  let j1a = case f y     of { True -&gt; p;   False -&gt; q }
<a name="line-1486"></a>      j1b = case f y     of { True -&gt; q;   False -&gt; p }
<a name="line-1487"></a>      j2a = case f (y+1) of { True -&gt; j1a; False -&gt; j1b }
<a name="line-1488"></a>      j2b = case f (y+1) of { True -&gt; j1b; False -&gt; j1a }
<a name="line-1489"></a>      ...
<a name="line-1490"></a>  in case f (y+10) of { True -&gt; j10a; False -&gt; j10b }
<a name="line-1491"></a>
<a name="line-1492"></a>when there are many branches. In pass 1, postInlineUnconditionally
<a name="line-1493"></a>inlines j10a and j10b (they are both small).  Now we have two calls
<a name="line-1494"></a>to j9a and two to j9b.  In pass 2, postInlineUnconditionally inlines
<a name="line-1495"></a>all four of these calls, leaving four calls to j8a and j8b. Etc.
<a name="line-1496"></a>Yikes!  This is exponential!
<a name="line-1497"></a>
<a name="line-1498"></a>A possible plan: stop doing postInlineUnconditionally
<a name="line-1499"></a>for some fixed, smallish number of branches, say 4. But that turned
<a name="line-1500"></a>out to be bad: see Note [Inline small things to avoid creating a thunk].
<a name="line-1501"></a>And, as it happened, the problem with #13253 was solved in a
<a name="line-1502"></a>different way (Note [Duplicating StrictArg] in Simplify).
<a name="line-1503"></a>
<a name="line-1504"></a>So I just set an arbitrary, high limit of 100, to stop any
<a name="line-1505"></a>totally exponential behaviour.
<a name="line-1506"></a>
<a name="line-1507"></a>This still leaves the nasty possibility that /ordinary/ inlining (not
<a name="line-1508"></a>postInlineUnconditionally) might inline these join points, each of
<a name="line-1509"></a>which is individually quiet small.  I'm still not sure what to do
<a name="line-1510"></a>about this (e.g. see #15488).
<a name="line-1511"></a>
<a name="line-1512"></a>Note [Top level and postInlineUnconditionally]
<a name="line-1513"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1514"></a>We don't do postInlineUnconditionally for top-level things (even for
<a name="line-1515"></a>ones that are trivial):
<a name="line-1516"></a>
<a name="line-1517"></a>  * Doing so will inline top-level error expressions that have been
<a name="line-1518"></a>    carefully floated out by FloatOut.  More generally, it might
<a name="line-1519"></a>    replace static allocation with dynamic.
<a name="line-1520"></a>
<a name="line-1521"></a>  * Even for trivial expressions there's a problem.  Consider
<a name="line-1522"></a>      {-# RULE "foo" forall (xs::[T]). reverse xs = ruggle xs #-}
<a name="line-1523"></a>      blah xs = reverse xs
<a name="line-1524"></a>      ruggle = sort
<a name="line-1525"></a>    In one simplifier pass we might fire the rule, getting
<a name="line-1526"></a>      blah xs = ruggle xs
<a name="line-1527"></a>    but in *that* simplifier pass we must not do postInlineUnconditionally
<a name="line-1528"></a>    on 'ruggle' because then we'll have an unbound occurrence of 'ruggle'
<a name="line-1529"></a>
<a name="line-1530"></a>    If the rhs is trivial it'll be inlined by callSiteInline, and then
<a name="line-1531"></a>    the binding will be dead and discarded by the next use of OccurAnal
<a name="line-1532"></a>
<a name="line-1533"></a>  * There is less point, because the main goal is to get rid of local
<a name="line-1534"></a>    bindings used in multiple case branches.
<a name="line-1535"></a>
<a name="line-1536"></a>  * The inliner should inline trivial things at call sites anyway.
<a name="line-1537"></a>
<a name="line-1538"></a>  * The Id might be exported.  We could check for that separately,
<a name="line-1539"></a>    but since we aren't going to postInlineUnconditionally /any/
<a name="line-1540"></a>    top-level bindings, we don't need to test.
<a name="line-1541"></a>
<a name="line-1542"></a>Note [Stable unfoldings and postInlineUnconditionally]
<a name="line-1543"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1544"></a>Do not do postInlineUnconditionally if the Id has a stable unfolding,
<a name="line-1545"></a>otherwise we lose the unfolding.  Example
<a name="line-1546"></a>
<a name="line-1547"></a>     -- f has stable unfolding with rhs (e |&gt; co)
<a name="line-1548"></a>     --   where 'e' is big
<a name="line-1549"></a>     f = e |&gt; co
<a name="line-1550"></a>
<a name="line-1551"></a>Then there's a danger we'll optimise to
<a name="line-1552"></a>
<a name="line-1553"></a>     f' = e
<a name="line-1554"></a>     f = f' |&gt; co
<a name="line-1555"></a>
<a name="line-1556"></a>and now postInlineUnconditionally, losing the stable unfolding on f.  Now f'
<a name="line-1557"></a>won't inline because 'e' is too big.
<a name="line-1558"></a>
<a name="line-1559"></a>    c.f. Note [Stable unfoldings and preInlineUnconditionally]
<a name="line-1560"></a>
<a name="line-1561"></a>
<a name="line-1562"></a>************************************************************************
<a name="line-1563"></a>*                                                                      *
<a name="line-1564"></a>        Rebuilding a lambda
<a name="line-1565"></a>*                                                                      *
<a name="line-1566"></a>************************************************************************
<a name="line-1567"></a>-}</span>
<a name="line-1568"></a>
<a name="line-1569"></a><a name="mkLam"></a><span class='hs-definition'>mkLam</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>OutExpr</span>
<a name="line-1570"></a><span class='hs-comment'>-- mkLam tries three things</span>
<a name="line-1571"></a><span class='hs-comment'>--      a) eta reduction, if that gives a trivial expression</span>
<a name="line-1572"></a><span class='hs-comment'>--      b) eta expansion [only if there are some value lambdas]</span>
<a name="line-1573"></a>
<a name="line-1574"></a><span class='hs-definition'>mkLam</span> <span class='hs-sel'>_env</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>body</span> <span class='hs-sel'>_cont</span>
<a name="line-1575"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>body</span>
<a name="line-1576"></a><span class='hs-definition'>mkLam</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1577"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-1578"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-layout'>}</span>
<a name="line-1579"></a>  <span class='hs-keyword'>where</span>
<a name="line-1580"></a>    <span class='hs-varid'>mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span>
<a name="line-1581"></a>
<a name="line-1582"></a>    <span class='hs-varid'>mkLam'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>OutExpr</span>
<a name="line-1583"></a>    <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1584"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>bndrs1</span><span class='hs-layout'>)</span> <span class='hs-varid'>body1</span>
<a name="line-1585"></a>      <span class='hs-keyword'>where</span>
<a name="line-1586"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>bndrs1</span><span class='hs-layout'>,</span> <span class='hs-varid'>body1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectBinders</span> <span class='hs-varid'>body</span>
<a name="line-1587"></a>
<a name="line-1588"></a>    <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-1589"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tickishFloatable</span> <span class='hs-varid'>t</span>
<a name="line-1590"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTick</span> <span class='hs-varid'>t</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>expr</span>
<a name="line-1591"></a>
<a name="line-1592"></a>    <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>body</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1593"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-comment'>-- Note [Casts and lambdas]</span>
<a name="line-1594"></a>        <span class='hs-varid'>sm_cast_swizzle</span> <span class='hs-varid'>mode</span>
<a name="line-1595"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>any</span> <span class='hs-varid'>bad</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span>
<a name="line-1596"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>lam</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span>
<a name="line-1597"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCast</span> <span class='hs-varid'>lam</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkPiCos</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1598"></a>      <span class='hs-keyword'>where</span>
<a name="line-1599"></a>        <span class='hs-varid'>co_vars</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoVarsOfCo</span> <span class='hs-varid'>co</span>
<a name="line-1600"></a>        <span class='hs-varid'>bad</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isCoVar</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>co_vars</span>
<a name="line-1601"></a>
<a name="line-1602"></a>    <span class='hs-varid'>mkLam'</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span>
<a name="line-1603"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_DoEtaReduction</span> <span class='hs-varid'>dflags</span>
<a name="line-1604"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>etad_lam</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-comment'>{-# SCC "tryee" #-}</span> <span class='hs-varid'>tryEtaReduce</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span>
<a name="line-1605"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>EtaReduction</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1606"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>etad_lam</span> <span class='hs-layout'>}</span>
<a name="line-1607"></a>
<a name="line-1608"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>contIsRhs</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- See Note [Eta-expanding lambdas]</span>
<a name="line-1609"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sm_eta_expand</span> <span class='hs-varid'>mode</span>
<a name="line-1610"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>any</span> <span class='hs-varid'>isRuntimeVar</span> <span class='hs-varid'>bndrs</span>
<a name="line-1611"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>body_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "eta" #-}</span> <span class='hs-varid'>exprEtaExpandArity</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>body</span>
<a name="line-1612"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>expandableArityType</span> <span class='hs-varid'>body_arity</span>
<a name="line-1613"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>EtaExpansion</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1614"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "eta3" #-}</span>
<a name="line-1615"></a>                       <span class='hs-varid'>mkLams</span> <span class='hs-varid'>bndrs</span> <span class='hs-varop'>$</span>
<a name="line-1616"></a>                       <span class='hs-varid'>etaExpandAT</span> <span class='hs-varid'>body_arity</span> <span class='hs-varid'>body</span>
<a name="line-1617"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>traceSmpl</span> <span class='hs-str'>"eta expand"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"before"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLams</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1618"></a>                                          <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"after"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>res</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1619"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>res</span> <span class='hs-layout'>}</span>
<a name="line-1620"></a>
<a name="line-1621"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1622"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLams</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1623"></a>
<a name="line-1624"></a><span class='hs-comment'>{-
<a name="line-1625"></a>Note [Eta expanding lambdas]
<a name="line-1626"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1627"></a>In general we *do* want to eta-expand lambdas. Consider
<a name="line-1628"></a>   f (\x -&gt; case x of (a,b) -&gt; \s -&gt; blah)
<a name="line-1629"></a>where 's' is a state token, and hence can be eta expanded.  This
<a name="line-1630"></a>showed up in the code for GHc.IO.Handle.Text.hPutChar, a rather
<a name="line-1631"></a>important function!
<a name="line-1632"></a>
<a name="line-1633"></a>The eta-expansion will never happen unless we do it now.  (Well, it's
<a name="line-1634"></a>possible that CorePrep will do it, but CorePrep only has a half-baked
<a name="line-1635"></a>eta-expander that can't deal with casts.  So it's much better to do it
<a name="line-1636"></a>here.)
<a name="line-1637"></a>
<a name="line-1638"></a>However, when the lambda is let-bound, as the RHS of a let, we have a
<a name="line-1639"></a>better eta-expander (in the form of tryEtaExpandRhs), so we don't
<a name="line-1640"></a>bother to try expansion in mkLam in that case; hence the contIsRhs
<a name="line-1641"></a>guard.
<a name="line-1642"></a>
<a name="line-1643"></a>NB: We check the SimplEnv (sm_eta_expand), not DynFlags.
<a name="line-1644"></a>    See Note [Eta-expansion in stable unfoldings]
<a name="line-1645"></a>
<a name="line-1646"></a>Note [Casts and lambdas]
<a name="line-1647"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1648"></a>Consider
<a name="line-1649"></a>        (\x. (\y. e) `cast` g1) `cast` g2
<a name="line-1650"></a>There is a danger here that the two lambdas look separated, and the
<a name="line-1651"></a>full laziness pass might float an expression to between the two.
<a name="line-1652"></a>
<a name="line-1653"></a>So this equation in mkLam' floats the g1 out, thus:
<a name="line-1654"></a>        (\x. e `cast` g1)  --&gt;  (\x.e) `cast` (tx -&gt; g1)
<a name="line-1655"></a>where x:tx.
<a name="line-1656"></a>
<a name="line-1657"></a>In general, this floats casts outside lambdas, where (I hope) they
<a name="line-1658"></a>might meet and cancel with some other cast:
<a name="line-1659"></a>        \x. e `cast` co   ===&gt;   (\x. e) `cast` (tx -&gt; co)
<a name="line-1660"></a>        /\a. e `cast` co  ===&gt;   (/\a. e) `cast` (/\a. co)
<a name="line-1661"></a>        /\g. e `cast` co  ===&gt;   (/\g. e) `cast` (/\g. co)
<a name="line-1662"></a>                          (if not (g `in` co))
<a name="line-1663"></a>
<a name="line-1664"></a>We call this "cast swizzling". It is controlled by sm_cast_swizzle.
<a name="line-1665"></a>See also Note [Cast swizzling on rule LHSs]
<a name="line-1666"></a>
<a name="line-1667"></a>Wrinkles
<a name="line-1668"></a>
<a name="line-1669"></a>* Notice that it works regardless of 'e'.  Originally it worked only
<a name="line-1670"></a>  if 'e' was itself a lambda, but in some cases that resulted in
<a name="line-1671"></a>  fruitless iteration in the simplifier.  A good example was when
<a name="line-1672"></a>  compiling Text.ParserCombinators.ReadPrec, where we had a definition
<a name="line-1673"></a>  like    (\x. Get `cast` g)
<a name="line-1674"></a>  where Get is a constructor with nonzero arity.  Then mkLam eta-expanded
<a name="line-1675"></a>  the Get, and the next iteration eta-reduced it, and then eta-expanded
<a name="line-1676"></a>  it again.
<a name="line-1677"></a>
<a name="line-1678"></a>* Note also the side condition for the case of coercion binders, namely
<a name="line-1679"></a>  not (any bad bndrs).  It does not make sense to transform
<a name="line-1680"></a>          /\g. e `cast` g  ==&gt;  (/\g.e) `cast` (/\g.g)
<a name="line-1681"></a>  because the latter is not well-kinded.
<a name="line-1682"></a>
<a name="line-1683"></a>
<a name="line-1684"></a>************************************************************************
<a name="line-1685"></a>*                                                                      *
<a name="line-1686"></a>              Eta expansion
<a name="line-1687"></a>*                                                                      *
<a name="line-1688"></a>************************************************************************
<a name="line-1689"></a>-}</span>
<a name="line-1690"></a>
<a name="line-1691"></a><a name="tryEtaExpandRhs"></a><span class='hs-definition'>tryEtaExpandRhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>
<a name="line-1692"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>ArityType</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1693"></a><span class='hs-comment'>-- See Note [Eta-expanding at let bindings]</span>
<a name="line-1694"></a><span class='hs-comment'>-- If tryEtaExpandRhs rhs = (n, is_bot, rhs') then</span>
<a name="line-1695"></a><span class='hs-comment'>--   (a) rhs' has manifest arity n</span>
<a name="line-1696"></a><span class='hs-comment'>--   (b) if is_bot is True then rhs' applied to n args is guaranteed bottom</span>
<a name="line-1697"></a><span class='hs-definition'>tryEtaExpandRhs</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span>
<a name="line-1698"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>join_arity</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isJoinId_maybe</span> <span class='hs-varid'>bndr</span>
<a name="line-1699"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>join_bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>join_body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectNBinders</span> <span class='hs-varid'>join_arity</span> <span class='hs-varid'>rhs</span>
<a name="line-1700"></a>             <span class='hs-varid'>oss</span>   <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>idOneShotInfo</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>join_bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>id</span><span class='hs-keyglyph'>]</span>
<a name="line-1701"></a>             <span class='hs-varid'>arity_type</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsDeadEnd</span> <span class='hs-varid'>join_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkBotArityType</span> <span class='hs-varid'>oss</span>
<a name="line-1702"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTopArityType</span> <span class='hs-varid'>oss</span>
<a name="line-1703"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>arity_type</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1704"></a>         <span class='hs-comment'>-- Note [Do not eta-expand join points]</span>
<a name="line-1705"></a>         <span class='hs-comment'>-- But do return the correct arity and bottom-ness, because</span>
<a name="line-1706"></a>         <span class='hs-comment'>-- these are used to set the bndr's IdInfo (#15517)</span>
<a name="line-1707"></a>         <span class='hs-comment'>-- Note [Invariants on join points] invariant 2b, in GHC.Core</span>
<a name="line-1708"></a>
<a name="line-1709"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sm_eta_expand</span> <span class='hs-varid'>mode</span>      <span class='hs-comment'>-- Provided eta-expansion is on</span>
<a name="line-1710"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>new_arity</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>old_arity</span>   <span class='hs-comment'>-- And the current manifest arity isn't enough</span>
<a name="line-1711"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>want_eta</span> <span class='hs-varid'>rhs</span>
<a name="line-1712"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>EtaExpansion</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-1713"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>arity_type</span><span class='hs-layout'>,</span> <span class='hs-varid'>etaExpandAT</span> <span class='hs-varid'>arity_type</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1714"></a>
<a name="line-1715"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1716"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>arity_type</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1717"></a>
<a name="line-1718"></a>  <span class='hs-keyword'>where</span>
<a name="line-1719"></a>    <span class='hs-varid'>dflags</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sm_dflags</span> <span class='hs-varid'>mode</span>
<a name="line-1720"></a>    <span class='hs-varid'>old_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprArity</span> <span class='hs-varid'>rhs</span>
<a name="line-1721"></a>
<a name="line-1722"></a>    <span class='hs-varid'>arity_type</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findRhsArity</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>old_arity</span>
<a name="line-1723"></a>                 <span class='hs-varop'>`maxWithArity`</span> <span class='hs-varid'>idCallArity</span> <span class='hs-varid'>bndr</span>
<a name="line-1724"></a>    <span class='hs-varid'>new_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arityTypeArity</span> <span class='hs-varid'>arity_type</span>
<a name="line-1725"></a>
<a name="line-1726"></a>    <span class='hs-comment'>-- See Note [Which RHSs do we eta-expand?]</span>
<a name="line-1727"></a>    <span class='hs-varid'>want_eta</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>want_eta</span> <span class='hs-varid'>e</span>
<a name="line-1728"></a>    <span class='hs-varid'>want_eta</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>want_eta</span> <span class='hs-varid'>e</span>
<a name="line-1729"></a>    <span class='hs-varid'>want_eta</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>b</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>want_eta</span> <span class='hs-varid'>e</span>
<a name="line-1730"></a>    <span class='hs-varid'>want_eta</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>e</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>want_eta</span> <span class='hs-varid'>e</span>
<a name="line-1731"></a>    <span class='hs-varid'>want_eta</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>                    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1732"></a>    <span class='hs-varid'>want_eta</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>                    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1733"></a>    <span class='hs-varid'>want_eta</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1734"></a><span class='hs-comment'>{-
<a name="line-1735"></a>    want_eta _ = case arity_type of
<a name="line-1736"></a>                   ATop (os:_) -&gt; isOneShotInfo os
<a name="line-1737"></a>                   ATop []     -&gt; False
<a name="line-1738"></a>                   ABot {}     -&gt; True
<a name="line-1739"></a>-}</span>
<a name="line-1740"></a>
<a name="line-1741"></a><span class='hs-comment'>{-
<a name="line-1742"></a>Note [Eta-expanding at let bindings]
<a name="line-1743"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1744"></a>We now eta expand at let-bindings, which is where the payoff comes.
<a name="line-1745"></a>The most significant thing is that we can do a simple arity analysis
<a name="line-1746"></a>(in GHC.Core.Opt.Arity.findRhsArity), which we can't do for free-floating lambdas
<a name="line-1747"></a>
<a name="line-1748"></a>One useful consequence of not eta-expanding lambdas is this example:
<a name="line-1749"></a>   genMap :: C a =&gt; ...
<a name="line-1750"></a>   {-# INLINE genMap #-}
<a name="line-1751"></a>   genMap f xs = ...
<a name="line-1752"></a>
<a name="line-1753"></a>   myMap :: D a =&gt; ...
<a name="line-1754"></a>   {-# INLINE myMap #-}
<a name="line-1755"></a>   myMap = genMap
<a name="line-1756"></a>
<a name="line-1757"></a>Notice that 'genMap' should only inline if applied to two arguments.
<a name="line-1758"></a>In the stable unfolding for myMap we'll have the unfolding
<a name="line-1759"></a>    (\d -&gt; genMap Int (..d..))
<a name="line-1760"></a>We do not want to eta-expand to
<a name="line-1761"></a>    (\d f xs -&gt; genMap Int (..d..) f xs)
<a name="line-1762"></a>because then 'genMap' will inline, and it really shouldn't: at least
<a name="line-1763"></a>as far as the programmer is concerned, it's not applied to two
<a name="line-1764"></a>arguments!
<a name="line-1765"></a>
<a name="line-1766"></a>Note [Which RHSs do we eta-expand?]
<a name="line-1767"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1768"></a>We don't eta-expand:
<a name="line-1769"></a>
<a name="line-1770"></a>* Trivial RHSs, e.g.     f = g
<a name="line-1771"></a>  If we eta expand do
<a name="line-1772"></a>    f = \x. g x
<a name="line-1773"></a>  we'll just eta-reduce again, and so on; so the
<a name="line-1774"></a>  simplifier never terminates.
<a name="line-1775"></a>
<a name="line-1776"></a>* PAPs: see Note [Do not eta-expand PAPs]
<a name="line-1777"></a>
<a name="line-1778"></a>What about things like this?
<a name="line-1779"></a>   f = case y of p -&gt; \x -&gt; blah
<a name="line-1780"></a>
<a name="line-1781"></a>Here we do eta-expand.  This is a change (Jun 20), but if we have
<a name="line-1782"></a>really decided that f has arity 1, then putting that lambda at the top
<a name="line-1783"></a>seems like a Good idea.
<a name="line-1784"></a>
<a name="line-1785"></a>Note [Do not eta-expand PAPs]
<a name="line-1786"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1787"></a>We used to have old_arity = manifestArity rhs, which meant that we
<a name="line-1788"></a>would eta-expand even PAPs.  But this gives no particular advantage,
<a name="line-1789"></a>and can lead to a massive blow-up in code size, exhibited by #9020.
<a name="line-1790"></a>Suppose we have a PAP
<a name="line-1791"></a>    foo :: IO ()
<a name="line-1792"></a>    foo = returnIO ()
<a name="line-1793"></a>Then we can eta-expand do
<a name="line-1794"></a>    foo = (\eta. (returnIO () |&gt; sym g) eta) |&gt; g
<a name="line-1795"></a>where
<a name="line-1796"></a>    g :: IO () ~ State# RealWorld -&gt; (# State# RealWorld, () #)
<a name="line-1797"></a>
<a name="line-1798"></a>But there is really no point in doing this, and it generates masses of
<a name="line-1799"></a>coercions and whatnot that eventually disappear again. For T9020, GHC
<a name="line-1800"></a>allocated 6.6G before, and 0.8G afterwards; and residency dropped from
<a name="line-1801"></a>1.8G to 45M.
<a name="line-1802"></a>
<a name="line-1803"></a>Moreover, if we eta expand
<a name="line-1804"></a>        f = g d  ==&gt;  f = \x. g d x
<a name="line-1805"></a>that might in turn make g inline (if it has an inline pragma), which
<a name="line-1806"></a>we might not want.  After all, INLINE pragmas say "inline only when
<a name="line-1807"></a>saturated" so we don't want to be too gung-ho about saturating!
<a name="line-1808"></a>
<a name="line-1809"></a>But note that this won't eta-expand, say
<a name="line-1810"></a>  f = \g -&gt; map g
<a name="line-1811"></a>Does it matter not eta-expanding such functions?  I'm not sure.  Perhaps
<a name="line-1812"></a>strictness analysis will have less to bite on?
<a name="line-1813"></a>
<a name="line-1814"></a>Note [Do not eta-expand join points]
<a name="line-1815"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1816"></a>Similarly to CPR (see Note [Don't w/w join points for CPR] in
<a name="line-1817"></a>GHC.Core.Opt.WorkWrap), a join point stands well to gain from its outer binding's
<a name="line-1818"></a>eta-expansion, and eta-expanding a join point is fraught with issues like how to
<a name="line-1819"></a>deal with a cast:
<a name="line-1820"></a>
<a name="line-1821"></a>    let join $j1 :: IO ()
<a name="line-1822"></a>             $j1 = ...
<a name="line-1823"></a>             $j2 :: Int -&gt; IO ()
<a name="line-1824"></a>             $j2 n = if n &gt; 0 then $j1
<a name="line-1825"></a>                              else ...
<a name="line-1826"></a>
<a name="line-1827"></a>    =&gt;
<a name="line-1828"></a>
<a name="line-1829"></a>    let join $j1 :: IO ()
<a name="line-1830"></a>             $j1 = (\eta -&gt; ...)
<a name="line-1831"></a>                     `cast` N:IO :: State# RealWorld -&gt; (# State# RealWorld, ())
<a name="line-1832"></a>                                 ~  IO ()
<a name="line-1833"></a>             $j2 :: Int -&gt; IO ()
<a name="line-1834"></a>             $j2 n = (\eta -&gt; if n &gt; 0 then $j1
<a name="line-1835"></a>                                       else ...)
<a name="line-1836"></a>                     `cast` N:IO :: State# RealWorld -&gt; (# State# RealWorld, ())
<a name="line-1837"></a>                                 ~  IO ()
<a name="line-1838"></a>
<a name="line-1839"></a>The cast here can't be pushed inside the lambda (since it's not casting to a
<a name="line-1840"></a>function type), so the lambda has to stay, but it can't because it contains a
<a name="line-1841"></a>reference to a join point. In fact, $j2 can't be eta-expanded at all. Rather
<a name="line-1842"></a>than try and detect this situation (and whatever other situations crop up!), we
<a name="line-1843"></a>don't bother; again, any surrounding eta-expansion will improve these join
<a name="line-1844"></a>points anyway, since an outer cast can *always* be pushed inside. By the time
<a name="line-1845"></a>CorePrep comes around, the code is very likely to look more like this:
<a name="line-1846"></a>
<a name="line-1847"></a>    let join $j1 :: State# RealWorld -&gt; (# State# RealWorld, ())
<a name="line-1848"></a>             $j1 = (...) eta
<a name="line-1849"></a>             $j2 :: Int -&gt; State# RealWorld -&gt; (# State# RealWorld, ())
<a name="line-1850"></a>             $j2 = if n &gt; 0 then $j1
<a name="line-1851"></a>                            else (...) eta
<a name="line-1852"></a>
<a name="line-1853"></a>
<a name="line-1854"></a>************************************************************************
<a name="line-1855"></a>*                                                                      *
<a name="line-1856"></a>\subsection{Floating lets out of big lambdas}
<a name="line-1857"></a>*                                                                      *
<a name="line-1858"></a>************************************************************************
<a name="line-1859"></a>
<a name="line-1860"></a>Note [Floating and type abstraction]
<a name="line-1861"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1862"></a>Consider this:
<a name="line-1863"></a>        x = /\a. C e1 e2
<a name="line-1864"></a>We'd like to float this to
<a name="line-1865"></a>        y1 = /\a. e1
<a name="line-1866"></a>        y2 = /\a. e2
<a name="line-1867"></a>        x  = /\a. C (y1 a) (y2 a)
<a name="line-1868"></a>for the usual reasons: we want to inline x rather vigorously.
<a name="line-1869"></a>
<a name="line-1870"></a>You may think that this kind of thing is rare.  But in some programs it is
<a name="line-1871"></a>common.  For example, if you do closure conversion you might get:
<a name="line-1872"></a>
<a name="line-1873"></a>        data a :-&gt; b = forall e. (e -&gt; a -&gt; b) :$ e
<a name="line-1874"></a>
<a name="line-1875"></a>        f_cc :: forall a. a :-&gt; a
<a name="line-1876"></a>        f_cc = /\a. (\e. id a) :$ ()
<a name="line-1877"></a>
<a name="line-1878"></a>Now we really want to inline that f_cc thing so that the
<a name="line-1879"></a>construction of the closure goes away.
<a name="line-1880"></a>
<a name="line-1881"></a>So I have elaborated simplLazyBind to understand right-hand sides that look
<a name="line-1882"></a>like
<a name="line-1883"></a>        /\ a1..an. body
<a name="line-1884"></a>
<a name="line-1885"></a>and treat them specially. The real work is done in
<a name="line-1886"></a>GHC.Core.Opt.Simplify.Utils.abstractFloats, but there is quite a bit of plumbing
<a name="line-1887"></a>in simplLazyBind as well.
<a name="line-1888"></a>
<a name="line-1889"></a>The same transformation is good when there are lets in the body:
<a name="line-1890"></a>
<a name="line-1891"></a>        /\abc -&gt; let(rec) x = e in b
<a name="line-1892"></a>   ==&gt;
<a name="line-1893"></a>        let(rec) x' = /\abc -&gt; let x = x' a b c in e
<a name="line-1894"></a>        in
<a name="line-1895"></a>        /\abc -&gt; let x = x' a b c in b
<a name="line-1896"></a>
<a name="line-1897"></a>This is good because it can turn things like:
<a name="line-1898"></a>
<a name="line-1899"></a>        let f = /\a -&gt; letrec g = ... g ... in g
<a name="line-1900"></a>into
<a name="line-1901"></a>        letrec g' = /\a -&gt; ... g' a ...
<a name="line-1902"></a>        in
<a name="line-1903"></a>        let f = /\ a -&gt; g' a
<a name="line-1904"></a>
<a name="line-1905"></a>which is better.  In effect, it means that big lambdas don't impede
<a name="line-1906"></a>let-floating.
<a name="line-1907"></a>
<a name="line-1908"></a>This optimisation is CRUCIAL in eliminating the junk introduced by
<a name="line-1909"></a>desugaring mutually recursive definitions.  Don't eliminate it lightly!
<a name="line-1910"></a>
<a name="line-1911"></a>[May 1999]  If we do this transformation *regardless* then we can
<a name="line-1912"></a>end up with some pretty silly stuff.  For example,
<a name="line-1913"></a>
<a name="line-1914"></a>        let
<a name="line-1915"></a>            st = /\ s -&gt; let { x1=r1 ; x2=r2 } in ...
<a name="line-1916"></a>        in ..
<a name="line-1917"></a>becomes
<a name="line-1918"></a>        let y1 = /\s -&gt; r1
<a name="line-1919"></a>            y2 = /\s -&gt; r2
<a name="line-1920"></a>            st = /\s -&gt; ...[y1 s/x1, y2 s/x2]
<a name="line-1921"></a>        in ..
<a name="line-1922"></a>
<a name="line-1923"></a>Unless the "..." is a WHNF there is really no point in doing this.
<a name="line-1924"></a>Indeed it can make things worse.  Suppose x1 is used strictly,
<a name="line-1925"></a>and is of the form
<a name="line-1926"></a>
<a name="line-1927"></a>        x1* = case f y of { (a,b) -&gt; e }
<a name="line-1928"></a>
<a name="line-1929"></a>If we abstract this wrt the tyvar we then can't do the case inline
<a name="line-1930"></a>as we would normally do.
<a name="line-1931"></a>
<a name="line-1932"></a>That's why the whole transformation is part of the same process that
<a name="line-1933"></a>floats let-bindings and constructor arguments out of RHSs.  In particular,
<a name="line-1934"></a>it is guarded by the doFloatFromRhs call in simplLazyBind.
<a name="line-1935"></a>
<a name="line-1936"></a>Note [Which type variables to abstract over]
<a name="line-1937"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1938"></a>Abstract only over the type variables free in the rhs wrt which the
<a name="line-1939"></a>new binding is abstracted.  Note that
<a name="line-1940"></a>
<a name="line-1941"></a>  * The naive approach of abstracting wrt the
<a name="line-1942"></a>    tyvars free in the Id's /type/ fails. Consider:
<a name="line-1943"></a>        /\ a b -&gt; let t :: (a,b) = (e1, e2)
<a name="line-1944"></a>                      x :: a     = fst t
<a name="line-1945"></a>                  in ...
<a name="line-1946"></a>    Here, b isn't free in x's type, but we must nevertheless
<a name="line-1947"></a>    abstract wrt b as well, because t's type mentions b.
<a name="line-1948"></a>    Since t is floated too, we'd end up with the bogus:
<a name="line-1949"></a>         poly_t = /\ a b -&gt; (e1, e2)
<a name="line-1950"></a>         poly_x = /\ a   -&gt; fst (poly_t a *b*)
<a name="line-1951"></a>
<a name="line-1952"></a>  * We must do closeOverKinds.  Example (#10934):
<a name="line-1953"></a>       f = /\k (f:k-&gt;*) (a:k). let t = AccFailure @ (f a) in ...
<a name="line-1954"></a>    Here we want to float 't', but we must remember to abstract over
<a name="line-1955"></a>    'k' as well, even though it is not explicitly mentioned in the RHS,
<a name="line-1956"></a>    otherwise we get
<a name="line-1957"></a>       t = /\ (f:k-&gt;*) (a:k). AccFailure @ (f a)
<a name="line-1958"></a>    which is obviously bogus.
<a name="line-1959"></a>-}</span>
<a name="line-1960"></a>
<a name="line-1961"></a><a name="abstractFloats"></a><span class='hs-definition'>abstractFloats</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplFloats</span>
<a name="line-1962"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>OutBind</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1963"></a><span class='hs-definition'>abstractFloats</span> <span class='hs-varid'>uf_opts</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>main_tvs</span> <span class='hs-varid'>floats</span> <span class='hs-varid'>body</span>
<a name="line-1964"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>notNull</span> <span class='hs-varid'>body_floats</span> <span class='hs-layout'>)</span>
<a name="line-1965"></a>    <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isNilOL</span> <span class='hs-layout'>(</span><span class='hs-varid'>sfJoinFloats</span> <span class='hs-varid'>floats</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1966"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>float_binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapAccumLM</span> <span class='hs-varid'>abstract</span> <span class='hs-varid'>empty_subst</span> <span class='hs-varid'>body_floats</span>
<a name="line-1967"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_binds</span><span class='hs-layout'>,</span> <span class='hs-conid'>GHC.Core.Subst.substExpr</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1968"></a>  <span class='hs-keyword'>where</span>
<a name="line-1969"></a>    <span class='hs-varid'>is_top_lvl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span>
<a name="line-1970"></a>    <span class='hs-varid'>main_tv_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>main_tvs</span>
<a name="line-1971"></a>    <span class='hs-varid'>body_floats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>letFloatBinds</span> <span class='hs-layout'>(</span><span class='hs-varid'>sfLetFloats</span> <span class='hs-varid'>floats</span><span class='hs-layout'>)</span>
<a name="line-1972"></a>    <span class='hs-varid'>empty_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GHC.Core.Subst.mkEmptySubst</span> <span class='hs-layout'>(</span><span class='hs-varid'>sfInScope</span> <span class='hs-varid'>floats</span><span class='hs-layout'>)</span>
<a name="line-1973"></a>
<a name="line-1974"></a>    <span class='hs-varid'>abstract</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GHC.Core.Subst.Subst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutBind</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>GHC.Core.Subst.Subst</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutBind</span><span class='hs-layout'>)</span>
<a name="line-1975"></a>    <span class='hs-varid'>abstract</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1976"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_id1</span><span class='hs-layout'>,</span> <span class='hs-varid'>poly_app</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mk_poly1</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varid'>id</span>
<a name="line-1977"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_id2</span><span class='hs-layout'>,</span> <span class='hs-varid'>poly_rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_poly2</span> <span class='hs-varid'>poly_id1</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varid'>rhs'</span>
<a name="line-1978"></a>                 <span class='hs-varop'>!</span><span class='hs-varid'>subst'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GHC.Core.Subst.extendIdSubst</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>id</span> <span class='hs-varid'>poly_app</span>
<a name="line-1979"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>poly_id2</span> <span class='hs-varid'>poly_rhs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1980"></a>      <span class='hs-keyword'>where</span>
<a name="line-1981"></a>        <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GHC.Core.Subst.substExpr</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>rhs</span>
<a name="line-1982"></a>
<a name="line-1983"></a>        <span class='hs-comment'>-- tvs_here: see Note [Which type variables to abstract over]</span>
<a name="line-1984"></a>        <span class='hs-varid'>tvs_here</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scopedSort</span> <span class='hs-varop'>$</span>
<a name="line-1985"></a>                   <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>main_tv_set</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1986"></a>                   <span class='hs-varid'>closeOverKindsList</span> <span class='hs-varop'>$</span>
<a name="line-1987"></a>                   <span class='hs-varid'>exprSomeFreeVarsList</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>rhs'</span>
<a name="line-1988"></a>
<a name="line-1989"></a>    <span class='hs-varid'>abstract</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>prs</span><span class='hs-layout'>)</span>
<a name="line-1990"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>poly_apps</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapAndUnzipM</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_poly1</span> <span class='hs-varid'>tvs_here</span><span class='hs-layout'>)</span> <span class='hs-varid'>ids</span>
<a name="line-1991"></a>            <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>subst'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GHC.Core.Subst.extendSubstList</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-varid'>ids</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>poly_apps</span><span class='hs-layout'>)</span>
<a name="line-1992"></a>                  <span class='hs-varid'>poly_pairs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mk_poly2</span> <span class='hs-varid'>poly_id</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varid'>rhs'</span>
<a name="line-1993"></a>                               <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>poly_ids</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>rhss</span>
<a name="line-1994"></a>                               <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GHC.Core.Subst.substExpr</span> <span class='hs-varid'>subst'</span> <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>]</span>
<a name="line-1995"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-conid'>Rec</span> <span class='hs-varid'>poly_pairs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1996"></a>       <span class='hs-keyword'>where</span>
<a name="line-1997"></a>         <span class='hs-layout'>(</span><span class='hs-varid'>ids</span><span class='hs-layout'>,</span><span class='hs-varid'>rhss</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip</span> <span class='hs-varid'>prs</span>
<a name="line-1998"></a>                <span class='hs-comment'>-- For a recursive group, it's a bit of a pain to work out the minimal</span>
<a name="line-1999"></a>                <span class='hs-comment'>-- set of tyvars over which to abstract:</span>
<a name="line-2000"></a>                <span class='hs-comment'>--      /\ a b c.  let x = ...a... in</span>
<a name="line-2001"></a>                <span class='hs-comment'>--                 letrec { p = ...x...q...</span>
<a name="line-2002"></a>                <span class='hs-comment'>--                          q = .....p...b... } in</span>
<a name="line-2003"></a>                <span class='hs-comment'>--                 ...</span>
<a name="line-2004"></a>                <span class='hs-comment'>-- Since 'x' is abstracted over 'a', the {p,q} group must be abstracted</span>
<a name="line-2005"></a>                <span class='hs-comment'>-- over 'a' (because x is replaced by (poly_x a)) as well as 'b'.</span>
<a name="line-2006"></a>                <span class='hs-comment'>-- Since it's a pain, we just use the whole set, which is always safe</span>
<a name="line-2007"></a>                <span class='hs-comment'>--</span>
<a name="line-2008"></a>                <span class='hs-comment'>-- If you ever want to be more selective, remember this bizarre case too:</span>
<a name="line-2009"></a>                <span class='hs-comment'>--      x::a = x</span>
<a name="line-2010"></a>                <span class='hs-comment'>-- Here, we must abstract 'x' over 'a'.</span>
<a name="line-2011"></a>         <span class='hs-varid'>tvs_here</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scopedSort</span> <span class='hs-varid'>main_tvs</span>
<a name="line-2012"></a>
<a name="line-2013"></a>    <span class='hs-varid'>mk_poly1</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-2014"></a>    <span class='hs-varid'>mk_poly1</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varid'>var</span>
<a name="line-2015"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uniq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-2016"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span>  <span class='hs-varid'>poly_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setNameUnique</span> <span class='hs-layout'>(</span><span class='hs-varid'>idName</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span> <span class='hs-varid'>uniq</span>      <span class='hs-comment'>-- Keep same name</span>
<a name="line-2017"></a>                  <span class='hs-varid'>poly_ty</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInfForAllTys</span> <span class='hs-varid'>tvs_here</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- But new type of course</span>
<a name="line-2018"></a>                  <span class='hs-varid'>poly_id</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>transferPolyIdInfo</span> <span class='hs-varid'>var</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varop'>$</span> <span class='hs-comment'>-- Note [transferPolyIdInfo] in GHC.Types.Id</span>
<a name="line-2019"></a>                              <span class='hs-varid'>mkLocalId</span> <span class='hs-varid'>poly_name</span> <span class='hs-layout'>(</span><span class='hs-varid'>idMult</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span> <span class='hs-varid'>poly_ty</span>
<a name="line-2020"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>poly_id</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTys</span> <span class='hs-varid'>tvs_here</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2021"></a>                <span class='hs-comment'>-- In the olden days, it was crucial to copy the occInfo of the original var,</span>
<a name="line-2022"></a>                <span class='hs-comment'>-- because we were looking at occurrence-analysed but as yet unsimplified code!</span>
<a name="line-2023"></a>                <span class='hs-comment'>-- In particular, we mustn't lose the loop breakers.  BUT NOW we are looking</span>
<a name="line-2024"></a>                <span class='hs-comment'>-- at already simplified code, so it doesn't matter</span>
<a name="line-2025"></a>                <span class='hs-comment'>--</span>
<a name="line-2026"></a>                <span class='hs-comment'>-- It's even right to retain single-occurrence or dead-var info:</span>
<a name="line-2027"></a>                <span class='hs-comment'>-- Suppose we started with  /\a -&gt; let x = E in B</span>
<a name="line-2028"></a>                <span class='hs-comment'>-- where x occurs once in B. Then we transform to:</span>
<a name="line-2029"></a>                <span class='hs-comment'>--      let x' = /\a -&gt; E in /\a -&gt; let x* = x' a in B</span>
<a name="line-2030"></a>                <span class='hs-comment'>-- where x* has an INLINE prag on it.  Now, once x* is inlined,</span>
<a name="line-2031"></a>                <span class='hs-comment'>-- the occurrences of x' will be just the occurrences originally</span>
<a name="line-2032"></a>                <span class='hs-comment'>-- pinned on x.</span>
<a name="line-2033"></a>
<a name="line-2034"></a>    <span class='hs-varid'>mk_poly2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-2035"></a>    <span class='hs-varid'>mk_poly2</span> <span class='hs-varid'>poly_id</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varid'>rhs</span>
<a name="line-2036"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_id</span> <span class='hs-varop'>`setIdUnfolding`</span> <span class='hs-varid'>unf</span><span class='hs-layout'>,</span> <span class='hs-varid'>poly_rhs</span><span class='hs-layout'>)</span>
<a name="line-2037"></a>      <span class='hs-keyword'>where</span>
<a name="line-2038"></a>        <span class='hs-varid'>poly_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>tvs_here</span> <span class='hs-varid'>rhs</span>
<a name="line-2039"></a>        <span class='hs-varid'>unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkUnfolding</span> <span class='hs-varid'>uf_opts</span> <span class='hs-conid'>InlineRhs</span> <span class='hs-varid'>is_top_lvl</span> <span class='hs-conid'>False</span> <span class='hs-varid'>poly_rhs</span>
<a name="line-2040"></a>
<a name="line-2041"></a>        <span class='hs-comment'>-- We want the unfolding.  Consider</span>
<a name="line-2042"></a>        <span class='hs-comment'>--      let</span>
<a name="line-2043"></a>        <span class='hs-comment'>--            x = /\a. let y = ... in Just y</span>
<a name="line-2044"></a>        <span class='hs-comment'>--      in body</span>
<a name="line-2045"></a>        <span class='hs-comment'>-- Then we float the y-binding out (via abstractFloats and addPolyBind)</span>
<a name="line-2046"></a>        <span class='hs-comment'>-- but 'x' may well then be inlined in 'body' in which case we'd like the</span>
<a name="line-2047"></a>        <span class='hs-comment'>-- opportunity to inline 'y' too.</span>
<a name="line-2048"></a>
<a name="line-2049"></a><span class='hs-comment'>{-
<a name="line-2050"></a>Note [Abstract over coercions]
<a name="line-2051"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2052"></a>If a coercion variable (g :: a ~ Int) is free in the RHS, then so is the
<a name="line-2053"></a>type variable a.  Rather than sort this mess out, we simply bale out and abstract
<a name="line-2054"></a>wrt all the type variables if any of them are coercion variables.
<a name="line-2055"></a>
<a name="line-2056"></a>
<a name="line-2057"></a>Historical note: if you use let-bindings instead of a substitution, beware of this:
<a name="line-2058"></a>
<a name="line-2059"></a>                -- Suppose we start with:
<a name="line-2060"></a>                --
<a name="line-2061"></a>                --      x = /\ a -&gt; let g = G in E
<a name="line-2062"></a>                --
<a name="line-2063"></a>                -- Then we'll float to get
<a name="line-2064"></a>                --
<a name="line-2065"></a>                --      x = let poly_g = /\ a -&gt; G
<a name="line-2066"></a>                --          in /\ a -&gt; let g = poly_g a in E
<a name="line-2067"></a>                --
<a name="line-2068"></a>                -- But now the occurrence analyser will see just one occurrence
<a name="line-2069"></a>                -- of poly_g, not inside a lambda, so the simplifier will
<a name="line-2070"></a>                -- PreInlineUnconditionally poly_g back into g!  Badk to square 1!
<a name="line-2071"></a>                -- (I used to think that the "don't inline lone occurrences" stuff
<a name="line-2072"></a>                --  would stop this happening, but since it's the *only* occurrence,
<a name="line-2073"></a>                --  PreInlineUnconditionally kicks in first!)
<a name="line-2074"></a>                --
<a name="line-2075"></a>                -- Solution: put an INLINE note on g's RHS, so that poly_g seems
<a name="line-2076"></a>                --           to appear many times.  (NB: mkInlineMe eliminates
<a name="line-2077"></a>                --           such notes on trivial RHSs, so do it manually.)
<a name="line-2078"></a>
<a name="line-2079"></a>************************************************************************
<a name="line-2080"></a>*                                                                      *
<a name="line-2081"></a>                prepareAlts
<a name="line-2082"></a>*                                                                      *
<a name="line-2083"></a>************************************************************************
<a name="line-2084"></a>
<a name="line-2085"></a>prepareAlts tries these things:
<a name="line-2086"></a>
<a name="line-2087"></a>1.  filterAlts: eliminate alternatives that cannot match, including
<a name="line-2088"></a>    the DEFAULT alternative.  Here "cannot match" includes knowledge
<a name="line-2089"></a>    from GADTs
<a name="line-2090"></a>
<a name="line-2091"></a>2.  refineDefaultAlt: if the DEFAULT alternative can match only one
<a name="line-2092"></a>    possible constructor, then make that constructor explicit.
<a name="line-2093"></a>    e.g.
<a name="line-2094"></a>        case e of x { DEFAULT -&gt; rhs }
<a name="line-2095"></a>     ===&gt;
<a name="line-2096"></a>        case e of x { (a,b) -&gt; rhs }
<a name="line-2097"></a>    where the type is a single constructor type.  This gives better code
<a name="line-2098"></a>    when rhs also scrutinises x or e.
<a name="line-2099"></a>    See CoreUtils Note [Refine DEFAULT case alternatives]
<a name="line-2100"></a>
<a name="line-2101"></a>3. combineIdenticalAlts: combine identical alternatives into a DEFAULT.
<a name="line-2102"></a>   See CoreUtils Note [Combine identical alternatives], which also
<a name="line-2103"></a>   says why we do this on InAlts not on OutAlts
<a name="line-2104"></a>
<a name="line-2105"></a>4. Returns a list of the constructors that cannot holds in the
<a name="line-2106"></a>   DEFAULT alternative (if there is one)
<a name="line-2107"></a>
<a name="line-2108"></a>It's a good idea to do this stuff before simplifying the alternatives, to
<a name="line-2109"></a>avoid simplifying alternatives we know can't happen, and to come up with
<a name="line-2110"></a>the list of constructors that are handled, to put into the IdInfo of the
<a name="line-2111"></a>case binder, for use when simplifying the alternatives.
<a name="line-2112"></a>
<a name="line-2113"></a>Eliminating the default alternative in (1) isn't so obvious, but it can
<a name="line-2114"></a>happen:
<a name="line-2115"></a>
<a name="line-2116"></a>data Colour = Red | Green | Blue
<a name="line-2117"></a>
<a name="line-2118"></a>f x = case x of
<a name="line-2119"></a>        Red -&gt; ..
<a name="line-2120"></a>        Green -&gt; ..
<a name="line-2121"></a>        DEFAULT -&gt; h x
<a name="line-2122"></a>
<a name="line-2123"></a>h y = case y of
<a name="line-2124"></a>        Blue -&gt; ..
<a name="line-2125"></a>        DEFAULT -&gt; [ case y of ... ]
<a name="line-2126"></a>
<a name="line-2127"></a>If we inline h into f, the default case of the inlined h can't happen.
<a name="line-2128"></a>If we don't notice this, we may end up filtering out *all* the cases
<a name="line-2129"></a>of the inner case y, which give us nowhere to go!
<a name="line-2130"></a>-}</span>
<a name="line-2131"></a>
<a name="line-2132"></a><a name="prepareAlts"></a><span class='hs-definition'>prepareAlts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InAlt</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>AltCon</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InAlt</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2133"></a><span class='hs-comment'>-- The returned alternatives can be empty, none are possible</span>
<a name="line-2134"></a><span class='hs-definition'>prepareAlts</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>alts</span>
<a name="line-2135"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>varType</span> <span class='hs-varid'>case_bndr'</span><span class='hs-layout'>)</span>
<a name="line-2136"></a>           <span class='hs-comment'>-- Case binder is needed just for its type. Note that as an</span>
<a name="line-2137"></a>           <span class='hs-comment'>--   OutId, it has maximum information; this is important.</span>
<a name="line-2138"></a>           <span class='hs-comment'>--   Test simpl013 is an example</span>
<a name="line-2139"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>us</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniquesM</span>
<a name="line-2140"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>idcs1</span><span class='hs-layout'>,</span> <span class='hs-varid'>alts1</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterAlts</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>imposs_cons</span> <span class='hs-varid'>alts</span>
<a name="line-2141"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>yes2</span><span class='hs-layout'>,</span>  <span class='hs-varid'>alts2</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>refineDefaultAlt</span> <span class='hs-varid'>us</span> <span class='hs-layout'>(</span><span class='hs-varid'>idMult</span> <span class='hs-varid'>case_bndr'</span><span class='hs-layout'>)</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>idcs1</span> <span class='hs-varid'>alts1</span>
<a name="line-2142"></a>               <span class='hs-comment'>-- the multiplicity on case_bndr's is the multiplicity of the</span>
<a name="line-2143"></a>               <span class='hs-comment'>-- case expression The newly introduced patterns in</span>
<a name="line-2144"></a>               <span class='hs-comment'>-- refineDefaultAlt must be scaled by this multiplicity</span>
<a name="line-2145"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>yes3</span><span class='hs-layout'>,</span> <span class='hs-varid'>idcs3</span><span class='hs-layout'>,</span> <span class='hs-varid'>alts3</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>combineIdenticalAlts</span> <span class='hs-varid'>idcs1</span> <span class='hs-varid'>alts2</span>
<a name="line-2146"></a>             <span class='hs-comment'>-- "idcs" stands for "impossible default data constructors"</span>
<a name="line-2147"></a>             <span class='hs-comment'>-- i.e. the constructors that can't match the default case</span>
<a name="line-2148"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-varid'>yes2</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>FillInCaseDefault</span> <span class='hs-varid'>case_bndr'</span><span class='hs-layout'>)</span>
<a name="line-2149"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-varid'>yes3</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>AltMerge</span> <span class='hs-varid'>case_bndr'</span><span class='hs-layout'>)</span>
<a name="line-2150"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>idcs3</span><span class='hs-layout'>,</span> <span class='hs-varid'>alts3</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2151"></a>
<a name="line-2152"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- Not a data type, so nothing interesting happens</span>
<a name="line-2153"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-2154"></a>  <span class='hs-keyword'>where</span>
<a name="line-2155"></a>    <span class='hs-varid'>imposs_cons</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>scrut</span> <span class='hs-keyword'>of</span>
<a name="line-2156"></a>                    <span class='hs-conid'>Var</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>otherCons</span> <span class='hs-layout'>(</span><span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-2157"></a>                    <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span>
<a name="line-2158"></a>
<a name="line-2159"></a>
<a name="line-2160"></a><span class='hs-comment'>{-
<a name="line-2161"></a>************************************************************************
<a name="line-2162"></a>*                                                                      *
<a name="line-2163"></a>                mkCase
<a name="line-2164"></a>*                                                                      *
<a name="line-2165"></a>************************************************************************
<a name="line-2166"></a>
<a name="line-2167"></a>mkCase tries these things
<a name="line-2168"></a>
<a name="line-2169"></a>* Note [Nerge nested cases]
<a name="line-2170"></a>* Note [Eliminate identity case]
<a name="line-2171"></a>* Note [Scrutinee constant folding]
<a name="line-2172"></a>
<a name="line-2173"></a>Note [Merge Nested Cases]
<a name="line-2174"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2175"></a>       case e of b {             ==&gt;   case e of b {
<a name="line-2176"></a>         p1 -&gt; rhs1                      p1 -&gt; rhs1
<a name="line-2177"></a>         ...                             ...
<a name="line-2178"></a>         pm -&gt; rhsm                      pm -&gt; rhsm
<a name="line-2179"></a>         _  -&gt; case b of b' {            pn -&gt; let b'=b in rhsn
<a name="line-2180"></a>                     pn -&gt; rhsn          ...
<a name="line-2181"></a>                     ...                 po -&gt; let b'=b in rhso
<a name="line-2182"></a>                     po -&gt; rhso          _  -&gt; let b'=b in rhsd
<a name="line-2183"></a>                     _  -&gt; rhsd
<a name="line-2184"></a>       }
<a name="line-2185"></a>
<a name="line-2186"></a>which merges two cases in one case when -- the default alternative of
<a name="line-2187"></a>the outer case scrutises the same variable as the outer case. This
<a name="line-2188"></a>transformation is called Case Merging.  It avoids that the same
<a name="line-2189"></a>variable is scrutinised multiple times.
<a name="line-2190"></a>
<a name="line-2191"></a>Note [Eliminate Identity Case]
<a name="line-2192"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2193"></a>        case e of               ===&gt; e
<a name="line-2194"></a>                True  -&gt; True;
<a name="line-2195"></a>                False -&gt; False
<a name="line-2196"></a>
<a name="line-2197"></a>and similar friends.
<a name="line-2198"></a>
<a name="line-2199"></a>Note [Scrutinee Constant Folding]
<a name="line-2200"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2201"></a>     case x op# k# of _ {  ===&gt; case x of _ {
<a name="line-2202"></a>        a1# -&gt; e1                  (a1# inv_op# k#) -&gt; e1
<a name="line-2203"></a>        a2# -&gt; e2                  (a2# inv_op# k#) -&gt; e2
<a name="line-2204"></a>        ...                        ...
<a name="line-2205"></a>        DEFAULT -&gt; ed              DEFAULT -&gt; ed
<a name="line-2206"></a>
<a name="line-2207"></a>     where (x op# k#) inv_op# k# == x
<a name="line-2208"></a>
<a name="line-2209"></a>And similarly for commuted arguments and for some unary operations.
<a name="line-2210"></a>
<a name="line-2211"></a>The purpose of this transformation is not only to avoid an arithmetic
<a name="line-2212"></a>operation at runtime but to allow other transformations to apply in cascade.
<a name="line-2213"></a>
<a name="line-2214"></a>Example with the "Merge Nested Cases" optimization (from #12877):
<a name="line-2215"></a>
<a name="line-2216"></a>      main = case t of t0
<a name="line-2217"></a>         0##     -&gt; ...
<a name="line-2218"></a>         DEFAULT -&gt; case t0 `minusWord#` 1## of t1
<a name="line-2219"></a>            0##     -&gt; ...
<a name="line-2220"></a>            DEFAULT -&gt; case t1 `minusWord#` 1## of t2
<a name="line-2221"></a>               0##     -&gt; ...
<a name="line-2222"></a>               DEFAULT -&gt; case t2 `minusWord#` 1## of _
<a name="line-2223"></a>                  0##     -&gt; ...
<a name="line-2224"></a>                  DEFAULT -&gt; ...
<a name="line-2225"></a>
<a name="line-2226"></a>  becomes:
<a name="line-2227"></a>
<a name="line-2228"></a>      main = case t of _
<a name="line-2229"></a>      0##     -&gt; ...
<a name="line-2230"></a>      1##     -&gt; ...
<a name="line-2231"></a>      2##     -&gt; ...
<a name="line-2232"></a>      3##     -&gt; ...
<a name="line-2233"></a>      DEFAULT -&gt; ...
<a name="line-2234"></a>
<a name="line-2235"></a>There are some wrinkles
<a name="line-2236"></a>
<a name="line-2237"></a>* Do not apply caseRules if there is just a single DEFAULT alternative
<a name="line-2238"></a>     case e +# 3# of b { DEFAULT -&gt; rhs }
<a name="line-2239"></a>  If we applied the transformation here we would (stupidly) get
<a name="line-2240"></a>     case a of b' { DEFAULT -&gt; let b = e +# 3# in rhs }
<a name="line-2241"></a>  and now the process may repeat, because that let will really
<a name="line-2242"></a>  be a case.
<a name="line-2243"></a>
<a name="line-2244"></a>* The type of the scrutinee might change.  E.g.
<a name="line-2245"></a>        case tagToEnum (x :: Int#) of (b::Bool)
<a name="line-2246"></a>          False -&gt; e1
<a name="line-2247"></a>          True -&gt; e2
<a name="line-2248"></a>  ==&gt;
<a name="line-2249"></a>        case x of (b'::Int#)
<a name="line-2250"></a>          DEFAULT -&gt; e1
<a name="line-2251"></a>          1#      -&gt; e2
<a name="line-2252"></a>
<a name="line-2253"></a>* The case binder may be used in the right hand sides, so we need
<a name="line-2254"></a>  to make a local binding for it, if it is alive.  e.g.
<a name="line-2255"></a>         case e +# 10# of b
<a name="line-2256"></a>           DEFAULT -&gt; blah...b...
<a name="line-2257"></a>           44#     -&gt; blah2...b...
<a name="line-2258"></a>  ===&gt;
<a name="line-2259"></a>         case e of b'
<a name="line-2260"></a>           DEFAULT -&gt; let b = b' +# 10# in blah...b...
<a name="line-2261"></a>           34#     -&gt; let b = 44# in blah2...b...
<a name="line-2262"></a>
<a name="line-2263"></a>  Note that in the non-DEFAULT cases we know what to bind 'b' to,
<a name="line-2264"></a>  whereas in the DEFAULT case we must reconstruct the original value.
<a name="line-2265"></a>  But NB: we use b'; we do not duplicate 'e'.
<a name="line-2266"></a>
<a name="line-2267"></a>* In dataToTag we might need to make up some fake binders;
<a name="line-2268"></a>  see Note [caseRules for dataToTag] in GHC.Core.Opt.ConstantFold
<a name="line-2269"></a>-}</span>
<a name="line-2270"></a>
<a name="line-2271"></a><a name="mkCase"></a><span class='hs-definition'>mkCase</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCase1</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCase2</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCase3</span>
<a name="line-2272"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-2273"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span>
<a name="line-2274"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutAlt</span><span class='hs-keyglyph'>]</span>               <span class='hs-comment'>-- Alternatives in standard (increasing) order</span>
<a name="line-2275"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>OutExpr</span>
<a name="line-2276"></a>
<a name="line-2277"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2278"></a><span class='hs-comment'>--      1. Merge Nested Cases</span>
<a name="line-2279"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2280"></a>
<a name="line-2281"></a><span class='hs-definition'>mkCase</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>outer_bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>deflt_rhs</span> <span class='hs-conop'>:</span> <span class='hs-varid'>outer_alts</span><span class='hs-layout'>)</span>
<a name="line-2282"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_CaseMerge</span> <span class='hs-varid'>dflags</span>
<a name="line-2283"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ticks</span><span class='hs-layout'>,</span> <span class='hs-conid'>Case</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>inner_scrut_var</span><span class='hs-layout'>)</span> <span class='hs-varid'>inner_bndr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>inner_alts</span><span class='hs-layout'>)</span>
<a name="line-2284"></a>       <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>stripTicksTop</span> <span class='hs-varid'>tickishFloatable</span> <span class='hs-varid'>deflt_rhs</span>
<a name="line-2285"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>inner_scrut_var</span> <span class='hs-varop'>==</span> <span class='hs-varid'>outer_bndr</span>
<a name="line-2286"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>CaseMerge</span> <span class='hs-varid'>outer_bndr</span><span class='hs-layout'>)</span>
<a name="line-2287"></a>
<a name="line-2288"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>wrap_alt</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>outer_bndr</span> <span class='hs-varop'>`notElem`</span> <span class='hs-varid'>args</span> <span class='hs-layout'>)</span>
<a name="line-2289"></a>                                            <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_rhs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2290"></a>                <span class='hs-comment'>-- Simplifier's no-shadowing invariant should ensure</span>
<a name="line-2291"></a>                <span class='hs-comment'>-- that outer_bndr is not shadowed by the inner patterns</span>
<a name="line-2292"></a>              <span class='hs-varid'>wrap_rhs</span> <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>inner_bndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>outer_bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span>
<a name="line-2293"></a>                <span class='hs-comment'>-- The let is OK even for unboxed binders,</span>
<a name="line-2294"></a>
<a name="line-2295"></a>              <span class='hs-varid'>wrapped_alts</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadBinder</span> <span class='hs-varid'>inner_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inner_alts</span>
<a name="line-2296"></a>                           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>wrap_alt</span> <span class='hs-varid'>inner_alts</span>
<a name="line-2297"></a>
<a name="line-2298"></a>              <span class='hs-varid'>merged_alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mergeAlts</span> <span class='hs-varid'>outer_alts</span> <span class='hs-varid'>wrapped_alts</span>
<a name="line-2299"></a>                <span class='hs-comment'>-- NB: mergeAlts gives priority to the left</span>
<a name="line-2300"></a>                <span class='hs-comment'>--      case x of</span>
<a name="line-2301"></a>                <span class='hs-comment'>--        A -&gt; e1</span>
<a name="line-2302"></a>                <span class='hs-comment'>--        DEFAULT -&gt; case x of</span>
<a name="line-2303"></a>                <span class='hs-comment'>--                      A -&gt; e2</span>
<a name="line-2304"></a>                <span class='hs-comment'>--                      B -&gt; e3</span>
<a name="line-2305"></a>                <span class='hs-comment'>-- When we merge, we must ensure that e1 takes</span>
<a name="line-2306"></a>                <span class='hs-comment'>-- precedence over e2 as the value for A!</span>
<a name="line-2307"></a>
<a name="line-2308"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>fmap</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTicks</span> <span class='hs-varid'>ticks</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2309"></a>          <span class='hs-varid'>mkCase1</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>outer_bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>merged_alts</span>
<a name="line-2310"></a>        <span class='hs-layout'>}</span>
<a name="line-2311"></a>        <span class='hs-comment'>-- Warning: don't call mkCase recursively!</span>
<a name="line-2312"></a>        <span class='hs-comment'>-- Firstly, there's no point, because inner alts have already had</span>
<a name="line-2313"></a>        <span class='hs-comment'>-- mkCase applied to them, so they won't have a case in their default</span>
<a name="line-2314"></a>        <span class='hs-comment'>-- Secondly, if you do, you get an infinite loop, because the bindCaseBndr</span>
<a name="line-2315"></a>        <span class='hs-comment'>-- in munge_rhs may put a case into the DEFAULT branch!</span>
<a name="line-2316"></a>
<a name="line-2317"></a><span class='hs-definition'>mkCase</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCase1</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span>
<a name="line-2318"></a>
<a name="line-2319"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2320"></a><span class='hs-comment'>--      2. Eliminate Identity Case</span>
<a name="line-2321"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2322"></a>
<a name="line-2323"></a><a name="mkCase1"></a><span class='hs-definition'>mkCase1</span> <span class='hs-sel'>_dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>alts</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>rhs1</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- Identity case</span>
<a name="line-2324"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>all</span> <span class='hs-varid'>identity_alt</span> <span class='hs-varid'>alts</span>
<a name="line-2325"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>CaseIdentity</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span>
<a name="line-2326"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTicks</span> <span class='hs-varid'>ticks</span> <span class='hs-varop'>$</span> <span class='hs-varid'>re_cast</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>rhs1</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2327"></a>  <span class='hs-keyword'>where</span>
<a name="line-2328"></a>    <span class='hs-varid'>ticks</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMap</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>stripTicksT</span> <span class='hs-varid'>tickishFloatable</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tail</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-2329"></a>    <span class='hs-varid'>identity_alt</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_eq</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span>
<a name="line-2330"></a>
<a name="line-2331"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span>        <span class='hs-comment'>-- See Note [RHS casts]</span>
<a name="line-2332"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>tyCoVarsOfCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>check_eq</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span>
<a name="line-2333"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>alt</span> <span class='hs-varid'>args</span>
<a name="line-2334"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tickishFloatable</span> <span class='hs-varid'>t</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>check_eq</span> <span class='hs-varid'>e</span> <span class='hs-varid'>alt</span> <span class='hs-varid'>args</span>
<a name="line-2335"></a>
<a name="line-2336"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-varid'>lit'</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lit</span> <span class='hs-varop'>==</span> <span class='hs-varid'>lit'</span>
<a name="line-2337"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-varid'>case_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-2338"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>   <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span>
<a name="line-2339"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>null</span> <span class='hs-varid'>args</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-varid'>dataConWorkId</span> <span class='hs-varid'>con</span>
<a name="line-2340"></a>                                             <span class='hs-comment'>-- Optimisation only</span>
<a name="line-2341"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-varid'>rhs</span>        <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cheapEqExpr'</span> <span class='hs-varid'>tickishFloatable</span> <span class='hs-varid'>rhs</span> <span class='hs-varop'>$</span>
<a name="line-2342"></a>                                             <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>con</span> <span class='hs-varid'>arg_tys</span> <span class='hs-varid'>args</span>
<a name="line-2343"></a>    <span class='hs-varid'>check_eq</span> <span class='hs-keyword'>_</span>          <span class='hs-keyword'>_</span>             <span class='hs-keyword'>_</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-2344"></a>
<a name="line-2345"></a>    <span class='hs-varid'>arg_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConAppArgs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span>
<a name="line-2346"></a>
<a name="line-2347"></a>        <span class='hs-comment'>-- Note [RHS casts]</span>
<a name="line-2348"></a>        <span class='hs-comment'>-- ~~~~~~~~~~~~~~~~</span>
<a name="line-2349"></a>        <span class='hs-comment'>-- We've seen this:</span>
<a name="line-2350"></a>        <span class='hs-comment'>--      case e of x { _ -&gt; x `cast` c }</span>
<a name="line-2351"></a>        <span class='hs-comment'>-- And we definitely want to eliminate this case, to give</span>
<a name="line-2352"></a>        <span class='hs-comment'>--      e `cast` c</span>
<a name="line-2353"></a>        <span class='hs-comment'>-- So we throw away the cast from the RHS, and reconstruct</span>
<a name="line-2354"></a>        <span class='hs-comment'>-- it at the other end.  All the RHS casts must be the same</span>
<a name="line-2355"></a>        <span class='hs-comment'>-- if (all identity_alt alts) holds.</span>
<a name="line-2356"></a>        <span class='hs-comment'>--</span>
<a name="line-2357"></a>        <span class='hs-comment'>-- Don't worry about nested casts, because the simplifier combines them</span>
<a name="line-2358"></a>
<a name="line-2359"></a>    <span class='hs-varid'>re_cast</span> <span class='hs-varid'>scrut</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Cast</span> <span class='hs-layout'>(</span><span class='hs-varid'>re_cast</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span>
<a name="line-2360"></a>    <span class='hs-varid'>re_cast</span> <span class='hs-varid'>scrut</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scrut</span>
<a name="line-2361"></a>
<a name="line-2362"></a><span class='hs-definition'>mkCase1</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCase2</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span>
<a name="line-2363"></a>
<a name="line-2364"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2365"></a><span class='hs-comment'>--      2. Scrutinee Constant Folding</span>
<a name="line-2366"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2367"></a>
<a name="line-2368"></a><a name="mkCase2"></a><span class='hs-definition'>mkCase2</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span>
<a name="line-2369"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-comment'>-- See Note [Scrutinee Constant Folding]</span>
<a name="line-2370"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>alts</span> <span class='hs-keyword'>of</span>  <span class='hs-comment'>-- Not if there is just a DEFAULT alternative</span>
<a name="line-2371"></a>      <span class='hs-keyglyph'>[</span><span class='hs-conid'>Alt</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-2372"></a>      <span class='hs-keyword'>_</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-2373"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_CaseFolding</span> <span class='hs-varid'>dflags</span>
<a name="line-2374"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>scrut'</span><span class='hs-layout'>,</span> <span class='hs-varid'>tx_con</span><span class='hs-layout'>,</span> <span class='hs-varid'>mk_orig</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>caseRules</span> <span class='hs-layout'>(</span><span class='hs-varid'>targetPlatform</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-varid'>scrut</span>
<a name="line-2375"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>bndr'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newId</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"lwild"</span><span class='hs-layout'>)</span> <span class='hs-conid'>Many</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>scrut'</span><span class='hs-layout'>)</span>
<a name="line-2376"></a>
<a name="line-2377"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>alts'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapMaybeM</span> <span class='hs-layout'>(</span><span class='hs-varid'>tx_alt</span> <span class='hs-varid'>tx_con</span> <span class='hs-varid'>mk_orig</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>)</span> <span class='hs-varid'>alts</span>
<a name="line-2378"></a>                  <span class='hs-comment'>-- mapMaybeM: discard unreachable alternatives</span>
<a name="line-2379"></a>                  <span class='hs-comment'>-- See Note [Unreachable caseRules alternatives]</span>
<a name="line-2380"></a>                  <span class='hs-comment'>-- in GHC.Core.Opt.ConstantFold</span>
<a name="line-2381"></a>
<a name="line-2382"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mkCase3</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>bndr'</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varop'>$</span>
<a name="line-2383"></a>         <span class='hs-varid'>add_default</span> <span class='hs-layout'>(</span><span class='hs-varid'>re_sort</span> <span class='hs-varid'>alts'</span><span class='hs-layout'>)</span>
<a name="line-2384"></a>       <span class='hs-layout'>}</span>
<a name="line-2385"></a>
<a name="line-2386"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2387"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCase3</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span>
<a name="line-2388"></a>  <span class='hs-keyword'>where</span>
<a name="line-2389"></a>    <span class='hs-comment'>-- We need to keep the correct association between the scrutinee and its</span>
<a name="line-2390"></a>    <span class='hs-comment'>-- binder if the latter isn't dead. Hence we wrap rhs of alternatives with</span>
<a name="line-2391"></a>    <span class='hs-comment'>-- "let bndr = ... in":</span>
<a name="line-2392"></a>    <span class='hs-comment'>--</span>
<a name="line-2393"></a>    <span class='hs-comment'>--     case v + 10 of y        =====&gt; case v of y</span>
<a name="line-2394"></a>    <span class='hs-comment'>--        20      -&gt; e1                 10      -&gt; let y = 20     in e1</span>
<a name="line-2395"></a>    <span class='hs-comment'>--        DEFAULT -&gt; e2                 DEFAULT -&gt; let y = v + 10 in e2</span>
<a name="line-2396"></a>    <span class='hs-comment'>--</span>
<a name="line-2397"></a>    <span class='hs-comment'>-- Other transformations give: =====&gt; case v of y'</span>
<a name="line-2398"></a>    <span class='hs-comment'>--                                      10      -&gt; let y = 20      in e1</span>
<a name="line-2399"></a>    <span class='hs-comment'>--                                      DEFAULT -&gt; let y = y' + 10 in e2</span>
<a name="line-2400"></a>    <span class='hs-comment'>--</span>
<a name="line-2401"></a>    <span class='hs-comment'>-- This wrapping is done in tx_alt; we use mk_orig, returned by caseRules,</span>
<a name="line-2402"></a>    <span class='hs-comment'>-- to construct an expression equivalent to the original one, for use</span>
<a name="line-2403"></a>    <span class='hs-comment'>-- in the DEFAULT case</span>
<a name="line-2404"></a>
<a name="line-2405"></a>    <span class='hs-varid'>tx_alt</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>AltCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>AltCon</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-2406"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreAlt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>CoreAlt</span><span class='hs-layout'>)</span>
<a name="line-2407"></a>    <span class='hs-varid'>tx_alt</span> <span class='hs-varid'>tx_con</span> <span class='hs-varid'>mk_orig</span> <span class='hs-varid'>new_bndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-2408"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>tx_con</span> <span class='hs-varid'>con</span> <span class='hs-keyword'>of</span>
<a name="line-2409"></a>          <span class='hs-conid'>Nothing</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span>
<a name="line-2410"></a>          <span class='hs-conid'>Just</span> <span class='hs-varid'>con'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>bs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mk_new_bndrs</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>con'</span>
<a name="line-2411"></a>                          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con'</span> <span class='hs-varid'>bs'</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2412"></a>      <span class='hs-keyword'>where</span>
<a name="line-2413"></a>        <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadBinder</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span>
<a name="line-2414"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bindNonRec</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>orig_val</span> <span class='hs-varid'>rhs</span>
<a name="line-2415"></a>
<a name="line-2416"></a>        <span class='hs-varid'>orig_val</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>con</span> <span class='hs-keyword'>of</span>
<a name="line-2417"></a>                      <span class='hs-conid'>DEFAULT</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mk_orig</span> <span class='hs-varid'>new_bndr</span>
<a name="line-2418"></a>                      <span class='hs-conid'>LitAlt</span> <span class='hs-varid'>l</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Lit</span> <span class='hs-varid'>l</span>
<a name="line-2419"></a>                      <span class='hs-conid'>DataAlt</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>dc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConAppArgs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>bs</span>
<a name="line-2420"></a>
<a name="line-2421"></a>    <span class='hs-varid'>mk_new_bndrs</span> <span class='hs-varid'>new_bndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span>
<a name="line-2422"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isNullaryRepDataCon</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span>
<a name="line-2423"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- For non-nullary data cons we must invent some fake binders</span>
<a name="line-2424"></a>        <span class='hs-comment'>-- See Note [caseRules for dataToTag] in GHC.Core.Opt.ConstantFold</span>
<a name="line-2425"></a>        <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>us</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniquesM</span>
<a name="line-2426"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>ex_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_ids</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepInstPat</span> <span class='hs-varid'>us</span> <span class='hs-layout'>(</span><span class='hs-varid'>idMult</span> <span class='hs-varid'>new_bndr</span><span class='hs-layout'>)</span> <span class='hs-varid'>dc</span>
<a name="line-2427"></a>                                        <span class='hs-layout'>(</span><span class='hs-varid'>tyConAppArgs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>new_bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2428"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ex_tvs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>arg_ids</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2429"></a>    <span class='hs-varid'>mk_new_bndrs</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>
<a name="line-2430"></a>
<a name="line-2431"></a>    <span class='hs-varid'>re_sort</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreAlt</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreAlt</span><span class='hs-keyglyph'>]</span>
<a name="line-2432"></a>    <span class='hs-comment'>-- Sort the alternatives to re-establish</span>
<a name="line-2433"></a>    <span class='hs-comment'>-- GHC.Core Note [Case expression invariants]</span>
<a name="line-2434"></a>    <span class='hs-varid'>re_sort</span> <span class='hs-varid'>alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sortBy</span> <span class='hs-varid'>cmpAlt</span> <span class='hs-varid'>alts</span>
<a name="line-2435"></a>
<a name="line-2436"></a>    <span class='hs-varid'>add_default</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreAlt</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreAlt</span><span class='hs-keyglyph'>]</span>
<a name="line-2437"></a>    <span class='hs-comment'>-- See Note [Literal cases]</span>
<a name="line-2438"></a>    <span class='hs-varid'>add_default</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span> <span class='hs-conop'>:</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Alt</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span> <span class='hs-conop'>:</span> <span class='hs-varid'>alts</span>
<a name="line-2439"></a>    <span class='hs-varid'>add_default</span> <span class='hs-varid'>alts</span>                            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alts</span>
<a name="line-2440"></a>
<a name="line-2441"></a><span class='hs-comment'>{- Note [Literal cases]
<a name="line-2442"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2443"></a>If we have
<a name="line-2444"></a>  case tagToEnum (a &gt;# b) of
<a name="line-2445"></a>     False -&gt; e1
<a name="line-2446"></a>     True  -&gt; e2
<a name="line-2447"></a>
<a name="line-2448"></a>then caseRules for TagToEnum will turn it into
<a name="line-2449"></a>  case tagToEnum (a &gt;# b) of
<a name="line-2450"></a>     0# -&gt; e1
<a name="line-2451"></a>     1# -&gt; e2
<a name="line-2452"></a>
<a name="line-2453"></a>Since the case is exhaustive (all cases are) we can convert it to
<a name="line-2454"></a>  case tagToEnum (a &gt;# b) of
<a name="line-2455"></a>     DEFAULT -&gt; e1
<a name="line-2456"></a>     1#      -&gt; e2
<a name="line-2457"></a>
<a name="line-2458"></a>This may generate sligthtly better code (although it should not, since
<a name="line-2459"></a>all cases are exhaustive) and/or optimise better.  I'm not certain that
<a name="line-2460"></a>it's necessary, but currently we do make this change.  We do it here,
<a name="line-2461"></a>NOT in the TagToEnum rules (see "Beware" in Note [caseRules for tagToEnum]
<a name="line-2462"></a>in GHC.Core.Opt.ConstantFold)
<a name="line-2463"></a>-}</span>
<a name="line-2464"></a>
<a name="line-2465"></a><a name="mkCase3"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2466"></a><span class='hs-comment'>--      Catch-all</span>
<a name="line-2467"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2468"></a><span class='hs-definition'>mkCase3</span> <span class='hs-sel'>_dflags</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span>
<a name="line-2469"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts_ty</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-2470"></a>
<a name="line-2471"></a><a name="isExitJoinId"></a><span class='hs-comment'>-- See Note [Exitification] and Note [Do not inline exit join points] in</span>
<a name="line-2472"></a><span class='hs-comment'>-- GHC.Core.Opt.Exitify</span>
<a name="line-2473"></a><span class='hs-comment'>-- This lives here (and not in Id) because occurrence info is only valid on</span>
<a name="line-2474"></a><span class='hs-comment'>-- InIds, so it's crucial that isExitJoinId is only called on freshly</span>
<a name="line-2475"></a><span class='hs-comment'>-- occ-analysed code. It's not a generic function you can call anywhere.</span>
<a name="line-2476"></a><span class='hs-definition'>isExitJoinId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2477"></a><span class='hs-definition'>isExitJoinId</span> <span class='hs-varid'>id</span>
<a name="line-2478"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isJoinId</span> <span class='hs-varid'>id</span>
<a name="line-2479"></a>  <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isOneOcc</span> <span class='hs-layout'>(</span><span class='hs-varid'>idOccInfo</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-2480"></a>  <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>occ_in_lam</span> <span class='hs-layout'>(</span><span class='hs-varid'>idOccInfo</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <span class='hs-conid'>IsInsideLam</span>
<a name="line-2481"></a>
<a name="line-2482"></a><span class='hs-comment'>{-
<a name="line-2483"></a>Note [Dead binders]
<a name="line-2484"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-2485"></a>Note that dead-ness is maintained by the simplifier, so that it is
<a name="line-2486"></a>accurate after simplification as well as before.
<a name="line-2487"></a>
<a name="line-2488"></a>
<a name="line-2489"></a>Note [Cascading case merge]
<a name="line-2490"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2491"></a>Case merging should cascade in one sweep, because it
<a name="line-2492"></a>happens bottom-up
<a name="line-2493"></a>
<a name="line-2494"></a>      case e of a {
<a name="line-2495"></a>        DEFAULT -&gt; case a of b
<a name="line-2496"></a>                      DEFAULT -&gt; case b of c {
<a name="line-2497"></a>                                     DEFAULT -&gt; e
<a name="line-2498"></a>                                     A -&gt; ea
<a name="line-2499"></a>                      B -&gt; eb
<a name="line-2500"></a>        C -&gt; ec
<a name="line-2501"></a>==&gt;
<a name="line-2502"></a>      case e of a {
<a name="line-2503"></a>        DEFAULT -&gt; case a of b
<a name="line-2504"></a>                      DEFAULT -&gt; let c = b in e
<a name="line-2505"></a>                      A -&gt; let c = b in ea
<a name="line-2506"></a>                      B -&gt; eb
<a name="line-2507"></a>        C -&gt; ec
<a name="line-2508"></a>==&gt;
<a name="line-2509"></a>      case e of a {
<a name="line-2510"></a>        DEFAULT -&gt; let b = a in let c = b in e
<a name="line-2511"></a>        A -&gt; let b = a in let c = b in ea
<a name="line-2512"></a>        B -&gt; let b = a in eb
<a name="line-2513"></a>        C -&gt; ec
<a name="line-2514"></a>
<a name="line-2515"></a>
<a name="line-2516"></a>However here's a tricky case that we still don't catch, and I don't
<a name="line-2517"></a>see how to catch it in one pass:
<a name="line-2518"></a>
<a name="line-2519"></a>  case x of c1 { I# a1 -&gt;
<a name="line-2520"></a>  case a1 of c2 -&gt;
<a name="line-2521"></a>    0 -&gt; ...
<a name="line-2522"></a>    DEFAULT -&gt; case x of c3 { I# a2 -&gt;
<a name="line-2523"></a>               case a2 of ...
<a name="line-2524"></a>
<a name="line-2525"></a>After occurrence analysis (and its binder-swap) we get this
<a name="line-2526"></a>
<a name="line-2527"></a>  case x of c1 { I# a1 -&gt;
<a name="line-2528"></a>  let x = c1 in         -- Binder-swap addition
<a name="line-2529"></a>  case a1 of c2 -&gt;
<a name="line-2530"></a>    0 -&gt; ...
<a name="line-2531"></a>    DEFAULT -&gt; case x of c3 { I# a2 -&gt;
<a name="line-2532"></a>               case a2 of ...
<a name="line-2533"></a>
<a name="line-2534"></a>When we simplify the inner case x, we'll see that
<a name="line-2535"></a>x=c1=I# a1.  So we'll bind a2 to a1, and get
<a name="line-2536"></a>
<a name="line-2537"></a>  case x of c1 { I# a1 -&gt;
<a name="line-2538"></a>  case a1 of c2 -&gt;
<a name="line-2539"></a>    0 -&gt; ...
<a name="line-2540"></a>    DEFAULT -&gt; case a1 of ...
<a name="line-2541"></a>
<a name="line-2542"></a>This is correct, but we can't do a case merge in this sweep
<a name="line-2543"></a>because c2 /= a1.  Reason: the binding c1=I# a1 went inwards
<a name="line-2544"></a>without getting changed to c1=I# c2.
<a name="line-2545"></a>
<a name="line-2546"></a>I don't think this is worth fixing, even if I knew how. It'll
<a name="line-2547"></a>all come out in the next pass anyway.
<a name="line-2548"></a>-}</span>
</pre></body>
</html>

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core/Opt/WorkWrap/Utils.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The GRASP/AQUA Project, Glasgow University, 1993-1998
<a name="line-3"></a>
<a name="line-4"></a>A library for the ``worker\/wrapper'' back-end to the strictness analyser
<a name="line-5"></a>-}</span>
<a name="line-6"></a>
<a name="line-7"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-8"></a>
<a name="line-9"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.Opt.WorkWrap.Utils</span>
<a name="line-10"></a>   <span class='hs-layout'>(</span> <span class='hs-varid'>mkWwBodies</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkWWstr</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkWorkerArgs</span>
<a name="line-11"></a>   <span class='hs-layout'>,</span> <span class='hs-conid'>DataConPatContext</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>UnboxingDecision</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>splitArgType_maybe</span><span class='hs-layout'>,</span> <span class='hs-varid'>wantToUnbox</span>
<a name="line-12"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>findTypeShape</span>
<a name="line-13"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>isWorkerSmallEnough</span>
<a name="line-14"></a>   <span class='hs-layout'>)</span>
<a name="line-15"></a><span class='hs-keyword'>where</span>
<a name="line-16"></a>
<a name="line-17"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-18"></a>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-20"></a>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Utils</span>   <span class='hs-layout'>(</span> <span class='hs-varid'>exprType</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCast</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkDefaultCase</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkSingleAltCase</span>
<a name="line-23"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>dataConRepFSInstPat</span> <span class='hs-layout'>)</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id.Info</span> <span class='hs-layout'>(</span> <span class='hs-conid'>JoinArity</span> <span class='hs-layout'>)</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.DataCon</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Demand</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Cpr</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Make</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>mkAbsentErrorApp</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCoreUbxTup</span>
<a name="line-30"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>mkCoreApp</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCoreLet</span> <span class='hs-layout'>)</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id.Make</span> <span class='hs-layout'>(</span> <span class='hs-varid'>voidArgId</span><span class='hs-layout'>,</span> <span class='hs-varid'>voidPrimId</span> <span class='hs-layout'>)</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Types</span>      <span class='hs-layout'>(</span> <span class='hs-varid'>tupleDataCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>unboxedUnitTy</span> <span class='hs-layout'>)</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Literal</span> <span class='hs-layout'>(</span> <span class='hs-varid'>absentLiteralOf</span><span class='hs-layout'>,</span> <span class='hs-varid'>rubbishLit</span> <span class='hs-layout'>)</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Env</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkInScopeSet</span> <span class='hs-layout'>)</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Set</span> <span class='hs-layout'>(</span> <span class='hs-conid'>VarSet</span> <span class='hs-layout'>)</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Multiplicity</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Predicate</span> <span class='hs-layout'>(</span> <span class='hs-varid'>isClassPred</span> <span class='hs-layout'>)</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.RepType</span>  <span class='hs-layout'>(</span> <span class='hs-varid'>isVoidTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>typePrimRep</span> <span class='hs-layout'>)</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FamInstEnv</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>       <span class='hs-layout'>(</span> <span class='hs-conid'>Boxity</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCon</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCon.RecWalk</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique.Supply</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span> <span class='hs-layout'>(</span> <span class='hs-varid'>getOccFS</span> <span class='hs-layout'>)</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Maybe</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Session</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Ppr</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.FastString</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.List.SetOps</span>
<a name="line-56"></a>
<a name="line-57"></a><span class='hs-comment'>{-
<a name="line-58"></a>************************************************************************
<a name="line-59"></a>*                                                                      *
<a name="line-60"></a>\subsection[mkWrapperAndWorker]{@mkWrapperAndWorker@}
<a name="line-61"></a>*                                                                      *
<a name="line-62"></a>************************************************************************
<a name="line-63"></a>
<a name="line-64"></a>Here's an example.  The original function is:
<a name="line-65"></a>
<a name="line-66"></a>\begin{verbatim}
<a name="line-67"></a>g :: forall a . Int -&gt; [a] -&gt; a
<a name="line-68"></a>
<a name="line-69"></a>g = \/\ a -&gt; \ x ys -&gt;
<a name="line-70"></a>        case x of
<a name="line-71"></a>          0 -&gt; head ys
<a name="line-72"></a>          _ -&gt; head (tail ys)
<a name="line-73"></a>\end{verbatim}
<a name="line-74"></a>
<a name="line-75"></a>From this, we want to produce:
<a name="line-76"></a>\begin{verbatim}
<a name="line-77"></a>-- wrapper (an unfolding)
<a name="line-78"></a>g :: forall a . Int -&gt; [a] -&gt; a
<a name="line-79"></a>
<a name="line-80"></a>g = \/\ a -&gt; \ x ys -&gt;
<a name="line-81"></a>        case x of
<a name="line-82"></a>          I# x# -&gt; $wg a x# ys
<a name="line-83"></a>            -- call the worker; don't forget the type args!
<a name="line-84"></a>
<a name="line-85"></a>-- worker
<a name="line-86"></a>$wg :: forall a . Int# -&gt; [a] -&gt; a
<a name="line-87"></a>
<a name="line-88"></a>$wg = \/\ a -&gt; \ x# ys -&gt;
<a name="line-89"></a>        let
<a name="line-90"></a>            x = I# x#
<a name="line-91"></a>        in
<a name="line-92"></a>            case x of               -- note: body of g moved intact
<a name="line-93"></a>              0 -&gt; head ys
<a name="line-94"></a>              _ -&gt; head (tail ys)
<a name="line-95"></a>\end{verbatim}
<a name="line-96"></a>
<a name="line-97"></a>Something we have to be careful about:  Here's an example:
<a name="line-98"></a>
<a name="line-99"></a>\begin{verbatim}
<a name="line-100"></a>-- "f" strictness: U(P)U(P)
<a name="line-101"></a>f (I# a) (I# b) = a +# b
<a name="line-102"></a>
<a name="line-103"></a>g = f   -- "g" strictness same as "f"
<a name="line-104"></a>\end{verbatim}
<a name="line-105"></a>
<a name="line-106"></a>\tr{f} will get a worker all nice and friendly-like; that's good.
<a name="line-107"></a>{\em But we don't want a worker for \tr{g}}, even though it has the
<a name="line-108"></a>same strictness as \tr{f}.  Doing so could break laziness, at best.
<a name="line-109"></a>
<a name="line-110"></a>Consequently, we insist that the number of strictness-info items is
<a name="line-111"></a>exactly the same as the number of lambda-bound arguments.  (This is
<a name="line-112"></a>probably slightly paranoid, but OK in practice.)  If it isn't the
<a name="line-113"></a>same, we ``revise'' the strictness info, so that we won't propagate
<a name="line-114"></a>the unusable strictness-info into the interfaces.
<a name="line-115"></a>
<a name="line-116"></a>
<a name="line-117"></a>************************************************************************
<a name="line-118"></a>*                                                                      *
<a name="line-119"></a>\subsection{The worker wrapper core}
<a name="line-120"></a>*                                                                      *
<a name="line-121"></a>************************************************************************
<a name="line-122"></a>
<a name="line-123"></a>@mkWwBodies@ is called when doing the worker\/wrapper split inside a module.
<a name="line-124"></a>-}</span>
<a name="line-125"></a>
<a name="line-126"></a><a name="WwResult"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>WwResult</span>
<a name="line-127"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>              <span class='hs-comment'>-- Demands for worker (value) args</span>
<a name="line-128"></a>     <span class='hs-conid'>JoinArity</span><span class='hs-layout'>,</span>             <span class='hs-comment'>-- Number of worker (type OR value) args</span>
<a name="line-129"></a>     <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Wrapper body, lacking only the worker Id</span>
<a name="line-130"></a>     <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Worker body, lacking the original function rhs</span>
<a name="line-131"></a>
<a name="line-132"></a><a name="mkWwBodies"></a><span class='hs-definition'>mkWwBodies</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-133"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-134"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span>         <span class='hs-comment'>-- Free vars of RHS</span>
<a name="line-135"></a>                             <span class='hs-comment'>-- See Note [Freshen WW arguments]</span>
<a name="line-136"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>             <span class='hs-comment'>-- The original function</span>
<a name="line-137"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Strictness of original function</span>
<a name="line-138"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cpr</span>            <span class='hs-comment'>-- Info about function result</span>
<a name="line-139"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>WwResult</span><span class='hs-layout'>)</span>
<a name="line-140"></a>
<a name="line-141"></a><span class='hs-comment'>-- wrap_fn_args E       = \x y -&gt; E</span>
<a name="line-142"></a><span class='hs-comment'>-- work_fn_args E       = E x y</span>
<a name="line-143"></a>
<a name="line-144"></a><span class='hs-comment'>-- wrap_fn_str E        = case x of { (a,b) -&gt;</span>
<a name="line-145"></a><span class='hs-comment'>--                        case a of { (a1,a2) -&gt;</span>
<a name="line-146"></a><span class='hs-comment'>--                        E a1 a2 b y }}</span>
<a name="line-147"></a><span class='hs-comment'>-- work_fn_str E        = \a1 a2 b y -&gt;</span>
<a name="line-148"></a><span class='hs-comment'>--                        let a = (a1,a2) in</span>
<a name="line-149"></a><span class='hs-comment'>--                        let x = (a,b) in</span>
<a name="line-150"></a><span class='hs-comment'>--                        E</span>
<a name="line-151"></a>
<a name="line-152"></a><span class='hs-definition'>mkWwBodies</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>rhs_fvs</span> <span class='hs-varid'>fun_id</span> <span class='hs-varid'>demands</span> <span class='hs-varid'>cpr_info</span>
<a name="line-153"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>empty_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkEmptyTCvSubst</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkInScopeSet</span> <span class='hs-varid'>rhs_fvs</span><span class='hs-layout'>)</span>
<a name="line-154"></a>                <span class='hs-comment'>-- See Note [Freshen WW arguments]</span>
<a name="line-155"></a>
<a name="line-156"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span>
<a name="line-157"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWargs</span> <span class='hs-varid'>empty_subst</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>demands</span>
<a name="line-158"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>useful1</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_str</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_str</span><span class='hs-layout'>)</span>
<a name="line-159"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWstr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>has_inlineable_prag</span> <span class='hs-varid'>wrap_args</span>
<a name="line-160"></a>
<a name="line-161"></a>        <span class='hs-comment'>-- Do CPR w/w.  See Note [Always do CPR w/w]</span>
<a name="line-162"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>useful2</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_cpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_cpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>cpr_res_ty</span><span class='hs-layout'>)</span>
<a name="line-163"></a>              <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWcpr</span> <span class='hs-layout'>(</span><span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_CprAnal</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>res_ty</span> <span class='hs-varid'>cpr_info</span>
<a name="line-164"></a>
<a name="line-165"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>work_lam_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_call_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWorkerArgs</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>work_args</span> <span class='hs-varid'>cpr_res_ty</span>
<a name="line-166"></a>              <span class='hs-varid'>worker_args_dmds</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>idDemandInfo</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>work_call_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>v</span><span class='hs-keyglyph'>]</span>
<a name="line-167"></a>              <span class='hs-varid'>wrapper_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wrap_fn_args</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn_cpr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn_str</span> <span class='hs-varop'>.</span> <span class='hs-varid'>applyToVars</span> <span class='hs-varid'>work_call_args</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Var</span>
<a name="line-168"></a>              <span class='hs-varid'>worker_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>work_lam_args</span><span class='hs-varop'>.</span> <span class='hs-varid'>work_fn_str</span> <span class='hs-varop'>.</span> <span class='hs-varid'>work_fn_cpr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>work_fn_args</span>
<a name="line-169"></a>
<a name="line-170"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isWorkerSmallEnough</span> <span class='hs-varid'>dflags</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>demands</span><span class='hs-layout'>)</span> <span class='hs-varid'>work_args</span>
<a name="line-171"></a>             <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>too_many_args_for_join_point</span> <span class='hs-varid'>wrap_args</span><span class='hs-layout'>)</span>
<a name="line-172"></a>             <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>useful1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-varid'>only_one_void_argument</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>useful2</span><span class='hs-layout'>)</span>
<a name="line-173"></a>          <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>worker_args_dmds</span><span class='hs-layout'>,</span> <span class='hs-varid'>length</span> <span class='hs-varid'>work_call_args</span><span class='hs-layout'>,</span>
<a name="line-174"></a>                       <span class='hs-varid'>wrapper_body</span><span class='hs-layout'>,</span> <span class='hs-varid'>worker_body</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-175"></a>          <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span>
<a name="line-176"></a>        <span class='hs-layout'>}</span>
<a name="line-177"></a>        <span class='hs-comment'>-- We use an INLINE unconditionally, even if the wrapper turns out to be</span>
<a name="line-178"></a>        <span class='hs-comment'>-- something trivial like</span>
<a name="line-179"></a>        <span class='hs-comment'>--      fw = ...</span>
<a name="line-180"></a>        <span class='hs-comment'>--      f = __inline__ (coerce T fw)</span>
<a name="line-181"></a>        <span class='hs-comment'>-- The point is to propagate the coerce to f's call sites, so even though</span>
<a name="line-182"></a>        <span class='hs-comment'>-- f's RHS is now trivial (size 1) we still want the __inline__ to prevent</span>
<a name="line-183"></a>        <span class='hs-comment'>-- fw from being inlined into f's RHS</span>
<a name="line-184"></a>  <span class='hs-keyword'>where</span>
<a name="line-185"></a>    <span class='hs-varid'>fun_ty</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>fun_id</span>
<a name="line-186"></a>    <span class='hs-varid'>mb_join_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isJoinId_maybe</span> <span class='hs-varid'>fun_id</span>
<a name="line-187"></a>    <span class='hs-varid'>has_inlineable_prag</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isStableUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>realIdUnfolding</span> <span class='hs-varid'>fun_id</span><span class='hs-layout'>)</span>
<a name="line-188"></a>                          <span class='hs-comment'>-- See Note [Do not unpack class dictionaries]</span>
<a name="line-189"></a>
<a name="line-190"></a>    <span class='hs-comment'>-- Note [Do not split void functions]</span>
<a name="line-191"></a>    <span class='hs-varid'>only_one_void_argument</span>
<a name="line-192"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>d</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>demands</span>
<a name="line-193"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_ty1</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-194"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isAbsDmd</span> <span class='hs-varid'>d</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isVoidTy</span> <span class='hs-varid'>arg_ty1</span>
<a name="line-195"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-196"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-197"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-198"></a>
<a name="line-199"></a>    <span class='hs-comment'>-- Note [Join points returning functions]</span>
<a name="line-200"></a>    <span class='hs-varid'>too_many_args_for_join_point</span> <span class='hs-varid'>wrap_args</span>
<a name="line-201"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>join_arity</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mb_join_arity</span>
<a name="line-202"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>wrap_args</span> <span class='hs-varop'>`lengthExceeds`</span> <span class='hs-varid'>join_arity</span>
<a name="line-203"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Unable to worker/wrapper join point with arity "</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-204"></a>                     <span class='hs-varid'>int</span> <span class='hs-varid'>join_arity</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"but"</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-205"></a>                     <span class='hs-varid'>int</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>wrap_args</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"args"</span><span class='hs-layout'>)</span>
<a name="line-206"></a>        <span class='hs-conid'>True</span>
<a name="line-207"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-208"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-209"></a>
<a name="line-210"></a><a name="isWorkerSmallEnough"></a><span class='hs-comment'>-- See Note [Limit w/w arity]</span>
<a name="line-211"></a><span class='hs-definition'>isWorkerSmallEnough</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-212"></a><span class='hs-definition'>isWorkerSmallEnough</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>old_n_args</span> <span class='hs-varid'>vars</span>
<a name="line-213"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>count</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>vars</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>max</span> <span class='hs-varid'>old_n_args</span> <span class='hs-layout'>(</span><span class='hs-varid'>maxWorkerArgs</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-214"></a>    <span class='hs-comment'>-- We count only Free variables (isId) to skip Type, Kind</span>
<a name="line-215"></a>    <span class='hs-comment'>-- variables which have no runtime representation.</span>
<a name="line-216"></a>    <span class='hs-comment'>-- Also if the function took 82 arguments before (old_n_args), it's fine if</span>
<a name="line-217"></a>    <span class='hs-comment'>-- it takes &lt;= 82 arguments afterwards.</span>
<a name="line-218"></a>
<a name="line-219"></a><span class='hs-comment'>{-
<a name="line-220"></a>Note [Always do CPR w/w]
<a name="line-221"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-222"></a>At one time we refrained from doing CPR w/w for thunks, on the grounds that
<a name="line-223"></a>we might duplicate work.  But that is already handled by the demand analyser,
<a name="line-224"></a>which doesn't give the CPR property if w/w might waste work: see
<a name="line-225"></a>Note [CPR for thunks] in GHC.Core.Opt.DmdAnal.
<a name="line-226"></a>
<a name="line-227"></a>And if something *has* been given the CPR property and we don't w/w, it's
<a name="line-228"></a>a disaster, because then the enclosing function might say it has the CPR
<a name="line-229"></a>property, but now doesn't and there a cascade of disaster.  A good example
<a name="line-230"></a>is #5920.
<a name="line-231"></a>
<a name="line-232"></a>Note [Limit w/w arity]
<a name="line-233"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-234"></a>Guard against high worker arity as it generates a lot of stack traffic.
<a name="line-235"></a>A simplified example is #11565#comment:6
<a name="line-236"></a>
<a name="line-237"></a>Current strategy is very simple: don't perform w/w transformation at all
<a name="line-238"></a>if the result produces a wrapper with arity higher than -fmax-worker-args
<a name="line-239"></a>and the number arguments before w/w (see #18122).
<a name="line-240"></a>
<a name="line-241"></a>It is a bit all or nothing, consider
<a name="line-242"></a>
<a name="line-243"></a>        f (x,y) (a,b,c,d,e ... , z) = rhs
<a name="line-244"></a>
<a name="line-245"></a>Currently we will remove all w/w ness entirely. But actually we could
<a name="line-246"></a>w/w on the (x,y) pair... it's the huge product that is the problem.
<a name="line-247"></a>
<a name="line-248"></a>Could we instead refrain from w/w on an arg-by-arg basis? Yes, that'd
<a name="line-249"></a>solve f. But we can get a lot of args from deeply-nested products:
<a name="line-250"></a>
<a name="line-251"></a>        g (a, (b, (c, (d, ...)))) = rhs
<a name="line-252"></a>
<a name="line-253"></a>This is harder to spot on an arg-by-arg basis. Previously mkWwStr was
<a name="line-254"></a>given some "fuel" saying how many arguments it could add; when we ran
<a name="line-255"></a>out of fuel it would stop w/wing.
<a name="line-256"></a>
<a name="line-257"></a>Still not very clever because it had a left-right bias.
<a name="line-258"></a>
<a name="line-259"></a>************************************************************************
<a name="line-260"></a>*                                                                      *
<a name="line-261"></a>\subsection{Making wrapper args}
<a name="line-262"></a>*                                                                      *
<a name="line-263"></a>************************************************************************
<a name="line-264"></a>
<a name="line-265"></a>During worker-wrapper stuff we may end up with an unlifted thing
<a name="line-266"></a>which we want to let-bind without losing laziness.  So we
<a name="line-267"></a>add a void argument.  E.g.
<a name="line-268"></a>
<a name="line-269"></a>        f = /\a -&gt; \x y z -&gt; E::Int#    -- E does not mention x,y,z
<a name="line-270"></a>==&gt;
<a name="line-271"></a>        fw = /\ a -&gt; \void -&gt; E
<a name="line-272"></a>        f  = /\ a -&gt; \x y z -&gt; fw realworld
<a name="line-273"></a>
<a name="line-274"></a>We use the state-token type which generates no code.
<a name="line-275"></a>-}</span>
<a name="line-276"></a>
<a name="line-277"></a><a name="mkWorkerArgs"></a><span class='hs-definition'>mkWorkerArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span>
<a name="line-278"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>    <span class='hs-comment'>-- Type of body</span>
<a name="line-279"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- Lambda bound args</span>
<a name="line-280"></a>                 <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Args at call site</span>
<a name="line-281"></a><span class='hs-definition'>mkWorkerArgs</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>args</span> <span class='hs-varid'>res_ty</span>
<a name="line-282"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>any</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>args</span> <span class='hs-varop'>||</span> <span class='hs-varid'>not</span> <span class='hs-varid'>needsAValueLambda</span>
<a name="line-283"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-284"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-285"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>args</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>voidArgId</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>voidPrimId</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-286"></a>    <span class='hs-keyword'>where</span>
<a name="line-287"></a>      <span class='hs-comment'>-- See "Making wrapper args" section above</span>
<a name="line-288"></a>      <span class='hs-varid'>needsAValueLambda</span> <span class='hs-keyglyph'>=</span>
<a name="line-289"></a>        <span class='hs-varid'>lifted</span>
<a name="line-290"></a>        <span class='hs-comment'>-- We may encounter a levity-polymorphic result, in which case we</span>
<a name="line-291"></a>        <span class='hs-comment'>-- conservatively assume that we have laziness that needs preservation.</span>
<a name="line-292"></a>        <span class='hs-comment'>-- See #15186.</span>
<a name="line-293"></a>        <span class='hs-varop'>||</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_FunToThunk</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-294"></a>           <span class='hs-comment'>-- see Note [Protecting the last value argument]</span>
<a name="line-295"></a>
<a name="line-296"></a>      <span class='hs-comment'>-- Might the result be lifted?</span>
<a name="line-297"></a>      <span class='hs-varid'>lifted</span> <span class='hs-keyglyph'>=</span>
<a name="line-298"></a>        <span class='hs-keyword'>case</span> <span class='hs-varid'>isLiftedType_maybe</span> <span class='hs-varid'>res_ty</span> <span class='hs-keyword'>of</span>
<a name="line-299"></a>          <span class='hs-conid'>Just</span> <span class='hs-varid'>lifted</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lifted</span>
<a name="line-300"></a>          <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-301"></a>
<a name="line-302"></a><span class='hs-comment'>{-
<a name="line-303"></a>Note [Protecting the last value argument]
<a name="line-304"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-305"></a>If the user writes (\_ -&gt; E), they might be intentionally disallowing
<a name="line-306"></a>the sharing of E. Since absence analysis and worker-wrapper are keen
<a name="line-307"></a>to remove such unused arguments, we add in a void argument to prevent
<a name="line-308"></a>the function from becoming a thunk.
<a name="line-309"></a>
<a name="line-310"></a>The user can avoid adding the void argument with the -ffun-to-thunk
<a name="line-311"></a>flag. However, this can create sharing, which may be bad in two ways. 1) It can
<a name="line-312"></a>create a space leak. 2) It can prevent inlining *under a lambda*. If w/w
<a name="line-313"></a>removes the last argument from a function f, then f now looks like a thunk, and
<a name="line-314"></a>so f can't be inlined *under a lambda*.
<a name="line-315"></a>
<a name="line-316"></a>Note [Join points and beta-redexes]
<a name="line-317"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-318"></a>
<a name="line-319"></a>Originally, the worker would invoke the original function by calling it with
<a name="line-320"></a>arguments, thus producing a beta-redex for the simplifier to munch away:
<a name="line-321"></a>
<a name="line-322"></a>  \x y z -&gt; e =&gt; (\x y z -&gt; e) wx wy wz
<a name="line-323"></a>
<a name="line-324"></a>Now that we have special rules about join points, however, this is Not Good if
<a name="line-325"></a>the original function is itself a join point, as then it may contain invocations
<a name="line-326"></a>of other join points:
<a name="line-327"></a>
<a name="line-328"></a>  join j1 x = ...
<a name="line-329"></a>  join j2 y = if y == 0 then 0 else j1 y
<a name="line-330"></a>
<a name="line-331"></a>  =&gt;
<a name="line-332"></a>
<a name="line-333"></a>  join j1 x = ...
<a name="line-334"></a>  join $wj2 y# = let wy = I# y# in (\y -&gt; if y == 0 then 0 else jump j1 y) wy
<a name="line-335"></a>  join j2 y = case y of I# y# -&gt; jump $wj2 y#
<a name="line-336"></a>
<a name="line-337"></a>There can't be an intervening lambda between a join point's declaration and its
<a name="line-338"></a>occurrences, so $wj2 here is wrong. But of course, this is easy enough to fix:
<a name="line-339"></a>
<a name="line-340"></a>  ...
<a name="line-341"></a>  let join $wj2 y# = let wy = I# y# in let y = wy in if y == 0 then 0 else j1 y
<a name="line-342"></a>  ...
<a name="line-343"></a>
<a name="line-344"></a>Hence we simply do the beta-reduction here. (This would be harder if we had to
<a name="line-345"></a>worry about hygiene, but luckily wy is freshly generated.)
<a name="line-346"></a>
<a name="line-347"></a>Note [Join points returning functions]
<a name="line-348"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-349"></a>
<a name="line-350"></a>It is crucial that the arity of a join point depends on its *callers,* not its
<a name="line-351"></a>own syntax. What this means is that a join point can have "extra lambdas":
<a name="line-352"></a>
<a name="line-353"></a>f :: Int -&gt; Int -&gt; (Int, Int) -&gt; Int
<a name="line-354"></a>f x y = join j (z, w) = \(u, v) -&gt; ...
<a name="line-355"></a>        in jump j (x, y)
<a name="line-356"></a>
<a name="line-357"></a>Typically this happens with functions that are seen as computing functions,
<a name="line-358"></a>rather than being curried. (The real-life example was GHC.Data.Graph.Ops.addConflicts.)
<a name="line-359"></a>
<a name="line-360"></a>When we create the wrapper, it *must* be in "eta-contracted" form so that the
<a name="line-361"></a>jump has the right number of arguments:
<a name="line-362"></a>
<a name="line-363"></a>f x y = join $wj z' w' = \u' v' -&gt; let {z = z'; w = w'; u = u'; v = v'} in ...
<a name="line-364"></a>             j (z, w)  = jump $wj z w
<a name="line-365"></a>
<a name="line-366"></a>(See Note [Join points and beta-redexes] for where the lets come from.) If j
<a name="line-367"></a>were a function, we would instead say
<a name="line-368"></a>
<a name="line-369"></a>f x y = let $wj = \z' w' u' v' -&gt; let {z = z'; w = w'; u = u'; v = v'} in ...
<a name="line-370"></a>            j (z, w) (u, v) = $wj z w u v
<a name="line-371"></a>
<a name="line-372"></a>Notice that the worker ends up with the same lambdas; it's only the wrapper we
<a name="line-373"></a>have to be concerned about.
<a name="line-374"></a>
<a name="line-375"></a>FIXME Currently the functionality to produce "eta-contracted" wrappers is
<a name="line-376"></a>unimplemented; we simply give up.
<a name="line-377"></a>
<a name="line-378"></a>************************************************************************
<a name="line-379"></a>*                                                                      *
<a name="line-380"></a>\subsection{Coercion stuff}
<a name="line-381"></a>*                                                                      *
<a name="line-382"></a>************************************************************************
<a name="line-383"></a>
<a name="line-384"></a>We really want to "look through" coerces.
<a name="line-385"></a>Reason: I've seen this situation:
<a name="line-386"></a>
<a name="line-387"></a>        let f = coerce T (\s -&gt; E)
<a name="line-388"></a>        in \x -&gt; case x of
<a name="line-389"></a>                    p -&gt; coerce T' f
<a name="line-390"></a>                    q -&gt; \s -&gt; E2
<a name="line-391"></a>                    r -&gt; coerce T' f
<a name="line-392"></a>
<a name="line-393"></a>If only we w/w'd f, we'd get
<a name="line-394"></a>        let f = coerce T (\s -&gt; fw s)
<a name="line-395"></a>            fw = \s -&gt; E
<a name="line-396"></a>        in ...
<a name="line-397"></a>
<a name="line-398"></a>Now we'll inline f to get
<a name="line-399"></a>
<a name="line-400"></a>        let fw = \s -&gt; E
<a name="line-401"></a>        in \x -&gt; case x of
<a name="line-402"></a>                    p -&gt; fw
<a name="line-403"></a>                    q -&gt; \s -&gt; E2
<a name="line-404"></a>                    r -&gt; fw
<a name="line-405"></a>
<a name="line-406"></a>Now we'll see that fw has arity 1, and will arity expand
<a name="line-407"></a>the \x to get what we want.
<a name="line-408"></a>-}</span>
<a name="line-409"></a>
<a name="line-410"></a><span class='hs-comment'>-- mkWWargs just does eta expansion</span>
<a name="line-411"></a><span class='hs-comment'>-- is driven off the function type and arity.</span>
<a name="line-412"></a><span class='hs-comment'>-- It chomps bites off foralls, arrows, newtypes</span>
<a name="line-413"></a><span class='hs-comment'>-- and keeps repeating that until it's satisfied the supplied arity</span>
<a name="line-414"></a>
<a name="line-415"></a><a name="mkWWargs"></a><span class='hs-definition'>mkWWargs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TCvSubst</span>            <span class='hs-comment'>-- Freshening substitution to apply to the type</span>
<a name="line-416"></a>                                <span class='hs-comment'>--   See Note [Freshen WW arguments]</span>
<a name="line-417"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>                <span class='hs-comment'>-- The type of the function</span>
<a name="line-418"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- Demands and one-shot info for value arguments</span>
<a name="line-419"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span>  <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>            <span class='hs-comment'>-- Wrapper args</span>
<a name="line-420"></a>                     <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- Wrapper fn</span>
<a name="line-421"></a>                     <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- Worker fn</span>
<a name="line-422"></a>                     <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>                      <span class='hs-comment'>-- Type of wrapper body</span>
<a name="line-423"></a>
<a name="line-424"></a><span class='hs-definition'>mkWWargs</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>demands</span>
<a name="line-425"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>demands</span>
<a name="line-426"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>fun_ty</span><span class='hs-layout'>)</span>
<a name="line-427"></a>
<a name="line-428"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd</span><span class='hs-conop'>:</span><span class='hs-varid'>demands'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>demands</span>
<a name="line-429"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>mult</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-430"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>uniq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-431"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_ty'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substScaledTy</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>mult</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-432"></a>              <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_wrap_arg</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>arg_ty'</span> <span class='hs-varid'>dmd</span>
<a name="line-433"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span>
<a name="line-434"></a>              <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWargs</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>fun_ty'</span> <span class='hs-varid'>demands'</span>
<a name="line-435"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span> <span class='hs-conop'>:</span> <span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span>
<a name="line-436"></a>                  <span class='hs-conid'>Lam</span> <span class='hs-varid'>id</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span>
<a name="line-437"></a>                  <span class='hs-varid'>apply_or_bind_then</span> <span class='hs-varid'>work_fn_args</span> <span class='hs-layout'>(</span><span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-438"></a>                  <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-439"></a>
<a name="line-440"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitForAllTyCoVar_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-441"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>uniq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-442"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>tv'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cloneTyVarBndr</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>uniq</span>
<a name="line-443"></a>                <span class='hs-comment'>-- See Note [Freshen WW arguments]</span>
<a name="line-444"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span>
<a name="line-445"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWargs</span> <span class='hs-varid'>subst'</span> <span class='hs-varid'>fun_ty'</span> <span class='hs-varid'>demands</span>
<a name="line-446"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span>
<a name="line-447"></a>                  <span class='hs-conid'>Lam</span> <span class='hs-varid'>tv'</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span>
<a name="line-448"></a>                  <span class='hs-varid'>apply_or_bind_then</span> <span class='hs-varid'>work_fn_args</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyArg</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-449"></a>                  <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-450"></a>
<a name="line-451"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>rep_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>topNormaliseNewType_maybe</span> <span class='hs-varid'>fun_ty</span>
<a name="line-452"></a>        <span class='hs-comment'>-- The newtype case is for when the function has</span>
<a name="line-453"></a>        <span class='hs-comment'>-- a newtype after the arrow (rare)</span>
<a name="line-454"></a>        <span class='hs-comment'>--</span>
<a name="line-455"></a>        <span class='hs-comment'>-- It's also important when we have a function returning (say) a pair</span>
<a name="line-456"></a>        <span class='hs-comment'>-- wrapped in a  newtype, at least if CPR analysis can look</span>
<a name="line-457"></a>        <span class='hs-comment'>-- through such newtypes, which it probably can since they are</span>
<a name="line-458"></a>        <span class='hs-comment'>-- simply coerces.</span>
<a name="line-459"></a>
<a name="line-460"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span>
<a name="line-461"></a>            <span class='hs-keyglyph'>&lt;-</span>  <span class='hs-varid'>mkWWargs</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>rep_ty</span> <span class='hs-varid'>demands</span>
<a name="line-462"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substCo</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>co</span>
<a name="line-463"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span><span class='hs-layout'>,</span>
<a name="line-464"></a>                  <span class='hs-keyglyph'>\</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cast</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_fn_args</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co'</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-465"></a>                  <span class='hs-keyglyph'>\</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>work_fn_args</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co'</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-466"></a>                  <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-467"></a>
<a name="line-468"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-469"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fun_ty</span> <span class='hs-layout'>)</span>                    <span class='hs-comment'>-- Should not happen: if there is a demand</span>
<a name="line-470"></a>    <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>fun_ty</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- then there should be a function arrow</span>
<a name="line-471"></a>  <span class='hs-keyword'>where</span>
<a name="line-472"></a>    <span class='hs-comment'>-- See Note [Join points and beta-redexes]</span>
<a name="line-473"></a>    <span class='hs-varid'>apply_or_bind_then</span> <span class='hs-varid'>k</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-474"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCoreLet</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>k</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- Important that arg is fresh!</span>
<a name="line-475"></a>    <span class='hs-varid'>apply_or_bind_then</span> <span class='hs-varid'>k</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>fun</span>
<a name="line-476"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkCoreApp</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"mkWWargs"</span><span class='hs-layout'>)</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span>
<a name="line-477"></a><a name="applyToVars"></a><span class='hs-definition'>applyToVars</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-478"></a><span class='hs-definition'>applyToVars</span> <span class='hs-varid'>vars</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarApps</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>vars</span>
<a name="line-479"></a>
<a name="line-480"></a><a name="mk_wrap_arg"></a><span class='hs-definition'>mk_wrap_arg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unique</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-481"></a><span class='hs-definition'>mk_wrap_arg</span> <span class='hs-varid'>uniq</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>w</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>dmd</span>
<a name="line-482"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSysLocalOrCoVar</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"w"</span><span class='hs-layout'>)</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>w</span> <span class='hs-varid'>ty</span>
<a name="line-483"></a>       <span class='hs-varop'>`setIdDemandInfo`</span> <span class='hs-varid'>dmd</span>
<a name="line-484"></a>
<a name="line-485"></a><span class='hs-comment'>{- Note [Freshen WW arguments]
<a name="line-486"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-487"></a>Wen we do a worker/wrapper split, we must not in-scope names as the arguments
<a name="line-488"></a>of the worker, else we'll get name capture.  E.g.
<a name="line-489"></a>
<a name="line-490"></a>   -- y1 is in scope from further out
<a name="line-491"></a>   f x = ..y1..
<a name="line-492"></a>
<a name="line-493"></a>If we accidentally choose y1 as a worker argument disaster results:
<a name="line-494"></a>
<a name="line-495"></a>   fww y1 y2 = let x = (y1,y2) in ...y1...
<a name="line-496"></a>
<a name="line-497"></a>To avoid this:
<a name="line-498"></a>
<a name="line-499"></a>  * We use a fresh unique for both type-variable and term-variable binders
<a name="line-500"></a>    Originally we lacked this freshness for type variables, and that led
<a name="line-501"></a>    to the very obscure #12562.  (A type variable in the worker shadowed
<a name="line-502"></a>    an outer term-variable binding.)
<a name="line-503"></a>
<a name="line-504"></a>  * Because of this cloning we have to substitute in the type/kind of the
<a name="line-505"></a>    new binders.  That's why we carry the TCvSubst through mkWWargs.
<a name="line-506"></a>
<a name="line-507"></a>    So we need a decent in-scope set, just in case that type/kind
<a name="line-508"></a>    itself has foralls.  We get this from the free vars of the RHS of the
<a name="line-509"></a>    function since those are the only variables that might be captured.
<a name="line-510"></a>    It's a lazy thunk, which will only be poked if the type/kind has a forall.
<a name="line-511"></a>
<a name="line-512"></a>    Another tricky case was when f :: forall a. a -&gt; forall a. a-&gt;a
<a name="line-513"></a>    (i.e. with shadowing), and then the worker used the same 'a' twice.
<a name="line-514"></a>-}</span>
<a name="line-515"></a>
<a name="line-516"></a><span class='hs-comment'>{-
<a name="line-517"></a>************************************************************************
<a name="line-518"></a>*                                                                      *
<a name="line-519"></a>\subsection{Unboxing Decision for Strictness and CPR}
<a name="line-520"></a>*                                                                      *
<a name="line-521"></a>************************************************************************
<a name="line-522"></a>-}</span>
<a name="line-523"></a>
<a name="line-524"></a><a name="DataConPatContext"></a><span class='hs-comment'>-- | The information needed to build a pattern for a DataCon to be unboxed.</span>
<a name="line-525"></a><a name="DataConPatContext"></a><span class='hs-comment'>-- The pattern can be generated from 'dcpc_dc' and 'dcpc_tc_args' via</span>
<a name="line-526"></a><a name="DataConPatContext"></a><span class='hs-comment'>-- 'GHC.Core.Utils.dataConRepInstPat'. The coercion 'dcpc_co' is for newtype</span>
<a name="line-527"></a><a name="DataConPatContext"></a><span class='hs-comment'>-- wrappers.</span>
<a name="line-528"></a><a name="DataConPatContext"></a><span class='hs-comment'>--</span>
<a name="line-529"></a><a name="DataConPatContext"></a><span class='hs-comment'>-- If we get @DataConPatContext dc tys co@ for some type @ty@</span>
<a name="line-530"></a><a name="DataConPatContext"></a><span class='hs-comment'>-- and @dataConRepInstPat ... dc tys = (exs, flds)@, then</span>
<a name="line-531"></a><a name="DataConPatContext"></a><span class='hs-comment'>--</span>
<a name="line-532"></a><a name="DataConPatContext"></a><span class='hs-comment'>--   * @dc @exs flds :: T tys@</span>
<a name="line-533"></a><a name="DataConPatContext"></a><span class='hs-comment'>--   * @co :: T tys ~ ty@</span>
<a name="line-534"></a><a name="DataConPatContext"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>DataConPatContext</span>
<a name="line-535"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DataConPatContext</span>
<a name="line-536"></a>  <span class='hs-layout'>{</span> <span class='hs-varid'>dcpc_dc</span>      <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>DataCon</span>
<a name="line-537"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>dcpc_tc_args</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-538"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>dcpc_co</span>      <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Coercion</span>
<a name="line-539"></a>  <span class='hs-layout'>}</span>
<a name="line-540"></a>
<a name="line-541"></a><a name="splitArgType_maybe"></a><span class='hs-comment'>-- | If @splitArgType_maybe ty = Just (dc, tys, co)@</span>
<a name="line-542"></a><span class='hs-comment'>-- then @dc \@tys \@_ex_tys (_args::_arg_tys) :: tc tys@</span>
<a name="line-543"></a><span class='hs-comment'>-- and  @co :: ty ~ tc tys@</span>
<a name="line-544"></a><span class='hs-comment'>-- where underscore prefixes are holes, e.g. yet unspecified.</span>
<a name="line-545"></a><span class='hs-comment'>--</span>
<a name="line-546"></a><span class='hs-comment'>-- See Note [Which types are unboxed?].</span>
<a name="line-547"></a><span class='hs-definition'>splitArgType_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>DataConPatContext</span>
<a name="line-548"></a><span class='hs-definition'>splitArgType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-549"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topNormaliseType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-550"></a>                    <span class='hs-varop'>`orElse`</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkRepReflCo</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-551"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-552"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>con</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConSingleAlgDataCon_maybe</span> <span class='hs-varid'>tc</span>
<a name="line-553"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>DataConPatContext</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dcpc_dc</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>con</span>
<a name="line-554"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>dcpc_tc_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc_args</span>
<a name="line-555"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>dcpc_co</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co</span> <span class='hs-layout'>}</span>
<a name="line-556"></a><span class='hs-definition'>splitArgType_maybe</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-557"></a>
<a name="line-558"></a><a name="splitResultType_maybe"></a><span class='hs-comment'>-- | If @splitResultType_maybe n ty = Just (dc, tys, co)@</span>
<a name="line-559"></a><span class='hs-comment'>-- then @dc \@tys \@_ex_tys (_args::_arg_tys) :: tc tys@</span>
<a name="line-560"></a><span class='hs-comment'>-- and  @co :: ty ~ tc tys@</span>
<a name="line-561"></a><span class='hs-comment'>-- where underscore prefixes are holes, e.g. yet unspecified.</span>
<a name="line-562"></a><span class='hs-comment'>-- @dc@ is the @n@th data constructor of @tc@.</span>
<a name="line-563"></a><span class='hs-comment'>--</span>
<a name="line-564"></a><span class='hs-comment'>-- See Note [Which types are unboxed?].</span>
<a name="line-565"></a><span class='hs-definition'>splitResultType_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConTag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>DataConPatContext</span>
<a name="line-566"></a><span class='hs-definition'>splitResultType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>con_tag</span> <span class='hs-varid'>ty</span>
<a name="line-567"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topNormaliseType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-568"></a>                    <span class='hs-varop'>`orElse`</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkRepReflCo</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-569"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-570"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isDataTyCon</span> <span class='hs-varid'>tc</span> <span class='hs-comment'>-- NB: rules out unboxed sums and pairs!</span>
<a name="line-571"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>cons</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConDataCons</span> <span class='hs-varid'>tc</span>
<a name="line-572"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>cons</span> <span class='hs-varop'>`lengthAtLeast`</span> <span class='hs-varid'>con_tag</span> <span class='hs-comment'>-- This might not be true if we import the</span>
<a name="line-573"></a>                                 <span class='hs-comment'>-- type constructor via a .hs-boot file (#8743)</span>
<a name="line-574"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>con</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cons</span> <span class='hs-varop'>`getNth`</span> <span class='hs-layout'>(</span><span class='hs-varid'>con_tag</span> <span class='hs-comment'>-</span> <span class='hs-varid'>fIRST_TAG</span><span class='hs-layout'>)</span>
<a name="line-575"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>null</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConExTyCoVars</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- no existentials;</span>
<a name="line-576"></a>                                 <span class='hs-comment'>-- See Note [Which types are unboxed?]</span>
<a name="line-577"></a>                                 <span class='hs-comment'>-- and GHC.Core.Opt.CprAnal.extendEnvForDataAlt</span>
<a name="line-578"></a>                                 <span class='hs-comment'>-- where we also check this.</span>
<a name="line-579"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>all</span> <span class='hs-varid'>isLinear</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConInstArgTys</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span>
<a name="line-580"></a>  <span class='hs-comment'>-- Deactivates CPR worker/wrapper splits on constructors with non-linear</span>
<a name="line-581"></a>  <span class='hs-comment'>-- arguments, for the moment, because they require unboxed tuple with variable</span>
<a name="line-582"></a>  <span class='hs-comment'>-- multiplicity fields.</span>
<a name="line-583"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>DataConPatContext</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dcpc_dc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>con</span>
<a name="line-584"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>dcpc_tc_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc_args</span>
<a name="line-585"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>dcpc_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co</span> <span class='hs-layout'>}</span>
<a name="line-586"></a><span class='hs-definition'>splitResultType_maybe</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-587"></a>
<a name="line-588"></a><a name="isLinear"></a><span class='hs-definition'>isLinear</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Scaled</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-589"></a><span class='hs-definition'>isLinear</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>w</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-590"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>w</span> <span class='hs-keyword'>of</span>
<a name="line-591"></a>    <span class='hs-conid'>One</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-592"></a>    <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-593"></a>
<a name="line-594"></a><a name="UnboxingDecision"></a><span class='hs-comment'>-- | Describes the outer shape of an argument to be unboxed or left as-is</span>
<a name="line-595"></a><a name="UnboxingDecision"></a><span class='hs-comment'>-- Depending on how @s@ is instantiated (e.g., 'Demand').</span>
<a name="line-596"></a><a name="UnboxingDecision"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>UnboxingDecision</span> <span class='hs-varid'>s</span>
<a name="line-597"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>StopUnboxing</span>
<a name="line-598"></a>  <span class='hs-comment'>-- ^ We ran out of strictness info. Leave untouched.</span>
<a name="line-599"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Unbox</span> <span class='hs-varop'>!</span><span class='hs-conid'>DataConPatContext</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>s</span><span class='hs-keyglyph'>]</span>
<a name="line-600"></a>  <span class='hs-comment'>-- ^ The argument is used strictly or the returned product was constructed, so</span>
<a name="line-601"></a>  <span class='hs-comment'>-- unbox it.</span>
<a name="line-602"></a>  <span class='hs-comment'>-- The 'DataConPatContext' carries the bits necessary for</span>
<a name="line-603"></a>  <span class='hs-comment'>-- instantiation with 'dataConRepInstPat'.</span>
<a name="line-604"></a>  <span class='hs-comment'>-- The @[s]@ carries the bits of information with which we can continue</span>
<a name="line-605"></a>  <span class='hs-comment'>-- unboxing, e.g. @s@ will be 'Demand'.</span>
<a name="line-606"></a>
<a name="line-607"></a><a name="wantToUnbox"></a><span class='hs-definition'>wantToUnbox</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnboxingDecision</span> <span class='hs-conid'>Demand</span>
<a name="line-608"></a><span class='hs-comment'>-- See Note [Which types are unboxed?]</span>
<a name="line-609"></a><span class='hs-definition'>wantToUnbox</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>has_inlineable_prag</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>dmd</span> <span class='hs-keyglyph'>=</span>
<a name="line-610"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>splitArgType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>of</span>
<a name="line-611"></a>    <span class='hs-conid'>Just</span> <span class='hs-varid'>dcpc</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>DataConPatContext</span><span class='hs-layout'>{</span> <span class='hs-varid'>dcpc_dc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dc</span> <span class='hs-layout'>}</span>
<a name="line-612"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStrUsedDmd</span> <span class='hs-varid'>dmd</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isUnliftedType</span> <span class='hs-varid'>ty</span>
<a name="line-613"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepArity</span> <span class='hs-varid'>dc</span>
<a name="line-614"></a>      <span class='hs-comment'>-- See Note [Unpacking arguments with product and polymorphic demands]</span>
<a name="line-615"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>cs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>split_prod_dmd_arity</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>arity</span>
<a name="line-616"></a>      <span class='hs-comment'>-- See Note [Do not unpack class dictionaries]</span>
<a name="line-617"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>has_inlineable_prag</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isClassPred</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-618"></a>      <span class='hs-comment'>-- See Note [mkWWstr and unsafeCoerce]</span>
<a name="line-619"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>cs</span> <span class='hs-varop'>`lengthIs`</span> <span class='hs-varid'>arity</span>
<a name="line-620"></a>      <span class='hs-comment'>-- See Note [Add demands for strict constructors]</span>
<a name="line-621"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>cs'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addDataConStrictness</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>cs</span>
<a name="line-622"></a>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unbox</span> <span class='hs-varid'>dcpc</span> <span class='hs-varid'>cs'</span>
<a name="line-623"></a>    <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StopUnboxing</span>
<a name="line-624"></a>  <span class='hs-keyword'>where</span>
<a name="line-625"></a>    <span class='hs-varid'>split_prod_dmd_arity</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>arity</span>
<a name="line-626"></a>      <span class='hs-comment'>-- For seqDmd, it should behave like &lt;S(AAAA)&gt;, for some</span>
<a name="line-627"></a>      <span class='hs-comment'>-- suitable arity</span>
<a name="line-628"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSeqDmd</span> <span class='hs-varid'>dmd</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>replicate</span> <span class='hs-varid'>arity</span> <span class='hs-varid'>absDmd</span><span class='hs-layout'>)</span>
<a name="line-629"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>_</span> <span class='hs-conop'>:*</span> <span class='hs-conid'>Prod</span> <span class='hs-varid'>ds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ds</span>
<a name="line-630"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-631"></a>
<a name="line-632"></a><span class='hs-comment'>{- Note [Which types are unboxed?]
<a name="line-633"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-634"></a>Worker/wrapper will unbox
<a name="line-635"></a>
<a name="line-636"></a>  1. A strict data type argument, that
<a name="line-637"></a>       * is an algebraic data type (not a newtype)
<a name="line-638"></a>       * has a single constructor (thus is a "product")
<a name="line-639"></a>       * that may bind existentials
<a name="line-640"></a>     We can transform
<a name="line-641"></a>     &gt; f (D @ex a b) = e
<a name="line-642"></a>     to
<a name="line-643"></a>     &gt; $wf @ex a b = e
<a name="line-644"></a>     via 'mkWWstr'.
<a name="line-645"></a>
<a name="line-646"></a>  2. The constructed result of a function, if
<a name="line-647"></a>       * its type is an algebraic data type (not a newtype)
<a name="line-648"></a>       * (might have multiple constructors, in contrast to (1))
<a name="line-649"></a>       * the applied data constructor *does not* bind existentials
<a name="line-650"></a>     We can transform
<a name="line-651"></a>     &gt; f x y = let ... in D a b
<a name="line-652"></a>     to
<a name="line-653"></a>     &gt; $wf x y = let ... in (# a, b #)
<a name="line-654"></a>     via 'mkWWcpr'.
<a name="line-655"></a>
<a name="line-656"></a>     NB: We don't allow existentials for CPR W/W, because we don't have unboxed
<a name="line-657"></a>     dependent tuples (yet?). Otherwise, we could transform
<a name="line-658"></a>     &gt; f x y = let ... in D @ex (a :: ..ex..) (b :: ..ex..)
<a name="line-659"></a>     to
<a name="line-660"></a>     &gt; $wf x y = let ... in (# @ex, (a :: ..ex..), (b :: ..ex..) #)
<a name="line-661"></a>
<a name="line-662"></a>The respective tests are in 'splitArgType_maybe' and
<a name="line-663"></a>'splitResultType_maybe', respectively.
<a name="line-664"></a>
<a name="line-665"></a>Note that the data constructor /can/ have evidence arguments: equality
<a name="line-666"></a>constraints, type classes etc.  So it can be GADT.  These evidence
<a name="line-667"></a>arguments are simply value arguments, and should not get in the way.
<a name="line-668"></a>
<a name="line-669"></a>Note [Unpacking arguments with product and polymorphic demands]
<a name="line-670"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-671"></a>The argument is unpacked in a case if it has a product type and has a
<a name="line-672"></a>strict *and* used demand put on it. I.e., arguments, with demands such
<a name="line-673"></a>as the following ones:
<a name="line-674"></a>
<a name="line-675"></a>   &lt;S,U(U, L)&gt;
<a name="line-676"></a>   &lt;S(L,S),U&gt;
<a name="line-677"></a>
<a name="line-678"></a>will be unpacked, but
<a name="line-679"></a>
<a name="line-680"></a>   &lt;S,U&gt; or &lt;B,U&gt;
<a name="line-681"></a>
<a name="line-682"></a>will not, because the pieces aren't used. This is quite important otherwise
<a name="line-683"></a>we end up unpacking massive tuples passed to the bottoming function. Example:
<a name="line-684"></a>
<a name="line-685"></a>        f :: ((Int,Int) -&gt; String) -&gt; (Int,Int) -&gt; a
<a name="line-686"></a>        f g pr = error (g pr)
<a name="line-687"></a>
<a name="line-688"></a>        main = print (f fst (1, error "no"))
<a name="line-689"></a>
<a name="line-690"></a>Does 'main' print "error 1" or "error no"?  We don't really want 'f'
<a name="line-691"></a>to unbox its second argument.  This actually happened in GHC's onwn
<a name="line-692"></a>source code, in Packages.applyPackageFlag, which ended up un-boxing
<a name="line-693"></a>the enormous DynFlags tuple, and being strict in the
<a name="line-694"></a>as-yet-un-filled-in unitState files.
<a name="line-695"></a>
<a name="line-696"></a>Note [Do not unpack class dictionaries]
<a name="line-697"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-698"></a>If we have
<a name="line-699"></a>   f :: Ord a =&gt; [a] -&gt; Int -&gt; a
<a name="line-700"></a>   {-# INLINABLE f #-}
<a name="line-701"></a>and we worker/wrapper f, we'll get a worker with an INLINABLE pragma
<a name="line-702"></a>(see Note [Worker-wrapper for INLINABLE functions] in GHC.Core.Opt.WorkWrap),
<a name="line-703"></a>which can still be specialised by the type-class specialiser, something like
<a name="line-704"></a>   fw :: Ord a =&gt; [a] -&gt; Int# -&gt; a
<a name="line-705"></a>
<a name="line-706"></a>BUT if f is strict in the Ord dictionary, we might unpack it, to get
<a name="line-707"></a>   fw :: (a-&gt;a-&gt;Bool) -&gt; [a] -&gt; Int# -&gt; a
<a name="line-708"></a>and the type-class specialiser can't specialise that. An example is #6056.
<a name="line-709"></a>
<a name="line-710"></a>But in any other situation a dictionary is just an ordinary value,
<a name="line-711"></a>and can be unpacked.  So we track the INLINABLE pragma, and switch
<a name="line-712"></a>off the unpacking in mkWWstr_one (see the isClassPred test).
<a name="line-713"></a>
<a name="line-714"></a>Historical note: #14955 describes how I got this fix wrong the first time.
<a name="line-715"></a>
<a name="line-716"></a>Note [mkWWstr and unsafeCoerce]
<a name="line-717"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-718"></a>By using unsafeCoerce, it is possible to make the number of demands fail to
<a name="line-719"></a>match the number of constructor arguments; this happened in #8037.
<a name="line-720"></a>If so, the worker/wrapper split doesn't work right and we get a Core Lint
<a name="line-721"></a>bug.  The fix here is simply to decline to do w/w if that happens.
<a name="line-722"></a>
<a name="line-723"></a>Note [Add demands for strict constructors]
<a name="line-724"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-725"></a>Consider this program (due to Roman):
<a name="line-726"></a>
<a name="line-727"></a>    data X a = X !a
<a name="line-728"></a>
<a name="line-729"></a>    foo :: X Int -&gt; Int -&gt; Int
<a name="line-730"></a>    foo (X a) n = go 0
<a name="line-731"></a>     where
<a name="line-732"></a>       go i | i &lt; n     = a + go (i+1)
<a name="line-733"></a>            | otherwise = 0
<a name="line-734"></a>
<a name="line-735"></a>We want the worker for 'foo' too look like this:
<a name="line-736"></a>
<a name="line-737"></a>    $wfoo :: Int# -&gt; Int# -&gt; Int#
<a name="line-738"></a>
<a name="line-739"></a>with the first argument unboxed, so that it is not eval'd each time
<a name="line-740"></a>around the 'go' loop (which would otherwise happen, since 'foo' is not
<a name="line-741"></a>strict in 'a').  It is sound for the wrapper to pass an unboxed arg
<a name="line-742"></a>because X is strict, so its argument must be evaluated.  And if we
<a name="line-743"></a>*don't* pass an unboxed argument, we can't even repair it by adding a
<a name="line-744"></a>`seq` thus:
<a name="line-745"></a>
<a name="line-746"></a>    foo (X a) n = a `seq` go 0
<a name="line-747"></a>
<a name="line-748"></a>because the seq is discarded (very early) since X is strict!
<a name="line-749"></a>
<a name="line-750"></a>So here's what we do
<a name="line-751"></a>
<a name="line-752"></a>* We leave the demand-analysis alone.  The demand on 'a' in the
<a name="line-753"></a>  definition of 'foo' is &lt;L, U(U)&gt;; the strictness info is Lazy
<a name="line-754"></a>  because foo's body may or may not evaluate 'a'; but the usage info
<a name="line-755"></a>  says that 'a' is unpacked and its content is used.
<a name="line-756"></a>
<a name="line-757"></a>* During worker/wrapper, if we unpack a strict constructor (as we do
<a name="line-758"></a>  for 'foo'), we use 'addDataConStrictness' to bump up the strictness on
<a name="line-759"></a>  the strict arguments of the data constructor.
<a name="line-760"></a>
<a name="line-761"></a>* That in turn means that, if the usage info supports doing so
<a name="line-762"></a>  (i.e. splitProdDmd_maybe returns Just), we will unpack that argument
<a name="line-763"></a>  -- even though the original demand (e.g. on 'a') was lazy.
<a name="line-764"></a>
<a name="line-765"></a>* What does "bump up the strictness" mean?  Just add a head-strict
<a name="line-766"></a>  demand to the strictness!  Even for a demand like &lt;L,A&gt; we can
<a name="line-767"></a>  safely turn it into &lt;S,A&gt;; remember case (1) of
<a name="line-768"></a>  Note [How to do the worker/wrapper split].
<a name="line-769"></a>
<a name="line-770"></a>The net effect is that the w/w transformation is more aggressive about
<a name="line-771"></a>unpacking the strict arguments of a data constructor, when that
<a name="line-772"></a>eagerness is supported by the usage info.
<a name="line-773"></a>
<a name="line-774"></a>There is the usual danger of reboxing, which as usual we ignore. But
<a name="line-775"></a>if X is monomorphic, and has an UNPACK pragma, then this optimisation
<a name="line-776"></a>is even more important.  We don't want the wrapper to rebox an unboxed
<a name="line-777"></a>argument, and pass an Int to $wfoo!
<a name="line-778"></a>
<a name="line-779"></a>This works in nested situations like
<a name="line-780"></a>
<a name="line-781"></a>    data family Bar a
<a name="line-782"></a>    data instance Bar (a, b) = BarPair !(Bar a) !(Bar b)
<a name="line-783"></a>    newtype instance Bar Int = Bar Int
<a name="line-784"></a>
<a name="line-785"></a>    foo :: Bar ((Int, Int), Int) -&gt; Int -&gt; Int
<a name="line-786"></a>    foo f k = case f of BarPair x y -&gt;
<a name="line-787"></a>              case burble of
<a name="line-788"></a>                 True -&gt; case x of
<a name="line-789"></a>                           BarPair p q -&gt; ...
<a name="line-790"></a>                 False -&gt; ...
<a name="line-791"></a>
<a name="line-792"></a>The extra eagerness lets us produce a worker of type:
<a name="line-793"></a>     $wfoo :: Int# -&gt; Int# -&gt; Int# -&gt; Int -&gt; Int
<a name="line-794"></a>     $wfoo p# q# y# = ...
<a name="line-795"></a>
<a name="line-796"></a>even though the `case x` is only lazily evaluated.
<a name="line-797"></a>
<a name="line-798"></a>--------- Historical note ------------
<a name="line-799"></a>We used to add data-con strictness demands when demand analysing case
<a name="line-800"></a>expression. However, it was noticed in #15696 that this misses some cases. For
<a name="line-801"></a>instance, consider the program (from T10482)
<a name="line-802"></a>
<a name="line-803"></a>    data family Bar a
<a name="line-804"></a>    data instance Bar (a, b) = BarPair !(Bar a) !(Bar b)
<a name="line-805"></a>    newtype instance Bar Int = Bar Int
<a name="line-806"></a>
<a name="line-807"></a>    foo :: Bar ((Int, Int), Int) -&gt; Int -&gt; Int
<a name="line-808"></a>    foo f k =
<a name="line-809"></a>      case f of
<a name="line-810"></a>        BarPair x y -&gt; case burble of
<a name="line-811"></a>                          True -&gt; case x of
<a name="line-812"></a>                                    BarPair p q -&gt; ...
<a name="line-813"></a>                          False -&gt; ...
<a name="line-814"></a>
<a name="line-815"></a>We really should be able to assume that `p` is already evaluated since it came
<a name="line-816"></a>from a strict field of BarPair. This strictness would allow us to produce a
<a name="line-817"></a>worker of type:
<a name="line-818"></a>
<a name="line-819"></a>    $wfoo :: Int# -&gt; Int# -&gt; Int# -&gt; Int -&gt; Int
<a name="line-820"></a>    $wfoo p# q# y# = ...
<a name="line-821"></a>
<a name="line-822"></a>even though the `case x` is only lazily evaluated
<a name="line-823"></a>
<a name="line-824"></a>Indeed before we fixed #15696 this would happen since we would float the inner
<a name="line-825"></a>`case x` through the `case burble` to get:
<a name="line-826"></a>
<a name="line-827"></a>    foo f k =
<a name="line-828"></a>      case f of
<a name="line-829"></a>        BarPair x y -&gt; case x of
<a name="line-830"></a>                          BarPair p q -&gt; case burble of
<a name="line-831"></a>                                          True -&gt; ...
<a name="line-832"></a>                                          False -&gt; ...
<a name="line-833"></a>
<a name="line-834"></a>However, after fixing #15696 this could no longer happen (for the reasons
<a name="line-835"></a>discussed in ticket:15696#comment:76). This means that the demand placed on `f`
<a name="line-836"></a>would then be significantly weaker (since the False branch of the case on
<a name="line-837"></a>`burble` is not strict in `p` or `q`).
<a name="line-838"></a>
<a name="line-839"></a>Consequently, we now instead account for data-con strictness in mkWWstr_one,
<a name="line-840"></a>applying the strictness demands to the final result of DmdAnal. The result is
<a name="line-841"></a>that we get the strict demand signature we wanted even if we can't float
<a name="line-842"></a>the case on `x` up through the case on `burble`.
<a name="line-843"></a>-}</span>
<a name="line-844"></a>
<a name="line-845"></a><span class='hs-comment'>{-
<a name="line-846"></a>************************************************************************
<a name="line-847"></a>*                                                                      *
<a name="line-848"></a>\subsection{Strictness stuff}
<a name="line-849"></a>*                                                                      *
<a name="line-850"></a>************************************************************************
<a name="line-851"></a>-}</span>
<a name="line-852"></a>
<a name="line-853"></a><a name="mkWWstr"></a><span class='hs-definition'>mkWWstr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-854"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-855"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>    <span class='hs-comment'>-- True &lt;=&gt; INLINEABLE pragma on this function defn</span>
<a name="line-856"></a>                   <span class='hs-comment'>-- See Note [Do not unpack class dictionaries]</span>
<a name="line-857"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span>                                <span class='hs-comment'>-- Wrapper args; have their demand info on them</span>
<a name="line-858"></a>                                                <span class='hs-comment'>--  *Includes type variables*</span>
<a name="line-859"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>                        <span class='hs-comment'>-- Is this useful</span>
<a name="line-860"></a>                   <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>                       <span class='hs-comment'>-- Worker args</span>
<a name="line-861"></a>                   <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Wrapper body, lacking the worker call</span>
<a name="line-862"></a>                                                <span class='hs-comment'>-- and without its lambdas</span>
<a name="line-863"></a>                                                <span class='hs-comment'>-- This fn adds the unboxing</span>
<a name="line-864"></a>
<a name="line-865"></a>                   <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- Worker body, lacking the original body of the function,</span>
<a name="line-866"></a>                                                <span class='hs-comment'>-- and lacking its lambdas.</span>
<a name="line-867"></a>                                                <span class='hs-comment'>-- This fn does the reboxing</span>
<a name="line-868"></a><span class='hs-definition'>mkWWstr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>has_inlineable_prag</span> <span class='hs-varid'>args</span>
<a name="line-869"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>args</span>
<a name="line-870"></a>  <span class='hs-keyword'>where</span>
<a name="line-871"></a>    <span class='hs-varid'>go_one</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWWstr_one</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>has_inlineable_prag</span> <span class='hs-varid'>arg</span>
<a name="line-872"></a>
<a name="line-873"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>)</span>
<a name="line-874"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span> <span class='hs-conop'>:</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>useful1</span><span class='hs-layout'>,</span> <span class='hs-varid'>args1</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn1</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go_one</span> <span class='hs-varid'>arg</span>
<a name="line-875"></a>                         <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>useful2</span><span class='hs-layout'>,</span> <span class='hs-varid'>args2</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn2</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>args</span>
<a name="line-876"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>useful1</span> <span class='hs-varop'>||</span> <span class='hs-varid'>useful2</span>
<a name="line-877"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>args1</span> <span class='hs-varop'>++</span> <span class='hs-varid'>args2</span>
<a name="line-878"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn1</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn2</span>
<a name="line-879"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>work_fn1</span> <span class='hs-varop'>.</span> <span class='hs-varid'>work_fn2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-880"></a>
<a name="line-881"></a><a name="mkWWstr_one"></a><span class='hs-comment'>----------------------</span>
<a name="line-882"></a><span class='hs-comment'>-- mkWWstr_one wrap_arg = (useful, work_args, wrap_fn, work_fn)</span>
<a name="line-883"></a><span class='hs-comment'>--   *  wrap_fn assumes wrap_arg is in scope,</span>
<a name="line-884"></a><span class='hs-comment'>--        brings into scope work_args (via cases)</span>
<a name="line-885"></a><span class='hs-comment'>--   * work_fn assumes work_args are in scope, a</span>
<a name="line-886"></a><span class='hs-comment'>--        brings into scope wrap_arg (via lets)</span>
<a name="line-887"></a><span class='hs-comment'>-- See Note [How to do the worker/wrapper split]</span>
<a name="line-888"></a><span class='hs-definition'>mkWWstr_one</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-889"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>    <span class='hs-comment'>-- True &lt;=&gt; INLINEABLE pragma on this function defn</span>
<a name="line-890"></a>                       <span class='hs-comment'>-- See Note [Do not unpack class dictionaries]</span>
<a name="line-891"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span>
<a name="line-892"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-893"></a><span class='hs-definition'>mkWWstr_one</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>has_inlineable_prag</span> <span class='hs-varid'>arg</span>
<a name="line-894"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>arg</span>
<a name="line-895"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>  <span class='hs-varid'>nop_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>)</span>
<a name="line-896"></a>
<a name="line-897"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isAbsDmd</span> <span class='hs-varid'>dmd</span>
<a name="line-898"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>work_fn</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mk_absent_let</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>dmd</span>
<a name="line-899"></a>     <span class='hs-comment'>-- Absent case.  We can't always handle absence for arbitrary</span>
<a name="line-900"></a>     <span class='hs-comment'>-- unlifted types, so we need to choose just the cases we can</span>
<a name="line-901"></a>     <span class='hs-comment'>-- (that's what mk_absent_let does)</span>
<a name="line-902"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn</span><span class='hs-layout'>)</span>
<a name="line-903"></a>
<a name="line-904"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Unbox</span> <span class='hs-varid'>dcpc</span> <span class='hs-varid'>cs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>wantToUnbox</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>has_inlineable_prag</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varid'>dmd</span>
<a name="line-905"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unbox_one</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>cs</span> <span class='hs-varid'>dcpc</span>
<a name="line-906"></a>
<a name="line-907"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-comment'>-- Other cases</span>
<a name="line-908"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>nop_fn</span><span class='hs-layout'>)</span>
<a name="line-909"></a>
<a name="line-910"></a>  <span class='hs-keyword'>where</span>
<a name="line-911"></a>    <span class='hs-varid'>arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>arg</span>
<a name="line-912"></a>    <span class='hs-varid'>dmd</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idDemandInfo</span> <span class='hs-varid'>arg</span>
<a name="line-913"></a>
<a name="line-914"></a><a name="unbox_one"></a><span class='hs-definition'>unbox_one</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span>
<a name="line-915"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span>
<a name="line-916"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataConPatContext</span>
<a name="line-917"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-918"></a><span class='hs-definition'>unbox_one</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>cs</span>
<a name="line-919"></a>          <span class='hs-conid'>DataConPatContext</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dcpc_dc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dc</span><span class='hs-layout'>,</span> <span class='hs-varid'>dcpc_tc_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc_args</span>
<a name="line-920"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>dcpc_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co</span> <span class='hs-layout'>}</span>
<a name="line-921"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>case_bndr_uniq</span><span class='hs-conop'>:</span><span class='hs-varid'>pat_bndrs_uniqs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniquesM</span>
<a name="line-922"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ex_name_fss</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>getOccFS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>dataConExTyCoVars</span> <span class='hs-varid'>dc</span>
<a name="line-923"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>ex_tvs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_ids</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-924"></a>               <span class='hs-varid'>dataConRepFSInstPat</span> <span class='hs-layout'>(</span><span class='hs-varid'>ex_name_fss</span> <span class='hs-varop'>++</span> <span class='hs-varid'>repeat</span> <span class='hs-varid'>ww_prefix</span><span class='hs-layout'>)</span> <span class='hs-varid'>pat_bndrs_uniqs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idMult</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>tc_args</span>
<a name="line-925"></a>             <span class='hs-varid'>arg_ids'</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWithEqual</span> <span class='hs-str'>"unbox_one"</span> <span class='hs-varid'>setIdDemandInfo</span> <span class='hs-varid'>arg_ids</span> <span class='hs-varid'>cs</span>
<a name="line-926"></a>             <span class='hs-varid'>unbox_fn</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkUnpackCase</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span> <span class='hs-layout'>(</span><span class='hs-varid'>idMult</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-varid'>case_bndr_uniq</span>
<a name="line-927"></a>                                      <span class='hs-varid'>dc</span> <span class='hs-layout'>(</span><span class='hs-varid'>ex_tvs'</span> <span class='hs-varop'>++</span> <span class='hs-varid'>arg_ids'</span><span class='hs-layout'>)</span>
<a name="line-928"></a>             <span class='hs-varid'>arg_no_unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapStableUnfolding</span> <span class='hs-varid'>arg</span>
<a name="line-929"></a>                          <span class='hs-comment'>-- See Note [Zap unfolding when beta-reducing]</span>
<a name="line-930"></a>                          <span class='hs-comment'>-- in GHC.Core.Opt.Simplify; and see #13890</span>
<a name="line-931"></a>             <span class='hs-varid'>rebox_fn</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>arg_no_unf</span> <span class='hs-varid'>con_app</span><span class='hs-layout'>)</span>
<a name="line-932"></a>             <span class='hs-varid'>con_app</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>tc_args</span> <span class='hs-layout'>(</span><span class='hs-varid'>ex_tvs'</span> <span class='hs-varop'>++</span> <span class='hs-varid'>arg_ids'</span><span class='hs-layout'>)</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span>
<a name="line-933"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>worker_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrap_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkWWstr</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-conid'>False</span> <span class='hs-layout'>(</span><span class='hs-varid'>ex_tvs'</span> <span class='hs-varop'>++</span> <span class='hs-varid'>arg_ids'</span><span class='hs-layout'>)</span>
<a name="line-934"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>worker_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>unbox_fn</span> <span class='hs-varop'>.</span> <span class='hs-varid'>wrap_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>work_fn</span> <span class='hs-varop'>.</span> <span class='hs-varid'>rebox_fn</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-935"></a>                          <span class='hs-comment'>-- Don't pass the arg, rebox instead</span>
<a name="line-936"></a>
<a name="line-937"></a><a name="nop_fn"></a><span class='hs-comment'>----------------------</span>
<a name="line-938"></a><span class='hs-definition'>nop_fn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-939"></a><span class='hs-definition'>nop_fn</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body</span>
<a name="line-940"></a>
<a name="line-941"></a><a name="addDataConStrictness"></a><span class='hs-definition'>addDataConStrictness</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span>
<a name="line-942"></a><span class='hs-comment'>-- See Note [Add demands for strict constructors]</span>
<a name="line-943"></a><span class='hs-definition'>addDataConStrictness</span> <span class='hs-varid'>con</span> <span class='hs-varid'>ds</span>
<a name="line-944"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dataConWrapId_maybe</span> <span class='hs-varid'>con</span>
<a name="line-945"></a>  <span class='hs-comment'>-- DataCon worker=wrapper. Implies no strict fields, so nothing to do</span>
<a name="line-946"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ds</span>
<a name="line-947"></a><span class='hs-definition'>addDataConStrictness</span> <span class='hs-varid'>con</span> <span class='hs-varid'>ds</span>
<a name="line-948"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWithEqual</span> <span class='hs-str'>"addDataConStrictness"</span> <span class='hs-varid'>add</span> <span class='hs-varid'>ds</span> <span class='hs-varid'>strs</span>
<a name="line-949"></a>  <span class='hs-keyword'>where</span>
<a name="line-950"></a>    <span class='hs-varid'>strs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepStrictness</span> <span class='hs-varid'>con</span>
<a name="line-951"></a>    <span class='hs-varid'>add</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>str</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isMarkedStrict</span> <span class='hs-varid'>str</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>strictifyDmd</span> <span class='hs-varid'>dmd</span>
<a name="line-952"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd</span>
<a name="line-953"></a>
<a name="line-954"></a><span class='hs-comment'>{- Note [How to do the worker/wrapper split]
<a name="line-955"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-956"></a>The worker-wrapper transformation, mkWWstr_one, takes into account
<a name="line-957"></a>several possibilities to decide if the function is worthy for
<a name="line-958"></a>splitting:
<a name="line-959"></a>
<a name="line-960"></a>1. If an argument is absent, it would be silly to pass it to
<a name="line-961"></a>   the worker.  Hence the isAbsDmd case.  This case must come
<a name="line-962"></a>   first because a demand like &lt;S,A&gt; or &lt;B,A&gt; is possible.
<a name="line-963"></a>   E.g. &lt;B,A&gt; comes from a function like
<a name="line-964"></a>       f x = error "urk"
<a name="line-965"></a>   and &lt;S,A&gt; can come from Note [Add demands for strict constructors]
<a name="line-966"></a>
<a name="line-967"></a>2. If the argument is evaluated strictly, and we can split the
<a name="line-968"></a>   product demand (splitProdDmd_maybe), then unbox it and w/w its
<a name="line-969"></a>   pieces.  For example
<a name="line-970"></a>
<a name="line-971"></a>    f :: (Int, Int) -&gt; Int
<a name="line-972"></a>    f p = (case p of (a,b) -&gt; a) + 1
<a name="line-973"></a>  is split to
<a name="line-974"></a>    f :: (Int, Int) -&gt; Int
<a name="line-975"></a>    f p = case p of (a,b) -&gt; $wf a
<a name="line-976"></a>
<a name="line-977"></a>    $wf :: Int -&gt; Int
<a name="line-978"></a>    $wf a = a + 1
<a name="line-979"></a>
<a name="line-980"></a>  and
<a name="line-981"></a>    g :: Bool -&gt; (Int, Int) -&gt; Int
<a name="line-982"></a>    g c p = case p of (a,b) -&gt;
<a name="line-983"></a>               if c then a else b
<a name="line-984"></a>  is split to
<a name="line-985"></a>   g c p = case p of (a,b) -&gt; $gw c a b
<a name="line-986"></a>   $gw c a b = if c then a else b
<a name="line-987"></a>
<a name="line-988"></a>2a But do /not/ split if the components are not used; that is, the
<a name="line-989"></a>   usage is just 'Used' rather than 'UProd'. In this case
<a name="line-990"></a>   splitProdDmd_maybe returns Nothing.  Otherwise we risk decomposing
<a name="line-991"></a>   a massive tuple which is barely used.  Example:
<a name="line-992"></a>
<a name="line-993"></a>        f :: ((Int,Int) -&gt; String) -&gt; (Int,Int) -&gt; a
<a name="line-994"></a>        f g pr = error (g pr)
<a name="line-995"></a>
<a name="line-996"></a>        main = print (f fst (1, error "no"))
<a name="line-997"></a>
<a name="line-998"></a>   Here, f does not take 'pr' apart, and it's stupid to do so.
<a name="line-999"></a>   Imagine that it had millions of fields. This actually happened
<a name="line-1000"></a>   in GHC itself where the tuple was DynFlags
<a name="line-1001"></a>
<a name="line-1002"></a>3. A plain 'seqDmd', which is head-strict with usage UHead, can't
<a name="line-1003"></a>   be split by splitProdDmd_maybe.  But we want it to behave just
<a name="line-1004"></a>   like U(AAAA) for suitable number of absent demands. So we have
<a name="line-1005"></a>   a special case for it, with arity coming from the data constructor.
<a name="line-1006"></a>
<a name="line-1007"></a>Note [Worker-wrapper for bottoming functions]
<a name="line-1008"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1009"></a>We used not to split if the result is bottom.
<a name="line-1010"></a>[Justification:  there's no efficiency to be gained.]
<a name="line-1011"></a>
<a name="line-1012"></a>But it's sometimes bad not to make a wrapper.  Consider
<a name="line-1013"></a>        fw = \x# -&gt; let x = I# x# in case e of
<a name="line-1014"></a>                                        p1 -&gt; error_fn x
<a name="line-1015"></a>                                        p2 -&gt; error_fn x
<a name="line-1016"></a>                                        p3 -&gt; the real stuff
<a name="line-1017"></a>The re-boxing code won't go away unless error_fn gets a wrapper too.
<a name="line-1018"></a>[We don't do reboxing now, but in general it's better to pass an
<a name="line-1019"></a>unboxed thing to f, and have it reboxed in the error cases....]
<a name="line-1020"></a>
<a name="line-1021"></a>Note [Record evaluated-ness in worker/wrapper]
<a name="line-1022"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1023"></a>Suppose we have
<a name="line-1024"></a>
<a name="line-1025"></a>   data T = MkT !Int Int
<a name="line-1026"></a>
<a name="line-1027"></a>   f :: T -&gt; T
<a name="line-1028"></a>   f x = e
<a name="line-1029"></a>
<a name="line-1030"></a>and f's is strict, and has the CPR property.  The we are going to generate
<a name="line-1031"></a>this w/w split
<a name="line-1032"></a>
<a name="line-1033"></a>   f x = case x of
<a name="line-1034"></a>           MkT x1 x2 -&gt; case $wf x1 x2 of
<a name="line-1035"></a>                           (# r1, r2 #) -&gt; MkT r1 r2
<a name="line-1036"></a>
<a name="line-1037"></a>   $wfw x1 x2 = let x = MkT x1 x2 in
<a name="line-1038"></a>                case e of
<a name="line-1039"></a>                  MkT r1 r2 -&gt; (# r1, r2 #)
<a name="line-1040"></a>
<a name="line-1041"></a>Note that
<a name="line-1042"></a>
<a name="line-1043"></a>* In the worker $wf, inside 'e' we can be sure that x1 will be
<a name="line-1044"></a>  evaluated (it came from unpacking the argument MkT.  But that's no
<a name="line-1045"></a>  immediately apparent in $wf
<a name="line-1046"></a>
<a name="line-1047"></a>* In the wrapper 'f', which we'll inline at call sites, we can be sure
<a name="line-1048"></a>  that 'r1' has been evaluated (because it came from unpacking the result
<a name="line-1049"></a>  MkT.  But that is not immediately apparent from the wrapper code.
<a name="line-1050"></a>
<a name="line-1051"></a>Missing these facts isn't unsound, but it loses possible future
<a name="line-1052"></a>opportunities for optimisation.
<a name="line-1053"></a>
<a name="line-1054"></a>Solution: use setCaseBndrEvald when creating
<a name="line-1055"></a> (A) The arg binders x1,x2 in mkWstr_one
<a name="line-1056"></a>         See #13077, test T13077
<a name="line-1057"></a> (B) The result binders r1,r2 in mkWWcpr_help
<a name="line-1058"></a>         See Trace #13077, test T13077a
<a name="line-1059"></a>         And #13027 comment:20, item (4)
<a name="line-1060"></a>to record that the relevant binder is evaluated.
<a name="line-1061"></a>
<a name="line-1062"></a>
<a name="line-1063"></a>************************************************************************
<a name="line-1064"></a>*                                                                      *
<a name="line-1065"></a>         Type scrutiny that is specific to demand analysis
<a name="line-1066"></a>*                                                                      *
<a name="line-1067"></a>************************************************************************
<a name="line-1068"></a>-}</span>
<a name="line-1069"></a>
<a name="line-1070"></a><a name="findTypeShape"></a><span class='hs-definition'>findTypeShape</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeShape</span>
<a name="line-1071"></a><span class='hs-comment'>-- Uncover the arrow and product shape of a type</span>
<a name="line-1072"></a><span class='hs-comment'>-- The data type TypeShape is defined in GHC.Types.Demand</span>
<a name="line-1073"></a><span class='hs-comment'>-- See Note [Trimming a demand to a type] in GHC.Core.Opt.DmdAnal</span>
<a name="line-1074"></a><span class='hs-definition'>findTypeShape</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-1075"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>setRecTcMaxBound</span> <span class='hs-num'>2</span> <span class='hs-varid'>initRecTc</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span>
<a name="line-1076"></a>       <span class='hs-comment'>-- You might think this bound of 2 is low, but actually</span>
<a name="line-1077"></a>       <span class='hs-comment'>-- I think even 1 would be fine.  This only bites for recursive</span>
<a name="line-1078"></a>       <span class='hs-comment'>-- product types, which are rare, and we really don't want</span>
<a name="line-1079"></a>       <span class='hs-comment'>-- to look deep into such products -- see #18034</span>
<a name="line-1080"></a>  <span class='hs-keyword'>where</span>
<a name="line-1081"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>rec_tc</span> <span class='hs-varid'>ty</span>
<a name="line-1082"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-1083"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TsFun</span> <span class='hs-layout'>(</span><span class='hs-varid'>go</span> <span class='hs-varid'>rec_tc</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>
<a name="line-1084"></a>
<a name="line-1085"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-1086"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_tc</span> <span class='hs-varid'>rec_tc</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tc_args</span>
<a name="line-1087"></a>
<a name="line-1088"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitForAllTyCoVar_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-1089"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>rec_tc</span> <span class='hs-varid'>ty'</span>
<a name="line-1090"></a>
<a name="line-1091"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1092"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TsUnk</span>
<a name="line-1093"></a>
<a name="line-1094"></a>    <span class='hs-varid'>go_tc</span> <span class='hs-varid'>rec_tc</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tc_args</span>
<a name="line-1095"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>topReduceTyFamApp_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tc_args</span>
<a name="line-1096"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>rec_tc</span> <span class='hs-varid'>rhs</span>
<a name="line-1097"></a>
<a name="line-1098"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>con</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConSingleAlgDataCon_maybe</span> <span class='hs-varid'>tc</span>
<a name="line-1099"></a>       <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>rec_tc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isTupleTyCon</span> <span class='hs-varid'>tc</span>
<a name="line-1100"></a>                        <span class='hs-keyword'>then</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>rec_tc</span>
<a name="line-1101"></a>                        <span class='hs-keyword'>else</span> <span class='hs-varid'>checkRecTc</span> <span class='hs-varid'>rec_tc</span> <span class='hs-varid'>tc</span>
<a name="line-1102"></a>         <span class='hs-comment'>-- We treat tuples specially because they can't cause loops.</span>
<a name="line-1103"></a>         <span class='hs-comment'>-- Maybe we should do so in checkRecTc.</span>
<a name="line-1104"></a>         <span class='hs-comment'>-- The use of 'dubiousDataConInstArgTys' is OK, since this</span>
<a name="line-1105"></a>         <span class='hs-comment'>-- function performs no substitution at all, hence the uniques</span>
<a name="line-1106"></a>         <span class='hs-comment'>-- don't matter.</span>
<a name="line-1107"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TsProd</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>go</span> <span class='hs-varid'>rec_tc</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>dubiousDataConInstArgTys</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1108"></a>
<a name="line-1109"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>instNewTyCon_maybe</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tc_args</span>
<a name="line-1110"></a>       <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>rec_tc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>checkRecTc</span> <span class='hs-varid'>rec_tc</span> <span class='hs-varid'>tc</span>
<a name="line-1111"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>rec_tc</span> <span class='hs-varid'>ty'</span>
<a name="line-1112"></a>
<a name="line-1113"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1114"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TsUnk</span>
<a name="line-1115"></a>
<a name="line-1116"></a><a name="dubiousDataConInstArgTys"></a><span class='hs-comment'>-- | Exactly 'dataConInstArgTys', but lacks the (ASSERT'ed) precondition that</span>
<a name="line-1117"></a><span class='hs-comment'>-- the 'DataCon' may not have existentials. The lack of cloning the existentials</span>
<a name="line-1118"></a><span class='hs-comment'>-- compared to 'dataConInstExAndArgVars' makes this function \"dubious\";</span>
<a name="line-1119"></a><span class='hs-comment'>-- only use it where type variables aren't substituted for!</span>
<a name="line-1120"></a><span class='hs-definition'>dubiousDataConInstArgTys</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-1121"></a><span class='hs-definition'>dubiousDataConInstArgTys</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>tc_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_tys</span>
<a name="line-1122"></a>  <span class='hs-keyword'>where</span>
<a name="line-1123"></a>    <span class='hs-varid'>univ_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConUnivTyVars</span> <span class='hs-varid'>dc</span>
<a name="line-1124"></a>    <span class='hs-varid'>ex_tvs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConExTyCoVars</span> <span class='hs-varid'>dc</span>
<a name="line-1125"></a>    <span class='hs-varid'>subst</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendTCvInScopeList</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipTvSubst</span> <span class='hs-varid'>univ_tvs</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span> <span class='hs-varid'>ex_tvs</span>
<a name="line-1126"></a>    <span class='hs-varid'>arg_tys</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varop'>.</span> <span class='hs-varid'>scaledThing</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConRepArgTys</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span>
<a name="line-1127"></a>
<a name="line-1128"></a><span class='hs-comment'>{-
<a name="line-1129"></a>************************************************************************
<a name="line-1130"></a>*                                                                      *
<a name="line-1131"></a>\subsection{CPR stuff}
<a name="line-1132"></a>*                                                                      *
<a name="line-1133"></a>************************************************************************
<a name="line-1134"></a>
<a name="line-1135"></a>
<a name="line-1136"></a>@mkWWcpr@ takes the worker/wrapper pair produced from the strictness
<a name="line-1137"></a>info and adds in the CPR transformation.  The worker returns an
<a name="line-1138"></a>unboxed tuple containing non-CPR components.  The wrapper takes this
<a name="line-1139"></a>tuple and re-produces the correct structured output.
<a name="line-1140"></a>
<a name="line-1141"></a>The non-CPR results appear ordered in the unboxed tuple as if by a
<a name="line-1142"></a>left-to-right traversal of the result structure.
<a name="line-1143"></a>-}</span>
<a name="line-1144"></a>
<a name="line-1145"></a><a name="mkWWcpr"></a><span class='hs-definition'>mkWWcpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-1146"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-1147"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>                              <span class='hs-comment'>-- function body type</span>
<a name="line-1148"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cpr</span>                               <span class='hs-comment'>-- CPR analysis results</span>
<a name="line-1149"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>                     <span class='hs-comment'>-- Is w/w'ing useful?</span>
<a name="line-1150"></a>                   <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- New wrapper</span>
<a name="line-1151"></a>                   <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- New worker</span>
<a name="line-1152"></a>                   <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>                     <span class='hs-comment'>-- Type of worker's body</span>
<a name="line-1153"></a>
<a name="line-1154"></a><span class='hs-definition'>mkWWcpr</span> <span class='hs-varid'>opt_CprAnal</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>body_ty</span> <span class='hs-varid'>cpr</span>
<a name="line-1155"></a>    <span class='hs-comment'>-- CPR explicitly turned off (or in -O0)</span>
<a name="line-1156"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>opt_CprAnal</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>body_ty</span><span class='hs-layout'>)</span>
<a name="line-1157"></a>    <span class='hs-comment'>-- CPR is turned on by default for -O and O2</span>
<a name="line-1158"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1159"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>asConCpr</span> <span class='hs-varid'>cpr</span> <span class='hs-keyword'>of</span>
<a name="line-1160"></a>       <span class='hs-conid'>Nothing</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>body_ty</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- No CPR info</span>
<a name="line-1161"></a>       <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>con_tag</span><span class='hs-layout'>,</span> <span class='hs-sel'>_cprs</span><span class='hs-layout'>)</span>
<a name="line-1162"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>dcpc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitResultType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>con_tag</span> <span class='hs-varid'>body_ty</span>
<a name="line-1163"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkWWcpr_help</span> <span class='hs-varid'>dcpc</span>
<a name="line-1164"></a>         <span class='hs-keyglyph'>|</span>  <span class='hs-varid'>otherwise</span>
<a name="line-1165"></a>         <span class='hs-comment'>-- See Note [non-algebraic or open body type warning]</span>
<a name="line-1166"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"mkWWcpr: non-algebraic or open body type"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>body_ty</span> <span class='hs-layout'>)</span>
<a name="line-1167"></a>            <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>body_ty</span><span class='hs-layout'>)</span>
<a name="line-1168"></a>
<a name="line-1169"></a><a name="mkWWcpr_help"></a><span class='hs-definition'>mkWWcpr_help</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataConPatContext</span>
<a name="line-1170"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>
<a name="line-1171"></a>
<a name="line-1172"></a><span class='hs-definition'>mkWWcpr_help</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataConPatContext</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dcpc_dc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dc</span><span class='hs-layout'>,</span> <span class='hs-varid'>dcpc_tc_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc_args</span>
<a name="line-1173"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>dcpc_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1174"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg_ty</span><span class='hs-keyglyph'>]</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dataConInstArgTys</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>tc_args</span> <span class='hs-comment'>-- NB: No existentials!</span>
<a name="line-1175"></a>  <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>str_mark</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dataConRepStrictness</span> <span class='hs-varid'>dc</span>
<a name="line-1176"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isUnliftedType</span> <span class='hs-layout'>(</span><span class='hs-varid'>scaledThing</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-1177"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isLinear</span> <span class='hs-varid'>arg_ty</span>
<a name="line-1178"></a>        <span class='hs-comment'>-- Special case when there is a single result of unlifted, linear, type</span>
<a name="line-1179"></a>        <span class='hs-comment'>--</span>
<a name="line-1180"></a>        <span class='hs-comment'>-- Wrapper:     case (..call worker..) of x -&gt; C x</span>
<a name="line-1181"></a>        <span class='hs-comment'>-- Worker:      case (   ..body..    ) of C x -&gt; x</span>
<a name="line-1182"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>work_uniq</span> <span class='hs-conop'>:</span> <span class='hs-varid'>arg_uniq</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniquesM</span>
<a name="line-1183"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_id</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_ww_local</span> <span class='hs-varid'>arg_uniq</span> <span class='hs-varid'>str_mark</span> <span class='hs-varid'>arg_ty</span>
<a name="line-1184"></a>             <span class='hs-varid'>con_app</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>tc_args</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg_id</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span>
<a name="line-1185"></a>
<a name="line-1186"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-conid'>True</span>
<a name="line-1187"></a>                <span class='hs-layout'>,</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>wkr_call</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkDefaultCase</span> <span class='hs-varid'>wkr_call</span> <span class='hs-varid'>arg_id</span> <span class='hs-varid'>con_app</span>
<a name="line-1188"></a>                <span class='hs-layout'>,</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>body</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkUnpackCase</span> <span class='hs-varid'>body</span> <span class='hs-varid'>co</span> <span class='hs-conid'>One</span> <span class='hs-varid'>work_uniq</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg_id</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>arg_id</span><span class='hs-layout'>)</span>
<a name="line-1189"></a>                                <span class='hs-comment'>-- varToCoreExpr important here: arg can be a coercion</span>
<a name="line-1190"></a>                                <span class='hs-comment'>-- Lacking this caused #10658</span>
<a name="line-1191"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>scaledThing</span> <span class='hs-varid'>arg_ty</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1192"></a>
<a name="line-1193"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-comment'>-- The general case</span>
<a name="line-1194"></a>        <span class='hs-comment'>-- Wrapper: case (..call worker..) of (# a, b #) -&gt; C a b</span>
<a name="line-1195"></a>        <span class='hs-comment'>-- Worker:  case (   ...body...  ) of C a b -&gt; (# a, b #)</span>
<a name="line-1196"></a>        <span class='hs-comment'>--</span>
<a name="line-1197"></a>        <span class='hs-comment'>-- Remark on linearity: in both the case of the wrapper and the worker,</span>
<a name="line-1198"></a>        <span class='hs-comment'>-- we build a linear case. All the multiplicity information is kept in</span>
<a name="line-1199"></a>        <span class='hs-comment'>-- the constructors (both C and (#, #)). In particular (#,#) is</span>
<a name="line-1200"></a>        <span class='hs-comment'>-- parametrised by the multiplicity of its fields. Specifically, in this</span>
<a name="line-1201"></a>        <span class='hs-comment'>-- instance, the multiplicity of the fields of (#,#) is chosen to be the</span>
<a name="line-1202"></a>        <span class='hs-comment'>-- same as those of C.</span>
<a name="line-1203"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>work_uniq</span> <span class='hs-conop'>:</span> <span class='hs-varid'>wild_uniq</span> <span class='hs-conop'>:</span> <span class='hs-varid'>pat_bndrs_uniqs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniquesM</span>
<a name="line-1204"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>case_mult</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>One</span> <span class='hs-comment'>-- see above</span>
<a name="line-1205"></a>             <span class='hs-layout'>(</span><span class='hs-sel'>_exs</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_ids</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-1206"></a>               <span class='hs-varid'>dataConRepFSInstPat</span> <span class='hs-layout'>(</span><span class='hs-varid'>repeat</span> <span class='hs-varid'>ww_prefix</span><span class='hs-layout'>)</span> <span class='hs-varid'>pat_bndrs_uniqs</span> <span class='hs-varid'>case_mult</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>tc_args</span>
<a name="line-1207"></a>             <span class='hs-varid'>wrap_wild</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_ww_local</span> <span class='hs-varid'>wild_uniq</span> <span class='hs-conid'>MarkedStrict</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>case_mult</span> <span class='hs-varid'>ubx_tup_ty</span><span class='hs-layout'>)</span>
<a name="line-1208"></a>             <span class='hs-varid'>ubx_tup_ty</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprType</span> <span class='hs-varid'>ubx_tup_app</span>
<a name="line-1209"></a>             <span class='hs-varid'>ubx_tup_app</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCoreUbxTup</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>arg_ids</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>arg_ids</span><span class='hs-layout'>)</span>
<a name="line-1210"></a>             <span class='hs-varid'>con_app</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>tc_args</span> <span class='hs-varid'>arg_ids</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span>
<a name="line-1211"></a>             <span class='hs-varid'>tup_con</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tupleDataCon</span> <span class='hs-conid'>Unboxed</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>arg_ids</span><span class='hs-layout'>)</span>
<a name="line-1212"></a>
<a name="line-1213"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>MASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>null</span> <span class='hs-sel'>_exs</span> <span class='hs-layout'>)</span> <span class='hs-comment'>-- Should have been caught by splitResultType_maybe</span>
<a name="line-1214"></a>
<a name="line-1215"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span>
<a name="line-1216"></a>                <span class='hs-layout'>,</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>wkr_call</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkSingleAltCase</span> <span class='hs-varid'>wkr_call</span> <span class='hs-varid'>wrap_wild</span>
<a name="line-1217"></a>                                                <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>tup_con</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_ids</span> <span class='hs-varid'>con_app</span>
<a name="line-1218"></a>                <span class='hs-layout'>,</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>body</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkUnpackCase</span> <span class='hs-varid'>body</span> <span class='hs-varid'>co</span> <span class='hs-varid'>case_mult</span> <span class='hs-varid'>work_uniq</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>arg_ids</span> <span class='hs-varid'>ubx_tup_app</span>
<a name="line-1219"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>ubx_tup_ty</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1220"></a>
<a name="line-1221"></a><a name="mkUnpackCase"></a><span class='hs-definition'>mkUnpackCase</span> <span class='hs-keyglyph'>::</span>  <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unique</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1222"></a><span class='hs-comment'>-- (mkUnpackCase e co uniq Con args body)</span>
<a name="line-1223"></a><span class='hs-comment'>--      returns</span>
<a name="line-1224"></a><span class='hs-comment'>-- case e |&gt; co of bndr { Con args -&gt; body }</span>
<a name="line-1225"></a>
<a name="line-1226"></a><span class='hs-definition'>mkUnpackCase</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>tickish</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span> <span class='hs-varid'>mult</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-varid'>body</span>   <span class='hs-comment'>-- See Note [Profiling and unpacking]</span>
<a name="line-1227"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>tickish</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkUnpackCase</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span> <span class='hs-varid'>mult</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1228"></a><span class='hs-definition'>mkUnpackCase</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>co</span> <span class='hs-varid'>mult</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>boxing_con</span> <span class='hs-varid'>unpk_args</span> <span class='hs-varid'>body</span>
<a name="line-1229"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSingleAltCase</span> <span class='hs-varid'>casted_scrut</span> <span class='hs-varid'>bndr</span>
<a name="line-1230"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>boxing_con</span><span class='hs-layout'>)</span> <span class='hs-varid'>unpk_args</span> <span class='hs-varid'>body</span>
<a name="line-1231"></a>  <span class='hs-keyword'>where</span>
<a name="line-1232"></a>    <span class='hs-varid'>casted_scrut</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scrut</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>co</span>
<a name="line-1233"></a>    <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_ww_local</span> <span class='hs-varid'>uniq</span> <span class='hs-conid'>MarkedStrict</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>mult</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>casted_scrut</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1234"></a>      <span class='hs-comment'>-- An unpacking case can always be chosen linear, because the variables</span>
<a name="line-1235"></a>      <span class='hs-comment'>-- are always passed to a constructor. This limits the</span>
<a name="line-1236"></a><span class='hs-comment'>{-
<a name="line-1237"></a>Note [non-algebraic or open body type warning]
<a name="line-1238"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1239"></a>
<a name="line-1240"></a>There are a few cases where the W/W transformation is told that something
<a name="line-1241"></a>returns a constructor, but the type at hand doesn't really match this. One
<a name="line-1242"></a>real-world example involves unsafeCoerce:
<a name="line-1243"></a>  foo = IO a
<a name="line-1244"></a>  foo = unsafeCoerce c_exit
<a name="line-1245"></a>  foreign import ccall "c_exit" c_exit :: IO ()
<a name="line-1246"></a>Here CPR will tell you that `foo` returns a () constructor for sure, but trying
<a name="line-1247"></a>to create a worker/wrapper for type `a` obviously fails.
<a name="line-1248"></a>(This was a real example until ee8e792  in libraries/base.)
<a name="line-1249"></a>
<a name="line-1250"></a>It does not seem feasible to avoid all such cases already in the analyser (and
<a name="line-1251"></a>after all, the analysis is not really wrong), so we simply do nothing here in
<a name="line-1252"></a>mkWWcpr. But we still want to emit warning with -DDEBUG, to hopefully catch
<a name="line-1253"></a>other cases where something went avoidably wrong.
<a name="line-1254"></a>
<a name="line-1255"></a>This warning also triggers for the stream fusion library within `text`.
<a name="line-1256"></a>We can'easily W/W constructed results like `Stream` because we have no simple
<a name="line-1257"></a>way to express existential types in the worker's type signature.
<a name="line-1258"></a>
<a name="line-1259"></a>Note [Profiling and unpacking]
<a name="line-1260"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1261"></a>If the original function looked like
<a name="line-1262"></a>        f = \ x -&gt; {-# SCC "foo" #-} E
<a name="line-1263"></a>
<a name="line-1264"></a>then we want the CPR'd worker to look like
<a name="line-1265"></a>        \ x -&gt; {-# SCC "foo" #-} (case E of I# x -&gt; x)
<a name="line-1266"></a>and definitely not
<a name="line-1267"></a>        \ x -&gt; case ({-# SCC "foo" #-} E) of I# x -&gt; x)
<a name="line-1268"></a>
<a name="line-1269"></a>This transform doesn't move work or allocation
<a name="line-1270"></a>from one cost centre to another.
<a name="line-1271"></a>
<a name="line-1272"></a>Later [SDM]: presumably this is because we want the simplifier to
<a name="line-1273"></a>eliminate the case, and the scc would get in the way?  I'm ok with
<a name="line-1274"></a>including the case itself in the cost centre, since it is morally
<a name="line-1275"></a>part of the function (post transformation) anyway.
<a name="line-1276"></a>
<a name="line-1277"></a>
<a name="line-1278"></a>************************************************************************
<a name="line-1279"></a>*                                                                      *
<a name="line-1280"></a>\subsection{Utilities}
<a name="line-1281"></a>*                                                                      *
<a name="line-1282"></a>************************************************************************
<a name="line-1283"></a>
<a name="line-1284"></a>Note [Absent errors]
<a name="line-1285"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-1286"></a>Consider
<a name="line-1287"></a>  data T = MkT [Int] [Int] ![Int]
<a name="line-1288"></a>  f :: T -&gt; Int# -&gt; blah
<a name="line-1289"></a>  f ps w = case ps of MkT xs _ _ -&gt; &lt;body mentioning xs&gt;
<a name="line-1290"></a>Then f gets a strictness sig of &lt;S(L,A,A)&gt;&lt;A&gt;. We make worker $wf thus:
<a name="line-1291"></a>
<a name="line-1292"></a>$wf :: [Int] -&gt; blah
<a name="line-1293"></a>$wf xs = case ps of MkT xs _ _ -&gt; &lt;body mentioning xs&gt;
<a name="line-1294"></a>  where
<a name="line-1295"></a>    ys = absentError "ys :: [Int]"
<a name="line-1296"></a>    zs = LitRubbish True
<a name="line-1297"></a>    ps = MkT xs ys zs
<a name="line-1298"></a>    w  = 0#
<a name="line-1299"></a>
<a name="line-1300"></a>We make a let-binding for Absent arguments, such as ys and w, that are not even
<a name="line-1301"></a>passed to the worker. They should, of course, never be used. We distinguish four
<a name="line-1302"></a>cases:
<a name="line-1303"></a>
<a name="line-1304"></a>1. Ordinary boxed, lifted arguments, like 'ys' We make a new binding for Ids
<a name="line-1305"></a>   that are marked absent, thus
<a name="line-1306"></a>      let ys = absentError "ys :: [Int]"
<a name="line-1307"></a>   The idea is that this binding will never be used; but if it
<a name="line-1308"></a>   buggily is used we'll get a runtime error message.
<a name="line-1309"></a>
<a name="line-1310"></a>2. Boxed, lifted types, with a strict demand, like 'zs'.  You may ask: how the
<a name="line-1311"></a>   demand be both absent and strict?  That's exactly what happens for 'zs': it
<a name="line-1312"></a>   is not used, so its demand is Absent, but then during w/w, in
<a name="line-1313"></a>   addDataConStrictness, we strictify the demand.  So it gets cardinality C_10,
<a name="line-1314"></a>   the empty interval.
<a name="line-1315"></a>
<a name="line-1316"></a>   We don't want to use an error-thunk for 'zs' because MkT's third argument has
<a name="line-1317"></a>   a bang, and hence should be always evaluated. This turned out to be
<a name="line-1318"></a>   important when fixing #16970, which establishes the invariant that strict
<a name="line-1319"></a>   constructor arguments are always evaluated. So we use LitRubbish instead
<a name="line-1320"></a>   of an error thunk -- see #19133.
<a name="line-1321"></a>
<a name="line-1322"></a>   These first two cases are distinguished by isStrictDmd in lifted_rhs.
<a name="line-1323"></a>
<a name="line-1324"></a>3. Unboxed types, like 'w', with a type like Float#, Int#. Coping with absence
<a name="line-1325"></a>   for unboxed types is important; see, for example, #4306 and #15627.  We
<a name="line-1326"></a>   simply find a suitable literal, using Literal.absentLiteralOf.  We don't have
<a name="line-1327"></a>   literals for every primitive type, so the function is partial.
<a name="line-1328"></a>
<a name="line-1329"></a>4. Boxed, unlifted types, like (Array# t).  We can't use absentError because
<a name="line-1330"></a>   unlifted bindings ares strict.  So we use LitRubbish, which we need to apply
<a name="line-1331"></a>   to the required type.
<a name="line-1332"></a>
<a name="line-1333"></a>Case (2) and (4) crucially use LitRubbish as the placeholder: see Note [Rubbish
<a name="line-1334"></a>literals] in GHC.Types.Literal.  We could do that in case (1) as well, but we
<a name="line-1335"></a>get slightly better self-checking with an error thunk.
<a name="line-1336"></a>
<a name="line-1337"></a>Suppose we use LitRubbish and absence analysis is Wrong, so that the "absent"
<a name="line-1338"></a>value is used after all.  Then in case (2) we could get a seg-fault, because we
<a name="line-1339"></a>may have replaced, say, a [Either Int Bool] by (), and that will fail if we do
<a name="line-1340"></a>case analysis on it.  Similarly with boxed unlifted types, case (4).
<a name="line-1341"></a>
<a name="line-1342"></a>In case (3), if absence analysis is wrong we could conceivably get an exception,
<a name="line-1343"></a>from a divide-by-zero with the absent value.  But it's very unlikely.
<a name="line-1344"></a>
<a name="line-1345"></a>Only in case (1) can we guarantee a civilised runtime error.  Not much we can do
<a name="line-1346"></a>about this; we really rely on absence analysis to be correct.
<a name="line-1347"></a>
<a name="line-1348"></a>
<a name="line-1349"></a>Historical note: I did try the experiment of using an error thunk for unlifted
<a name="line-1350"></a>things too, relying on the simplifier to drop it as dead code.  But this is
<a name="line-1351"></a>fragile
<a name="line-1352"></a>
<a name="line-1353"></a> - It fails when profiling is on, which disables various optimisations
<a name="line-1354"></a>
<a name="line-1355"></a> - It fails when reboxing happens. E.g.
<a name="line-1356"></a>      data T = MkT Int Int#
<a name="line-1357"></a>      f p@(MkT a _) = ...g p....
<a name="line-1358"></a>   where g is /lazy/ in 'p', but only uses the first component.  Then
<a name="line-1359"></a>   'f' is /strict/ in 'p', and only uses the first component.  So we only
<a name="line-1360"></a>   pass that component to the worker for 'f', which reconstructs 'p' to
<a name="line-1361"></a>   pass it to 'g'.  Alas we can't say
<a name="line-1362"></a>       ...f (MkT a (absentError Int# "blah"))...
<a name="line-1363"></a>   because `MkT` is strict in its Int# argument, so we get an absentError
<a name="line-1364"></a>   exception when we shouldn't.  Very annoying!
<a name="line-1365"></a>-}</span>
<a name="line-1366"></a>
<a name="line-1367"></a><a name="mk_absent_let"></a><span class='hs-comment'>-- | Tries to find a suitable dummy RHS to bind the given absent identifier to.</span>
<a name="line-1368"></a><span class='hs-comment'>--</span>
<a name="line-1369"></a><span class='hs-comment'>-- If @mk_absent_let _ id == Just wrap@, then @wrap e@ will wrap a let binding</span>
<a name="line-1370"></a><span class='hs-comment'>-- for @id@ with that RHS around @e@. Otherwise, there could no suitable RHS be</span>
<a name="line-1371"></a><span class='hs-comment'>-- found (currently only happens for bindings of 'VecRep' representation).</span>
<a name="line-1372"></a><span class='hs-definition'>mk_absent_let</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1373"></a><span class='hs-definition'>mk_absent_let</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>dmd</span>
<a name="line-1374"></a>
<a name="line-1375"></a>  <span class='hs-comment'>-- The lifted case: Bind 'absentError'</span>
<a name="line-1376"></a>  <span class='hs-comment'>-- See Note [Absent errors]</span>
<a name="line-1377"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isUnliftedType</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-1378"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>lifted_arg</span> <span class='hs-varid'>lifted_rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1379"></a>  <span class='hs-comment'>-- The 'UnliftedRep' (because polymorphic) case: Bind @__RUBBISH \@arg_ty@</span>
<a name="line-1380"></a>  <span class='hs-comment'>-- See Note [Absent errors]</span>
<a name="line-1381"></a>
<a name="line-1382"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>UnliftedRep</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>typePrimRep</span> <span class='hs-varid'>arg_ty</span>
<a name="line-1383"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>unlifted_rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1384"></a>
<a name="line-1385"></a>  <span class='hs-comment'>-- The monomorphic unlifted cases: Bind to some literal, if possible</span>
<a name="line-1386"></a>  <span class='hs-comment'>-- See Note [Absent errors]</span>
<a name="line-1387"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConAppTyCon_maybe</span> <span class='hs-varid'>nty</span>
<a name="line-1388"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>lit</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>absentLiteralOf</span> <span class='hs-varid'>tc</span>
<a name="line-1389"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1390"></a>
<a name="line-1391"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>nty</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>unboxedUnitTy</span>
<a name="line-1392"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>voidPrimId</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1393"></a>
<a name="line-1394"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1395"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"No absent value for"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg_ty</span> <span class='hs-layout'>)</span>
<a name="line-1396"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-comment'>-- Can happen for 'State#' and things of 'VecRep'</span>
<a name="line-1397"></a>  <span class='hs-keyword'>where</span>
<a name="line-1398"></a>    <span class='hs-varid'>lifted_arg</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>`setIdStrictness`</span> <span class='hs-varid'>botSig</span> <span class='hs-varop'>`setIdCprInfo`</span> <span class='hs-varid'>mkCprSig</span> <span class='hs-num'>0</span> <span class='hs-varid'>botCpr</span>
<a name="line-1399"></a>              <span class='hs-comment'>-- Note in strictness signature that this is bottoming</span>
<a name="line-1400"></a>              <span class='hs-comment'>-- (for the sake of the "empty case scrutinee not known to</span>
<a name="line-1401"></a>              <span class='hs-comment'>-- diverge for sure lint" warning)</span>
<a name="line-1402"></a>
<a name="line-1403"></a>    <span class='hs-varid'>lifted_rhs</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStrictDmd</span> <span class='hs-varid'>dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>rubbishLit</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg_ty</span><span class='hs-keyglyph'>]</span>
<a name="line-1404"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkAbsentErrorApp</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varid'>msg</span>
<a name="line-1405"></a>    <span class='hs-varid'>unlifted_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>rubbishLit</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg_ty</span><span class='hs-keyglyph'>]</span>
<a name="line-1406"></a>
<a name="line-1407"></a>    <span class='hs-varid'>arg_ty</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>arg</span>
<a name="line-1408"></a>
<a name="line-1409"></a>    <span class='hs-comment'>-- Normalise the type to have best chance of finding an absent literal</span>
<a name="line-1410"></a>    <span class='hs-comment'>-- e.g. (#17852)   data unlifted N = MkN Int#</span>
<a name="line-1411"></a>    <span class='hs-comment'>--                 f :: N -&gt; a -&gt; a</span>
<a name="line-1412"></a>    <span class='hs-comment'>--                 f _ x = x</span>
<a name="line-1413"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>nty</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topNormaliseType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>arg_ty</span>
<a name="line-1414"></a>                   <span class='hs-varop'>`orElse`</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkRepReflCo</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-1415"></a>
<a name="line-1416"></a>    <span class='hs-varid'>msg</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>showSDoc</span> <span class='hs-layout'>(</span><span class='hs-varid'>gopt_set</span> <span class='hs-varid'>dflags</span> <span class='hs-conid'>Opt_SuppressUniques</span><span class='hs-layout'>)</span>
<a name="line-1417"></a>                            <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span>
<a name="line-1418"></a>                              <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Arg:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg</span>
<a name="line-1419"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Type:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg_ty</span>
<a name="line-1420"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>file_msg</span>
<a name="line-1421"></a>                              <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1422"></a>    <span class='hs-varid'>file_msg</span>     <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>outputFile</span> <span class='hs-varid'>dflags</span> <span class='hs-keyword'>of</span>
<a name="line-1423"></a>                     <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>empty</span>
<a name="line-1424"></a>                     <span class='hs-conid'>Just</span> <span class='hs-varid'>f</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"In output file "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span>
<a name="line-1425"></a>              <span class='hs-comment'>-- We need to suppress uniques here because otherwise they'd</span>
<a name="line-1426"></a>              <span class='hs-comment'>-- end up in the generated code as strings. This is bad for</span>
<a name="line-1427"></a>              <span class='hs-comment'>-- determinism, because with different uniques the strings</span>
<a name="line-1428"></a>              <span class='hs-comment'>-- will have different lengths and hence different costs for</span>
<a name="line-1429"></a>              <span class='hs-comment'>-- the inliner leading to different inlining.</span>
<a name="line-1430"></a>              <span class='hs-comment'>-- See also Note [Unique Determinism] in GHC.Types.Unique</span>
<a name="line-1431"></a>
<a name="line-1432"></a><a name="ww_prefix"></a><span class='hs-definition'>ww_prefix</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FastString</span>
<a name="line-1433"></a><span class='hs-definition'>ww_prefix</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fsLit</span> <span class='hs-str'>"ww"</span>
<a name="line-1434"></a>
<a name="line-1435"></a><a name="mk_ww_local"></a><span class='hs-definition'>mk_ww_local</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unique</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StrictnessMark</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-1436"></a><span class='hs-comment'>-- The StrictnessMark comes form the data constructor and says</span>
<a name="line-1437"></a><span class='hs-comment'>-- whether this field is strict</span>
<a name="line-1438"></a><span class='hs-comment'>-- See Note [Record evaluated-ness in worker/wrapper]</span>
<a name="line-1439"></a><span class='hs-definition'>mk_ww_local</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>str</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>w</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1440"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setCaseBndrEvald</span> <span class='hs-varid'>str</span> <span class='hs-varop'>$</span>
<a name="line-1441"></a>    <span class='hs-varid'>mkSysLocalOrCoVar</span> <span class='hs-varid'>ww_prefix</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>w</span> <span class='hs-varid'>ty</span>
</pre></body>
</html>

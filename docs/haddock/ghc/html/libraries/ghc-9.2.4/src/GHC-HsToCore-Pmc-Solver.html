<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/HsToCore/Pmc/Solver.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP                 #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE LambdaCase          #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE ScopedTypeVariables #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE ViewPatterns        #-}</span>
<a name="line-5"></a>
<a name="line-6"></a><span class='hs-comment'>{-
<a name="line-7"></a>Authors: George Karachalias &lt;george.karachalias@cs.kuleuven.be&gt;
<a name="line-8"></a>         Sebastian Graf &lt;sgraf1337@gmail.com&gt;
<a name="line-9"></a>         Ryan Scott &lt;ryan.gl.scott@gmail.com&gt;
<a name="line-10"></a>-}</span>
<a name="line-11"></a>
<a name="line-12"></a><span class='hs-comment'>-- | Model refinements type as per the</span>
<a name="line-13"></a><span class='hs-comment'>-- [Lower Your Guards paper](https://dl.acm.org/doi/abs/10.1145/3408989).</span>
<a name="line-14"></a><span class='hs-comment'>-- The main export of the module are the functions 'addPhiCtsNablas' for adding</span>
<a name="line-15"></a><span class='hs-comment'>-- facts to the oracle, 'isInhabited' to check if a refinement type is inhabited</span>
<a name="line-16"></a><span class='hs-comment'>-- and 'generateInhabitingPatterns' to turn a 'Nabla' into a concrete pattern</span>
<a name="line-17"></a><span class='hs-comment'>-- for an equation.</span>
<a name="line-18"></a><span class='hs-comment'>--</span>
<a name="line-19"></a><span class='hs-comment'>-- In terms of the LYG paper, this module is concerned with Sections 3.4, 3.6</span>
<a name="line-20"></a><span class='hs-comment'>-- and 3.7. E.g., it represents refinement types directly as a bunch of</span>
<a name="line-21"></a><span class='hs-comment'>-- normalised refinement types 'Nabla'.</span>
<a name="line-22"></a>
<a name="line-23"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.HsToCore.Pmc.Solver</span> <span class='hs-layout'>(</span>
<a name="line-24"></a>
<a name="line-25"></a>        <span class='hs-conid'>Nabla</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nablas</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>initNablas</span><span class='hs-layout'>,</span>
<a name="line-26"></a>        <span class='hs-varid'>lookupRefuts</span><span class='hs-layout'>,</span> <span class='hs-varid'>lookupSolution</span><span class='hs-layout'>,</span>
<a name="line-27"></a>
<a name="line-28"></a>        <span class='hs-conid'>PhiCt</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>PhiCts</span><span class='hs-layout'>,</span>
<a name="line-29"></a>        <span class='hs-varid'>addPhiCtNablas</span><span class='hs-layout'>,</span>
<a name="line-30"></a>        <span class='hs-varid'>addPhiCtsNablas</span><span class='hs-layout'>,</span>
<a name="line-31"></a>
<a name="line-32"></a>        <span class='hs-varid'>isInhabited</span><span class='hs-layout'>,</span>
<a name="line-33"></a>        <span class='hs-varid'>generateInhabitingPatterns</span>
<a name="line-34"></a>
<a name="line-35"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-36"></a>
<a name="line-37"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-38"></a>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-40"></a>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.HsToCore.Pmc.Types</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.HsToCore.Pmc.Utils</span> <span class='hs-layout'>(</span><span class='hs-varid'>tracePm</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkPmId</span><span class='hs-layout'>)</span>
<a name="line-43"></a>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Session</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Config</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Monad</span> <span class='hs-layout'>(</span><span class='hs-varid'>allM</span><span class='hs-layout'>)</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Bag</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.CompleteMatch</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique.Set</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique.DSet</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique.SDFM</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span>      <span class='hs-layout'>(</span><span class='hs-conid'>EvVar</span><span class='hs-layout'>)</span>
<a name="line-58"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Env</span>
<a name="line-59"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Set</span>
<a name="line-60"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core</span>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FVs</span>       <span class='hs-layout'>(</span><span class='hs-varid'>exprFreeVars</span><span class='hs-layout'>)</span>
<a name="line-62"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Map.Expr</span>
<a name="line-63"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.SimpleOpt</span> <span class='hs-layout'>(</span><span class='hs-varid'>simpleOptExpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>exprIsConApp_maybe</span><span class='hs-layout'>)</span>
<a name="line-64"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Utils</span>     <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span><span class='hs-layout'>)</span>
<a name="line-65"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Make</span>      <span class='hs-layout'>(</span><span class='hs-varid'>mkListExpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCharExpr</span><span class='hs-layout'>)</span>
<a name="line-66"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique.Supply</span>
<a name="line-67"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.FastString</span>
<a name="line-68"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.SrcLoc</span>
<a name="line-69"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Maybe</span>
<a name="line-70"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.ConLike</span>
<a name="line-71"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.DataCon</span>
<a name="line-72"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.PatSyn</span>
<a name="line-73"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCon</span>
<a name="line-74"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCon.RecWalk</span>
<a name="line-75"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Types</span>
<a name="line-76"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Types.Prim</span> <span class='hs-layout'>(</span><span class='hs-varid'>tYPETyCon</span><span class='hs-layout'>)</span>
<a name="line-77"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCo.Rep</span>
<a name="line-78"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCo.Subst</span> <span class='hs-layout'>(</span><span class='hs-varid'>elemTCvSubst</span><span class='hs-layout'>)</span>
<a name="line-79"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-80"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Solver</span>   <span class='hs-layout'>(</span><span class='hs-varid'>tcNormalise</span><span class='hs-layout'>,</span> <span class='hs-varid'>tcCheckGivens</span><span class='hs-layout'>,</span> <span class='hs-varid'>tcCheckWanteds</span><span class='hs-layout'>)</span>
<a name="line-81"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Unify</span>    <span class='hs-layout'>(</span><span class='hs-varid'>tcMatchTy</span><span class='hs-layout'>)</span>
<a name="line-82"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion</span>
<a name="line-83"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.HsToCore.Monad</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldlM</span><span class='hs-layout'>)</span>
<a name="line-84"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Instance.Family</span>
<a name="line-85"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FamInstEnv</span>
<a name="line-86"></a>
<a name="line-87"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Applicative</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;|&gt;</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-88"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Monad</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldM</span><span class='hs-layout'>,</span> <span class='hs-varid'>forM</span><span class='hs-layout'>,</span> <span class='hs-varid'>guard</span><span class='hs-layout'>,</span> <span class='hs-varid'>mzero</span><span class='hs-layout'>,</span> <span class='hs-varid'>when</span><span class='hs-layout'>,</span> <span class='hs-varid'>filterM</span><span class='hs-layout'>)</span>
<a name="line-89"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Monad.Trans.Class</span> <span class='hs-layout'>(</span><span class='hs-varid'>lift</span><span class='hs-layout'>)</span>
<a name="line-90"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Monad.Trans.State.Strict</span>
<a name="line-91"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Coerce</span>
<a name="line-92"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Either</span>   <span class='hs-layout'>(</span><span class='hs-varid'>partitionEithers</span><span class='hs-layout'>)</span>
<a name="line-93"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Foldable</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldlM</span><span class='hs-layout'>,</span> <span class='hs-varid'>minimumBy</span><span class='hs-layout'>,</span> <span class='hs-varid'>toList</span><span class='hs-layout'>)</span>
<a name="line-94"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Monoid</span>   <span class='hs-layout'>(</span><span class='hs-conid'>Any</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-95"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List</span>     <span class='hs-layout'>(</span><span class='hs-varid'>sortBy</span><span class='hs-layout'>,</span> <span class='hs-varid'>find</span><span class='hs-layout'>)</span>
<a name="line-96"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.List.NonEmpty</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>NE</span>
<a name="line-97"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Ord</span>      <span class='hs-layout'>(</span><span class='hs-varid'>comparing</span><span class='hs-layout'>)</span>
<a name="line-98"></a>
<a name="line-99"></a><span class='hs-comment'>--</span>
<a name="line-100"></a><span class='hs-comment'>-- * Main exports</span>
<a name="line-101"></a><span class='hs-comment'>--</span>
<a name="line-102"></a>
<a name="line-103"></a><a name="addPhiCtsNablas"></a><span class='hs-comment'>-- | Add a bunch of 'PhiCt's to all the 'Nabla's.</span>
<a name="line-104"></a><span class='hs-comment'>-- Lifts 'addPhiCts' over many 'Nablas'.</span>
<a name="line-105"></a><span class='hs-definition'>addPhiCtsNablas</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nablas</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PhiCts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nablas</span>
<a name="line-106"></a><span class='hs-definition'>addPhiCtsNablas</span> <span class='hs-varid'>nablas</span> <span class='hs-varid'>cts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftNablasM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>d</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addPhiCts</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cts</span><span class='hs-layout'>)</span> <span class='hs-varid'>nablas</span>
<a name="line-107"></a>
<a name="line-108"></a><a name="addPhiCtNablas"></a><span class='hs-comment'>-- | 'addPmCtsNablas' for a single 'PmCt'.</span>
<a name="line-109"></a><span class='hs-definition'>addPhiCtNablas</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nablas</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PhiCt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nablas</span>
<a name="line-110"></a><span class='hs-definition'>addPhiCtNablas</span> <span class='hs-varid'>nablas</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addPhiCtsNablas</span> <span class='hs-varid'>nablas</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitBag</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-111"></a>
<a name="line-112"></a><a name="liftNablasM"></a><span class='hs-definition'>liftNablasM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Nabla</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nablas</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-conid'>Nablas</span>
<a name="line-113"></a><span class='hs-definition'>liftNablasM</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>MkNablas</span> <span class='hs-varid'>ds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MkNablas</span> <span class='hs-varop'>.</span> <span class='hs-varid'>catBagMaybes</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>traverse</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ds</span><span class='hs-layout'>)</span>
<a name="line-114"></a>
<a name="line-115"></a><a name="isInhabited"></a><span class='hs-comment'>-- | Test if any of the 'Nabla's is inhabited. Currently this is pure, because</span>
<a name="line-116"></a><span class='hs-comment'>-- we preserve the invariant that there are no uninhabited 'Nabla's. But that</span>
<a name="line-117"></a><span class='hs-comment'>-- could change in the future, for example by implementing this function in</span>
<a name="line-118"></a><span class='hs-comment'>-- terms of @notNull &lt;$&gt; generateInhabitingPatterns 1 ds@.</span>
<a name="line-119"></a><span class='hs-definition'>isInhabited</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nablas</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Bool</span>
<a name="line-120"></a><span class='hs-definition'>isInhabited</span> <span class='hs-layout'>(</span><span class='hs-conid'>MkNablas</span> <span class='hs-varid'>ds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>ds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-121"></a>
<a name="line-122"></a><span class='hs-comment'>-----------------------------------------------</span>
<a name="line-123"></a><span class='hs-comment'>-- * Caching residual COMPLETE sets</span>
<a name="line-124"></a>
<a name="line-125"></a><span class='hs-comment'>-- See Note [Implementation of COMPLETE pragmas]</span>
<a name="line-126"></a>
<a name="line-127"></a><a name="updRcm"></a><span class='hs-comment'>-- | Update the COMPLETE sets of 'ResidualCompleteMatches', or 'Nothing'</span>
<a name="line-128"></a><span class='hs-comment'>-- if there was no change as per the update function.</span>
<a name="line-129"></a><span class='hs-definition'>updRcm</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>CompleteMatch</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-conid'>CompleteMatch</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-130"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ResidualCompleteMatches</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>ResidualCompleteMatches</span><span class='hs-layout'>)</span>
<a name="line-131"></a><span class='hs-definition'>updRcm</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>RCM</span> <span class='hs-varid'>vanilla</span> <span class='hs-varid'>pragmas</span><span class='hs-layout'>)</span>
<a name="line-132"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>any_change</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-133"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>RCM</span> <span class='hs-varid'>vanilla'</span> <span class='hs-varid'>pragmas'</span><span class='hs-layout'>)</span>
<a name="line-134"></a>  <span class='hs-keyword'>where</span>
<a name="line-135"></a>    <span class='hs-varid'>f'</span> <span class='hs-keyglyph'>::</span>  <span class='hs-conid'>CompleteMatch</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Any</span><span class='hs-layout'>,</span>  <span class='hs-conid'>CompleteMatch</span><span class='hs-layout'>)</span>
<a name="line-136"></a>    <span class='hs-varid'>f'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coerce</span> <span class='hs-varid'>f</span>
<a name="line-137"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>chgd</span><span class='hs-layout'>,</span> <span class='hs-varid'>vanilla'</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>traverse</span> <span class='hs-varid'>f'</span> <span class='hs-varid'>vanilla</span>
<a name="line-138"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>chgds</span><span class='hs-layout'>,</span> <span class='hs-varid'>pragmas'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>traverse</span> <span class='hs-layout'>(</span><span class='hs-varid'>traverse</span> <span class='hs-varid'>f'</span><span class='hs-layout'>)</span> <span class='hs-varid'>pragmas</span>
<a name="line-139"></a>    <span class='hs-varid'>any_change</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getAny</span> <span class='hs-varop'>$</span> <span class='hs-varid'>chgd</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>chgds</span>
<a name="line-140"></a>
<a name="line-141"></a><a name="vanillaCompleteMatchTC"></a><span class='hs-comment'>-- | A pseudo-'CompleteMatch' for the vanilla complete set of the given data</span>
<a name="line-142"></a><span class='hs-comment'>-- 'TyCon'.</span>
<a name="line-143"></a><span class='hs-comment'>-- Ex.: @vanillaCompleteMatchTC 'Maybe' ==&gt; Just ("Maybe", {'Just','Nothing'})@</span>
<a name="line-144"></a><span class='hs-definition'>vanillaCompleteMatchTC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>CompleteMatch</span>
<a name="line-145"></a><span class='hs-definition'>vanillaCompleteMatchTC</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>=</span>
<a name="line-146"></a>  <span class='hs-keyword'>let</span> <span class='hs-comment'>-- | TYPE acts like an empty data type on the term-level (#14086), but</span>
<a name="line-147"></a>      <span class='hs-comment'>-- it is a PrimTyCon, so tyConDataCons_maybe returns Nothing. Hence a</span>
<a name="line-148"></a>      <span class='hs-comment'>-- special case.</span>
<a name="line-149"></a>      <span class='hs-varid'>mb_dcs</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tYPETyCon</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>[]</span>
<a name="line-150"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConDataCons_maybe</span> <span class='hs-varid'>tc</span>
<a name="line-151"></a>  <span class='hs-keyword'>in</span> <span class='hs-varid'>vanillaCompleteMatch</span> <span class='hs-varop'>.</span> <span class='hs-varid'>mkUniqDSet</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-conid'>RealDataCon</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>mb_dcs</span>
<a name="line-152"></a>
<a name="line-153"></a><a name="addCompleteMatches"></a><span class='hs-comment'>-- | Initialise from 'dsGetCompleteMatches' (containing all COMPLETE pragmas)</span>
<a name="line-154"></a><span class='hs-comment'>-- if the given 'ResidualCompleteMatches' were empty.</span>
<a name="line-155"></a><span class='hs-definition'>addCompleteMatches</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ResidualCompleteMatches</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>ResidualCompleteMatches</span>
<a name="line-156"></a><span class='hs-definition'>addCompleteMatches</span> <span class='hs-layout'>(</span><span class='hs-conid'>RCM</span> <span class='hs-varid'>v</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RCM</span> <span class='hs-varid'>v</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Just</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>dsGetCompleteMatches</span>
<a name="line-157"></a><span class='hs-definition'>addCompleteMatches</span> <span class='hs-varid'>rcm</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>rcm</span>
<a name="line-158"></a>
<a name="line-159"></a><a name="addConLikeMatches"></a><span class='hs-comment'>-- | Adds the declared 'CompleteMatches' from COMPLETE pragmas, as well as the</span>
<a name="line-160"></a><span class='hs-comment'>-- vanilla data defn if it is a 'DataCon'.</span>
<a name="line-161"></a><span class='hs-definition'>addConLikeMatches</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ConLike</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ResidualCompleteMatches</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>ResidualCompleteMatches</span>
<a name="line-162"></a><span class='hs-definition'>addConLikeMatches</span> <span class='hs-layout'>(</span><span class='hs-conid'>RealDataCon</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-varid'>rcm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addTyConMatches</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-varid'>rcm</span>
<a name="line-163"></a><span class='hs-definition'>addConLikeMatches</span> <span class='hs-layout'>(</span><span class='hs-conid'>PatSynCon</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-varid'>rcm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addCompleteMatches</span> <span class='hs-varid'>rcm</span>
<a name="line-164"></a>
<a name="line-165"></a><a name="addTyConMatches"></a><span class='hs-comment'>-- | Adds</span>
<a name="line-166"></a><span class='hs-comment'>--    * the 'CompleteMatches' from COMPLETE pragmas</span>
<a name="line-167"></a><span class='hs-comment'>--    * and the /vanilla/ 'CompleteMatch' from the data 'TyCon'</span>
<a name="line-168"></a><span class='hs-comment'>-- to the 'ResidualCompleteMatches', if not already present.</span>
<a name="line-169"></a><span class='hs-definition'>addTyConMatches</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ResidualCompleteMatches</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>ResidualCompleteMatches</span>
<a name="line-170"></a><span class='hs-definition'>addTyConMatches</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>rcm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>add_tc_match</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>addCompleteMatches</span> <span class='hs-varid'>rcm</span>
<a name="line-171"></a>  <span class='hs-keyword'>where</span>
<a name="line-172"></a>    <span class='hs-comment'>-- | Add the vanilla COMPLETE set from the data defn, if any. But only if</span>
<a name="line-173"></a>    <span class='hs-comment'>-- it's not already present.</span>
<a name="line-174"></a>    <span class='hs-varid'>add_tc_match</span> <span class='hs-varid'>rcm</span>
<a name="line-175"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rcm</span><span class='hs-layout'>{</span><span class='hs-varid'>rcm_vanilla</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rcm_vanilla</span> <span class='hs-varid'>rcm</span> <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-varid'>vanillaCompleteMatchTC</span> <span class='hs-varid'>tc</span><span class='hs-layout'>}</span>
<a name="line-176"></a>
<a name="line-177"></a><a name="markMatched"></a><span class='hs-definition'>markMatched</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PmAltCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ResidualCompleteMatches</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>ResidualCompleteMatches</span><span class='hs-layout'>)</span>
<a name="line-178"></a><span class='hs-comment'>-- Nothing means the PmAltCon didn't occur in any COMPLETE set.</span>
<a name="line-179"></a><span class='hs-comment'>-- See Note [Shortcutting the inhabitation test] for how this is useful for</span>
<a name="line-180"></a><span class='hs-comment'>-- performance on T17836.</span>
<a name="line-181"></a><span class='hs-definition'>markMatched</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmAltLit</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>      <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>Nothing</span> <span class='hs-comment'>-- lits are never part of a COMPLETE set</span>
<a name="line-182"></a><span class='hs-definition'>markMatched</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmAltConLike</span> <span class='hs-varid'>cl</span><span class='hs-layout'>)</span> <span class='hs-varid'>rcm</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-183"></a>  <span class='hs-varid'>rcm'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addConLikeMatches</span> <span class='hs-varid'>cl</span> <span class='hs-varid'>rcm</span>
<a name="line-184"></a>  <span class='hs-keyword'>let</span> <span class='hs-varid'>go</span> <span class='hs-varid'>cm</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupUniqDSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>cmConLikes</span> <span class='hs-varid'>cm</span><span class='hs-layout'>)</span> <span class='hs-varid'>cl</span> <span class='hs-keyword'>of</span>
<a name="line-185"></a>        <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>cm</span><span class='hs-layout'>)</span>
<a name="line-186"></a>        <span class='hs-conid'>Just</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span>  <span class='hs-varid'>cm</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cmConLikes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>delOneFromUniqDSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>cmConLikes</span> <span class='hs-varid'>cm</span><span class='hs-layout'>)</span> <span class='hs-varid'>cl</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-187"></a>  <span class='hs-varid'>pure</span> <span class='hs-varop'>$</span> <span class='hs-varid'>updRcm</span> <span class='hs-varid'>go</span> <span class='hs-varid'>rcm'</span>
<a name="line-188"></a>
<a name="line-189"></a><span class='hs-comment'>{-
<a name="line-190"></a>Note [Implementation of COMPLETE pragmas]
<a name="line-191"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-192"></a>A COMPLETE set represents a set of conlikes (i.e., constructors or
<a name="line-193"></a>pattern synonyms) such that if they are all pattern-matched against in a
<a name="line-194"></a>function, it gives rise to a total function. An example is:
<a name="line-195"></a>
<a name="line-196"></a>  newtype Boolean = Boolean Int
<a name="line-197"></a>  pattern F, T :: Boolean
<a name="line-198"></a>  pattern F = Boolean 0
<a name="line-199"></a>  pattern T = Boolean 1
<a name="line-200"></a>  {-# COMPLETE F, T #-}
<a name="line-201"></a>
<a name="line-202"></a>  -- This is a total function
<a name="line-203"></a>  booleanToInt :: Boolean -&gt; Int
<a name="line-204"></a>  booleanToInt F = 0
<a name="line-205"></a>  booleanToInt T = 1
<a name="line-206"></a>
<a name="line-207"></a>COMPLETE sets are represented internally in GHC as a set of 'ConLike's. For
<a name="line-208"></a>example, the pragma {-# COMPLETE F, T #-} would be represented as:
<a name="line-209"></a>
<a name="line-210"></a>  CompleteMatch {F, T} Nothing
<a name="line-211"></a>
<a name="line-212"></a>What is the Maybe for? Answer: COMPLETE pragmas may optionally specify a
<a name="line-213"></a>result *type constructor* (cf. T14422):
<a name="line-214"></a>
<a name="line-215"></a>  class C f where
<a name="line-216"></a>    foo :: f a -&gt; ()
<a name="line-217"></a>  pattern P :: C f =&gt; f a
<a name="line-218"></a>  pattern P &lt;- (foo -&gt; ())
<a name="line-219"></a>
<a name="line-220"></a>  instance C State where
<a name="line-221"></a>    foo _ = ()
<a name="line-222"></a>  {-# COMPLETE P :: State #-}
<a name="line-223"></a>
<a name="line-224"></a>  f :: State a -&gt; ()
<a name="line-225"></a>  f P = ()
<a name="line-226"></a>  g :: C f =&gt; f a -&gt; ()
<a name="line-227"></a>  g P = ()
<a name="line-228"></a>
<a name="line-229"></a>The @:: State@ here means that the types at which the COMPLETE pragma *applies*
<a name="line-230"></a>is restricted to scrutinee types that are applications of the 'State' TyCon. So
<a name="line-231"></a>it applies to the match in @f@ but not in @g@ above, resulting in a warning for
<a name="line-232"></a>the latter but not for the former. The pragma is represented as
<a name="line-233"></a>
<a name="line-234"></a>  CompleteMatch {P} (Just State)
<a name="line-235"></a>
<a name="line-236"></a>GHC collects all COMPLETE pragmas from the current module and from imports
<a name="line-237"></a>into a field in the DsM environment, which can be accessed with
<a name="line-238"></a>dsGetCompleteMatches from "GHC.HsToCore.Monad".
<a name="line-239"></a>Currently, COMPLETE pragmas can't be orphans (e.g. at least one ConLike must
<a name="line-240"></a>also be defined in the module of the pragma) and do not impact recompilation
<a name="line-241"></a>checking (#18675).
<a name="line-242"></a>
<a name="line-243"></a>The pattern-match checker will then initialise each variable's 'VarInfo' with
<a name="line-244"></a>*all* imported COMPLETE sets (in 'GHC.HsToCore.Pmc.Solver.addCompleteMatches'),
<a name="line-245"></a>well-typed or not, into a 'ResidualCompleteMatches'. The trick is that a
<a name="line-246"></a>COMPLETE set that is ill-typed for that match variable could never be written by
<a name="line-247"></a>the user! And we make sure not to report any ill-typed COMPLETE sets when
<a name="line-248"></a>formatting 'Nabla's for warnings in 'generateInhabitingPatterns'.
<a name="line-249"></a>
<a name="line-250"></a>A 'ResidualCompleteMatches' is a list of all COMPLETE sets, minus the ConLikes
<a name="line-251"></a>we know a particular variable can't be (through negative constructor constraints
<a name="line-252"></a>@x /~ K@ or a failed attempt at instantiating that ConLike during inhabitation
<a name="line-253"></a>testing). If *any* of the COMPLETE sets become empty, we know that the match
<a name="line-254"></a>was exhaustive.
<a name="line-255"></a>
<a name="line-256"></a>We assume that a COMPLETE set does not apply if for one of its
<a name="line-257"></a>ConLikes we fail to 'matchConLikeResTy' or the
<a name="line-258"></a>type of the match variable isn't an application of the optional
<a name="line-259"></a>result type constructor from the pragma. Why don't we simply
<a name="line-260"></a>prune inapplicable COMPLETE sets from 'ResidualCompleteMatches'?
<a name="line-261"></a>The answer is that additional type constraints might make more
<a name="line-262"></a>COMPLETE sets applicable! Example:
<a name="line-263"></a>
<a name="line-264"></a>  h :: a -&gt; a :~: Boolean -&gt; ()
<a name="line-265"></a>  h x Refl | T &lt;- x = ()
<a name="line-266"></a>           | F &lt;- x = ()
<a name="line-267"></a>
<a name="line-268"></a>If we eagerly prune {F,T} from the residual matches of @x@, then we don't see
<a name="line-269"></a>that the match in the guards of @h@ is exhaustive, where the COMPLETE set
<a name="line-270"></a>applies due to refined type information.
<a name="line-271"></a>-}</span>
<a name="line-272"></a>
<a name="line-273"></a><span class='hs-comment'>-----------------------</span>
<a name="line-274"></a><span class='hs-comment'>-- * Type normalisation</span>
<a name="line-275"></a>
<a name="line-276"></a><a name="TopNormaliseTypeResult"></a><span class='hs-comment'>-- | The return value of 'pmTopNormaliseType'</span>
<a name="line-277"></a><a name="TopNormaliseTypeResult"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TopNormaliseTypeResult</span>
<a name="line-278"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NormalisedByConstraints</span> <span class='hs-conid'>Type</span>
<a name="line-279"></a>  <span class='hs-comment'>-- ^ 'tcNormalise' was able to simplify the type with some local constraint</span>
<a name="line-280"></a>  <span class='hs-comment'>-- from the type oracle, but 'topNormaliseTypeX' couldn't identify a type</span>
<a name="line-281"></a>  <span class='hs-comment'>-- redex.</span>
<a name="line-282"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HadRedexes</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-conid'>Type</span>
<a name="line-283"></a>  <span class='hs-comment'>-- ^ 'tcNormalise' may or may not been able to simplify the type, but</span>
<a name="line-284"></a>  <span class='hs-comment'>-- 'topNormaliseTypeX' made progress either way and got rid of at least one</span>
<a name="line-285"></a>  <span class='hs-comment'>-- outermost type or data family redex or newtype.</span>
<a name="line-286"></a>  <span class='hs-comment'>-- The first field is the last type that was reduced solely through type</span>
<a name="line-287"></a>  <span class='hs-comment'>-- family applications (possibly just the 'tcNormalise'd type). This is the</span>
<a name="line-288"></a>  <span class='hs-comment'>-- one that is equal (in source Haskell) to the initial type.</span>
<a name="line-289"></a>  <span class='hs-comment'>-- The third field is the type that we get when also looking through data</span>
<a name="line-290"></a>  <span class='hs-comment'>-- family applications and newtypes. This would be the representation type in</span>
<a name="line-291"></a>  <span class='hs-comment'>-- Core (modulo casts).</span>
<a name="line-292"></a>  <span class='hs-comment'>-- The second field is the list of Newtype 'DataCon's that we looked through</span>
<a name="line-293"></a>  <span class='hs-comment'>-- in the chain of reduction steps between the Source type and the Core type.</span>
<a name="line-294"></a>  <span class='hs-comment'>-- We also keep the type of the DataCon application and its field, so that we</span>
<a name="line-295"></a>  <span class='hs-comment'>-- don't have to reconstruct it in 'inhabitationCandidates' and</span>
<a name="line-296"></a>  <span class='hs-comment'>-- 'generateInhabitingPatterns'.</span>
<a name="line-297"></a>  <span class='hs-comment'>-- For an example, see Note [Type normalisation].</span>
<a name="line-298"></a>
<a name="line-299"></a><a name="tntrGuts"></a><span class='hs-comment'>-- | Return the fields of 'HadRedexes'. Returns appropriate defaults in the</span>
<a name="line-300"></a><span class='hs-comment'>-- other cases.</span>
<a name="line-301"></a><span class='hs-definition'>tntrGuts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopNormaliseTypeResult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>
<a name="line-302"></a><span class='hs-definition'>tntrGuts</span> <span class='hs-layout'>(</span><span class='hs-conid'>NormalisedByConstraints</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-layout'>,</span>     <span class='hs-conid'>[]</span><span class='hs-layout'>,</span>      <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-303"></a><span class='hs-definition'>tntrGuts</span> <span class='hs-layout'>(</span><span class='hs-conid'>HadRedexes</span> <span class='hs-varid'>src_ty</span> <span class='hs-varid'>ds</span> <span class='hs-varid'>core_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>src_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>ds</span><span class='hs-layout'>,</span> <span class='hs-varid'>core_ty</span><span class='hs-layout'>)</span>
<a name="line-304"></a>
<a name="line-305"></a><a name="instance%20Outputable%20TopNormaliseTypeResult"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>TopNormaliseTypeResult</span> <span class='hs-keyword'>where</span>
<a name="line-306"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>NormalisedByConstraints</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"NormalisedByConstraints"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span>
<a name="line-307"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>HadRedexes</span> <span class='hs-varid'>src_ty</span> <span class='hs-varid'>ds</span> <span class='hs-varid'>core_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"HadRedexes"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>braces</span> <span class='hs-varid'>fields</span>
<a name="line-308"></a>    <span class='hs-keyword'>where</span>
<a name="line-309"></a>      <span class='hs-varid'>fields</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fsep</span> <span class='hs-layout'>(</span><span class='hs-varid'>punctuate</span> <span class='hs-varid'>comma</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"src_ty ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>src_ty</span>
<a name="line-310"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"newtype_dcs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ds</span>
<a name="line-311"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"core_ty ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>core_ty</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-312"></a>
<a name="line-313"></a><a name="pmTopNormaliseType"></a><span class='hs-definition'>pmTopNormaliseType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyState</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>TopNormaliseTypeResult</span>
<a name="line-314"></a><span class='hs-comment'>-- ^ Get rid of *outermost* (or toplevel)</span>
<a name="line-315"></a><span class='hs-comment'>--      * type function redex</span>
<a name="line-316"></a><span class='hs-comment'>--      * data family redex</span>
<a name="line-317"></a><span class='hs-comment'>--      * newtypes</span>
<a name="line-318"></a><span class='hs-comment'>--</span>
<a name="line-319"></a><span class='hs-comment'>-- Behaves like `topNormaliseType_maybe`, but instead of returning a</span>
<a name="line-320"></a><span class='hs-comment'>-- coercion, it returns useful information for issuing pattern matching</span>
<a name="line-321"></a><span class='hs-comment'>-- warnings. See Note [Type normalisation] for details.</span>
<a name="line-322"></a><span class='hs-comment'>-- It also initially 'tcNormalise's the type with the bag of local constraints.</span>
<a name="line-323"></a><span class='hs-comment'>--</span>
<a name="line-324"></a><span class='hs-comment'>-- See 'TopNormaliseTypeResult' for the meaning of the return value.</span>
<a name="line-325"></a><span class='hs-comment'>--</span>
<a name="line-326"></a><span class='hs-comment'>-- NB: Normalisation can potentially change kinds, if the head of the type</span>
<a name="line-327"></a><span class='hs-comment'>-- is a type family with a variable result kind. I (Richard E) can't think</span>
<a name="line-328"></a><span class='hs-comment'>-- of a way to cause trouble here, though.</span>
<a name="line-329"></a><span class='hs-definition'>pmTopNormaliseType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TySt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>inert</span><span class='hs-layout'>)</span> <span class='hs-varid'>typ</span>
<a name="line-330"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dsGetFamInstEnvs</span>
<a name="line-331"></a>       <span class='hs-varid'>tracePm</span> <span class='hs-str'>"normalise"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>typ</span><span class='hs-layout'>)</span>
<a name="line-332"></a>       <span class='hs-comment'>-- Before proceeding, we chuck typ into the constraint solver, in case</span>
<a name="line-333"></a>       <span class='hs-comment'>-- solving for given equalities may reduce typ some. See</span>
<a name="line-334"></a>       <span class='hs-comment'>-- "Wrinkle: local equalities" in Note [Type normalisation].</span>
<a name="line-335"></a>       <span class='hs-varid'>typ'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>initTcDsForSolver</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tcNormalise</span> <span class='hs-varid'>inert</span> <span class='hs-varid'>typ</span>
<a name="line-336"></a>       <span class='hs-comment'>-- Now we look with topNormaliseTypeX through type and data family</span>
<a name="line-337"></a>       <span class='hs-comment'>-- applications and newtypes, which tcNormalise does not do.</span>
<a name="line-338"></a>       <span class='hs-comment'>-- See also 'TopNormaliseTypeResult'.</span>
<a name="line-339"></a>       <span class='hs-varid'>pure</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>topNormaliseTypeX</span> <span class='hs-layout'>(</span><span class='hs-varid'>stepper</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>comb</span> <span class='hs-varid'>typ'</span> <span class='hs-keyword'>of</span>
<a name="line-340"></a>         <span class='hs-conid'>Nothing</span>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NormalisedByConstraints</span> <span class='hs-varid'>typ'</span>
<a name="line-341"></a>         <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>ty_f</span><span class='hs-layout'>,</span><span class='hs-varid'>tm_f</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HadRedexes</span> <span class='hs-varid'>src_ty</span> <span class='hs-varid'>newtype_dcs</span> <span class='hs-varid'>core_ty</span>
<a name="line-342"></a>           <span class='hs-keyword'>where</span>
<a name="line-343"></a>             <span class='hs-varid'>src_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eq_src_ty</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>typ'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ty_f</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ty</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-344"></a>             <span class='hs-varid'>newtype_dcs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tm_f</span> <span class='hs-conid'>[]</span>
<a name="line-345"></a>             <span class='hs-varid'>core_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>
<a name="line-346"></a>  <span class='hs-keyword'>where</span>
<a name="line-347"></a>    <span class='hs-comment'>-- Find the first type in the sequence of rewrites that is a data type,</span>
<a name="line-348"></a>    <span class='hs-comment'>-- newtype, or a data family application (not the representation tycon!).</span>
<a name="line-349"></a>    <span class='hs-comment'>-- This is the one that is equal (in source Haskell) to the initial type.</span>
<a name="line-350"></a>    <span class='hs-comment'>-- If none is found in the list, then all of them are type family</span>
<a name="line-351"></a>    <span class='hs-comment'>-- applications, so we simply return the last one, which is the *simplest*.</span>
<a name="line-352"></a>    <span class='hs-varid'>eq_src_ty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-353"></a>    <span class='hs-varid'>eq_src_ty</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maybe</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-varid'>find</span> <span class='hs-varid'>is_closed_or_data_family</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-354"></a>
<a name="line-355"></a>    <span class='hs-varid'>is_closed_or_data_family</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-356"></a>    <span class='hs-varid'>is_closed_or_data_family</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pmIsClosedType</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isDataFamilyAppType</span> <span class='hs-varid'>ty</span>
<a name="line-357"></a>
<a name="line-358"></a>    <span class='hs-comment'>-- For efficiency, represent both lists as difference lists.</span>
<a name="line-359"></a>    <span class='hs-comment'>-- comb performs the concatenation, for both lists.</span>
<a name="line-360"></a>    <span class='hs-varid'>comb</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyf1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tmf1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyf2</span><span class='hs-layout'>,</span> <span class='hs-varid'>tmf2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyf1</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tyf2</span><span class='hs-layout'>,</span> <span class='hs-varid'>tmf1</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tmf2</span><span class='hs-layout'>)</span>
<a name="line-361"></a>
<a name="line-362"></a>    <span class='hs-varid'>stepper</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>newTypeStepper</span> <span class='hs-varop'>`composeSteppers`</span> <span class='hs-varid'>tyFamStepper</span> <span class='hs-varid'>env</span>
<a name="line-363"></a>
<a name="line-364"></a>    <span class='hs-comment'>-- A 'NormaliseStepper' that unwraps newtypes, careful not to fall into</span>
<a name="line-365"></a>    <span class='hs-comment'>-- a loop. If it would fall into a loop, it produces 'NS_Abort'.</span>
<a name="line-366"></a>    <span class='hs-varid'>newTypeStepper</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NormaliseStepper</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-367"></a>    <span class='hs-varid'>newTypeStepper</span> <span class='hs-varid'>rec_nts</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-368"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-sel'>_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>instNewTyCon_maybe</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-369"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>orig_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-370"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>checkRecTc</span> <span class='hs-varid'>rec_nts</span> <span class='hs-varid'>tc</span> <span class='hs-keyword'>of</span>
<a name="line-371"></a>          <span class='hs-conid'>Just</span> <span class='hs-varid'>rec_nts'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tyf</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>orig_ty</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span>
<a name="line-372"></a>                               <span class='hs-varid'>tmf</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>orig_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>tyConSingleDataCon</span> <span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span>
<a name="line-373"></a>                           <span class='hs-keyword'>in</span>  <span class='hs-conid'>NS_Step</span> <span class='hs-varid'>rec_nts'</span> <span class='hs-varid'>ty'</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyf</span><span class='hs-layout'>,</span> <span class='hs-varid'>tmf</span><span class='hs-layout'>)</span>
<a name="line-374"></a>          <span class='hs-conid'>Nothing</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NS_Abort</span>
<a name="line-375"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-376"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NS_Done</span>
<a name="line-377"></a>
<a name="line-378"></a>    <span class='hs-varid'>tyFamStepper</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NormaliseStepper</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-379"></a>    <span class='hs-varid'>tyFamStepper</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rec_nts</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>  <span class='hs-comment'>-- Try to step a type/data family</span>
<a name="line-380"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>topReduceTyFamApp_maybe</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-keyword'>of</span>
<a name="line-381"></a>          <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NS_Step</span> <span class='hs-varid'>rec_nts</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>rhs</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-382"></a>          <span class='hs-keyword'>_</span>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NS_Done</span>
<a name="line-383"></a>
<a name="line-384"></a><a name="pmIsClosedType"></a><span class='hs-comment'>-- | Returns 'True' if the argument 'Type' is a fully saturated application of</span>
<a name="line-385"></a><span class='hs-comment'>-- a closed type constructor.</span>
<a name="line-386"></a><span class='hs-comment'>--</span>
<a name="line-387"></a><span class='hs-comment'>-- Closed type constructors are those with a fixed right hand side, as</span>
<a name="line-388"></a><span class='hs-comment'>-- opposed to e.g. associated types. These are of particular interest for</span>
<a name="line-389"></a><span class='hs-comment'>-- pattern-match coverage checking, because GHC can exhaustively consider all</span>
<a name="line-390"></a><span class='hs-comment'>-- possible forms that values of a closed type can take on.</span>
<a name="line-391"></a><span class='hs-comment'>--</span>
<a name="line-392"></a><span class='hs-comment'>-- Note that this function is intended to be used to check types of value-level</span>
<a name="line-393"></a><span class='hs-comment'>-- patterns, so as a consequence, the 'Type' supplied as an argument to this</span>
<a name="line-394"></a><span class='hs-comment'>-- function should be of kind @Type@.</span>
<a name="line-395"></a><span class='hs-definition'>pmIsClosedType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-396"></a><span class='hs-definition'>pmIsClosedType</span> <span class='hs-varid'>ty</span>
<a name="line-397"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>of</span>
<a name="line-398"></a>      <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty_args</span><span class='hs-layout'>)</span>
<a name="line-399"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_algebraic_like</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isFamilyTyCon</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-400"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>ty_args</span> <span class='hs-varop'>`lengthIs`</span> <span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>)</span> <span class='hs-conid'>True</span>
<a name="line-401"></a>      <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-402"></a>  <span class='hs-keyword'>where</span>
<a name="line-403"></a>    <span class='hs-comment'>-- This returns True for TyCons which /act like/ algebraic types.</span>
<a name="line-404"></a>    <span class='hs-comment'>-- (See "Type#type_classification" for what an algebraic type is.)</span>
<a name="line-405"></a>    <span class='hs-comment'>--</span>
<a name="line-406"></a>    <span class='hs-comment'>-- This is qualified with \"like\" because of a particular special</span>
<a name="line-407"></a>    <span class='hs-comment'>-- case: TYPE (the underlyind kind behind Type, among others). TYPE</span>
<a name="line-408"></a>    <span class='hs-comment'>-- is conceptually a datatype (and thus algebraic), but in practice it is</span>
<a name="line-409"></a>    <span class='hs-comment'>-- a primitive builtin type, so we must check for it specially.</span>
<a name="line-410"></a>    <span class='hs-comment'>--</span>
<a name="line-411"></a>    <span class='hs-comment'>-- NB: it makes sense to think of TYPE as a closed type in a value-level,</span>
<a name="line-412"></a>    <span class='hs-comment'>-- pattern-matching context. However, at the kind level, TYPE is certainly</span>
<a name="line-413"></a>    <span class='hs-comment'>-- not closed! Since this function is specifically tailored towards pattern</span>
<a name="line-414"></a>    <span class='hs-comment'>-- matching, however, it's OK to label TYPE as closed.</span>
<a name="line-415"></a>    <span class='hs-varid'>is_algebraic_like</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-416"></a>    <span class='hs-varid'>is_algebraic_like</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isAlgTyCon</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>||</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tYPETyCon</span>
<a name="line-417"></a>
<a name="line-418"></a><a name="normaliseSourceTypeWHNF"></a><span class='hs-comment'>-- | Normalise the given source type to WHNF. If it isn't already in WHNF</span>
<a name="line-419"></a><span class='hs-comment'>-- ('isSourceTypeInWHNF') , it will normalise the type and then try to step</span>
<a name="line-420"></a><span class='hs-comment'>-- through type family applications, but not data family applications or</span>
<a name="line-421"></a><span class='hs-comment'>-- newtypes.</span>
<a name="line-422"></a><span class='hs-comment'>--</span>
<a name="line-423"></a><span class='hs-comment'>-- This is a pretty common case of calling 'pmTopNormaliseType' and it should be</span>
<a name="line-424"></a><span class='hs-comment'>-- efficient.</span>
<a name="line-425"></a><span class='hs-definition'>normaliseSourceTypeWHNF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyState</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Type</span>
<a name="line-426"></a><span class='hs-definition'>normaliseSourceTypeWHNF</span> <span class='hs-keyword'>_</span>     <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSourceTypeInWHNF</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>ty</span>
<a name="line-427"></a><span class='hs-definition'>normaliseSourceTypeWHNF</span> <span class='hs-varid'>ty_st</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span>
<a name="line-428"></a>  <span class='hs-varid'>pmTopNormaliseType</span> <span class='hs-varid'>ty_st</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
<a name="line-429"></a>    <span class='hs-conid'>NormalisedByConstraints</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>ty</span>
<a name="line-430"></a>    <span class='hs-conid'>HadRedexes</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>ty</span>
<a name="line-431"></a>
<a name="line-432"></a><a name="isSourceTypeInWHNF"></a><span class='hs-comment'>-- | Is the source type in WHNF wrt. 'pmTopNormaliseType'?</span>
<a name="line-433"></a><span class='hs-comment'>--</span>
<a name="line-434"></a><span class='hs-comment'>-- Returns False if the given type is not a TyCon application, or if the TyCon</span>
<a name="line-435"></a><span class='hs-comment'>-- app head is a type family TyCon. (But not for data family TyCons!)</span>
<a name="line-436"></a><span class='hs-definition'>isSourceTypeInWHNF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-437"></a><span class='hs-definition'>isSourceTypeInWHNF</span> <span class='hs-varid'>ty</span>
<a name="line-438"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTypeFamilyTyCon</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-439"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-440"></a>
<a name="line-441"></a><span class='hs-comment'>{- Note [Type normalisation]
<a name="line-442"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-443"></a>Constructs like -XEmptyCase or a previous unsuccessful pattern match on a data
<a name="line-444"></a>constructor place a non-void constraint on the matched thing. This means that it
<a name="line-445"></a>boils down to checking whether the type of the scrutinee is inhabited. Function
<a name="line-446"></a>pmTopNormaliseType gets rid of the outermost type function/data family redex and
<a name="line-447"></a>newtypes, in search of an algebraic type constructor, which is easier to check
<a name="line-448"></a>for inhabitation.
<a name="line-449"></a>
<a name="line-450"></a>It returns 3 results instead of one, because there are 2 subtle points:
<a name="line-451"></a>1. Newtypes are isomorphic to the underlying type in core but not in the source
<a name="line-452"></a>   language,
<a name="line-453"></a>2. The representational data family tycon is used internally but should not be
<a name="line-454"></a>   shown to the user
<a name="line-455"></a>
<a name="line-456"></a>Hence, if pmTopNormaliseType env ty_cs ty = Just (src_ty, dcs, core_ty),
<a name="line-457"></a>then
<a name="line-458"></a>  (a) src_ty is the rewritten type which we can show to the user. That is, the
<a name="line-459"></a>      type we get if we rewrite type families but not data families or
<a name="line-460"></a>      newtypes.
<a name="line-461"></a>  (b) dcs is the list of newtype constructors "skipped", every time we normalise
<a name="line-462"></a>      a newtype to its core representation, we keep track of the source data
<a name="line-463"></a>      constructor. For convenience, we also track the type we unwrap and the
<a name="line-464"></a>      type of its field. Example: @Down 42@ =&gt; @[(Down @Int, Down, Int)]
<a name="line-465"></a>  (c) core_ty is the rewritten type. That is,
<a name="line-466"></a>        pmTopNormaliseType env ty_cs ty = Just (src_ty, dcs, core_ty)
<a name="line-467"></a>      implies
<a name="line-468"></a>        topNormaliseType_maybe env ty = Just (co, core_ty)
<a name="line-469"></a>      for some coercion co.
<a name="line-470"></a>
<a name="line-471"></a>To see how all cases come into play, consider the following example:
<a name="line-472"></a>
<a name="line-473"></a>  data family T a :: *
<a name="line-474"></a>  data instance T Int = T1 | T2 Bool
<a name="line-475"></a>  -- Which gives rise to FC:
<a name="line-476"></a>  --   data T a
<a name="line-477"></a>  --   data R:TInt = T1 | T2 Bool
<a name="line-478"></a>  --   axiom ax_ti : T Int ~R R:TInt
<a name="line-479"></a>
<a name="line-480"></a>  newtype G1 = MkG1 (T Int)
<a name="line-481"></a>  newtype G2 = MkG2 G1
<a name="line-482"></a>
<a name="line-483"></a>  type instance F Int  = F Char
<a name="line-484"></a>  type instance F Char = G2
<a name="line-485"></a>
<a name="line-486"></a>In this case pmTopNormaliseType env ty_cs (F Int) results in
<a name="line-487"></a>
<a name="line-488"></a>  Just (G2, [(G2,MkG2,G1),(G1,MkG1,T Int)], R:TInt)
<a name="line-489"></a>
<a name="line-490"></a>Which means that in source Haskell:
<a name="line-491"></a>  - G2 is equivalent to F Int (in contrast, G1 isn't).
<a name="line-492"></a>  - if (x : R:TInt) then (MkG2 (MkG1 x) : F Int).
<a name="line-493"></a>
<a name="line-494"></a>-----
<a name="line-495"></a>-- Wrinkle: Local equalities
<a name="line-496"></a>-----
<a name="line-497"></a>
<a name="line-498"></a>Given the following type family:
<a name="line-499"></a>
<a name="line-500"></a>  type family F a
<a name="line-501"></a>  type instance F Int = Void
<a name="line-502"></a>
<a name="line-503"></a>Should the following program (from #14813) be considered exhaustive?
<a name="line-504"></a>
<a name="line-505"></a>  f :: (i ~ Int) =&gt; F i -&gt; a
<a name="line-506"></a>  f x = case x of {}
<a name="line-507"></a>
<a name="line-508"></a>You might think "of course, since `x` is obviously of type Void". But the
<a name="line-509"></a>idType of `x` is technically F i, not Void, so if we pass F i to
<a name="line-510"></a>inhabitationCandidates, we'll mistakenly conclude that `f` is non-exhaustive.
<a name="line-511"></a>In order to avoid this pitfall, we need to normalise the type passed to
<a name="line-512"></a>pmTopNormaliseType, using the constraint solver to solve for any local
<a name="line-513"></a>equalities (such as i ~ Int) that may be in scope.
<a name="line-514"></a>-}</span>
<a name="line-515"></a>
<a name="line-516"></a><span class='hs-comment'>-----------------------</span>
<a name="line-517"></a><span class='hs-comment'>-- * Looking up VarInfo</span>
<a name="line-518"></a>
<a name="line-519"></a><a name="emptyRCM"></a><span class='hs-definition'>emptyRCM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ResidualCompleteMatches</span>
<a name="line-520"></a><span class='hs-definition'>emptyRCM</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RCM</span> <span class='hs-conid'>Nothing</span> <span class='hs-conid'>Nothing</span>
<a name="line-521"></a>
<a name="line-522"></a><a name="emptyVarInfo"></a><span class='hs-definition'>emptyVarInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarInfo</span>
<a name="line-523"></a><span class='hs-definition'>emptyVarInfo</span> <span class='hs-varid'>x</span>
<a name="line-524"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>VI</span>
<a name="line-525"></a>  <span class='hs-layout'>{</span> <span class='hs-varid'>vi_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
<a name="line-526"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>vi_pos</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-527"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>vi_neg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyPmAltConSet</span>
<a name="line-528"></a>  <span class='hs-comment'>-- Why not set IsNotBot for unlifted type here?</span>
<a name="line-529"></a>  <span class='hs-comment'>-- Because we'd have to trigger an inhabitation test, which we can't.</span>
<a name="line-530"></a>  <span class='hs-comment'>-- See case (4) in Note [Strict fields and variables of unlifted type]</span>
<a name="line-531"></a>  <span class='hs-comment'>-- in GHC.HsToCore.Pmc.Solver</span>
<a name="line-532"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>vi_bot</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MaybeBot</span>
<a name="line-533"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>vi_rcm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyRCM</span>
<a name="line-534"></a>  <span class='hs-layout'>}</span>
<a name="line-535"></a>
<a name="line-536"></a><a name="lookupVarInfo"></a><span class='hs-definition'>lookupVarInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TmState</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarInfo</span>
<a name="line-537"></a><span class='hs-comment'>-- (lookupVarInfo tms x) tells what we know about 'x'</span>
<a name="line-538"></a><span class='hs-definition'>lookupVarInfo</span> <span class='hs-layout'>(</span><span class='hs-conid'>TmSt</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromMaybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyVarInfo</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupUSDFM</span> <span class='hs-varid'>env</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-539"></a>
<a name="line-540"></a><a name="lookupVarInfoNT"></a><span class='hs-comment'>-- | Like @lookupVarInfo ts x@, but @lookupVarInfo ts x = (y, vi)@ also looks</span>
<a name="line-541"></a><span class='hs-comment'>-- through newtype constructors. We have @x ~ N1 (... (Nk y))@ such that the</span>
<a name="line-542"></a><span class='hs-comment'>-- returned @y@ doesn't have a positive newtype constructor constraint</span>
<a name="line-543"></a><span class='hs-comment'>-- associated with it (yet). The 'VarInfo' returned is that of @y@'s</span>
<a name="line-544"></a><span class='hs-comment'>-- representative.</span>
<a name="line-545"></a><span class='hs-comment'>--</span>
<a name="line-546"></a><span class='hs-comment'>-- Careful, this means that @idType x@ might be different to @idType y@, even</span>
<a name="line-547"></a><span class='hs-comment'>-- modulo type normalisation!</span>
<a name="line-548"></a><span class='hs-comment'>--</span>
<a name="line-549"></a><span class='hs-comment'>-- See also Note [Coverage checking Newtype matches].</span>
<a name="line-550"></a><span class='hs-definition'>lookupVarInfoNT</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TmState</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>VarInfo</span><span class='hs-layout'>)</span>
<a name="line-551"></a><span class='hs-definition'>lookupVarInfoNT</span> <span class='hs-varid'>ts</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupVarInfo</span> <span class='hs-varid'>ts</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>of</span>
<a name="line-552"></a>  <span class='hs-conid'>VI</span><span class='hs-layout'>{</span> <span class='hs-varid'>vi_pos</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>as_newtype</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>y</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lookupVarInfoNT</span> <span class='hs-varid'>ts</span> <span class='hs-varid'>y</span>
<a name="line-553"></a>  <span class='hs-varid'>res</span>                                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>
<a name="line-554"></a>  <span class='hs-keyword'>where</span>
<a name="line-555"></a>    <span class='hs-varid'>as_newtype</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>listToMaybe</span> <span class='hs-varop'>.</span> <span class='hs-varid'>mapMaybe</span> <span class='hs-varid'>go</span>
<a name="line-556"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>PACA</span><span class='hs-layout'>{</span><span class='hs-varid'>paca_con</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PmAltConLike</span> <span class='hs-layout'>(</span><span class='hs-conid'>RealDataCon</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>paca_ids</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>}</span>
<a name="line-557"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNewDataCon</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>y</span>
<a name="line-558"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-559"></a>
<a name="line-560"></a><a name="trvVarInfo"></a><span class='hs-definition'>trvVarInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Functor</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>VarInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>VarInfo</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nabla</span><span class='hs-layout'>)</span>
<a name="line-561"></a><span class='hs-definition'>trvVarInfo</span> <span class='hs-varid'>f</span> <span class='hs-varid'>nabla</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>TmSt</span><span class='hs-layout'>{</span><span class='hs-varid'>ts_facts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-varid'>x</span>
<a name="line-562"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>set_vi</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupVarInfo</span> <span class='hs-varid'>ts</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-563"></a>  <span class='hs-keyword'>where</span>
<a name="line-564"></a>    <span class='hs-varid'>set_vi</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>vi'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-565"></a>      <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-layout'>{</span> <span class='hs-varid'>ts_facts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addToUSDFM</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>vi_id</span> <span class='hs-varid'>vi'</span><span class='hs-layout'>)</span> <span class='hs-varid'>vi'</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-566"></a>
<a name="line-567"></a><span class='hs-comment'>{- Note [Coverage checking Newtype matches]
<a name="line-568"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-569"></a>Newtypes have quite peculiar match semantics compared to ordinary DataCons. In a
<a name="line-570"></a>pattern-match, they behave like a irrefutable (lazy) match, but for inhabitation
<a name="line-571"></a>testing purposes (e.g. at construction sites), they behave rather like a DataCon
<a name="line-572"></a>with a *strict* field, because they don't contribute their own bottom and are
<a name="line-573"></a>inhabited iff the wrapped type is inhabited.
<a name="line-574"></a>
<a name="line-575"></a>This distinction becomes apparent in #17248:
<a name="line-576"></a>
<a name="line-577"></a>  newtype T2 a = T2 a
<a name="line-578"></a>  g _      True = ()
<a name="line-579"></a>  g (T2 _) True = ()
<a name="line-580"></a>  g !_     True = ()
<a name="line-581"></a>
<a name="line-582"></a>If we treat Newtypes like we treat regular DataCons, we would mark the third
<a name="line-583"></a>clause as redundant, which clearly is unsound. The solution:
<a name="line-584"></a>1. 'isPmAltConMatchStrict' returns False for newtypes, indicating that a
<a name="line-585"></a>   newtype match is lazy.
<a name="line-586"></a>2. When we find @x ~ T2 y@, transfer all constraints on @x@ (which involve @@)
<a name="line-587"></a>   to @y@, similar to what 'equate' does, and don't add a @x  @ constraint.
<a name="line-588"></a>   This way, the third clause will still be marked as inaccessible RHS instead
<a name="line-589"></a>   of redundant. This is ensured by calling 'lookupVarInfoNT'.
<a name="line-590"></a>3. Immediately reject when we find @x  T2@.
<a name="line-591"></a>Handling of Newtypes is also described in the Appendix of the Lower Your Guards paper,
<a name="line-592"></a>where you can find the solution in a perhaps more digestible format.
<a name="line-593"></a>-}</span>
<a name="line-594"></a>
<a name="line-595"></a><span class='hs-comment'>------------------------------------------------</span>
<a name="line-596"></a><span class='hs-comment'>-- * Exported utility functions querying 'Nabla'</span>
<a name="line-597"></a>
<a name="line-598"></a><a name="lookupRefuts"></a><span class='hs-definition'>lookupRefuts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PmAltCon</span><span class='hs-keyglyph'>]</span>
<a name="line-599"></a><span class='hs-comment'>-- Unfortunately we need the extra bit of polymorphism and the unfortunate</span>
<a name="line-600"></a><span class='hs-comment'>-- duplication of lookupVarInfo here.</span>
<a name="line-601"></a><span class='hs-definition'>lookupRefuts</span> <span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span> <span class='hs-layout'>}</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span>
<a name="line-602"></a>  <span class='hs-varid'>pmAltConSetElems</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vi_neg</span> <span class='hs-varop'>$</span> <span class='hs-varid'>lookupVarInfo</span> <span class='hs-varid'>ts</span> <span class='hs-varid'>x</span>
<a name="line-603"></a>
<a name="line-604"></a><a name="isDataConSolution"></a><span class='hs-definition'>isDataConSolution</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PmAltConApp</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-605"></a><span class='hs-definition'>isDataConSolution</span> <span class='hs-conid'>PACA</span><span class='hs-layout'>{</span><span class='hs-varid'>paca_con</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PmAltConLike</span> <span class='hs-layout'>(</span><span class='hs-conid'>RealDataCon</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-606"></a><span class='hs-definition'>isDataConSolution</span> <span class='hs-keyword'>_</span>                                             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-607"></a>
<a name="line-608"></a><a name="lookupSolution"></a><span class='hs-comment'>-- @lookupSolution nabla x@ picks a single solution ('vi_pos') of @x@ from</span>
<a name="line-609"></a><span class='hs-comment'>-- possibly many, preferring 'RealDataCon' solutions whenever possible.</span>
<a name="line-610"></a><span class='hs-definition'>lookupSolution</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>PmAltConApp</span>
<a name="line-611"></a><span class='hs-definition'>lookupSolution</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>vi_pos</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupVarInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_tm_st</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-612"></a>  <span class='hs-conid'>[]</span>                                         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-613"></a>  <span class='hs-varid'>pos</span>
<a name="line-614"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>sol</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>find</span> <span class='hs-varid'>isDataConSolution</span> <span class='hs-varid'>pos</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>sol</span>
<a name="line-615"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span> <span class='hs-varid'>pos</span><span class='hs-layout'>)</span>
<a name="line-616"></a>
<a name="line-617"></a><span class='hs-comment'>-------------------------</span>
<a name="line-618"></a><span class='hs-comment'>-- * Adding  constraints</span>
<a name="line-619"></a><span class='hs-comment'>--</span>
<a name="line-620"></a><span class='hs-comment'>-- Figure 7 in the LYG paper.</span>
<a name="line-621"></a>
<a name="line-622"></a><a name="PhiCt"></a><span class='hs-comment'>-- | A high-level pattern-match constraint. Corresponds to  from Figure 3 of</span>
<a name="line-623"></a><a name="PhiCt"></a><span class='hs-comment'>-- the LYG paper.</span>
<a name="line-624"></a><a name="PhiCt"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>PhiCt</span>
<a name="line-625"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PhiTyCt</span> <span class='hs-varop'>!</span><span class='hs-conid'>PredType</span>
<a name="line-626"></a>  <span class='hs-comment'>-- ^ A type constraint "T ~ U".</span>
<a name="line-627"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PhiCoreCt</span>    <span class='hs-varop'>!</span><span class='hs-conid'>Id</span> <span class='hs-varop'>!</span><span class='hs-conid'>CoreExpr</span>
<a name="line-628"></a>  <span class='hs-comment'>-- ^ @PhiCoreCt x e@ encodes "x ~ e", equating @x@ with the 'CoreExpr' @e@.</span>
<a name="line-629"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PhiConCt</span>     <span class='hs-varop'>!</span><span class='hs-conid'>Id</span> <span class='hs-varop'>!</span><span class='hs-conid'>PmAltCon</span> <span class='hs-varop'>!</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>!</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>!</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span>
<a name="line-630"></a>  <span class='hs-comment'>-- ^ @PhiConCt x K tvs dicts ys@ encodes @K \@tvs dicts ys &lt;- x@, matching @x@</span>
<a name="line-631"></a>  <span class='hs-comment'>-- against the 'PmAltCon' application @K \@tvs dicts ys@, binding @tvs@,</span>
<a name="line-632"></a>  <span class='hs-comment'>-- @dicts@ and possibly unlifted fields @ys@ in the process.</span>
<a name="line-633"></a>  <span class='hs-comment'>-- See Note [Strict fields and variables of unlifted type].</span>
<a name="line-634"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PhiNotConCt</span>  <span class='hs-varop'>!</span><span class='hs-conid'>Id</span> <span class='hs-varop'>!</span><span class='hs-conid'>PmAltCon</span>
<a name="line-635"></a>  <span class='hs-comment'>-- ^ @PhiNotConCt x K@ encodes "x  K", asserting that @x@ can't be headed</span>
<a name="line-636"></a>  <span class='hs-comment'>-- by @K@.</span>
<a name="line-637"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PhiBotCt</span>     <span class='hs-varop'>!</span><span class='hs-conid'>Id</span>
<a name="line-638"></a>  <span class='hs-comment'>-- ^ @PhiBotCt x@ encodes "x ~ ", equating @x@ to .</span>
<a name="line-639"></a>  <span class='hs-comment'>-- by @K@.</span>
<a name="line-640"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PhiNotBotCt</span> <span class='hs-varop'>!</span><span class='hs-conid'>Id</span>
<a name="line-641"></a>  <span class='hs-comment'>-- ^ @PhiNotBotCt x y@ encodes "x  ", asserting that @x@ can't be .</span>
<a name="line-642"></a>
<a name="line-643"></a><a name="instance%20Outputable%20PhiCt"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>PhiCt</span> <span class='hs-keyword'>where</span>
<a name="line-644"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiTyCt</span> <span class='hs-varid'>ty_ct</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty_ct</span>
<a name="line-645"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiCoreCt</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'~'</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>e</span>
<a name="line-646"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiConCt</span> <span class='hs-varid'>x</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>dicts</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-647"></a>    <span class='hs-varid'>hsep</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>con</span> <span class='hs-conop'>:</span> <span class='hs-varid'>pp_tvs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>pp_dicts</span> <span class='hs-varop'>++</span> <span class='hs-varid'>pp_args</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"&lt;-"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>x</span>
<a name="line-648"></a>    <span class='hs-keyword'>where</span>
<a name="line-649"></a>      <span class='hs-varid'>pp_tvs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'@'</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>ppr</span><span class='hs-layout'>)</span> <span class='hs-varid'>tvs</span>
<a name="line-650"></a>      <span class='hs-varid'>pp_dicts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dicts</span>
<a name="line-651"></a>      <span class='hs-varid'>pp_args</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>args</span>
<a name="line-652"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiNotConCt</span> <span class='hs-varid'>x</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>""</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>con</span>
<a name="line-653"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiBotCt</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>                    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"~ "</span>
<a name="line-654"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiNotBotCt</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>" "</span>
<a name="line-655"></a>
<a name="line-656"></a><a name="PhiCts"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>PhiCts</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>PhiCt</span>
<a name="line-657"></a>
<a name="line-658"></a><a name="initFuel"></a><span class='hs-comment'>-- | The fuel for the inhabitation test.</span>
<a name="line-659"></a><span class='hs-comment'>-- See Note [Fuel for the inhabitation test].</span>
<a name="line-660"></a><span class='hs-definition'>initFuel</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-661"></a><span class='hs-definition'>initFuel</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>4</span> <span class='hs-comment'>-- 4 because it's the smallest number that passes f' in T17977b</span>
<a name="line-662"></a>
<a name="line-663"></a><a name="addPhiCts"></a><span class='hs-comment'>-- | Adds new constraints to 'Nabla' and returns 'Nothing' if that leads to a</span>
<a name="line-664"></a><span class='hs-comment'>-- contradiction.</span>
<a name="line-665"></a><span class='hs-comment'>--</span>
<a name="line-666"></a><span class='hs-comment'>-- In terms of the paper, this function models the \(_\) function in</span>
<a name="line-667"></a><span class='hs-comment'>-- Figure 7 on batches of  constraints.</span>
<a name="line-668"></a><span class='hs-definition'>addPhiCts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PhiCts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Nabla</span><span class='hs-layout'>)</span>
<a name="line-669"></a><span class='hs-comment'>-- See Note [TmState invariants].</span>
<a name="line-670"></a><span class='hs-definition'>addPhiCts</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>cts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runMaybeT</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-671"></a>  <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty_cts</span><span class='hs-layout'>,</span> <span class='hs-varid'>tm_cts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionPhiCts</span> <span class='hs-varid'>cts</span>
<a name="line-672"></a>  <span class='hs-varid'>nabla'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addTyCts</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-varid'>listToBag</span> <span class='hs-varid'>ty_cts</span><span class='hs-layout'>)</span>
<a name="line-673"></a>  <span class='hs-varid'>nabla''</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>foldlM</span> <span class='hs-varid'>addPhiTmCt</span> <span class='hs-varid'>nabla'</span> <span class='hs-layout'>(</span><span class='hs-varid'>listToBag</span> <span class='hs-varid'>tm_cts</span><span class='hs-layout'>)</span>
<a name="line-674"></a>  <span class='hs-varid'>inhabitationTest</span> <span class='hs-varid'>initFuel</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_ty_st</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span> <span class='hs-varid'>nabla''</span>
<a name="line-675"></a>
<a name="line-676"></a><a name="partitionPhiCts"></a><span class='hs-definition'>partitionPhiCts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PhiCts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PhiCt</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-677"></a><span class='hs-definition'>partitionPhiCts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionEithers</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>to_either</span> <span class='hs-varop'>.</span> <span class='hs-varid'>toList</span>
<a name="line-678"></a>  <span class='hs-keyword'>where</span>
<a name="line-679"></a>    <span class='hs-varid'>to_either</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiTyCt</span> <span class='hs-varid'>pred_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-varid'>pred_ty</span>
<a name="line-680"></a>    <span class='hs-varid'>to_either</span> <span class='hs-varid'>ct</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>ct</span>
<a name="line-681"></a>
<a name="line-682"></a><span class='hs-comment'>-----------------------------</span>
<a name="line-683"></a><span class='hs-comment'>-- ** Adding type constraints</span>
<a name="line-684"></a>
<a name="line-685"></a><a name="addTyCts"></a><span class='hs-comment'>-- | Adds new type-level constraints by calling out to the type-checker via</span>
<a name="line-686"></a><span class='hs-comment'>-- 'tyOracle'.</span>
<a name="line-687"></a><span class='hs-definition'>addTyCts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nabla</span>
<a name="line-688"></a><span class='hs-definition'>addTyCts</span> <span class='hs-varid'>nabla</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_ty_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty_st</span> <span class='hs-layout'>}</span> <span class='hs-varid'>new_ty_cs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-689"></a>  <span class='hs-varid'>ty_st'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>MaybeT</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyOracle</span> <span class='hs-varid'>ty_st</span> <span class='hs-varid'>new_ty_cs</span><span class='hs-layout'>)</span>
<a name="line-690"></a>  <span class='hs-varid'>pure</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_ty_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty_st'</span> <span class='hs-layout'>}</span>
<a name="line-691"></a>
<a name="line-692"></a><a name="tyOracle"></a><span class='hs-comment'>-- | Add some extra type constraints to the 'TyState'; return 'Nothing' if we</span>
<a name="line-693"></a><span class='hs-comment'>-- find a contradiction (e.g. @Int ~ Bool@).</span>
<a name="line-694"></a><span class='hs-definition'>tyOracle</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyState</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>TyState</span><span class='hs-layout'>)</span>
<a name="line-695"></a><span class='hs-definition'>tyOracle</span> <span class='hs-varid'>ty_st</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>TySt</span> <span class='hs-varid'>n</span> <span class='hs-varid'>inert</span><span class='hs-layout'>)</span> <span class='hs-varid'>cts</span>
<a name="line-696"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>cts</span>
<a name="line-697"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>ty_st</span><span class='hs-layout'>)</span>
<a name="line-698"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-699"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>evs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>traverse</span> <span class='hs-varid'>nameTyCt</span> <span class='hs-varid'>cts</span>
<a name="line-700"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tracePm</span> <span class='hs-str'>"tyOracle"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>cts</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inert</span><span class='hs-layout'>)</span>
<a name="line-701"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mb_new_inert</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>initTcDsForSolver</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tcCheckGivens</span> <span class='hs-varid'>inert</span> <span class='hs-varid'>evs</span>
<a name="line-702"></a>         <span class='hs-comment'>-- return the new inert set and increment the sequence number n</span>
<a name="line-703"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>TySt</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>mb_new_inert</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-704"></a>
<a name="line-705"></a><a name="nameTyCt"></a><span class='hs-comment'>-- | Allocates a fresh 'EvVar' name for 'PredTy's.</span>
<a name="line-706"></a><span class='hs-definition'>nameTyCt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>EvVar</span>
<a name="line-707"></a><span class='hs-definition'>nameTyCt</span> <span class='hs-varid'>pred_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-708"></a>  <span class='hs-varid'>unique</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-709"></a>  <span class='hs-keyword'>let</span> <span class='hs-varid'>occname</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarOccFS</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-layout'>(</span><span class='hs-str'>"pm_"</span><span class='hs-varop'>++</span><span class='hs-varid'>show</span> <span class='hs-varid'>unique</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-710"></a>      <span class='hs-varid'>idname</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInternalName</span> <span class='hs-varid'>unique</span> <span class='hs-varid'>occname</span> <span class='hs-varid'>noSrcSpan</span>
<a name="line-711"></a>  <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLocalIdOrCoVar</span> <span class='hs-varid'>idname</span> <span class='hs-conid'>Many</span> <span class='hs-varid'>pred_ty</span><span class='hs-layout'>)</span>
<a name="line-712"></a>
<a name="line-713"></a><span class='hs-comment'>-----------------------------</span>
<a name="line-714"></a><span class='hs-comment'>-- ** Adding term constraints</span>
<a name="line-715"></a>
<a name="line-716"></a><a name="addPhiTmCt"></a><span class='hs-comment'>-- | Adds a single higher-level  constraint by dispatching to the various</span>
<a name="line-717"></a><span class='hs-comment'>-- oracle functions.</span>
<a name="line-718"></a><span class='hs-comment'>--</span>
<a name="line-719"></a><span class='hs-comment'>-- In terms of the paper, this function amounts to the constructor constraint</span>
<a name="line-720"></a><span class='hs-comment'>-- case of \(_\) in Figure 7, which "desugars" higher-level  constraints</span>
<a name="line-721"></a><span class='hs-comment'>-- into lower-level  constraints. We don't have a data type for  constraints</span>
<a name="line-722"></a><span class='hs-comment'>-- and call the corresponding oracle function directly instead.</span>
<a name="line-723"></a><span class='hs-comment'>--</span>
<a name="line-724"></a><span class='hs-comment'>-- Precondition: The  is /not/ a type constraint! These should be handled by</span>
<a name="line-725"></a><span class='hs-comment'>-- 'addTyCts' before, through 'addPhiCts'.</span>
<a name="line-726"></a><span class='hs-definition'>addPhiTmCt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PhiCt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nabla</span>
<a name="line-727"></a><span class='hs-definition'>addPhiTmCt</span> <span class='hs-keyword'>_</span>     <span class='hs-layout'>(</span><span class='hs-conid'>PhiTyCt</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"addPhiCt:TyCt"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- See the precondition</span>
<a name="line-728"></a><span class='hs-definition'>addPhiTmCt</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiCoreCt</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addCoreCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span>
<a name="line-729"></a><span class='hs-definition'>addPhiTmCt</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiConCt</span> <span class='hs-varid'>x</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>dicts</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-730"></a>  <span class='hs-comment'>-- Case (1) of Note [Strict fields and variables of unlifted type]</span>
<a name="line-731"></a>  <span class='hs-comment'>-- PhiConCt correspond to the higher-level  constraints from the paper with</span>
<a name="line-732"></a>  <span class='hs-comment'>-- bindings semantics. It disperses into lower-level  constraints that the</span>
<a name="line-733"></a>  <span class='hs-comment'>-- 'add*Ct' functions correspond to.</span>
<a name="line-734"></a>  <span class='hs-varid'>nabla'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addTyCts</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-varid'>listToBag</span> <span class='hs-varid'>dicts</span><span class='hs-layout'>)</span>
<a name="line-735"></a>  <span class='hs-varid'>nabla''</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addConCt</span> <span class='hs-varid'>nabla'</span> <span class='hs-varid'>x</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>args</span>
<a name="line-736"></a>  <span class='hs-varid'>foldlM</span> <span class='hs-varid'>addNotBotCt</span> <span class='hs-varid'>nabla''</span> <span class='hs-layout'>(</span><span class='hs-varid'>filterUnliftedFields</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-737"></a><span class='hs-definition'>addPhiTmCt</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiNotConCt</span> <span class='hs-varid'>x</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addNotConCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-varid'>con</span>
<a name="line-738"></a><span class='hs-definition'>addPhiTmCt</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiBotCt</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addBotCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span>
<a name="line-739"></a><span class='hs-definition'>addPhiTmCt</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiNotBotCt</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addNotBotCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span>
<a name="line-740"></a>
<a name="line-741"></a><a name="filterUnliftedFields"></a><span class='hs-definition'>filterUnliftedFields</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PmAltCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span>
<a name="line-742"></a><span class='hs-definition'>filterUnliftedFields</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span>
<a name="line-743"></a>  <span class='hs-keyglyph'>[</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>bang</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zipEqual</span> <span class='hs-str'>"addPhiCt"</span> <span class='hs-varid'>args</span> <span class='hs-layout'>(</span><span class='hs-varid'>pmAltConImplBangs</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span>
<a name="line-744"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>isBanged</span> <span class='hs-varid'>bang</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isUnliftedType</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-745"></a>
<a name="line-746"></a><a name="addBotCt"></a><span class='hs-comment'>-- | Adds the constraint @x ~ @, e.g. that evaluation of a particular 'Id' @x@</span>
<a name="line-747"></a><span class='hs-comment'>-- surely diverges. Quite similar to 'addConCt', only that it only cares about</span>
<a name="line-748"></a><span class='hs-comment'>-- .</span>
<a name="line-749"></a><span class='hs-definition'>addBotCt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nabla</span>
<a name="line-750"></a><span class='hs-definition'>addBotCt</span> <span class='hs-varid'>nabla</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>TmSt</span><span class='hs-layout'>{</span> <span class='hs-varid'>ts_facts</span><span class='hs-keyglyph'>=</span><span class='hs-varid'>env</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-751"></a>  <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-layout'>,</span> <span class='hs-varid'>vi</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>VI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>vi_bot</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bot</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupVarInfoNT</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_tm_st</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span>
<a name="line-752"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>bot</span> <span class='hs-keyword'>of</span>
<a name="line-753"></a>    <span class='hs-conid'>IsNotBot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mzero</span>      <span class='hs-comment'>-- There was x  . Contradiction!</span>
<a name="line-754"></a>    <span class='hs-conid'>IsBot</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>nabla</span> <span class='hs-comment'>-- There already is x ~ . Nothing left to do</span>
<a name="line-755"></a>    <span class='hs-conid'>MaybeBot</span> <span class='hs-keyglyph'>-&gt;</span>            <span class='hs-comment'>-- We add x ~ </span>
<a name="line-756"></a>      <span class='hs-comment'>-- Case (3) in Note [Strict fields and variables of unlifted type]</span>
<a name="line-757"></a>      <span class='hs-keyword'>if</span> <span class='hs-varid'>isUnliftedType</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-758"></a>        <span class='hs-keyword'>then</span> <span class='hs-varid'>mzero</span> <span class='hs-comment'>-- unlifted vars can never be </span>
<a name="line-759"></a>        <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span>
<a name="line-760"></a>          <span class='hs-keyword'>let</span> <span class='hs-varid'>vi'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vi</span><span class='hs-layout'>{</span> <span class='hs-varid'>vi_bot</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IsBot</span> <span class='hs-layout'>}</span>
<a name="line-761"></a>          <span class='hs-varid'>pure</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-layout'>{</span><span class='hs-varid'>ts_facts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addToUSDFM</span> <span class='hs-varid'>env</span> <span class='hs-varid'>y</span> <span class='hs-varid'>vi'</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-762"></a>
<a name="line-763"></a><a name="addNotBotCt"></a><span class='hs-comment'>-- | Adds the constraint @x ~/ @ to 'Nabla'. Quite similar to 'addNotConCt',</span>
<a name="line-764"></a><span class='hs-comment'>-- but only cares for the  "constructor".</span>
<a name="line-765"></a><span class='hs-definition'>addNotBotCt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nabla</span>
<a name="line-766"></a><span class='hs-definition'>addNotBotCt</span> <span class='hs-varid'>nabla</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>TmSt</span><span class='hs-layout'>{</span><span class='hs-varid'>ts_facts</span><span class='hs-keyglyph'>=</span><span class='hs-varid'>env</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-767"></a>  <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-layout'>,</span> <span class='hs-varid'>vi</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>VI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>vi_bot</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bot</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupVarInfoNT</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_tm_st</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span>
<a name="line-768"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>bot</span> <span class='hs-keyword'>of</span>
<a name="line-769"></a>    <span class='hs-conid'>IsBot</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mzero</span>      <span class='hs-comment'>-- There was x ~ . Contradiction!</span>
<a name="line-770"></a>    <span class='hs-conid'>IsNotBot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>nabla</span> <span class='hs-comment'>-- There already is x  . Nothing left to do</span>
<a name="line-771"></a>    <span class='hs-conid'>MaybeBot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>         <span class='hs-comment'>-- We add x   and test if x is still inhabited</span>
<a name="line-772"></a>      <span class='hs-comment'>-- Mark dirty for a delayed inhabitation test</span>
<a name="line-773"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>vi'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vi</span><span class='hs-layout'>{</span> <span class='hs-varid'>vi_bot</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IsNotBot</span><span class='hs-layout'>}</span>
<a name="line-774"></a>      <span class='hs-varid'>pure</span> <span class='hs-varop'>$</span> <span class='hs-varid'>markDirty</span> <span class='hs-varid'>y</span>
<a name="line-775"></a>           <span class='hs-varop'>$</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-layout'>{</span> <span class='hs-varid'>ts_facts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addToUSDFM</span> <span class='hs-varid'>env</span> <span class='hs-varid'>y</span> <span class='hs-varid'>vi'</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-776"></a>
<a name="line-777"></a><a name="addNotConCt"></a><span class='hs-comment'>-- | Record a @x ~/ K@ constraint, e.g. that a particular 'Id' @x@ can't</span>
<a name="line-778"></a><span class='hs-comment'>-- take the shape of a 'PmAltCon' @K@ in the 'Nabla' and return @Nothing@ if</span>
<a name="line-779"></a><span class='hs-comment'>-- that leads to a contradiction.</span>
<a name="line-780"></a><span class='hs-comment'>-- See Note [TmState invariants].</span>
<a name="line-781"></a><span class='hs-definition'>addNotConCt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PmAltCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nabla</span>
<a name="line-782"></a><span class='hs-definition'>addNotConCt</span> <span class='hs-keyword'>_</span>     <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmAltConLike</span> <span class='hs-layout'>(</span><span class='hs-conid'>RealDataCon</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-783"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNewDataCon</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mzero</span> <span class='hs-comment'>-- (3) in Note [Coverage checking Newtype matches]</span>
<a name="line-784"></a><span class='hs-definition'>addNotConCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-varid'>nalt</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-785"></a>  <span class='hs-layout'>(</span><span class='hs-varid'>mb_mark_dirty</span><span class='hs-layout'>,</span> <span class='hs-varid'>nabla'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>trvVarInfo</span> <span class='hs-varid'>go</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span>
<a name="line-786"></a>  <span class='hs-varid'>pure</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_mark_dirty</span> <span class='hs-keyword'>of</span>
<a name="line-787"></a>    <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>markDirty</span> <span class='hs-varid'>x</span> <span class='hs-varid'>nabla'</span>
<a name="line-788"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>nabla'</span>
<a name="line-789"></a>  <span class='hs-keyword'>where</span>
<a name="line-790"></a>    <span class='hs-comment'>-- | Update `x`'s 'VarInfo' entry. Fail ('MaybeT') if contradiction,</span>
<a name="line-791"></a>    <span class='hs-comment'>-- otherwise return updated entry and `Just x'` if `x` should be marked dirty,</span>
<a name="line-792"></a>    <span class='hs-comment'>-- where `x'` is the representative of `x`.</span>
<a name="line-793"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>VarInfo</span><span class='hs-layout'>)</span>
<a name="line-794"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>vi</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>VI</span> <span class='hs-varid'>x'</span> <span class='hs-varid'>pos</span> <span class='hs-varid'>neg</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>rcm</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-795"></a>      <span class='hs-comment'>-- 1. Bail out quickly when nalt contradicts a solution</span>
<a name="line-796"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>contradicts</span> <span class='hs-varid'>nalt</span> <span class='hs-varid'>sol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqPmAltCon</span> <span class='hs-layout'>(</span><span class='hs-varid'>paca_con</span> <span class='hs-varid'>sol</span><span class='hs-layout'>)</span> <span class='hs-varid'>nalt</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Equal</span>
<a name="line-797"></a>      <span class='hs-varid'>guard</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>contradicts</span> <span class='hs-varid'>nalt</span><span class='hs-layout'>)</span> <span class='hs-varid'>pos</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-798"></a>      <span class='hs-comment'>-- 2. Only record the new fact when it's not already implied by one of the</span>
<a name="line-799"></a>      <span class='hs-comment'>-- solutions</span>
<a name="line-800"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>implies</span> <span class='hs-varid'>nalt</span> <span class='hs-varid'>sol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqPmAltCon</span> <span class='hs-layout'>(</span><span class='hs-varid'>paca_con</span> <span class='hs-varid'>sol</span><span class='hs-layout'>)</span> <span class='hs-varid'>nalt</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Disjoint</span>
<a name="line-801"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>neg'</span>
<a name="line-802"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>implies</span> <span class='hs-varid'>nalt</span><span class='hs-layout'>)</span> <span class='hs-varid'>pos</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>neg</span>
<a name="line-803"></a>            <span class='hs-comment'>-- See Note [Completeness checking with required Thetas]</span>
<a name="line-804"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>hasRequiredTheta</span> <span class='hs-varid'>nalt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>neg</span>
<a name="line-805"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendPmAltConSet</span> <span class='hs-varid'>neg</span> <span class='hs-varid'>nalt</span>
<a name="line-806"></a>      <span class='hs-conid'>MASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isPmAltConMatchStrict</span> <span class='hs-varid'>nalt</span> <span class='hs-layout'>)</span>
<a name="line-807"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>vi'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vi</span><span class='hs-layout'>{</span> <span class='hs-varid'>vi_neg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>neg'</span><span class='hs-layout'>,</span> <span class='hs-varid'>vi_bot</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IsNotBot</span> <span class='hs-layout'>}</span>
<a name="line-808"></a>      <span class='hs-comment'>-- 3. Make sure there's at least one other possible constructor</span>
<a name="line-809"></a>      <span class='hs-varid'>mb_rcm'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lift</span> <span class='hs-layout'>(</span><span class='hs-varid'>markMatched</span> <span class='hs-varid'>nalt</span> <span class='hs-varid'>rcm</span><span class='hs-layout'>)</span>
<a name="line-810"></a>      <span class='hs-varid'>pure</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_rcm'</span> <span class='hs-keyword'>of</span>
<a name="line-811"></a>        <span class='hs-comment'>-- If nalt could be removed from a COMPLETE set, we'll get back Just and</span>
<a name="line-812"></a>        <span class='hs-comment'>-- have to mark x dirty, by returning Just x'.</span>
<a name="line-813"></a>        <span class='hs-conid'>Just</span> <span class='hs-varid'>rcm'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>x'</span><span class='hs-layout'>,</span>  <span class='hs-varid'>vi'</span><span class='hs-layout'>{</span> <span class='hs-varid'>vi_rcm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rcm'</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-814"></a>        <span class='hs-comment'>-- Otherwise, nalt didn't occur in any residual COMPLETE set and we</span>
<a name="line-815"></a>        <span class='hs-comment'>-- don't have to mark it dirty. So we return Nothing, which in the case</span>
<a name="line-816"></a>        <span class='hs-comment'>-- above would have compromised precision.</span>
<a name="line-817"></a>        <span class='hs-comment'>-- See Note [Shortcutting the inhabitation test], grep for T17836.</span>
<a name="line-818"></a>        <span class='hs-conid'>Nothing</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-varid'>vi'</span><span class='hs-layout'>)</span>
<a name="line-819"></a>
<a name="line-820"></a><a name="hasRequiredTheta"></a><span class='hs-definition'>hasRequiredTheta</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PmAltCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-821"></a><span class='hs-definition'>hasRequiredTheta</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmAltConLike</span> <span class='hs-varid'>cl</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>notNull</span> <span class='hs-varid'>req_theta</span>
<a name="line-822"></a>  <span class='hs-keyword'>where</span>
<a name="line-823"></a>    <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>req_theta</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>conLikeFullSig</span> <span class='hs-varid'>cl</span>
<a name="line-824"></a><span class='hs-definition'>hasRequiredTheta</span> <span class='hs-keyword'>_</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-825"></a>
<a name="line-826"></a><a name="addConCt"></a><span class='hs-comment'>-- | Add a @x ~ K tvs args ts@ constraint.</span>
<a name="line-827"></a><span class='hs-comment'>-- @addConCt x K tvs args ts@ extends the substitution with a solution</span>
<a name="line-828"></a><span class='hs-comment'>-- @x :-&gt; (K, tvs, args)@ if compatible with the negative and positive info we</span>
<a name="line-829"></a><span class='hs-comment'>-- have on @x@, reject (@Nothing@) otherwise.</span>
<a name="line-830"></a><span class='hs-comment'>--</span>
<a name="line-831"></a><span class='hs-comment'>-- See Note [TmState invariants].</span>
<a name="line-832"></a><span class='hs-definition'>addConCt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PmAltCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nabla</span>
<a name="line-833"></a><span class='hs-definition'>addConCt</span> <span class='hs-varid'>nabla</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>TmSt</span><span class='hs-layout'>{</span> <span class='hs-varid'>ts_facts</span><span class='hs-keyglyph'>=</span><span class='hs-varid'>env</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-varid'>x</span> <span class='hs-varid'>alt</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-834"></a>  <span class='hs-keyword'>let</span> <span class='hs-varid'>vi</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>VI</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>pos</span> <span class='hs-varid'>neg</span> <span class='hs-varid'>bot</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupVarInfo</span> <span class='hs-varid'>ts</span> <span class='hs-varid'>x</span>
<a name="line-835"></a>  <span class='hs-comment'>-- First try to refute with a negative fact</span>
<a name="line-836"></a>  <span class='hs-varid'>guard</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>elemPmAltConSet</span> <span class='hs-varid'>alt</span> <span class='hs-varid'>neg</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-837"></a>  <span class='hs-comment'>-- Then see if any of the other solutions (remember: each of them is an</span>
<a name="line-838"></a>  <span class='hs-comment'>-- additional refinement of the possible values x could take) indicate a</span>
<a name="line-839"></a>  <span class='hs-comment'>-- contradiction</span>
<a name="line-840"></a>  <span class='hs-varid'>guard</span> <span class='hs-layout'>(</span><span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>/=</span> <span class='hs-conid'>Disjoint</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>eqPmAltCon</span> <span class='hs-varid'>alt</span> <span class='hs-varop'>.</span> <span class='hs-varid'>paca_con</span><span class='hs-layout'>)</span> <span class='hs-varid'>pos</span><span class='hs-layout'>)</span>
<a name="line-841"></a>  <span class='hs-comment'>-- Now we should be good! Add (alt, tvs, args) as a possible solution, or</span>
<a name="line-842"></a>  <span class='hs-comment'>-- refine an existing one</span>
<a name="line-843"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>find</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>==</span> <span class='hs-conid'>Equal</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>eqPmAltCon</span> <span class='hs-varid'>alt</span> <span class='hs-varop'>.</span> <span class='hs-varid'>paca_con</span><span class='hs-layout'>)</span> <span class='hs-varid'>pos</span> <span class='hs-keyword'>of</span>
<a name="line-844"></a>    <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>PACA</span> <span class='hs-sel'>_con</span> <span class='hs-varid'>other_tvs</span> <span class='hs-varid'>other_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-845"></a>      <span class='hs-comment'>-- We must unify existentially bound ty vars and arguments!</span>
<a name="line-846"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>ty_cts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>equateTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>other_tvs</span><span class='hs-layout'>)</span>
<a name="line-847"></a>      <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>args</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>other_args</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-848"></a>        <span class='hs-varid'>lift</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tracePm</span> <span class='hs-str'>"error"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>alt</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>args</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>other_args</span><span class='hs-layout'>)</span>
<a name="line-849"></a>      <span class='hs-varid'>nabla'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>MaybeT</span> <span class='hs-varop'>$</span> <span class='hs-varid'>addPhiCts</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-varid'>listToBag</span> <span class='hs-varid'>ty_cts</span><span class='hs-layout'>)</span>
<a name="line-850"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>add_var_ct</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addVarCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span>
<a name="line-851"></a>      <span class='hs-varid'>foldlM</span> <span class='hs-varid'>add_var_ct</span> <span class='hs-varid'>nabla'</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zipEqual</span> <span class='hs-str'>"addConCt"</span> <span class='hs-varid'>args</span> <span class='hs-varid'>other_args</span>
<a name="line-852"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-853"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>pos'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PACA</span> <span class='hs-varid'>alt</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>args</span> <span class='hs-conop'>:</span> <span class='hs-varid'>pos</span>
<a name="line-854"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>nabla_with</span> <span class='hs-varid'>bot'</span> <span class='hs-keyglyph'>=</span>
<a name="line-855"></a>            <span class='hs-varid'>nabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-layout'>{</span><span class='hs-varid'>ts_facts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addToUSDFM</span> <span class='hs-varid'>env</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>vi</span><span class='hs-layout'>{</span><span class='hs-varid'>vi_pos</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pos'</span><span class='hs-layout'>,</span> <span class='hs-varid'>vi_bot</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bot'</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-856"></a>      <span class='hs-comment'>-- Do (2) in Note [Coverage checking Newtype matches]</span>
<a name="line-857"></a>      <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>alt</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-858"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>PmAltConLike</span> <span class='hs-layout'>(</span><span class='hs-conid'>RealDataCon</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNewDataCon</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-859"></a>          <span class='hs-keyword'>case</span> <span class='hs-varid'>bot</span> <span class='hs-keyword'>of</span>
<a name="line-860"></a>            <span class='hs-conid'>MaybeBot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_with</span> <span class='hs-conid'>MaybeBot</span><span class='hs-layout'>)</span>
<a name="line-861"></a>            <span class='hs-conid'>IsBot</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addBotCt</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_with</span> <span class='hs-conid'>MaybeBot</span><span class='hs-layout'>)</span> <span class='hs-varid'>y</span>
<a name="line-862"></a>            <span class='hs-conid'>IsNotBot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addNotBotCt</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_with</span> <span class='hs-conid'>MaybeBot</span><span class='hs-layout'>)</span> <span class='hs-varid'>y</span>
<a name="line-863"></a>        <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isPmAltConMatchStrict</span> <span class='hs-varid'>alt</span> <span class='hs-layout'>)</span>
<a name="line-864"></a>             <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_with</span> <span class='hs-conid'>IsNotBot</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- strict match ==&gt; not </span>
<a name="line-865"></a>
<a name="line-866"></a><a name="equateTys"></a><span class='hs-definition'>equateTys</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PhiCt</span><span class='hs-keyglyph'>]</span>
<a name="line-867"></a><span class='hs-definition'>equateTys</span> <span class='hs-varid'>ts</span> <span class='hs-varid'>us</span> <span class='hs-keyglyph'>=</span>
<a name="line-868"></a>  <span class='hs-keyglyph'>[</span> <span class='hs-conid'>PhiTyCt</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkPrimEqPred</span> <span class='hs-varid'>t</span> <span class='hs-varid'>u</span><span class='hs-layout'>)</span>
<a name="line-869"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-varid'>u</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zipEqual</span> <span class='hs-str'>"equateTys"</span> <span class='hs-varid'>ts</span> <span class='hs-varid'>us</span>
<a name="line-870"></a>  <span class='hs-comment'>-- The following line filters out trivial Refl constraints, so that we don't</span>
<a name="line-871"></a>  <span class='hs-comment'>-- need to initialise the type oracle that often</span>
<a name="line-872"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqType</span> <span class='hs-varid'>t</span> <span class='hs-varid'>u</span><span class='hs-layout'>)</span>
<a name="line-873"></a>  <span class='hs-keyglyph'>]</span>
<a name="line-874"></a>
<a name="line-875"></a><a name="addVarCt"></a><span class='hs-comment'>-- | Adds a @x ~ y@ constraint by merging the two 'VarInfo's and record the</span>
<a name="line-876"></a><span class='hs-comment'>-- gained knowledge in 'Nabla'.</span>
<a name="line-877"></a><span class='hs-comment'>--</span>
<a name="line-878"></a><span class='hs-comment'>-- Returns @Nothing@ when there's a contradiction while merging. Returns @Just</span>
<a name="line-879"></a><span class='hs-comment'>-- nabla@ when the constraint was compatible with prior facts, in which case</span>
<a name="line-880"></a><span class='hs-comment'>-- @nabla@ has integrated the knowledge from the equality constraint.</span>
<a name="line-881"></a><span class='hs-comment'>--</span>
<a name="line-882"></a><span class='hs-comment'>-- See Note [TmState invariants].</span>
<a name="line-883"></a><span class='hs-definition'>addVarCt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nabla</span>
<a name="line-884"></a><span class='hs-definition'>addVarCt</span> <span class='hs-varid'>nabla</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>TmSt</span><span class='hs-layout'>{</span> <span class='hs-varid'>ts_facts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span>
<a name="line-885"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>equateUSDFM</span> <span class='hs-varid'>env</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>of</span>
<a name="line-886"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span>   <span class='hs-varid'>env'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-layout'>{</span> <span class='hs-varid'>ts_facts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env'</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-887"></a>    <span class='hs-comment'>-- Add the constraints we had for x to y</span>
<a name="line-888"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>vi_x</span><span class='hs-layout'>,</span> <span class='hs-varid'>env'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-889"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>nabla_equated</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-layout'>{</span><span class='hs-varid'>ts_facts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env'</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-890"></a>      <span class='hs-comment'>-- and then gradually merge every positive fact we have on x into y</span>
<a name="line-891"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>add_pos</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>PACA</span> <span class='hs-varid'>cl</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addConCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>y</span> <span class='hs-varid'>cl</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>args</span>
<a name="line-892"></a>      <span class='hs-varid'>nabla_pos</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>foldlM</span> <span class='hs-varid'>add_pos</span> <span class='hs-varid'>nabla_equated</span> <span class='hs-layout'>(</span><span class='hs-varid'>vi_pos</span> <span class='hs-varid'>vi_x</span><span class='hs-layout'>)</span>
<a name="line-893"></a>      <span class='hs-comment'>-- Do the same for negative info</span>
<a name="line-894"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>add_neg</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>nalt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addNotConCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>y</span> <span class='hs-varid'>nalt</span>
<a name="line-895"></a>      <span class='hs-varid'>foldlM</span> <span class='hs-varid'>add_neg</span> <span class='hs-varid'>nabla_pos</span> <span class='hs-layout'>(</span><span class='hs-varid'>pmAltConSetElems</span> <span class='hs-layout'>(</span><span class='hs-varid'>vi_neg</span> <span class='hs-varid'>vi_x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-896"></a>
<a name="line-897"></a><a name="addCoreCt"></a><span class='hs-comment'>-- | Inspects a 'PmCoreCt' @let x = e@ by recording constraints for @x@ based</span>
<a name="line-898"></a><span class='hs-comment'>-- on the shape of the 'CoreExpr' @e@. Examples:</span>
<a name="line-899"></a><span class='hs-comment'>--</span>
<a name="line-900"></a><span class='hs-comment'>--   * For @let x = Just (42, 'z')@ we want to record the</span>
<a name="line-901"></a><span class='hs-comment'>--     constraints @x ~ Just a, a ~ (b, c), b ~ 42, c ~ 'z'@.</span>
<a name="line-902"></a><span class='hs-comment'>--     See 'data_con_app'.</span>
<a name="line-903"></a><span class='hs-comment'>--   * For @let x = unpackCString# "tmp"@ we want to record the literal</span>
<a name="line-904"></a><span class='hs-comment'>--     constraint @x ~ "tmp"@.</span>
<a name="line-905"></a><span class='hs-comment'>--   * For @let x = I# 42@ we want the literal constraint @x ~ 42@. Similar</span>
<a name="line-906"></a><span class='hs-comment'>--     for other literals. See 'coreExprAsPmLit'.</span>
<a name="line-907"></a><span class='hs-comment'>--   * Finally, if we have @let x = e@ and we already have seen @let y = e@, we</span>
<a name="line-908"></a><span class='hs-comment'>--     want to record @x ~ y@.</span>
<a name="line-909"></a><span class='hs-definition'>addCoreCt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nabla</span>
<a name="line-910"></a><span class='hs-definition'>addCoreCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-911"></a>  <span class='hs-varid'>simpl_opts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>initSimpleOpts</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-912"></a>  <span class='hs-keyword'>let</span> <span class='hs-varid'>e'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simpleOptExpr</span> <span class='hs-varid'>simpl_opts</span> <span class='hs-varid'>e</span>
<a name="line-913"></a>  <span class='hs-comment'>-- lift $ tracePm "addCoreCt" (ppr x &lt;+&gt; dcolon &lt;+&gt; ppr (idType x) $$ ppr e $$ ppr e')</span>
<a name="line-914"></a>  <span class='hs-varid'>execStateT</span> <span class='hs-layout'>(</span><span class='hs-varid'>core_expr</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span> <span class='hs-varid'>nabla</span>
<a name="line-915"></a>  <span class='hs-keyword'>where</span>
<a name="line-916"></a>    <span class='hs-comment'>-- | Takes apart a 'CoreExpr' and tries to extract as much information about</span>
<a name="line-917"></a>    <span class='hs-comment'>-- literals and constructor applications as possible.</span>
<a name="line-918"></a>    <span class='hs-varid'>core_expr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StateT</span> <span class='hs-conid'>Nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span><span class='hs-layout'>)</span> <span class='hs-conid'>()</span>
<a name="line-919"></a>    <span class='hs-comment'>-- TODO: Handle newtypes properly, by wrapping the expression in a DataCon</span>
<a name="line-920"></a>    <span class='hs-comment'>-- This is the right thing for casts involving data family instances and</span>
<a name="line-921"></a>    <span class='hs-comment'>-- their representation TyCon, though (which are not visible in source</span>
<a name="line-922"></a>    <span class='hs-comment'>-- syntax). See Note [COMPLETE sets on data families]</span>
<a name="line-923"></a>    <span class='hs-comment'>-- core_expr x e | pprTrace "core_expr" (ppr x $$ ppr e) False = undefined</span>
<a name="line-924"></a>    <span class='hs-varid'>core_expr</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-sel'>_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>core_expr</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span>
<a name="line-925"></a>    <span class='hs-varid'>core_expr</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-sel'>_t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>core_expr</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span>
<a name="line-926"></a>    <span class='hs-varid'>core_expr</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span>
<a name="line-927"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>pmLitAsStringLit</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>coreExprAsPmLit</span> <span class='hs-varid'>e</span>
<a name="line-928"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>expr_ty</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>stringTy</span>
<a name="line-929"></a>      <span class='hs-comment'>-- See Note [Representation of Strings in TmState]</span>
<a name="line-930"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>unpackFS</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span>
<a name="line-931"></a>          <span class='hs-comment'>-- We need this special case to break a loop with coreExprAsPmLit</span>
<a name="line-932"></a>          <span class='hs-comment'>-- Otherwise we alternate endlessly between [] and ""</span>
<a name="line-933"></a>          <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>data_con_app</span> <span class='hs-varid'>x</span> <span class='hs-varid'>emptyInScopeSet</span> <span class='hs-varid'>nilDataCon</span> <span class='hs-conid'>[]</span>
<a name="line-934"></a>          <span class='hs-varid'>s'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>core_expr</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkListExpr</span> <span class='hs-varid'>charTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>mkCharExpr</span> <span class='hs-varid'>s'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-935"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>lit</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>coreExprAsPmLit</span> <span class='hs-varid'>e</span>
<a name="line-936"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pm_lit</span> <span class='hs-varid'>x</span> <span class='hs-varid'>lit</span>
<a name="line-937"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>in_scope</span><span class='hs-layout'>,</span> <span class='hs-sel'>_empty_floats</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>dc</span><span class='hs-layout'>,</span> <span class='hs-sel'>_arg_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-938"></a>            <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>exprIsConApp_maybe</span> <span class='hs-varid'>in_scope_env</span> <span class='hs-varid'>e</span>
<a name="line-939"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>data_con_app</span> <span class='hs-varid'>x</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>args</span>
<a name="line-940"></a>      <span class='hs-comment'>-- See Note [Detecting pattern synonym applications in expressions]</span>
<a name="line-941"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isDataConId_maybe</span> <span class='hs-varid'>x</span>
<a name="line-942"></a>      <span class='hs-comment'>-- We don't consider DataCons flexible variables</span>
<a name="line-943"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modifyT</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addVarCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-944"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-945"></a>      <span class='hs-comment'>-- Any other expression. Try to find other uses of a semantically</span>
<a name="line-946"></a>      <span class='hs-comment'>-- equivalent expression and represent them by the same variable!</span>
<a name="line-947"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>equate_with_similar_expr</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span>
<a name="line-948"></a>      <span class='hs-keyword'>where</span>
<a name="line-949"></a>        <span class='hs-varid'>expr_ty</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprType</span> <span class='hs-varid'>e</span>
<a name="line-950"></a>        <span class='hs-varid'>expr_in_scope</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInScopeSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprFreeVars</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-951"></a>        <span class='hs-varid'>in_scope_env</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>expr_in_scope</span><span class='hs-layout'>,</span> <span class='hs-varid'>const</span> <span class='hs-conid'>NoUnfolding</span><span class='hs-layout'>)</span>
<a name="line-952"></a>        <span class='hs-comment'>-- It's inconvenient to get hold of a global in-scope set</span>
<a name="line-953"></a>        <span class='hs-comment'>-- here, but it'll only be needed if exprIsConApp_maybe ends</span>
<a name="line-954"></a>        <span class='hs-comment'>-- up substituting inside a forall or lambda (i.e. seldom)</span>
<a name="line-955"></a>        <span class='hs-comment'>-- so using exprFreeVars seems fine.   See MR !1647.</span>
<a name="line-956"></a>
<a name="line-957"></a>    <span class='hs-comment'>-- | The @e@ in @let x = e@ had no familiar form. But we can still see if</span>
<a name="line-958"></a>    <span class='hs-comment'>-- see if we already encountered a constraint @let y = e'@ with @e'@</span>
<a name="line-959"></a>    <span class='hs-comment'>-- semantically equivalent to @e@, in which case we may add the constraint</span>
<a name="line-960"></a>    <span class='hs-comment'>-- @x ~ y@.</span>
<a name="line-961"></a>    <span class='hs-varid'>equate_with_similar_expr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StateT</span> <span class='hs-conid'>Nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span><span class='hs-layout'>)</span> <span class='hs-conid'>()</span>
<a name="line-962"></a>    <span class='hs-varid'>equate_with_similar_expr</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-963"></a>      <span class='hs-varid'>rep</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>StateT</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lift</span> <span class='hs-layout'>(</span><span class='hs-varid'>representCoreExpr</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-964"></a>      <span class='hs-comment'>-- Note that @rep == x@ if we encountered @e@ for the first time.</span>
<a name="line-965"></a>      <span class='hs-varid'>modifyT</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addVarCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-varid'>rep</span><span class='hs-layout'>)</span>
<a name="line-966"></a>
<a name="line-967"></a>    <span class='hs-varid'>bind_expr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StateT</span> <span class='hs-conid'>Nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span><span class='hs-layout'>)</span> <span class='hs-conid'>Id</span>
<a name="line-968"></a>    <span class='hs-varid'>bind_expr</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-969"></a>      <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lift</span> <span class='hs-layout'>(</span><span class='hs-varid'>lift</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkPmId</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-970"></a>      <span class='hs-varid'>core_expr</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span>
<a name="line-971"></a>      <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span>
<a name="line-972"></a>
<a name="line-973"></a>    <span class='hs-comment'>-- | Look at @let x = K taus theta es@ and generate the following</span>
<a name="line-974"></a>    <span class='hs-comment'>-- constraints (assuming universals were dropped from @taus@ before):</span>
<a name="line-975"></a>    <span class='hs-comment'>--   1. @x  @ if 'K' is not a Newtype constructor.</span>
<a name="line-976"></a>    <span class='hs-comment'>--   2. @a_1 ~ tau_1, ..., a_n ~ tau_n@ for fresh @a_i@</span>
<a name="line-977"></a>    <span class='hs-comment'>--   3. @y_1 ~ e_1, ..., y_m ~ e_m@ for fresh @y_i@</span>
<a name="line-978"></a>    <span class='hs-comment'>--   4. @x ~ K as ys@</span>
<a name="line-979"></a>    <span class='hs-comment'>-- This is quite similar to PmCheck.pmConCts.</span>
<a name="line-980"></a>    <span class='hs-varid'>data_con_app</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InScopeSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StateT</span> <span class='hs-conid'>Nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span><span class='hs-layout'>)</span> <span class='hs-conid'>()</span>
<a name="line-981"></a>    <span class='hs-varid'>data_con_app</span> <span class='hs-varid'>x</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-982"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>dc_ex_tvs</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConExTyCoVars</span> <span class='hs-varid'>dc</span>
<a name="line-983"></a>          <span class='hs-varid'>arty</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConSourceArity</span> <span class='hs-varid'>dc</span>
<a name="line-984"></a>          <span class='hs-layout'>(</span><span class='hs-varid'>ex_ty_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>val_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitAtList</span> <span class='hs-varid'>dc_ex_tvs</span> <span class='hs-varid'>args</span>
<a name="line-985"></a>          <span class='hs-varid'>ex_tys</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>exprToType</span> <span class='hs-varid'>ex_ty_args</span>
<a name="line-986"></a>          <span class='hs-varid'>vis_args</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>reverse</span> <span class='hs-varop'>$</span> <span class='hs-varid'>take</span> <span class='hs-varid'>arty</span> <span class='hs-varop'>$</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>val_args</span>
<a name="line-987"></a>      <span class='hs-varid'>uniq_supply</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lift</span> <span class='hs-varop'>$</span> <span class='hs-varid'>lift</span> <span class='hs-varop'>$</span> <span class='hs-varid'>getUniqueSupplyM</span>
<a name="line-988"></a>      <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>ex_tvs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cloneTyVarBndrs</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkEmptyTCvSubst</span> <span class='hs-varid'>in_scope</span><span class='hs-layout'>)</span> <span class='hs-varid'>dc_ex_tvs</span> <span class='hs-varid'>uniq_supply</span>
<a name="line-989"></a>          <span class='hs-varid'>ty_cts</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>equateTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>ex_tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>ex_tys</span>
<a name="line-990"></a>      <span class='hs-comment'>-- 1. @x  @ if 'K' is not a Newtype constructor (#18341)</span>
<a name="line-991"></a>      <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isNewDataCon</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-992"></a>        <span class='hs-varid'>modifyT</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addNotBotCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span>
<a name="line-993"></a>      <span class='hs-comment'>-- 2. @a_1 ~ tau_1, ..., a_n ~ tau_n@ for fresh @a_i@. See also #17703</span>
<a name="line-994"></a>      <span class='hs-varid'>modifyT</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-varop'>$</span> <span class='hs-varid'>addPhiCts</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-varid'>listToBag</span> <span class='hs-varid'>ty_cts</span><span class='hs-layout'>)</span>
<a name="line-995"></a>      <span class='hs-comment'>-- 3. @y_1 ~ e_1, ..., y_m ~ e_m@ for fresh @y_i@</span>
<a name="line-996"></a>      <span class='hs-varid'>arg_ids</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>traverse</span> <span class='hs-varid'>bind_expr</span> <span class='hs-varid'>vis_args</span>
<a name="line-997"></a>      <span class='hs-comment'>-- 4. @x ~ K as ys@</span>
<a name="line-998"></a>      <span class='hs-varid'>pm_alt_con_app</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmAltConLike</span> <span class='hs-layout'>(</span><span class='hs-conid'>RealDataCon</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>ex_tvs</span> <span class='hs-varid'>arg_ids</span>
<a name="line-999"></a>
<a name="line-1000"></a>    <span class='hs-comment'>-- | Adds a literal constraint, i.e. @x ~ 42@.</span>
<a name="line-1001"></a>    <span class='hs-comment'>-- Also we assume that literal expressions won't diverge, so this</span>
<a name="line-1002"></a>    <span class='hs-comment'>-- will add a @x ~/ @ constraint.</span>
<a name="line-1003"></a>    <span class='hs-varid'>pm_lit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PmLit</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StateT</span> <span class='hs-conid'>Nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span><span class='hs-layout'>)</span> <span class='hs-conid'>()</span>
<a name="line-1004"></a>    <span class='hs-varid'>pm_lit</span> <span class='hs-varid'>x</span> <span class='hs-varid'>lit</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1005"></a>      <span class='hs-varid'>modifyT</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addNotBotCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span>
<a name="line-1006"></a>      <span class='hs-varid'>pm_alt_con_app</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmAltLit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span>
<a name="line-1007"></a>
<a name="line-1008"></a>    <span class='hs-comment'>-- | Adds the given constructor application as a solution for @x@.</span>
<a name="line-1009"></a>    <span class='hs-varid'>pm_alt_con_app</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PmAltCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StateT</span> <span class='hs-conid'>Nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span><span class='hs-layout'>)</span> <span class='hs-conid'>()</span>
<a name="line-1010"></a>    <span class='hs-varid'>pm_alt_con_app</span> <span class='hs-varid'>x</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modifyT</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addConCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>args</span>
<a name="line-1011"></a>
<a name="line-1012"></a><a name="representCoreExpr"></a><span class='hs-comment'>-- | Finds a representant of the semantic equality class of the given @e@.</span>
<a name="line-1013"></a><span class='hs-comment'>-- Which is the @x@ of a @let x = e'@ constraint (with @e@ semantically</span>
<a name="line-1014"></a><span class='hs-comment'>-- equivalent to @e'@) we encountered earlier, or a fresh identifier if</span>
<a name="line-1015"></a><span class='hs-comment'>-- there weren't any such constraints.</span>
<a name="line-1016"></a><span class='hs-definition'>representCoreExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nabla</span><span class='hs-layout'>)</span>
<a name="line-1017"></a><span class='hs-definition'>representCoreExpr</span> <span class='hs-varid'>nabla</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>TmSt</span><span class='hs-layout'>{</span> <span class='hs-varid'>ts_reps</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>reps</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-varid'>e</span>
<a name="line-1018"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>rep</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupCoreMap</span> <span class='hs-varid'>reps</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep</span><span class='hs-layout'>,</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span>
<a name="line-1019"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1020"></a>      <span class='hs-varid'>rep</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkPmId</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1021"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>reps'</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendCoreMap</span> <span class='hs-varid'>reps</span> <span class='hs-varid'>e</span> <span class='hs-varid'>rep</span>
<a name="line-1022"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>nabla'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-layout'>{</span> <span class='hs-varid'>ts_reps</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>reps'</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1023"></a>      <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep</span><span class='hs-layout'>,</span> <span class='hs-varid'>nabla'</span><span class='hs-layout'>)</span>
<a name="line-1024"></a>
<a name="line-1025"></a><a name="modifyT"></a><span class='hs-comment'>-- | Like 'modify', but with an effectful modifier action</span>
<a name="line-1026"></a><span class='hs-definition'>modifyT</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StateT</span> <span class='hs-varid'>s</span> <span class='hs-varid'>m</span> <span class='hs-conid'>()</span>
<a name="line-1027"></a><span class='hs-definition'>modifyT</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>StateT</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fmap</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,)</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f</span>
<a name="line-1028"></a>
<a name="line-1029"></a><span class='hs-comment'>{- Note [The Pos/Neg invariant]
<a name="line-1030"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1031"></a>Invariant applying to each VarInfo: Whenever we have @C @tvs args@ in 'vi_pos',
<a name="line-1032"></a>any entry in 'vi_neg' must be incomparable to C (return Nothing) according to
<a name="line-1033"></a>'eqPmAltCons'. Those entries that are comparable either lead to a refutation
<a name="line-1034"></a>or are redundant. Examples:
<a name="line-1035"></a>* @x ~ Just y@, @x  [Just]@. 'eqPmAltCon' returns @Equal@, so refute.
<a name="line-1036"></a>* @x ~ Nothing@, @x  [Just]@. 'eqPmAltCon' returns @Disjoint@, so negative
<a name="line-1037"></a>  info is redundant and should be discarded.
<a name="line-1038"></a>* @x ~ I# y@, @x  [4,2]@. 'eqPmAltCon' returns @PossiblyOverlap@, so orthogal.
<a name="line-1039"></a>  We keep this info in order to be able to refute a redundant match on i.e. 4
<a name="line-1040"></a>  later on.
<a name="line-1041"></a>
<a name="line-1042"></a>This carries over to pattern synonyms and overloaded literals. Say, we have
<a name="line-1043"></a>    pattern Just42 = Just 42
<a name="line-1044"></a>    case Just42 of x
<a name="line-1045"></a>      Nothing -&gt; ()
<a name="line-1046"></a>      Just _  -&gt; ()
<a name="line-1047"></a>Even though we had a solution for the value abstraction called x here in form
<a name="line-1048"></a>of a PatSynCon Just42, this solution is incomparable to both Nothing and
<a name="line-1049"></a>Just. Hence we retain the info in vi_neg, which eventually allows us to detect
<a name="line-1050"></a>the complete pattern match.
<a name="line-1051"></a>
<a name="line-1052"></a>The Pos/Neg invariant extends to vi_rcm, which essentially stores positive
<a name="line-1053"></a>information. We make sure that vi_neg and vi_rcm never overlap. This isn't
<a name="line-1054"></a>strictly necessary since vi_rcm is just a cache, so doesn't need to be
<a name="line-1055"></a>accurate: Every suggestion of a possible ConLike from vi_rcm might be
<a name="line-1056"></a>refutable by the type oracle anyway. But it helps to maintain sanity while
<a name="line-1057"></a>debugging traces.
<a name="line-1058"></a>
<a name="line-1059"></a>Note [Why record both positive and negative info?]
<a name="line-1060"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1061"></a>You might think that knowing positive info (like x ~ Just y) would render
<a name="line-1062"></a>negative info irrelevant, but not so because of pattern synonyms.  E.g we might
<a name="line-1063"></a>know that x cannot match (Foo 4), where pattern Foo p = Just p
<a name="line-1064"></a>
<a name="line-1065"></a>Also overloaded literals themselves behave like pattern synonyms. E.g if
<a name="line-1066"></a>postively we know that (x ~ I# y), we might also negatively want to record that
<a name="line-1067"></a>x does not match 45 f 45       = e2 f (I# 22#) = e3 f 45       = e4  --
<a name="line-1068"></a>Overlapped
<a name="line-1069"></a>
<a name="line-1070"></a>Note [TmState invariants]
<a name="line-1071"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1072"></a>The term oracle state is never obviously (i.e., without consulting the type
<a name="line-1073"></a>oracle or doing inhabitation testing) contradictory. This implies a few
<a name="line-1074"></a>invariants:
<a name="line-1075"></a>* Whenever vi_pos overlaps with vi_neg according to 'eqPmAltCon', we refute.
<a name="line-1076"></a>  This is implied by the Note [Pos/Neg invariant].
<a name="line-1077"></a>* Whenever vi_neg subsumes a COMPLETE set, we refute. We consult vi_rcm to
<a name="line-1078"></a>  detect this, but we could just compare whole COMPLETE sets to vi_neg every
<a name="line-1079"></a>  time, if it weren't for performance.
<a name="line-1080"></a>
<a name="line-1081"></a>Maintaining these invariants in 'addVarCt' (the core of the term oracle) and
<a name="line-1082"></a>'addNotConCt' is subtle.
<a name="line-1083"></a>* Merging VarInfos. Example: Add the fact @x ~ y@ (see 'equate').
<a name="line-1084"></a>  - (COMPLETE) If we had @x  True@ and @y  False@, then we get
<a name="line-1085"></a>    @x  [True,False]@. This is vacuous by matter of comparing to the built-in
<a name="line-1086"></a>    COMPLETE set, so should refute.
<a name="line-1087"></a>  - (Pos/Neg) If we had @x  True@ and @y ~ True@, we have to refute.
<a name="line-1088"></a>* Adding positive information. Example: Add the fact @x ~ K ys@ (see 'addConCt')
<a name="line-1089"></a>  - (Neg) If we had @x  K@, refute.
<a name="line-1090"></a>  - (Pos) If we had @x ~ K2@, and that contradicts the new solution according to
<a name="line-1091"></a>    'eqPmAltCon' (ex. K2 is [] and K is (:)), then refute.
<a name="line-1092"></a>  - (Refine) If we had @x  K zs@, unify each y with each z in turn.
<a name="line-1093"></a>* Adding negative information. Example: Add the fact @x  Nothing@ (see 'addNotConCt')
<a name="line-1094"></a>  - (Refut) If we have @x ~ K ys@, refute.
<a name="line-1095"></a>  - (COMPLETE) If K=Nothing and we had @x  Just@, then we get
<a name="line-1096"></a>    @x  [Just,Nothing]@. This is vacuous by matter of comparing to the built-in
<a name="line-1097"></a>    COMPLETE set, so should refute.
<a name="line-1098"></a>
<a name="line-1099"></a>Note that merging VarInfo in equate can be done by calling out to 'addConCt' and
<a name="line-1100"></a>'addNotConCt' for each of the facts individually.
<a name="line-1101"></a>
<a name="line-1102"></a>Note [Representation of Strings in TmState]
<a name="line-1103"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1104"></a>Instead of treating regular String literals as a PmLits, we treat it as a list
<a name="line-1105"></a>of characters in the oracle for better overlap reasoning. The following example
<a name="line-1106"></a>shows why:
<a name="line-1107"></a>
<a name="line-1108"></a>  f :: String -&gt; ()
<a name="line-1109"></a>  f ('f':_) = ()
<a name="line-1110"></a>  f "foo"   = ()
<a name="line-1111"></a>  f _       = ()
<a name="line-1112"></a>
<a name="line-1113"></a>The second case is redundant, and we like to warn about it. Therefore either
<a name="line-1114"></a>the oracle will have to do some smart conversion between the list and literal
<a name="line-1115"></a>representation or treat is as the list it really is at runtime.
<a name="line-1116"></a>
<a name="line-1117"></a>The "smart conversion" has the advantage of leveraging the more compact literal
<a name="line-1118"></a>representation wherever possible, but is really nasty to get right with negative
<a name="line-1119"></a>equalities: Just think of how to encode @x /= "foo"@.
<a name="line-1120"></a>The "list" option is far simpler, but incurs some overhead in representation and
<a name="line-1121"></a>warning messages (which can be alleviated by someone with enough dedication).
<a name="line-1122"></a>
<a name="line-1123"></a>Note [Detecting pattern synonym applications in expressions]
<a name="line-1124"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1125"></a>At the moment we fail to detect pattern synonyms in scrutinees and RHS of
<a name="line-1126"></a>guards. This could be alleviated with considerable effort and complexity, but
<a name="line-1127"></a>the returns are meager. Consider:
<a name="line-1128"></a>
<a name="line-1129"></a>    pattern P
<a name="line-1130"></a>    pattern Q
<a name="line-1131"></a>    case P 15 of
<a name="line-1132"></a>      Q _  -&gt; ...
<a name="line-1133"></a>      P 15 -&gt;
<a name="line-1134"></a>
<a name="line-1135"></a>Compared to the situation where P and Q are DataCons, the lack of generativity
<a name="line-1136"></a>means we could never flag Q as redundant. (also see Note [Undecidable Equality
<a name="line-1137"></a>for PmAltCons] in PmTypes.) On the other hand, if we fail to recognise the
<a name="line-1138"></a>pattern synonym, we flag the pattern match as inexhaustive. That wouldn't happen
<a name="line-1139"></a>if we had knowledge about the scrutinee, in which case the oracle basically
<a name="line-1140"></a>knows "If it's a P, then its field is 15".
<a name="line-1141"></a>
<a name="line-1142"></a>This is a pretty narrow use case and I don't think we should to try to fix it
<a name="line-1143"></a>until a user complains energetically.
<a name="line-1144"></a>
<a name="line-1145"></a>Note [Completeness checking with required Thetas]
<a name="line-1146"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1147"></a>Consider the situation in #11224
<a name="line-1148"></a>
<a name="line-1149"></a>    import Text.Read (readMaybe)
<a name="line-1150"></a>    pattern PRead :: Read a =&gt; () =&gt; a -&gt; String
<a name="line-1151"></a>    pattern PRead x &lt;- (readMaybe -&gt; Just x)
<a name="line-1152"></a>    f :: String -&gt; Int
<a name="line-1153"></a>    f (PRead x)  = x
<a name="line-1154"></a>    f (PRead xs) = length xs
<a name="line-1155"></a>    f _          = 0
<a name="line-1156"></a>
<a name="line-1157"></a>Is the first match exhaustive on the PRead synonym? Should the second line thus
<a name="line-1158"></a>deemed redundant? The answer is, of course, No! The required theta is like a
<a name="line-1159"></a>hidden parameter which must be supplied at the pattern match site, so PRead
<a name="line-1160"></a>is much more like a view pattern (where behavior depends on the particular value
<a name="line-1161"></a>passed in).
<a name="line-1162"></a>The simple solution here is to forget in 'addNotConCt' that we matched
<a name="line-1163"></a>on synonyms with a required Theta like @PRead@, so that subsequent matches on
<a name="line-1164"></a>the same constructor are never flagged as redundant. The consequence is that
<a name="line-1165"></a>we no longer detect the actually redundant match in
<a name="line-1166"></a>
<a name="line-1167"></a>    g :: String -&gt; Int
<a name="line-1168"></a>    g (PRead x) = x
<a name="line-1169"></a>    g (PRead y) = y -- redundant!
<a name="line-1170"></a>    g _         = 0
<a name="line-1171"></a>
<a name="line-1172"></a>But that's a small price to pay, compared to the proper solution here involving
<a name="line-1173"></a>storing required arguments along with the PmAltConLike in 'vi_neg'.
<a name="line-1174"></a>
<a name="line-1175"></a>Note [Strict fields and variables of unlifted type]
<a name="line-1176"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1177"></a>Binders of unlifted type (and strict fields) are unlifted by construction;
<a name="line-1178"></a>they are conceived with an implicit (but delayed checked) @@ constraint to
<a name="line-1179"></a>begin with. Hence, desugaring in "GHC.HsToCore.Pmc" is entirely unconcerned
<a name="line-1180"></a>by strict fields, since the forcing happens *before* pattern matching. And
<a name="line-1181"></a>the  constructor constraints emitted by 'GHC.HsToCore.Pmc.checkGrd' have
<a name="line-1182"></a>complex binding semantics (binding type constraints and unlifted fields), so
<a name="line-1183"></a>unliftedness semantics are entirely confined to the oracle.
<a name="line-1184"></a>
<a name="line-1185"></a>These are the moving parts:
<a name="line-1186"></a>
<a name="line-1187"></a>  1.  For each strict (or more generally, unlifted) field @s@ of a 'PhiConCt'
<a name="line-1188"></a>      we have to add a @s  @ constraint in the corresponding case of
<a name="line-1189"></a>      'addPhiTmCt'. Strict fields are devoid of  by construction, there's
<a name="line-1190"></a>      nothing that a bang pattern would act on. Example from #18341:
<a name="line-1191"></a>
<a name="line-1192"></a>        data T = MkT !Int
<a name="line-1193"></a>        f :: T -&gt; ()
<a name="line-1194"></a>        f (MkT  _) | False = () -- inaccessible
<a name="line-1195"></a>        f (MkT !_) | False = () -- redundant, not only inaccessible!
<a name="line-1196"></a>        f _                = ()
<a name="line-1197"></a>
<a name="line-1198"></a>      The second clause desugars to @MkT n &lt;- x, !n@. When coverage checked,
<a name="line-1199"></a>      the 'PmCon' @MkT n &lt;- x@ refines the set of values that reach the bang
<a name="line-1200"></a>      pattern with the  constraints @MkT n &lt;- x@ (Nothing surprising so far).
<a name="line-1201"></a>      Upon that constraint, it disperses into two lower-level  constraints
<a name="line-1202"></a>      @x ~ MkT n, n  @ per Equation (3) in Figure 7 of the paper.
<a name="line-1203"></a>
<a name="line-1204"></a>      Checking the 'PmBang' @!n@ will then try to add the
<a name="line-1205"></a>      constraint @n ~ @ to this set to get the diverging set, which is found
<a name="line-1206"></a>      to be empty. Hence the whole clause is detected as redundant, as
<a name="line-1207"></a>      expected.
<a name="line-1208"></a>
<a name="line-1209"></a>  2.  Similarly, when performing the 'inhabitationTest', when instantiating a
<a name="line-1210"></a>      constructor we call 'instCon', which generates a higher-level 
<a name="line-1211"></a>      constructor constraint.
<a name="line-1212"></a>
<a name="line-1213"></a>  3.  The preceding points handle unlifted constructor fields, but there also
<a name="line-1214"></a>      are regular binders of unlifted type. We simply fail in 'addBotCt' for
<a name="line-1215"></a>      any binder of unlifted type.
<a name="line-1216"></a>      It would be enough to check for unliftedness once, when the binder comes
<a name="line-1217"></a>      into scope, but we haven't really a way to track that.
<a name="line-1218"></a>
<a name="line-1219"></a>  4.  Why not start an 'emptyVarInfo' of unlifted type with @vi_bot = IsNotBot@?
<a name="line-1220"></a>      Because then we'd need to trigger an inhabitation test, because the var
<a name="line-1221"></a>      might actually be void to begin with. But we can't trigger the test from
<a name="line-1222"></a>      'emptyVarInfo'.
<a name="line-1223"></a>      Historically, that is what we did and not doing the test led to #20631,
<a name="line-1224"></a>      where 'addNotBotCt' trivially succeeded, because the 'VarInfo' already
<a name="line-1225"></a>      said 'IsNotBot', implying that a prior inhabitation test succeeded.
<a name="line-1226"></a>-}</span>
<a name="line-1227"></a>
<a name="line-1228"></a><span class='hs-comment'>-------------------------</span>
<a name="line-1229"></a><span class='hs-comment'>-- * Inhabitation testing</span>
<a name="line-1230"></a><span class='hs-comment'>--</span>
<a name="line-1231"></a><span class='hs-comment'>-- Figure 8 in the LYG paper.</span>
<a name="line-1232"></a>
<a name="line-1233"></a><a name="tyStateRefined"></a><span class='hs-definition'>tyStateRefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyState</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyState</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1234"></a><span class='hs-comment'>-- Makes use of the fact that the two TyStates we compare will never have the</span>
<a name="line-1235"></a><span class='hs-comment'>-- same sequence number. It is invalid to call this function when a is not a</span>
<a name="line-1236"></a><span class='hs-comment'>-- refinement of b or vice versa!</span>
<a name="line-1237"></a><span class='hs-definition'>tyStateRefined</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty_st_n</span> <span class='hs-varid'>a</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>ty_st_n</span> <span class='hs-varid'>b</span>
<a name="line-1238"></a>
<a name="line-1239"></a><a name="markDirty"></a><span class='hs-definition'>markDirty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span>
<a name="line-1240"></a><span class='hs-definition'>markDirty</span> <span class='hs-varid'>x</span> <span class='hs-varid'>nabla</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span><span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>TmSt</span><span class='hs-layout'>{</span><span class='hs-varid'>ts_dirty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dirty</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span>
<a name="line-1241"></a>  <span class='hs-varid'>nabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-layout'>{</span> <span class='hs-varid'>ts_dirty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendDVarSet</span> <span class='hs-varid'>dirty</span> <span class='hs-varid'>x</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1242"></a>
<a name="line-1243"></a><a name="traverseDirty"></a><span class='hs-definition'>traverseDirty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>VarInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-conid'>VarInfo</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TmState</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-conid'>TmState</span>
<a name="line-1244"></a><span class='hs-definition'>traverseDirty</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ts</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>TmSt</span><span class='hs-layout'>{</span><span class='hs-varid'>ts_facts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>ts_dirty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dirty</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span>
<a name="line-1245"></a>  <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>uniqDSetToList</span> <span class='hs-varid'>dirty</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span>
<a name="line-1246"></a>  <span class='hs-keyword'>where</span>
<a name="line-1247"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span>     <span class='hs-varid'>env</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>ts</span><span class='hs-layout'>{</span><span class='hs-varid'>ts_facts</span><span class='hs-keyglyph'>=</span><span class='hs-varid'>env</span><span class='hs-layout'>}</span>
<a name="line-1248"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>!</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1249"></a>      <span class='hs-varid'>vi'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupVarInfo</span> <span class='hs-varid'>ts</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1250"></a>      <span class='hs-varid'>go</span> <span class='hs-varid'>xs</span> <span class='hs-layout'>(</span><span class='hs-varid'>addToUSDFM</span> <span class='hs-varid'>env</span> <span class='hs-varid'>x</span> <span class='hs-varid'>vi'</span><span class='hs-layout'>)</span>
<a name="line-1251"></a>
<a name="line-1252"></a><a name="traverseAll"></a><span class='hs-definition'>traverseAll</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>VarInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-conid'>VarInfo</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TmState</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-conid'>TmState</span>
<a name="line-1253"></a><span class='hs-definition'>traverseAll</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ts</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>TmSt</span><span class='hs-layout'>{</span><span class='hs-varid'>ts_facts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1254"></a>  <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>traverseUSDFM</span> <span class='hs-varid'>f</span> <span class='hs-varid'>env</span>
<a name="line-1255"></a>  <span class='hs-varid'>pure</span> <span class='hs-varid'>ts</span><span class='hs-layout'>{</span><span class='hs-varid'>ts_facts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env'</span><span class='hs-layout'>}</span>
<a name="line-1256"></a>
<a name="line-1257"></a><a name="inhabitationTest"></a><span class='hs-comment'>-- | Makes sure the given 'Nabla' is still inhabited, by trying to instantiate</span>
<a name="line-1258"></a><span class='hs-comment'>-- all dirty variables (or all variables when the 'TyState' changed) to concrete</span>
<a name="line-1259"></a><span class='hs-comment'>-- inhabitants. It returns a 'Nabla' with the *same* inhabitants, but with some</span>
<a name="line-1260"></a><span class='hs-comment'>-- amount of work cached (like failed instantiation attempts) from the test.</span>
<a name="line-1261"></a><span class='hs-comment'>--</span>
<a name="line-1262"></a><span class='hs-comment'>-- The \(  x inh\) judgment form in Figure 8 of the LYG paper.</span>
<a name="line-1263"></a><span class='hs-definition'>inhabitationTest</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyState</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nabla</span>
<a name="line-1264"></a><span class='hs-definition'>inhabitationTest</span> <span class='hs-num'>0</span>     <span class='hs-keyword'>_</span>         <span class='hs-varid'>nabla</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>nabla</span>
<a name="line-1265"></a><span class='hs-definition'>inhabitationTest</span> <span class='hs-varid'>fuel</span>  <span class='hs-varid'>old_ty_st</span> <span class='hs-varid'>nabla</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1266"></a>  <span class='hs-comment'>-- lift $ tracePm "inhabitation test" $ vcat</span>
<a name="line-1267"></a>  <span class='hs-comment'>--   [ ppr fuel</span>
<a name="line-1268"></a>  <span class='hs-comment'>--   , ppr old_ty_st</span>
<a name="line-1269"></a>  <span class='hs-comment'>--   , ppr nabla</span>
<a name="line-1270"></a>  <span class='hs-comment'>--   , text "tyStateRefined:" &lt;+&gt; ppr (tyStateRefined old_ty_st (nabla_ty_st nabla))</span>
<a name="line-1271"></a>  <span class='hs-comment'>--   ]</span>
<a name="line-1272"></a>  <span class='hs-comment'>-- When type state didn't change, we only need to traverse dirty VarInfos</span>
<a name="line-1273"></a>  <span class='hs-varid'>ts'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>tyStateRefined</span> <span class='hs-varid'>old_ty_st</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_ty_st</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span>
<a name="line-1274"></a>            <span class='hs-keyword'>then</span> <span class='hs-varid'>traverseAll</span>   <span class='hs-varid'>test_one</span> <span class='hs-varid'>ts</span>
<a name="line-1275"></a>            <span class='hs-keyword'>else</span> <span class='hs-varid'>traverseDirty</span> <span class='hs-varid'>test_one</span> <span class='hs-varid'>ts</span>
<a name="line-1276"></a>  <span class='hs-varid'>pure</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts'</span><span class='hs-layout'>{</span><span class='hs-varid'>ts_dirty</span><span class='hs-keyglyph'>=</span><span class='hs-varid'>emptyDVarSet</span><span class='hs-layout'>}</span><span class='hs-layout'>}</span>
<a name="line-1277"></a>  <span class='hs-keyword'>where</span>
<a name="line-1278"></a>    <span class='hs-varid'>nabla_not_dirty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_tm_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ts</span><span class='hs-layout'>{</span><span class='hs-varid'>ts_dirty</span><span class='hs-keyglyph'>=</span><span class='hs-varid'>emptyDVarSet</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1279"></a>    <span class='hs-varid'>test_one</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>VarInfo</span>
<a name="line-1280"></a>    <span class='hs-varid'>test_one</span> <span class='hs-varid'>vi</span> <span class='hs-keyglyph'>=</span>
<a name="line-1281"></a>      <span class='hs-varid'>lift</span> <span class='hs-layout'>(</span><span class='hs-varid'>varNeedsTesting</span> <span class='hs-varid'>old_ty_st</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>vi</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
<a name="line-1282"></a>        <span class='hs-conid'>True</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-1283"></a>          <span class='hs-comment'>-- lift $ tracePm "test_one" (ppr vi)</span>
<a name="line-1284"></a>          <span class='hs-comment'>-- No solution yet and needs testing</span>
<a name="line-1285"></a>          <span class='hs-comment'>-- We have to test with a Nabla where all dirty bits are cleared</span>
<a name="line-1286"></a>          <span class='hs-varid'>instantiate</span> <span class='hs-layout'>(</span><span class='hs-varid'>fuel</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>nabla_not_dirty</span> <span class='hs-varid'>vi</span>
<a name="line-1287"></a>        <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>vi</span>
<a name="line-1288"></a>
<a name="line-1289"></a><a name="varNeedsTesting"></a><span class='hs-comment'>-- | Checks whether the given 'VarInfo' needs to be tested for inhabitants.</span>
<a name="line-1290"></a><span class='hs-comment'>-- Returns `False` when we can skip the inhabitation test, presuming it would</span>
<a name="line-1291"></a><span class='hs-comment'>-- say "yes" anyway. See Note [Shortcutting the inhabitation test].</span>
<a name="line-1292"></a><span class='hs-definition'>varNeedsTesting</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyState</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Bool</span>
<a name="line-1293"></a><span class='hs-definition'>varNeedsTesting</span> <span class='hs-keyword'>_</span>         <span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span><span class='hs-varid'>nabla_tm_st</span><span class='hs-keyglyph'>=</span><span class='hs-varid'>tm_st</span><span class='hs-layout'>}</span>     <span class='hs-varid'>vi</span>
<a name="line-1294"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>elemDVarSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>vi_id</span> <span class='hs-varid'>vi</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ts_dirty</span> <span class='hs-varid'>tm_st</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>True</span>
<a name="line-1295"></a><span class='hs-definition'>varNeedsTesting</span> <span class='hs-keyword'>_</span>         <span class='hs-keyword'>_</span>                              <span class='hs-varid'>vi</span>
<a name="line-1296"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>notNull</span> <span class='hs-layout'>(</span><span class='hs-varid'>vi_pos</span> <span class='hs-varid'>vi</span><span class='hs-layout'>)</span>                     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>False</span>
<a name="line-1297"></a><span class='hs-definition'>varNeedsTesting</span> <span class='hs-varid'>old_ty_st</span> <span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span><span class='hs-varid'>nabla_ty_st</span><span class='hs-keyglyph'>=</span><span class='hs-varid'>new_ty_st</span><span class='hs-layout'>}</span> <span class='hs-keyword'>_</span>
<a name="line-1298"></a>  <span class='hs-comment'>-- Same type state =&gt; still inhabited</span>
<a name="line-1299"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyStateRefined</span> <span class='hs-varid'>old_ty_st</span> <span class='hs-varid'>new_ty_st</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>False</span>
<a name="line-1300"></a><span class='hs-definition'>varNeedsTesting</span> <span class='hs-varid'>old_ty_st</span> <span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span><span class='hs-varid'>nabla_ty_st</span><span class='hs-keyglyph'>=</span><span class='hs-varid'>new_ty_st</span><span class='hs-layout'>}</span> <span class='hs-varid'>vi</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1301"></a>  <span class='hs-comment'>-- These normalisations are relatively expensive, but still better than having</span>
<a name="line-1302"></a>  <span class='hs-comment'>-- to perform a full inhabitation test</span>
<a name="line-1303"></a>  <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>old_norm_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tntrGuts</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>pmTopNormaliseType</span> <span class='hs-varid'>old_ty_st</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vi_id</span> <span class='hs-varid'>vi</span><span class='hs-layout'>)</span>
<a name="line-1304"></a>  <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_norm_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tntrGuts</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>pmTopNormaliseType</span> <span class='hs-varid'>new_ty_st</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vi_id</span> <span class='hs-varid'>vi</span><span class='hs-layout'>)</span>
<a name="line-1305"></a>  <span class='hs-keyword'>if</span> <span class='hs-varid'>old_norm_ty</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>new_norm_ty</span>
<a name="line-1306"></a>    <span class='hs-keyword'>then</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>False</span>
<a name="line-1307"></a>    <span class='hs-keyword'>else</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>True</span>
<a name="line-1308"></a>
<a name="line-1309"></a><a name="instantiate"></a><span class='hs-comment'>-- | Returns (Just vi) if at least one member of each ConLike in the COMPLETE</span>
<a name="line-1310"></a><span class='hs-comment'>-- set satisfies the oracle</span>
<a name="line-1311"></a><span class='hs-comment'>--</span>
<a name="line-1312"></a><span class='hs-comment'>-- Internally uses and updates the CompleteMatchs in vi_rcm.</span>
<a name="line-1313"></a><span class='hs-comment'>--</span>
<a name="line-1314"></a><span class='hs-comment'>-- NB: Does /not/ filter each CompleteMatch with the oracle; members may</span>
<a name="line-1315"></a><span class='hs-comment'>--     remain that do not statisfy it.  This lazy approach just</span>
<a name="line-1316"></a><span class='hs-comment'>--     avoids doing unnecessary work.</span>
<a name="line-1317"></a><span class='hs-definition'>instantiate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>VarInfo</span>
<a name="line-1318"></a><span class='hs-definition'>instantiate</span> <span class='hs-varid'>fuel</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>vi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>instBot</span> <span class='hs-varid'>fuel</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>vi</span> <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-varid'>instCompleteSets</span> <span class='hs-varid'>fuel</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>vi</span>
<a name="line-1319"></a>
<a name="line-1320"></a><a name="instBot"></a><span class='hs-comment'>-- | The \(_{Bot}\) rule from the paper</span>
<a name="line-1321"></a><span class='hs-definition'>instBot</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>VarInfo</span>
<a name="line-1322"></a><span class='hs-definition'>instBot</span> <span class='hs-sel'>_fuel</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>vi</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1323"></a>  <span class='hs-sel'>_nabla'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addBotCt</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-varid'>vi_id</span> <span class='hs-varid'>vi</span><span class='hs-layout'>)</span>
<a name="line-1324"></a>  <span class='hs-varid'>pure</span> <span class='hs-varid'>vi</span>
<a name="line-1325"></a>
<a name="line-1326"></a><a name="addNormalisedTypeMatches"></a><span class='hs-definition'>addNormalisedTypeMatches</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-layout'>(</span><span class='hs-conid'>ResidualCompleteMatches</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nabla</span><span class='hs-layout'>)</span>
<a name="line-1327"></a><span class='hs-definition'>addNormalisedTypeMatches</span> <span class='hs-varid'>nabla</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span> <span class='hs-varid'>nabla_ty_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty_st</span> <span class='hs-layout'>}</span> <span class='hs-varid'>x</span>
<a name="line-1328"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trvVarInfo</span> <span class='hs-varid'>add_matches</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span>
<a name="line-1329"></a>  <span class='hs-keyword'>where</span>
<a name="line-1330"></a>    <span class='hs-varid'>add_matches</span> <span class='hs-varid'>vi</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>VI</span><span class='hs-layout'>{</span> <span class='hs-varid'>vi_rcm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rcm</span> <span class='hs-layout'>}</span>
<a name="line-1331"></a>      <span class='hs-comment'>-- important common case, shaving down allocations of PmSeriesG by -5%</span>
<a name="line-1332"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isRcmInitialised</span> <span class='hs-varid'>rcm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>rcm</span><span class='hs-layout'>,</span> <span class='hs-varid'>vi</span><span class='hs-layout'>)</span>
<a name="line-1333"></a>    <span class='hs-varid'>add_matches</span> <span class='hs-varid'>vi</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>VI</span><span class='hs-layout'>{</span> <span class='hs-varid'>vi_rcm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rcm</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1334"></a>      <span class='hs-varid'>norm_res_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>normaliseSourceTypeWHNF</span> <span class='hs-varid'>ty_st</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1335"></a>      <span class='hs-varid'>env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dsGetFamInstEnvs</span>
<a name="line-1336"></a>      <span class='hs-varid'>rcm'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>splitReprTyConApp_maybe</span> <span class='hs-varid'>env</span> <span class='hs-varid'>norm_res_ty</span> <span class='hs-keyword'>of</span>
<a name="line-1337"></a>        <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_tc</span><span class='hs-layout'>,</span> <span class='hs-sel'>_args</span><span class='hs-layout'>,</span> <span class='hs-sel'>_co</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addTyConMatches</span> <span class='hs-varid'>rep_tc</span> <span class='hs-varid'>rcm</span>
<a name="line-1338"></a>        <span class='hs-conid'>Nothing</span>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addCompleteMatches</span> <span class='hs-varid'>rcm</span>
<a name="line-1339"></a>      <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>rcm'</span><span class='hs-layout'>,</span> <span class='hs-varid'>vi</span><span class='hs-layout'>{</span> <span class='hs-varid'>vi_rcm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rcm'</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1340"></a>
<a name="line-1341"></a><a name="splitReprTyConApp_maybe"></a><span class='hs-comment'>-- | Does a 'splitTyConApp_maybe' and then tries to look through a data family</span>
<a name="line-1342"></a><span class='hs-comment'>-- application to find the representation TyCon, to which the data constructors</span>
<a name="line-1343"></a><span class='hs-comment'>-- are attached. Returns the representation TyCon, the TyCon application args</span>
<a name="line-1344"></a><span class='hs-comment'>-- and a representational coercion that will be Refl for non-data family apps.</span>
<a name="line-1345"></a><span class='hs-definition'>splitReprTyConApp_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyCon</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1346"></a><span class='hs-definition'>splitReprTyConApp_maybe</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span>
<a name="line-1347"></a>  <span class='hs-varid'>uncurry</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcLookupDataFamInst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-1348"></a>
<a name="line-1349"></a><a name="instCompleteSets"></a><span class='hs-comment'>-- | This is the |-Inst rule from the paper (section 4.5). Tries to</span>
<a name="line-1350"></a><span class='hs-comment'>-- find an inhabitant in every complete set by instantiating with one their</span>
<a name="line-1351"></a><span class='hs-comment'>-- constructors. If there is any complete set where we can't find an</span>
<a name="line-1352"></a><span class='hs-comment'>-- inhabitant, the whole thing is uninhabited. It returns the updated 'VarInfo'</span>
<a name="line-1353"></a><span class='hs-comment'>-- where all the attempted ConLike instantiations have been purged from the</span>
<a name="line-1354"></a><span class='hs-comment'>-- 'ResidualCompleteMatches', which functions as a cache.</span>
<a name="line-1355"></a><span class='hs-definition'>instCompleteSets</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>VarInfo</span>
<a name="line-1356"></a><span class='hs-definition'>instCompleteSets</span> <span class='hs-varid'>fuel</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>vi</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1357"></a>  <span class='hs-keyword'>let</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vi_id</span> <span class='hs-varid'>vi</span>
<a name="line-1358"></a>  <span class='hs-layout'>(</span><span class='hs-varid'>rcm</span><span class='hs-layout'>,</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lift</span> <span class='hs-layout'>(</span><span class='hs-varid'>addNormalisedTypeMatches</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1359"></a>  <span class='hs-varid'>nabla</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>foldM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>nabla</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>instCompleteSet</span> <span class='hs-varid'>fuel</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-varid'>getRcm</span> <span class='hs-varid'>rcm</span><span class='hs-layout'>)</span>
<a name="line-1360"></a>  <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupVarInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_tm_st</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1361"></a>
<a name="line-1362"></a><a name="anyConLikeSolution"></a><span class='hs-definition'>anyConLikeSolution</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConLike</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PmAltConApp</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1363"></a><span class='hs-definition'>anyConLikeSolution</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>go</span> <span class='hs-varop'>.</span> <span class='hs-varid'>paca_con</span><span class='hs-layout'>)</span>
<a name="line-1364"></a>  <span class='hs-keyword'>where</span>
<a name="line-1365"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmAltConLike</span> <span class='hs-varid'>cl</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>p</span> <span class='hs-varid'>cl</span>
<a name="line-1366"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1367"></a>
<a name="line-1368"></a><a name="instCompleteSet"></a><span class='hs-comment'>-- | @instCompleteSet fuel nabla x cls@ iterates over @cls@ until it finds</span>
<a name="line-1369"></a><span class='hs-comment'>-- the first inhabited ConLike (as per 'instCon'). Any failed instantiation</span>
<a name="line-1370"></a><span class='hs-comment'>-- attempts of a ConLike are recorded as negative information in the returned</span>
<a name="line-1371"></a><span class='hs-comment'>-- 'Nabla', so that later calls to this function can skip repeatedly fruitless</span>
<a name="line-1372"></a><span class='hs-comment'>-- instantiation of that same constructor.</span>
<a name="line-1373"></a><span class='hs-comment'>--</span>
<a name="line-1374"></a><span class='hs-comment'>-- Note that the returned Nabla is just a different representation of the</span>
<a name="line-1375"></a><span class='hs-comment'>-- original Nabla, not a proper refinement! No positive information will be</span>
<a name="line-1376"></a><span class='hs-comment'>-- added, only negative information from failed instantiation attempts,</span>
<a name="line-1377"></a><span class='hs-comment'>-- entirely as an optimisation.</span>
<a name="line-1378"></a><span class='hs-definition'>instCompleteSet</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CompleteMatch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nabla</span>
<a name="line-1379"></a><span class='hs-definition'>instCompleteSet</span> <span class='hs-varid'>fuel</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-varid'>cs</span>
<a name="line-1380"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>anyConLikeSolution</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elementOfUniqDSet`</span> <span class='hs-layout'>(</span><span class='hs-varid'>cmConLikes</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>vi_pos</span> <span class='hs-varid'>vi</span><span class='hs-layout'>)</span>
<a name="line-1381"></a>  <span class='hs-comment'>-- No need to instantiate a constructor of this COMPLETE set if we already</span>
<a name="line-1382"></a>  <span class='hs-comment'>-- have a solution!</span>
<a name="line-1383"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>nabla</span>
<a name="line-1384"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>completeMatchAppliesAtType</span> <span class='hs-layout'>(</span><span class='hs-varid'>varType</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span>
<a name="line-1385"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>nabla</span>
<a name="line-1386"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1387"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-varid'>sorted_candidates</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span>
<a name="line-1388"></a>  <span class='hs-keyword'>where</span>
<a name="line-1389"></a>    <span class='hs-varid'>vi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupVarInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_tm_st</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span>
<a name="line-1390"></a>
<a name="line-1391"></a>    <span class='hs-varid'>sorted_candidates</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CompleteMatch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ConLike</span><span class='hs-keyglyph'>]</span>
<a name="line-1392"></a>    <span class='hs-varid'>sorted_candidates</span> <span class='hs-varid'>cm</span>
<a name="line-1393"></a>      <span class='hs-comment'>-- If there aren't many candidates, we can try to sort them by number of</span>
<a name="line-1394"></a>      <span class='hs-comment'>-- strict fields, type constraints, etc., so that we are fast in the</span>
<a name="line-1395"></a>      <span class='hs-comment'>-- common case</span>
<a name="line-1396"></a>      <span class='hs-comment'>-- (either many simple constructors *or* few "complicated" ones).</span>
<a name="line-1397"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sizeUniqDSet</span> <span class='hs-varid'>cs</span> <span class='hs-varop'>&lt;=</span> <span class='hs-num'>5</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sortBy</span> <span class='hs-varid'>compareConLikeTestability</span> <span class='hs-layout'>(</span><span class='hs-varid'>uniqDSetToList</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span>
<a name="line-1398"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>uniqDSetToList</span> <span class='hs-varid'>cs</span>
<a name="line-1399"></a>      <span class='hs-keyword'>where</span> <span class='hs-varid'>cs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cmConLikes</span> <span class='hs-varid'>cm</span>
<a name="line-1400"></a>
<a name="line-1401"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ConLike</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nabla</span>
<a name="line-1402"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>     <span class='hs-conid'>[]</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mzero</span>
<a name="line-1403"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>RealDataCon</span> <span class='hs-varid'>dc</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-1404"></a>      <span class='hs-comment'>-- See Note [DataCons that are definitely inhabitable]</span>
<a name="line-1405"></a>      <span class='hs-comment'>-- Recall that dc can't be in vi_neg, because then it would be</span>
<a name="line-1406"></a>      <span class='hs-comment'>-- deleted from the residual COMPLETE set.</span>
<a name="line-1407"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDataConTriviallyInhabited</span> <span class='hs-varid'>dc</span>
<a name="line-1408"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>nabla</span>
<a name="line-1409"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-varid'>con</span><span class='hs-conop'>:</span><span class='hs-varid'>cons</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1410"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vi_id</span> <span class='hs-varid'>vi</span>
<a name="line-1411"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>recur_not_con</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1412"></a>            <span class='hs-varid'>nabla'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addNotConCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmAltConLike</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span>
<a name="line-1413"></a>            <span class='hs-varid'>go</span> <span class='hs-varid'>nabla'</span> <span class='hs-varid'>cons</span>
<a name="line-1414"></a>      <span class='hs-layout'>(</span><span class='hs-varid'>nabla</span> <span class='hs-varop'>&lt;$</span> <span class='hs-varid'>instCon</span> <span class='hs-varid'>fuel</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- return the original nabla, not the</span>
<a name="line-1415"></a>                                          <span class='hs-comment'>-- refined one!</span>
<a name="line-1416"></a>            <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-varid'>recur_not_con</span> <span class='hs-comment'>-- Assume that x can't be con. Encode that fact</span>
<a name="line-1417"></a>                              <span class='hs-comment'>-- with addNotConCt and recur.</span>
<a name="line-1418"></a>
<a name="line-1419"></a><a name="isDataConTriviallyInhabited"></a><span class='hs-comment'>-- | Is this 'DataCon' trivially inhabited, that is, without needing to perform</span>
<a name="line-1420"></a><span class='hs-comment'>-- any inhabitation testing because of strict/unlifted fields or type</span>
<a name="line-1421"></a><span class='hs-comment'>-- equalities? See Note [DataCons that are definitely inhabitable]</span>
<a name="line-1422"></a><span class='hs-definition'>isDataConTriviallyInhabited</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1423"></a><span class='hs-definition'>isDataConTriviallyInhabited</span> <span class='hs-varid'>dc</span>
<a name="line-1424"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyConTriviallyInhabited</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1425"></a><span class='hs-definition'>isDataConTriviallyInhabited</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>=</span>
<a name="line-1426"></a>  <span class='hs-varid'>null</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConTheta</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span>         <span class='hs-comment'>-- (1)</span>
<a name="line-1427"></a>  <span class='hs-varid'>null</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConImplBangs</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span>     <span class='hs-comment'>-- (2)</span>
<a name="line-1428"></a>  <span class='hs-varid'>null</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConUnliftedFieldTys</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- (3)</span>
<a name="line-1429"></a>
<a name="line-1430"></a><a name="dataConUnliftedFieldTys"></a><span class='hs-definition'>dataConUnliftedFieldTys</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-1431"></a><span class='hs-definition'>dataConUnliftedFieldTys</span> <span class='hs-keyglyph'>=</span>
<a name="line-1432"></a>  <span class='hs-comment'>-- A levity polymorphic field requires an inhabitation test, hence compare to</span>
<a name="line-1433"></a>  <span class='hs-comment'>-- @Just True@</span>
<a name="line-1434"></a>  <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>==</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>isLiftedType_maybe</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>scaledThing</span> <span class='hs-varop'>.</span> <span class='hs-varid'>dataConOrigArgTys</span>
<a name="line-1435"></a>
<a name="line-1436"></a><a name="isTyConTriviallyInhabited"></a><span class='hs-definition'>isTyConTriviallyInhabited</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1437"></a><span class='hs-definition'>isTyConTriviallyInhabited</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>elementOfUniqSet</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>triviallyInhabitedTyCons</span>
<a name="line-1438"></a>
<a name="line-1439"></a><a name="triviallyInhabitedTyCons"></a><span class='hs-comment'>-- | All these types are trivially inhabited</span>
<a name="line-1440"></a><span class='hs-definition'>triviallyInhabitedTyCons</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UniqSet</span> <span class='hs-conid'>TyCon</span>
<a name="line-1441"></a><span class='hs-definition'>triviallyInhabitedTyCons</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkUniqSet</span> <span class='hs-keyglyph'>[</span>
<a name="line-1442"></a>    <span class='hs-varid'>charTyCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>doubleTyCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>floatTyCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>intTyCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>wordTyCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>word8TyCon</span>
<a name="line-1443"></a>  <span class='hs-keyglyph'>]</span>
<a name="line-1444"></a>
<a name="line-1445"></a><a name="compareConLikeTestability"></a><span class='hs-definition'>compareConLikeTestability</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ConLike</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConLike</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span>
<a name="line-1446"></a><span class='hs-comment'>-- We should instantiate DataCons first, because they are likely to occur in</span>
<a name="line-1447"></a><span class='hs-comment'>-- multiple COMPLETE sets at once and we might find that multiple COMPLETE sets</span>
<a name="line-1448"></a><span class='hs-comment'>-- are inhabitated by instantiating only a single DataCon.</span>
<a name="line-1449"></a><span class='hs-definition'>compareConLikeTestability</span> <span class='hs-conid'>PatSynCon</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>     <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-1450"></a><span class='hs-definition'>compareConLikeTestability</span> <span class='hs-keyword'>_</span>               <span class='hs-conid'>PatSynCon</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-1451"></a><span class='hs-definition'>compareConLikeTestability</span> <span class='hs-layout'>(</span><span class='hs-conid'>RealDataCon</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>RealDataCon</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mconcat</span>
<a name="line-1452"></a>  <span class='hs-comment'>-- Thetas are most expensive to check, as they might incur a whole new round</span>
<a name="line-1453"></a>  <span class='hs-comment'>-- of inhabitation testing</span>
<a name="line-1454"></a>  <span class='hs-keyglyph'>[</span> <span class='hs-varid'>comparing</span> <span class='hs-layout'>(</span><span class='hs-varid'>fast_length</span> <span class='hs-varop'>.</span> <span class='hs-varid'>dataConTheta</span><span class='hs-layout'>)</span>
<a name="line-1455"></a>  <span class='hs-comment'>-- Unlifted or strict fields only incur an inhabitation test for that</span>
<a name="line-1456"></a>  <span class='hs-comment'>-- particular field. Still something to avoid.</span>
<a name="line-1457"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>comparing</span> <span class='hs-varid'>unlifted_or_strict_fields</span>
<a name="line-1458"></a>  <span class='hs-keyglyph'>]</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span>
<a name="line-1459"></a>  <span class='hs-keyword'>where</span>
<a name="line-1460"></a>    <span class='hs-varid'>fast_length</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1461"></a>    <span class='hs-varid'>fast_length</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>atLength</span> <span class='hs-varid'>length</span> <span class='hs-num'>6</span> <span class='hs-varid'>xs</span> <span class='hs-num'>5</span> <span class='hs-comment'>-- @min 6 (length xs)@, but O(1)</span>
<a name="line-1462"></a>
<a name="line-1463"></a>    <span class='hs-comment'>-- An upper bound on the number of strict or unlifted fields. Approximate in</span>
<a name="line-1464"></a>    <span class='hs-comment'>-- the unlikely bogus case of an unlifted field that has a bang.</span>
<a name="line-1465"></a>    <span class='hs-varid'>unlifted_or_strict_fields</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1466"></a>    <span class='hs-varid'>unlifted_or_strict_fields</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fast_length</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConImplBangs</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span>
<a name="line-1467"></a>                                 <span class='hs-varop'>+</span> <span class='hs-varid'>fast_length</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConUnliftedFieldTys</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span>
<a name="line-1468"></a>
<a name="line-1469"></a><a name="instCon"></a><span class='hs-comment'>-- | @instCon fuel nabla (x::match_ty) K@ tries to instantiate @x@ to @K@ by</span>
<a name="line-1470"></a><span class='hs-comment'>-- adding the proper constructor constraint.</span>
<a name="line-1471"></a><span class='hs-comment'>--</span>
<a name="line-1472"></a><span class='hs-comment'>-- See Note [Instantiating a ConLike].</span>
<a name="line-1473"></a><span class='hs-definition'>instCon</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConLike</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Nabla</span>
<a name="line-1474"></a><span class='hs-definition'>instCon</span> <span class='hs-varid'>fuel</span> <span class='hs-varid'>nabla</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>MkNabla</span><span class='hs-layout'>{</span><span class='hs-varid'>nabla_ty_st</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty_st</span><span class='hs-layout'>}</span> <span class='hs-varid'>x</span> <span class='hs-varid'>con</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MaybeT</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-1475"></a>  <span class='hs-varid'>env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dsGetFamInstEnvs</span>
<a name="line-1476"></a>  <span class='hs-keyword'>let</span> <span class='hs-varid'>match_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>x</span>
<a name="line-1477"></a>  <span class='hs-varid'>norm_match_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>normaliseSourceTypeWHNF</span> <span class='hs-varid'>ty_st</span> <span class='hs-varid'>match_ty</span>
<a name="line-1478"></a>  <span class='hs-varid'>mb_sigma_univ</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchConLikeResTy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty_st</span> <span class='hs-varid'>norm_match_ty</span> <span class='hs-varid'>con</span>
<a name="line-1479"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_sigma_univ</span> <span class='hs-keyword'>of</span>
<a name="line-1480"></a>    <span class='hs-conid'>Just</span> <span class='hs-varid'>sigma_univ</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-1481"></a>      <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-sel'>_univ_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ex_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>eq_spec</span><span class='hs-layout'>,</span> <span class='hs-varid'>thetas</span><span class='hs-layout'>,</span> <span class='hs-sel'>_req_theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>field_tys</span><span class='hs-layout'>,</span> <span class='hs-sel'>_con_res_ty</span><span class='hs-layout'>)</span>
<a name="line-1482"></a>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>conLikeFullSig</span> <span class='hs-varid'>con</span>
<a name="line-1483"></a>      <span class='hs-comment'>-- Following Note [Instantiating a ConLike]:</span>
<a name="line-1484"></a>      <span class='hs-comment'>-- (1) _req_theta has been tested in 'matchConLikeResTy'</span>
<a name="line-1485"></a>      <span class='hs-comment'>-- (2) Instantiate fresh existentials</span>
<a name="line-1486"></a>      <span class='hs-layout'>(</span><span class='hs-varid'>sigma_ex</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>cloneTyVarBndrs</span> <span class='hs-varid'>sigma_univ</span> <span class='hs-varid'>ex_tvs</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>getUniqueSupplyM</span>
<a name="line-1487"></a>      <span class='hs-comment'>-- (3) Substitute provided constraints bound by the constructor.</span>
<a name="line-1488"></a>      <span class='hs-comment'>--     These are added to the type oracle as new facts (in a moment)</span>
<a name="line-1489"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>gammas</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTheta</span> <span class='hs-varid'>sigma_ex</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqSpecPreds</span> <span class='hs-varid'>eq_spec</span> <span class='hs-varop'>++</span> <span class='hs-varid'>thetas</span><span class='hs-layout'>)</span>
<a name="line-1490"></a>      <span class='hs-comment'>-- (4) Instantiate fresh term variables as arguments to the constructor</span>
<a name="line-1491"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>field_tys'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTys</span> <span class='hs-varid'>sigma_ex</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>scaledThing</span> <span class='hs-varid'>field_tys</span>
<a name="line-1492"></a>      <span class='hs-varid'>arg_ids</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>mkPmId</span> <span class='hs-varid'>field_tys'</span>
<a name="line-1493"></a>      <span class='hs-varid'>tracePm</span> <span class='hs-str'>"instCon"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-1494"></a>        <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>match_ty</span>
<a name="line-1495"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"In WHNF:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>isSourceTypeInWHNF</span> <span class='hs-varid'>match_ty</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>norm_match_ty</span>
<a name="line-1496"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>con</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"... -&gt;"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-sel'>_con_res_ty</span>
<a name="line-1497"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>tv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>char</span> <span class='hs-chr'>''</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTyVar</span> <span class='hs-varid'>sigma_univ</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-sel'>_univ_tvs</span><span class='hs-layout'>)</span>
<a name="line-1498"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>gammas</span>
<a name="line-1499"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_ids</span><span class='hs-layout'>)</span>
<a name="line-1500"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fuel</span>
<a name="line-1501"></a>        <span class='hs-keyglyph'>]</span>
<a name="line-1502"></a>      <span class='hs-comment'>-- (5) Finally add the new constructor constraint</span>
<a name="line-1503"></a>      <span class='hs-varid'>runMaybeT</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-1504"></a>        <span class='hs-comment'>-- Case (2) of Note [Strict fields and variables of unlifted type]</span>
<a name="line-1505"></a>        <span class='hs-keyword'>let</span> <span class='hs-varid'>alt</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PmAltConLike</span> <span class='hs-varid'>con</span>
<a name="line-1506"></a>        <span class='hs-varid'>nabla'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addPhiTmCt</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiConCt</span> <span class='hs-varid'>x</span> <span class='hs-varid'>alt</span> <span class='hs-varid'>ex_tvs</span> <span class='hs-varid'>gammas</span> <span class='hs-varid'>arg_ids</span><span class='hs-layout'>)</span>
<a name="line-1507"></a>        <span class='hs-keyword'>let</span> <span class='hs-varid'>branching_factor</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varop'>$</span> <span class='hs-varid'>filterUnliftedFields</span> <span class='hs-varid'>alt</span> <span class='hs-varid'>arg_ids</span>
<a name="line-1508"></a>        <span class='hs-comment'>-- See Note [Fuel for the inhabitation test]</span>
<a name="line-1509"></a>        <span class='hs-keyword'>let</span> <span class='hs-varid'>new_fuel</span>
<a name="line-1510"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>branching_factor</span> <span class='hs-varop'>&lt;=</span> <span class='hs-num'>1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fuel</span>
<a name="line-1511"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>min</span> <span class='hs-varid'>fuel</span> <span class='hs-num'>2</span>
<a name="line-1512"></a>        <span class='hs-varid'>inhabitationTest</span> <span class='hs-varid'>new_fuel</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_ty_st</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span> <span class='hs-varid'>nabla'</span>
<a name="line-1513"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Matching against match_ty failed. Inhabited!</span>
<a name="line-1514"></a>                                 <span class='hs-comment'>-- See Note [Instantiating a ConLike].</span>
<a name="line-1515"></a>
<a name="line-1516"></a><a name="matchConLikeResTy"></a><span class='hs-comment'>-- | @matchConLikeResTy _ _ ty K@ tries to match @ty@ against the result</span>
<a name="line-1517"></a><span class='hs-comment'>-- type of @K@, @res_ty@. It returns a substitution @s@ for @K@'s universal</span>
<a name="line-1518"></a><span class='hs-comment'>-- tyvars such that @s(res_ty)@ equals @ty@ if successful.</span>
<a name="line-1519"></a><span class='hs-comment'>--</span>
<a name="line-1520"></a><span class='hs-comment'>-- Make sure that @ty@ is normalised before.</span>
<a name="line-1521"></a><span class='hs-comment'>--</span>
<a name="line-1522"></a><span class='hs-comment'>-- See Note [Matching against a ConLike result type].</span>
<a name="line-1523"></a><span class='hs-definition'>matchConLikeResTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyState</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConLike</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>TCvSubst</span><span class='hs-layout'>)</span>
<a name="line-1524"></a><span class='hs-definition'>matchConLikeResTy</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>_</span>              <span class='hs-varid'>ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>RealDataCon</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-1525"></a>  <span class='hs-layout'>(</span><span class='hs-varid'>rep_tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>,</span> <span class='hs-sel'>_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitReprTyConApp_maybe</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-1526"></a>  <span class='hs-keyword'>if</span> <span class='hs-varid'>rep_tc</span> <span class='hs-varop'>==</span> <span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>dc</span>
<a name="line-1527"></a>    <span class='hs-keyword'>then</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipTCvSubst</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConUnivTyVars</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span>
<a name="line-1528"></a>    <span class='hs-keyword'>else</span> <span class='hs-conid'>Nothing</span>
<a name="line-1529"></a><span class='hs-definition'>matchConLikeResTy</span> <span class='hs-keyword'>_</span>   <span class='hs-layout'>(</span><span class='hs-conid'>TySt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>inert</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>PatSynCon</span> <span class='hs-varid'>ps</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runMaybeT</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-1530"></a>  <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>univ_tvs</span><span class='hs-layout'>,</span><span class='hs-varid'>req_theta</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>con_res_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>patSynSig</span> <span class='hs-varid'>ps</span>
<a name="line-1531"></a>  <span class='hs-varid'>subst</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>MaybeT</span> <span class='hs-varop'>$</span> <span class='hs-varid'>pure</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tcMatchTy</span> <span class='hs-varid'>con_res_ty</span> <span class='hs-varid'>ty</span>
<a name="line-1532"></a>  <span class='hs-varid'>guard</span> <span class='hs-varop'>$</span> <span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemTCvSubst`</span> <span class='hs-varid'>subst</span><span class='hs-layout'>)</span> <span class='hs-varid'>univ_tvs</span> <span class='hs-comment'>-- See the Note about T11336b</span>
<a name="line-1533"></a>  <span class='hs-keyword'>if</span> <span class='hs-varid'>null</span> <span class='hs-varid'>req_theta</span>
<a name="line-1534"></a>    <span class='hs-keyword'>then</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>subst</span>
<a name="line-1535"></a>    <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span>
<a name="line-1536"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>req_theta'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTys</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>req_theta</span>
<a name="line-1537"></a>      <span class='hs-varid'>satisfiable</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lift</span> <span class='hs-varop'>$</span> <span class='hs-varid'>initTcDsForSolver</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tcCheckWanteds</span> <span class='hs-varid'>inert</span> <span class='hs-varid'>req_theta'</span>
<a name="line-1538"></a>      <span class='hs-keyword'>if</span> <span class='hs-varid'>satisfiable</span>
<a name="line-1539"></a>        <span class='hs-keyword'>then</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>subst</span>
<a name="line-1540"></a>        <span class='hs-keyword'>else</span> <span class='hs-varid'>mzero</span>
<a name="line-1541"></a>
<a name="line-1542"></a><span class='hs-comment'>{- Note [Soundness and completeness]
<a name="line-1543"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1544"></a>Soundness and completeness of the pattern-match checker depends entirely on the
<a name="line-1545"></a>soundness and completeness of the inhabitation test.
<a name="line-1546"></a>
<a name="line-1547"></a>Achieving both soundness and completeness at the same time is undecidable.
<a name="line-1548"></a>See also T17977 and Note [Fuel for the inhabitation test].
<a name="line-1549"></a>Losing soundness would make the algorithm pointless; hence we give up on
<a name="line-1550"></a>completeness, but try to get as close as possible (how close is called
<a name="line-1551"></a>the 'precision' of the algorithm).
<a name="line-1552"></a>
<a name="line-1553"></a>Soundness means that you
<a name="line-1554"></a>  1. Can remove clauses flagged as redundant without changing program semantics
<a name="line-1555"></a>     (no false positives).
<a name="line-1556"></a>  2. Can be sure that your program is free of incomplete pattern matches
<a name="line-1557"></a>     when the checker doesn't flag any inexhaustive definitions
<a name="line-1558"></a>     (no false negatives).
<a name="line-1559"></a>
<a name="line-1560"></a>A complete algorithm would mean that
<a name="line-1561"></a>  1. When a clause can be deleted without changing program semantics, it will
<a name="line-1562"></a>     be flagged as redundant (no false negatives).
<a name="line-1563"></a>  2. A program that is free of incomplete pattern matches will never have a
<a name="line-1564"></a>     definition be flagged as inexhaustive (no false positives).
<a name="line-1565"></a>
<a name="line-1566"></a>Via the LYG algorithm, we reduce both these properties to a property on
<a name="line-1567"></a>the inhabitation test of refinementment types:
<a name="line-1568"></a>  *Soundness*:    If the inhabitation test says "no" for a given refinement type
<a name="line-1569"></a>                  Nabla, then it provably has no inhabitant.
<a name="line-1570"></a>  *Completeness*: If the inhabitation test says "yes" for a given refinement type
<a name="line-1571"></a>                  Nabla, then it provably has an inhabitant.
<a name="line-1572"></a>Our test is sound, but incomplete, so there are instances where we say
<a name="line-1573"></a>"yes" but in fact the Nabla is empty. Which entails false positive exhaustivity
<a name="line-1574"></a>and false negative redundancy warnings, as above.
<a name="line-1575"></a>
<a name="line-1576"></a>In summary, we have the following correspondence:
<a name="line-1577"></a>
<a name="line-1578"></a>Property     | Exhaustiveness warnings | Redundancy warnings | Inhabitation test |
<a name="line-1579"></a>-------------|-------------------------|---------------------|-------------------|
<a name="line-1580"></a>Soundness    | No false negatives      | No false positives  | Only says "no"    |
<a name="line-1581"></a>             |                         |                     | if there is no    |
<a name="line-1582"></a>             |                         |                     | inhabitant        |
<a name="line-1583"></a>Completeness | No false positives      | No false negatives  | Only says "yes"   |
<a name="line-1584"></a>             |                         |                     | if there is an    |
<a name="line-1585"></a>             |                         |                     | inhabitant        |
<a name="line-1586"></a>
<a name="line-1587"></a>Note [Shortcutting the inhabitation test]
<a name="line-1588"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1589"></a>Generally, we have to re-test a refinement type for inhabitants whenever we
<a name="line-1590"></a>add a new constraint. Often, we can say "no" early, upon trying to add a
<a name="line-1591"></a>contradicting constraint, see Note [The Pos/Neg invariant]. Still, COMPLETE
<a name="line-1592"></a>sets and type evidence are best handled in a delayed fashion, because of
<a name="line-1593"></a>the recursive nature of the test and our fuel-based approach.
<a name="line-1594"></a>But even then there are some cases in which we can skip the full test,
<a name="line-1595"></a>because we are sure that the refinement type is still inhabited. These
<a name="line-1596"></a>conditions are monitored by 'varNeedsTesting'. It returns
<a name="line-1597"></a>
<a name="line-1598"></a>- `True` whenever a full inhabitation test is needed
<a name="line-1599"></a>- `False` whenever the test can be skipped, amounting to an inhabitation test
<a name="line-1600"></a>  that says "yes".
<a name="line-1601"></a>
<a name="line-1602"></a>According to Note [Soundness and Completeness], this test will never compromise
<a name="line-1603"></a>soundness: The `True` case just forwards to the actual inhabitation test and the
<a name="line-1604"></a>`False` case amounts to an inhabitation test that is trivially sound, because it
<a name="line-1605"></a>never says "no".
<a name="line-1606"></a>
<a name="line-1607"></a>Of course, if the returns says `False`, Completeness (and thus Precision) of the
<a name="line-1608"></a>algorithm is affected, but we get to skip costly inhabitation tests. We try to
<a name="line-1609"></a>trade as little Precision as possible against as much Performance as possible.
<a name="line-1610"></a>Here are the tests, in order:
<a name="line-1611"></a>
<a name="line-1612"></a>  1. If a variable is dirty (because of a newly added negative term constraint),
<a name="line-1613"></a>     we have to test.
<a name="line-1614"></a>  2. If a variable has positive information, we don't have to test: The
<a name="line-1615"></a>     positive information acts as constructive proof for inhabitation.
<a name="line-1616"></a>  3. If the type state didn't change, there is no need to test.
<a name="line-1617"></a>  4. If the variable's normalised type didn't change, there is no need to test.
<a name="line-1618"></a>  5. Otherwise, we have to test.
<a name="line-1619"></a>
<a name="line-1620"></a>Why (1) before (2)?
<a name="line-1621"></a>-------------------
<a name="line-1622"></a>Consider the reverse for (T18960):
<a name="line-1623"></a>  pattern P x = x
<a name="line-1624"></a>  {-# COMPLETE P :: () #-}
<a name="line-1625"></a>  foo = case () of x@(P _) -&gt; ()
<a name="line-1626"></a>This should be exhaustive. But if we say "We know `x` has solution `()`, so it's
<a name="line-1627"></a>inhabited", then we'll get a warning saying that `()` wasn't matched.
<a name="line-1628"></a>But the match on `P` added the new negative information to the uncovered set,
<a name="line-1629"></a>in the process of which we marked `x` as dirty. By giving the dirty flag a
<a name="line-1630"></a>higher priority than positive info, we get to test again and see that `x` is
<a name="line-1631"></a>uninhabited and the match is exhaustive.
<a name="line-1632"></a>
<a name="line-1633"></a>But suppose that `P` wasn't mentioned in any COMPLETE set. Then we simply
<a name="line-1634"></a>don't mark `x` as dirty and will emit a warning again (which we would anyway),
<a name="line-1635"></a>without running a superfluous inhabitation test. That speeds up T17836
<a name="line-1636"></a>considerably.
<a name="line-1637"></a>
<a name="line-1638"></a>Why (2) before (3) and (4)?
<a name="line-1639"></a>---------------------------
<a name="line-1640"></a>Simply because (2) is more efficient to test than (3) (not by a lot), which
<a name="line-1641"></a>is more efficient to test than (4), which is still more efficient than running
<a name="line-1642"></a>the full inhabitation test (5).
<a name="line-1643"></a>
<a name="line-1644"></a>Note [Fuel for the inhabitation test]
<a name="line-1645"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1646"></a>Whether or not a type is inhabited is undecidable in general, see also
<a name="line-1647"></a>Note [Soundness and Completeness]. As a result, we can run into infinite
<a name="line-1648"></a>loops in `inhabitationTest`. Therefore, we adopt a fuel-based approach to
<a name="line-1649"></a>prevent that.
<a name="line-1650"></a>
<a name="line-1651"></a>Consider the following example:
<a name="line-1652"></a>
<a name="line-1653"></a>  data Abyss = MkAbyss !Abyss
<a name="line-1654"></a>  stareIntoTheAbyss :: Abyss -&gt; a
<a name="line-1655"></a>  stareIntoTheAbyss x = case x of {}
<a name="line-1656"></a>
<a name="line-1657"></a>In principle, stareIntoTheAbyss is exhaustive, since there is no way to
<a name="line-1658"></a>construct a terminating value using MkAbyss. But this can't be proven by mere
<a name="line-1659"></a>instantiation and requires an inductive argument, which `inhabitationTest`
<a name="line-1660"></a>currently isn't equipped to do.
<a name="line-1661"></a>
<a name="line-1662"></a>In order to prevent endless instantiation attempts in @inhabitationTest@, we
<a name="line-1663"></a>use the fuel as an upper bound such attempts.
<a name="line-1664"></a>
<a name="line-1665"></a>The same problem occurs with recursive newtypes, like in the following code:
<a name="line-1666"></a>
<a name="line-1667"></a>  newtype Chasm = MkChasm Chasm
<a name="line-1668"></a>  gazeIntoTheChasm :: Chasm -&gt; a
<a name="line-1669"></a>  gazeIntoTheChasm x = case x of {} -- Erroneously warned as non-exhaustive
<a name="line-1670"></a>
<a name="line-1671"></a>So this limitation is somewhat understandable.
<a name="line-1672"></a>
<a name="line-1673"></a>Note that even with this recursion detection, there is still a possibility that
<a name="line-1674"></a>`inhabitationTest` can run in exponential time in the amount of fuel. Consider
<a name="line-1675"></a>the following data type:
<a name="line-1676"></a>
<a name="line-1677"></a>  data T = MkT !T !T !T
<a name="line-1678"></a>
<a name="line-1679"></a>If we try to instantiate each of its fields, that will require us to once again
<a name="line-1680"></a>check if `MkT` is inhabitable in each of those three fields, which in turn will
<a name="line-1681"></a>require us to check if `MkT` is inhabitable again... As you can see, the
<a name="line-1682"></a>branching factor adds up quickly, and if the initial fuel is, say,
<a name="line-1683"></a>100, then the inhabiation test will effectively take forever.
<a name="line-1684"></a>
<a name="line-1685"></a>To mitigate this, we check the branching factor every time we are about to do
<a name="line-1686"></a>inhabitation testing in 'instCon'. If the branching factor exceeds 1
<a name="line-1687"></a>(i.e., if there is potential for exponential runtime), then we limit the
<a name="line-1688"></a>maximum recursion depth to 1 to mitigate the problem. If the branching factor
<a name="line-1689"></a>is exactly 1 (i.e., we have a linear chain instead of a tree), then it's okay
<a name="line-1690"></a>to stick with a larger maximum recursion depth.
<a name="line-1691"></a>
<a name="line-1692"></a>In #17977 we saw that the defaultRecTcMaxBound (100 at the time of writing) was
<a name="line-1693"></a>too large and had detrimental effect on performance of the coverage checker.
<a name="line-1694"></a>Given that we only commit to a best effort anyway, we decided to substantially
<a name="line-1695"></a>decrement the fuel to 4, at the cost of precision in some edge cases
<a name="line-1696"></a>like
<a name="line-1697"></a>
<a name="line-1698"></a>  data Nat = Z | S Nat
<a name="line-1699"></a>  data Down :: Nat -&gt; Type where
<a name="line-1700"></a>    Down :: !(Down n) -&gt; Down (S n)
<a name="line-1701"></a>  f :: Down (S (S (S (S (S Z))))) -&gt; ()
<a name="line-1702"></a>  f x = case x of {}
<a name="line-1703"></a>
<a name="line-1704"></a>Since the coverage won't bother to instantiate Down 4 levels deep to see that it
<a name="line-1705"></a>is in fact uninhabited, it will emit a inexhaustivity warning for the case.
<a name="line-1706"></a>
<a name="line-1707"></a>Note [DataCons that are definitely inhabitable]
<a name="line-1708"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1709"></a>Another microoptimization applies to data types like this one:
<a name="line-1710"></a>
<a name="line-1711"></a>  data S a = S ![a] !T
<a name="line-1712"></a>
<a name="line-1713"></a>Even though there is a strict field of type [a], it's quite silly to call
<a name="line-1714"></a>'instCon' on it, since it's "obvious" that it is inhabitable. To make this
<a name="line-1715"></a>intuition formal, we say that a DataCon C is definitely inhabitable (DI) if:
<a name="line-1716"></a>
<a name="line-1717"></a>  1. C has no equality constraints (since they might be unsatisfiable)
<a name="line-1718"></a>  2. C has no strict arguments (since they might be uninhabitable)
<a name="line-1719"></a>  3. C has no unlifted argument types (since they might be uninhabitable)
<a name="line-1720"></a>
<a name="line-1721"></a>It's relatively cheap to check if a DataCon is DI, so before we call 'instCon'
<a name="line-1722"></a>on a constructor of a COMPLETE set, we filter out all of the DI ones.
<a name="line-1723"></a>
<a name="line-1724"></a>This fast path shaves down -7% allocations for PmSeriesG, for example.
<a name="line-1725"></a>
<a name="line-1726"></a>Note [Matching against a ConLike result type]
<a name="line-1727"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1728"></a>Given a ConLike
<a name="line-1729"></a>
<a name="line-1730"></a>&gt; C :: forall us. R =&gt; ... -&gt; res_ty
<a name="line-1731"></a>
<a name="line-1732"></a>is a pattern `C ...` compatible with the type `ty`? Clearly that is the case if
<a name="line-1733"></a>`res_ty` /subsumes/ `ty` and the required constraints `R` (strictly a feature of
<a name="line-1734"></a>pattern synonyms) are satisfiable. In that case, 'matchConLikeResTy' returns a
<a name="line-1735"></a>substitution  over `us` such that `(res_ty) == ty`.
<a name="line-1736"></a>
<a name="line-1737"></a>It's surprisingly tricky to implement correctly, and works quite different for
<a name="line-1738"></a>DataCons and PatSynCons:
<a name="line-1739"></a>
<a name="line-1740"></a>  * For data cons, we look at `ty` and see if it's a TyCon app `T t1 ... tn`.
<a name="line-1741"></a>    If that is the case, we make sure that `C` is a DataCon of `T` and return
<a name="line-1742"></a>    a substitution mapping `C`'s universal tyvars `us` to `t1`...`tn`.
<a name="line-1743"></a>
<a name="line-1744"></a>    Wrinkle: Since `T` might be a data family TyCon, we have to look up its
<a name="line-1745"></a>    representation TyCon before we compare to `C`'s TyCon.
<a name="line-1746"></a>    So we use 'splitReprTyConApp_maybe' instead of 'splitTyConApp_maybe'.
<a name="line-1747"></a>
<a name="line-1748"></a>  * For pattern synonyms, we directly match `ty` against `res_ty` to get the
<a name="line-1749"></a>    substitution . See Note [Pattern synonym result type] in "GHC.Core.PatSyn".
<a name="line-1750"></a>
<a name="line-1751"></a>    Fortunately, we don't have to treat data family TyCons specially:
<a name="line-1752"></a>    Pattern synonyms /never/ apply to a data family representation TyCon.
<a name="line-1753"></a>    We do have to consider the required constraints `(R)`, though, as we have
<a name="line-1754"></a>    seen in #19475. That is done by solving them as Wanted constraints given the
<a name="line-1755"></a>    inert set of the current type state (which is part of a Nabla's TySt). Since
<a name="line-1756"></a>    spinning up a constraint solver session is costly, we only do so in the rare
<a name="line-1757"></a>    cases that a pattern synonym actually carries any required constraints.
<a name="line-1758"></a>
<a name="line-1759"></a>    We can get into the strange situation that not all universal type variables
<a name="line-1760"></a>    `us` occur in `res_ty`. Example from T11336b:
<a name="line-1761"></a>
<a name="line-1762"></a>      instance C Proxy where ...                      -- impl uninteresting
<a name="line-1763"></a>      pattern P :: forall f a. C f =&gt; f a -&gt; Proxy a  -- impl uninteresting
<a name="line-1764"></a>
<a name="line-1765"></a>      fun :: Proxy a -&gt; ()
<a name="line-1766"></a>      fun (P Proxy) = ()
<a name="line-1767"></a>      fun (P Proxy) = () -- ideally detected as redundant
<a name="line-1768"></a>
<a name="line-1769"></a>    `f` is a universal type variable and `C f` the required constraint of
<a name="line-1770"></a>    pattern synonym `P`. But `f` doesn't occur in the result type `Proxy a` of
<a name="line-1771"></a>    `P`, so  will not even have `f` in its in-scope set. It's a bit unclear
<a name="line-1772"></a>    what to do here; we might want to freshen `f` to `f'` and see if we can
<a name="line-1773"></a>    solve `C f'` as a Wanted constraint, which we most likely can't.
<a name="line-1774"></a>    Hence, we simply skip the freshening and declare the match as failed when
<a name="line-1775"></a>    there is a variable like `f`. For the definition of `fun`, that
<a name="line-1776"></a>    means we will not remember that we matched on `P` and thus will
<a name="line-1777"></a>    not detect its second clause as redundant.
<a name="line-1778"></a>
<a name="line-1779"></a>    See Note [Pattern synonym result type] in "GHC.Core.PatSyn" for similar
<a name="line-1780"></a>    oddities.
<a name="line-1781"></a>
<a name="line-1782"></a>Note [Instantiating a ConLike]
<a name="line-1783"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1784"></a>`instCon` implements the the \(Inst\) function from Figure 8 of the LYG paper.
<a name="line-1785"></a>
<a name="line-1786"></a>Given the following type of ConLike `K`
<a name="line-1787"></a>
<a name="line-1788"></a>&gt; K :: forall us. R =&gt; forall es. P =&gt; t1 -&gt; ... -&gt; tn -&gt; res_ty
<a name="line-1789"></a>
<a name="line-1790"></a>and a variable `x::match_ty`, it tries to find an instantiation
<a name="line-1791"></a>`K ex_tvs gammas arg_ids :: match_ty` (for fresh `arg_ids`) and ultimately adds
<a name="line-1792"></a>a constructor constraint `K ex_tvs gammas arg_ids &lt;- x` to the given Nabla.
<a name="line-1793"></a>
<a name="line-1794"></a>As a first step, it tries (via 'matchConLikeResTy') to match `match_ty` against
<a name="line-1795"></a>`res_ty` and checks that that the required constraints @R@ are satisfiable.
<a name="line-1796"></a>See Note [Matching against a ConLike result type].
<a name="line-1797"></a>
<a name="line-1798"></a>If matching /fails/, it trivially (and conservatively) reports "inhabited" by
<a name="line-1799"></a>returning the unrefined input Nabla. After all, the match might have failed due
<a name="line-1800"></a>to incomplete type information in Nabla.
<a name="line-1801"></a>(Type refinement from unpacking GADT constructors might monomorphise `match_ty`
<a name="line-1802"></a>so much that `res_ty` ultimately subsumes it.)
<a name="line-1803"></a>
<a name="line-1804"></a>If matching /succeeds/, we get a substitution  for the (universal)
<a name="line-1805"></a>tyvars `us`. After applying , we get
<a name="line-1806"></a>
<a name="line-1807"></a>&gt; K @(us) :: (R) =&gt; forall (es). (P) =&gt; (t1) -&gt; ... -&gt; (tn) -&gt; match_ty
<a name="line-1808"></a>
<a name="line-1809"></a>The existentials `es` might still occur in argument types `(tn)`, though.
<a name="line-1810"></a>Now 'instCon' performs the following steps:
<a name="line-1811"></a>
<a name="line-1812"></a> 1. It drops the required constraints `(R)`, as they have already been
<a name="line-1813"></a>    discharged by 'matchConLikeResTy'.
<a name="line-1814"></a> 2. It instantiates fresh binders `es'` for the other type variables `es`
<a name="line-1815"></a>    bound by `K` and adds the mapping to  to get ', so that we have
<a name="line-1816"></a>
<a name="line-1817"></a>    &gt; K @(us) @es' :: '(P) =&gt; '(t1) -&gt; ... -&gt; '(tn) -&gt; match_ty
<a name="line-1818"></a>
<a name="line-1819"></a> 3. It adds new type constraints from the substituted
<a name="line-1820"></a>    provided constraints @'(P)@.
<a name="line-1821"></a> 4. It substitutes and conjures new binders @arg_ids@ for the argument types
<a name="line-1822"></a>    @'(t1) ... '(tn)@.
<a name="line-1823"></a> 5. It adds a term constraint @K es' '(P) arg_ids &lt;- x@, which handles
<a name="line-1824"></a>    the details regarding type constraints and unlifted fields.
<a name="line-1825"></a>
<a name="line-1826"></a>And finally the extended 'Nabla' is returned if all the constraints were
<a name="line-1827"></a>compatible.
<a name="line-1828"></a>-}</span>
<a name="line-1829"></a>
<a name="line-1830"></a><span class='hs-comment'>--------------------------------------</span>
<a name="line-1831"></a><span class='hs-comment'>-- * Generating inhabitants of a Nabla</span>
<a name="line-1832"></a><span class='hs-comment'>--</span>
<a name="line-1833"></a><span class='hs-comment'>-- This is important for warnings. Roughly corresponds to G in Figure 6 of the</span>
<a name="line-1834"></a><span class='hs-comment'>-- LYG paper, with a few tweaks for better warning messages.</span>
<a name="line-1835"></a>
<a name="line-1836"></a><a name="generateInhabitingPatterns"></a><span class='hs-comment'>-- | @generateInhabitingPatterns vs n nabla@ returns a list of at most @n@ (but</span>
<a name="line-1837"></a><span class='hs-comment'>-- perhaps empty) refinements of @nabla@ that represent inhabited patterns.</span>
<a name="line-1838"></a><span class='hs-comment'>-- Negative information is only retained if literals are involved or for</span>
<a name="line-1839"></a><span class='hs-comment'>-- recursive GADTs.</span>
<a name="line-1840"></a><span class='hs-definition'>generateInhabitingPatterns</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Nabla</span><span class='hs-keyglyph'>]</span>
<a name="line-1841"></a><span class='hs-comment'>-- See Note [Why inhabitationTest doesn't call generateInhabitingPatterns]</span>
<a name="line-1842"></a><span class='hs-definition'>generateInhabitingPatterns</span> <span class='hs-keyword'>_</span>      <span class='hs-num'>0</span> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>[]</span>
<a name="line-1843"></a><span class='hs-definition'>generateInhabitingPatterns</span> <span class='hs-conid'>[]</span>     <span class='hs-keyword'>_</span> <span class='hs-varid'>nabla</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>nabla</span><span class='hs-keyglyph'>]</span>
<a name="line-1844"></a><span class='hs-definition'>generateInhabitingPatterns</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>n</span> <span class='hs-varid'>nabla</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1845"></a>  <span class='hs-varid'>tracePm</span> <span class='hs-str'>"generateInhabitingPatterns"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span>
<a name="line-1846"></a>  <span class='hs-keyword'>let</span> <span class='hs-conid'>VI</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>pos</span> <span class='hs-varid'>neg</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupVarInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_tm_st</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span>
<a name="line-1847"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>pos</span> <span class='hs-keyword'>of</span>
<a name="line-1848"></a>    <span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-1849"></a>      <span class='hs-comment'>-- All solutions must be valid at once. Try to find candidates for their</span>
<a name="line-1850"></a>      <span class='hs-comment'>-- fields. Example:</span>
<a name="line-1851"></a>      <span class='hs-comment'>--   f x@(Just _) True = case x of SomePatSyn _ -&gt; ()</span>
<a name="line-1852"></a>      <span class='hs-comment'>-- after this clause, we want to report that</span>
<a name="line-1853"></a>      <span class='hs-comment'>--   * @f Nothing _@ is uncovered</span>
<a name="line-1854"></a>      <span class='hs-comment'>--   * @f x False@ is uncovered</span>
<a name="line-1855"></a>      <span class='hs-comment'>-- where @x@ will have two possibly compatible solutions, @Just y@ for</span>
<a name="line-1856"></a>      <span class='hs-comment'>-- some @y@ and @SomePatSyn z@ for some @z@. We must find evidence for @y@</span>
<a name="line-1857"></a>      <span class='hs-comment'>-- and @z@ that is valid at the same time. These constitute arg_vas below.</span>
<a name="line-1858"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_vas</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMap</span> <span class='hs-varid'>paca_ids</span> <span class='hs-varid'>pos</span>
<a name="line-1859"></a>      <span class='hs-varid'>generateInhabitingPatterns</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_vas</span> <span class='hs-varop'>++</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>n</span> <span class='hs-varid'>nabla</span>
<a name="line-1860"></a>    <span class='hs-conid'>[]</span>
<a name="line-1861"></a>      <span class='hs-comment'>-- When there are literals involved, just print negative info</span>
<a name="line-1862"></a>      <span class='hs-comment'>-- instead of listing missed constructors</span>
<a name="line-1863"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>notNull</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PmAltLit</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pmAltConSetElems</span> <span class='hs-varid'>neg</span> <span class='hs-keyglyph'>]</span>
<a name="line-1864"></a>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>generateInhabitingPatterns</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>nabla</span>
<a name="line-1865"></a>    <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>try_instantiate</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>nabla</span>
<a name="line-1866"></a>  <span class='hs-keyword'>where</span>
<a name="line-1867"></a>    <span class='hs-comment'>-- | Tries to instantiate a variable by possibly following the chain of</span>
<a name="line-1868"></a>    <span class='hs-comment'>-- newtypes and then instantiating to all ConLikes of the wrapped type's</span>
<a name="line-1869"></a>    <span class='hs-comment'>-- minimal residual COMPLETE set.</span>
<a name="line-1870"></a>    <span class='hs-varid'>try_instantiate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Nabla</span><span class='hs-keyglyph'>]</span>
<a name="line-1871"></a>    <span class='hs-comment'>-- Convention: x binds the outer constructor in the chain, y the inner one.</span>
<a name="line-1872"></a>    <span class='hs-varid'>try_instantiate</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>nabla</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1873"></a>      <span class='hs-layout'>(</span><span class='hs-sel'>_src_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>dcs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rep_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tntrGuts</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>pmTopNormaliseType</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_ty_st</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1874"></a>      <span class='hs-varid'>mb_stuff</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runMaybeT</span> <span class='hs-varop'>$</span> <span class='hs-varid'>instantiate_newtype_chain</span> <span class='hs-varid'>x</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>dcs</span>
<a name="line-1875"></a>      <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_stuff</span> <span class='hs-keyword'>of</span>
<a name="line-1876"></a>        <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>[]</span>
<a name="line-1877"></a>        <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-layout'>,</span> <span class='hs-varid'>newty_nabla</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-1878"></a>          <span class='hs-keyword'>let</span> <span class='hs-varid'>vi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupVarInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_tm_st</span> <span class='hs-varid'>newty_nabla</span><span class='hs-layout'>)</span> <span class='hs-varid'>y</span>
<a name="line-1879"></a>          <span class='hs-varid'>env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dsGetFamInstEnvs</span>
<a name="line-1880"></a>          <span class='hs-varid'>rcm</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>splitReprTyConApp_maybe</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rep_ty</span> <span class='hs-keyword'>of</span>
<a name="line-1881"></a>            <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addTyConMatches</span> <span class='hs-varid'>tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>vi_rcm</span> <span class='hs-varid'>vi</span><span class='hs-layout'>)</span>
<a name="line-1882"></a>            <span class='hs-conid'>Nothing</span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addCompleteMatches</span> <span class='hs-layout'>(</span><span class='hs-varid'>vi_rcm</span> <span class='hs-varid'>vi</span><span class='hs-layout'>)</span>
<a name="line-1883"></a>
<a name="line-1884"></a>          <span class='hs-comment'>-- Test all COMPLETE sets for inhabitants (n inhs at max). Take care of .</span>
<a name="line-1885"></a>          <span class='hs-varid'>clss</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pickApplicableCompleteSets</span> <span class='hs-layout'>(</span><span class='hs-varid'>nabla_ty_st</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span> <span class='hs-varid'>rep_ty</span> <span class='hs-varid'>rcm</span>
<a name="line-1886"></a>          <span class='hs-keyword'>case</span> <span class='hs-conid'>NE.nonEmpty</span> <span class='hs-layout'>(</span><span class='hs-varid'>uniqDSetToList</span> <span class='hs-varop'>.</span> <span class='hs-varid'>cmConLikes</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>clss</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-1887"></a>            <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1888"></a>              <span class='hs-comment'>-- No COMPLETE sets ==&gt; inhabited</span>
<a name="line-1889"></a>              <span class='hs-varid'>generateInhabitingPatterns</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>newty_nabla</span>
<a name="line-1890"></a>            <span class='hs-conid'>Just</span> <span class='hs-varid'>clss</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-1891"></a>              <span class='hs-comment'>-- Try each COMPLETE set, pick the one with the smallest number of</span>
<a name="line-1892"></a>              <span class='hs-comment'>-- inhabitants</span>
<a name="line-1893"></a>              <span class='hs-varid'>nablass'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>forM</span> <span class='hs-varid'>clss</span> <span class='hs-layout'>(</span><span class='hs-varid'>instantiate_cons</span> <span class='hs-varid'>y</span> <span class='hs-varid'>rep_ty</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>newty_nabla</span><span class='hs-layout'>)</span>
<a name="line-1894"></a>              <span class='hs-keyword'>let</span> <span class='hs-varid'>nablas'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>minimumBy</span> <span class='hs-layout'>(</span><span class='hs-varid'>comparing</span> <span class='hs-varid'>length</span><span class='hs-layout'>)</span> <span class='hs-varid'>nablass'</span>
<a name="line-1895"></a>              <span class='hs-keyword'>if</span> <span class='hs-varid'>null</span> <span class='hs-varid'>nablas'</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>vi_bot</span> <span class='hs-varid'>vi</span> <span class='hs-varop'>/=</span> <span class='hs-conid'>IsNotBot</span>
<a name="line-1896"></a>                <span class='hs-keyword'>then</span> <span class='hs-varid'>generateInhabitingPatterns</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>newty_nabla</span> <span class='hs-comment'>-- bot is still possible. Display a wildcard!</span>
<a name="line-1897"></a>                <span class='hs-keyword'>else</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>nablas'</span>
<a name="line-1898"></a>
<a name="line-1899"></a>    <span class='hs-comment'>-- | Instantiates a chain of newtypes, beginning at @x@.</span>
<a name="line-1900"></a>    <span class='hs-comment'>-- Turns @x nabla [T,U,V]@ to @(y, nabla')@, where @nabla'@ we has the fact</span>
<a name="line-1901"></a>    <span class='hs-comment'>-- @x ~ T (U (V y))@.</span>
<a name="line-1902"></a>    <span class='hs-varid'>instantiate_newtype_chain</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeT</span> <span class='hs-conid'>DsM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nabla</span><span class='hs-layout'>)</span>
<a name="line-1903"></a>    <span class='hs-varid'>instantiate_newtype_chain</span> <span class='hs-varid'>x</span> <span class='hs-varid'>nabla</span> <span class='hs-conid'>[]</span>                      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>nabla</span><span class='hs-layout'>)</span>
<a name="line-1904"></a>    <span class='hs-varid'>instantiate_newtype_chain</span> <span class='hs-varid'>x</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-sel'>_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>dc</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>dcs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1905"></a>      <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lift</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkPmId</span> <span class='hs-varid'>arg_ty</span>
<a name="line-1906"></a>      <span class='hs-comment'>-- Newtypes don't have existentials (yet?!), so passing an empty</span>
<a name="line-1907"></a>      <span class='hs-comment'>-- list as ex_tvs.</span>
<a name="line-1908"></a>      <span class='hs-varid'>nabla'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addConCt</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmAltConLike</span> <span class='hs-layout'>(</span><span class='hs-conid'>RealDataCon</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span>
<a name="line-1909"></a>      <span class='hs-varid'>instantiate_newtype_chain</span> <span class='hs-varid'>y</span> <span class='hs-varid'>nabla'</span> <span class='hs-varid'>dcs</span>
<a name="line-1910"></a>
<a name="line-1911"></a>    <span class='hs-varid'>instantiate_cons</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nabla</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ConLike</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Nabla</span><span class='hs-keyglyph'>]</span>
<a name="line-1912"></a>    <span class='hs-varid'>instantiate_cons</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>  <span class='hs-keyword'>_</span>  <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>     <span class='hs-conid'>[]</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>[]</span>
<a name="line-1913"></a>    <span class='hs-varid'>instantiate_cons</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>  <span class='hs-keyword'>_</span>  <span class='hs-num'>0</span> <span class='hs-keyword'>_</span>     <span class='hs-keyword'>_</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>[]</span>
<a name="line-1914"></a>    <span class='hs-varid'>instantiate_cons</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>nabla</span> <span class='hs-keyword'>_</span>
<a name="line-1915"></a>      <span class='hs-comment'>-- We don't want to expose users to GHC-specific constructors for Int etc.</span>
<a name="line-1916"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>fmap</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTyConTriviallyInhabited</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>True</span>
<a name="line-1917"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>generateInhabitingPatterns</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>nabla</span>
<a name="line-1918"></a>    <span class='hs-varid'>instantiate_cons</span> <span class='hs-varid'>x</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>nabla</span> <span class='hs-layout'>(</span><span class='hs-varid'>cl</span><span class='hs-conop'>:</span><span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1919"></a>      <span class='hs-comment'>-- The following line is where we call out to the inhabitationTest!</span>
<a name="line-1920"></a>      <span class='hs-varid'>mb_nabla</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runMaybeT</span> <span class='hs-varop'>$</span> <span class='hs-varid'>instCon</span> <span class='hs-num'>4</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>x</span> <span class='hs-varid'>cl</span>
<a name="line-1921"></a>      <span class='hs-varid'>tracePm</span> <span class='hs-str'>"instantiate_cons"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1922"></a>                                       <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span>
<a name="line-1923"></a>                                       <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cl</span>
<a name="line-1924"></a>                                       <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>nabla</span>
<a name="line-1925"></a>                                       <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>mb_nabla</span>
<a name="line-1926"></a>                                       <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1927"></a>      <span class='hs-varid'>con_nablas</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_nabla</span> <span class='hs-keyword'>of</span>
<a name="line-1928"></a>        <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>[]</span>
<a name="line-1929"></a>        <span class='hs-comment'>-- NB: We don't prepend arg_vars as we don't have any evidence on</span>
<a name="line-1930"></a>        <span class='hs-comment'>-- them and we only want to split once on a data type. They are</span>
<a name="line-1931"></a>        <span class='hs-comment'>-- inhabited, otherwise the inhabitation test would have refuted.</span>
<a name="line-1932"></a>        <span class='hs-conid'>Just</span> <span class='hs-varid'>nabla'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>generateInhabitingPatterns</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>nabla'</span>
<a name="line-1933"></a>      <span class='hs-varid'>other_cons_nablas</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>instantiate_cons</span> <span class='hs-varid'>x</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>xs</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span> <span class='hs-comment'>-</span> <span class='hs-varid'>length</span> <span class='hs-varid'>con_nablas</span><span class='hs-layout'>)</span> <span class='hs-varid'>nabla</span> <span class='hs-varid'>cls</span>
<a name="line-1934"></a>      <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>con_nablas</span> <span class='hs-varop'>++</span> <span class='hs-varid'>other_cons_nablas</span><span class='hs-layout'>)</span>
<a name="line-1935"></a>
<a name="line-1936"></a><a name="pickApplicableCompleteSets"></a><span class='hs-definition'>pickApplicableCompleteSets</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyState</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ResidualCompleteMatches</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CompleteMatch</span><span class='hs-keyglyph'>]</span>
<a name="line-1937"></a><span class='hs-comment'>-- See Note [Implementation of COMPLETE pragmas] on what "applicable" means</span>
<a name="line-1938"></a><span class='hs-definition'>pickApplicableCompleteSets</span> <span class='hs-varid'>ty_st</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>rcm</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1939"></a>  <span class='hs-keyword'>let</span> <span class='hs-varid'>cl_res_ty_ok</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ConLike</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Bool</span>
<a name="line-1940"></a>      <span class='hs-varid'>cl_res_ty_ok</span> <span class='hs-varid'>cl</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1941"></a>        <span class='hs-varid'>env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dsGetFamInstEnvs</span>
<a name="line-1942"></a>        <span class='hs-varid'>isJust</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>matchConLikeResTy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty_st</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>cl</span>
<a name="line-1943"></a>  <span class='hs-keyword'>let</span> <span class='hs-varid'>cm_applicable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CompleteMatch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-conid'>Bool</span>
<a name="line-1944"></a>      <span class='hs-varid'>cm_applicable</span> <span class='hs-varid'>cm</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1945"></a>        <span class='hs-varid'>cls_ok</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>allM</span> <span class='hs-varid'>cl_res_ty_ok</span> <span class='hs-layout'>(</span><span class='hs-varid'>uniqDSetToList</span> <span class='hs-layout'>(</span><span class='hs-varid'>cmConLikes</span> <span class='hs-varid'>cm</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1946"></a>        <span class='hs-keyword'>let</span> <span class='hs-varid'>match_ty_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>completeMatchAppliesAtType</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>cm</span>
<a name="line-1947"></a>        <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls_ok</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>match_ty_ok</span><span class='hs-layout'>)</span>
<a name="line-1948"></a>  <span class='hs-varid'>applicable_cms</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>filterM</span> <span class='hs-varid'>cm_applicable</span> <span class='hs-layout'>(</span><span class='hs-varid'>getRcm</span> <span class='hs-varid'>rcm</span><span class='hs-layout'>)</span>
<a name="line-1949"></a>  <span class='hs-varid'>tracePm</span> <span class='hs-str'>"pickApplicableCompleteSets:"</span> <span class='hs-varop'>$</span>
<a name="line-1950"></a>    <span class='hs-varid'>vcat</span>
<a name="line-1951"></a>      <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span>
<a name="line-1952"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rcm</span>
<a name="line-1953"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>applicable_cms</span>
<a name="line-1954"></a>      <span class='hs-keyglyph'>]</span>
<a name="line-1955"></a>  <span class='hs-varid'>return</span> <span class='hs-varid'>applicable_cms</span>
<a name="line-1956"></a>
<a name="line-1957"></a><span class='hs-comment'>{- Note [Why inhabitationTest doesn't call generateInhabitingPatterns]
<a name="line-1958"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1959"></a>Why can't we define `inhabitationTest` (IT) in terms of
<a name="line-1960"></a>`generateInhabitingPatterns` (GIP) as
<a name="line-1961"></a>
<a name="line-1962"></a>  inhabitationTest nabla = do
<a name="line-1963"></a>    nablas &lt;- lift $ generateInhabitingPatterns all_variables 1 nabla
<a name="line-1964"></a>    guard (notNull nablas)
<a name="line-1965"></a>
<a name="line-1966"></a>There are a few technical reasons, like the lack of a fuel-tracking approach
<a name="line-1967"></a>to stay decidable, that could be overcome. But the nail in the coffin is
<a name="line-1968"></a>performance: In order to provide good warning messages, GIP commits to *one*
<a name="line-1969"></a>COMPLETE set, and goes through some hoops to find the minimal one. This implies
<a name="line-1970"></a>it has to look at *all* constructors in the residual COMPLETE matches and see if
<a name="line-1971"></a>they match, if only to filter out ill-typed COMPLETE sets
<a name="line-1972"></a>(see Note [Implementation of COMPLETE pragmas]). That is untractable for an
<a name="line-1973"></a>efficient IT on huge enumerations.
<a name="line-1974"></a>
<a name="line-1975"></a>But we still need GIP to produce the Nablas as proxies for
<a name="line-1976"></a>uncovered patterns that we display warnings for. It's fine to pay this price
<a name="line-1977"></a>once at the end, but IT is called far more often than that.
<a name="line-1978"></a>-}</span>
</pre></body>
</html>

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Types/Id/Make.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The University of Glasgow 2006
<a name="line-3"></a>(c) The AQUA Project, Glasgow University, 1998
<a name="line-4"></a>
<a name="line-5"></a>
<a name="line-6"></a>This module contains definitions for the IdInfo for things that
<a name="line-7"></a>have a standard form, namely:
<a name="line-8"></a>
<a name="line-9"></a>- data constructors
<a name="line-10"></a>- record selectors
<a name="line-11"></a>- method and superclass selectors
<a name="line-12"></a>- primitive operations
<a name="line-13"></a>-}</span>
<a name="line-14"></a>
<a name="line-15"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-16"></a>
<a name="line-17"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span>
<a name="line-18"></a>
<a name="line-19"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Types.Id.Make</span> <span class='hs-layout'>(</span>
<a name="line-20"></a>        <span class='hs-varid'>mkDictFunId</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkDictFunTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkDictSelId</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkDictSelRhs</span><span class='hs-layout'>,</span>
<a name="line-21"></a>
<a name="line-22"></a>        <span class='hs-varid'>mkPrimOpId</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkFCallId</span><span class='hs-layout'>,</span>
<a name="line-23"></a>
<a name="line-24"></a>        <span class='hs-varid'>unwrapNewTypeBody</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrapFamInstBody</span><span class='hs-layout'>,</span>
<a name="line-25"></a>        <span class='hs-conid'>DataConBoxer</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>vanillaDataConBoxer</span><span class='hs-layout'>,</span>
<a name="line-26"></a>        <span class='hs-varid'>mkDataConRep</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkDataConWorkId</span><span class='hs-layout'>,</span>
<a name="line-27"></a>
<a name="line-28"></a>        <span class='hs-comment'>-- And some particular Ids; see below for why they are wired in</span>
<a name="line-29"></a>        <span class='hs-varid'>wiredInIds</span><span class='hs-layout'>,</span> <span class='hs-varid'>ghcPrimIds</span><span class='hs-layout'>,</span>
<a name="line-30"></a>        <span class='hs-varid'>realWorldPrimId</span><span class='hs-layout'>,</span>
<a name="line-31"></a>        <span class='hs-varid'>voidPrimId</span><span class='hs-layout'>,</span> <span class='hs-varid'>voidArgId</span><span class='hs-layout'>,</span>
<a name="line-32"></a>        <span class='hs-varid'>nullAddrId</span><span class='hs-layout'>,</span> <span class='hs-varid'>seqId</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazyId</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazyIdKey</span><span class='hs-layout'>,</span>
<a name="line-33"></a>        <span class='hs-varid'>coercionTokenId</span><span class='hs-layout'>,</span> <span class='hs-varid'>magicDictId</span><span class='hs-layout'>,</span> <span class='hs-varid'>coerceId</span><span class='hs-layout'>,</span>
<a name="line-34"></a>        <span class='hs-varid'>proxyHashId</span><span class='hs-layout'>,</span> <span class='hs-varid'>noinlineId</span><span class='hs-layout'>,</span> <span class='hs-varid'>noinlineIdName</span><span class='hs-layout'>,</span>
<a name="line-35"></a>        <span class='hs-varid'>coerceName</span><span class='hs-layout'>,</span> <span class='hs-varid'>leftSectionName</span><span class='hs-layout'>,</span> <span class='hs-varid'>rightSectionName</span><span class='hs-layout'>,</span>
<a name="line-36"></a>
<a name="line-37"></a>        <span class='hs-comment'>-- Re-export error Ids</span>
<a name="line-38"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.Opt.ConstantFold</span>
<a name="line-39"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-40"></a>
<a name="line-41"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-42"></a>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-44"></a>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Types.Prim</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Types</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.ConstantFold</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Multiplicity</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCo.Rep</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FamInstEnv</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.TcType</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TcType</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Make</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FVs</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>mkRuleInfo</span> <span class='hs-layout'>)</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Utils</span>   <span class='hs-layout'>(</span> <span class='hs-varid'>exprType</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCast</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkDefaultCase</span> <span class='hs-layout'>)</span>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Unfold.Make</span>
<a name="line-58"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.SimpleOpt</span>
<a name="line-59"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Literal</span>
<a name="line-60"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.SourceText</span>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCon</span>
<a name="line-62"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Class</span>
<a name="line-63"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name.Set</span>
<a name="line-64"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span>
<a name="line-65"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.PrimOps</span>
<a name="line-66"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.ForeignCall</span>
<a name="line-67"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.DataCon</span>
<a name="line-68"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span>
<a name="line-69"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id.Info</span>
<a name="line-70"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Demand</span>
<a name="line-71"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Cpr</span>
<a name="line-72"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.TyThing</span>
<a name="line-73"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core</span>
<a name="line-74"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique</span>
<a name="line-75"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Uniques</span>
<a name="line-76"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique.Supply</span>
<a name="line-77"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Names</span>
<a name="line-78"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>       <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span> <span class='hs-conid'>SuccessFlag</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-79"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-80"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Session</span>
<a name="line-81"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Ppr</span>
<a name="line-82"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-83"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-84"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.FastString</span>
<a name="line-85"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.List.SetOps</span>
<a name="line-86"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span> <span class='hs-layout'>(</span><span class='hs-conid'>VarBndr</span><span class='hs-layout'>(</span><span class='hs-conid'>Bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-87"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>GHC.LanguageExtensions</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>LangExt</span>
<a name="line-88"></a>
<a name="line-89"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Maybe</span>       <span class='hs-layout'>(</span> <span class='hs-varid'>maybeToList</span> <span class='hs-layout'>)</span>
<a name="line-90"></a>
<a name="line-91"></a><span class='hs-comment'>{-
<a name="line-92"></a>************************************************************************
<a name="line-93"></a>*                                                                      *
<a name="line-94"></a>\subsection{Wired in Ids}
<a name="line-95"></a>*                                                                      *
<a name="line-96"></a>************************************************************************
<a name="line-97"></a>
<a name="line-98"></a>Note [Wired-in Ids]
<a name="line-99"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-100"></a>A "wired-in" Id can be referred to directly in GHC (e.g. 'voidPrimId')
<a name="line-101"></a>rather than by looking it up its name in some environment or fetching
<a name="line-102"></a>it from an interface file.
<a name="line-103"></a>
<a name="line-104"></a>There are several reasons why an Id might appear in the wiredInIds:
<a name="line-105"></a>
<a name="line-106"></a>* ghcPrimIds: see Note [ghcPrimIds (aka pseudoops)]
<a name="line-107"></a>
<a name="line-108"></a>* magicIds: see Note [magicIds]
<a name="line-109"></a>
<a name="line-110"></a>* errorIds, defined in GHC.Core.Make.
<a name="line-111"></a>  These error functions (e.g. rUNTIME_ERROR_ID) are wired in
<a name="line-112"></a>  because the desugarer generates code that mentions them directly
<a name="line-113"></a>
<a name="line-114"></a>In all cases except ghcPrimIds, there is a definition site in a
<a name="line-115"></a>library module, which may be called (e.g. in higher order situations);
<a name="line-116"></a>but the wired-in version means that the details are never read from
<a name="line-117"></a>that module's interface file; instead, the full definition is right
<a name="line-118"></a>here.
<a name="line-119"></a>
<a name="line-120"></a>Note [ghcPrimIds (aka pseudoops)]
<a name="line-121"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-122"></a>The ghcPrimIds
<a name="line-123"></a>
<a name="line-124"></a>  * Are exported from GHC.Prim (see ghcPrimExports, used in ghcPrimInterface)
<a name="line-125"></a>    See Note [GHC.Prim] in primops.txt.pp for the remaining items in GHC.Prim.
<a name="line-126"></a>
<a name="line-127"></a>  * Can't be defined in Haskell, and hence no Haskell binding site,
<a name="line-128"></a>    but have perfectly reasonable unfoldings in Core
<a name="line-129"></a>
<a name="line-130"></a>  * Either have a CompulsoryUnfolding (hence always inlined), or
<a name="line-131"></a>        of an EvaldUnfolding and void representation (e.g. realWorldPrimId)
<a name="line-132"></a>
<a name="line-133"></a>  * Are (or should be) defined in primops.txt.pp as 'pseudoop'
<a name="line-134"></a>    Reason: that's how we generate documentation for them
<a name="line-135"></a>
<a name="line-136"></a>Note [magicIds]
<a name="line-137"></a>~~~~~~~~~~~~~~~
<a name="line-138"></a>The magicIds
<a name="line-139"></a>
<a name="line-140"></a>  * Are exported from GHC.Magic
<a name="line-141"></a>
<a name="line-142"></a>  * Can be defined in Haskell (and are, in ghc-prim:GHC/Magic.hs).
<a name="line-143"></a>    This definition at least generates Haddock documentation for them.
<a name="line-144"></a>
<a name="line-145"></a>  * May or may not have a CompulsoryUnfolding.
<a name="line-146"></a>
<a name="line-147"></a>  * But have some special behaviour that can't be done via an
<a name="line-148"></a>    unfolding from an interface file.
<a name="line-149"></a>
<a name="line-150"></a>  * May have IdInfo that differs from what would be imported from GHC.Magic.hi.
<a name="line-151"></a>    For example, 'lazy' gets a lazy strictness signature, per Note [lazyId magic].
<a name="line-152"></a>
<a name="line-153"></a>  The two remaining identifiers in GHC.Magic, runRW# and inline, are not listed
<a name="line-154"></a>  in magicIds: they have special behavior but they can be known-key and
<a name="line-155"></a>  not wired-in.
<a name="line-156"></a>  runRW#: see Note [Simplification of runRW#] in Prep, runRW# code in
<a name="line-157"></a>  Simplifier, Note [Linting of runRW#].
<a name="line-158"></a>  inline: see Note [inlineId magic]
<a name="line-159"></a>-}</span>
<a name="line-160"></a>
<a name="line-161"></a><a name="wiredInIds"></a><span class='hs-definition'>wiredInIds</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span>
<a name="line-162"></a><span class='hs-definition'>wiredInIds</span>
<a name="line-163"></a>  <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>magicIds</span>
<a name="line-164"></a>  <span class='hs-varop'>++</span> <span class='hs-varid'>ghcPrimIds</span>
<a name="line-165"></a>  <span class='hs-varop'>++</span> <span class='hs-varid'>errorIds</span>           <span class='hs-comment'>-- Defined in GHC.Core.Make</span>
<a name="line-166"></a>
<a name="line-167"></a><a name="magicIds"></a><span class='hs-definition'>magicIds</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- See Note [magicIds]</span>
<a name="line-168"></a><span class='hs-definition'>magicIds</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>lazyId</span><span class='hs-layout'>,</span> <span class='hs-varid'>oneShotId</span><span class='hs-layout'>,</span> <span class='hs-varid'>noinlineId</span><span class='hs-keyglyph'>]</span>
<a name="line-169"></a>
<a name="line-170"></a><a name="ghcPrimIds"></a><span class='hs-definition'>ghcPrimIds</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- See Note [ghcPrimIds (aka pseudoops)]</span>
<a name="line-171"></a><span class='hs-definition'>ghcPrimIds</span>
<a name="line-172"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>realWorldPrimId</span>
<a name="line-173"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>voidPrimId</span>
<a name="line-174"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>nullAddrId</span>
<a name="line-175"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>seqId</span>
<a name="line-176"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>magicDictId</span>
<a name="line-177"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>coerceId</span>
<a name="line-178"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>proxyHashId</span>
<a name="line-179"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>leftSectionId</span>
<a name="line-180"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>rightSectionId</span>
<a name="line-181"></a>    <span class='hs-keyglyph'>]</span>
<a name="line-182"></a>
<a name="line-183"></a><span class='hs-comment'>{-
<a name="line-184"></a>************************************************************************
<a name="line-185"></a>*                                                                      *
<a name="line-186"></a>\subsection{Data constructors}
<a name="line-187"></a>*                                                                      *
<a name="line-188"></a>************************************************************************
<a name="line-189"></a>
<a name="line-190"></a>The wrapper for a constructor is an ordinary top-level binding that evaluates
<a name="line-191"></a>any strict args, unboxes any args that are going to be flattened, and calls
<a name="line-192"></a>the worker.
<a name="line-193"></a>
<a name="line-194"></a>We're going to build a constructor that looks like:
<a name="line-195"></a>
<a name="line-196"></a>        data (Data a, C b) =&gt;  T a b = T1 !a !Int b
<a name="line-197"></a>
<a name="line-198"></a>        T1 = /\ a b -&gt;
<a name="line-199"></a>             \d1::Data a, d2::C b -&gt;
<a name="line-200"></a>             \p q r -&gt; case p of { p -&gt;
<a name="line-201"></a>                       case q of { q -&gt;
<a name="line-202"></a>                       Con T1 [a,b] [p,q,r]}}
<a name="line-203"></a>
<a name="line-204"></a>Notice that
<a name="line-205"></a>
<a name="line-206"></a>* d2 is thrown away --- a context in a data decl is used to make sure
<a name="line-207"></a>  one *could* construct dictionaries at the site the constructor
<a name="line-208"></a>  is used, but the dictionary isn't actually used.
<a name="line-209"></a>
<a name="line-210"></a>* We have to check that we can construct Data dictionaries for
<a name="line-211"></a>  the types a and Int.  Once we've done that we can throw d1 away too.
<a name="line-212"></a>
<a name="line-213"></a>* We use (case p of q -&gt; ...) to evaluate p, rather than "seq" because
<a name="line-214"></a>  all that matters is that the arguments are evaluated.  "seq" is
<a name="line-215"></a>  very careful to preserve evaluation order, which we don't need
<a name="line-216"></a>  to be here.
<a name="line-217"></a>
<a name="line-218"></a>  You might think that we could simply give constructors some strictness
<a name="line-219"></a>  info, like PrimOps, and let CoreToStg do the let-to-case transformation.
<a name="line-220"></a>  But we don't do that because in the case of primops and functions strictness
<a name="line-221"></a>  is a *property* not a *requirement*.  In the case of constructors we need to
<a name="line-222"></a>  do something active to evaluate the argument.
<a name="line-223"></a>
<a name="line-224"></a>  Making an explicit case expression allows the simplifier to eliminate
<a name="line-225"></a>  it in the (common) case where the constructor arg is already evaluated.
<a name="line-226"></a>
<a name="line-227"></a>Note [Wrappers for data instance tycons]
<a name="line-228"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-229"></a>In the case of data instances, the wrapper also applies the coercion turning
<a name="line-230"></a>the representation type into the family instance type to cast the result of
<a name="line-231"></a>the wrapper.  For example, consider the declarations
<a name="line-232"></a>
<a name="line-233"></a>  data family Map k :: * -&gt; *
<a name="line-234"></a>  data instance Map (a, b) v = MapPair (Map a (Pair b v))
<a name="line-235"></a>
<a name="line-236"></a>The tycon to which the datacon MapPair belongs gets a unique internal
<a name="line-237"></a>name of the form :R123Map, and we call it the representation tycon.
<a name="line-238"></a>In contrast, Map is the family tycon (accessible via
<a name="line-239"></a>tyConFamInst_maybe). A coercion allows you to move between
<a name="line-240"></a>representation and family type.  It is accessible from :R123Map via
<a name="line-241"></a>tyConFamilyCoercion_maybe and has kind
<a name="line-242"></a>
<a name="line-243"></a>  Co123Map a b v :: {Map (a, b) v ~ :R123Map a b v}
<a name="line-244"></a>
<a name="line-245"></a>The wrapper and worker of MapPair get the types
<a name="line-246"></a>
<a name="line-247"></a>        -- Wrapper
<a name="line-248"></a>  $WMapPair :: forall a b v. Map a (Map a b v) -&gt; Map (a, b) v
<a name="line-249"></a>  $WMapPair a b v = MapPair a b v `cast` sym (Co123Map a b v)
<a name="line-250"></a>
<a name="line-251"></a>        -- Worker
<a name="line-252"></a>  MapPair :: forall a b v. Map a (Map a b v) -&gt; :R123Map a b v
<a name="line-253"></a>
<a name="line-254"></a>This coercion is conditionally applied by wrapFamInstBody.
<a name="line-255"></a>
<a name="line-256"></a>It's a bit more complicated if the data instance is a GADT as well!
<a name="line-257"></a>
<a name="line-258"></a>   data instance T [a] where
<a name="line-259"></a>        T1 :: forall b. b -&gt; T [Maybe b]
<a name="line-260"></a>
<a name="line-261"></a>Hence we translate to
<a name="line-262"></a>
<a name="line-263"></a>        -- Wrapper
<a name="line-264"></a>  $WT1 :: forall b. b -&gt; T [Maybe b]
<a name="line-265"></a>  $WT1 b v = T1 (Maybe b) b (Maybe b) v
<a name="line-266"></a>                        `cast` sym (Co7T (Maybe b))
<a name="line-267"></a>
<a name="line-268"></a>        -- Worker
<a name="line-269"></a>  T1 :: forall c b. (c ~ Maybe b) =&gt; b -&gt; :R7T c
<a name="line-270"></a>
<a name="line-271"></a>        -- Coercion from family type to representation type
<a name="line-272"></a>  Co7T a :: T [a] ~ :R7T a
<a name="line-273"></a>
<a name="line-274"></a>Newtype instances through an additional wrinkle into the mix. Consider the
<a name="line-275"></a>following example (adapted from #15318, comment:2):
<a name="line-276"></a>
<a name="line-277"></a>  data family T a
<a name="line-278"></a>  newtype instance T [a] = MkT [a]
<a name="line-279"></a>
<a name="line-280"></a>Within the newtype instance, there are three distinct types at play:
<a name="line-281"></a>
<a name="line-282"></a>1. The newtype's underlying type, [a].
<a name="line-283"></a>2. The instance's representation type, TList a (where TList is the
<a name="line-284"></a>   representation tycon).
<a name="line-285"></a>3. The family type, T [a].
<a name="line-286"></a>
<a name="line-287"></a>We need two coercions in order to cast from (1) to (3):
<a name="line-288"></a>
<a name="line-289"></a>(a) A newtype coercion axiom:
<a name="line-290"></a>
<a name="line-291"></a>      axiom coTList a :: TList a ~ [a]
<a name="line-292"></a>
<a name="line-293"></a>    (Where TList is the representation tycon of the newtype instance.)
<a name="line-294"></a>
<a name="line-295"></a>(b) A data family instance coercion axiom:
<a name="line-296"></a>
<a name="line-297"></a>      axiom coT a :: T [a] ~ TList a
<a name="line-298"></a>
<a name="line-299"></a>When we translate the newtype instance to Core, we obtain:
<a name="line-300"></a>
<a name="line-301"></a>    -- Wrapper
<a name="line-302"></a>  $WMkT :: forall a. [a] -&gt; T [a]
<a name="line-303"></a>  $WMkT a x = MkT a x |&gt; Sym (coT a)
<a name="line-304"></a>
<a name="line-305"></a>    -- Worker
<a name="line-306"></a>  MkT :: forall a. [a] -&gt; TList [a]
<a name="line-307"></a>  MkT a x = x |&gt; Sym (coTList a)
<a name="line-308"></a>
<a name="line-309"></a>Unlike for data instances, the worker for a newtype instance is actually an
<a name="line-310"></a>executable function which expands to a cast, but otherwise, the general
<a name="line-311"></a>strategy is essentially the same as for data instances. Also note that we have
<a name="line-312"></a>a wrapper, which is unusual for a newtype, but we make GHC produce one anyway
<a name="line-313"></a>for symmetry with the way data instances are handled.
<a name="line-314"></a>
<a name="line-315"></a>Note [Newtype datacons]
<a name="line-316"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-317"></a>The "data constructor" for a newtype should always be vanilla.  At one
<a name="line-318"></a>point this wasn't true, because the newtype arising from
<a name="line-319"></a>     class C a =&gt; D a
<a name="line-320"></a>looked like
<a name="line-321"></a>       newtype T:D a = D:D (C a)
<a name="line-322"></a>so the data constructor for T:C had a single argument, namely the
<a name="line-323"></a>predicate (C a).  But now we treat that as an ordinary argument, not
<a name="line-324"></a>part of the theta-type, so all is well.
<a name="line-325"></a>
<a name="line-326"></a>Note [Newtype workers]
<a name="line-327"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-328"></a>A newtype does not really have a worker. Instead, newtype constructors
<a name="line-329"></a>just unfold into a cast. But we need *something* for, say, MkAge to refer
<a name="line-330"></a>to. So, we do this:
<a name="line-331"></a>
<a name="line-332"></a>* The Id used as the newtype worker will have a compulsory unfolding to
<a name="line-333"></a>  a cast. See Note [Compulsory newtype unfolding]
<a name="line-334"></a>
<a name="line-335"></a>* This Id is labeled as a DataConWrapId. We don't want to use a DataConWorkId,
<a name="line-336"></a>  as those have special treatment in the back end.
<a name="line-337"></a>
<a name="line-338"></a>* There is no top-level binding, because the compulsory unfolding
<a name="line-339"></a>  means that it will be inlined (to a cast) at every call site.
<a name="line-340"></a>
<a name="line-341"></a>We probably should have a NewtypeWorkId, but these Ids disappear as soon as
<a name="line-342"></a>we desugar anyway, so it seems a step too far.
<a name="line-343"></a>
<a name="line-344"></a>Note [Compulsory newtype unfolding]
<a name="line-345"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-346"></a>Newtype wrappers, just like workers, have compulsory unfoldings.
<a name="line-347"></a>This is needed so that two optimizations involving newtypes have the same
<a name="line-348"></a>effect whether a wrapper is present or not:
<a name="line-349"></a>
<a name="line-350"></a>(1) Case-of-known constructor.
<a name="line-351"></a>    See Note [beta-reduction in exprIsConApp_maybe].
<a name="line-352"></a>
<a name="line-353"></a>(2) Matching against the map/coerce RULE. Suppose we have the RULE
<a name="line-354"></a>
<a name="line-355"></a>    {-# RULE "map/coerce" map coerce = ... #-}
<a name="line-356"></a>
<a name="line-357"></a>    As described in Note [Getting the map/coerce RULE to work],
<a name="line-358"></a>    the occurrence of 'coerce' is transformed into:
<a name="line-359"></a>
<a name="line-360"></a>    {-# RULE "map/coerce" forall (c :: T1 ~R# T2).
<a name="line-361"></a>                          map ((\v -&gt; v) `cast` c) = ... #-}
<a name="line-362"></a>
<a name="line-363"></a>    We'd like 'map Age' to match the LHS. For this to happen, Age
<a name="line-364"></a>    must be unfolded, otherwise we'll be stuck. This is tested in T16208.
<a name="line-365"></a>
<a name="line-366"></a>It also allows for the posssibility of levity polymorphic newtypes
<a name="line-367"></a>with wrappers (with -XUnliftedNewtypes):
<a name="line-368"></a>
<a name="line-369"></a>  newtype N (a :: TYPE r) = MkN a
<a name="line-370"></a>
<a name="line-371"></a>With -XUnliftedNewtypes, this is allowed -- even though MkN is levity-
<a name="line-372"></a>polymorphic. It's OK because MkN evaporates in the compiled code, becoming
<a name="line-373"></a>just a cast. That is, it has a compulsory unfolding. As long as its
<a name="line-374"></a>argument is not levity-polymorphic (which it can't be, according to
<a name="line-375"></a>Note [Levity polymorphism invariants] in GHC.Core), and it's saturated,
<a name="line-376"></a>no levity-polymorphic code ends up in the code generator. The saturation
<a name="line-377"></a>condition is effectively checked by Note [Detecting forced eta expansion]
<a name="line-378"></a>in GHC.HsToCore.Expr.
<a name="line-379"></a>
<a name="line-380"></a>However, if we make a *wrapper* for a newtype, we get into trouble.
<a name="line-381"></a>The saturation condition is no longer checked (because hasNoBinding
<a name="line-382"></a>returns False) and indeed we generate a forbidden levity-polymorphic
<a name="line-383"></a>binding.
<a name="line-384"></a>
<a name="line-385"></a>The solution is simple, though: just make the newtype wrappers
<a name="line-386"></a>as ephemeral as the newtype workers. In other words, give the wrappers
<a name="line-387"></a>compulsory unfoldings and no bindings. The compulsory unfolding is given
<a name="line-388"></a>in wrap_unf in mkDataConRep, and the lack of a binding happens in
<a name="line-389"></a>GHC.Iface.Tidy.getTyConImplicitBinds, where we say that a newtype has no
<a name="line-390"></a>implicit bindings.
<a name="line-391"></a>
<a name="line-392"></a>Note [Records and linear types]
<a name="line-393"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-394"></a>All the fields, in a record constructor, are linear, because there is no syntax
<a name="line-395"></a>to specify the type of record field. There will be (see the proposal
<a name="line-396"></a>https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0111-linear-types.rst#records-and-projections
<a name="line-397"></a>), but it isn't implemented yet.
<a name="line-398"></a>
<a name="line-399"></a>Projections of records can't be linear:
<a name="line-400"></a>
<a name="line-401"></a>  data Foo = MkFoo { a :: A, b :: B }
<a name="line-402"></a>
<a name="line-403"></a>If we had
<a name="line-404"></a>
<a name="line-405"></a>  a :: Foo %1 -&gt; A
<a name="line-406"></a>
<a name="line-407"></a>We could write
<a name="line-408"></a>
<a name="line-409"></a>  bad :: A %1 -&gt; B %1 -&gt; A
<a name="line-410"></a>  bad x y = a (MkFoo { a=x, b=y })
<a name="line-411"></a>
<a name="line-412"></a>There is an exception: if `b` (more generally all the fields besides `a`) is
<a name="line-413"></a>unrestricted, then is perfectly possible to have a linear projection. Such a
<a name="line-414"></a>linear projection has as simple definition.
<a name="line-415"></a>
<a name="line-416"></a>  data Bar = MkBar { c :: C, d # Many :: D }
<a name="line-417"></a>
<a name="line-418"></a>  c :: Bar %1 -&gt; C
<a name="line-419"></a>  c MkBar{ c=x, d=_} = x
<a name="line-420"></a>
<a name="line-421"></a>The `# Many` syntax, for records, does not exist yet. But there is one important
<a name="line-422"></a>special case which already happens: when there is a single field (usually a
<a name="line-423"></a>newtype).
<a name="line-424"></a>
<a name="line-425"></a>  newtype Baz = MkBaz { unbaz :: E }
<a name="line-426"></a>
<a name="line-427"></a>unbaz could be linear. And, in fact, it is linear in the proposal design.
<a name="line-428"></a>
<a name="line-429"></a>However, this hasn't been implemented yet.
<a name="line-430"></a>
<a name="line-431"></a>************************************************************************
<a name="line-432"></a>*                                                                      *
<a name="line-433"></a>\subsection{Dictionary selectors}
<a name="line-434"></a>*                                                                      *
<a name="line-435"></a>************************************************************************
<a name="line-436"></a>
<a name="line-437"></a>Selecting a field for a dictionary.  If there is just one field, then
<a name="line-438"></a>there's nothing to do.
<a name="line-439"></a>
<a name="line-440"></a>Dictionary selectors may get nested forall-types.  Thus:
<a name="line-441"></a>
<a name="line-442"></a>        class Foo a where
<a name="line-443"></a>          op :: forall b. Ord b =&gt; a -&gt; b -&gt; b
<a name="line-444"></a>
<a name="line-445"></a>Then the top-level type for op is
<a name="line-446"></a>
<a name="line-447"></a>        op :: forall a. Foo a =&gt;
<a name="line-448"></a>              forall b. Ord b =&gt;
<a name="line-449"></a>              a -&gt; b -&gt; b
<a name="line-450"></a>
<a name="line-451"></a>Note [Type classes and linear types]
<a name="line-452"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-453"></a>
<a name="line-454"></a>Constraints, in particular type classes, don't have attached linearity
<a name="line-455"></a>information. Implicitly, they are all unrestricted. See the linear types proposal,
<a name="line-456"></a>https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0111-linear-types.rst .
<a name="line-457"></a>
<a name="line-458"></a>When translating to core `C =&gt; ...` is always translated to an unrestricted
<a name="line-459"></a>arrow `C # Many -&gt; ...`.
<a name="line-460"></a>
<a name="line-461"></a>Therefore there is no loss of generality if we make all selectors unrestricted.
<a name="line-462"></a>
<a name="line-463"></a>-}</span>
<a name="line-464"></a>
<a name="line-465"></a><a name="mkDictSelId"></a><span class='hs-definition'>mkDictSelId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span>          <span class='hs-comment'>-- Name of one of the *value* selectors</span>
<a name="line-466"></a>                             <span class='hs-comment'>-- (dictionary superclass or method)</span>
<a name="line-467"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-468"></a><span class='hs-definition'>mkDictSelId</span> <span class='hs-varid'>name</span> <span class='hs-varid'>clas</span>
<a name="line-469"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkGlobalId</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClassOpId</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span> <span class='hs-varid'>name</span> <span class='hs-varid'>sel_ty</span> <span class='hs-varid'>info</span>
<a name="line-470"></a>  <span class='hs-keyword'>where</span>
<a name="line-471"></a>    <span class='hs-varid'>tycon</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>classTyCon</span> <span class='hs-varid'>clas</span>
<a name="line-472"></a>    <span class='hs-varid'>sel_names</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>idName</span> <span class='hs-layout'>(</span><span class='hs-varid'>classAllSelIds</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span>
<a name="line-473"></a>    <span class='hs-varid'>new_tycon</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNewTyCon</span> <span class='hs-varid'>tycon</span>
<a name="line-474"></a>    <span class='hs-keyglyph'>[</span><span class='hs-varid'>data_con</span><span class='hs-keyglyph'>]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConDataCons</span> <span class='hs-varid'>tycon</span>
<a name="line-475"></a>    <span class='hs-varid'>tyvars</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConUserTyVarBinders</span> <span class='hs-varid'>data_con</span>
<a name="line-476"></a>    <span class='hs-varid'>n_ty_args</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>tyvars</span>
<a name="line-477"></a>    <span class='hs-varid'>arg_tys</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepArgTys</span> <span class='hs-varid'>data_con</span>  <span class='hs-comment'>-- Includes the dictionary superclasses</span>
<a name="line-478"></a>    <span class='hs-varid'>val_index</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>assoc</span> <span class='hs-str'>"MkId.mkDictSelId"</span> <span class='hs-layout'>(</span><span class='hs-varid'>sel_names</span> <span class='hs-varop'>`zip`</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>name</span>
<a name="line-479"></a>
<a name="line-480"></a>    <span class='hs-varid'>sel_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInvisForAllTys</span> <span class='hs-varid'>tyvars</span> <span class='hs-varop'>$</span>
<a name="line-481"></a>             <span class='hs-varid'>mkInvisFunTyMany</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>clas</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>binderVars</span> <span class='hs-varid'>tyvars</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-482"></a>             <span class='hs-varid'>scaledThing</span> <span class='hs-layout'>(</span><span class='hs-varid'>getNth</span> <span class='hs-varid'>arg_tys</span> <span class='hs-varid'>val_index</span><span class='hs-layout'>)</span>
<a name="line-483"></a>               <span class='hs-comment'>-- See Note [Type classes and linear types]</span>
<a name="line-484"></a>
<a name="line-485"></a>    <span class='hs-varid'>base_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span>
<a name="line-486"></a>                <span class='hs-varop'>`setArityInfo`</span>          <span class='hs-num'>1</span>
<a name="line-487"></a>                <span class='hs-varop'>`setStrictnessInfo`</span>     <span class='hs-varid'>strict_sig</span>
<a name="line-488"></a>                <span class='hs-varop'>`setCprInfo`</span>            <span class='hs-varid'>topCprSig</span>
<a name="line-489"></a>                <span class='hs-varop'>`setLevityInfoWithType`</span> <span class='hs-varid'>sel_ty</span>
<a name="line-490"></a>
<a name="line-491"></a>    <span class='hs-varid'>info</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>new_tycon</span>
<a name="line-492"></a>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>base_info</span> <span class='hs-varop'>`setInlinePragInfo`</span> <span class='hs-varid'>alwaysInlinePragma</span>
<a name="line-493"></a>                     <span class='hs-varop'>`setUnfoldingInfo`</span>  <span class='hs-varid'>mkInlineUnfoldingWithArity</span> <span class='hs-num'>1</span>
<a name="line-494"></a>                                           <span class='hs-varid'>defaultSimpleOpts</span>
<a name="line-495"></a>                                           <span class='hs-layout'>(</span><span class='hs-varid'>mkDictSelRhs</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>val_index</span><span class='hs-layout'>)</span>
<a name="line-496"></a>                   <span class='hs-comment'>-- See Note [Single-method classes] in GHC.Tc.TyCl.Instance</span>
<a name="line-497"></a>                   <span class='hs-comment'>-- for why alwaysInlinePragma</span>
<a name="line-498"></a>
<a name="line-499"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-500"></a>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>base_info</span> <span class='hs-varop'>`setRuleInfo`</span> <span class='hs-varid'>mkRuleInfo</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>rule</span><span class='hs-keyglyph'>]</span>
<a name="line-501"></a>                   <span class='hs-comment'>-- Add a magic BuiltinRule, but no unfolding</span>
<a name="line-502"></a>                   <span class='hs-comment'>-- so that the rule is always available to fire.</span>
<a name="line-503"></a>                   <span class='hs-comment'>-- See Note [ClassOp/DFun selection] in GHC.Tc.TyCl.Instance</span>
<a name="line-504"></a>
<a name="line-505"></a>    <span class='hs-comment'>-- This is the built-in rule that goes</span>
<a name="line-506"></a>    <span class='hs-comment'>--      op (dfT d1 d2) ---&gt;  opT d1 d2</span>
<a name="line-507"></a>    <span class='hs-varid'>rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fsLit</span> <span class='hs-str'>"Class op "</span> <span class='hs-varop'>`appendFS`</span>
<a name="line-508"></a>                                     <span class='hs-varid'>occNameFS</span> <span class='hs-layout'>(</span><span class='hs-varid'>getOccName</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span>
<a name="line-509"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>ru_fn</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>name</span>
<a name="line-510"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>ru_nargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n_ty_args</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span>
<a name="line-511"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>ru_try</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dictSelRule</span> <span class='hs-varid'>val_index</span> <span class='hs-varid'>n_ty_args</span> <span class='hs-layout'>}</span>
<a name="line-512"></a>
<a name="line-513"></a>        <span class='hs-comment'>-- The strictness signature is of the form U(AAAVAAAA) -&gt; T</span>
<a name="line-514"></a>        <span class='hs-comment'>-- where the V depends on which item we are selecting</span>
<a name="line-515"></a>        <span class='hs-comment'>-- It's worth giving one, so that absence info etc is generated</span>
<a name="line-516"></a>        <span class='hs-comment'>-- even if the selector isn't inlined</span>
<a name="line-517"></a>
<a name="line-518"></a>    <span class='hs-varid'>strict_sig</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClosedStrictSig</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg_dmd</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>topDiv</span>
<a name="line-519"></a>    <span class='hs-varid'>arg_dmd</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>new_tycon</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evalDmd</span>
<a name="line-520"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>C_1N</span> <span class='hs-conop'>:*</span>
<a name="line-521"></a>                          <span class='hs-conid'>Prod</span> <span class='hs-keyglyph'>[</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>name</span> <span class='hs-varop'>==</span> <span class='hs-varid'>sel_name</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>evalDmd</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>absDmd</span>
<a name="line-522"></a>                               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sel_name</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>sel_names</span> <span class='hs-keyglyph'>]</span>
<a name="line-523"></a>
<a name="line-524"></a><a name="mkDictSelRhs"></a><span class='hs-definition'>mkDictSelRhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Class</span>
<a name="line-525"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>         <span class='hs-comment'>-- 0-indexed selector among (superclasses ++ methods)</span>
<a name="line-526"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-527"></a><span class='hs-definition'>mkDictSelRhs</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>val_index</span>
<a name="line-528"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>tyvars</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>dict_id</span> <span class='hs-varid'>rhs_body</span><span class='hs-layout'>)</span>
<a name="line-529"></a>  <span class='hs-keyword'>where</span>
<a name="line-530"></a>    <span class='hs-varid'>tycon</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>classTyCon</span> <span class='hs-varid'>clas</span>
<a name="line-531"></a>    <span class='hs-varid'>new_tycon</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNewTyCon</span> <span class='hs-varid'>tycon</span>
<a name="line-532"></a>    <span class='hs-keyglyph'>[</span><span class='hs-varid'>data_con</span><span class='hs-keyglyph'>]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConDataCons</span> <span class='hs-varid'>tycon</span>
<a name="line-533"></a>    <span class='hs-varid'>tyvars</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConUnivTyVars</span> <span class='hs-varid'>data_con</span>
<a name="line-534"></a>    <span class='hs-varid'>arg_tys</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepArgTys</span> <span class='hs-varid'>data_con</span>  <span class='hs-comment'>-- Includes the dictionary superclasses</span>
<a name="line-535"></a>
<a name="line-536"></a>    <span class='hs-varid'>the_arg_id</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getNth</span> <span class='hs-varid'>arg_ids</span> <span class='hs-varid'>val_index</span>
<a name="line-537"></a>    <span class='hs-varid'>pred</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>clas</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTys</span> <span class='hs-varid'>tyvars</span><span class='hs-layout'>)</span>
<a name="line-538"></a>    <span class='hs-varid'>dict_id</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTemplateLocal</span> <span class='hs-num'>1</span> <span class='hs-varid'>pred</span>
<a name="line-539"></a>    <span class='hs-varid'>arg_ids</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTemplateLocalsNum</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>scaledThing</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>)</span>
<a name="line-540"></a>
<a name="line-541"></a>    <span class='hs-varid'>rhs_body</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>new_tycon</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unwrapNewTypeBody</span> <span class='hs-varid'>tycon</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTys</span> <span class='hs-varid'>tyvars</span><span class='hs-layout'>)</span>
<a name="line-542"></a>                                                   <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>dict_id</span><span class='hs-layout'>)</span>
<a name="line-543"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSingleAltCase</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>dict_id</span><span class='hs-layout'>)</span> <span class='hs-varid'>dict_id</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>data_con</span><span class='hs-layout'>)</span>
<a name="line-544"></a>                                           <span class='hs-varid'>arg_ids</span> <span class='hs-layout'>(</span><span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>the_arg_id</span><span class='hs-layout'>)</span>
<a name="line-545"></a>                                <span class='hs-comment'>-- varToCoreExpr needed for equality superclass selectors</span>
<a name="line-546"></a>                                <span class='hs-comment'>--   sel a b d = case x of { MkC _ (g:a~b) _ -&gt; CO g }</span>
<a name="line-547"></a>
<a name="line-548"></a><a name="dictSelRule"></a><span class='hs-definition'>dictSelRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RuleFun</span>
<a name="line-549"></a><span class='hs-comment'>-- Tries to persuade the argument to look like a constructor</span>
<a name="line-550"></a><span class='hs-comment'>-- application, using exprIsConApp_maybe, and then selects</span>
<a name="line-551"></a><span class='hs-comment'>-- from it</span>
<a name="line-552"></a><span class='hs-comment'>--       sel_i t1..tk (D t1..tk op1 ... opm) = opi</span>
<a name="line-553"></a><span class='hs-comment'>--</span>
<a name="line-554"></a><span class='hs-definition'>dictSelRule</span> <span class='hs-varid'>val_index</span> <span class='hs-varid'>n_ty_args</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>id_unf</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>args</span>
<a name="line-555"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>dict_arg</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>drop</span> <span class='hs-varid'>n_ty_args</span> <span class='hs-varid'>args</span>
<a name="line-556"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>con_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>exprIsConApp_maybe</span> <span class='hs-varid'>id_unf</span> <span class='hs-varid'>dict_arg</span>
<a name="line-557"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrapFloats</span> <span class='hs-varid'>floats</span> <span class='hs-varop'>$</span> <span class='hs-varid'>getNth</span> <span class='hs-varid'>con_args</span> <span class='hs-varid'>val_index</span><span class='hs-layout'>)</span>
<a name="line-558"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-559"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-560"></a>
<a name="line-561"></a><span class='hs-comment'>{-
<a name="line-562"></a>************************************************************************
<a name="line-563"></a>*                                                                      *
<a name="line-564"></a>        Data constructors
<a name="line-565"></a>*                                                                      *
<a name="line-566"></a>************************************************************************
<a name="line-567"></a>-}</span>
<a name="line-568"></a>
<a name="line-569"></a><a name="mkDataConWorkId"></a><span class='hs-definition'>mkDataConWorkId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-570"></a><span class='hs-definition'>mkDataConWorkId</span> <span class='hs-varid'>wkr_name</span> <span class='hs-varid'>data_con</span>
<a name="line-571"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNewTyCon</span> <span class='hs-varid'>tycon</span>
<a name="line-572"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkGlobalId</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataConWrapId</span> <span class='hs-varid'>data_con</span><span class='hs-layout'>)</span> <span class='hs-varid'>wkr_name</span> <span class='hs-varid'>wkr_ty</span> <span class='hs-varid'>nt_work_info</span>
<a name="line-573"></a>      <span class='hs-comment'>-- See Note [Newtype workers]</span>
<a name="line-574"></a>
<a name="line-575"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-576"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkGlobalId</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataConWorkId</span> <span class='hs-varid'>data_con</span><span class='hs-layout'>)</span> <span class='hs-varid'>wkr_name</span> <span class='hs-varid'>wkr_ty</span> <span class='hs-varid'>alg_wkr_info</span>
<a name="line-577"></a>
<a name="line-578"></a>  <span class='hs-keyword'>where</span>
<a name="line-579"></a>    <span class='hs-varid'>tycon</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>data_con</span>  <span class='hs-comment'>-- The representation TyCon</span>
<a name="line-580"></a>    <span class='hs-varid'>wkr_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepType</span> <span class='hs-varid'>data_con</span>
<a name="line-581"></a>
<a name="line-582"></a>    <span class='hs-comment'>----------- Workers for data types --------------</span>
<a name="line-583"></a>    <span class='hs-varid'>alg_wkr_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span>
<a name="line-584"></a>                   <span class='hs-varop'>`setArityInfo`</span>          <span class='hs-varid'>wkr_arity</span>
<a name="line-585"></a>                   <span class='hs-varop'>`setCprInfo`</span>            <span class='hs-varid'>mkCprSig</span> <span class='hs-varid'>wkr_arity</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConCPR</span> <span class='hs-varid'>data_con</span><span class='hs-layout'>)</span>
<a name="line-586"></a>                   <span class='hs-varop'>`setInlinePragInfo`</span>     <span class='hs-varid'>wkr_inline_prag</span>
<a name="line-587"></a>                   <span class='hs-varop'>`setUnfoldingInfo`</span>      <span class='hs-varid'>evaldUnfolding</span>  <span class='hs-comment'>-- Record that it's evaluated,</span>
<a name="line-588"></a>                                                           <span class='hs-comment'>-- even if arity = 0</span>
<a name="line-589"></a>                   <span class='hs-varop'>`setLevityInfoWithType`</span> <span class='hs-varid'>wkr_ty</span>
<a name="line-590"></a>                     <span class='hs-comment'>-- NB: unboxed tuples have workers, so we can't use</span>
<a name="line-591"></a>                     <span class='hs-comment'>-- setNeverLevPoly</span>
<a name="line-592"></a>
<a name="line-593"></a>    <span class='hs-varid'>wkr_inline_prag</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>defaultInlinePragma</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inl_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ConLike</span> <span class='hs-layout'>}</span>
<a name="line-594"></a>    <span class='hs-varid'>wkr_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepArity</span> <span class='hs-varid'>data_con</span>
<a name="line-595"></a>    <span class='hs-comment'>----------- Workers for newtypes --------------</span>
<a name="line-596"></a>    <span class='hs-varid'>univ_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConUnivTyVars</span> <span class='hs-varid'>data_con</span>
<a name="line-597"></a>    <span class='hs-varid'>arg_tys</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepArgTys</span>  <span class='hs-varid'>data_con</span>  <span class='hs-comment'>-- Should be same as dataConOrigArgTys</span>
<a name="line-598"></a>    <span class='hs-varid'>nt_work_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span>          <span class='hs-comment'>-- The NoCaf-ness is set by noCafIdInfo</span>
<a name="line-599"></a>                  <span class='hs-varop'>`setArityInfo`</span> <span class='hs-num'>1</span>      <span class='hs-comment'>-- Arity 1</span>
<a name="line-600"></a>                  <span class='hs-varop'>`setInlinePragInfo`</span>     <span class='hs-varid'>dataConWrapperInlinePragma</span>
<a name="line-601"></a>                  <span class='hs-varop'>`setUnfoldingInfo`</span>      <span class='hs-varid'>newtype_unf</span>
<a name="line-602"></a>                  <span class='hs-varop'>`setLevityInfoWithType`</span> <span class='hs-varid'>wkr_ty</span>
<a name="line-603"></a>    <span class='hs-varid'>id_arg1</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkScaledTemplateLocal</span> <span class='hs-num'>1</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>)</span>
<a name="line-604"></a>    <span class='hs-varid'>res_ty_args</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyCoVarTys</span> <span class='hs-varid'>univ_tvs</span>
<a name="line-605"></a>    <span class='hs-varid'>newtype_unf</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>isVanillaDataCon</span> <span class='hs-varid'>data_con</span> <span class='hs-varop'>&amp;&amp;</span>
<a name="line-606"></a>                            <span class='hs-varid'>isSingleton</span> <span class='hs-varid'>arg_tys</span>
<a name="line-607"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>data_con</span>  <span class='hs-layout'>)</span>
<a name="line-608"></a>                              <span class='hs-comment'>-- Note [Newtype datacons]</span>
<a name="line-609"></a>                   <span class='hs-varid'>mkCompulsoryUnfolding</span> <span class='hs-varid'>defaultSimpleOpts</span> <span class='hs-varop'>$</span>
<a name="line-610"></a>                   <span class='hs-varid'>mkLams</span> <span class='hs-varid'>univ_tvs</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>id_arg1</span> <span class='hs-varop'>$</span>
<a name="line-611"></a>                   <span class='hs-varid'>wrapNewTypeBody</span> <span class='hs-varid'>tycon</span> <span class='hs-varid'>res_ty_args</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>id_arg1</span><span class='hs-layout'>)</span>
<a name="line-612"></a>
<a name="line-613"></a><a name="dataConCPR"></a><span class='hs-definition'>dataConCPR</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cpr</span>
<a name="line-614"></a><span class='hs-definition'>dataConCPR</span> <span class='hs-varid'>con</span>
<a name="line-615"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDataTyCon</span> <span class='hs-varid'>tycon</span>     <span class='hs-comment'>-- Real data types only; that is,</span>
<a name="line-616"></a>                          <span class='hs-comment'>-- not unboxed tuples or newtypes</span>
<a name="line-617"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>null</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConExTyCoVars</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- No existentials</span>
<a name="line-618"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>wkr_arity</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span>
<a name="line-619"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>wkr_arity</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>mAX_CPR_SIZE</span>
<a name="line-620"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flatConCpr</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConTag</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span>
<a name="line-621"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-622"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topCpr</span>
<a name="line-623"></a>  <span class='hs-keyword'>where</span>
<a name="line-624"></a>    <span class='hs-varid'>tycon</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>con</span>
<a name="line-625"></a>    <span class='hs-varid'>wkr_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepArity</span> <span class='hs-varid'>con</span>
<a name="line-626"></a>
<a name="line-627"></a>    <span class='hs-varid'>mAX_CPR_SIZE</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Arity</span>
<a name="line-628"></a>    <span class='hs-varid'>mAX_CPR_SIZE</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>10</span>
<a name="line-629"></a>    <span class='hs-comment'>-- We do not treat very big tuples as CPR-ish:</span>
<a name="line-630"></a>    <span class='hs-comment'>--      a) for a start we get into trouble because there aren't</span>
<a name="line-631"></a>    <span class='hs-comment'>--         "enough" unboxed tuple types (a tiresome restriction,</span>
<a name="line-632"></a>    <span class='hs-comment'>--         but hard to fix),</span>
<a name="line-633"></a>    <span class='hs-comment'>--      b) more importantly, big unboxed tuples get returned mainly</span>
<a name="line-634"></a>    <span class='hs-comment'>--         on the stack, and are often then allocated in the heap</span>
<a name="line-635"></a>    <span class='hs-comment'>--         by the caller.  So doing CPR for them may in fact make</span>
<a name="line-636"></a>    <span class='hs-comment'>--         things worse.</span>
<a name="line-637"></a>
<a name="line-638"></a><span class='hs-comment'>{-
<a name="line-639"></a>-------------------------------------------------
<a name="line-640"></a>--         Data constructor representation
<a name="line-641"></a>--
<a name="line-642"></a>-- This is where we decide how to wrap/unwrap the
<a name="line-643"></a>-- constructor fields
<a name="line-644"></a>--
<a name="line-645"></a>--------------------------------------------------
<a name="line-646"></a>-}</span>
<a name="line-647"></a>
<a name="line-648"></a><a name="Unboxer"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Unboxer</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-649"></a>  <span class='hs-comment'>-- Unbox: bind rep vars by decomposing src var</span>
<a name="line-650"></a>
<a name="line-651"></a><a name="Boxer"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Boxer</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnitBox</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Boxer</span> <span class='hs-layout'>(</span><span class='hs-conid'>TCvSubst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-652"></a>  <span class='hs-comment'>-- Box:   build src arg using these rep vars</span>
<a name="line-653"></a>
<a name="line-654"></a><a name="DataConBoxer"></a><span class='hs-comment'>-- | Data Constructor Boxer</span>
<a name="line-655"></a><a name="DataConBoxer"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>DataConBoxer</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DCB</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBind</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-656"></a>                       <span class='hs-comment'>-- Bind these src-level vars, returning the</span>
<a name="line-657"></a>                       <span class='hs-comment'>-- rep-level vars to bind in the pattern</span>
<a name="line-658"></a>
<a name="line-659"></a><a name="vanillaDataConBoxer"></a><span class='hs-definition'>vanillaDataConBoxer</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataConBoxer</span>
<a name="line-660"></a><span class='hs-comment'>-- No transformation on arguments needed</span>
<a name="line-661"></a><span class='hs-definition'>vanillaDataConBoxer</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DCB</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-sel'>_tys</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-662"></a>
<a name="line-663"></a><span class='hs-comment'>{-
<a name="line-664"></a>Note [Inline partially-applied constructor wrappers]
<a name="line-665"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-666"></a>
<a name="line-667"></a>We allow the wrapper to inline when partially applied to avoid
<a name="line-668"></a>boxing values unnecessarily. For example, consider
<a name="line-669"></a>
<a name="line-670"></a>   data Foo a = Foo !Int a
<a name="line-671"></a>
<a name="line-672"></a>   instance Traversable Foo where
<a name="line-673"></a>     traverse f (Foo i a) = Foo i &lt;$&gt; f a
<a name="line-674"></a>
<a name="line-675"></a>This desugars to
<a name="line-676"></a>
<a name="line-677"></a>   traverse f foo = case foo of
<a name="line-678"></a>        Foo i# a -&gt; let i = I# i#
<a name="line-679"></a>                    in map ($WFoo i) (f a)
<a name="line-680"></a>
<a name="line-681"></a>If the wrapper `$WFoo` is not inlined, we get a fruitless reboxing of `i`.
<a name="line-682"></a>But if we inline the wrapper, we get
<a name="line-683"></a>
<a name="line-684"></a>   map (\a. case i of I# i# a -&gt; Foo i# a) (f a)
<a name="line-685"></a>
<a name="line-686"></a>and now case-of-known-constructor eliminates the redundant allocation.
<a name="line-687"></a>
<a name="line-688"></a>-}</span>
<a name="line-689"></a>
<a name="line-690"></a><a name="mkDataConRep"></a><span class='hs-definition'>mkDataConRep</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-691"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-692"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span>
<a name="line-693"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>HsImplBang</span><span class='hs-keyglyph'>]</span>
<a name="line-694"></a>                <span class='hs-comment'>-- See Note [Bangs on imported data constructors]</span>
<a name="line-695"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataCon</span>
<a name="line-696"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-conid'>DataConRep</span>
<a name="line-697"></a><span class='hs-definition'>mkDataConRep</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>wrap_name</span> <span class='hs-varid'>mb_bangs</span> <span class='hs-varid'>data_con</span>
<a name="line-698"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>wrapper_reqd</span>
<a name="line-699"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>NoDataConRep</span>
<a name="line-700"></a>
<a name="line-701"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-702"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wrap_args</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>newLocal</span> <span class='hs-varid'>wrap_arg_tys</span>
<a name="line-703"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wrap_body</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mk_rep_app</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrap_args</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>dropList</span> <span class='hs-varid'>eq_spec</span> <span class='hs-varid'>unboxers</span><span class='hs-layout'>)</span>
<a name="line-704"></a>                                 <span class='hs-varid'>initial_wrap_app</span>
<a name="line-705"></a>
<a name="line-706"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>wrap_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkGlobalId</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataConWrapId</span> <span class='hs-varid'>data_con</span><span class='hs-layout'>)</span> <span class='hs-varid'>wrap_name</span> <span class='hs-varid'>wrap_ty</span> <span class='hs-varid'>wrap_info</span>
<a name="line-707"></a>             <span class='hs-varid'>wrap_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span>
<a name="line-708"></a>                         <span class='hs-varop'>`setArityInfo`</span>         <span class='hs-varid'>wrap_arity</span>
<a name="line-709"></a>                             <span class='hs-comment'>-- It's important to specify the arity, so that partial</span>
<a name="line-710"></a>                             <span class='hs-comment'>-- applications are treated as values</span>
<a name="line-711"></a>                         <span class='hs-varop'>`setInlinePragInfo`</span>    <span class='hs-varid'>wrap_prag</span>
<a name="line-712"></a>                         <span class='hs-varop'>`setUnfoldingInfo`</span>     <span class='hs-varid'>wrap_unf</span>
<a name="line-713"></a>                         <span class='hs-varop'>`setStrictnessInfo`</span>    <span class='hs-varid'>wrap_sig</span>
<a name="line-714"></a>                         <span class='hs-varop'>`setCprInfo`</span>           <span class='hs-varid'>mkCprSig</span> <span class='hs-varid'>wrap_arity</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConCPR</span> <span class='hs-varid'>data_con</span><span class='hs-layout'>)</span>
<a name="line-715"></a>                             <span class='hs-comment'>-- We need to get the CAF info right here because GHC.Iface.Tidy</span>
<a name="line-716"></a>                             <span class='hs-comment'>-- does not tidy the IdInfo of implicit bindings (like the wrapper)</span>
<a name="line-717"></a>                             <span class='hs-comment'>-- so it not make sure that the CAF info is sane</span>
<a name="line-718"></a>                         <span class='hs-varop'>`setLevityInfoWithType`</span> <span class='hs-varid'>wrap_ty</span>
<a name="line-719"></a>
<a name="line-720"></a>             <span class='hs-varid'>wrap_sig</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClosedStrictSig</span> <span class='hs-varid'>wrap_arg_dmds</span> <span class='hs-varid'>topDiv</span>
<a name="line-721"></a>
<a name="line-722"></a>             <span class='hs-varid'>wrap_arg_dmds</span> <span class='hs-keyglyph'>=</span>
<a name="line-723"></a>               <span class='hs-varid'>replicate</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span> <span class='hs-varid'>topDmd</span> <span class='hs-varop'>++</span> <span class='hs-varid'>map</span> <span class='hs-varid'>mk_dmd</span> <span class='hs-varid'>arg_ibangs</span>
<a name="line-724"></a>               <span class='hs-comment'>-- Don't forget the dictionary arguments when building</span>
<a name="line-725"></a>               <span class='hs-comment'>-- the strictness signature (#14290).</span>
<a name="line-726"></a>
<a name="line-727"></a>             <span class='hs-varid'>mk_dmd</span> <span class='hs-varid'>str</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isBanged</span> <span class='hs-varid'>str</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evalDmd</span>
<a name="line-728"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topDmd</span>
<a name="line-729"></a>
<a name="line-730"></a>             <span class='hs-varid'>wrap_prag</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConWrapperInlinePragma</span>
<a name="line-731"></a>                         <span class='hs-varop'>`setInlinePragmaActivation`</span> <span class='hs-varid'>activateDuringFinal</span>
<a name="line-732"></a>                         <span class='hs-comment'>-- See Note [Activation for data constructor wrappers]</span>
<a name="line-733"></a>
<a name="line-734"></a>             <span class='hs-comment'>-- The wrapper will usually be inlined (see wrap_unf), so its</span>
<a name="line-735"></a>             <span class='hs-comment'>-- strictness and CPR info is usually irrelevant. But this is</span>
<a name="line-736"></a>             <span class='hs-comment'>-- not always the case; GHC may choose not to inline it. In</span>
<a name="line-737"></a>             <span class='hs-comment'>-- particular, the wrapper constructor is not inlined inside</span>
<a name="line-738"></a>             <span class='hs-comment'>-- an INLINE rhs or when it is not applied to any arguments.</span>
<a name="line-739"></a>             <span class='hs-comment'>-- See Note [Inline partially-applied constructor wrappers]</span>
<a name="line-740"></a>             <span class='hs-comment'>-- Passing Nothing here allows the wrapper to inline when</span>
<a name="line-741"></a>             <span class='hs-comment'>-- unsaturated.</span>
<a name="line-742"></a>             <span class='hs-varid'>wrap_unf</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNewTyCon</span> <span class='hs-varid'>tycon</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCompulsoryUnfolding</span> <span class='hs-varid'>defaultSimpleOpts</span> <span class='hs-varid'>wrap_rhs</span>
<a name="line-743"></a>                        <span class='hs-comment'>-- See Note [Compulsory newtype unfolding]</span>
<a name="line-744"></a>                      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInlineUnfolding</span> <span class='hs-varid'>defaultSimpleOpts</span> <span class='hs-varid'>wrap_rhs</span>
<a name="line-745"></a>             <span class='hs-varid'>wrap_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>wrap_tvs</span> <span class='hs-varop'>$</span>
<a name="line-746"></a>                        <span class='hs-varid'>mkLams</span> <span class='hs-varid'>wrap_args</span> <span class='hs-varop'>$</span>
<a name="line-747"></a>                        <span class='hs-varid'>wrapFamInstBody</span> <span class='hs-varid'>tycon</span> <span class='hs-varid'>res_ty_args</span> <span class='hs-varop'>$</span>
<a name="line-748"></a>                        <span class='hs-varid'>wrap_body</span>
<a name="line-749"></a>
<a name="line-750"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>DCR</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dcr_wrap_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wrap_id</span>
<a name="line-751"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>dcr_boxer</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_boxer</span> <span class='hs-varid'>boxers</span>
<a name="line-752"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>dcr_arg_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rep_tys</span>
<a name="line-753"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>dcr_stricts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rep_strs</span>
<a name="line-754"></a>                       <span class='hs-comment'>-- For newtypes, dcr_bangs is always [HsLazy].</span>
<a name="line-755"></a>                       <span class='hs-comment'>-- See Note [HsImplBangs for newtypes].</span>
<a name="line-756"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>dcr_bangs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_ibangs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-757"></a>
<a name="line-758"></a>  <span class='hs-keyword'>where</span>
<a name="line-759"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>univ_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ex_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>eq_spec</span><span class='hs-layout'>,</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>orig_arg_tys</span><span class='hs-layout'>,</span> <span class='hs-sel'>_orig_res_ty</span><span class='hs-layout'>)</span>
<a name="line-760"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConFullSig</span> <span class='hs-varid'>data_con</span>
<a name="line-761"></a>    <span class='hs-varid'>wrap_tvs</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConUserTyVars</span> <span class='hs-varid'>data_con</span>
<a name="line-762"></a>    <span class='hs-varid'>res_ty_args</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTyVars</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTvSubstPrs</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>eqSpecPair</span> <span class='hs-varid'>eq_spec</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>univ_tvs</span>
<a name="line-763"></a>
<a name="line-764"></a>    <span class='hs-varid'>tycon</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>data_con</span>       <span class='hs-comment'>-- The representation TyCon (not family)</span>
<a name="line-765"></a>    <span class='hs-varid'>wrap_ty</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConWrapperType</span> <span class='hs-varid'>data_con</span>
<a name="line-766"></a>    <span class='hs-varid'>ev_tys</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqSpecPreds</span> <span class='hs-varid'>eq_spec</span> <span class='hs-varop'>++</span> <span class='hs-varid'>theta</span>
<a name="line-767"></a>    <span class='hs-varid'>all_arg_tys</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>unrestricted</span> <span class='hs-varid'>ev_tys</span> <span class='hs-varop'>++</span> <span class='hs-varid'>orig_arg_tys</span>
<a name="line-768"></a>    <span class='hs-varid'>ev_ibangs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>HsLazy</span><span class='hs-layout'>)</span> <span class='hs-varid'>ev_tys</span>
<a name="line-769"></a>    <span class='hs-varid'>orig_bangs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConSrcBangs</span> <span class='hs-varid'>data_con</span>
<a name="line-770"></a>
<a name="line-771"></a>    <span class='hs-varid'>wrap_arg_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>unrestricted</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-varid'>orig_arg_tys</span>
<a name="line-772"></a>    <span class='hs-varid'>wrap_arity</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>count</span> <span class='hs-varid'>isCoVar</span> <span class='hs-varid'>ex_tvs</span> <span class='hs-varop'>+</span> <span class='hs-varid'>length</span> <span class='hs-varid'>wrap_arg_tys</span>
<a name="line-773"></a>             <span class='hs-comment'>-- The wrap_args are the arguments *other than* the eq_spec</span>
<a name="line-774"></a>             <span class='hs-comment'>-- Because we are going to apply the eq_spec args manually in the</span>
<a name="line-775"></a>             <span class='hs-comment'>-- wrapper</span>
<a name="line-776"></a>
<a name="line-777"></a>    <span class='hs-varid'>new_tycon</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNewTyCon</span> <span class='hs-varid'>tycon</span>
<a name="line-778"></a>    <span class='hs-varid'>arg_ibangs</span>
<a name="line-779"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>new_tycon</span>
<a name="line-780"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>HsLazy</span><span class='hs-layout'>)</span> <span class='hs-varid'>orig_arg_tys</span> <span class='hs-comment'>-- See Note [HsImplBangs for newtypes]</span>
<a name="line-781"></a>                                        <span class='hs-comment'>-- orig_arg_tys should be a singleton, but</span>
<a name="line-782"></a>                                        <span class='hs-comment'>-- if a user declared a wrong newtype we</span>
<a name="line-783"></a>                                        <span class='hs-comment'>-- detect this later (see test T2334A)</span>
<a name="line-784"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-785"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_bangs</span> <span class='hs-keyword'>of</span>
<a name="line-786"></a>          <span class='hs-conid'>Nothing</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConSrcToImplBang</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span><span class='hs-layout'>)</span>
<a name="line-787"></a>                                <span class='hs-varid'>orig_arg_tys</span> <span class='hs-varid'>orig_bangs</span>
<a name="line-788"></a>          <span class='hs-conid'>Just</span> <span class='hs-varid'>bangs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>bangs</span>
<a name="line-789"></a>
<a name="line-790"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>rep_tys_w_strs</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrappers</span><span class='hs-layout'>)</span>
<a name="line-791"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipWith</span> <span class='hs-varid'>dataConArgRep</span> <span class='hs-varid'>all_arg_tys</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev_ibangs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>arg_ibangs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-792"></a>
<a name="line-793"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>unboxers</span><span class='hs-layout'>,</span> <span class='hs-varid'>boxers</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip</span> <span class='hs-varid'>wrappers</span>
<a name="line-794"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>rep_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>rep_strs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip</span> <span class='hs-layout'>(</span><span class='hs-varid'>concat</span> <span class='hs-varid'>rep_tys_w_strs</span><span class='hs-layout'>)</span>
<a name="line-795"></a>
<a name="line-796"></a>    <span class='hs-varid'>wrapper_reqd</span> <span class='hs-keyglyph'>=</span>
<a name="line-797"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>new_tycon</span>
<a name="line-798"></a>                     <span class='hs-comment'>-- (Most) newtypes have only a worker, with the exception</span>
<a name="line-799"></a>                     <span class='hs-comment'>-- of some newtypes written with GADT syntax. See below.</span>
<a name="line-800"></a>         <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>any</span> <span class='hs-varid'>isBanged</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev_ibangs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>arg_ibangs</span><span class='hs-layout'>)</span>
<a name="line-801"></a>                     <span class='hs-comment'>-- Some forcing/unboxing (includes eq_spec)</span>
<a name="line-802"></a>             <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>$</span> <span class='hs-varid'>null</span> <span class='hs-varid'>eq_spec</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- GADT</span>
<a name="line-803"></a>      <span class='hs-varop'>||</span> <span class='hs-varid'>isFamInstTyCon</span> <span class='hs-varid'>tycon</span> <span class='hs-comment'>-- Cast result</span>
<a name="line-804"></a>      <span class='hs-varop'>||</span> <span class='hs-varid'>dataConUserTyVarsArePermuted</span> <span class='hs-varid'>data_con</span>
<a name="line-805"></a>                     <span class='hs-comment'>-- If the data type was written with GADT syntax and</span>
<a name="line-806"></a>                     <span class='hs-comment'>-- orders the type variables differently from what the</span>
<a name="line-807"></a>                     <span class='hs-comment'>-- worker expects, it needs a data con wrapper to reorder</span>
<a name="line-808"></a>                     <span class='hs-comment'>-- the type variables.</span>
<a name="line-809"></a>                     <span class='hs-comment'>-- See Note [Data con wrappers and GADT syntax].</span>
<a name="line-810"></a>
<a name="line-811"></a>    <span class='hs-varid'>initial_wrap_app</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConWorkId</span> <span class='hs-varid'>data_con</span><span class='hs-layout'>)</span>
<a name="line-812"></a>                       <span class='hs-varop'>`mkTyApps`</span>  <span class='hs-varid'>res_ty_args</span>
<a name="line-813"></a>                       <span class='hs-varop'>`mkVarApps`</span> <span class='hs-varid'>ex_tvs</span>
<a name="line-814"></a>                       <span class='hs-varop'>`mkCoApps`</span>  <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkReflCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-varop'>.</span> <span class='hs-varid'>eqSpecType</span><span class='hs-layout'>)</span> <span class='hs-varid'>eq_spec</span>
<a name="line-815"></a>
<a name="line-816"></a>    <span class='hs-varid'>mk_boxer</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Boxer</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataConBoxer</span>
<a name="line-817"></a>    <span class='hs-varid'>mk_boxer</span> <span class='hs-varid'>boxers</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DCB</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>ty_args</span> <span class='hs-varid'>src_vars</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-818"></a>                      <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>ex_vars</span><span class='hs-layout'>,</span> <span class='hs-varid'>term_vars</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitAtList</span> <span class='hs-varid'>ex_tvs</span> <span class='hs-varid'>src_vars</span>
<a name="line-819"></a>                               <span class='hs-varid'>subst1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipTvSubst</span> <span class='hs-varid'>univ_tvs</span> <span class='hs-varid'>ty_args</span>
<a name="line-820"></a>                               <span class='hs-varid'>subst2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendTCvSubstList</span> <span class='hs-varid'>subst1</span> <span class='hs-varid'>ex_tvs</span>
<a name="line-821"></a>                                                           <span class='hs-layout'>(</span><span class='hs-varid'>mkTyCoVarTys</span> <span class='hs-varid'>ex_vars</span><span class='hs-layout'>)</span>
<a name="line-822"></a>                         <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>subst2</span> <span class='hs-varid'>boxers</span> <span class='hs-varid'>term_vars</span>
<a name="line-823"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ex_vars</span> <span class='hs-varop'>++</span> <span class='hs-varid'>rep_ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>)</span>
<a name="line-824"></a>
<a name="line-825"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>src_vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>null</span> <span class='hs-varid'>src_vars</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>data_con</span> <span class='hs-layout'>)</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-826"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>UnitBox</span> <span class='hs-conop'>:</span> <span class='hs-varid'>boxers</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>src_var</span> <span class='hs-conop'>:</span> <span class='hs-varid'>src_vars</span><span class='hs-layout'>)</span>
<a name="line-827"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_ids2</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>boxers</span> <span class='hs-varid'>src_vars</span>
<a name="line-828"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>src_var</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rep_ids2</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-829"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>Boxer</span> <span class='hs-varid'>boxer</span> <span class='hs-conop'>:</span> <span class='hs-varid'>boxers</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>src_var</span> <span class='hs-conop'>:</span> <span class='hs-varid'>src_vars</span><span class='hs-layout'>)</span>
<a name="line-830"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_ids1</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>boxer</span> <span class='hs-varid'>subst</span>
<a name="line-831"></a>           <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_ids2</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>boxers</span> <span class='hs-varid'>src_vars</span>
<a name="line-832"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_ids1</span> <span class='hs-varop'>++</span> <span class='hs-varid'>rep_ids2</span><span class='hs-layout'>,</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>src_var</span> <span class='hs-varid'>arg</span> <span class='hs-conop'>:</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-833"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"mk_boxer"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>data_con</span><span class='hs-layout'>)</span>
<a name="line-834"></a>
<a name="line-835"></a>    <span class='hs-varid'>mk_rep_app</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>Unboxer</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-836"></a>    <span class='hs-varid'>mk_rep_app</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>con_app</span>
<a name="line-837"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>con_app</span>
<a name="line-838"></a>    <span class='hs-varid'>mk_rep_app</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>wrap_arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>unboxer</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>prs</span><span class='hs-layout'>)</span> <span class='hs-varid'>con_app</span>
<a name="line-839"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>unbox_fn</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unboxer</span> <span class='hs-varid'>wrap_arg</span>
<a name="line-840"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>expr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mk_rep_app</span> <span class='hs-varid'>prs</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkVarApps</span> <span class='hs-varid'>con_app</span> <span class='hs-varid'>rep_ids</span><span class='hs-layout'>)</span>
<a name="line-841"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>unbox_fn</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-842"></a>
<a name="line-843"></a>
<a name="line-844"></a><a name="dataConWrapperInlinePragma"></a><span class='hs-definition'>dataConWrapperInlinePragma</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InlinePragma</span>
<a name="line-845"></a><span class='hs-comment'>-- See Note [DataCon wrappers are conlike]</span>
<a name="line-846"></a><span class='hs-definition'>dataConWrapperInlinePragma</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alwaysInlinePragma</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inl_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ConLike</span>
<a name="line-847"></a>                                                <span class='hs-layout'>,</span> <span class='hs-varid'>inl_inline</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Inline</span> <span class='hs-layout'>}</span>
<a name="line-848"></a>
<a name="line-849"></a><span class='hs-comment'>{- Note [Activation for data constructor wrappers]
<a name="line-850"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-851"></a>The Activation on a data constructor wrapper allows it to inline only in Phase
<a name="line-852"></a>0. This way rules have a chance to fire if they mention a data constructor on
<a name="line-853"></a>the left
<a name="line-854"></a>   RULE "foo"  f (K a b) = ...
<a name="line-855"></a>Since the LHS of rules are simplified with InitialPhase, we won't
<a name="line-856"></a>inline the wrapper on the LHS either.
<a name="line-857"></a>
<a name="line-858"></a>On the other hand, this means that exprIsConApp_maybe must be able to deal
<a name="line-859"></a>with wrappers so that case-of-constructor is not delayed; see
<a name="line-860"></a>Note [exprIsConApp_maybe on data constructors with wrappers] for details.
<a name="line-861"></a>
<a name="line-862"></a>It used to activate in phases 2 (afterInitial) and later, but it makes it
<a name="line-863"></a>awkward to write a RULE[1] with a constructor on the left: it would work if a
<a name="line-864"></a>constructor has no wrapper, but whether a constructor has a wrapper depends, for
<a name="line-865"></a>instance, on the order of type argument of that constructors. Therefore changing
<a name="line-866"></a>the order of type argument could make previously working RULEs fail.
<a name="line-867"></a>
<a name="line-868"></a>See also https://gitlab.haskell.org/ghc/ghc/issues/15840 .
<a name="line-869"></a>
<a name="line-870"></a>Note [DataCon wrappers are conlike]
<a name="line-871"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-872"></a>DataCon workers are clearly ConLike --- they are the Con in
<a name="line-873"></a>ConLike, after all --- but what about DataCon wrappers? Should they
<a name="line-874"></a>be marked ConLike, too?
<a name="line-875"></a>
<a name="line-876"></a>Yes, absolutely! As described in Note [CONLIKE pragma] in
<a name="line-877"></a>GHC.Types.Basic, isConLike influences GHC.Core.Utils.exprIsExpandable,
<a name="line-878"></a>which is used by both RULE matching and the case-of-known-constructor
<a name="line-879"></a>optimization. Its crucial that both of those things can see
<a name="line-880"></a>applications of DataCon wrappers:
<a name="line-881"></a>
<a name="line-882"></a>  * User-defined RULEs match on wrappers, not workers, so we might
<a name="line-883"></a>    need to look through an unfolding built from a DataCon wrapper to
<a name="line-884"></a>    determine if a RULE matches.
<a name="line-885"></a>
<a name="line-886"></a>  * Likewise, if we have something like
<a name="line-887"></a>        let x = $WC a b in ... case x of { C y z -&gt; e } ...
<a name="line-888"></a>    we still want to apply case-of-known-constructor.
<a name="line-889"></a>
<a name="line-890"></a>Therefore, its important that we consider DataCon wrappers conlike.
<a name="line-891"></a>This is especially true now that we dont inline DataCon wrappers
<a name="line-892"></a>until the final simplifier phase; see Note [Activation for data
<a name="line-893"></a>constructor wrappers].
<a name="line-894"></a>
<a name="line-895"></a>For further reading, see:
<a name="line-896"></a>  * Note [Conlike is interesting] in GHC.Core.Op.Simplify.Utils
<a name="line-897"></a>  * Note [Lone variables] in GHC.Core.Unfold
<a name="line-898"></a>  * Note [exprIsConApp_maybe on data constructors with wrappers]
<a name="line-899"></a>    in GHC.Core.SimpleOpt
<a name="line-900"></a>  * #18012
<a name="line-901"></a>
<a name="line-902"></a>Note [Bangs on imported data constructors]
<a name="line-903"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-904"></a>
<a name="line-905"></a>We pass Maybe [HsImplBang] to mkDataConRep to make use of HsImplBangs
<a name="line-906"></a>from imported modules.
<a name="line-907"></a>
<a name="line-908"></a>- Nothing &lt;=&gt; use HsSrcBangs
<a name="line-909"></a>- Just bangs &lt;=&gt; use HsImplBangs
<a name="line-910"></a>
<a name="line-911"></a>For imported types we can't work it all out from the HsSrcBangs,
<a name="line-912"></a>because we want to be very sure to follow what the original module
<a name="line-913"></a>(where the data type was declared) decided, and that depends on what
<a name="line-914"></a>flags were enabled when it was compiled. So we record the decisions in
<a name="line-915"></a>the interface file.
<a name="line-916"></a>
<a name="line-917"></a>The HsImplBangs passed are in 1-1 correspondence with the
<a name="line-918"></a>dataConOrigArgTys of the DataCon.
<a name="line-919"></a>
<a name="line-920"></a>Note [Data con wrappers and unlifted types]
<a name="line-921"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-922"></a>Consider
<a name="line-923"></a>   data T = MkT !Int#
<a name="line-924"></a>
<a name="line-925"></a>We certainly do not want to make a wrapper
<a name="line-926"></a>   $WMkT x = case x of y { DEFAULT -&gt; MkT y }
<a name="line-927"></a>
<a name="line-928"></a>For a start, it's still to generate a no-op.  But worse, since wrappers
<a name="line-929"></a>are currently injected at TidyCore, we don't even optimise it away!
<a name="line-930"></a>So the stupid case expression stays there.  This actually happened for
<a name="line-931"></a>the Integer data type (see #1600 comment:66)!
<a name="line-932"></a>
<a name="line-933"></a>Note [Data con wrappers and GADT syntax]
<a name="line-934"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-935"></a>Consider these two very similar data types:
<a name="line-936"></a>
<a name="line-937"></a>  data T1 a b = MkT1 b
<a name="line-938"></a>
<a name="line-939"></a>  data T2 a b where
<a name="line-940"></a>    MkT2 :: forall b a. b -&gt; T2 a b
<a name="line-941"></a>
<a name="line-942"></a>Despite their similar appearance, T2 will have a data con wrapper but T1 will
<a name="line-943"></a>not. What sets them apart? The types of their constructors, which are:
<a name="line-944"></a>
<a name="line-945"></a>  MkT1 :: forall a b. b -&gt; T1 a b
<a name="line-946"></a>  MkT2 :: forall b a. b -&gt; T2 a b
<a name="line-947"></a>
<a name="line-948"></a>MkT2's use of GADT syntax allows it to permute the order in which `a` and `b`
<a name="line-949"></a>would normally appear. See Note [DataCon user type variable binders] in GHC.Core.DataCon
<a name="line-950"></a>for further discussion on this topic.
<a name="line-951"></a>
<a name="line-952"></a>The worker data cons for T1 and T2, however, both have types such that `a` is
<a name="line-953"></a>expected to come before `b` as arguments. Because MkT2 permutes this order, it
<a name="line-954"></a>needs a data con wrapper to swizzle around the type variables to be in the
<a name="line-955"></a>order the worker expects.
<a name="line-956"></a>
<a name="line-957"></a>A somewhat surprising consequence of this is that *newtypes* can have data con
<a name="line-958"></a>wrappers! After all, a newtype can also be written with GADT syntax:
<a name="line-959"></a>
<a name="line-960"></a>  newtype T3 a b where
<a name="line-961"></a>    MkT3 :: forall b a. b -&gt; T3 a b
<a name="line-962"></a>
<a name="line-963"></a>Again, this needs a wrapper data con to reorder the type variables. It does
<a name="line-964"></a>mean that this newtype constructor requires another level of indirection when
<a name="line-965"></a>being called, but the inliner should make swift work of that.
<a name="line-966"></a>
<a name="line-967"></a>Note [HsImplBangs for newtypes]
<a name="line-968"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-969"></a>Most of the time, we use the dataConSrctoImplBang function to decide what
<a name="line-970"></a>strictness/unpackedness to use for the fields of a data type constructor. But
<a name="line-971"></a>there is an exception to this rule: newtype constructors. You might not think
<a name="line-972"></a>that newtypes would pose a challenge, since newtypes are seemingly forbidden
<a name="line-973"></a>from having strictness annotations in the first place. But consider this
<a name="line-974"></a>(from #16141):
<a name="line-975"></a>
<a name="line-976"></a>  {-# LANGUAGE StrictData #-}
<a name="line-977"></a>  {-# OPTIONS_GHC -O #-}
<a name="line-978"></a>  newtype T a b where
<a name="line-979"></a>    MkT :: forall b a. Int -&gt; T a b
<a name="line-980"></a>
<a name="line-981"></a>Because StrictData (plus optimization) is enabled, invoking
<a name="line-982"></a>dataConSrcToImplBang would sneak in and unpack the field of type Int to Int#!
<a name="line-983"></a>This would be disastrous, since the wrapper for `MkT` uses a coercion involving
<a name="line-984"></a>Int, not Int#.
<a name="line-985"></a>
<a name="line-986"></a>Bottom line: dataConSrcToImplBang should never be invoked for newtypes. In the
<a name="line-987"></a>case of a newtype constructor, we simply hardcode its dcr_bangs field to
<a name="line-988"></a>[HsLazy].
<a name="line-989"></a>-}</span>
<a name="line-990"></a>
<a name="line-991"></a><a name="newLocal"></a><span class='hs-comment'>-------------------------</span>
<a name="line-992"></a><span class='hs-definition'>newLocal</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-conid'>Var</span>
<a name="line-993"></a><span class='hs-definition'>newLocal</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>w</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uniq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-994"></a>                            <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSysLocalOrCoVar</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"dt"</span><span class='hs-layout'>)</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>w</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-995"></a>                 <span class='hs-comment'>-- We should not have "OrCoVar" here, this is a bug (#17545)</span>
<a name="line-996"></a>
<a name="line-997"></a>
<a name="line-998"></a><a name="dataConSrcToImplBang"></a><span class='hs-comment'>-- | Unpack/Strictness decisions from source module.</span>
<a name="line-999"></a><span class='hs-comment'>--</span>
<a name="line-1000"></a><span class='hs-comment'>-- This function should only ever be invoked for data constructor fields, and</span>
<a name="line-1001"></a><span class='hs-comment'>-- never on the field of a newtype constructor.</span>
<a name="line-1002"></a><span class='hs-comment'>-- See @Note [HsImplBangs for newtypes]@.</span>
<a name="line-1003"></a><span class='hs-definition'>dataConSrcToImplBang</span>
<a name="line-1004"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span>
<a name="line-1005"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-1006"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span>
<a name="line-1007"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HsSrcBang</span>
<a name="line-1008"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HsImplBang</span>
<a name="line-1009"></a>
<a name="line-1010"></a><span class='hs-definition'>dataConSrcToImplBang</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>arg_ty</span>
<a name="line-1011"></a>                     <span class='hs-layout'>(</span><span class='hs-conid'>HsSrcBang</span> <span class='hs-varid'>ann</span> <span class='hs-varid'>unpk</span> <span class='hs-conid'>NoSrcStrict</span><span class='hs-layout'>)</span>
<a name="line-1012"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.StrictData</span> <span class='hs-varid'>dflags</span> <span class='hs-comment'>-- StrictData =&gt; strict field</span>
<a name="line-1013"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConSrcToImplBang</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>arg_ty</span>
<a name="line-1014"></a>                  <span class='hs-layout'>(</span><span class='hs-conid'>HsSrcBang</span> <span class='hs-varid'>ann</span> <span class='hs-varid'>unpk</span> <span class='hs-conid'>SrcStrict</span><span class='hs-layout'>)</span>
<a name="line-1015"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-comment'>-- no StrictData =&gt; lazy field</span>
<a name="line-1016"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsLazy</span>
<a name="line-1017"></a>
<a name="line-1018"></a><span class='hs-definition'>dataConSrcToImplBang</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsSrcBang</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>SrcLazy</span><span class='hs-layout'>)</span>
<a name="line-1019"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsLazy</span>
<a name="line-1020"></a>
<a name="line-1021"></a><span class='hs-definition'>dataConSrcToImplBang</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>arg_ty</span>
<a name="line-1022"></a>                     <span class='hs-layout'>(</span><span class='hs-conid'>HsSrcBang</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>unpk_prag</span> <span class='hs-conid'>SrcStrict</span><span class='hs-layout'>)</span>
<a name="line-1023"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isUnliftedType</span> <span class='hs-layout'>(</span><span class='hs-varid'>scaledThing</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-1024"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsLazy</span>  <span class='hs-comment'>-- For !Int#, say, use HsLazy</span>
<a name="line-1025"></a>            <span class='hs-comment'>-- See Note [Data con wrappers and unlifted types]</span>
<a name="line-1026"></a>
<a name="line-1027"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_OmitInterfacePragmas</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Don't unpack if -fomit-iface-pragmas</span>
<a name="line-1028"></a>          <span class='hs-comment'>-- Don't unpack if we aren't optimising; rather arbitrarily,</span>
<a name="line-1029"></a>          <span class='hs-comment'>-- we use -fomit-iface-pragmas as the indication</span>
<a name="line-1030"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>mb_co</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topNormaliseType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-varid'>scaledThing</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-1031"></a>                     <span class='hs-comment'>-- Unwrap type families and newtypes</span>
<a name="line-1032"></a>        <span class='hs-varid'>arg_ty'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_co</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>scaledSet</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varid'>ty</span><span class='hs-layout'>;</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>arg_ty</span> <span class='hs-layout'>}</span>
<a name="line-1033"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isUnpackableType</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-varid'>scaledThing</span> <span class='hs-varid'>arg_ty'</span><span class='hs-layout'>)</span>
<a name="line-1034"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_tys</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dataConArgUnpack</span> <span class='hs-varid'>arg_ty'</span>
<a name="line-1035"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>unpk_prag</span> <span class='hs-keyword'>of</span>
<a name="line-1036"></a>      <span class='hs-conid'>NoSrcUnpack</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1037"></a>        <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_UnboxStrictFields</span> <span class='hs-varid'>dflags</span>
<a name="line-1038"></a>            <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_UnboxSmallStrictFields</span> <span class='hs-varid'>dflags</span>
<a name="line-1039"></a>                <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>rep_tys</span> <span class='hs-varop'>`lengthAtMost`</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- See Note [Unpack one-wide fields]</span>
<a name="line-1040"></a>      <span class='hs-varid'>srcUnpack</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>isSrcUnpacked</span> <span class='hs-varid'>srcUnpack</span>
<a name="line-1041"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_co</span> <span class='hs-keyword'>of</span>
<a name="line-1042"></a>      <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HsUnpack</span> <span class='hs-conid'>Nothing</span>
<a name="line-1043"></a>      <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HsUnpack</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1044"></a>
<a name="line-1045"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-comment'>-- Record the strict-but-no-unpack decision</span>
<a name="line-1046"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsStrict</span>
<a name="line-1047"></a>
<a name="line-1048"></a>
<a name="line-1049"></a><a name="dataConArgRep"></a><span class='hs-comment'>-- | Wrappers/Workers and representation following Unpack/Strictness</span>
<a name="line-1050"></a><span class='hs-comment'>-- decisions</span>
<a name="line-1051"></a><span class='hs-definition'>dataConArgRep</span>
<a name="line-1052"></a>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span>
<a name="line-1053"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HsImplBang</span>
<a name="line-1054"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span><span class='hs-layout'>,</span><span class='hs-conid'>StrictnessMark</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- Rep types</span>
<a name="line-1055"></a>     <span class='hs-layout'>,</span><span class='hs-layout'>(</span><span class='hs-conid'>Unboxer</span><span class='hs-layout'>,</span><span class='hs-conid'>Boxer</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1056"></a>
<a name="line-1057"></a><span class='hs-definition'>dataConArgRep</span> <span class='hs-varid'>arg_ty</span> <span class='hs-conid'>HsLazy</span>
<a name="line-1058"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>NotMarkedStrict</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitUnboxer</span><span class='hs-layout'>,</span> <span class='hs-varid'>unitBoxer</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1059"></a>
<a name="line-1060"></a><span class='hs-definition'>dataConArgRep</span> <span class='hs-varid'>arg_ty</span> <span class='hs-conid'>HsStrict</span>
<a name="line-1061"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>MarkedStrict</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>seqUnboxer</span><span class='hs-layout'>,</span> <span class='hs-varid'>unitBoxer</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1062"></a>
<a name="line-1063"></a><span class='hs-definition'>dataConArgRep</span> <span class='hs-varid'>arg_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsUnpack</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span>
<a name="line-1064"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrappers</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dataConArgUnpack</span> <span class='hs-varid'>arg_ty</span>
<a name="line-1065"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrappers</span><span class='hs-layout'>)</span>
<a name="line-1066"></a>
<a name="line-1067"></a><span class='hs-definition'>dataConArgRep</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>w</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsUnpack</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1068"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co_rep_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionRKind</span> <span class='hs-varid'>co</span>
<a name="line-1069"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrappers</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>dataConArgUnpack</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>w</span> <span class='hs-varid'>co_rep_ty</span><span class='hs-layout'>)</span>
<a name="line-1070"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrapCo</span> <span class='hs-varid'>co</span> <span class='hs-varid'>co_rep_ty</span> <span class='hs-varid'>wrappers</span><span class='hs-layout'>)</span>
<a name="line-1071"></a>
<a name="line-1072"></a>
<a name="line-1073"></a><a name="wrapCo"></a><span class='hs-comment'>-------------------------</span>
<a name="line-1074"></a><span class='hs-definition'>wrapCo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Unboxer</span><span class='hs-layout'>,</span> <span class='hs-conid'>Boxer</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Unboxer</span><span class='hs-layout'>,</span> <span class='hs-conid'>Boxer</span><span class='hs-layout'>)</span>
<a name="line-1075"></a><span class='hs-definition'>wrapCo</span> <span class='hs-varid'>co</span> <span class='hs-varid'>rep_ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>unbox_rep</span><span class='hs-layout'>,</span> <span class='hs-varid'>box_rep</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- co :: arg_ty ~ rep_ty</span>
<a name="line-1076"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>unboxer</span><span class='hs-layout'>,</span> <span class='hs-varid'>boxer</span><span class='hs-layout'>)</span>
<a name="line-1077"></a>  <span class='hs-keyword'>where</span>
<a name="line-1078"></a>    <span class='hs-varid'>unboxer</span> <span class='hs-varid'>arg_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rep_id</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newLocal</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-layout'>(</span><span class='hs-varid'>idMult</span> <span class='hs-varid'>arg_id</span><span class='hs-layout'>)</span> <span class='hs-varid'>rep_ty</span><span class='hs-layout'>)</span>
<a name="line-1079"></a>                        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>rep_fn</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unbox_rep</span> <span class='hs-varid'>rep_id</span>
<a name="line-1080"></a>                        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co_bind</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>rep_id</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>arg_id</span> <span class='hs-varop'>`Cast`</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1081"></a>                        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_ids</span><span class='hs-layout'>,</span> <span class='hs-conid'>Let</span> <span class='hs-varid'>co_bind</span> <span class='hs-varop'>.</span> <span class='hs-varid'>rep_fn</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1082"></a>    <span class='hs-varid'>boxer</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Boxer</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>subst</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1083"></a>            <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>rep_expr</span><span class='hs-layout'>)</span>
<a name="line-1084"></a>                    <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>box_rep</span> <span class='hs-keyword'>of</span>
<a name="line-1085"></a>                         <span class='hs-conid'>UnitBox</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rep_id</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newLocal</span> <span class='hs-layout'>(</span><span class='hs-varid'>linear</span> <span class='hs-varop'>$</span> <span class='hs-conid'>TcType.substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>rep_ty</span><span class='hs-layout'>)</span>
<a name="line-1086"></a>                                       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>rep_id</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>rep_id</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1087"></a>                         <span class='hs-conid'>Boxer</span> <span class='hs-varid'>boxer</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>boxer</span> <span class='hs-varid'>subst</span>
<a name="line-1088"></a>               <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>sco</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substCoUnchecked</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>co</span>
<a name="line-1089"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>rep_expr</span> <span class='hs-varop'>`Cast`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>sco</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1090"></a>
<a name="line-1091"></a><a name="seqUnboxer"></a><span class='hs-comment'>------------------------</span>
<a name="line-1092"></a><span class='hs-definition'>seqUnboxer</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unboxer</span>
<a name="line-1093"></a><span class='hs-definition'>seqUnboxer</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>v</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkDefaultCase</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-1094"></a>
<a name="line-1095"></a><a name="unitUnboxer"></a><span class='hs-definition'>unitUnboxer</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unboxer</span>
<a name="line-1096"></a><span class='hs-definition'>unitUnboxer</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>v</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1097"></a>
<a name="line-1098"></a><a name="unitBoxer"></a><span class='hs-definition'>unitBoxer</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Boxer</span>
<a name="line-1099"></a><span class='hs-definition'>unitBoxer</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnitBox</span>
<a name="line-1100"></a>
<a name="line-1101"></a><a name="dataConArgUnpack"></a><span class='hs-comment'>-------------------------</span>
<a name="line-1102"></a><span class='hs-definition'>dataConArgUnpack</span>
<a name="line-1103"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span>
<a name="line-1104"></a>   <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>StrictnessMark</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- Rep types</span>
<a name="line-1105"></a>       <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>Unboxer</span><span class='hs-layout'>,</span> <span class='hs-conid'>Boxer</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1106"></a>
<a name="line-1107"></a><span class='hs-definition'>dataConArgUnpack</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>arg_mult</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-1108"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>arg_ty</span>
<a name="line-1109"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>con</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConSingleAlgDataCon_maybe</span> <span class='hs-varid'>tc</span>
<a name="line-1110"></a>      <span class='hs-comment'>-- NB: check for an *algebraic* data type</span>
<a name="line-1111"></a>      <span class='hs-comment'>-- A recursive newtype might mean that</span>
<a name="line-1112"></a>      <span class='hs-comment'>-- 'arg_ty' is a newtype</span>
<a name="line-1113"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rep_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>scaleScaled</span> <span class='hs-varid'>arg_mult</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>dataConInstArgTys</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tc_args</span>
<a name="line-1114"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>null</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConExTyCoVars</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1115"></a>      <span class='hs-comment'>-- Note [Unpacking GADTs and existentials]</span>
<a name="line-1116"></a>    <span class='hs-layout'>(</span> <span class='hs-varid'>rep_tys</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>dataConRepStrictness</span> <span class='hs-varid'>con</span>
<a name="line-1117"></a>    <span class='hs-layout'>,</span><span class='hs-layout'>(</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>arg_id</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1118"></a>       <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rep_ids</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>newLocal</span> <span class='hs-varid'>rep_tys</span>
<a name="line-1119"></a>          <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>r_mult</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idMult</span> <span class='hs-varid'>arg_id</span>
<a name="line-1120"></a>          <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rep_ids'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>scaleIdBy</span> <span class='hs-varid'>r_mult</span><span class='hs-layout'>)</span> <span class='hs-varid'>rep_ids</span>
<a name="line-1121"></a>          <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>unbox_fn</span> <span class='hs-varid'>body</span>
<a name="line-1122"></a>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSingleAltCase</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>arg_id</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_id</span>
<a name="line-1123"></a>                             <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-varid'>rep_ids'</span> <span class='hs-varid'>body</span>
<a name="line-1124"></a>          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>unbox_fn</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1125"></a>     <span class='hs-layout'>,</span> <span class='hs-conid'>Boxer</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>subst</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1126"></a>       <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rep_ids</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>newLocal</span> <span class='hs-varop'>.</span> <span class='hs-conid'>TcType.substScaledTyUnchecked</span> <span class='hs-varid'>subst</span><span class='hs-layout'>)</span> <span class='hs-varid'>rep_tys</span>
<a name="line-1127"></a>          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>rep_ids</span><span class='hs-layout'>,</span> <span class='hs-conid'>Var</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConWorkId</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span>
<a name="line-1128"></a>                             <span class='hs-varop'>`mkTyApps`</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTysUnchecked</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span>
<a name="line-1129"></a>                             <span class='hs-varop'>`mkVarApps`</span> <span class='hs-varid'>rep_ids</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1130"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1131"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"dataConArgUnpack"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-1132"></a>    <span class='hs-comment'>-- An interface file specified Unpacked, but we couldn't unpack it</span>
<a name="line-1133"></a>
<a name="line-1134"></a><a name="isUnpackableType"></a><span class='hs-definition'>isUnpackableType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1135"></a><span class='hs-comment'>-- True if we can unpack the UNPACK the argument type</span>
<a name="line-1136"></a><span class='hs-comment'>-- See Note [Recursive unboxing]</span>
<a name="line-1137"></a><span class='hs-comment'>-- We look "deeply" inside rather than relying on the DataCons</span>
<a name="line-1138"></a><span class='hs-comment'>-- we encounter on the way, because otherwise we might well</span>
<a name="line-1139"></a><span class='hs-comment'>-- end up relying on ourselves!</span>
<a name="line-1140"></a><span class='hs-definition'>isUnpackableType</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-1141"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>data_con</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unpackable_type</span> <span class='hs-varid'>ty</span>
<a name="line-1142"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ok_con_args</span> <span class='hs-varid'>emptyNameSet</span> <span class='hs-varid'>data_con</span>
<a name="line-1143"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1144"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1145"></a>  <span class='hs-keyword'>where</span>
<a name="line-1146"></a>    <span class='hs-varid'>ok_con_args</span> <span class='hs-varid'>dcs</span> <span class='hs-varid'>con</span>
<a name="line-1147"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>dc_name</span> <span class='hs-varop'>`elemNameSet`</span> <span class='hs-varid'>dcs</span>
<a name="line-1148"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1149"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1150"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varid'>ok_arg</span> <span class='hs-varid'>dcs'</span><span class='hs-layout'>)</span>
<a name="line-1151"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>dataConOrigArgTys</span> <span class='hs-varid'>con</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>dataConSrcBangs</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span>
<a name="line-1152"></a>          <span class='hs-comment'>-- NB: dataConSrcBangs gives the *user* request;</span>
<a name="line-1153"></a>          <span class='hs-comment'>-- We'd get a black hole if we used dataConImplBangs</span>
<a name="line-1154"></a>       <span class='hs-keyword'>where</span>
<a name="line-1155"></a>         <span class='hs-varid'>dc_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getName</span> <span class='hs-varid'>con</span>
<a name="line-1156"></a>         <span class='hs-varid'>dcs'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dcs</span> <span class='hs-varop'>`extendNameSet`</span> <span class='hs-varid'>dc_name</span>
<a name="line-1157"></a>
<a name="line-1158"></a>    <span class='hs-varid'>ok_arg</span> <span class='hs-varid'>dcs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>bang</span><span class='hs-layout'>)</span>
<a name="line-1159"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>attempt_unpack</span> <span class='hs-varid'>bang</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>ok_ty</span> <span class='hs-varid'>dcs</span> <span class='hs-varid'>norm_ty</span>
<a name="line-1160"></a>      <span class='hs-keyword'>where</span>
<a name="line-1161"></a>        <span class='hs-varid'>norm_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topNormaliseType</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>ty</span>
<a name="line-1162"></a>
<a name="line-1163"></a>    <span class='hs-varid'>ok_ty</span> <span class='hs-varid'>dcs</span> <span class='hs-varid'>ty</span>
<a name="line-1164"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>data_con</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unpackable_type</span> <span class='hs-varid'>ty</span>
<a name="line-1165"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ok_con_args</span> <span class='hs-varid'>dcs</span> <span class='hs-varid'>data_con</span>
<a name="line-1166"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1167"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>        <span class='hs-comment'>-- NB True here, in contrast to False at top level</span>
<a name="line-1168"></a>
<a name="line-1169"></a>    <span class='hs-varid'>attempt_unpack</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsSrcBang</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>SrcUnpack</span> <span class='hs-conid'>NoSrcStrict</span><span class='hs-layout'>)</span>
<a name="line-1170"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.StrictData</span> <span class='hs-varid'>dflags</span>
<a name="line-1171"></a>    <span class='hs-varid'>attempt_unpack</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsSrcBang</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>SrcUnpack</span> <span class='hs-conid'>SrcStrict</span><span class='hs-layout'>)</span>
<a name="line-1172"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1173"></a>    <span class='hs-varid'>attempt_unpack</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsSrcBang</span> <span class='hs-keyword'>_</span>  <span class='hs-conid'>NoSrcUnpack</span> <span class='hs-conid'>SrcStrict</span><span class='hs-layout'>)</span>
<a name="line-1174"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>  <span class='hs-comment'>-- Be conservative</span>
<a name="line-1175"></a>    <span class='hs-varid'>attempt_unpack</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsSrcBang</span> <span class='hs-keyword'>_</span>  <span class='hs-conid'>NoSrcUnpack</span> <span class='hs-conid'>NoSrcStrict</span><span class='hs-layout'>)</span>
<a name="line-1176"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.StrictData</span> <span class='hs-varid'>dflags</span> <span class='hs-comment'>-- Be conservative</span>
<a name="line-1177"></a>    <span class='hs-varid'>attempt_unpack</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1178"></a>
<a name="line-1179"></a>    <span class='hs-varid'>unpackable_type</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>DataCon</span>
<a name="line-1180"></a>    <span class='hs-comment'>-- Works just on a single level</span>
<a name="line-1181"></a>    <span class='hs-varid'>unpackable_type</span> <span class='hs-varid'>ty</span>
<a name="line-1182"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-1183"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>data_con</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConSingleAlgDataCon_maybe</span> <span class='hs-varid'>tc</span>
<a name="line-1184"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>null</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConExTyCoVars</span> <span class='hs-varid'>data_con</span><span class='hs-layout'>)</span>
<a name="line-1185"></a>          <span class='hs-comment'>-- See Note [Unpacking GADTs and existentials]</span>
<a name="line-1186"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>data_con</span>
<a name="line-1187"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1188"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1189"></a>
<a name="line-1190"></a><span class='hs-comment'>{-
<a name="line-1191"></a>Note [Unpacking GADTs and existentials]
<a name="line-1192"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1193"></a>There is nothing stopping us unpacking a data type with equality
<a name="line-1194"></a>components, like
<a name="line-1195"></a>  data Equal a b where
<a name="line-1196"></a>    Equal :: Equal a a
<a name="line-1197"></a>
<a name="line-1198"></a>And it'd be fine to unpack a product type with existential components
<a name="line-1199"></a>too, but that would require a bit more plumbing, so currently we don't.
<a name="line-1200"></a>
<a name="line-1201"></a>So for now we require: null (dataConExTyCoVars data_con)
<a name="line-1202"></a>See #14978
<a name="line-1203"></a>
<a name="line-1204"></a>Note [Unpack one-wide fields]
<a name="line-1205"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1206"></a>The flag UnboxSmallStrictFields ensures that any field that can
<a name="line-1207"></a>(safely) be unboxed to a word-sized unboxed field, should be so unboxed.
<a name="line-1208"></a>For example:
<a name="line-1209"></a>
<a name="line-1210"></a>    data A = A Int#
<a name="line-1211"></a>    newtype B = B A
<a name="line-1212"></a>    data C = C !B
<a name="line-1213"></a>    data D = D !C
<a name="line-1214"></a>    data E = E !()
<a name="line-1215"></a>    data F = F !D
<a name="line-1216"></a>    data G = G !F !F
<a name="line-1217"></a>
<a name="line-1218"></a>All of these should have an Int# as their representation, except
<a name="line-1219"></a>G which should have two Int#s.
<a name="line-1220"></a>
<a name="line-1221"></a>However
<a name="line-1222"></a>
<a name="line-1223"></a>    data T = T !(S Int)
<a name="line-1224"></a>    data S = S !a
<a name="line-1225"></a>
<a name="line-1226"></a>Here we can represent T with an Int#.
<a name="line-1227"></a>
<a name="line-1228"></a>Note [Recursive unboxing]
<a name="line-1229"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1230"></a>Consider
<a name="line-1231"></a>  data R = MkR {-# UNPACK #-} !S Int
<a name="line-1232"></a>  data S = MkS {-# UNPACK #-} !Int
<a name="line-1233"></a>The representation arguments of MkR are the *representation* arguments
<a name="line-1234"></a>of S (plus Int); the rep args of MkS are Int#.  This is all fine.
<a name="line-1235"></a>
<a name="line-1236"></a>But be careful not to try to unbox this!
<a name="line-1237"></a>        data T = MkT {-# UNPACK #-} !T Int
<a name="line-1238"></a>Because then we'd get an infinite number of arguments.
<a name="line-1239"></a>
<a name="line-1240"></a>Here is a more complicated case:
<a name="line-1241"></a>        data S = MkS {-# UNPACK #-} !T Int
<a name="line-1242"></a>        data T = MkT {-# UNPACK #-} !S Int
<a name="line-1243"></a>Each of S and T must decide independently whether to unpack
<a name="line-1244"></a>and they had better not both say yes. So they must both say no.
<a name="line-1245"></a>
<a name="line-1246"></a>Also behave conservatively when there is no UNPACK pragma
<a name="line-1247"></a>        data T = MkS !T Int
<a name="line-1248"></a>with -funbox-strict-fields or -funbox-small-strict-fields
<a name="line-1249"></a>we need to behave as if there was an UNPACK pragma there.
<a name="line-1250"></a>
<a name="line-1251"></a>But it's the *argument* type that matters. This is fine:
<a name="line-1252"></a>        data S = MkS S !Int
<a name="line-1253"></a>because Int is non-recursive.
<a name="line-1254"></a>
<a name="line-1255"></a>************************************************************************
<a name="line-1256"></a>*                                                                      *
<a name="line-1257"></a>        Wrapping and unwrapping newtypes and type families
<a name="line-1258"></a>*                                                                      *
<a name="line-1259"></a>************************************************************************
<a name="line-1260"></a>-}</span>
<a name="line-1261"></a>
<a name="line-1262"></a><a name="wrapNewTypeBody"></a><span class='hs-definition'>wrapNewTypeBody</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1263"></a><span class='hs-comment'>-- The wrapper for the data constructor for a newtype looks like this:</span>
<a name="line-1264"></a><span class='hs-comment'>--      newtype T a = MkT (a,Int)</span>
<a name="line-1265"></a><span class='hs-comment'>--      MkT :: forall a. (a,Int) -&gt; T a</span>
<a name="line-1266"></a><span class='hs-comment'>--      MkT = /\a. \(x:(a,Int)). x `cast` sym (CoT a)</span>
<a name="line-1267"></a><span class='hs-comment'>-- where CoT is the coercion TyCon associated with the newtype</span>
<a name="line-1268"></a><span class='hs-comment'>--</span>
<a name="line-1269"></a><span class='hs-comment'>-- The call (wrapNewTypeBody T [a] e) returns the</span>
<a name="line-1270"></a><span class='hs-comment'>-- body of the wrapper, namely</span>
<a name="line-1271"></a><span class='hs-comment'>--      e `cast` (CoT [a])</span>
<a name="line-1272"></a><span class='hs-comment'>--</span>
<a name="line-1273"></a><span class='hs-comment'>-- If a coercion constructor is provided in the newtype, then we use</span>
<a name="line-1274"></a><span class='hs-comment'>-- it, otherwise the wrap/unwrap are both no-ops</span>
<a name="line-1275"></a>
<a name="line-1276"></a><span class='hs-definition'>wrapNewTypeBody</span> <span class='hs-varid'>tycon</span> <span class='hs-varid'>args</span> <span class='hs-varid'>result_expr</span>
<a name="line-1277"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isNewTyCon</span> <span class='hs-varid'>tycon</span> <span class='hs-layout'>)</span>
<a name="line-1278"></a>    <span class='hs-varid'>mkCast</span> <span class='hs-varid'>result_expr</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1279"></a>  <span class='hs-keyword'>where</span>
<a name="line-1280"></a>    <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkUnbranchedAxInstCo</span> <span class='hs-conid'>Representational</span> <span class='hs-layout'>(</span><span class='hs-varid'>newTyConCo</span> <span class='hs-varid'>tycon</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span> <span class='hs-conid'>[]</span>
<a name="line-1281"></a>
<a name="line-1282"></a><span class='hs-comment'>-- When unwrapping, we do *not* apply any family coercion, because this will</span>
<a name="line-1283"></a><span class='hs-comment'>-- be done via a CoPat by the type checker.  We have to do it this way as</span>
<a name="line-1284"></a><span class='hs-comment'>-- computing the right type arguments for the coercion requires more than just</span>
<a name="line-1285"></a><span class='hs-comment'>-- a splitting operation (cf, GHC.Tc.Gen.Pat.tcConPat).</span>
<a name="line-1286"></a>
<a name="line-1287"></a><a name="unwrapNewTypeBody"></a><span class='hs-definition'>unwrapNewTypeBody</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1288"></a><span class='hs-definition'>unwrapNewTypeBody</span> <span class='hs-varid'>tycon</span> <span class='hs-varid'>args</span> <span class='hs-varid'>result_expr</span>
<a name="line-1289"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isNewTyCon</span> <span class='hs-varid'>tycon</span> <span class='hs-layout'>)</span>
<a name="line-1290"></a>    <span class='hs-varid'>mkCast</span> <span class='hs-varid'>result_expr</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkUnbranchedAxInstCo</span> <span class='hs-conid'>Representational</span> <span class='hs-layout'>(</span><span class='hs-varid'>newTyConCo</span> <span class='hs-varid'>tycon</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-1291"></a>
<a name="line-1292"></a><a name="wrapFamInstBody"></a><span class='hs-comment'>-- If the type constructor is a representation type of a data instance, wrap</span>
<a name="line-1293"></a><span class='hs-comment'>-- the expression into a cast adjusting the expression type, which is an</span>
<a name="line-1294"></a><span class='hs-comment'>-- instance of the representation type, to the corresponding instance of the</span>
<a name="line-1295"></a><span class='hs-comment'>-- family instance type.</span>
<a name="line-1296"></a><span class='hs-comment'>-- See Note [Wrappers for data instance tycons]</span>
<a name="line-1297"></a><span class='hs-definition'>wrapFamInstBody</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1298"></a><span class='hs-definition'>wrapFamInstBody</span> <span class='hs-varid'>tycon</span> <span class='hs-varid'>args</span> <span class='hs-varid'>body</span>
<a name="line-1299"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>co_con</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConFamilyCoercion_maybe</span> <span class='hs-varid'>tycon</span>
<a name="line-1300"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCast</span> <span class='hs-varid'>body</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkUnbranchedAxInstCo</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>co_con</span> <span class='hs-varid'>args</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1301"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1302"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body</span>
<a name="line-1303"></a>
<a name="line-1304"></a><span class='hs-comment'>{-
<a name="line-1305"></a>************************************************************************
<a name="line-1306"></a>*                                                                      *
<a name="line-1307"></a>\subsection{Primitive operations}
<a name="line-1308"></a>*                                                                      *
<a name="line-1309"></a>************************************************************************
<a name="line-1310"></a>-}</span>
<a name="line-1311"></a>
<a name="line-1312"></a><a name="mkPrimOpId"></a><span class='hs-definition'>mkPrimOpId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PrimOp</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-1313"></a><span class='hs-definition'>mkPrimOpId</span> <span class='hs-varid'>prim_op</span>
<a name="line-1314"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span>
<a name="line-1315"></a>  <span class='hs-keyword'>where</span>
<a name="line-1316"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>tyvars</span><span class='hs-layout'>,</span><span class='hs-varid'>arg_tys</span><span class='hs-layout'>,</span><span class='hs-varid'>res_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>arity</span><span class='hs-layout'>,</span> <span class='hs-varid'>strict_sig</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>primOpSig</span> <span class='hs-varid'>prim_op</span>
<a name="line-1317"></a>    <span class='hs-varid'>ty</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSpecForAllTys</span> <span class='hs-varid'>tyvars</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkVisFunTysMany</span> <span class='hs-varid'>arg_tys</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span>
<a name="line-1318"></a>    <span class='hs-varid'>name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInName</span> <span class='hs-varid'>gHC_PRIM</span> <span class='hs-layout'>(</span><span class='hs-varid'>primOpOcc</span> <span class='hs-varid'>prim_op</span><span class='hs-layout'>)</span>
<a name="line-1319"></a>                         <span class='hs-layout'>(</span><span class='hs-varid'>mkPrimOpIdUnique</span> <span class='hs-layout'>(</span><span class='hs-varid'>primOpTag</span> <span class='hs-varid'>prim_op</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1320"></a>                         <span class='hs-layout'>(</span><span class='hs-conid'>AnId</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-conid'>UserSyntax</span>
<a name="line-1321"></a>    <span class='hs-varid'>id</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkGlobalId</span> <span class='hs-layout'>(</span><span class='hs-conid'>PrimOpId</span> <span class='hs-varid'>prim_op</span><span class='hs-layout'>)</span> <span class='hs-varid'>name</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>info</span>
<a name="line-1322"></a>
<a name="line-1323"></a>    <span class='hs-comment'>-- PrimOps don't ever construct a product, but we want to preserve bottoms</span>
<a name="line-1324"></a>    <span class='hs-varid'>cpr</span>
<a name="line-1325"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadEndDiv</span> <span class='hs-layout'>(</span><span class='hs-varid'>snd</span> <span class='hs-layout'>(</span><span class='hs-varid'>splitStrictSig</span> <span class='hs-varid'>strict_sig</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>botCpr</span>
<a name="line-1326"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                                      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topCpr</span>
<a name="line-1327"></a>
<a name="line-1328"></a>    <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span>
<a name="line-1329"></a>           <span class='hs-varop'>`setRuleInfo`</span>           <span class='hs-varid'>mkRuleInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>maybeToList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>primOpRules</span> <span class='hs-varid'>name</span> <span class='hs-varid'>prim_op</span><span class='hs-layout'>)</span>
<a name="line-1330"></a>           <span class='hs-varop'>`setArityInfo`</span>          <span class='hs-varid'>arity</span>
<a name="line-1331"></a>           <span class='hs-varop'>`setStrictnessInfo`</span>     <span class='hs-varid'>strict_sig</span>
<a name="line-1332"></a>           <span class='hs-varop'>`setCprInfo`</span>            <span class='hs-varid'>mkCprSig</span> <span class='hs-varid'>arity</span> <span class='hs-varid'>cpr</span>
<a name="line-1333"></a>           <span class='hs-varop'>`setInlinePragInfo`</span>     <span class='hs-varid'>neverInlinePragma</span>
<a name="line-1334"></a>           <span class='hs-varop'>`setLevityInfoWithType`</span> <span class='hs-varid'>res_ty</span>
<a name="line-1335"></a>               <span class='hs-comment'>-- We give PrimOps a NOINLINE pragma so that we don't</span>
<a name="line-1336"></a>               <span class='hs-comment'>-- get silly warnings from Desugar.dsRule (the inline_shadows_rule</span>
<a name="line-1337"></a>               <span class='hs-comment'>-- test) about a RULE conflicting with a possible inlining</span>
<a name="line-1338"></a>               <span class='hs-comment'>-- cf #7287</span>
<a name="line-1339"></a>
<a name="line-1340"></a><span class='hs-comment'>-- For each ccall we manufacture a separate CCallOpId, giving it</span>
<a name="line-1341"></a><span class='hs-comment'>-- a fresh unique, a type that is correct for this particular ccall,</span>
<a name="line-1342"></a><span class='hs-comment'>-- and a CCall structure that gives the correct details about calling</span>
<a name="line-1343"></a><span class='hs-comment'>-- convention etc.</span>
<a name="line-1344"></a><span class='hs-comment'>--</span>
<a name="line-1345"></a><span class='hs-comment'>-- The *name* of this Id is a local name whose OccName gives the full</span>
<a name="line-1346"></a><span class='hs-comment'>-- details of the ccall, type and all.  This means that the interface</span>
<a name="line-1347"></a><span class='hs-comment'>-- file reader can reconstruct a suitable Id</span>
<a name="line-1348"></a>
<a name="line-1349"></a><a name="mkFCallId"></a><span class='hs-definition'>mkFCallId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unique</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ForeignCall</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-1350"></a><span class='hs-definition'>mkFCallId</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>fcall</span> <span class='hs-varid'>ty</span>
<a name="line-1351"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>noFreeVarsOfType</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>)</span>
<a name="line-1352"></a>    <span class='hs-comment'>-- A CCallOpId should have no free type variables;</span>
<a name="line-1353"></a>    <span class='hs-comment'>-- when doing substitutions won't substitute over it</span>
<a name="line-1354"></a>    <span class='hs-varid'>mkGlobalId</span> <span class='hs-layout'>(</span><span class='hs-conid'>FCallId</span> <span class='hs-varid'>fcall</span><span class='hs-layout'>)</span> <span class='hs-varid'>name</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>info</span>
<a name="line-1355"></a>  <span class='hs-keyword'>where</span>
<a name="line-1356"></a>    <span class='hs-varid'>occ_str</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>showSDoc</span> <span class='hs-varid'>dflags</span> <span class='hs-layout'>(</span><span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>fcall</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1357"></a>    <span class='hs-comment'>-- The "occurrence name" of a ccall is the full info about the</span>
<a name="line-1358"></a>    <span class='hs-comment'>-- ccall; it is encoded, but may have embedded spaces etc!</span>
<a name="line-1359"></a>
<a name="line-1360"></a>    <span class='hs-varid'>name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkFCallName</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>occ_str</span>
<a name="line-1361"></a>
<a name="line-1362"></a>    <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span>
<a name="line-1363"></a>           <span class='hs-varop'>`setArityInfo`</span>          <span class='hs-varid'>arity</span>
<a name="line-1364"></a>           <span class='hs-varop'>`setStrictnessInfo`</span>     <span class='hs-varid'>strict_sig</span>
<a name="line-1365"></a>           <span class='hs-varop'>`setCprInfo`</span>            <span class='hs-varid'>topCprSig</span>
<a name="line-1366"></a>           <span class='hs-varop'>`setLevityInfoWithType`</span> <span class='hs-varid'>ty</span>
<a name="line-1367"></a>
<a name="line-1368"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitPiTys</span> <span class='hs-varid'>ty</span>
<a name="line-1369"></a>    <span class='hs-varid'>arity</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>count</span> <span class='hs-varid'>isAnonTyCoBinder</span> <span class='hs-varid'>bndrs</span>
<a name="line-1370"></a>    <span class='hs-varid'>strict_sig</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClosedStrictSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>replicate</span> <span class='hs-varid'>arity</span> <span class='hs-varid'>topDmd</span><span class='hs-layout'>)</span> <span class='hs-varid'>topDiv</span>
<a name="line-1371"></a>    <span class='hs-comment'>-- the call does not claim to be strict in its arguments, since they</span>
<a name="line-1372"></a>    <span class='hs-comment'>-- may be lifted (foreign import prim) and the called code doesn't</span>
<a name="line-1373"></a>    <span class='hs-comment'>-- necessarily force them. See #11076.</span>
<a name="line-1374"></a><span class='hs-comment'>{-
<a name="line-1375"></a>************************************************************************
<a name="line-1376"></a>*                                                                      *
<a name="line-1377"></a>\subsection{DictFuns and default methods}
<a name="line-1378"></a>*                                                                      *
<a name="line-1379"></a>************************************************************************
<a name="line-1380"></a>
<a name="line-1381"></a>Note [Dict funs and default methods]
<a name="line-1382"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1383"></a>Dict funs and default methods are *not* ImplicitIds.  Their definition
<a name="line-1384"></a>involves user-written code, so we can't figure out their strictness etc
<a name="line-1385"></a>based on fixed info, as we can for constructors and record selectors (say).
<a name="line-1386"></a>
<a name="line-1387"></a>NB: See also Note [Exported LocalIds] in GHC.Types.Id
<a name="line-1388"></a>-}</span>
<a name="line-1389"></a>
<a name="line-1390"></a><a name="mkDictFunId"></a><span class='hs-definition'>mkDictFunId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span>      <span class='hs-comment'>-- Name to use for the dict fun;</span>
<a name="line-1391"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span>
<a name="line-1392"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span>
<a name="line-1393"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span>
<a name="line-1394"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-1395"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-1396"></a><span class='hs-comment'>-- Implements the DFun Superclass Invariant (see GHC.Tc.TyCl.Instance)</span>
<a name="line-1397"></a><span class='hs-comment'>-- See Note [Dict funs and default methods]</span>
<a name="line-1398"></a>
<a name="line-1399"></a><span class='hs-definition'>mkDictFunId</span> <span class='hs-varid'>dfun_name</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span>
<a name="line-1400"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkExportedLocalId</span> <span class='hs-layout'>(</span><span class='hs-conid'>DFunId</span> <span class='hs-varid'>is_nt</span><span class='hs-layout'>)</span>
<a name="line-1401"></a>                      <span class='hs-varid'>dfun_name</span>
<a name="line-1402"></a>                      <span class='hs-varid'>dfun_ty</span>
<a name="line-1403"></a>  <span class='hs-keyword'>where</span>
<a name="line-1404"></a>    <span class='hs-varid'>is_nt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNewTyCon</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span>
<a name="line-1405"></a>    <span class='hs-varid'>dfun_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkDictFunTy</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span>
<a name="line-1406"></a>
<a name="line-1407"></a><a name="mkDictFunTy"></a><span class='hs-definition'>mkDictFunTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1408"></a><span class='hs-definition'>mkDictFunTy</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span>
<a name="line-1409"></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSpecSigmaTy</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1410"></a>
<a name="line-1411"></a><span class='hs-comment'>{-
<a name="line-1412"></a>************************************************************************
<a name="line-1413"></a>*                                                                      *
<a name="line-1414"></a>\subsection{Un-definable}
<a name="line-1415"></a>*                                                                      *
<a name="line-1416"></a>************************************************************************
<a name="line-1417"></a>
<a name="line-1418"></a>These Ids can't be defined in Haskell.  They could be defined in
<a name="line-1419"></a>unfoldings in the wired-in GHC.Prim interface file, but we'd have to
<a name="line-1420"></a>ensure that they were definitely, definitely inlined, because there is
<a name="line-1421"></a>no curried identifier for them.  That's what mkCompulsoryUnfolding
<a name="line-1422"></a>does. Alternatively, we could add the definitions to mi_decls of ghcPrimIface
<a name="line-1423"></a>but it's not clear if this would be simpler.
<a name="line-1424"></a>
<a name="line-1425"></a>coercionToken# is not listed in ghcPrimIds, since its type uses (~#)
<a name="line-1426"></a>which is not supposed to be used in expressions (GHC throws an assertion
<a name="line-1427"></a>failure when trying.)
<a name="line-1428"></a>-}</span>
<a name="line-1429"></a>
<a name="line-1430"></a><a name="nullAddrName"></a><span class='hs-definition'>nullAddrName</span><span class='hs-layout'>,</span> <span class='hs-varid'>seqName</span><span class='hs-layout'>,</span>
<a name="line-1431"></a>   <span class='hs-varid'>realWorldName</span><span class='hs-layout'>,</span> <span class='hs-varid'>voidPrimIdName</span><span class='hs-layout'>,</span> <span class='hs-varid'>coercionTokenName</span><span class='hs-layout'>,</span>
<a name="line-1432"></a>   <span class='hs-varid'>magicDictName</span><span class='hs-layout'>,</span> <span class='hs-varid'>coerceName</span><span class='hs-layout'>,</span> <span class='hs-varid'>proxyName</span><span class='hs-layout'>,</span>
<a name="line-1433"></a>   <span class='hs-varid'>leftSectionName</span><span class='hs-layout'>,</span> <span class='hs-varid'>rightSectionName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span>
<a name="line-1434"></a><span class='hs-definition'>nullAddrName</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInIdName</span> <span class='hs-varid'>gHC_PRIM</span>  <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"nullAddr#"</span><span class='hs-layout'>)</span>      <span class='hs-varid'>nullAddrIdKey</span>      <span class='hs-varid'>nullAddrId</span>
<a name="line-1435"></a><a name="seqName"></a><span class='hs-definition'>seqName</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInIdName</span> <span class='hs-varid'>gHC_PRIM</span>  <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"seq"</span><span class='hs-layout'>)</span>            <span class='hs-varid'>seqIdKey</span>           <span class='hs-varid'>seqId</span>
<a name="line-1436"></a><a name="realWorldName"></a><span class='hs-definition'>realWorldName</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInIdName</span> <span class='hs-varid'>gHC_PRIM</span>  <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"realWorld#"</span><span class='hs-layout'>)</span>     <span class='hs-varid'>realWorldPrimIdKey</span> <span class='hs-varid'>realWorldPrimId</span>
<a name="line-1437"></a><a name="voidPrimIdName"></a><span class='hs-definition'>voidPrimIdName</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInIdName</span> <span class='hs-varid'>gHC_PRIM</span>  <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"void#"</span><span class='hs-layout'>)</span>          <span class='hs-varid'>voidPrimIdKey</span>      <span class='hs-varid'>voidPrimId</span>
<a name="line-1438"></a><a name="coercionTokenName"></a><span class='hs-definition'>coercionTokenName</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInIdName</span> <span class='hs-varid'>gHC_PRIM</span>  <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"coercionToken#"</span><span class='hs-layout'>)</span> <span class='hs-varid'>coercionTokenIdKey</span> <span class='hs-varid'>coercionTokenId</span>
<a name="line-1439"></a><a name="magicDictName"></a><span class='hs-definition'>magicDictName</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInIdName</span> <span class='hs-varid'>gHC_PRIM</span>  <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"magicDict"</span><span class='hs-layout'>)</span>      <span class='hs-varid'>magicDictKey</span>       <span class='hs-varid'>magicDictId</span>
<a name="line-1440"></a><a name="coerceName"></a><span class='hs-definition'>coerceName</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInIdName</span> <span class='hs-varid'>gHC_PRIM</span>  <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"coerce"</span><span class='hs-layout'>)</span>         <span class='hs-varid'>coerceKey</span>          <span class='hs-varid'>coerceId</span>
<a name="line-1441"></a><a name="proxyName"></a><span class='hs-definition'>proxyName</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInIdName</span> <span class='hs-varid'>gHC_PRIM</span>  <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"proxy#"</span><span class='hs-layout'>)</span>         <span class='hs-varid'>proxyHashKey</span>       <span class='hs-varid'>proxyHashId</span>
<a name="line-1442"></a><a name="leftSectionName"></a><span class='hs-definition'>leftSectionName</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInIdName</span> <span class='hs-varid'>gHC_PRIM</span>  <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"leftSection"</span><span class='hs-layout'>)</span>    <span class='hs-varid'>leftSectionKey</span>     <span class='hs-varid'>leftSectionId</span>
<a name="line-1443"></a><a name="rightSectionName"></a><span class='hs-definition'>rightSectionName</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInIdName</span> <span class='hs-varid'>gHC_PRIM</span>  <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"rightSection"</span><span class='hs-layout'>)</span>   <span class='hs-varid'>rightSectionKey</span>    <span class='hs-varid'>rightSectionId</span>
<a name="line-1444"></a>
<a name="line-1445"></a><a name="lazyIdName"></a><span class='hs-comment'>-- Names listed in magicIds; see Note [magicIds]</span>
<a name="line-1446"></a><span class='hs-definition'>lazyIdName</span><span class='hs-layout'>,</span> <span class='hs-varid'>oneShotName</span><span class='hs-layout'>,</span> <span class='hs-varid'>noinlineIdName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span>
<a name="line-1447"></a><span class='hs-definition'>lazyIdName</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInIdName</span> <span class='hs-varid'>gHC_MAGIC</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"lazy"</span><span class='hs-layout'>)</span>           <span class='hs-varid'>lazyIdKey</span>          <span class='hs-varid'>lazyId</span>
<a name="line-1448"></a><a name="oneShotName"></a><span class='hs-definition'>oneShotName</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInIdName</span> <span class='hs-varid'>gHC_MAGIC</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"oneShot"</span><span class='hs-layout'>)</span>        <span class='hs-varid'>oneShotKey</span>         <span class='hs-varid'>oneShotId</span>
<a name="line-1449"></a><a name="noinlineIdName"></a><span class='hs-definition'>noinlineIdName</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWiredInIdName</span> <span class='hs-varid'>gHC_MAGIC</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"noinline"</span><span class='hs-layout'>)</span>       <span class='hs-varid'>noinlineIdKey</span>      <span class='hs-varid'>noinlineId</span>
<a name="line-1450"></a>
<a name="line-1451"></a><a name="proxyHashId"></a><span class='hs-comment'>------------------------------------------------</span>
<a name="line-1452"></a><span class='hs-definition'>proxyHashId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>
<a name="line-1453"></a><span class='hs-definition'>proxyHashId</span>
<a name="line-1454"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pcMiscPrelId</span> <span class='hs-varid'>proxyName</span> <span class='hs-varid'>ty</span>
<a name="line-1455"></a>       <span class='hs-layout'>(</span><span class='hs-varid'>noCafIdInfo</span> <span class='hs-varop'>`setUnfoldingInfo`</span> <span class='hs-varid'>evaldUnfolding</span> <span class='hs-comment'>-- Note [evaldUnfoldings]</span>
<a name="line-1456"></a>                    <span class='hs-varop'>`setNeverLevPoly`</span>  <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1457"></a>  <span class='hs-keyword'>where</span>
<a name="line-1458"></a>    <span class='hs-comment'>-- proxy# :: forall {k} (a:k). Proxy# k a</span>
<a name="line-1459"></a>    <span class='hs-comment'>--</span>
<a name="line-1460"></a>    <span class='hs-comment'>-- The visibility of the `k` binder is Inferred to match the type of the</span>
<a name="line-1461"></a>    <span class='hs-comment'>-- Proxy data constructor (#16293).</span>
<a name="line-1462"></a>    <span class='hs-keyglyph'>[</span><span class='hs-varid'>kv</span><span class='hs-layout'>,</span><span class='hs-varid'>tv</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTemplateKiTyVars</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>liftedTypeKind</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>id</span>
<a name="line-1463"></a>    <span class='hs-varid'>kv_ty</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>kv</span>
<a name="line-1464"></a>    <span class='hs-varid'>tv_ty</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv</span>
<a name="line-1465"></a>    <span class='hs-varid'>ty</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInfForAllTy</span> <span class='hs-varid'>kv</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkSpecForAllTy</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkProxyPrimTy</span> <span class='hs-varid'>kv_ty</span> <span class='hs-varid'>tv_ty</span>
<a name="line-1466"></a>
<a name="line-1467"></a><a name="nullAddrId"></a><span class='hs-comment'>------------------------------------------------</span>
<a name="line-1468"></a><span class='hs-definition'>nullAddrId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>
<a name="line-1469"></a><span class='hs-comment'>-- nullAddr# :: Addr#</span>
<a name="line-1470"></a><span class='hs-comment'>-- The reason it is here is because we don't provide</span>
<a name="line-1471"></a><span class='hs-comment'>-- a way to write this literal in Haskell.</span>
<a name="line-1472"></a><span class='hs-definition'>nullAddrId</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pcMiscPrelId</span> <span class='hs-varid'>nullAddrName</span> <span class='hs-varid'>addrPrimTy</span> <span class='hs-varid'>info</span>
<a name="line-1473"></a>  <span class='hs-keyword'>where</span>
<a name="line-1474"></a>    <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span> <span class='hs-varop'>`setInlinePragInfo`</span> <span class='hs-varid'>alwaysInlinePragma</span>
<a name="line-1475"></a>                       <span class='hs-varop'>`setUnfoldingInfo`</span>  <span class='hs-varid'>mkCompulsoryUnfolding</span> <span class='hs-varid'>defaultSimpleOpts</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>nullAddrLit</span><span class='hs-layout'>)</span>
<a name="line-1476"></a>                       <span class='hs-varop'>`setNeverLevPoly`</span>   <span class='hs-varid'>addrPrimTy</span>
<a name="line-1477"></a>
<a name="line-1478"></a><a name="seqId"></a><span class='hs-comment'>------------------------------------------------</span>
<a name="line-1479"></a><span class='hs-definition'>seqId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>     <span class='hs-comment'>-- See Note [seqId magic]</span>
<a name="line-1480"></a><span class='hs-definition'>seqId</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pcMiscPrelId</span> <span class='hs-varid'>seqName</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>info</span>
<a name="line-1481"></a>  <span class='hs-keyword'>where</span>
<a name="line-1482"></a>    <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span> <span class='hs-varop'>`setInlinePragInfo`</span> <span class='hs-varid'>inline_prag</span>
<a name="line-1483"></a>                       <span class='hs-varop'>`setUnfoldingInfo`</span>  <span class='hs-varid'>mkCompulsoryUnfolding</span> <span class='hs-varid'>defaultSimpleOpts</span> <span class='hs-varid'>rhs</span>
<a name="line-1484"></a>
<a name="line-1485"></a>    <span class='hs-varid'>inline_prag</span>
<a name="line-1486"></a>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alwaysInlinePragma</span> <span class='hs-varop'>`setInlinePragmaActivation`</span> <span class='hs-conid'>ActiveAfter</span>
<a name="line-1487"></a>                 <span class='hs-conid'>NoSourceText</span> <span class='hs-num'>0</span>
<a name="line-1488"></a>                  <span class='hs-comment'>-- Make 'seq' not inline-always, so that simpleOptExpr</span>
<a name="line-1489"></a>                  <span class='hs-comment'>-- (see GHC.Core.Subst.simple_app) won't inline 'seq' on the</span>
<a name="line-1490"></a>                  <span class='hs-comment'>-- LHS of rules.  That way we can have rules for 'seq';</span>
<a name="line-1491"></a>                  <span class='hs-comment'>-- see Note [seqId magic]</span>
<a name="line-1492"></a>
<a name="line-1493"></a>    <span class='hs-comment'>-- seq :: forall (r :: RuntimeRep) a (b :: TYPE r). a -&gt; b -&gt; b</span>
<a name="line-1494"></a>    <span class='hs-varid'>ty</span>  <span class='hs-keyglyph'>=</span>
<a name="line-1495"></a>      <span class='hs-varid'>mkInfForAllTy</span> <span class='hs-varid'>runtimeRep2TyVar</span>
<a name="line-1496"></a>      <span class='hs-varop'>$</span> <span class='hs-varid'>mkSpecForAllTys</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>alphaTyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>openBetaTyVar</span><span class='hs-keyglyph'>]</span>
<a name="line-1497"></a>      <span class='hs-varop'>$</span> <span class='hs-varid'>mkVisFunTyMany</span> <span class='hs-varid'>alphaTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkVisFunTyMany</span> <span class='hs-varid'>openBetaTy</span> <span class='hs-varid'>openBetaTy</span><span class='hs-layout'>)</span>
<a name="line-1498"></a>
<a name="line-1499"></a>    <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTemplateLocals</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>alphaTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>openBetaTy</span><span class='hs-keyglyph'>]</span>
<a name="line-1500"></a>    <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>runtimeRep2TyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>alphaTyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>openBetaTyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1501"></a>          <span class='hs-conid'>Case</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span> <span class='hs-varid'>openBetaTy</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Alt</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1502"></a>
<a name="line-1503"></a><a name="lazyId"></a><span class='hs-comment'>------------------------------------------------</span>
<a name="line-1504"></a><span class='hs-definition'>lazyId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>    <span class='hs-comment'>-- See Note [lazyId magic]</span>
<a name="line-1505"></a><span class='hs-definition'>lazyId</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pcMiscPrelId</span> <span class='hs-varid'>lazyIdName</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>info</span>
<a name="line-1506"></a>  <span class='hs-keyword'>where</span>
<a name="line-1507"></a>    <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span> <span class='hs-varop'>`setNeverLevPoly`</span> <span class='hs-varid'>ty</span>
<a name="line-1508"></a>    <span class='hs-varid'>ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSpecForAllTys</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>alphaTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkVisFunTyMany</span> <span class='hs-varid'>alphaTy</span> <span class='hs-varid'>alphaTy</span><span class='hs-layout'>)</span>
<a name="line-1509"></a>
<a name="line-1510"></a><a name="noinlineId"></a><span class='hs-definition'>noinlineId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-comment'>-- See Note [noinlineId magic]</span>
<a name="line-1511"></a><span class='hs-definition'>noinlineId</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pcMiscPrelId</span> <span class='hs-varid'>noinlineIdName</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>info</span>
<a name="line-1512"></a>  <span class='hs-keyword'>where</span>
<a name="line-1513"></a>    <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span> <span class='hs-varop'>`setNeverLevPoly`</span> <span class='hs-varid'>ty</span>
<a name="line-1514"></a>    <span class='hs-varid'>ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSpecForAllTys</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>alphaTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkVisFunTyMany</span> <span class='hs-varid'>alphaTy</span> <span class='hs-varid'>alphaTy</span><span class='hs-layout'>)</span>
<a name="line-1515"></a>
<a name="line-1516"></a><a name="oneShotId"></a><span class='hs-definition'>oneShotId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-comment'>-- See Note [The oneShot function]</span>
<a name="line-1517"></a><span class='hs-definition'>oneShotId</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pcMiscPrelId</span> <span class='hs-varid'>oneShotName</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>info</span>
<a name="line-1518"></a>  <span class='hs-keyword'>where</span>
<a name="line-1519"></a>    <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span> <span class='hs-varop'>`setInlinePragInfo`</span> <span class='hs-varid'>alwaysInlinePragma</span>
<a name="line-1520"></a>                       <span class='hs-varop'>`setUnfoldingInfo`</span>  <span class='hs-varid'>mkCompulsoryUnfolding</span> <span class='hs-varid'>defaultSimpleOpts</span> <span class='hs-varid'>rhs</span>
<a name="line-1521"></a>    <span class='hs-varid'>ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInfForAllTys</span>  <span class='hs-keyglyph'>[</span> <span class='hs-varid'>runtimeRep1TyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>runtimeRep2TyVar</span> <span class='hs-keyglyph'>]</span> <span class='hs-varop'>$</span>
<a name="line-1522"></a>          <span class='hs-varid'>mkSpecForAllTys</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>openAlphaTyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>openBetaTyVar</span> <span class='hs-keyglyph'>]</span>      <span class='hs-varop'>$</span>
<a name="line-1523"></a>          <span class='hs-varid'>mkVisFunTyMany</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>fun_ty</span>
<a name="line-1524"></a>    <span class='hs-varid'>fun_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVisFunTyMany</span> <span class='hs-varid'>openAlphaTy</span> <span class='hs-varid'>openBetaTy</span>
<a name="line-1525"></a>    <span class='hs-keyglyph'>[</span><span class='hs-varid'>body</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTemplateLocals</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>fun_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>openAlphaTy</span><span class='hs-keyglyph'>]</span>
<a name="line-1526"></a>    <span class='hs-varid'>x'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setOneShotLambda</span> <span class='hs-varid'>x</span>  <span class='hs-comment'>-- Here is the magic bit!</span>
<a name="line-1527"></a>    <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>runtimeRep1TyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>runtimeRep2TyVar</span>
<a name="line-1528"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>openAlphaTyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>openBetaTyVar</span>
<a name="line-1529"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>,</span> <span class='hs-varid'>x'</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>$</span>
<a name="line-1530"></a>          <span class='hs-conid'>Var</span> <span class='hs-varid'>body</span> <span class='hs-varop'>`App`</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>x'</span>
<a name="line-1531"></a>
<a name="line-1532"></a><span class='hs-comment'>----------------------------------------------------------------------</span>
<a name="line-1533"></a><span class='hs-comment'>{- Note [Wired-in Ids for rebindable syntax]
<a name="line-1534"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1535"></a>The functions leftSectionId, rightSectionId are
<a name="line-1536"></a>wired in here ONLY because they are use in a levity-polymorphic way
<a name="line-1537"></a>by the rebindable syntax mechanism. See GHC.Rename.Expr
<a name="line-1538"></a>Note [Handling overloaded and rebindable constructs].
<a name="line-1539"></a>
<a name="line-1540"></a>Alas, we can't currenly give Haskell definitions for
<a name="line-1541"></a>levity-polymorphic functions.
<a name="line-1542"></a>
<a name="line-1543"></a>They have Compulsory unfoldings to so that the levity polymorphism
<a name="line-1544"></a>does not linger for long.
<a name="line-1545"></a>-}</span>
<a name="line-1546"></a>
<a name="line-1547"></a><a name="leftSectionId"></a><span class='hs-comment'>-- See Note [Left and right sections] in GHC.Rename.Expr</span>
<a name="line-1548"></a><span class='hs-comment'>-- See Note [Wired-in Ids for rebindable syntax]</span>
<a name="line-1549"></a><span class='hs-comment'>--   leftSection :: forall r1 r2 n (a:Type r1) (b:TYPE r2).</span>
<a name="line-1550"></a><span class='hs-comment'>--                  (a %n-&gt; b) -&gt; a %n-&gt; b</span>
<a name="line-1551"></a><span class='hs-comment'>--   leftSection f x = f x</span>
<a name="line-1552"></a><span class='hs-comment'>-- Important that it is eta-expanded, so that (leftSection undefined `seq` ())</span>
<a name="line-1553"></a><span class='hs-comment'>--   is () and not undefined</span>
<a name="line-1554"></a><span class='hs-comment'>-- Important that is is multiplicity-polymorphic (test linear/should_compile/OldList)</span>
<a name="line-1555"></a><span class='hs-definition'>leftSectionId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>
<a name="line-1556"></a><span class='hs-definition'>leftSectionId</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pcMiscPrelId</span> <span class='hs-varid'>leftSectionName</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>info</span>
<a name="line-1557"></a>  <span class='hs-keyword'>where</span>
<a name="line-1558"></a>    <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span> <span class='hs-varop'>`setInlinePragInfo`</span> <span class='hs-varid'>alwaysInlinePragma</span>
<a name="line-1559"></a>                       <span class='hs-varop'>`setUnfoldingInfo`</span>  <span class='hs-varid'>mkCompulsoryUnfolding</span> <span class='hs-varid'>defaultSimpleOpts</span> <span class='hs-varid'>rhs</span>
<a name="line-1560"></a>    <span class='hs-varid'>ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInfForAllTys</span>  <span class='hs-keyglyph'>[</span><span class='hs-varid'>runtimeRep1TyVar</span><span class='hs-layout'>,</span><span class='hs-varid'>runtimeRep2TyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>multiplicityTyVar1</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>$</span>
<a name="line-1561"></a>          <span class='hs-varid'>mkSpecForAllTys</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>openAlphaTyVar</span><span class='hs-layout'>,</span>  <span class='hs-varid'>openBetaTyVar</span><span class='hs-keyglyph'>]</span>    <span class='hs-varop'>$</span>
<a name="line-1562"></a>          <span class='hs-varid'>exprType</span> <span class='hs-varid'>body</span>
<a name="line-1563"></a>    <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTemplateLocals</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>mkVisFunTy</span> <span class='hs-varid'>mult</span> <span class='hs-varid'>openAlphaTy</span> <span class='hs-varid'>openBetaTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>openAlphaTy</span><span class='hs-keyglyph'>]</span>
<a name="line-1564"></a>
<a name="line-1565"></a>    <span class='hs-varid'>mult</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>multiplicityTyVar1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Mult</span>
<a name="line-1566"></a>    <span class='hs-varid'>xmult</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdMult</span> <span class='hs-varid'>x</span> <span class='hs-varid'>mult</span>
<a name="line-1567"></a>
<a name="line-1568"></a>    <span class='hs-varid'>rhs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>runtimeRep1TyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>runtimeRep2TyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>multiplicityTyVar1</span>
<a name="line-1569"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>openAlphaTyVar</span><span class='hs-layout'>,</span>   <span class='hs-varid'>openBetaTyVar</span>   <span class='hs-keyglyph'>]</span> <span class='hs-varid'>body</span>
<a name="line-1570"></a>    <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-layout'>,</span><span class='hs-varid'>xmult</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>$</span> <span class='hs-conid'>App</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>xmult</span><span class='hs-layout'>)</span>
<a name="line-1571"></a>
<a name="line-1572"></a><a name="rightSectionId"></a><span class='hs-comment'>-- See Note [Left and right sections] in GHC.Rename.Expr</span>
<a name="line-1573"></a><span class='hs-comment'>-- See Note [Wired-in Ids for rebindable syntax]</span>
<a name="line-1574"></a><span class='hs-comment'>--   rightSection :: forall r1 r2 r3 (a:TYPE r1) (b:TYPE r2) (c:TYPE r3).</span>
<a name="line-1575"></a><span class='hs-comment'>--                   (a %n1 -&gt; b %n2-&gt; c) -&gt; b %n2-&gt; a %n1-&gt; c</span>
<a name="line-1576"></a><span class='hs-comment'>--   rightSection f y x = f x y</span>
<a name="line-1577"></a><span class='hs-comment'>-- Again, multiplicity polymorphism is important</span>
<a name="line-1578"></a><span class='hs-definition'>rightSectionId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>
<a name="line-1579"></a><span class='hs-definition'>rightSectionId</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pcMiscPrelId</span> <span class='hs-varid'>rightSectionName</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>info</span>
<a name="line-1580"></a>  <span class='hs-keyword'>where</span>
<a name="line-1581"></a>    <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span> <span class='hs-varop'>`setInlinePragInfo`</span> <span class='hs-varid'>alwaysInlinePragma</span>
<a name="line-1582"></a>                       <span class='hs-varop'>`setUnfoldingInfo`</span>  <span class='hs-varid'>mkCompulsoryUnfolding</span> <span class='hs-varid'>defaultSimpleOpts</span> <span class='hs-varid'>rhs</span>
<a name="line-1583"></a>    <span class='hs-varid'>ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInfForAllTys</span>  <span class='hs-keyglyph'>[</span><span class='hs-varid'>runtimeRep1TyVar</span><span class='hs-layout'>,</span><span class='hs-varid'>runtimeRep2TyVar</span><span class='hs-layout'>,</span><span class='hs-varid'>runtimeRep3TyVar</span>
<a name="line-1584"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>multiplicityTyVar1</span><span class='hs-layout'>,</span> <span class='hs-varid'>multiplicityTyVar2</span> <span class='hs-keyglyph'>]</span> <span class='hs-varop'>$</span>
<a name="line-1585"></a>          <span class='hs-varid'>mkSpecForAllTys</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>openAlphaTyVar</span><span class='hs-layout'>,</span>  <span class='hs-varid'>openBetaTyVar</span><span class='hs-layout'>,</span>   <span class='hs-varid'>openGammaTyVar</span> <span class='hs-keyglyph'>]</span>  <span class='hs-varop'>$</span>
<a name="line-1586"></a>          <span class='hs-varid'>exprType</span> <span class='hs-varid'>body</span>
<a name="line-1587"></a>    <span class='hs-varid'>mult1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>multiplicityTyVar1</span>
<a name="line-1588"></a>    <span class='hs-varid'>mult2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>multiplicityTyVar2</span>
<a name="line-1589"></a>
<a name="line-1590"></a>    <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTemplateLocals</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mkVisFunTys</span> <span class='hs-keyglyph'>[</span> <span class='hs-conid'>Scaled</span> <span class='hs-varid'>mult1</span> <span class='hs-varid'>openAlphaTy</span>
<a name="line-1591"></a>                                             <span class='hs-layout'>,</span> <span class='hs-conid'>Scaled</span> <span class='hs-varid'>mult2</span> <span class='hs-varid'>openBetaTy</span> <span class='hs-keyglyph'>]</span> <span class='hs-varid'>openGammaTy</span>
<a name="line-1592"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>openAlphaTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>openBetaTy</span> <span class='hs-keyglyph'>]</span>
<a name="line-1593"></a>    <span class='hs-varid'>xmult</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdMult</span> <span class='hs-varid'>x</span> <span class='hs-varid'>mult1</span>
<a name="line-1594"></a>    <span class='hs-varid'>ymult</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdMult</span> <span class='hs-varid'>y</span> <span class='hs-varid'>mult2</span>
<a name="line-1595"></a>    <span class='hs-varid'>rhs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>runtimeRep1TyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>runtimeRep2TyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>runtimeRep3TyVar</span>
<a name="line-1596"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>multiplicityTyVar1</span><span class='hs-layout'>,</span> <span class='hs-varid'>multiplicityTyVar2</span>
<a name="line-1597"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>openAlphaTyVar</span><span class='hs-layout'>,</span>   <span class='hs-varid'>openBetaTyVar</span><span class='hs-layout'>,</span>    <span class='hs-varid'>openGammaTyVar</span> <span class='hs-keyglyph'>]</span> <span class='hs-varid'>body</span>
<a name="line-1598"></a>    <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-layout'>,</span><span class='hs-varid'>ymult</span><span class='hs-layout'>,</span><span class='hs-varid'>xmult</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkVarApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>xmult</span><span class='hs-layout'>,</span><span class='hs-varid'>ymult</span><span class='hs-keyglyph'>]</span>
<a name="line-1599"></a>
<a name="line-1600"></a><a name="magicDictId"></a><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<a name="line-1601"></a><span class='hs-definition'>magicDictId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>  <span class='hs-comment'>-- See Note [magicDictId magic]</span>
<a name="line-1602"></a><span class='hs-definition'>magicDictId</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pcMiscPrelId</span> <span class='hs-varid'>magicDictName</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>info</span>
<a name="line-1603"></a>  <span class='hs-keyword'>where</span>
<a name="line-1604"></a>  <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span> <span class='hs-varop'>`setInlinePragInfo`</span> <span class='hs-varid'>neverInlinePragma</span>
<a name="line-1605"></a>                     <span class='hs-varop'>`setNeverLevPoly`</span>   <span class='hs-varid'>ty</span>
<a name="line-1606"></a>  <span class='hs-varid'>ty</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSpecForAllTys</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>alphaTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>alphaTy</span>
<a name="line-1607"></a>
<a name="line-1608"></a><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<a name="line-1609"></a>
<a name="line-1610"></a><a name="coerceId"></a><span class='hs-definition'>coerceId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>
<a name="line-1611"></a><span class='hs-definition'>coerceId</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pcMiscPrelId</span> <span class='hs-varid'>coerceName</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>info</span>
<a name="line-1612"></a>  <span class='hs-keyword'>where</span>
<a name="line-1613"></a>    <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noCafIdInfo</span> <span class='hs-varop'>`setInlinePragInfo`</span> <span class='hs-varid'>alwaysInlinePragma</span>
<a name="line-1614"></a>                       <span class='hs-varop'>`setUnfoldingInfo`</span>  <span class='hs-varid'>mkCompulsoryUnfolding</span> <span class='hs-varid'>defaultSimpleOpts</span> <span class='hs-varid'>rhs</span>
<a name="line-1615"></a>    <span class='hs-varid'>eqRTy</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>coercibleTyCon</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>tYPE</span> <span class='hs-varid'>r</span> <span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>]</span>
<a name="line-1616"></a>    <span class='hs-varid'>eqRPrimTy</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>eqReprPrimTyCon</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>tYPE</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>tYPE</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>]</span>
<a name="line-1617"></a>    <span class='hs-varid'>ty</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInvisForAllTys</span> <span class='hs-keyglyph'>[</span> <span class='hs-conid'>Bndr</span> <span class='hs-varid'>rv</span> <span class='hs-conid'>InferredSpec</span>
<a name="line-1618"></a>                                 <span class='hs-layout'>,</span> <span class='hs-conid'>Bndr</span> <span class='hs-varid'>av</span> <span class='hs-conid'>SpecifiedSpec</span>
<a name="line-1619"></a>                                 <span class='hs-layout'>,</span> <span class='hs-conid'>Bndr</span> <span class='hs-varid'>bv</span> <span class='hs-conid'>SpecifiedSpec</span>
<a name="line-1620"></a>                                 <span class='hs-keyglyph'>]</span> <span class='hs-varop'>$</span>
<a name="line-1621"></a>                <span class='hs-varid'>mkInvisFunTyMany</span> <span class='hs-varid'>eqRTy</span> <span class='hs-varop'>$</span>
<a name="line-1622"></a>                <span class='hs-varid'>mkVisFunTyMany</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span>
<a name="line-1623"></a>
<a name="line-1624"></a>    <span class='hs-varid'>bndrs</span><span class='hs-keyglyph'>@</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>rv</span><span class='hs-layout'>,</span><span class='hs-varid'>av</span><span class='hs-layout'>,</span><span class='hs-varid'>bv</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTemplateKiTyVar</span> <span class='hs-varid'>runtimeRepTy</span>
<a name="line-1625"></a>                        <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>r</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>tYPE</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>tYPE</span> <span class='hs-varid'>r</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1626"></a>
<a name="line-1627"></a>    <span class='hs-keyglyph'>[</span><span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTys</span> <span class='hs-varid'>bndrs</span>
<a name="line-1628"></a>
<a name="line-1629"></a>    <span class='hs-keyglyph'>[</span><span class='hs-varid'>eqR</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>eq</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTemplateLocals</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>eqRTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>eqRPrimTy</span><span class='hs-keyglyph'>]</span>
<a name="line-1630"></a>    <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>eqR</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1631"></a>          <span class='hs-varid'>mkWildCase</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>eqR</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>unrestricted</span> <span class='hs-varid'>eqRTy</span><span class='hs-layout'>)</span> <span class='hs-varid'>b</span> <span class='hs-varop'>$</span>
<a name="line-1632"></a>          <span class='hs-keyglyph'>[</span><span class='hs-conid'>Alt</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>coercibleDataCon</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>eq</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCoVarCo</span> <span class='hs-varid'>eq</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1633"></a>
<a name="line-1634"></a><span class='hs-comment'>{-
<a name="line-1635"></a>Note [seqId magic]
<a name="line-1636"></a>~~~~~~~~~~~~~~~~~~
<a name="line-1637"></a>'GHC.Prim.seq' is special in several ways.
<a name="line-1638"></a>
<a name="line-1639"></a>a) Its fixity is set in GHC.Iface.Load.ghcPrimIface
<a name="line-1640"></a>
<a name="line-1641"></a>b) It has quite a bit of desugaring magic.
<a name="line-1642"></a>   See GHC.HsToCore.Utils Note [Desugaring seq] (1) and (2) and (3)
<a name="line-1643"></a>
<a name="line-1644"></a>c) There is some special rule handing: Note [User-defined RULES for seq]
<a name="line-1645"></a>
<a name="line-1646"></a>Historical note:
<a name="line-1647"></a>    In GHC.Tc.Gen.Expr we used to need a special typing rule for 'seq', to handle calls
<a name="line-1648"></a>    whose second argument had an unboxed type, e.g.  x `seq` 3#
<a name="line-1649"></a>
<a name="line-1650"></a>    However, with levity polymorphism we can now give seq the type seq ::
<a name="line-1651"></a>    forall (r :: RuntimeRep) a (b :: TYPE r). a -&gt; b -&gt; b which handles this
<a name="line-1652"></a>    case without special treatment in the typechecker.
<a name="line-1653"></a>
<a name="line-1654"></a>Note [User-defined RULES for seq]
<a name="line-1655"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1656"></a>Roman found situations where he had
<a name="line-1657"></a>      case (f n) of _ -&gt; e
<a name="line-1658"></a>where he knew that f (which was strict in n) would terminate if n did.
<a name="line-1659"></a>Notice that the result of (f n) is discarded. So it makes sense to
<a name="line-1660"></a>transform to
<a name="line-1661"></a>      case n of _ -&gt; e
<a name="line-1662"></a>
<a name="line-1663"></a>Rather than attempt some general analysis to support this, I've added
<a name="line-1664"></a>enough support that you can do this using a rewrite rule:
<a name="line-1665"></a>
<a name="line-1666"></a>  RULE "f/seq" forall n.  seq (f n) = seq n
<a name="line-1667"></a>
<a name="line-1668"></a>You write that rule.  When GHC sees a case expression that discards
<a name="line-1669"></a>its result, it mentally transforms it to a call to 'seq' and looks for
<a name="line-1670"></a>a RULE.  (This is done in GHC.Core.Opt.Simplify.trySeqRules.)  As usual, the
<a name="line-1671"></a>correctness of the rule is up to you.
<a name="line-1672"></a>
<a name="line-1673"></a>VERY IMPORTANT: to make this work, we give the RULE an arity of 1, not 2.
<a name="line-1674"></a>If we wrote
<a name="line-1675"></a>  RULE "f/seq" forall n e.  seq (f n) e = seq n e
<a name="line-1676"></a>with rule arity 2, then two bad things would happen:
<a name="line-1677"></a>
<a name="line-1678"></a>  - The magical desugaring done in Note [seqId magic] item (b)
<a name="line-1679"></a>    for saturated application of 'seq' would turn the LHS into
<a name="line-1680"></a>    a case expression!
<a name="line-1681"></a>
<a name="line-1682"></a>  - The code in GHC.Core.Opt.Simplify.rebuildCase would need to actually supply
<a name="line-1683"></a>    the value argument, which turns out to be awkward.
<a name="line-1684"></a>
<a name="line-1685"></a>See also: Note [User-defined RULES for seq] in GHC.Core.Opt.Simplify.
<a name="line-1686"></a>
<a name="line-1687"></a>
<a name="line-1688"></a>Note [lazyId magic]
<a name="line-1689"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-1690"></a>lazy :: forall a. a -&gt; a
<a name="line-1691"></a>
<a name="line-1692"></a>'lazy' is used to make sure that a sub-expression, and its free variables,
<a name="line-1693"></a>are truly used call-by-need, with no code motion.  Key examples:
<a name="line-1694"></a>
<a name="line-1695"></a>* pseq:    pseq a b = a `seq` lazy b
<a name="line-1696"></a>  We want to make sure that the free vars of 'b' are not evaluated
<a name="line-1697"></a>  before 'a', even though the expression is plainly strict in 'b'.
<a name="line-1698"></a>
<a name="line-1699"></a>* catch:   catch a b = catch# (lazy a) b
<a name="line-1700"></a>  Again, it's clear that 'a' will be evaluated strictly (and indeed
<a name="line-1701"></a>  applied to a state token) but we want to make sure that any exceptions
<a name="line-1702"></a>  arising from the evaluation of 'a' are caught by the catch (see
<a name="line-1703"></a>  #11555).
<a name="line-1704"></a>
<a name="line-1705"></a>Implementing 'lazy' is a bit tricky:
<a name="line-1706"></a>
<a name="line-1707"></a>* It must not have a strictness signature: by being a built-in Id,
<a name="line-1708"></a>  all the info about lazyId comes from here, not from GHC.Magic.hi.
<a name="line-1709"></a>  This is important, because the strictness analyser will spot it as
<a name="line-1710"></a>  strict!
<a name="line-1711"></a>
<a name="line-1712"></a>* It must not have an unfolding: it gets "inlined" by a HACK in
<a name="line-1713"></a>  CorePrep. It's very important to do this inlining *after* unfoldings
<a name="line-1714"></a>  are exposed in the interface file.  Otherwise, the unfolding for
<a name="line-1715"></a>  (say) pseq in the interface file will not mention 'lazy', so if we
<a name="line-1716"></a>  inline 'pseq' we'll totally miss the very thing that 'lazy' was
<a name="line-1717"></a>  there for in the first place. See #3259 for a real world
<a name="line-1718"></a>  example.
<a name="line-1719"></a>
<a name="line-1720"></a>* Suppose CorePrep sees (catch# (lazy e) b).  At all costs we must
<a name="line-1721"></a>  avoid using call by value here:
<a name="line-1722"></a>     case e of r -&gt; catch# r b
<a name="line-1723"></a>  Avoiding that is the whole point of 'lazy'.  So in CorePrep (which
<a name="line-1724"></a>  generate the 'case' expression for a call-by-value call) we must
<a name="line-1725"></a>  spot the 'lazy' on the arg (in CorePrep.cpeApp), and build a 'let'
<a name="line-1726"></a>  instead.
<a name="line-1727"></a>
<a name="line-1728"></a>* lazyId is defined in GHC.Base, so we don't *have* to inline it.  If it
<a name="line-1729"></a>  appears un-applied, we'll end up just calling it.
<a name="line-1730"></a>
<a name="line-1731"></a>Note [noinlineId magic]
<a name="line-1732"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1733"></a>'noinline' is used to make sure that a function f is never inlined,
<a name="line-1734"></a>e.g., as in 'noinline f x'.  We won't inline f because we never inline
<a name="line-1735"></a>lone variables (see Note [Lone variables] in GHC.Core.Unfold
<a name="line-1736"></a>
<a name="line-1737"></a>You might think that we could implement noinline like this:
<a name="line-1738"></a>   {-# NOINLINE #-}
<a name="line-1739"></a>   noinline :: forall a. a -&gt; a
<a name="line-1740"></a>   noinline x = x
<a name="line-1741"></a>
<a name="line-1742"></a>But actually we give 'noinline' a wired-in name for three distinct reasons:
<a name="line-1743"></a>
<a name="line-1744"></a>1. We don't want to leave a (useless) call to noinline in the final program,
<a name="line-1745"></a>   to be executed at runtime. So we have a little bit of magic to
<a name="line-1746"></a>   optimize away 'noinline' after we are done running the simplifier.
<a name="line-1747"></a>   This is done in GHC.CoreToStg.Prep.cpeApp.
<a name="line-1748"></a>
<a name="line-1749"></a>2. 'noinline' sometimes gets inserted automatically when we serialize an
<a name="line-1750"></a>   expression to the interface format, in GHC.CoreToIface.toIfaceVar.
<a name="line-1751"></a>   See Note [Inlining and hs-boot files] in GHC.CoreToIface
<a name="line-1752"></a>
<a name="line-1753"></a>3. Given foo :: Eq a =&gt; [a] -&gt; Bool, the expression
<a name="line-1754"></a>     noinline foo x xs
<a name="line-1755"></a>   where x::Int, will naturally desugar to
<a name="line-1756"></a>      noinline @Int (foo @Int dEqInt) x xs
<a name="line-1757"></a>   But now it's entirely possible htat (foo @Int dEqInt) will inline foo,
<a name="line-1758"></a>   since 'foo' is no longer a lone variable -- see #18995
<a name="line-1759"></a>
<a name="line-1760"></a>   Solution: in the desugarer, rewrite
<a name="line-1761"></a>      noinline (f x y)  ==&gt;  noinline f x y
<a name="line-1762"></a>   This is done in GHC.HsToCore.Utils.mkCoreAppDs.
<a name="line-1763"></a>
<a name="line-1764"></a>Note that noinline as currently implemented can hide some simplifications since
<a name="line-1765"></a>it hides strictness from the demand analyser. Specifically, the demand analyser
<a name="line-1766"></a>will treat 'noinline f x' as lazy in 'x', even if the demand signature of 'f'
<a name="line-1767"></a>specifies that it is strict in its argument. We considered fixing this this by adding a
<a name="line-1768"></a>special case to the demand analyser to address #16588. However, the special
<a name="line-1769"></a>case seemed like a large and expensive hammer to address a rare case and
<a name="line-1770"></a>consequently we rather opted to use a more minimal solution.
<a name="line-1771"></a>
<a name="line-1772"></a>Note [The oneShot function]
<a name="line-1773"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1774"></a>In the context of making left-folds fuse somewhat okish (see ticket #7994
<a name="line-1775"></a>and Note [Left folds via right fold]) it was determined that it would be useful
<a name="line-1776"></a>if library authors could explicitly tell the compiler that a certain lambda is
<a name="line-1777"></a>called at most once. The oneShot function allows that.
<a name="line-1778"></a>
<a name="line-1779"></a>'oneShot' is levity-polymorphic, i.e. the type variables can refer to unlifted
<a name="line-1780"></a>types as well (#10744); e.g.
<a name="line-1781"></a>   oneShot (\x:Int# -&gt; x +# 1#)
<a name="line-1782"></a>
<a name="line-1783"></a>Like most magic functions it has a compulsory unfolding, so there is no need
<a name="line-1784"></a>for a real definition somewhere. We have one in GHC.Magic for the convenience
<a name="line-1785"></a>of putting the documentation there.
<a name="line-1786"></a>
<a name="line-1787"></a>It uses `setOneShotLambda` on the lambda's binder. That is the whole magic:
<a name="line-1788"></a>
<a name="line-1789"></a>A typical call looks like
<a name="line-1790"></a>     oneShot (\y. e)
<a name="line-1791"></a>after unfolding the definition `oneShot = \f \x[oneshot]. f x` we get
<a name="line-1792"></a>     (\f \x[oneshot]. f x) (\y. e)
<a name="line-1793"></a> --&gt; \x[oneshot]. ((\y.e) x)
<a name="line-1794"></a> --&gt; \x[oneshot] e[x/y]
<a name="line-1795"></a>which is what we want.
<a name="line-1796"></a>
<a name="line-1797"></a>It is only effective if the one-shot info survives as long as possible; in
<a name="line-1798"></a>particular it must make it into the interface in unfoldings. See Note [Preserve
<a name="line-1799"></a>OneShotInfo] in GHC.Core.Tidy.
<a name="line-1800"></a>
<a name="line-1801"></a>Also see https://gitlab.haskell.org/ghc/ghc/wikis/one-shot.
<a name="line-1802"></a>
<a name="line-1803"></a>
<a name="line-1804"></a>Note [magicDictId magic]
<a name="line-1805"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1806"></a>The identifier `magicDict` is just a place-holder, which is used to
<a name="line-1807"></a>implement a primitive that we cannot define in Haskell but we can write
<a name="line-1808"></a>in Core.  It is declared with a place-holder type:
<a name="line-1809"></a>
<a name="line-1810"></a>    magicDict :: forall a. a
<a name="line-1811"></a>
<a name="line-1812"></a>The intention is that the identifier will be used in a very specific way,
<a name="line-1813"></a>to create dictionaries for classes with a single method.  Consider a class
<a name="line-1814"></a>like this:
<a name="line-1815"></a>
<a name="line-1816"></a>   class C a where
<a name="line-1817"></a>     f :: T a
<a name="line-1818"></a>
<a name="line-1819"></a>We are going to use `magicDict`, in conjunction with a built-in Prelude
<a name="line-1820"></a>rule, to cast values of type `T a` into dictionaries for `C a`.  To do
<a name="line-1821"></a>this, we define a function like this in the library:
<a name="line-1822"></a>
<a name="line-1823"></a>  data WrapC a b = WrapC (C a =&gt; Proxy a -&gt; b)
<a name="line-1824"></a>
<a name="line-1825"></a>  withT :: (C a =&gt; Proxy a -&gt; b)
<a name="line-1826"></a>        -&gt;  T a -&gt; Proxy a -&gt; b
<a name="line-1827"></a>  withT f x y = magicDict (WrapC f) x y
<a name="line-1828"></a>
<a name="line-1829"></a>The purpose of `WrapC` is to avoid having `f` instantiated.
<a name="line-1830"></a>Also, it avoids impredicativity, because `magicDict`'s type
<a name="line-1831"></a>cannot be instantiated with a forall.  The field of `WrapC` contains
<a name="line-1832"></a>a `Proxy` parameter which is used to link the type of the constraint,
<a name="line-1833"></a>`C a`, with the type of the `Wrap` value being made.
<a name="line-1834"></a>
<a name="line-1835"></a>Next, we add a built-in Prelude rule (see GHC.Core.Opt.ConstantFold),
<a name="line-1836"></a>which will replace the RHS of this definition with the appropriate
<a name="line-1837"></a>definition in Core.  The rewrite rule works as follows:
<a name="line-1838"></a>
<a name="line-1839"></a>  magicDict @t (wrap @a @b f) x y
<a name="line-1840"></a>----&gt;
<a name="line-1841"></a>  f (x `cast` co a) y
<a name="line-1842"></a>
<a name="line-1843"></a>The `co` coercion is the newtype-coercion extracted from the type-class.
<a name="line-1844"></a>The type class is obtained by looking at the type of wrap.
<a name="line-1845"></a>
<a name="line-1846"></a>In the constant folding rule it's very import to make sure to strip all ticks
<a name="line-1847"></a>from the expression as if there's an occurence of
<a name="line-1848"></a>magicDict we *must* convert it for correctness. See #19667 for where this went
<a name="line-1849"></a>wrong in GHCi.
<a name="line-1850"></a>
<a name="line-1851"></a>
<a name="line-1852"></a>-------------------------------------------------------------
<a name="line-1853"></a>@realWorld#@ used to be a magic literal, \tr{void#}.  If things get
<a name="line-1854"></a>nasty as-is, change it back to a literal (@Literal@).
<a name="line-1855"></a>
<a name="line-1856"></a>voidArgId is a Local Id used simply as an argument in functions
<a name="line-1857"></a>where we just want an arg to avoid having a thunk of unlifted type.
<a name="line-1858"></a>E.g.
<a name="line-1859"></a>        x = \ void :: Void# -&gt; (# p, q #)
<a name="line-1860"></a>
<a name="line-1861"></a>This comes up in strictness analysis
<a name="line-1862"></a>
<a name="line-1863"></a>Note [evaldUnfoldings]
<a name="line-1864"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1865"></a>The evaldUnfolding makes it look that some primitive value is
<a name="line-1866"></a>evaluated, which in turn makes Simplify.interestingArg return True,
<a name="line-1867"></a>which in turn makes INLINE things applied to said value likely to be
<a name="line-1868"></a>inlined.
<a name="line-1869"></a>-}</span>
<a name="line-1870"></a>
<a name="line-1871"></a><a name="realWorldPrimId"></a><span class='hs-definition'>realWorldPrimId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>   <span class='hs-comment'>-- :: State# RealWorld</span>
<a name="line-1872"></a><span class='hs-definition'>realWorldPrimId</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pcMiscPrelId</span> <span class='hs-varid'>realWorldName</span> <span class='hs-varid'>realWorldStatePrimTy</span>
<a name="line-1873"></a>                     <span class='hs-layout'>(</span><span class='hs-varid'>noCafIdInfo</span> <span class='hs-varop'>`setUnfoldingInfo`</span> <span class='hs-varid'>evaldUnfolding</span>    <span class='hs-comment'>-- Note [evaldUnfoldings]</span>
<a name="line-1874"></a>                                  <span class='hs-varop'>`setOneShotInfo`</span>   <span class='hs-varid'>stateHackOneShot</span>
<a name="line-1875"></a>                                  <span class='hs-varop'>`setNeverLevPoly`</span>  <span class='hs-varid'>realWorldStatePrimTy</span><span class='hs-layout'>)</span>
<a name="line-1876"></a>
<a name="line-1877"></a><a name="voidPrimId"></a><span class='hs-definition'>voidPrimId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>     <span class='hs-comment'>-- Global constant :: Void#</span>
<a name="line-1878"></a>                     <span class='hs-comment'>-- The type Void# is now the same as (# #) (ticket #18441),</span>
<a name="line-1879"></a>                     <span class='hs-comment'>-- this identifier just signifies the (# #) datacon</span>
<a name="line-1880"></a>                     <span class='hs-comment'>-- and is kept for backwards compatibility.</span>
<a name="line-1881"></a>                     <span class='hs-comment'>-- We cannot define it in normal Haskell, since it's</span>
<a name="line-1882"></a>                     <span class='hs-comment'>-- a top-level unlifted value.</span>
<a name="line-1883"></a><span class='hs-definition'>voidPrimId</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pcMiscPrelId</span> <span class='hs-varid'>voidPrimIdName</span> <span class='hs-varid'>unboxedUnitTy</span>
<a name="line-1884"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>noCafIdInfo</span> <span class='hs-varop'>`setUnfoldingInfo`</span> <span class='hs-varid'>mkCompulsoryUnfolding</span> <span class='hs-varid'>defaultSimpleOpts</span> <span class='hs-varid'>rhs</span>
<a name="line-1885"></a>                             <span class='hs-varop'>`setNeverLevPoly`</span>  <span class='hs-varid'>unboxedUnitTy</span><span class='hs-layout'>)</span>
<a name="line-1886"></a>    <span class='hs-keyword'>where</span> <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConWorkId</span> <span class='hs-varid'>unboxedUnitDataCon</span><span class='hs-layout'>)</span>
<a name="line-1887"></a>
<a name="line-1888"></a>
<a name="line-1889"></a><a name="voidArgId"></a><span class='hs-definition'>voidArgId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>       <span class='hs-comment'>-- Local lambda-bound :: Void#</span>
<a name="line-1890"></a><span class='hs-definition'>voidArgId</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSysLocal</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"void"</span><span class='hs-layout'>)</span> <span class='hs-varid'>voidArgIdKey</span> <span class='hs-conid'>Many</span> <span class='hs-varid'>unboxedUnitTy</span>
<a name="line-1891"></a>
<a name="line-1892"></a><a name="coercionTokenId"></a><span class='hs-definition'>coercionTokenId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>         <span class='hs-comment'>-- :: () ~# ()</span>
<a name="line-1893"></a><span class='hs-definition'>coercionTokenId</span> <span class='hs-comment'>-- See Note [Coercion tokens] in "GHC.CoreToStg"</span>
<a name="line-1894"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pcMiscPrelId</span> <span class='hs-varid'>coercionTokenName</span>
<a name="line-1895"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>eqPrimTyCon</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>liftedTypeKind</span><span class='hs-layout'>,</span> <span class='hs-varid'>liftedTypeKind</span><span class='hs-layout'>,</span> <span class='hs-varid'>unitTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>unitTy</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1896"></a>                 <span class='hs-varid'>noCafIdInfo</span>
<a name="line-1897"></a>
<a name="line-1898"></a><a name="pcMiscPrelId"></a><span class='hs-definition'>pcMiscPrelId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IdInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-1899"></a><span class='hs-definition'>pcMiscPrelId</span> <span class='hs-varid'>name</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>info</span>
<a name="line-1900"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVanillaGlobalWithInfo</span> <span class='hs-varid'>name</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>info</span>
</pre></body>
</html>

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Language/Haskell/Syntax/Pat.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE ConstraintKinds #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE DeriveTraversable #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE FlexibleContexts #-}</span>
<a name="line-5"></a><span class='hs-comment'>{-# LANGUAGE FlexibleInstances #-}</span>
<a name="line-6"></a><span class='hs-comment'>{-# LANGUAGE ScopedTypeVariables #-}</span>
<a name="line-7"></a><span class='hs-comment'>{-# LANGUAGE TypeApplications #-}</span>
<a name="line-8"></a><span class='hs-comment'>{-# LANGUAGE TypeFamilies #-}</span>
<a name="line-9"></a><span class='hs-comment'>{-# LANGUAGE UndecidableInstances #-}</span> <span class='hs-comment'>-- Wrinkle in Note [Trees That Grow]</span>
<a name="line-10"></a>                                      <span class='hs-comment'>-- in module Language.Haskell.Syntax.Extension</span>
<a name="line-11"></a><span class='hs-comment'>{-# LANGUAGE ViewPatterns #-}</span>
<a name="line-12"></a><span class='hs-comment'>{-
<a name="line-13"></a>(c) The University of Glasgow 2006
<a name="line-14"></a>(c) The GRASP/AQUA Project, Glasgow University, 1992-1998
<a name="line-15"></a>
<a name="line-16"></a>\section[PatSyntax]{Abstract Haskell syntax---patterns}
<a name="line-17"></a>-}</span>
<a name="line-18"></a>
<a name="line-19"></a><span class='hs-comment'>-- See Note [Language.Haskell.Syntax.* Hierarchy] for why not GHC.Hs.*</span>
<a name="line-20"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Language.Haskell.Syntax.Pat</span> <span class='hs-layout'>(</span>
<a name="line-21"></a>        <span class='hs-conid'>Pat</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>LPat</span><span class='hs-layout'>,</span>
<a name="line-22"></a>        <span class='hs-conid'>ConLikeP</span><span class='hs-layout'>,</span>
<a name="line-23"></a>
<a name="line-24"></a>        <span class='hs-conid'>HsConPatDetails</span><span class='hs-layout'>,</span> <span class='hs-varid'>hsConPatArgs</span><span class='hs-layout'>,</span>
<a name="line-25"></a>        <span class='hs-conid'>HsRecFields</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>HsRecField'</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsRecField'</span><span class='hs-layout'>,</span>
<a name="line-26"></a>        <span class='hs-conid'>HsRecField</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsRecField</span><span class='hs-layout'>,</span>
<a name="line-27"></a>        <span class='hs-conid'>HsRecUpdField</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsRecUpdField</span><span class='hs-layout'>,</span>
<a name="line-28"></a>        <span class='hs-varid'>hsRecFields</span><span class='hs-layout'>,</span> <span class='hs-varid'>hsRecFieldSel</span><span class='hs-layout'>,</span> <span class='hs-varid'>hsRecFieldsArgs</span><span class='hs-layout'>,</span>
<a name="line-29"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-30"></a>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-32"></a>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>Language.Haskell.Syntax.Expr</span> <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>HsSplice</span><span class='hs-layout'>)</span>
<a name="line-34"></a>
<a name="line-35"></a><span class='hs-comment'>-- friends:</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Language.Haskell.Syntax.Lit</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Language.Haskell.Syntax.Extension</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Language.Haskell.Syntax.Type</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-40"></a><span class='hs-comment'>-- others:</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Ppr</span> <span class='hs-layout'>(</span> <span class='hs-comment'>{- instance OutputableBndr TyVar -}</span> <span class='hs-layout'>)</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.SrcLoc</span>
<a name="line-44"></a><span class='hs-comment'>-- libraries:</span>
<a name="line-45"></a>
<a name="line-46"></a><a name="LPat"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-47"></a>
<a name="line-48"></a><span class='hs-comment'>-- | Pattern</span>
<a name="line-49"></a><span class='hs-comment'>--</span>
<a name="line-50"></a><span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnBang'</span>
<a name="line-51"></a>
<a name="line-52"></a><a name="Pat"></a><span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-53"></a><a name="Pat"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Pat</span> <span class='hs-varid'>p</span>
<a name="line-54"></a>  <span class='hs-keyglyph'>=</span>     <span class='hs-comment'>------------ Simple patterns ---------------</span>
<a name="line-55"></a>    <span class='hs-conid'>WildPat</span>     <span class='hs-layout'>(</span><span class='hs-conid'>XWildPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- ^ Wildcard Pattern</span>
<a name="line-56"></a>        <span class='hs-comment'>-- The sole reason for a type on a WildPat is to</span>
<a name="line-57"></a>        <span class='hs-comment'>-- support hsPatType :: Pat Id -&gt; Type</span>
<a name="line-58"></a>
<a name="line-59"></a>       <span class='hs-comment'>-- AZ:TODO above comment needs to be updated</span>
<a name="line-60"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>VarPat</span>      <span class='hs-layout'>(</span><span class='hs-conid'>XVarPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-61"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LIdP</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- ^ Variable Pattern</span>
<a name="line-62"></a>
<a name="line-63"></a>                             <span class='hs-comment'>-- See Note [Located RdrNames] in GHC.Hs.Expr</span>
<a name="line-64"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LazyPat</span>     <span class='hs-layout'>(</span><span class='hs-conid'>XLazyPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-65"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>                <span class='hs-comment'>-- ^ Lazy Pattern</span>
<a name="line-66"></a>    <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnTilde'</span>
<a name="line-67"></a>
<a name="line-68"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-69"></a>
<a name="line-70"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AsPat</span>       <span class='hs-layout'>(</span><span class='hs-conid'>XAsPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-71"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LIdP</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- ^ As pattern</span>
<a name="line-72"></a>    <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnAt'</span>
<a name="line-73"></a>
<a name="line-74"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-75"></a>
<a name="line-76"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ParPat</span>      <span class='hs-layout'>(</span><span class='hs-conid'>XParPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-77"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>                <span class='hs-comment'>-- ^ Parenthesised pattern</span>
<a name="line-78"></a>                                        <span class='hs-comment'>-- See Note [Parens in HsSyn] in GHC.Hs.Expr</span>
<a name="line-79"></a>    <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'('@,</span>
<a name="line-80"></a>    <span class='hs-comment'>--                                    'GHC.Parser.Annotation.AnnClose' @')'@</span>
<a name="line-81"></a>
<a name="line-82"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-83"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>BangPat</span>     <span class='hs-layout'>(</span><span class='hs-conid'>XBangPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-84"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>                <span class='hs-comment'>-- ^ Bang pattern</span>
<a name="line-85"></a>    <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnBang'</span>
<a name="line-86"></a>
<a name="line-87"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-88"></a>
<a name="line-89"></a>        <span class='hs-comment'>------------ Lists, tuples, arrays ---------------</span>
<a name="line-90"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ListPat</span>     <span class='hs-layout'>(</span><span class='hs-conid'>XListPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-91"></a>                <span class='hs-keyglyph'>[</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span>
<a name="line-92"></a>                   <span class='hs-comment'>-- For OverloadedLists a Just (ty,fn) gives</span>
<a name="line-93"></a>                   <span class='hs-comment'>-- overall type of the pattern, and the toList</span>
<a name="line-94"></a><span class='hs-comment'>-- function to convert the scrutinee to a list value</span>
<a name="line-95"></a>
<a name="line-96"></a>    <span class='hs-comment'>-- ^ Syntactic List</span>
<a name="line-97"></a>    <span class='hs-comment'>--</span>
<a name="line-98"></a>    <span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'['@,</span>
<a name="line-99"></a>    <span class='hs-comment'>--                                    'GHC.Parser.Annotation.AnnClose' @']'@</span>
<a name="line-100"></a>
<a name="line-101"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-102"></a>
<a name="line-103"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TuplePat</span>    <span class='hs-layout'>(</span><span class='hs-conid'>XTuplePat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-104"></a>                  <span class='hs-comment'>-- after typechecking, holds the types of the tuple components</span>
<a name="line-105"></a>                <span class='hs-keyglyph'>[</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span>         <span class='hs-comment'>-- Tuple sub-patterns</span>
<a name="line-106"></a>                <span class='hs-conid'>Boxity</span>           <span class='hs-comment'>-- UnitPat is TuplePat []</span>
<a name="line-107"></a>        <span class='hs-comment'>-- You might think that the post typechecking Type was redundant,</span>
<a name="line-108"></a>        <span class='hs-comment'>-- because we can get the pattern type by getting the types of the</span>
<a name="line-109"></a>        <span class='hs-comment'>-- sub-patterns.</span>
<a name="line-110"></a>        <span class='hs-comment'>-- But it's essential</span>
<a name="line-111"></a>        <span class='hs-comment'>--      data T a where</span>
<a name="line-112"></a>        <span class='hs-comment'>--        T1 :: Int -&gt; T Int</span>
<a name="line-113"></a>        <span class='hs-comment'>--      f :: (T a, a) -&gt; Int</span>
<a name="line-114"></a>        <span class='hs-comment'>--      f (T1 x, z) = z</span>
<a name="line-115"></a>        <span class='hs-comment'>-- When desugaring, we must generate</span>
<a name="line-116"></a>        <span class='hs-comment'>--      f = /\a. \v::a.  case v of (t::T a, w::a) -&gt;</span>
<a name="line-117"></a>        <span class='hs-comment'>--                       case t of (T1 (x::Int)) -&gt;</span>
<a name="line-118"></a>        <span class='hs-comment'>-- Note the (w::a), NOT (w::Int), because we have not yet</span>
<a name="line-119"></a>        <span class='hs-comment'>-- refined 'a' to Int.  So we must know that the second component</span>
<a name="line-120"></a>        <span class='hs-comment'>-- of the tuple is of type 'a' not Int.  See selectMatchVar</span>
<a name="line-121"></a>        <span class='hs-comment'>-- (June 14: I'm not sure this comment is right; the sub-patterns</span>
<a name="line-122"></a>        <span class='hs-comment'>--           will be wrapped in CoPats, no?)</span>
<a name="line-123"></a>    <span class='hs-comment'>-- ^ Tuple sub-patterns</span>
<a name="line-124"></a>    <span class='hs-comment'>--</span>
<a name="line-125"></a>    <span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' :</span>
<a name="line-126"></a>    <span class='hs-comment'>--            'GHC.Parser.Annotation.AnnOpen' @'('@ or @'(#'@,</span>
<a name="line-127"></a>    <span class='hs-comment'>--            'GHC.Parser.Annotation.AnnClose' @')'@ or  @'#)'@</span>
<a name="line-128"></a>
<a name="line-129"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SumPat</span>      <span class='hs-layout'>(</span><span class='hs-conid'>XSumPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- after typechecker, types of the alternative</span>
<a name="line-130"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>           <span class='hs-comment'>-- Sum sub-pattern</span>
<a name="line-131"></a>                <span class='hs-conid'>ConTag</span>             <span class='hs-comment'>-- Alternative (one-based)</span>
<a name="line-132"></a>                <span class='hs-conid'>Arity</span>              <span class='hs-comment'>-- Arity (INVARIANT: â‰¥ 2)</span>
<a name="line-133"></a>    <span class='hs-comment'>-- ^ Anonymous sum pattern</span>
<a name="line-134"></a>    <span class='hs-comment'>--</span>
<a name="line-135"></a>    <span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' :</span>
<a name="line-136"></a>    <span class='hs-comment'>--            'GHC.Parser.Annotation.AnnOpen' @'(#'@,</span>
<a name="line-137"></a>    <span class='hs-comment'>--            'GHC.Parser.Annotation.AnnClose' @'#)'@</span>
<a name="line-138"></a>
<a name="line-139"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-140"></a>
<a name="line-141"></a>        <span class='hs-comment'>------------ Constructor patterns ---------------</span>
<a name="line-142"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ConPat</span> <span class='hs-layout'>{</span>
<a name="line-143"></a>        <span class='hs-varid'>pat_con_ext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XConPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>,</span>
<a name="line-144"></a>        <span class='hs-varid'>pat_con</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConLikeP</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-145"></a>        <span class='hs-varid'>pat_args</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsConPatDetails</span> <span class='hs-varid'>p</span>
<a name="line-146"></a>    <span class='hs-layout'>}</span>
<a name="line-147"></a>    <span class='hs-comment'>-- ^ Constructor Pattern</span>
<a name="line-148"></a>
<a name="line-149"></a>        <span class='hs-comment'>------------ View patterns ---------------</span>
<a name="line-150"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnRarrow'</span>
<a name="line-151"></a>
<a name="line-152"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-153"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ViewPat</span>       <span class='hs-layout'>(</span><span class='hs-conid'>XViewPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- The overall type of the pattern</span>
<a name="line-154"></a>                                   <span class='hs-comment'>-- (= the argument type of the view function)</span>
<a name="line-155"></a>                                   <span class='hs-comment'>-- for hsPatType.</span>
<a name="line-156"></a>                  <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-157"></a>                  <span class='hs-layout'>(</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-158"></a>    <span class='hs-comment'>-- ^ View Pattern</span>
<a name="line-159"></a>
<a name="line-160"></a>        <span class='hs-comment'>------------ Pattern splices ---------------</span>
<a name="line-161"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'$('@</span>
<a name="line-162"></a>  <span class='hs-comment'>--        'GHC.Parser.Annotation.AnnClose' @')'@</span>
<a name="line-163"></a>
<a name="line-164"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-165"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SplicePat</span>       <span class='hs-layout'>(</span><span class='hs-conid'>XSplicePat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-166"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>HsSplice</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- ^ Splice Pattern (Includes quasi-quotes)</span>
<a name="line-167"></a>
<a name="line-168"></a>        <span class='hs-comment'>------------ Literal and n+k patterns ---------------</span>
<a name="line-169"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LitPat</span>          <span class='hs-layout'>(</span><span class='hs-conid'>XLitPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-170"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>HsLit</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>           <span class='hs-comment'>-- ^ Literal Pattern</span>
<a name="line-171"></a>                                        <span class='hs-comment'>-- Used for *non-overloaded* literal patterns:</span>
<a name="line-172"></a>                                        <span class='hs-comment'>-- Int#, Char#, Int, Char, String, etc.</span>
<a name="line-173"></a>
<a name="line-174"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NPat</span>                <span class='hs-comment'>-- Natural Pattern</span>
<a name="line-175"></a>                        <span class='hs-comment'>-- Used for all overloaded literals,</span>
<a name="line-176"></a>                        <span class='hs-comment'>-- including overloaded strings with -XOverloadedStrings</span>
<a name="line-177"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>XNPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>            <span class='hs-comment'>-- Overall type of pattern. Might be</span>
<a name="line-178"></a>                                         <span class='hs-comment'>-- different than the literal's type</span>
<a name="line-179"></a>                                         <span class='hs-comment'>-- if (==) or negate changes the type</span>
<a name="line-180"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsOverLit</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- ALWAYS positive</span>
<a name="line-181"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Just (Name of 'negate') for</span>
<a name="line-182"></a>                                           <span class='hs-comment'>-- negative patterns, Nothing</span>
<a name="line-183"></a>                                           <span class='hs-comment'>-- otherwise</span>
<a name="line-184"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>       <span class='hs-comment'>-- Equality checker, of type t-&gt;t-&gt;Bool</span>
<a name="line-185"></a>
<a name="line-186"></a>  <span class='hs-comment'>-- ^ Natural Pattern</span>
<a name="line-187"></a>  <span class='hs-comment'>--</span>
<a name="line-188"></a>  <span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnVal' @'+'@</span>
<a name="line-189"></a>
<a name="line-190"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-191"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NPlusKPat</span>       <span class='hs-layout'>(</span><span class='hs-conid'>XNPlusKPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>           <span class='hs-comment'>-- Type of overall pattern</span>
<a name="line-192"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>LIdP</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>                 <span class='hs-comment'>-- n+k pattern</span>
<a name="line-193"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsOverLit</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- It'll always be an HsIntegral</span>
<a name="line-194"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>HsOverLit</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>            <span class='hs-comment'>-- See Note [NPlusK patterns] in GHC.Tc.Gen.Pat</span>
<a name="line-195"></a>                     <span class='hs-comment'>-- NB: This could be (PostTc ...), but that induced a</span>
<a name="line-196"></a>                     <span class='hs-comment'>-- a new hs-boot file. Not worth it.</span>
<a name="line-197"></a>
<a name="line-198"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- (&gt;=) function, of type t1-&gt;t2-&gt;Bool</span>
<a name="line-199"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- Name of '-' (see GHC.Rename.Env.lookupSyntax)</span>
<a name="line-200"></a>  <span class='hs-comment'>-- ^ n+k pattern</span>
<a name="line-201"></a>
<a name="line-202"></a>        <span class='hs-comment'>------------ Pattern type signatures ---------------</span>
<a name="line-203"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon'</span>
<a name="line-204"></a>
<a name="line-205"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-206"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SigPat</span>          <span class='hs-layout'>(</span><span class='hs-conid'>XSigPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>             <span class='hs-comment'>-- After typechecker: Type</span>
<a name="line-207"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>                <span class='hs-comment'>-- Pattern with a type signature</span>
<a name="line-208"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>HsPatSigType</span> <span class='hs-layout'>(</span><span class='hs-conid'>NoGhcTc</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-comment'>--  Signature can bind both</span>
<a name="line-209"></a>                                               <span class='hs-comment'>--  kind and type vars</span>
<a name="line-210"></a>
<a name="line-211"></a>    <span class='hs-comment'>-- ^ Pattern with a type signature</span>
<a name="line-212"></a>
<a name="line-213"></a>  <span class='hs-comment'>-- | Trees that Grow extension point for new constructors</span>
<a name="line-214"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XPat</span>
<a name="line-215"></a>      <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-216"></a>
<a name="line-217"></a><a name="ConLikeP"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>family</span> <span class='hs-conid'>ConLikeP</span> <span class='hs-varid'>x</span>
<a name="line-218"></a>
<a name="line-219"></a>
<a name="line-220"></a><span class='hs-comment'>-- ---------------------------------------------------------------------</span>
<a name="line-221"></a>
<a name="line-222"></a>
<a name="line-223"></a><a name="HsConPatDetails"></a><span class='hs-comment'>-- | Haskell Constructor Pattern Details</span>
<a name="line-224"></a><a name="HsConPatDetails"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>HsConPatDetails</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsConDetails</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsPatSigType</span> <span class='hs-layout'>(</span><span class='hs-conid'>NoGhcTc</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsRecFields</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-225"></a>
<a name="line-226"></a><a name="hsConPatArgs"></a><span class='hs-definition'>hsConPatArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>p</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-conid'>UnXRec</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HsConPatDetails</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span>
<a name="line-227"></a><span class='hs-definition'>hsConPatArgs</span> <span class='hs-layout'>(</span><span class='hs-conid'>PrefixCon</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ps</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ps</span>
<a name="line-228"></a><span class='hs-definition'>hsConPatArgs</span> <span class='hs-layout'>(</span><span class='hs-conid'>RecCon</span> <span class='hs-varid'>fs</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>hsRecFieldArg</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unXRec</span> <span class='hs-keyglyph'>@</span><span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>rec_flds</span> <span class='hs-varid'>fs</span><span class='hs-layout'>)</span>
<a name="line-229"></a><span class='hs-definition'>hsConPatArgs</span> <span class='hs-layout'>(</span><span class='hs-conid'>InfixCon</span> <span class='hs-varid'>p1</span> <span class='hs-varid'>p2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>p1</span><span class='hs-layout'>,</span><span class='hs-varid'>p2</span><span class='hs-keyglyph'>]</span>
<a name="line-230"></a>
<a name="line-231"></a><a name="HsRecFields"></a><span class='hs-comment'>-- | Haskell Record Fields</span>
<a name="line-232"></a><a name="HsRecFields"></a><span class='hs-comment'>--</span>
<a name="line-233"></a><a name="HsRecFields"></a><span class='hs-comment'>-- HsRecFields is used only for patterns and expressions (not data type</span>
<a name="line-234"></a><a name="HsRecFields"></a><span class='hs-comment'>-- declarations)</span>
<a name="line-235"></a><a name="HsRecFields"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsRecFields</span> <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span>         <span class='hs-comment'>-- A bunch of record fields</span>
<a name="line-236"></a>                                <span class='hs-comment'>--      { x = 3, y = True }</span>
<a name="line-237"></a>        <span class='hs-comment'>-- Used for both expressions and patterns</span>
<a name="line-238"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsRecFields</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rec_flds</span>   <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsRecField</span> <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>
<a name="line-239"></a>                  <span class='hs-varid'>rec_dotdot</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Located</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>  <span class='hs-comment'>-- Note [DotDot fields]</span>
<a name="line-240"></a>  <span class='hs-comment'>-- AZ:The XRec for LHsRecField makes the derivings fail.</span>
<a name="line-241"></a>  <span class='hs-comment'>-- deriving (Functor, Foldable, Traversable)</span>
<a name="line-242"></a>
<a name="line-243"></a>
<a name="line-244"></a><span class='hs-comment'>-- Note [DotDot fields]</span>
<a name="line-245"></a><span class='hs-comment'>-- ~~~~~~~~~~~~~~~~~~~~</span>
<a name="line-246"></a><span class='hs-comment'>-- The rec_dotdot field means this:</span>
<a name="line-247"></a><span class='hs-comment'>--   Nothing =&gt; the normal case</span>
<a name="line-248"></a><span class='hs-comment'>--   Just n  =&gt; the group uses ".." notation,</span>
<a name="line-249"></a><span class='hs-comment'>--</span>
<a name="line-250"></a><span class='hs-comment'>-- In the latter case:</span>
<a name="line-251"></a><span class='hs-comment'>--</span>
<a name="line-252"></a><span class='hs-comment'>--   *before* renamer: rec_flds are exactly the n user-written fields</span>
<a name="line-253"></a><span class='hs-comment'>--</span>
<a name="line-254"></a><span class='hs-comment'>--   *after* renamer:  rec_flds includes *all* fields, with</span>
<a name="line-255"></a><span class='hs-comment'>--                     the first 'n' being the user-written ones</span>
<a name="line-256"></a><span class='hs-comment'>--                     and the remainder being 'filled in' implicitly</span>
<a name="line-257"></a>
<a name="line-258"></a><a name="LHsRecField'"></a><span class='hs-comment'>-- | Located Haskell Record Field</span>
<a name="line-259"></a><a name="LHsRecField'"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsRecField'</span> <span class='hs-varid'>p</span> <span class='hs-varid'>id</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsRecField'</span> <span class='hs-varid'>id</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-260"></a>
<a name="line-261"></a><a name="LHsRecField"></a><span class='hs-comment'>-- | Located Haskell Record Field</span>
<a name="line-262"></a><a name="LHsRecField"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsRecField</span>  <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsRecField</span>  <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-263"></a>
<a name="line-264"></a><a name="LHsRecUpdField"></a><span class='hs-comment'>-- | Located Haskell Record Update Field</span>
<a name="line-265"></a><a name="LHsRecUpdField"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsRecUpdField</span> <span class='hs-varid'>p</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsRecUpdField</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-266"></a>
<a name="line-267"></a><a name="HsRecField"></a><span class='hs-comment'>-- | Haskell Record Field</span>
<a name="line-268"></a><a name="HsRecField"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>HsRecField</span>    <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsRecField'</span> <span class='hs-layout'>(</span><span class='hs-conid'>FieldOcc</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg</span>
<a name="line-269"></a>
<a name="line-270"></a><a name="HsRecUpdField"></a><span class='hs-comment'>-- | Haskell Record Update Field</span>
<a name="line-271"></a><a name="HsRecUpdField"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>HsRecUpdField</span> <span class='hs-varid'>p</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsRecField'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AmbiguousFieldOcc</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-272"></a>
<a name="line-273"></a><a name="HsRecField'"></a><span class='hs-comment'>-- | Haskell Record Field</span>
<a name="line-274"></a><a name="HsRecField'"></a><span class='hs-comment'>--</span>
<a name="line-275"></a><a name="HsRecField'"></a><span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnEqual',</span>
<a name="line-276"></a><a name="HsRecField'"></a><span class='hs-comment'>--</span>
<a name="line-277"></a><a name="HsRecField'"></a><span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-278"></a><a name="HsRecField'"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsRecField'</span> <span class='hs-varid'>id</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsRecField</span> <span class='hs-layout'>{</span>
<a name="line-279"></a>        <span class='hs-varid'>hsRecFieldAnn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XHsRecField</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span>
<a name="line-280"></a>        <span class='hs-varid'>hsRecFieldLbl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Located</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span>
<a name="line-281"></a>        <span class='hs-varid'>hsRecFieldArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span>           <span class='hs-comment'>-- ^ Filled in by renamer when punning</span>
<a name="line-282"></a>        <span class='hs-varid'>hsRecPun</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>           <span class='hs-comment'>-- ^ Note [Punning]</span>
<a name="line-283"></a>  <span class='hs-layout'>}</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Functor</span><span class='hs-layout'>,</span> <span class='hs-conid'>Foldable</span><span class='hs-layout'>,</span> <span class='hs-conid'>Traversable</span><span class='hs-layout'>)</span>
<a name="line-284"></a>
<a name="line-285"></a>
<a name="line-286"></a><span class='hs-comment'>-- Note [Punning]</span>
<a name="line-287"></a><span class='hs-comment'>-- ~~~~~~~~~~~~~~</span>
<a name="line-288"></a><span class='hs-comment'>-- If you write T { x, y = v+1 }, the HsRecFields will be</span>
<a name="line-289"></a><span class='hs-comment'>--      HsRecField x x True ...</span>
<a name="line-290"></a><span class='hs-comment'>--      HsRecField y (v+1) False ...</span>
<a name="line-291"></a><span class='hs-comment'>-- That is, for "punned" field x is expanded (in the renamer)</span>
<a name="line-292"></a><span class='hs-comment'>-- to x=x; but with a punning flag so we can detect it later</span>
<a name="line-293"></a><span class='hs-comment'>-- (e.g. when pretty printing)</span>
<a name="line-294"></a><span class='hs-comment'>--</span>
<a name="line-295"></a><span class='hs-comment'>-- If the original field was qualified, we un-qualify it, thus</span>
<a name="line-296"></a><span class='hs-comment'>--    T { A.x } means T { A.x = x }</span>
<a name="line-297"></a>
<a name="line-298"></a>
<a name="line-299"></a><span class='hs-comment'>-- Note [HsRecField and HsRecUpdField]</span>
<a name="line-300"></a><span class='hs-comment'>-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<a name="line-301"></a>
<a name="line-302"></a><span class='hs-comment'>-- A HsRecField (used for record construction and pattern matching)</span>
<a name="line-303"></a><span class='hs-comment'>-- contains an unambiguous occurrence of a field (i.e. a FieldOcc).</span>
<a name="line-304"></a><span class='hs-comment'>-- We can't just store the Name, because thanks to</span>
<a name="line-305"></a><span class='hs-comment'>-- DuplicateRecordFields this may not correspond to the label the user</span>
<a name="line-306"></a><span class='hs-comment'>-- wrote.</span>
<a name="line-307"></a><span class='hs-comment'>--</span>
<a name="line-308"></a><span class='hs-comment'>-- A HsRecUpdField (used for record update) contains a potentially</span>
<a name="line-309"></a><span class='hs-comment'>-- ambiguous occurrence of a field (an AmbiguousFieldOcc).  The</span>
<a name="line-310"></a><span class='hs-comment'>-- renamer will fill in the selector function if it can, but if the</span>
<a name="line-311"></a><span class='hs-comment'>-- selector is ambiguous the renamer will defer to the typechecker.</span>
<a name="line-312"></a><span class='hs-comment'>-- After the typechecker, a unique selector will have been determined.</span>
<a name="line-313"></a><span class='hs-comment'>--</span>
<a name="line-314"></a><span class='hs-comment'>-- The renamer produces an Unambiguous result if it can, rather than</span>
<a name="line-315"></a><span class='hs-comment'>-- just doing the lookup in the typechecker, so that completely</span>
<a name="line-316"></a><span class='hs-comment'>-- unambiguous updates can be represented by 'GHC.HsToCore.Quote.repUpdFields'.</span>
<a name="line-317"></a><span class='hs-comment'>--</span>
<a name="line-318"></a><span class='hs-comment'>-- For example, suppose we have:</span>
<a name="line-319"></a><span class='hs-comment'>--</span>
<a name="line-320"></a><span class='hs-comment'>--     data S = MkS { x :: Int }</span>
<a name="line-321"></a><span class='hs-comment'>--     data T = MkT { x :: Int }</span>
<a name="line-322"></a><span class='hs-comment'>--</span>
<a name="line-323"></a><span class='hs-comment'>--     f z = (z { x = 3 }) :: S</span>
<a name="line-324"></a><span class='hs-comment'>--</span>
<a name="line-325"></a><span class='hs-comment'>-- The parsed HsRecUpdField corresponding to the record update will have:</span>
<a name="line-326"></a><span class='hs-comment'>--</span>
<a name="line-327"></a><span class='hs-comment'>--     hsRecFieldLbl = Unambiguous "x" noExtField :: AmbiguousFieldOcc RdrName</span>
<a name="line-328"></a><span class='hs-comment'>--</span>
<a name="line-329"></a><span class='hs-comment'>-- After the renamer, this will become:</span>
<a name="line-330"></a><span class='hs-comment'>--</span>
<a name="line-331"></a><span class='hs-comment'>--     hsRecFieldLbl = Ambiguous   "x" noExtField :: AmbiguousFieldOcc Name</span>
<a name="line-332"></a><span class='hs-comment'>--</span>
<a name="line-333"></a><span class='hs-comment'>-- (note that the Unambiguous constructor is not type-correct here).</span>
<a name="line-334"></a><span class='hs-comment'>-- The typechecker will determine the particular selector:</span>
<a name="line-335"></a><span class='hs-comment'>--</span>
<a name="line-336"></a><span class='hs-comment'>--     hsRecFieldLbl = Unambiguous "x" $sel:x:MkS  :: AmbiguousFieldOcc Id</span>
<a name="line-337"></a><span class='hs-comment'>--</span>
<a name="line-338"></a><span class='hs-comment'>-- See also Note [Disambiguating record fields] in GHC.Tc.Gen.Head.</span>
<a name="line-339"></a>
<a name="line-340"></a><a name="hsRecFields"></a><span class='hs-definition'>hsRecFields</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span><span class='hs-varop'>.</span> <span class='hs-conid'>UnXRec</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HsRecFields</span> <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>XCFieldOcc</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span>
<a name="line-341"></a><span class='hs-definition'>hsRecFields</span> <span class='hs-varid'>rbinds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>unLoc</span> <span class='hs-varop'>.</span> <span class='hs-varid'>hsRecFieldSel</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unXRec</span> <span class='hs-keyglyph'>@</span><span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>rec_flds</span> <span class='hs-varid'>rbinds</span><span class='hs-layout'>)</span>
<a name="line-342"></a>
<a name="line-343"></a><a name="hsRecFieldsArgs"></a><span class='hs-comment'>-- Probably won't typecheck at once, things have changed :/</span>
<a name="line-344"></a><span class='hs-definition'>hsRecFieldsArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span><span class='hs-varop'>.</span> <span class='hs-conid'>UnXRec</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HsRecFields</span> <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span>
<a name="line-345"></a><span class='hs-definition'>hsRecFieldsArgs</span> <span class='hs-varid'>rbinds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>hsRecFieldArg</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unXRec</span> <span class='hs-keyglyph'>@</span><span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>rec_flds</span> <span class='hs-varid'>rbinds</span><span class='hs-layout'>)</span>
<a name="line-346"></a>
<a name="line-347"></a><a name="hsRecFieldSel"></a><span class='hs-definition'>hsRecFieldSel</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsRecField</span> <span class='hs-varid'>pass</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Located</span> <span class='hs-layout'>(</span><span class='hs-conid'>XCFieldOcc</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-348"></a><span class='hs-definition'>hsRecFieldSel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmap</span> <span class='hs-varid'>extFieldOcc</span> <span class='hs-varop'>.</span> <span class='hs-varid'>hsRecFieldLbl</span>
<a name="line-349"></a>
<a name="line-350"></a>
<a name="line-351"></a><span class='hs-comment'>{-
<a name="line-352"></a>************************************************************************
<a name="line-353"></a>*                                                                      *
<a name="line-354"></a>*              Printing patterns
<a name="line-355"></a>*                                                                      *
<a name="line-356"></a>************************************************************************
<a name="line-357"></a>-}</span>
<a name="line-358"></a>
<a name="line-359"></a><a name="instance%20Outputable%20(HsRecFields%20p%20arg)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Outputable</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsRecField</span> <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-360"></a>      <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsRecFields</span> <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-361"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsRecFields</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rec_flds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flds</span><span class='hs-layout'>,</span> <span class='hs-varid'>rec_dotdot</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-362"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsep</span> <span class='hs-layout'>(</span><span class='hs-varid'>punctuate</span> <span class='hs-varid'>comma</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>flds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-363"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsRecFields</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rec_flds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flds</span><span class='hs-layout'>,</span> <span class='hs-varid'>rec_dotdot</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>unLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-364"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsep</span> <span class='hs-layout'>(</span><span class='hs-varid'>punctuate</span> <span class='hs-varid'>comma</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>take</span> <span class='hs-varid'>n</span> <span class='hs-varid'>flds</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>dotdot</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-365"></a>        <span class='hs-keyword'>where</span>
<a name="line-366"></a>          <span class='hs-varid'>dotdot</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>".."</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>whenPprDebug</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>drop</span> <span class='hs-varid'>n</span> <span class='hs-varid'>flds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-367"></a>
<a name="line-368"></a><a name="instance%20Outputable%20(HsRecField'%20p%20arg)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Outputable</span> <span class='hs-varid'>p</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutputableBndr</span> <span class='hs-varid'>p</span><span class='hs-layout'>,</span> <span class='hs-conid'>Outputable</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-369"></a>      <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsRecField'</span> <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-370"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsRecField</span> <span class='hs-layout'>{</span> <span class='hs-varid'>hsRecFieldLbl</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>L</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-varid'>hsRecFieldArg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span>
<a name="line-371"></a>                    <span class='hs-varid'>hsRecPun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pun</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-372"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPrefixOcc</span> <span class='hs-varid'>f</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppUnless</span> <span class='hs-varid'>pun</span> <span class='hs-varop'>$</span> <span class='hs-varid'>equals</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
</pre></body>
</html>

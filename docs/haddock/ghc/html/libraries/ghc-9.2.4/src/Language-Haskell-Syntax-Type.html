<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Language/Haskell/Syntax/Type.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE ConstraintKinds #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE DeriveDataTypeable #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE FlexibleContexts #-}</span>
<a name="line-5"></a><span class='hs-comment'>{-# LANGUAGE FlexibleInstances #-}</span>
<a name="line-6"></a><span class='hs-comment'>{-# LANGUAGE ScopedTypeVariables #-}</span>
<a name="line-7"></a><span class='hs-comment'>{-# LANGUAGE StandaloneDeriving #-}</span>
<a name="line-8"></a><span class='hs-comment'>{-# LANGUAGE TypeFamilies #-}</span>
<a name="line-9"></a><span class='hs-comment'>{-# LANGUAGE UndecidableInstances #-}</span> <span class='hs-comment'>-- Wrinkle in Note [Trees That Grow]</span>
<a name="line-10"></a>                                      <span class='hs-comment'>-- in module Language.Haskell.Syntax.Extension</span>
<a name="line-11"></a><span class='hs-comment'>{-
<a name="line-12"></a>(c) The University of Glasgow 2006
<a name="line-13"></a>(c) The GRASP/AQUA Project, Glasgow University, 1992-1998
<a name="line-14"></a>
<a name="line-15"></a>
<a name="line-16"></a>GHC.Hs.Type: Abstract syntax: user-defined types
<a name="line-17"></a>-}</span>
<a name="line-18"></a>
<a name="line-19"></a><span class='hs-comment'>-- See Note [Language.Haskell.Syntax.* Hierarchy] for why not GHC.Hs.*</span>
<a name="line-20"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Language.Haskell.Syntax.Type</span> <span class='hs-layout'>(</span>
<a name="line-21"></a>        <span class='hs-conid'>Mult</span><span class='hs-layout'>,</span> <span class='hs-conid'>HsScaled</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-22"></a>        <span class='hs-varid'>hsMult</span><span class='hs-layout'>,</span> <span class='hs-varid'>hsScaledThing</span><span class='hs-layout'>,</span>
<a name="line-23"></a>        <span class='hs-conid'>HsArrow</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-24"></a>        <span class='hs-varid'>hsLinear</span><span class='hs-layout'>,</span> <span class='hs-varid'>hsUnrestricted</span><span class='hs-layout'>,</span>
<a name="line-25"></a>
<a name="line-26"></a>        <span class='hs-conid'>HsType</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>HsCoreTy</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsType</span><span class='hs-layout'>,</span> <span class='hs-conid'>HsKind</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsKind</span><span class='hs-layout'>,</span>
<a name="line-27"></a>        <span class='hs-conid'>HsForAllTelescope</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>HsTyVarBndr</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsTyVarBndr</span><span class='hs-layout'>,</span>
<a name="line-28"></a>        <span class='hs-conid'>LHsQTyVars</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-29"></a>        <span class='hs-conid'>HsOuterTyVarBndrs</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>HsOuterFamEqnTyVarBndrs</span><span class='hs-layout'>,</span> <span class='hs-conid'>HsOuterSigTyVarBndrs</span><span class='hs-layout'>,</span>
<a name="line-30"></a>        <span class='hs-conid'>HsWildCardBndrs</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-31"></a>        <span class='hs-conid'>HsPatSigType</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>HsPSRn</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-32"></a>        <span class='hs-conid'>HsSigType</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsSigType</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsSigWcType</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsWcType</span><span class='hs-layout'>,</span>
<a name="line-33"></a>        <span class='hs-conid'>HsTupleSort</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-34"></a>        <span class='hs-conid'>HsContext</span><span class='hs-layout'>,</span> <span class='hs-conid'>LHsContext</span><span class='hs-layout'>,</span>
<a name="line-35"></a>        <span class='hs-conid'>HsTyLit</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-36"></a>        <span class='hs-conid'>HsIPName</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>hsIPNameFS</span><span class='hs-layout'>,</span>
<a name="line-37"></a>        <span class='hs-conid'>HsArg</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>numVisibleArgs</span><span class='hs-layout'>,</span>
<a name="line-38"></a>        <span class='hs-conid'>LHsTypeArg</span><span class='hs-layout'>,</span>
<a name="line-39"></a>
<a name="line-40"></a>        <span class='hs-conid'>LBangType</span><span class='hs-layout'>,</span> <span class='hs-conid'>BangType</span><span class='hs-layout'>,</span>
<a name="line-41"></a>        <span class='hs-conid'>HsSrcBang</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>HsImplBang</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-42"></a>        <span class='hs-conid'>SrcStrictness</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>SrcUnpackedness</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-43"></a>
<a name="line-44"></a>        <span class='hs-conid'>ConDeclField</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>LConDeclField</span><span class='hs-layout'>,</span>
<a name="line-45"></a>
<a name="line-46"></a>        <span class='hs-conid'>HsConDetails</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>noTypeArgs</span><span class='hs-layout'>,</span>
<a name="line-47"></a>
<a name="line-48"></a>        <span class='hs-conid'>FieldOcc</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>LFieldOcc</span><span class='hs-layout'>,</span>
<a name="line-49"></a>        <span class='hs-conid'>AmbiguousFieldOcc</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-50"></a>
<a name="line-51"></a>        <span class='hs-varid'>mapHsOuterImplicit</span><span class='hs-layout'>,</span>
<a name="line-52"></a>        <span class='hs-varid'>hsQTvExplicit</span><span class='hs-layout'>,</span>
<a name="line-53"></a>        <span class='hs-varid'>isHsKindedTyVar</span><span class='hs-layout'>,</span>
<a name="line-54"></a>        <span class='hs-varid'>hsPatSigType</span><span class='hs-layout'>,</span>
<a name="line-55"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-56"></a>
<a name="line-57"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-58"></a>
<a name="line-59"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-60"></a>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>Language.Haskell.Syntax.Expr</span> <span class='hs-layout'>(</span> <span class='hs-conid'>HsSplice</span> <span class='hs-layout'>)</span>
<a name="line-62"></a>
<a name="line-63"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Language.Haskell.Syntax.Extension</span>
<a name="line-64"></a>
<a name="line-65"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.SourceText</span>
<a name="line-66"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span><span class='hs-layout'>(</span> <span class='hs-conid'>Name</span> <span class='hs-layout'>)</span>
<a name="line-67"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name.Reader</span> <span class='hs-layout'>(</span> <span class='hs-conid'>RdrName</span> <span class='hs-layout'>)</span>
<a name="line-68"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.DataCon</span><span class='hs-layout'>(</span> <span class='hs-conid'>HsSrcBang</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>HsImplBang</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-69"></a>                         <span class='hs-conid'>SrcStrictness</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>SrcUnpackedness</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-70"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-71"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Hs.Doc</span>
<a name="line-72"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-73"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.SrcLoc</span>
<a name="line-74"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-75"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.FastString</span>
<a name="line-76"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span> <span class='hs-layout'>(</span> <span class='hs-varid'>count</span> <span class='hs-layout'>)</span>
<a name="line-77"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Parser.Annotation</span>
<a name="line-78"></a>
<a name="line-79"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Data</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Fixity</span><span class='hs-layout'>,</span> <span class='hs-conid'>Prefix</span><span class='hs-layout'>,</span> <span class='hs-conid'>Infix</span> <span class='hs-layout'>)</span>
<a name="line-80"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Void</span>
<a name="line-81"></a>
<a name="line-82"></a><span class='hs-comment'>{-
<a name="line-83"></a>************************************************************************
<a name="line-84"></a>*                                                                      *
<a name="line-85"></a>\subsection{Bang annotations}
<a name="line-86"></a>*                                                                      *
<a name="line-87"></a>************************************************************************
<a name="line-88"></a>-}</span>
<a name="line-89"></a>
<a name="line-90"></a><a name="LBangType"></a><span class='hs-comment'>-- | Located Bang Type</span>
<a name="line-91"></a><a name="LBangType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LBangType</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>pass</span> <span class='hs-layout'>(</span><span class='hs-conid'>BangType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-92"></a>
<a name="line-93"></a><a name="BangType"></a><span class='hs-comment'>-- | Bang Type</span>
<a name="line-94"></a><a name="BangType"></a><span class='hs-comment'>--</span>
<a name="line-95"></a><a name="BangType"></a><span class='hs-comment'>-- In the parser, strictness and packedness annotations bind more tightly</span>
<a name="line-96"></a><a name="BangType"></a><span class='hs-comment'>-- than docstrings. This means that when consuming a 'BangType' (and looking</span>
<a name="line-97"></a><a name="BangType"></a><span class='hs-comment'>-- for 'HsBangTy') we must be ready to peer behind a potential layer of</span>
<a name="line-98"></a><a name="BangType"></a><span class='hs-comment'>-- 'HsDocTy'. See #15206 for motivation and 'getBangType' for an example.</span>
<a name="line-99"></a><a name="BangType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>BangType</span> <span class='hs-varid'>pass</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsType</span> <span class='hs-varid'>pass</span>       <span class='hs-comment'>-- Bangs are in the HsType data type</span>
<a name="line-100"></a>
<a name="line-101"></a><span class='hs-comment'>{-
<a name="line-102"></a>************************************************************************
<a name="line-103"></a>*                                                                      *
<a name="line-104"></a>\subsection{Data types}
<a name="line-105"></a>*                                                                      *
<a name="line-106"></a>************************************************************************
<a name="line-107"></a>
<a name="line-108"></a>This is the syntax for types as seen in type signatures.
<a name="line-109"></a>
<a name="line-110"></a>Note [HsBSig binder lists]
<a name="line-111"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-112"></a>Consider a binder (or pattern) decorated with a type or kind,
<a name="line-113"></a>   \ (x :: a -&gt; a). blah
<a name="line-114"></a>   forall (a :: k -&gt; *) (b :: k). blah
<a name="line-115"></a>Then we use a LHsBndrSig on the binder, so that the
<a name="line-116"></a>renamer can decorate it with the variables bound
<a name="line-117"></a>by the pattern ('a' in the first example, 'k' in the second),
<a name="line-118"></a>assuming that neither of them is in scope already
<a name="line-119"></a>See also Note [Kind and type-variable binders] in GHC.Rename.HsType
<a name="line-120"></a>
<a name="line-121"></a>Note [HsType binders]
<a name="line-122"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-123"></a>The system for recording type and kind-variable binders in HsTypes
<a name="line-124"></a>is a bit complicated.  Here's how it works.
<a name="line-125"></a>
<a name="line-126"></a>* In a HsType,
<a name="line-127"></a>     HsForAllTy   represents an /explicit, user-written/ 'forall' that
<a name="line-128"></a>                  is nested within another HsType
<a name="line-129"></a>                   e.g.   forall a b.   {...} or
<a name="line-130"></a>                          forall a b -&gt; {...}
<a name="line-131"></a>
<a name="line-132"></a>                  Note that top-level 'forall's are represented with a
<a name="line-133"></a>                  different AST form. See the description of HsOuterTyVarBndrs
<a name="line-134"></a>                  below.
<a name="line-135"></a>     HsQualTy     represents an /explicit, user-written/ context
<a name="line-136"></a>                   e.g.   (Eq a, Show a) =&gt; ...
<a name="line-137"></a>                  The context can be empty if that's what the user wrote
<a name="line-138"></a>  These constructors represent what the user wrote, no more
<a name="line-139"></a>  and no less.
<a name="line-140"></a>
<a name="line-141"></a>* The ForAllTelescope field of HsForAllTy represents whether a forall is
<a name="line-142"></a>  invisible (e.g., forall a b. {...}, with a dot) or visible
<a name="line-143"></a>  (e.g., forall a b -&gt; {...}, with an arrow).
<a name="line-144"></a>
<a name="line-145"></a>* HsTyVarBndr describes a quantified type variable written by the
<a name="line-146"></a>  user.  For example
<a name="line-147"></a>     f :: forall a (b :: *).  blah
<a name="line-148"></a>  here 'a' and '(b::*)' are each a HsTyVarBndr.  A HsForAllTy has
<a name="line-149"></a>  a list of LHsTyVarBndrs.
<a name="line-150"></a>
<a name="line-151"></a>* HsOuterTyVarBndrs is used to represent the outermost quantified type
<a name="line-152"></a>  variables in a type that obeys the forall-or-nothing rule. An
<a name="line-153"></a>  HsOuterTyVarBndrs can be one of the following:
<a name="line-154"></a>
<a name="line-155"></a>    HsOuterImplicit (implicit quantification, added by renamer)
<a name="line-156"></a>          f :: a -&gt; a     -- Desugars to f :: forall {a}. a -&gt; a
<a name="line-157"></a>    HsOuterExplicit (explicit user quantifiation):
<a name="line-158"></a>          f :: forall a. a -&gt; a
<a name="line-159"></a>
<a name="line-160"></a>  See Note [forall-or-nothing rule].
<a name="line-161"></a>
<a name="line-162"></a>* An HsSigType is an LHsType with an accompanying HsOuterTyVarBndrs that
<a name="line-163"></a>  represents the presence (or absence) of its outermost 'forall'.
<a name="line-164"></a>  See Note [Representing type signatures].
<a name="line-165"></a>
<a name="line-166"></a>* HsWildCardBndrs is a wrapper that binds the wildcard variables
<a name="line-167"></a>  of the wrapped thing.  It is filled in by the renamer
<a name="line-168"></a>     f :: _a -&gt; _
<a name="line-169"></a>  The enclosing HsWildCardBndrs binds the wildcards _a and _.
<a name="line-170"></a>
<a name="line-171"></a>* HsSigPatType describes types that appear in pattern signatures and
<a name="line-172"></a>  the signatures of term-level binders in RULES. Like
<a name="line-173"></a>  HsWildCardBndrs/HsOuterTyVarBndrs, they track the names of wildcard
<a name="line-174"></a>  variables and implicitly bound type variables. Unlike
<a name="line-175"></a>  HsOuterTyVarBndrs, however, HsSigPatTypes do not obey the
<a name="line-176"></a>  forall-or-nothing rule. See Note [Pattern signature binders and scoping].
<a name="line-177"></a>
<a name="line-178"></a>* The explicit presence of these wrappers specifies, in the HsSyn,
<a name="line-179"></a>  exactly where implicit quantification is allowed, and where
<a name="line-180"></a>  wildcards are allowed.
<a name="line-181"></a>
<a name="line-182"></a>* LHsQTyVars is used in data/class declarations, where the user gives
<a name="line-183"></a>  explicit *type* variable bindings, but we need to implicitly bind
<a name="line-184"></a>  *kind* variables.  For example
<a name="line-185"></a>      class C (a :: k -&gt; *) where ...
<a name="line-186"></a>  The 'k' is implicitly bound in the hsq_tvs field of LHsQTyVars
<a name="line-187"></a>
<a name="line-188"></a>Note [The wildcard story for types]
<a name="line-189"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-190"></a>Types can have wildcards in them, to support partial type signatures,
<a name="line-191"></a>like       f :: Int -&gt; (_ , _a) -&gt; _a
<a name="line-192"></a>
<a name="line-193"></a>A wildcard in a type can be
<a name="line-194"></a>
<a name="line-195"></a>  * An anonymous wildcard,
<a name="line-196"></a>        written '_'
<a name="line-197"></a>    In HsType this is represented by HsWildCardTy.
<a name="line-198"></a>    The renamer leaves it untouched, and it is later given a fresh
<a name="line-199"></a>    meta tyvar in the typechecker.
<a name="line-200"></a>
<a name="line-201"></a>  * A named wildcard,
<a name="line-202"></a>        written '_a', '_foo', etc
<a name="line-203"></a>    In HsType this is represented by (HsTyVar "_a")
<a name="line-204"></a>    i.e. a perfectly ordinary type variable that happens
<a name="line-205"></a>         to start with an underscore
<a name="line-206"></a>
<a name="line-207"></a>Note carefully:
<a name="line-208"></a>
<a name="line-209"></a>* When NamedWildCards is off, type variables that start with an
<a name="line-210"></a>  underscore really /are/ ordinary type variables.  And indeed, even
<a name="line-211"></a>  when NamedWildCards is on you can bind _a explicitly as an ordinary
<a name="line-212"></a>  type variable:
<a name="line-213"></a>        data T _a _b = MkT _b _a
<a name="line-214"></a>  Or even:
<a name="line-215"></a>        f :: forall _a. _a -&gt; _b
<a name="line-216"></a>  Here _a is an ordinary forall'd binder, but (With NamedWildCards)
<a name="line-217"></a>  _b is a named wildcard.  (See the comments in #10982)
<a name="line-218"></a>
<a name="line-219"></a>* Named wildcards are bound by the HsWildCardBndrs (for types that obey the
<a name="line-220"></a>  forall-or-nothing rule) and HsPatSigType (for type signatures in patterns
<a name="line-221"></a>  and term-level binders in RULES), which wrap types that are allowed to have
<a name="line-222"></a>  wildcards. Unnamed wildcards, however are left unchanged until typechecking,
<a name="line-223"></a>  where we give them fresh wild tyvars and determine whether or not to emit
<a name="line-224"></a>  hole constraints on each wildcard (we don't if it's a visible type/kind
<a name="line-225"></a>  argument or a type family pattern). See related notes
<a name="line-226"></a>  Note [Wildcards in visible kind application] and
<a name="line-227"></a>  Note [Wildcards in visible type application] in GHC.Tc.Gen.HsType.
<a name="line-228"></a>
<a name="line-229"></a>* After type checking is done, we report what types the wildcards
<a name="line-230"></a>  got unified with.
<a name="line-231"></a>
<a name="line-232"></a>Note [Ordering of implicit variables]
<a name="line-233"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-234"></a>Since the advent of -XTypeApplications, GHC makes promises about the ordering
<a name="line-235"></a>of implicit variable quantification. Specifically, we offer that implicitly
<a name="line-236"></a>quantified variables (such as those in const :: a -&gt; b -&gt; a, without a `forall`)
<a name="line-237"></a>will occur in left-to-right order of first occurrence. Here are a few examples:
<a name="line-238"></a>
<a name="line-239"></a>  const :: a -&gt; b -&gt; a       -- forall a b. ...
<a name="line-240"></a>  f :: Eq a =&gt; b -&gt; a -&gt; a   -- forall a b. ...  contexts are included
<a name="line-241"></a>
<a name="line-242"></a>  type a &lt;-&lt; b = b -&gt; a
<a name="line-243"></a>  g :: a &lt;-&lt; b               -- forall a b. ...  type synonyms matter
<a name="line-244"></a>
<a name="line-245"></a>  class Functor f where
<a name="line-246"></a>    fmap :: (a -&gt; b) -&gt; f a -&gt; f b   -- forall f a b. ...
<a name="line-247"></a>    -- The f is quantified by the class, so only a and b are considered in fmap
<a name="line-248"></a>
<a name="line-249"></a>This simple story is complicated by the possibility of dependency: all variables
<a name="line-250"></a>must come after any variables mentioned in their kinds.
<a name="line-251"></a>
<a name="line-252"></a>  typeRep :: Typeable a =&gt; TypeRep (a :: k)   -- forall k a. ...
<a name="line-253"></a>
<a name="line-254"></a>The k comes first because a depends on k, even though the k appears later than
<a name="line-255"></a>the a in the code. Thus, GHC does a *stable topological sort* on the variables.
<a name="line-256"></a>By "stable", we mean that any two variables who do not depend on each other
<a name="line-257"></a>preserve their existing left-to-right ordering.
<a name="line-258"></a>
<a name="line-259"></a>Implicitly bound variables are collected by the extract- family of functions
<a name="line-260"></a>(extractHsTysRdrTyVars, extractHsTyVarBndrsKVs, etc.) in GHC.Rename.HsType.
<a name="line-261"></a>These functions thus promise to keep left-to-right ordering.
<a name="line-262"></a>Look for pointers to this note to see the places where the action happens.
<a name="line-263"></a>
<a name="line-264"></a>Note that we also maintain this ordering in kind signatures. Even though
<a name="line-265"></a>there's no visible kind application (yet), having implicit variables be
<a name="line-266"></a>quantified in left-to-right order in kind signatures is nice since:
<a name="line-267"></a>
<a name="line-268"></a>* It's consistent with the treatment for type signatures.
<a name="line-269"></a>* It can affect how types are displayed with -fprint-explicit-kinds (see
<a name="line-270"></a>  #15568 for an example), which is a situation where knowing the order in
<a name="line-271"></a>  which implicit variables are quantified can be useful.
<a name="line-272"></a>* In the event that visible kind application is implemented, the order in
<a name="line-273"></a>  which we would expect implicit variables to be ordered in kinds will have
<a name="line-274"></a>  already been established.
<a name="line-275"></a>-}</span>
<a name="line-276"></a>
<a name="line-277"></a><a name="LHsContext"></a><span class='hs-comment'>-- | Located Haskell Context</span>
<a name="line-278"></a><a name="LHsContext"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsContext</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>pass</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsContext</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-279"></a>      <span class='hs-comment'>-- ^ 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnUnit'</span>
<a name="line-280"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-281"></a>
<a name="line-282"></a><a name="HsContext"></a><span class='hs-comment'>-- | Haskell Context</span>
<a name="line-283"></a><a name="HsContext"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>HsContext</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-keyglyph'>]</span>
<a name="line-284"></a>
<a name="line-285"></a><a name="LHsType"></a><span class='hs-comment'>-- | Located Haskell Type</span>
<a name="line-286"></a><a name="LHsType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>pass</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-287"></a>      <span class='hs-comment'>-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when</span>
<a name="line-288"></a>      <span class='hs-comment'>--   in a list</span>
<a name="line-289"></a>
<a name="line-290"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-291"></a>
<a name="line-292"></a><a name="HsKind"></a><span class='hs-comment'>-- | Haskell Kind</span>
<a name="line-293"></a><a name="HsKind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>HsKind</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsType</span> <span class='hs-varid'>pass</span>
<a name="line-294"></a>
<a name="line-295"></a><a name="LHsKind"></a><span class='hs-comment'>-- | Located Haskell Kind</span>
<a name="line-296"></a><a name="LHsKind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsKind</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>pass</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsKind</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-297"></a>      <span class='hs-comment'>-- ^ 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon'</span>
<a name="line-298"></a>
<a name="line-299"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-300"></a>
<a name="line-301"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-302"></a><span class='hs-comment'>--             LHsQTyVars</span>
<a name="line-303"></a><span class='hs-comment'>--  The explicitly-quantified binders in a data/type declaration</span>
<a name="line-304"></a>
<a name="line-305"></a><a name="HsForAllTelescope"></a><span class='hs-comment'>-- | The type variable binders in an 'HsForAllTy'.</span>
<a name="line-306"></a><a name="HsForAllTelescope"></a><span class='hs-comment'>-- See also @Note [Variable Specificity and Forall Visibility]@ in</span>
<a name="line-307"></a><a name="HsForAllTelescope"></a><span class='hs-comment'>-- "GHC.Tc.Gen.HsType".</span>
<a name="line-308"></a><a name="HsForAllTelescope"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsForAllTelescope</span> <span class='hs-varid'>pass</span>
<a name="line-309"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsForAllVis</span> <span class='hs-comment'>-- ^ A visible @forall@ (e.g., @forall a -&gt; {...}@).</span>
<a name="line-310"></a>                <span class='hs-comment'>--   These do not have any notion of specificity, so we use</span>
<a name="line-311"></a>                <span class='hs-comment'>--   '()' as a placeholder value.</span>
<a name="line-312"></a>    <span class='hs-layout'>{</span> <span class='hs-varid'>hsf_xvis</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XHsForAllVis</span> <span class='hs-varid'>pass</span>
<a name="line-313"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>hsf_vis_bndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsTyVarBndr</span> <span class='hs-conid'>()</span> <span class='hs-varid'>pass</span><span class='hs-keyglyph'>]</span>
<a name="line-314"></a>    <span class='hs-layout'>}</span>
<a name="line-315"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsForAllInvis</span> <span class='hs-comment'>-- ^ An invisible @forall@ (e.g., @forall a {b} c. {...}@),</span>
<a name="line-316"></a>                  <span class='hs-comment'>--   where each binder has a 'Specificity'.</span>
<a name="line-317"></a>    <span class='hs-layout'>{</span> <span class='hs-varid'>hsf_xinvis</span>       <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XHsForAllInvis</span> <span class='hs-varid'>pass</span>
<a name="line-318"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>hsf_invis_bndrs</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsTyVarBndr</span> <span class='hs-conid'>Specificity</span> <span class='hs-varid'>pass</span><span class='hs-keyglyph'>]</span>
<a name="line-319"></a>    <span class='hs-layout'>}</span>
<a name="line-320"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XHsForAllTelescope</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXHsForAllTelescope</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-321"></a>
<a name="line-322"></a><a name="LHsTyVarBndr"></a><span class='hs-comment'>-- | Located Haskell Type Variable Binder</span>
<a name="line-323"></a><a name="LHsTyVarBndr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsTyVarBndr</span> <span class='hs-varid'>flag</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>pass</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsTyVarBndr</span> <span class='hs-varid'>flag</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-324"></a>                         <span class='hs-comment'>-- See Note [HsType binders]</span>
<a name="line-325"></a>
<a name="line-326"></a><a name="LHsQTyVars"></a><span class='hs-comment'>-- | Located Haskell Quantified Type Variables</span>
<a name="line-327"></a><a name="LHsQTyVars"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>LHsQTyVars</span> <span class='hs-varid'>pass</span>   <span class='hs-comment'>-- See Note [HsType binders]</span>
<a name="line-328"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsQTvs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>hsq_ext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XHsQTvs</span> <span class='hs-varid'>pass</span>
<a name="line-329"></a>
<a name="line-330"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>hsq_explicit</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsTyVarBndr</span> <span class='hs-conid'>()</span> <span class='hs-varid'>pass</span><span class='hs-keyglyph'>]</span>
<a name="line-331"></a>                <span class='hs-comment'>-- Explicit variables, written by the user</span>
<a name="line-332"></a>    <span class='hs-layout'>}</span>
<a name="line-333"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XLHsQTyVars</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXLHsQTyVars</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-334"></a>
<a name="line-335"></a><a name="hsQTvExplicit"></a><span class='hs-definition'>hsQTvExplicit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LHsQTyVars</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsTyVarBndr</span> <span class='hs-conid'>()</span> <span class='hs-varid'>pass</span><span class='hs-keyglyph'>]</span>
<a name="line-336"></a><span class='hs-definition'>hsQTvExplicit</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hsq_explicit</span>
<a name="line-337"></a>
<a name="line-338"></a><span class='hs-comment'>------------------------------------------------</span>
<a name="line-339"></a><span class='hs-comment'>--            HsOuterTyVarBndrs</span>
<a name="line-340"></a><span class='hs-comment'>-- Used to quantify the outermost type variable binders of a type that obeys</span>
<a name="line-341"></a><span class='hs-comment'>-- the forall-or-nothing rule. These are used to represent the outermost</span>
<a name="line-342"></a><span class='hs-comment'>-- quantification in:</span>
<a name="line-343"></a><span class='hs-comment'>--    * Type signatures (LHsSigType/LHsSigWcType)</span>
<a name="line-344"></a><span class='hs-comment'>--    * Patterns in a type/data family instance (HsTyPats)</span>
<a name="line-345"></a><span class='hs-comment'>--</span>
<a name="line-346"></a><span class='hs-comment'>-- We support two forms:</span>
<a name="line-347"></a><span class='hs-comment'>--   HsOuterImplicit (implicit quantification, added by renamer)</span>
<a name="line-348"></a><span class='hs-comment'>--         f :: a -&gt; a     -- Desugars to f :: forall {a}. a -&gt; a</span>
<a name="line-349"></a><span class='hs-comment'>--         type instance F (a,b) = a-&gt;b</span>
<a name="line-350"></a><span class='hs-comment'>--   HsOuterExplicit (explicit user quantifiation):</span>
<a name="line-351"></a><span class='hs-comment'>--         f :: forall a. a -&gt; a</span>
<a name="line-352"></a><span class='hs-comment'>--         type instance forall a b. F (a,b) = a-&gt;b</span>
<a name="line-353"></a><span class='hs-comment'>--</span>
<a name="line-354"></a><span class='hs-comment'>-- In constrast, when the user writes /visible/ quanitification</span>
<a name="line-355"></a><span class='hs-comment'>--         T :: forall k -&gt; k -&gt; Type</span>
<a name="line-356"></a><span class='hs-comment'>-- we use use HsOuterImplicit, wrapped around a HsForAllTy</span>
<a name="line-357"></a><span class='hs-comment'>-- for the visible quantification</span>
<a name="line-358"></a><span class='hs-comment'>--</span>
<a name="line-359"></a><span class='hs-comment'>-- See Note [forall-or-nothing rule]</span>
<a name="line-360"></a>
<a name="line-361"></a><a name="HsOuterTyVarBndrs"></a><span class='hs-comment'>-- | The outermost type variables in a type that obeys the @forall@-or-nothing</span>
<a name="line-362"></a><a name="HsOuterTyVarBndrs"></a><span class='hs-comment'>-- rule. See @Note [forall-or-nothing rule]@.</span>
<a name="line-363"></a><a name="HsOuterTyVarBndrs"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsOuterTyVarBndrs</span> <span class='hs-varid'>flag</span> <span class='hs-varid'>pass</span>
<a name="line-364"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsOuterImplicit</span> <span class='hs-comment'>-- ^ Implicit forall, e.g.,</span>
<a name="line-365"></a>                    <span class='hs-comment'>--    @f :: a -&gt; b -&gt; b@</span>
<a name="line-366"></a>    <span class='hs-layout'>{</span> <span class='hs-varid'>hso_ximplicit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XHsOuterImplicit</span> <span class='hs-varid'>pass</span>
<a name="line-367"></a>    <span class='hs-layout'>}</span>
<a name="line-368"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsOuterExplicit</span> <span class='hs-comment'>-- ^ Explicit forall, e.g.,</span>
<a name="line-369"></a>                    <span class='hs-comment'>--    @f :: forall a b. a -&gt; b -&gt; b@</span>
<a name="line-370"></a>    <span class='hs-layout'>{</span> <span class='hs-varid'>hso_xexplicit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XHsOuterExplicit</span> <span class='hs-varid'>pass</span> <span class='hs-varid'>flag</span>
<a name="line-371"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>hso_bndrs</span>     <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsTyVarBndr</span> <span class='hs-varid'>flag</span> <span class='hs-layout'>(</span><span class='hs-conid'>NoGhcTc</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-372"></a>    <span class='hs-layout'>}</span>
<a name="line-373"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XHsOuterTyVarBndrs</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXHsOuterTyVarBndrs</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-374"></a>
<a name="line-375"></a><a name="HsOuterSigTyVarBndrs"></a><span class='hs-comment'>-- | Used for signatures, e.g.,</span>
<a name="line-376"></a><a name="HsOuterSigTyVarBndrs"></a><span class='hs-comment'>--</span>
<a name="line-377"></a><a name="HsOuterSigTyVarBndrs"></a><span class='hs-comment'>-- @</span>
<a name="line-378"></a><a name="HsOuterSigTyVarBndrs"></a><span class='hs-comment'>-- f :: forall a {b}. blah</span>
<a name="line-379"></a><a name="HsOuterSigTyVarBndrs"></a><span class='hs-comment'>-- @</span>
<a name="line-380"></a><a name="HsOuterSigTyVarBndrs"></a><span class='hs-comment'>--</span>
<a name="line-381"></a><a name="HsOuterSigTyVarBndrs"></a><span class='hs-comment'>-- We use 'Specificity' for the 'HsOuterTyVarBndrs' @flag@ to allow</span>
<a name="line-382"></a><a name="HsOuterSigTyVarBndrs"></a><span class='hs-comment'>-- distinguishing between specified and inferred type variables.</span>
<a name="line-383"></a><a name="HsOuterSigTyVarBndrs"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>HsOuterSigTyVarBndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsOuterTyVarBndrs</span> <span class='hs-conid'>Specificity</span>
<a name="line-384"></a>
<a name="line-385"></a><a name="HsOuterFamEqnTyVarBndrs"></a><span class='hs-comment'>-- | Used for type-family instance equations, e.g.,</span>
<a name="line-386"></a><a name="HsOuterFamEqnTyVarBndrs"></a><span class='hs-comment'>--</span>
<a name="line-387"></a><a name="HsOuterFamEqnTyVarBndrs"></a><span class='hs-comment'>-- @</span>
<a name="line-388"></a><a name="HsOuterFamEqnTyVarBndrs"></a><span class='hs-comment'>-- type instance forall a. F [a] = Tree a</span>
<a name="line-389"></a><a name="HsOuterFamEqnTyVarBndrs"></a><span class='hs-comment'>-- @</span>
<a name="line-390"></a><a name="HsOuterFamEqnTyVarBndrs"></a><span class='hs-comment'>--</span>
<a name="line-391"></a><a name="HsOuterFamEqnTyVarBndrs"></a><span class='hs-comment'>-- The notion of specificity is irrelevant in type family equations, so we use</span>
<a name="line-392"></a><a name="HsOuterFamEqnTyVarBndrs"></a><span class='hs-comment'>-- @()@ for the 'HsOuterTyVarBndrs' @flag@.</span>
<a name="line-393"></a><a name="HsOuterFamEqnTyVarBndrs"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>HsOuterFamEqnTyVarBndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsOuterTyVarBndrs</span> <span class='hs-conid'>()</span>
<a name="line-394"></a>
<a name="line-395"></a><a name="HsWildCardBndrs"></a><span class='hs-comment'>-- | Haskell Wildcard Binders</span>
<a name="line-396"></a><a name="HsWildCardBndrs"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsWildCardBndrs</span> <span class='hs-varid'>pass</span> <span class='hs-varid'>thing</span>
<a name="line-397"></a>    <span class='hs-comment'>-- See Note [HsType binders]</span>
<a name="line-398"></a>    <span class='hs-comment'>-- See Note [The wildcard story for types]</span>
<a name="line-399"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsWC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>hswc_ext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XHsWC</span> <span class='hs-varid'>pass</span> <span class='hs-varid'>thing</span>
<a name="line-400"></a>                <span class='hs-comment'>-- after the renamer</span>
<a name="line-401"></a>                <span class='hs-comment'>-- Wild cards, only named</span>
<a name="line-402"></a>                <span class='hs-comment'>-- See Note [Wildcards in visible kind application]</span>
<a name="line-403"></a>
<a name="line-404"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>hswc_body</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>thing</span>
<a name="line-405"></a>                <span class='hs-comment'>-- Main payload (type or list of types)</span>
<a name="line-406"></a>                <span class='hs-comment'>-- If there is an extra-constraints wildcard,</span>
<a name="line-407"></a>                <span class='hs-comment'>-- it's still there in the hsc_body.</span>
<a name="line-408"></a>    <span class='hs-layout'>}</span>
<a name="line-409"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XHsWildCardBndrs</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXHsWildCardBndrs</span> <span class='hs-varid'>pass</span> <span class='hs-varid'>thing</span><span class='hs-layout'>)</span>
<a name="line-410"></a>
<a name="line-411"></a><a name="HsPatSigType"></a><span class='hs-comment'>-- | Types that can appear in pattern signatures, as well as the signatures for</span>
<a name="line-412"></a><a name="HsPatSigType"></a><span class='hs-comment'>-- term-level binders in RULES.</span>
<a name="line-413"></a><a name="HsPatSigType"></a><span class='hs-comment'>-- See @Note [Pattern signature binders and scoping]@.</span>
<a name="line-414"></a><a name="HsPatSigType"></a><span class='hs-comment'>--</span>
<a name="line-415"></a><a name="HsPatSigType"></a><span class='hs-comment'>-- This is very similar to 'HsSigWcType', but with</span>
<a name="line-416"></a><a name="HsPatSigType"></a><span class='hs-comment'>-- slightly different semantics: see @Note [HsType binders]@.</span>
<a name="line-417"></a><a name="HsPatSigType"></a><span class='hs-comment'>-- See also @Note [The wildcard story for types]@.</span>
<a name="line-418"></a><a name="HsPatSigType"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsPatSigType</span> <span class='hs-varid'>pass</span>
<a name="line-419"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsPS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>hsps_ext</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XHsPS</span> <span class='hs-varid'>pass</span>   <span class='hs-comment'>-- ^ After renamer: 'HsPSRn'</span>
<a name="line-420"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>hsps_body</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span> <span class='hs-comment'>-- ^ Main payload (the type itself)</span>
<a name="line-421"></a>    <span class='hs-layout'>}</span>
<a name="line-422"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XHsPatSigType</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXHsPatSigType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-423"></a>
<a name="line-424"></a><a name="HsPSRn"></a><span class='hs-comment'>-- | The extension field for 'HsPatSigType', which is only used in the</span>
<a name="line-425"></a><a name="HsPSRn"></a><span class='hs-comment'>-- renamer onwards. See @Note [Pattern signature binders and scoping]@.</span>
<a name="line-426"></a><a name="HsPSRn"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsPSRn</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsPSRn</span>
<a name="line-427"></a>  <span class='hs-layout'>{</span> <span class='hs-varid'>hsps_nwcs</span>    <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- ^ Wildcard names</span>
<a name="line-428"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>hsps_imp_tvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- ^ Implicitly bound variable names</span>
<a name="line-429"></a>  <span class='hs-layout'>}</span>
<a name="line-430"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-431"></a>
<a name="line-432"></a><a name="LHsSigType"></a><span class='hs-comment'>-- | Located Haskell Signature Type</span>
<a name="line-433"></a><a name="LHsSigType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsSigType</span>   <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>pass</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsSigType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>               <span class='hs-comment'>-- Implicit only</span>
<a name="line-434"></a>
<a name="line-435"></a><a name="LHsWcType"></a><span class='hs-comment'>-- | Located Haskell Wildcard Type</span>
<a name="line-436"></a><a name="LHsWcType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsWcType</span>    <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsWildCardBndrs</span> <span class='hs-varid'>pass</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- Wildcard only</span>
<a name="line-437"></a>
<a name="line-438"></a><a name="LHsSigWcType"></a><span class='hs-comment'>-- | Located Haskell Signature Wildcard Type</span>
<a name="line-439"></a><a name="LHsSigWcType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsSigWcType</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsWildCardBndrs</span> <span class='hs-varid'>pass</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsSigType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Both</span>
<a name="line-440"></a>
<a name="line-441"></a><a name="HsSigType"></a><span class='hs-comment'>-- | A type signature that obeys the @forall@-or-nothing rule. In other</span>
<a name="line-442"></a><a name="HsSigType"></a><span class='hs-comment'>-- words, an 'LHsType' that uses an 'HsOuterSigTyVarBndrs' to represent its</span>
<a name="line-443"></a><a name="HsSigType"></a><span class='hs-comment'>-- outermost type variable quantification.</span>
<a name="line-444"></a><a name="HsSigType"></a><span class='hs-comment'>-- See @Note [Representing type signatures]@.</span>
<a name="line-445"></a><a name="HsSigType"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsSigType</span> <span class='hs-varid'>pass</span>
<a name="line-446"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsSig</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sig_ext</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XHsSig</span> <span class='hs-varid'>pass</span>
<a name="line-447"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>sig_bndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsOuterSigTyVarBndrs</span> <span class='hs-varid'>pass</span>
<a name="line-448"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>sig_body</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span>
<a name="line-449"></a>          <span class='hs-layout'>}</span>
<a name="line-450"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XHsSigType</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXHsSigType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-451"></a>
<a name="line-452"></a><a name="hsPatSigType"></a><span class='hs-definition'>hsPatSigType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsPatSigType</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span>
<a name="line-453"></a><span class='hs-definition'>hsPatSigType</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hsps_body</span>
<a name="line-454"></a>
<a name="line-455"></a><span class='hs-comment'>{-
<a name="line-456"></a>Note [forall-or-nothing rule]
<a name="line-457"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-458"></a>Free variables in signatures are usually bound in an implicit 'forall' at the
<a name="line-459"></a>beginning of user-written signatures. However, if the signature has an
<a name="line-460"></a>explicit, invisible forall at the beginning, this is disabled. This is referred
<a name="line-461"></a>to as the forall-or-nothing rule.
<a name="line-462"></a>
<a name="line-463"></a>The idea is nested foralls express something which is only expressible
<a name="line-464"></a>explicitly, while a top level forall could (usually) be replaced with an
<a name="line-465"></a>implicit binding. Top-level foralls alone ("forall.") are therefore an
<a name="line-466"></a>indication that the user is trying to be fastidious, so we don't implicitly
<a name="line-467"></a>bind any variables.
<a name="line-468"></a>
<a name="line-469"></a>Note that this rule only applies to outermost /in/visible 'forall's, and not
<a name="line-470"></a>outermost visible 'forall's. See #18660 for more on this point.
<a name="line-471"></a>
<a name="line-472"></a>Here are some concrete examples to demonstrate the forall-or-nothing rule in
<a name="line-473"></a>action:
<a name="line-474"></a>
<a name="line-475"></a>  type F1 :: a -&gt; b -&gt; b                    -- Legal; a,b are implicitly quantified.
<a name="line-476"></a>                                            -- Equivalently: forall a b. a -&gt; b -&gt; b
<a name="line-477"></a>
<a name="line-478"></a>  type F2 :: forall a b. a -&gt; b -&gt; b        -- Legal; explicitly quantified
<a name="line-479"></a>
<a name="line-480"></a>  type F3 :: forall a. a -&gt; b -&gt; b          -- Illegal; the forall-or-nothing rule says that
<a name="line-481"></a>                                            -- if you quantify a, you must also quantify b
<a name="line-482"></a>
<a name="line-483"></a>  type F4 :: forall a -&gt; b -&gt; b             -- Legal; the top quantifier (forall a) is a /visible/
<a name="line-484"></a>                                            -- quantifer, so the "nothing" part of the forall-or-nothing
<a name="line-485"></a>                                            -- rule applies, and b is therefore implicitly quantified.
<a name="line-486"></a>                                            -- Equivalently: forall b. forall a -&gt; b -&gt; b
<a name="line-487"></a>
<a name="line-488"></a>  type F5 :: forall b. forall a -&gt; b -&gt; c   -- Illegal; the forall-or-nothing rule says that
<a name="line-489"></a>                                            -- if you quantify b, you must also quantify c
<a name="line-490"></a>
<a name="line-491"></a>  type F6 :: forall a -&gt; forall b. b -&gt; c   -- Legal: just like F4.
<a name="line-492"></a>
<a name="line-493"></a>For a complete list of all places where the forall-or-nothing rule applies, see
<a name="line-494"></a>"The `forall`-or-nothing rule" section of the GHC User's Guide.
<a name="line-495"></a>
<a name="line-496"></a>Any type that obeys the forall-or-nothing rule is represented in the AST with
<a name="line-497"></a>an HsOuterTyVarBndrs:
<a name="line-498"></a>
<a name="line-499"></a>* If the type has an outermost, invisible 'forall', it uses HsOuterExplicit,
<a name="line-500"></a>  which contains a list of the explicitly quantified type variable binders in
<a name="line-501"></a>  `hso_bndrs`. After typechecking, HsOuterExplicit also stores a list of the
<a name="line-502"></a>  explicitly quantified `InvisTVBinder`s in
<a name="line-503"></a>  `hso_xexplicit :: XHsOuterExplicit GhcTc`.
<a name="line-504"></a>
<a name="line-505"></a>* Otherwise, it uses HsOuterImplicit. HsOuterImplicit is used for different
<a name="line-506"></a>  things depending on the phase:
<a name="line-507"></a>
<a name="line-508"></a>  * After parsing, it does not store anything in particular.
<a name="line-509"></a>  * After renaming, it stores the implicitly bound type variable `Name`s in
<a name="line-510"></a>    `hso_ximplicit :: XHsOuterImplicit GhcRn`.
<a name="line-511"></a>  * After typechecking, it stores the implicitly bound `TyVar`s in
<a name="line-512"></a>    `hso_ximplicit :: XHsOuterImplicit GhcTc`.
<a name="line-513"></a>
<a name="line-514"></a>  NB: this implicit quantification is purely lexical: we bind any
<a name="line-515"></a>      type or kind variables that are not in scope. The type checker
<a name="line-516"></a>      may subsequently quantify over further kind variables.
<a name="line-517"></a>      See Note [Binding scoped type variables] in GHC.Tc.Gen.Sig.
<a name="line-518"></a>
<a name="line-519"></a>HsOuterTyVarBndrs GhcTc is used in the typechecker as an intermediate data type
<a name="line-520"></a>for storing the outermost TyVars/InvisTVBinders in a type.
<a name="line-521"></a>See GHC.Tc.Gen.HsType.bindOuterTKBndrsX for an example of this.
<a name="line-522"></a>
<a name="line-523"></a>Note [Representing type signatures]
<a name="line-524"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-525"></a>HsSigType is used to represent an explicit user type signature. These are
<a name="line-526"></a>used in a variety of places. Some examples include:
<a name="line-527"></a>
<a name="line-528"></a>* Type signatures (e.g., f :: a -&gt; a)
<a name="line-529"></a>* Standalone kind signatures (e.g., type G :: a -&gt; a)
<a name="line-530"></a>* GADT constructor types (e.g., data T where MkT :: a -&gt; T)
<a name="line-531"></a>
<a name="line-532"></a>A HsSigType is the combination of an HsOuterSigTyVarBndrs and an LHsType:
<a name="line-533"></a>
<a name="line-534"></a>* The HsOuterSigTyVarBndrs binds the /explicitly/ quantified type variables
<a name="line-535"></a>  when the type signature has an outermost, user-written 'forall' (i.e,
<a name="line-536"></a>  the HsOuterExplicit constructor is used). If there is no outermost 'forall',
<a name="line-537"></a>  then it binds the /implicitly/ quantified type variables instead (i.e.,
<a name="line-538"></a>  the HsOuterImplicit constructor is used).
<a name="line-539"></a>* The LHsType represents the rest of the type.
<a name="line-540"></a>
<a name="line-541"></a>E.g. For a signature like
<a name="line-542"></a>   f :: forall k (a::k). blah
<a name="line-543"></a>we get
<a name="line-544"></a>   HsSig { sig_bndrs = HsOuterExplicit { hso_bndrs = [k, (a :: k)] }
<a name="line-545"></a>         , sig_body  = blah }
<a name="line-546"></a>
<a name="line-547"></a>Note [Pattern signature binders and scoping]
<a name="line-548"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-549"></a>Consider the pattern signatures like those on `t` and `g` in:
<a name="line-550"></a>
<a name="line-551"></a>   f = let h = \(t :: (b, b) -&gt;
<a name="line-552"></a>               \(g :: forall a. a -&gt; b) -&gt;
<a name="line-553"></a>               ...(t :: (Int,Int))...
<a name="line-554"></a>       in woggle
<a name="line-555"></a>
<a name="line-556"></a>* The `b` in t's pattern signature is implicitly bound and scopes over
<a name="line-557"></a>  the signature and the body of the lambda.  It stands for a type (any type);
<a name="line-558"></a>  indeed we subsequently discover that b=Int.
<a name="line-559"></a>  (See Note [TyVarTv] in GHC.Tc.Utils.TcMType for more on this point.)
<a name="line-560"></a>* The `b` in g's pattern signature is an /occurrence/ of the `b` bound by
<a name="line-561"></a>  t's pattern signature.
<a name="line-562"></a>* The `a` in `forall a` scopes only over the type `a -&gt; b`, not over the body
<a name="line-563"></a>  of the lambda.
<a name="line-564"></a>* There is no forall-or-nothing rule for pattern signatures, which is why the
<a name="line-565"></a>  type `forall a. a -&gt; b` is permitted in `g`'s pattern signature, even though
<a name="line-566"></a>  `b` is not explicitly bound. See Note [forall-or-nothing rule].
<a name="line-567"></a>
<a name="line-568"></a>Similar scoping rules apply to term variable binders in RULES, like in the
<a name="line-569"></a>following example:
<a name="line-570"></a>
<a name="line-571"></a>   {-# RULES "h" forall (t :: (b, b)) (g :: forall a. a -&gt; b). h t g = ... #-}
<a name="line-572"></a>
<a name="line-573"></a>Just like in pattern signatures, the `b` in t's signature is implicitly bound
<a name="line-574"></a>and scopes over the remainder of the RULE. As a result, the `b` in g's
<a name="line-575"></a>signature is an occurrence. Moreover, the `a` in `forall a` scopes only over
<a name="line-576"></a>the type `a -&gt; b`, and the forall-or-nothing rule does not apply.
<a name="line-577"></a>
<a name="line-578"></a>While quite similar, RULE term binder signatures behave slightly differently
<a name="line-579"></a>from pattern signatures in two ways:
<a name="line-580"></a>
<a name="line-581"></a>1. Unlike in pattern signatures, where type variables can stand for any type,
<a name="line-582"></a>   type variables in RULE term binder signatures are skolems.
<a name="line-583"></a>   See Note [Typechecking pattern signature binders] in GHC.Tc.Gen.HsType for
<a name="line-584"></a>   more on this point.
<a name="line-585"></a>
<a name="line-586"></a>   In this sense, type variables in pattern signatures are quite similar to
<a name="line-587"></a>   named wildcards, as both can refer to arbitrary types. The main difference
<a name="line-588"></a>   lies in error reporting: if a named wildcard `_a` in a pattern signature
<a name="line-589"></a>   stands for Int, then by default GHC will emit a warning stating as much.
<a name="line-590"></a>   Changing `_a` to `a`, on the other hand, will cause it not to be reported.
<a name="line-591"></a>2. In the `h` RULE above, only term variables are explicitly bound, so any free
<a name="line-592"></a>   type variables in the term variables' signatures are implicitly bound.
<a name="line-593"></a>   This is just like how the free type variables in pattern signatures are
<a name="line-594"></a>   implicitly bound. If a RULE explicitly binds both term and type variables,
<a name="line-595"></a>   however, then free type variables in term signatures are /not/ implicitly
<a name="line-596"></a>   bound. For example, this RULE would be ill scoped:
<a name="line-597"></a>
<a name="line-598"></a>     {-# RULES "h2" forall b. forall (t :: (b, c)) (g :: forall a. a -&gt; b).
<a name="line-599"></a>                    h2 t g = ... #-}
<a name="line-600"></a>
<a name="line-601"></a>   This is because `b` and `c` occur free in the signature for `t`, but only
<a name="line-602"></a>   `b` was explicitly bound, leaving `c` out of scope. If the RULE had started
<a name="line-603"></a>   with `forall b c.`, then it would have been accepted.
<a name="line-604"></a>
<a name="line-605"></a>The types in pattern signatures and RULE term binder signatures are represented
<a name="line-606"></a>in the AST by HsSigPatType. From the renamer onward, the hsps_ext field (of
<a name="line-607"></a>type HsPSRn) tracks the names of named wildcards and implicitly bound type
<a name="line-608"></a>variables so that they can be brought into scope during renaming and
<a name="line-609"></a>typechecking.
<a name="line-610"></a>
<a name="line-611"></a>Note [Lexically scoped type variables]
<a name="line-612"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-613"></a>The ScopedTypeVariables extension does two things:
<a name="line-614"></a>
<a name="line-615"></a>* It allows the use of type signatures in patterns
<a name="line-616"></a>  (e.g., `f (x :: a -&gt; a) = ...`). See
<a name="line-617"></a>  Note [Pattern signature binders and scoping] for more on this point.
<a name="line-618"></a>* It brings lexically scoped type variables into scope for certain type
<a name="line-619"></a>  signatures with outermost invisible 'forall's.
<a name="line-620"></a>
<a name="line-621"></a>This Note concerns the latter bullet point. Per the
<a name="line-622"></a>"Lexically scoped type variables" section of the GHC User's Guide, the
<a name="line-623"></a>following forms of type signatures can have lexically scoped type variables:
<a name="line-624"></a>
<a name="line-625"></a>* In declarations with type signatures, e.g.,
<a name="line-626"></a>
<a name="line-627"></a>    f :: forall a. a -&gt; a
<a name="line-628"></a>    f x = e @a
<a name="line-629"></a>
<a name="line-630"></a>  Here, the 'forall a' brings 'a' into scope over the body of 'f'.
<a name="line-631"></a>
<a name="line-632"></a>  Note that ScopedTypeVariables does /not/ interact with standalone kind
<a name="line-633"></a>  signatures, only type signatures.
<a name="line-634"></a>
<a name="line-635"></a>* In explicit type annotations in expressions, e.g.,
<a name="line-636"></a>
<a name="line-637"></a>    id @a :: forall a. a -&gt; a
<a name="line-638"></a>
<a name="line-639"></a>* In instance declarations, e.g.,
<a name="line-640"></a>
<a name="line-641"></a>    instance forall a. C [a] where
<a name="line-642"></a>      m = e @a
<a name="line-643"></a>
<a name="line-644"></a>  Note that unlike the examples above, the use of an outermost 'forall' isn't
<a name="line-645"></a>  required to bring 'a' into scope. That is, the following would also work:
<a name="line-646"></a>
<a name="line-647"></a>    instance forall a. C [a] where
<a name="line-648"></a>      m = e @a
<a name="line-649"></a>
<a name="line-650"></a>Note that all of the types above obey the forall-or-nothing rule. As a result,
<a name="line-651"></a>the places in the AST that can have lexically scoped type variables are a
<a name="line-652"></a>subset of the places that use HsOuterTyVarBndrs
<a name="line-653"></a>(See Note [forall-or-nothing rule].)
<a name="line-654"></a>
<a name="line-655"></a>Some other observations about lexically scoped type variables:
<a name="line-656"></a>
<a name="line-657"></a>* Only type variables bound by an /invisible/ forall can be lexically scoped.
<a name="line-658"></a>  See Note [hsScopedTvs and visible foralls].
<a name="line-659"></a>* The lexically scoped type variables may be a strict subset of the type
<a name="line-660"></a>  variables brought into scope by a type signature.
<a name="line-661"></a>  See Note [Binding scoped type variables] in GHC.Tc.Gen.Sig.
<a name="line-662"></a>-}</span>
<a name="line-663"></a>
<a name="line-664"></a><a name="mapHsOuterImplicit"></a><span class='hs-definition'>mapHsOuterImplicit</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>XHsOuterImplicit</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>XHsOuterImplicit</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-665"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HsOuterTyVarBndrs</span> <span class='hs-varid'>flag</span> <span class='hs-varid'>pass</span>
<a name="line-666"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HsOuterTyVarBndrs</span> <span class='hs-varid'>flag</span> <span class='hs-varid'>pass</span>
<a name="line-667"></a><span class='hs-definition'>mapHsOuterImplicit</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsOuterImplicit</span><span class='hs-layout'>{</span><span class='hs-varid'>hso_ximplicit</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>imp</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-668"></a>  <span class='hs-conid'>HsOuterImplicit</span><span class='hs-layout'>{</span><span class='hs-varid'>hso_ximplicit</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>imp</span><span class='hs-layout'>}</span>
<a name="line-669"></a><span class='hs-definition'>mapHsOuterImplicit</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>hso</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>HsOuterExplicit</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hso</span>
<a name="line-670"></a><span class='hs-definition'>mapHsOuterImplicit</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>hso</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>XHsOuterTyVarBndrs</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hso</span>
<a name="line-671"></a>
<a name="line-672"></a>
<a name="line-673"></a><a name="HsIPName"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-674"></a><a name="HsIPName"></a><span class='hs-comment'>-- | These names are used early on to store the names of implicit</span>
<a name="line-675"></a><a name="HsIPName"></a><span class='hs-comment'>-- parameters.  They completely disappear after type-checking.</span>
<a name="line-676"></a><a name="HsIPName"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>HsIPName</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsIPName</span> <span class='hs-conid'>FastString</span>
<a name="line-677"></a>  <span class='hs-keyword'>deriving</span><span class='hs-layout'>(</span> <span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Data</span> <span class='hs-layout'>)</span>
<a name="line-678"></a>
<a name="line-679"></a><a name="hsIPNameFS"></a><span class='hs-definition'>hsIPNameFS</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsIPName</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FastString</span>
<a name="line-680"></a><span class='hs-definition'>hsIPNameFS</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsIPName</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<a name="line-681"></a>
<a name="line-682"></a><a name="instance%20Outputable%20HsIPName"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>HsIPName</span> <span class='hs-keyword'>where</span>
<a name="line-683"></a>    <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsIPName</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'?'</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ftext</span> <span class='hs-varid'>n</span> <span class='hs-comment'>-- Ordinary implicit parameters</span>
<a name="line-684"></a>
<a name="line-685"></a><a name="instance%20OutputableBndr%20HsIPName"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>OutputableBndr</span> <span class='hs-conid'>HsIPName</span> <span class='hs-keyword'>where</span>
<a name="line-686"></a>    <span class='hs-varid'>pprBndr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>n</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>n</span>         <span class='hs-comment'>-- Simple for now</span>
<a name="line-687"></a>    <span class='hs-varid'>pprInfixOcc</span>  <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>n</span>
<a name="line-688"></a>    <span class='hs-varid'>pprPrefixOcc</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>n</span>
<a name="line-689"></a>
<a name="line-690"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-691"></a>
<a name="line-692"></a><a name="HsTyVarBndr"></a><span class='hs-comment'>-- | Haskell Type Variable Binder</span>
<a name="line-693"></a><a name="HsTyVarBndr"></a><span class='hs-comment'>-- The flag annotates the binder. It is 'Specificity' in places where</span>
<a name="line-694"></a><a name="HsTyVarBndr"></a><span class='hs-comment'>-- explicit specificity is allowed (e.g. x :: forall {a} b. ...) or</span>
<a name="line-695"></a><a name="HsTyVarBndr"></a><span class='hs-comment'>-- '()' in other places.</span>
<a name="line-696"></a><a name="HsTyVarBndr"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsTyVarBndr</span> <span class='hs-varid'>flag</span> <span class='hs-varid'>pass</span>
<a name="line-697"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UserTyVar</span>        <span class='hs-comment'>-- no explicit kinding</span>
<a name="line-698"></a>         <span class='hs-layout'>(</span><span class='hs-conid'>XUserTyVar</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-699"></a>         <span class='hs-varid'>flag</span>
<a name="line-700"></a>         <span class='hs-layout'>(</span><span class='hs-conid'>LIdP</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-701"></a>        <span class='hs-comment'>-- See Note [Located RdrNames] in GHC.Hs.Expr</span>
<a name="line-702"></a>
<a name="line-703"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>KindedTyVar</span>
<a name="line-704"></a>         <span class='hs-layout'>(</span><span class='hs-conid'>XKindedTyVar</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-705"></a>         <span class='hs-varid'>flag</span>
<a name="line-706"></a>         <span class='hs-layout'>(</span><span class='hs-conid'>LIdP</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-707"></a>         <span class='hs-layout'>(</span><span class='hs-conid'>LHsKind</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- The user-supplied kind signature</span>
<a name="line-708"></a>        <span class='hs-comment'>-- ^</span>
<a name="line-709"></a>        <span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span>
<a name="line-710"></a>        <span class='hs-comment'>--          'GHC.Parser.Annotation.AnnDcolon', 'GHC.Parser.Annotation.AnnClose'</span>
<a name="line-711"></a>
<a name="line-712"></a>        <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-713"></a>
<a name="line-714"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XTyVarBndr</span>
<a name="line-715"></a>      <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXTyVarBndr</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-716"></a>
<a name="line-717"></a><a name="isHsKindedTyVar"></a><span class='hs-comment'>-- | Does this 'HsTyVarBndr' come with an explicit kind annotation?</span>
<a name="line-718"></a><span class='hs-definition'>isHsKindedTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsTyVarBndr</span> <span class='hs-varid'>flag</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-719"></a><span class='hs-definition'>isHsKindedTyVar</span> <span class='hs-layout'>(</span><span class='hs-conid'>UserTyVar</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-720"></a><span class='hs-definition'>isHsKindedTyVar</span> <span class='hs-layout'>(</span><span class='hs-conid'>KindedTyVar</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-721"></a><span class='hs-definition'>isHsKindedTyVar</span> <span class='hs-layout'>(</span><span class='hs-conid'>XTyVarBndr</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-722"></a>
<a name="line-723"></a><a name="HsType"></a><span class='hs-comment'>-- | Haskell Type</span>
<a name="line-724"></a><a name="HsType"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsType</span> <span class='hs-varid'>pass</span>
<a name="line-725"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsForAllTy</span>   <span class='hs-comment'>-- See Note [HsType binders]</span>
<a name="line-726"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>hst_xforall</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XForAllTy</span> <span class='hs-varid'>pass</span>
<a name="line-727"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>hst_tele</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsForAllTelescope</span> <span class='hs-varid'>pass</span>
<a name="line-728"></a>                                     <span class='hs-comment'>-- Explicit, user-supplied 'forall a {b} c'</span>
<a name="line-729"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>hst_body</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span>  <span class='hs-comment'>-- body type</span>
<a name="line-730"></a>      <span class='hs-layout'>}</span>
<a name="line-731"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnForall',</span>
<a name="line-732"></a>      <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnDot','GHC.Parser.Annotation.AnnDarrow'</span>
<a name="line-733"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in "GHC.Parser.Annotation"</span>
<a name="line-734"></a>
<a name="line-735"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsQualTy</span>   <span class='hs-comment'>-- See Note [HsType binders]</span>
<a name="line-736"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>hst_xqual</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XQualTy</span> <span class='hs-varid'>pass</span>
<a name="line-737"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>hst_ctxt</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsContext</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Context C =&gt; blah</span>
<a name="line-738"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>hst_body</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span> <span class='hs-layout'>}</span>
<a name="line-739"></a>
<a name="line-740"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsTyVar</span>  <span class='hs-layout'>(</span><span class='hs-conid'>XTyVar</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-741"></a>              <span class='hs-conid'>PromotionFlag</span>    <span class='hs-comment'>-- Whether explicitly promoted,</span>
<a name="line-742"></a>                               <span class='hs-comment'>-- for the pretty printer</span>
<a name="line-743"></a>             <span class='hs-layout'>(</span><span class='hs-conid'>LIdP</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-744"></a>                  <span class='hs-comment'>-- Type variable, type constructor, or data constructor</span>
<a name="line-745"></a>                  <span class='hs-comment'>-- see Note [Promotions (HsTyVar)]</span>
<a name="line-746"></a>                  <span class='hs-comment'>-- See Note [Located RdrNames] in GHC.Hs.Expr</span>
<a name="line-747"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span>
<a name="line-748"></a>
<a name="line-749"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-750"></a>
<a name="line-751"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsAppTy</span>             <span class='hs-layout'>(</span><span class='hs-conid'>XAppTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-752"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-753"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-754"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span>
<a name="line-755"></a>
<a name="line-756"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-757"></a>
<a name="line-758"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsAppKindTy</span>         <span class='hs-layout'>(</span><span class='hs-conid'>XAppKindTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- type level type app</span>
<a name="line-759"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-760"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>LHsKind</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-761"></a>
<a name="line-762"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsFunTy</span>             <span class='hs-layout'>(</span><span class='hs-conid'>XFunTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-763"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>HsArrow</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-764"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- function type</span>
<a name="line-765"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-766"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnRarrow',</span>
<a name="line-767"></a>
<a name="line-768"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-769"></a>
<a name="line-770"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsListTy</span>            <span class='hs-layout'>(</span><span class='hs-conid'>XListTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-771"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Element type</span>
<a name="line-772"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'['@,</span>
<a name="line-773"></a>      <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnClose' @']'@</span>
<a name="line-774"></a>
<a name="line-775"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-776"></a>
<a name="line-777"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsTupleTy</span>           <span class='hs-layout'>(</span><span class='hs-conid'>XTupleTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-778"></a>                        <span class='hs-conid'>HsTupleSort</span>
<a name="line-779"></a>                        <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- Element types (length gives arity)</span>
<a name="line-780"></a>    <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'(' or '(#'@,</span>
<a name="line-781"></a>    <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnClose' @')' or '#)'@</span>
<a name="line-782"></a>
<a name="line-783"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-784"></a>
<a name="line-785"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsSumTy</span>             <span class='hs-layout'>(</span><span class='hs-conid'>XSumTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-786"></a>                        <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- Element types (length gives arity)</span>
<a name="line-787"></a>    <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'(#'@,</span>
<a name="line-788"></a>    <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnClose' '#)'@</span>
<a name="line-789"></a>
<a name="line-790"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-791"></a>
<a name="line-792"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsOpTy</span>              <span class='hs-layout'>(</span><span class='hs-conid'>XOpTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-793"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LIdP</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-794"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span>
<a name="line-795"></a>
<a name="line-796"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-797"></a>
<a name="line-798"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsParTy</span>             <span class='hs-layout'>(</span><span class='hs-conid'>XParTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-799"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- See Note [Parens in HsSyn] in GHC.Hs.Expr</span>
<a name="line-800"></a>        <span class='hs-comment'>-- Parenthesis preserved for the precedence re-arrangement in</span>
<a name="line-801"></a>        <span class='hs-comment'>-- GHC.Rename.HsType</span>
<a name="line-802"></a>        <span class='hs-comment'>-- It's important that a * (b + c) doesn't get rearranged to (a*b) + c!</span>
<a name="line-803"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'('@,</span>
<a name="line-804"></a>      <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnClose' @')'@</span>
<a name="line-805"></a>
<a name="line-806"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-807"></a>
<a name="line-808"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsIParamTy</span>          <span class='hs-layout'>(</span><span class='hs-conid'>XIParamTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-809"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>XRec</span> <span class='hs-varid'>pass</span> <span class='hs-conid'>HsIPName</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- (?x :: ty)</span>
<a name="line-810"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- Implicit parameters as they occur in</span>
<a name="line-811"></a>                                         <span class='hs-comment'>-- contexts</span>
<a name="line-812"></a>      <span class='hs-comment'>-- ^</span>
<a name="line-813"></a>      <span class='hs-comment'>-- &gt; (?x :: ty)</span>
<a name="line-814"></a>      <span class='hs-comment'>--</span>
<a name="line-815"></a>      <span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon'</span>
<a name="line-816"></a>
<a name="line-817"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-818"></a>
<a name="line-819"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsStarTy</span>            <span class='hs-layout'>(</span><span class='hs-conid'>XStarTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-820"></a>                        <span class='hs-conid'>Bool</span>             <span class='hs-comment'>-- Is this the Unicode variant?</span>
<a name="line-821"></a>                                         <span class='hs-comment'>-- Note [HsStarTy]</span>
<a name="line-822"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span>
<a name="line-823"></a>
<a name="line-824"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsKindSig</span>           <span class='hs-layout'>(</span><span class='hs-conid'>XKindSig</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-825"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- (ty :: kind)</span>
<a name="line-826"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>LHsKind</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- A type with a kind signature</span>
<a name="line-827"></a>      <span class='hs-comment'>-- ^</span>
<a name="line-828"></a>      <span class='hs-comment'>-- &gt; (ty :: kind)</span>
<a name="line-829"></a>      <span class='hs-comment'>--</span>
<a name="line-830"></a>      <span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'('@,</span>
<a name="line-831"></a>      <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnDcolon','GHC.Parser.Annotation.AnnClose' @')'@</span>
<a name="line-832"></a>
<a name="line-833"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-834"></a>
<a name="line-835"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsSpliceTy</span>          <span class='hs-layout'>(</span><span class='hs-conid'>XSpliceTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-836"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>HsSplice</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- Includes quasi-quotes</span>
<a name="line-837"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'$('@,</span>
<a name="line-838"></a>      <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnClose' @')'@</span>
<a name="line-839"></a>
<a name="line-840"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-841"></a>
<a name="line-842"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsDocTy</span>             <span class='hs-layout'>(</span><span class='hs-conid'>XDocTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-843"></a>                        <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span> <span class='hs-conid'>LHsDocString</span> <span class='hs-comment'>-- A documented type</span>
<a name="line-844"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span>
<a name="line-845"></a>
<a name="line-846"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-847"></a>
<a name="line-848"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsBangTy</span>    <span class='hs-layout'>(</span><span class='hs-conid'>XBangTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-849"></a>                <span class='hs-conid'>HsSrcBang</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- Bang-style type annotations</span>
<a name="line-850"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' :</span>
<a name="line-851"></a>      <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnOpen' @'{-\# UNPACK' or '{-\# NOUNPACK'@,</span>
<a name="line-852"></a>      <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnClose' @'#-}'@</span>
<a name="line-853"></a>      <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnBang' @\'!\'@</span>
<a name="line-854"></a>
<a name="line-855"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-856"></a>
<a name="line-857"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsRecTy</span>     <span class='hs-layout'>(</span><span class='hs-conid'>XRecTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-858"></a>                <span class='hs-keyglyph'>[</span><span class='hs-conid'>LConDeclField</span> <span class='hs-varid'>pass</span><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- Only in data type declarations</span>
<a name="line-859"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'{'@,</span>
<a name="line-860"></a>      <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnClose' @'}'@</span>
<a name="line-861"></a>
<a name="line-862"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-863"></a>
<a name="line-864"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsExplicitListTy</span>       <span class='hs-comment'>-- A promoted explicit list</span>
<a name="line-865"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>XExplicitListTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-866"></a>        <span class='hs-conid'>PromotionFlag</span>      <span class='hs-comment'>-- whether explicitly promoted, for pretty printer</span>
<a name="line-867"></a>        <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-keyglyph'>]</span>
<a name="line-868"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @"'["@,</span>
<a name="line-869"></a>      <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnClose' @']'@</span>
<a name="line-870"></a>
<a name="line-871"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-872"></a>
<a name="line-873"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsExplicitTupleTy</span>      <span class='hs-comment'>-- A promoted explicit tuple</span>
<a name="line-874"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>XExplicitTupleTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-875"></a>        <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-keyglyph'>]</span>
<a name="line-876"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @"'("@,</span>
<a name="line-877"></a>      <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnClose' @')'@</span>
<a name="line-878"></a>
<a name="line-879"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-880"></a>
<a name="line-881"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsTyLit</span> <span class='hs-layout'>(</span><span class='hs-conid'>XTyLit</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span> <span class='hs-conid'>HsTyLit</span>      <span class='hs-comment'>-- A promoted numeric literal.</span>
<a name="line-882"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span>
<a name="line-883"></a>
<a name="line-884"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-885"></a>
<a name="line-886"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsWildCardTy</span> <span class='hs-layout'>(</span><span class='hs-conid'>XWildCardTy</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- A type wildcard</span>
<a name="line-887"></a>      <span class='hs-comment'>-- See Note [The wildcard story for types]</span>
<a name="line-888"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span>
<a name="line-889"></a>
<a name="line-890"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-891"></a>
<a name="line-892"></a>  <span class='hs-comment'>-- For adding new constructors via Trees that Grow</span>
<a name="line-893"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XHsType</span>
<a name="line-894"></a>      <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-895"></a>
<a name="line-896"></a><a name="HsCoreTy"></a><span class='hs-comment'>-- An escape hatch for tunnelling a Core 'Type' through 'HsType'.</span>
<a name="line-897"></a><a name="HsCoreTy"></a><span class='hs-comment'>-- For more details on how this works, see:</span>
<a name="line-898"></a><a name="HsCoreTy"></a><span class='hs-comment'>--</span>
<a name="line-899"></a><a name="HsCoreTy"></a><span class='hs-comment'>-- * @Note [Renaming HsCoreTys]@ in "GHC.Rename.HsType"</span>
<a name="line-900"></a><a name="HsCoreTy"></a><span class='hs-comment'>--</span>
<a name="line-901"></a><a name="HsCoreTy"></a><span class='hs-comment'>-- * @Note [Typechecking HsCoreTys]@ in "GHC.Tc.Gen.HsType"</span>
<a name="line-902"></a><a name="HsCoreTy"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>HsCoreTy</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span>
<a name="line-903"></a>
<a name="line-904"></a>
<a name="line-905"></a><a name="HsTyLit"></a><span class='hs-comment'>-- Note [Literal source text] in GHC.Types.Basic for SourceText fields in</span>
<a name="line-906"></a><a name="HsTyLit"></a><span class='hs-comment'>-- the following</span>
<a name="line-907"></a><a name="HsTyLit"></a><span class='hs-comment'>-- | Haskell Type Literal</span>
<a name="line-908"></a><a name="HsTyLit"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsTyLit</span>
<a name="line-909"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsNumTy</span> <span class='hs-conid'>SourceText</span> <span class='hs-conid'>Integer</span>
<a name="line-910"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsStrTy</span> <span class='hs-conid'>SourceText</span> <span class='hs-conid'>FastString</span>
<a name="line-911"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsCharTy</span> <span class='hs-conid'>SourceText</span> <span class='hs-conid'>Char</span>
<a name="line-912"></a>    <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-913"></a>
<a name="line-914"></a><a name="HsArrow"></a><span class='hs-comment'>-- | Denotes the type of arrows in the surface language</span>
<a name="line-915"></a><a name="HsArrow"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsArrow</span> <span class='hs-varid'>pass</span>
<a name="line-916"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsUnrestrictedArrow</span> <span class='hs-conid'>IsUnicodeSyntax</span>
<a name="line-917"></a>    <span class='hs-comment'>-- ^ a -&gt; b or a  b</span>
<a name="line-918"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsLinearArrow</span> <span class='hs-conid'>IsUnicodeSyntax</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>AddEpAnn</span><span class='hs-layout'>)</span>
<a name="line-919"></a>    <span class='hs-comment'>-- ^ a %1 -&gt; b or a %1  b, or a  b</span>
<a name="line-920"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsExplicitMult</span> <span class='hs-conid'>IsUnicodeSyntax</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>AddEpAnn</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-921"></a>    <span class='hs-comment'>-- ^ a %m -&gt; b or a %m  b (very much including `a %Many -&gt; b`!</span>
<a name="line-922"></a>    <span class='hs-comment'>-- This is how the programmer wrote it). It is stored as an</span>
<a name="line-923"></a>    <span class='hs-comment'>-- `HsType` so as to preserve the syntax as written in the</span>
<a name="line-924"></a>    <span class='hs-comment'>-- program.</span>
<a name="line-925"></a>
<a name="line-926"></a><a name="HsScaled"></a><span class='hs-comment'>-- | This is used in the syntax. In constructor declaration. It must keep the</span>
<a name="line-927"></a><a name="HsScaled"></a><span class='hs-comment'>-- arrow representation.</span>
<a name="line-928"></a><a name="HsScaled"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsScaled</span> <span class='hs-varid'>pass</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsScaled</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsArrow</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span>
<a name="line-929"></a>
<a name="line-930"></a><a name="hsMult"></a><span class='hs-definition'>hsMult</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsScaled</span> <span class='hs-varid'>pass</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HsArrow</span> <span class='hs-varid'>pass</span>
<a name="line-931"></a><span class='hs-definition'>hsMult</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsScaled</span> <span class='hs-varid'>m</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m</span>
<a name="line-932"></a>
<a name="line-933"></a><a name="hsScaledThing"></a><span class='hs-definition'>hsScaledThing</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsScaled</span> <span class='hs-varid'>pass</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-934"></a><span class='hs-definition'>hsScaledThing</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsScaled</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t</span>
<a name="line-935"></a>
<a name="line-936"></a><a name="hsUnrestricted"></a><span class='hs-comment'>-- | When creating syntax we use the shorthands. It's better for printing, also,</span>
<a name="line-937"></a><span class='hs-comment'>-- the shorthands work trivially at each pass.</span>
<a name="line-938"></a><span class='hs-definition'>hsUnrestricted</span><span class='hs-layout'>,</span> <span class='hs-varid'>hsLinear</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HsScaled</span> <span class='hs-varid'>pass</span> <span class='hs-varid'>a</span>
<a name="line-939"></a><span class='hs-definition'>hsUnrestricted</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsScaled</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsUnrestrictedArrow</span> <span class='hs-conid'>NormalSyntax</span><span class='hs-layout'>)</span>
<a name="line-940"></a><a name="hsLinear"></a><span class='hs-definition'>hsLinear</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsScaled</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsLinearArrow</span> <span class='hs-conid'>NormalSyntax</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span>
<a name="line-941"></a>
<a name="line-942"></a><a name="instance%20Outputable%20(HsScaled%20pass%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsScaled</span> <span class='hs-varid'>pass</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-943"></a>   <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsScaled</span> <span class='hs-sel'>_cnt</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- ppr cnt &lt;&gt; ppr t</span>
<a name="line-944"></a>                            <span class='hs-varid'>ppr</span> <span class='hs-varid'>t</span>
<a name="line-945"></a>
<a name="line-946"></a><span class='hs-comment'>{-
<a name="line-947"></a>Note [Unit tuples]
<a name="line-948"></a>~~~~~~~~~~~~~~~~~~
<a name="line-949"></a>Consider the type
<a name="line-950"></a>    type instance F Int = ()
<a name="line-951"></a>We want to parse that "()"
<a name="line-952"></a>    as HsTupleTy HsBoxedOrConstraintTuple [],
<a name="line-953"></a>NOT as HsTyVar unitTyCon
<a name="line-954"></a>
<a name="line-955"></a>Why? Because F might have kind (* -&gt; Constraint), so we when parsing we
<a name="line-956"></a>don't know if that tuple is going to be a constraint tuple or an ordinary
<a name="line-957"></a>unit tuple.  The HsTupleSort flag is specifically designed to deal with
<a name="line-958"></a>that, but it has to work for unit tuples too.
<a name="line-959"></a>
<a name="line-960"></a>Note [Promotions (HsTyVar)]
<a name="line-961"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-962"></a>HsTyVar: A name in a type or kind.
<a name="line-963"></a>  Here are the allowed namespaces for the name.
<a name="line-964"></a>    In a type:
<a name="line-965"></a>      Var: not allowed
<a name="line-966"></a>      Data: promoted data constructor
<a name="line-967"></a>      Tv: type variable
<a name="line-968"></a>      TcCls before renamer: type constructor, class constructor, or promoted data constructor
<a name="line-969"></a>      TcCls after renamer: type constructor or class constructor
<a name="line-970"></a>    In a kind:
<a name="line-971"></a>      Var, Data: not allowed
<a name="line-972"></a>      Tv: kind variable
<a name="line-973"></a>      TcCls: kind constructor or promoted type constructor
<a name="line-974"></a>
<a name="line-975"></a>  The 'Promoted' field in an HsTyVar captures whether the type was promoted in
<a name="line-976"></a>  the source code by prefixing an apostrophe.
<a name="line-977"></a>
<a name="line-978"></a>Note [HsStarTy]
<a name="line-979"></a>~~~~~~~~~~~~~~~
<a name="line-980"></a>When the StarIsType extension is enabled, we want to treat '*' and its Unicode
<a name="line-981"></a>variant identically to 'Data.Kind.Type'. Unfortunately, doing so in the parser
<a name="line-982"></a>would mean that when we pretty-print it back, we don't know whether the user
<a name="line-983"></a>wrote '*' or 'Type', and lose the parse/ppr roundtrip property.
<a name="line-984"></a>
<a name="line-985"></a>As a workaround, we parse '*' as HsStarTy (if it stands for 'Data.Kind.Type')
<a name="line-986"></a>and then desugar it to 'Data.Kind.Type' in the typechecker (see tc_hs_type).
<a name="line-987"></a>When '*' is a regular type operator (StarIsType is disabled), HsStarTy is not
<a name="line-988"></a>involved.
<a name="line-989"></a>
<a name="line-990"></a>
<a name="line-991"></a>Note [Promoted lists and tuples]
<a name="line-992"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-993"></a>Notice the difference between
<a name="line-994"></a>   HsListTy    HsExplicitListTy
<a name="line-995"></a>   HsTupleTy   HsExplicitListTupleTy
<a name="line-996"></a>
<a name="line-997"></a>E.g.    f :: [Int]                      HsListTy
<a name="line-998"></a>
<a name="line-999"></a>        g3  :: T '[]                   All these use
<a name="line-1000"></a>        g2  :: T '[True]                  HsExplicitListTy
<a name="line-1001"></a>        g1  :: T '[True,False]
<a name="line-1002"></a>        g1a :: T [True,False]             (can omit ' where unambiguous)
<a name="line-1003"></a>
<a name="line-1004"></a>  kind of T :: [Bool] -&gt; *        This kind uses HsListTy!
<a name="line-1005"></a>
<a name="line-1006"></a>E.g.    h :: (Int,Bool)                 HsTupleTy; f is a pair
<a name="line-1007"></a>        k :: S '(True,False)            HsExplicitTypleTy; S is indexed by
<a name="line-1008"></a>                                           a type-level pair of booleans
<a name="line-1009"></a>        kind of S :: (Bool,Bool) -&gt; *   This kind uses HsExplicitTupleTy
<a name="line-1010"></a>
<a name="line-1011"></a>Note [Distinguishing tuple kinds]
<a name="line-1012"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1013"></a>
<a name="line-1014"></a>Apart from promotion, tuples can have one of three different kinds:
<a name="line-1015"></a>
<a name="line-1016"></a>        x :: (Int, Bool)                -- Regular boxed tuples
<a name="line-1017"></a>        f :: Int# -&gt; (# Int#, Int# #)   -- Unboxed tuples
<a name="line-1018"></a>        g :: (Eq a, Ord a) =&gt; a         -- Constraint tuples
<a name="line-1019"></a>
<a name="line-1020"></a>For convenience, internally we use a single constructor for all of these,
<a name="line-1021"></a>namely HsTupleTy, but keep track of the tuple kind (in the first argument to
<a name="line-1022"></a>HsTupleTy, a HsTupleSort). We can tell if a tuple is unboxed while parsing,
<a name="line-1023"></a>because of the #. However, with -XConstraintKinds we can only distinguish
<a name="line-1024"></a>between constraint and boxed tuples during type checking, in general. Hence the
<a name="line-1025"></a>two constructors of HsTupleSort:
<a name="line-1026"></a>
<a name="line-1027"></a>        HsUnboxedTuple                  -&gt; Produced by the parser
<a name="line-1028"></a>        HsBoxedOrConstraintTuple        -&gt; Could be a boxed or a constraint
<a name="line-1029"></a>                                        tuple. Produced by the parser only,
<a name="line-1030"></a>                                        disappears after type checking
<a name="line-1031"></a>
<a name="line-1032"></a>After typechecking, we use TupleSort (which clearly distinguishes between
<a name="line-1033"></a>constraint tuples and boxed tuples) rather than HsTupleSort.
<a name="line-1034"></a>-}</span>
<a name="line-1035"></a>
<a name="line-1036"></a><a name="HsTupleSort"></a><span class='hs-comment'>-- | Haskell Tuple Sort</span>
<a name="line-1037"></a><a name="HsTupleSort"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsTupleSort</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsUnboxedTuple</span>
<a name="line-1038"></a>                 <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsBoxedOrConstraintTuple</span>
<a name="line-1039"></a>                 <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-1040"></a>
<a name="line-1041"></a><a name="LConDeclField"></a><span class='hs-comment'>-- | Located Constructor Declaration Field</span>
<a name="line-1042"></a><a name="LConDeclField"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LConDeclField</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>pass</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConDeclField</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-1043"></a>      <span class='hs-comment'>-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when</span>
<a name="line-1044"></a>      <span class='hs-comment'>--   in a list</span>
<a name="line-1045"></a>
<a name="line-1046"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-1047"></a>
<a name="line-1048"></a><a name="ConDeclField"></a><span class='hs-comment'>-- | Constructor Declaration Field</span>
<a name="line-1049"></a><a name="ConDeclField"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ConDeclField</span> <span class='hs-varid'>pass</span>  <span class='hs-comment'>-- Record fields have Haddock docs on them</span>
<a name="line-1050"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ConDeclField</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cd_fld_ext</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XConDeclField</span> <span class='hs-varid'>pass</span><span class='hs-layout'>,</span>
<a name="line-1051"></a>                   <span class='hs-varid'>cd_fld_names</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LFieldOcc</span> <span class='hs-varid'>pass</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>
<a name="line-1052"></a>                                   <span class='hs-comment'>-- ^ See Note [ConDeclField passs]</span>
<a name="line-1053"></a>                   <span class='hs-varid'>cd_fld_type</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LBangType</span> <span class='hs-varid'>pass</span><span class='hs-layout'>,</span>
<a name="line-1054"></a>                   <span class='hs-varid'>cd_fld_doc</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>LHsDocString</span> <span class='hs-layout'>}</span>
<a name="line-1055"></a>      <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon'</span>
<a name="line-1056"></a>
<a name="line-1057"></a>      <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-1058"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XConDeclField</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXConDeclField</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-1059"></a>
<a name="line-1060"></a><a name="HsConDetails"></a><span class='hs-comment'>-- | Describes the arguments to a data constructor. This is a common</span>
<a name="line-1061"></a><a name="HsConDetails"></a><span class='hs-comment'>-- representation for several constructor-related concepts, including:</span>
<a name="line-1062"></a><a name="HsConDetails"></a><span class='hs-comment'>--</span>
<a name="line-1063"></a><a name="HsConDetails"></a><span class='hs-comment'>-- * The arguments in a Haskell98-style constructor declaration</span>
<a name="line-1064"></a><a name="HsConDetails"></a><span class='hs-comment'>--   (see 'HsConDeclH98Details' in "GHC.Hs.Decls").</span>
<a name="line-1065"></a><a name="HsConDetails"></a><span class='hs-comment'>--</span>
<a name="line-1066"></a><a name="HsConDetails"></a><span class='hs-comment'>-- * The arguments in constructor patterns in @case@/function definitions</span>
<a name="line-1067"></a><a name="HsConDetails"></a><span class='hs-comment'>--   (see 'HsConPatDetails' in "GHC.Hs.Pat").</span>
<a name="line-1068"></a><a name="HsConDetails"></a><span class='hs-comment'>--</span>
<a name="line-1069"></a><a name="HsConDetails"></a><span class='hs-comment'>-- * The left-hand side arguments in a pattern synonym binding</span>
<a name="line-1070"></a><a name="HsConDetails"></a><span class='hs-comment'>--   (see 'HsPatSynDetails' in "GHC.Hs.Binds").</span>
<a name="line-1071"></a><a name="HsConDetails"></a><span class='hs-comment'>--</span>
<a name="line-1072"></a><a name="HsConDetails"></a><span class='hs-comment'>-- One notable exception is the arguments in a GADT constructor, which uses</span>
<a name="line-1073"></a><a name="HsConDetails"></a><span class='hs-comment'>-- a separate data type entirely (see 'HsConDeclGADTDetails' in</span>
<a name="line-1074"></a><a name="HsConDetails"></a><span class='hs-comment'>-- "GHC.Hs.Decls"). This is because GADT constructors cannot be declared with</span>
<a name="line-1075"></a><a name="HsConDetails"></a><span class='hs-comment'>-- infix syntax, unlike the concepts above (#18844).</span>
<a name="line-1076"></a><a name="HsConDetails"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsConDetails</span> <span class='hs-varid'>tyarg</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>rec</span>
<a name="line-1077"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PrefixCon</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>tyarg</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- C @t1 @t2 p1 p2 p3</span>
<a name="line-1078"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>RecCon</span>    <span class='hs-varid'>rec</span>               <span class='hs-comment'>-- C { x = p1, y = p2 }</span>
<a name="line-1079"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>InfixCon</span>  <span class='hs-varid'>arg</span> <span class='hs-varid'>arg</span>           <span class='hs-comment'>-- p1 `C` p2</span>
<a name="line-1080"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-1081"></a>
<a name="line-1082"></a><a name="noTypeArgs"></a><span class='hs-comment'>-- | An empty list that can be used to indicate that there are no</span>
<a name="line-1083"></a><span class='hs-comment'>-- type arguments allowed in cases where HsConDetails is applied to Void.</span>
<a name="line-1084"></a><span class='hs-definition'>noTypeArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Void</span><span class='hs-keyglyph'>]</span>
<a name="line-1085"></a><span class='hs-definition'>noTypeArgs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-1086"></a>
<a name="line-1087"></a><a name="instance%20Outputable%20(HsConDetails%20tyarg%20arg%20rec)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Outputable</span> <span class='hs-varid'>tyarg</span><span class='hs-layout'>,</span> <span class='hs-conid'>Outputable</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-conid'>Outputable</span> <span class='hs-varid'>rec</span><span class='hs-layout'>)</span>
<a name="line-1088"></a>         <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsConDetails</span> <span class='hs-varid'>tyarg</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>rec</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-1089"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>PrefixCon</span> <span class='hs-varid'>tyargs</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"PrefixCon:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>hsep</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"@"</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>tyargs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>args</span>
<a name="line-1090"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>RecCon</span> <span class='hs-varid'>rec</span><span class='hs-layout'>)</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"RecCon:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rec</span>
<a name="line-1091"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>InfixCon</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"InfixCon:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-keyglyph'>]</span>
<a name="line-1092"></a>
<a name="line-1093"></a><span class='hs-comment'>{-
<a name="line-1094"></a>Note [ConDeclField passs]
<a name="line-1095"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1096"></a>
<a name="line-1097"></a>A ConDeclField contains a list of field occurrences: these always
<a name="line-1098"></a>include the field label as the user wrote it.  After the renamer, it
<a name="line-1099"></a>will additionally contain the identity of the selector function in the
<a name="line-1100"></a>second component.
<a name="line-1101"></a>
<a name="line-1102"></a>Due to DuplicateRecordFields, the OccName of the selector function
<a name="line-1103"></a>may have been mangled, which is why we keep the original field label
<a name="line-1104"></a>separately.  For example, when DuplicateRecordFields is enabled
<a name="line-1105"></a>
<a name="line-1106"></a>    data T = MkT { x :: Int }
<a name="line-1107"></a>
<a name="line-1108"></a>gives
<a name="line-1109"></a>
<a name="line-1110"></a>    ConDeclField { cd_fld_names = [L _ (FieldOcc "x" $sel:x:MkT)], ... }.
<a name="line-1111"></a>-}</span>
<a name="line-1112"></a>
<a name="line-1113"></a><span class='hs-comment'>-----------------------</span>
<a name="line-1114"></a><span class='hs-comment'>-- A valid type must have a for-all at the top of the type, or of the fn arg</span>
<a name="line-1115"></a><span class='hs-comment'>-- types</span>
<a name="line-1116"></a>
<a name="line-1117"></a><span class='hs-comment'>---------------------</span>
<a name="line-1118"></a>
<a name="line-1119"></a><span class='hs-comment'>{- Note [Scoping of named wildcards]
<a name="line-1120"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1121"></a>Consider
<a name="line-1122"></a>  f :: _a -&gt; _a
<a name="line-1123"></a>  f x = let g :: _a -&gt; _a
<a name="line-1124"></a>            g = ...
<a name="line-1125"></a>        in ...
<a name="line-1126"></a>
<a name="line-1127"></a>Currently, for better or worse, the "_a" variables are all the same. So
<a name="line-1128"></a>although there is no explicit forall, the "_a" scopes over the definition.
<a name="line-1129"></a>I don't know if this is a good idea, but there it is.
<a name="line-1130"></a>-}</span>
<a name="line-1131"></a>
<a name="line-1132"></a><span class='hs-comment'>{- Note [hsScopedTvs and visible foralls]
<a name="line-1133"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1134"></a>-XScopedTypeVariables can be defined in terms of a desugaring to
<a name="line-1135"></a>-XTypeAbstractions (GHC Proposal #50):
<a name="line-1136"></a>
<a name="line-1137"></a>    fn :: forall a b c. tau(a,b,c)            fn :: forall a b c. tau(a,b,c)
<a name="line-1138"></a>    fn = defn(a,b,c)                   ==&gt;    fn @x @y @z = defn(x,y,z)
<a name="line-1139"></a>
<a name="line-1140"></a>That is, for every type variable of the leading 'forall' in the type signature,
<a name="line-1141"></a>we add an invisible binder at term level.
<a name="line-1142"></a>
<a name="line-1143"></a>This model does not extend to visible forall, as discussed here:
<a name="line-1144"></a>
<a name="line-1145"></a>* https://gitlab.haskell.org/ghc/ghc/issues/16734#note_203412
<a name="line-1146"></a>* https://github.com/ghc-proposals/ghc-proposals/pull/238
<a name="line-1147"></a>
<a name="line-1148"></a>The conclusion of these discussions can be summarized as follows:
<a name="line-1149"></a>
<a name="line-1150"></a>  &gt; Assuming support for visible 'forall' in terms, consider this example:
<a name="line-1151"></a>  &gt;
<a name="line-1152"></a>  &gt;     vfn :: forall x y -&gt; tau(x,y)
<a name="line-1153"></a>  &gt;     vfn = \a b -&gt; ...
<a name="line-1154"></a>  &gt;
<a name="line-1155"></a>  &gt; The user has written their own binders 'a' and 'b' to stand for 'x' and
<a name="line-1156"></a>  &gt; 'y', and we definitely should not desugar this into:
<a name="line-1157"></a>  &gt;
<a name="line-1158"></a>  &gt;     vfn :: forall x y -&gt; tau(x,y)
<a name="line-1159"></a>  &gt;     vfn x y = \a b -&gt; ...         -- bad!
<a name="line-1160"></a>
<a name="line-1161"></a>This design choice is reflected in the design of HsOuterSigTyVarBndrs, which are
<a name="line-1162"></a>used in every place that ScopedTypeVariables takes effect:
<a name="line-1163"></a>
<a name="line-1164"></a>  data HsOuterTyVarBndrs flag pass
<a name="line-1165"></a>    = HsOuterImplicit { ... }
<a name="line-1166"></a>    | HsOuterExplicit { ..., hso_bndrs :: [LHsTyVarBndr flag pass] }
<a name="line-1167"></a>    | ...
<a name="line-1168"></a>  type HsOuterSigTyVarBndrs = HsOuterTyVarBndrs Specificity
<a name="line-1169"></a>
<a name="line-1170"></a>The HsOuterExplicit constructor is only used in type signatures with outermost,
<a name="line-1171"></a>/invisible/ 'forall's. Any other typeincluding those with outermost,
<a name="line-1172"></a>/visible/ 'forall'swill use HsOuterImplicit. Therefore, when we determine
<a name="line-1173"></a>which type variables to bring into scope over the body of a function
<a name="line-1174"></a>(in hsScopedTvs), we /only/ bring the type variables bound by the hso_bndrs in
<a name="line-1175"></a>an HsOuterExplicit into scope. If we have an HsOuterImplicit instead, then we
<a name="line-1176"></a>do not bring any type variables into scope over the body of a function at all.
<a name="line-1177"></a>
<a name="line-1178"></a>At the moment, GHC does not support visible 'forall' in terms. Nevertheless,
<a name="line-1179"></a>it is still possible to write erroneous programs that use visible 'forall's in
<a name="line-1180"></a>terms, such as this example:
<a name="line-1181"></a>
<a name="line-1182"></a>    x :: forall a -&gt; a -&gt; a
<a name="line-1183"></a>    x = x
<a name="line-1184"></a>
<a name="line-1185"></a>Previous versions of GHC would bring `a` into scope over the body of `x` in the
<a name="line-1186"></a>hopes that the typechecker would error out later
<a name="line-1187"></a>(see `GHC.Tc.Validity.vdqAllowed`). However, this can wreak havoc in the
<a name="line-1188"></a>renamer before GHC gets to that point (see #17687 for an example of this).
<a name="line-1189"></a>Bottom line: nip problems in the bud by refraining from bringing any type
<a name="line-1190"></a>variables in an HsOuterImplicit into scope over the body of a function, even
<a name="line-1191"></a>if they correspond to a visible 'forall'.
<a name="line-1192"></a>-}</span>
<a name="line-1193"></a>
<a name="line-1194"></a><span class='hs-comment'>{-
<a name="line-1195"></a>************************************************************************
<a name="line-1196"></a>*                                                                      *
<a name="line-1197"></a>                Decomposing HsTypes
<a name="line-1198"></a>*                                                                      *
<a name="line-1199"></a>************************************************************************
<a name="line-1200"></a>-}</span>
<a name="line-1201"></a>
<a name="line-1202"></a><a name="HsArg"></a><span class='hs-comment'>-- Arguments in an expression/type after splitting</span>
<a name="line-1203"></a><a name="HsArg"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsArg</span> <span class='hs-varid'>tm</span> <span class='hs-varid'>ty</span>
<a name="line-1204"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsValArg</span> <span class='hs-varid'>tm</span>   <span class='hs-comment'>-- Argument is an ordinary expression     (f arg)</span>
<a name="line-1205"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsTypeArg</span> <span class='hs-conid'>SrcSpan</span> <span class='hs-varid'>ty</span> <span class='hs-comment'>-- Argument is a visible type application (f @ty)</span>
<a name="line-1206"></a>                         <span class='hs-comment'>-- SrcSpan is location of the `@`</span>
<a name="line-1207"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsArgPar</span> <span class='hs-conid'>SrcSpan</span> <span class='hs-comment'>-- See Note [HsArgPar]</span>
<a name="line-1208"></a>
<a name="line-1209"></a><a name="numVisibleArgs"></a><span class='hs-definition'>numVisibleArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>HsArg</span> <span class='hs-varid'>tm</span> <span class='hs-varid'>ty</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arity</span>
<a name="line-1210"></a><span class='hs-definition'>numVisibleArgs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>count</span> <span class='hs-varid'>is_vis</span>
<a name="line-1211"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>is_vis</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsValArg</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1212"></a>        <span class='hs-varid'>is_vis</span> <span class='hs-keyword'>_</span>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1213"></a>
<a name="line-1214"></a><a name="LHsTypeArg"></a><span class='hs-comment'>-- type level equivalent</span>
<a name="line-1215"></a><a name="LHsTypeArg"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsTypeArg</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsKind</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-1216"></a>
<a name="line-1217"></a><a name="instance%20Outputable%20(HsArg%20tm%20ty)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Outputable</span> <span class='hs-varid'>tm</span><span class='hs-layout'>,</span> <span class='hs-conid'>Outputable</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsArg</span> <span class='hs-varid'>tm</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-1218"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsValArg</span> <span class='hs-varid'>tm</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tm</span>
<a name="line-1219"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsTypeArg</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'@'</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span>
<a name="line-1220"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsArgPar</span> <span class='hs-varid'>sp</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"HsArgPar"</span>  <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>sp</span>
<a name="line-1221"></a><span class='hs-comment'>{-
<a name="line-1222"></a>Note [HsArgPar]
<a name="line-1223"></a>A HsArgPar indicates that everything to the left of this in the argument list is
<a name="line-1224"></a>enclosed in parentheses together with the function itself. It is necessary so
<a name="line-1225"></a>that we can recreate the parenthesis structure in the original source after
<a name="line-1226"></a>typechecking the arguments.
<a name="line-1227"></a>
<a name="line-1228"></a>The SrcSpan is the span of the original HsPar
<a name="line-1229"></a>
<a name="line-1230"></a>((f arg1) arg2 arg3) results in an input argument list of
<a name="line-1231"></a>[HsValArg arg1, HsArgPar span1, HsValArg arg2, HsValArg arg3, HsArgPar span2]
<a name="line-1232"></a>
<a name="line-1233"></a>-}</span>
<a name="line-1234"></a>
<a name="line-1235"></a><span class='hs-comment'>--------------------------------</span>
<a name="line-1236"></a>
<a name="line-1237"></a>
<a name="line-1238"></a><span class='hs-comment'>{-
<a name="line-1239"></a>************************************************************************
<a name="line-1240"></a>*                                                                      *
<a name="line-1241"></a>                FieldOcc
<a name="line-1242"></a>*                                                                      *
<a name="line-1243"></a>************************************************************************
<a name="line-1244"></a>-}</span>
<a name="line-1245"></a>
<a name="line-1246"></a><a name="LFieldOcc"></a><span class='hs-comment'>-- | Located Field Occurrence</span>
<a name="line-1247"></a><a name="LFieldOcc"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LFieldOcc</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>pass</span> <span class='hs-layout'>(</span><span class='hs-conid'>FieldOcc</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-1248"></a>
<a name="line-1249"></a><a name="FieldOcc"></a><span class='hs-comment'>-- | Field Occurrence</span>
<a name="line-1250"></a><a name="FieldOcc"></a><span class='hs-comment'>--</span>
<a name="line-1251"></a><a name="FieldOcc"></a><span class='hs-comment'>-- Represents an *occurrence* of an unambiguous field.  This may or may not be a</span>
<a name="line-1252"></a><a name="FieldOcc"></a><span class='hs-comment'>-- binding occurrence (e.g. this type is used in 'ConDeclField' and</span>
<a name="line-1253"></a><a name="FieldOcc"></a><span class='hs-comment'>-- 'RecordPatSynField' which bind their fields, but also in 'HsRecField' for</span>
<a name="line-1254"></a><a name="FieldOcc"></a><span class='hs-comment'>-- record construction and patterns, which do not).</span>
<a name="line-1255"></a><a name="FieldOcc"></a><span class='hs-comment'>--</span>
<a name="line-1256"></a><a name="FieldOcc"></a><span class='hs-comment'>-- We store both the 'RdrName' the user originally wrote, and after the renamer,</span>
<a name="line-1257"></a><a name="FieldOcc"></a><span class='hs-comment'>-- the selector function.</span>
<a name="line-1258"></a><a name="FieldOcc"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>FieldOcc</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FieldOcc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>extFieldOcc</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XCFieldOcc</span> <span class='hs-varid'>pass</span>
<a name="line-1259"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>rdrNameFieldOcc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LocatedN</span> <span class='hs-conid'>RdrName</span>
<a name="line-1260"></a>                                 <span class='hs-comment'>-- ^ See Note [Located RdrNames] in "GHC.Hs.Expr"</span>
<a name="line-1261"></a>                              <span class='hs-layout'>}</span>
<a name="line-1262"></a>
<a name="line-1263"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XFieldOcc</span>
<a name="line-1264"></a>      <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXFieldOcc</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-1265"></a>
<a name="line-1266"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>XCFieldOcc</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>XXFieldOcc</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>FieldOcc</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-1267"></a>
<a name="line-1268"></a><a name="instance%20Outputable%20(FieldOcc%20pass)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>FieldOcc</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-1269"></a>  <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>rdrNameFieldOcc</span>
<a name="line-1270"></a>
<a name="line-1271"></a><a name="instance%20OutputableBndr%20(FieldOcc%20pass)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>OutputableBndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>FieldOcc</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-1272"></a>  <span class='hs-varid'>pprInfixOcc</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprInfixOcc</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unLoc</span> <span class='hs-varop'>.</span> <span class='hs-varid'>rdrNameFieldOcc</span>
<a name="line-1273"></a>  <span class='hs-varid'>pprPrefixOcc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPrefixOcc</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unLoc</span> <span class='hs-varop'>.</span> <span class='hs-varid'>rdrNameFieldOcc</span>
<a name="line-1274"></a>
<a name="line-1275"></a><a name="instance%20OutputableBndr%20(GenLocated%20SrcSpan%20(FieldOcc%20pass))"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>OutputableBndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenLocated</span> <span class='hs-conid'>SrcSpan</span> <span class='hs-layout'>(</span><span class='hs-conid'>FieldOcc</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-1276"></a>  <span class='hs-varid'>pprInfixOcc</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprInfixOcc</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unLoc</span>
<a name="line-1277"></a>  <span class='hs-varid'>pprPrefixOcc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPrefixOcc</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unLoc</span>
<a name="line-1278"></a>
<a name="line-1279"></a><a name="AmbiguousFieldOcc"></a><span class='hs-comment'>-- | Ambiguous Field Occurrence</span>
<a name="line-1280"></a><a name="AmbiguousFieldOcc"></a><span class='hs-comment'>--</span>
<a name="line-1281"></a><a name="AmbiguousFieldOcc"></a><span class='hs-comment'>-- Represents an *occurrence* of a field that is potentially</span>
<a name="line-1282"></a><a name="AmbiguousFieldOcc"></a><span class='hs-comment'>-- ambiguous after the renamer, with the ambiguity resolved by the</span>
<a name="line-1283"></a><a name="AmbiguousFieldOcc"></a><span class='hs-comment'>-- typechecker.  We always store the 'RdrName' that the user</span>
<a name="line-1284"></a><a name="AmbiguousFieldOcc"></a><span class='hs-comment'>-- originally wrote, and store the selector function after the renamer</span>
<a name="line-1285"></a><a name="AmbiguousFieldOcc"></a><span class='hs-comment'>-- (for unambiguous occurrences) or the typechecker (for ambiguous</span>
<a name="line-1286"></a><a name="AmbiguousFieldOcc"></a><span class='hs-comment'>-- occurrences).</span>
<a name="line-1287"></a><a name="AmbiguousFieldOcc"></a><span class='hs-comment'>--</span>
<a name="line-1288"></a><a name="AmbiguousFieldOcc"></a><span class='hs-comment'>-- See Note [HsRecField and HsRecUpdField] in "GHC.Hs.Pat" and</span>
<a name="line-1289"></a><a name="AmbiguousFieldOcc"></a><span class='hs-comment'>-- Note [Disambiguating record fields] in "GHC.Tc.Gen.Head".</span>
<a name="line-1290"></a><a name="AmbiguousFieldOcc"></a><span class='hs-comment'>-- See Note [Located RdrNames] in "GHC.Hs.Expr"</span>
<a name="line-1291"></a><a name="AmbiguousFieldOcc"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>AmbiguousFieldOcc</span> <span class='hs-varid'>pass</span>
<a name="line-1292"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Unambiguous</span> <span class='hs-layout'>(</span><span class='hs-conid'>XUnambiguous</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LocatedN</span> <span class='hs-conid'>RdrName</span><span class='hs-layout'>)</span>
<a name="line-1293"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Ambiguous</span>   <span class='hs-layout'>(</span><span class='hs-conid'>XAmbiguous</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>   <span class='hs-layout'>(</span><span class='hs-conid'>LocatedN</span> <span class='hs-conid'>RdrName</span><span class='hs-layout'>)</span>
<a name="line-1294"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XAmbiguousFieldOcc</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXAmbiguousFieldOcc</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-1295"></a>
<a name="line-1296"></a>
<a name="line-1297"></a><span class='hs-comment'>{-
<a name="line-1298"></a>************************************************************************
<a name="line-1299"></a>*                                                                      *
<a name="line-1300"></a>\subsection{Pretty printing}
<a name="line-1301"></a>*                                                                      *
<a name="line-1302"></a>************************************************************************
<a name="line-1303"></a>-}</span>
<a name="line-1304"></a>
<a name="line-1305"></a><a name="instance%20Outputable%20HsTyLit"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>HsTyLit</span> <span class='hs-keyword'>where</span>
<a name="line-1306"></a>    <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr_tylit</span>
<a name="line-1307"></a><a name="ppr_tylit"></a><span class='hs-comment'>--------------------------</span>
<a name="line-1308"></a><span class='hs-definition'>ppr_tylit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsTyLit</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1309"></a><span class='hs-definition'>ppr_tylit</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsNumTy</span> <span class='hs-varid'>source</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprWithSourceText</span> <span class='hs-varid'>source</span> <span class='hs-layout'>(</span><span class='hs-varid'>integer</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span>
<a name="line-1310"></a><span class='hs-definition'>ppr_tylit</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsStrTy</span> <span class='hs-varid'>source</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprWithSourceText</span> <span class='hs-varid'>source</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-layout'>(</span><span class='hs-varid'>show</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1311"></a><span class='hs-definition'>ppr_tylit</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsCharTy</span> <span class='hs-varid'>source</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprWithSourceText</span> <span class='hs-varid'>source</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-layout'>(</span><span class='hs-varid'>show</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre></body>
</html>

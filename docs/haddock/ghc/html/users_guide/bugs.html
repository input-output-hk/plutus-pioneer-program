

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>14. Known bugs and infelicities &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="15. Eventlog encodings" href="eventlog-formats.html" />
    <link rel="prev" title="13. Running GHC on Win32 systems" href="win32-dlls.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">5. Using GHC</a></li>
<li class="toctree-l1"><a class="reference internal" href="exts.html">6. Language extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">14. Known bugs and infelicities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#haskell-standards-vs-glasgow-haskell-language-non-compliance">14.1. Haskell standards vs. Glasgow Haskell: language non-compliance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#divergence-from-haskell-98-and-haskell-2010">14.1.1. Divergence from Haskell 98 and Haskell 2010</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#lexical-syntax">14.1.1.1. Lexical syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#context-free-syntax">14.1.1.2. Context-free syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expressions-and-patterns">14.1.1.3. Expressions and patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#failable-patterns">14.1.1.4. Failable patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#typechecking-of-recursive-binding-groups">14.1.1.5. Typechecking of recursive binding groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="#default-module-headers-with-main-is">14.1.1.6. Default Module headers with -main-is</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-system-and-interface-files">14.1.1.7. Module system and interface files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#numbers-basic-types-and-built-in-classes">14.1.1.8. Numbers, basic types, and built-in classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#in-prelude-support">14.1.1.9. In <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-foreign-function-interface">14.1.1.10. The Foreign Function Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ghc-s-interpretation-of-undefined-behaviour-in-haskell-98-and-haskell-2010">14.1.2. GHC’s interpretation of undefined behaviour in Haskell 98 and Haskell 2010</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#known-bugs-or-infelicities">14.2. Known bugs or infelicities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#bugs-in-ghc">14.2.1. Bugs in GHC</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bugs-in-ghci-the-interactive-ghc">14.2.2. Bugs in GHCi (the interactive GHC)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li><span class="section-number">14. </span>Known bugs and infelicities</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/bugs.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="known-bugs-and-infelicities">
<span id="bugs-and-infelicities"></span><h1><span class="section-number">14. </span>Known bugs and infelicities<a class="headerlink" href="#known-bugs-and-infelicities" title="Permalink to this heading">¶</a></h1>
<section id="haskell-standards-vs-glasgow-haskell-language-non-compliance">
<span id="vs-haskell-defn"></span><h2><span class="section-number">14.1. </span>Haskell standards vs. Glasgow Haskell: language non-compliance<a class="headerlink" href="#haskell-standards-vs-glasgow-haskell-language-non-compliance" title="Permalink to this heading">¶</a></h2>
<p id="index-0">This section lists Glasgow Haskell infelicities in its implementation of
Haskell 98 and Haskell 2010. See also the “when things go wrong” section
(<a class="reference internal" href="gone_wrong.html#wrong"><span class="std std-ref">What to do when something goes wrong</span></a>) for information about crashes, space leaks, and other
undesirable phenomena.</p>
<p>The limitations here are listed in Haskell Report order (roughly).</p>
<section id="divergence-from-haskell-98-and-haskell-2010">
<span id="haskell-standards-divergence"></span><h3><span class="section-number">14.1.1. </span>Divergence from Haskell 98 and Haskell 2010<a class="headerlink" href="#divergence-from-haskell-98-and-haskell-2010" title="Permalink to this heading">¶</a></h3>
<p>GHC aims to be able to behave (mostly) like a Haskell 98 or Haskell 2010
compiler, if you tell it to try to behave like that  with the
<a class="reference internal" href="exts/control.html#extension-Haskell98"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Haskell98</span></code></a> and <a class="reference internal" href="exts/control.html#extension-Haskell2010"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Haskell2010</span></code></a> flags. The known deviations
from the standards are described below. Unless otherwise stated, the deviation
applies in both Haskell 98 and Haskell 2010 mode.</p>
<section id="lexical-syntax">
<span id="infelicities-lexical"></span><h4><span class="section-number">14.1.1.1. </span>Lexical syntax<a class="headerlink" href="#lexical-syntax" title="Permalink to this heading">¶</a></h4>
<ul>
<li><p>Certain lexical rules regarding qualified identifiers are slightly
different in GHC compared to the Haskell report. When you have
⟨module⟩<code class="docutils literal notranslate"><span class="pre">.</span></code>⟨reservedop⟩, such as <code class="docutils literal notranslate"><span class="pre">M.\</span></code>, GHC will interpret it
as a single qualified operator rather than the two lexemes <code class="docutils literal notranslate"><span class="pre">M</span></code> and
<code class="docutils literal notranslate"><span class="pre">.\</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">forall</span></code> is always a reserved keyword at the type level, contrary
to the Haskell Report, which allows type variables to be named <code class="docutils literal notranslate"><span class="pre">forall</span></code>.
Note that this does not imply that GHC always enables the
<a class="reference internal" href="exts/explicit_forall.html#extension-ExplicitForAll"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExplicitForAll</span></code></a> extension. Even without this extension enabled,
reserving <code class="docutils literal notranslate"><span class="pre">forall</span></code> as a keyword has significance. For instance, GHC will
not parse the type signature <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">::</span> <span class="pre">forall</span> <span class="pre">x</span></code>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">(!)</span></code> operator, when written in prefix form (preceded by whitespace
and not followed by whitespace, as in <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">!x</span> <span class="pre">=</span> <span class="pre">...</span></code>), is interpreted as a
bang pattern, contrary to the Haskell Report, which prescribes to treat <code class="docutils literal notranslate"><span class="pre">!</span></code>
as an operator regardless of surrounding whitespace. Note that this does not
imply that GHC always enables <a class="reference internal" href="exts/strict.html#extension-BangPatterns"><code class="xref std std-extension docutils literal notranslate"><span class="pre">BangPatterns</span></code></a>. Without the
extension, GHC will issue a parse error on <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">!x</span></code>, asking to enable the
extension.</p></li>
<li><p>Irrefutable patterns must be written in prefix form:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="o">~</span><span class="n">a</span><span class="w"> </span><span class="o">~</span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w">    </span><span class="c1">-- accepted by both GHC and the Haskell Report</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w">  </span><span class="c1">-- accepted by the Haskell Report but not GHC</span><span class="w"></span>
</pre></div>
</div>
<p>When written in non-prefix form, <code class="docutils literal notranslate"><span class="pre">(~)</span></code> is treated by GHC as a regular
infix operator.</p>
<p>See <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0229-whitespace-bang-patterns.rst">GHC Proposal #229</a>
for the precise rules.</p>
</li>
<li><p>Strictness annotations in data declarations must be written in prefix form:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="o">!</span><span class="kt">Int</span><span class="w">   </span><span class="c1">-- accepted by both GHC and the Haskell Report</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="kt">Int</span><span class="w">  </span><span class="c1">-- accepted by the Haskell Report but not GHC</span><span class="w"></span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0229-whitespace-bang-patterns.rst">GHC Proposal #229</a>
for the precise rules.</p>
</li>
<li><p>As-patterns must not be surrounded by whitespace on either side:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="n">p</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w">    </span><span class="c1">-- accepted by both GHC and the Haskell Report</span><span class="w"></span>

<span class="c1">-- accepted by the Haskell Report but not GHC:</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">p</span><span class="o">@</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>When surrounded by whitespace on both sides, <code class="docutils literal notranslate"><span class="pre">(&#64;)</span></code> is treated by GHC as a
regular infix operator.</p>
<p>When preceded but not followed by whitespace, <code class="docutils literal notranslate"><span class="pre">(&#64;)</span></code> is treated as a
visible type application.</p>
<p>See <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0229-whitespace-bang-patterns.rst">GHC Proposal #229</a>
for the precise rules.</p>
</li>
</ul>
</section>
<section id="context-free-syntax">
<span id="infelicities-syntax"></span><h4><span class="section-number">14.1.1.2. </span>Context-free syntax<a class="headerlink" href="#context-free-syntax" title="Permalink to this heading">¶</a></h4>
<ul>
<li><p>In Haskell 98 mode (but not in Haskell 2010 mode), GHC
is a little less strict about the layout rule when used in <code class="docutils literal notranslate"><span class="pre">do</span></code>
expressions. Specifically, the restriction that “a nested context
must be indented further to the right than the enclosing context” is
relaxed to allow the nested context to be at the same level as the
enclosing context, if the enclosing context is a <code class="docutils literal notranslate"><span class="pre">do</span></code> expression.</p>
<p>For example, the following code is accepted by GHC:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getArgs</span><span class="w"></span>
<span class="w">          </span><span class="kr">if</span><span class="w"> </span><span class="n">null</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">          </span><span class="n">ps</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mapM</span><span class="w"> </span><span class="n">process</span><span class="w"> </span><span class="n">args</span><span class="w"></span>
<span class="w">          </span><span class="n">mapM</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">ps</span><span class="w"></span>
</pre></div>
</div>
<p>This behaviour is controlled by the <a class="reference internal" href="#extension-NondecreasingIndentation"><code class="xref std std-extension docutils literal notranslate"><span class="pre">NondecreasingIndentation</span></code></a>
extension.</p>
</li>
</ul>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-NondecreasingIndentation">
<span id="ghc-flag--XNondecreasingIndentation"></span><span id="extension-NoNondecreasingIndentation"></span><span class="sig-name descname"><span class="pre">NondecreasingIndentation</span></span><a class="headerlink" href="#extension-NondecreasingIndentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.2.1</p>
</dd>
</dl>
<p>Allow nested contexts to be at the same indentation level as
its enclosing context.</p>
</dd></dl>

<ul>
<li><p>GHC doesn’t do the fixity resolution in expressions during parsing as
required by Haskell 98 (but not by Haskell 2010). For example,
according to the Haskell 98 report, the following expression is
legal:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
<p>and parses as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
<p>because according to the report, the <code class="docutils literal notranslate"><span class="pre">let</span></code> expression “extends as
far to the right as possible”. Since it can’t extend past the second
equals sign without causing a parse error (<code class="docutils literal notranslate"><span class="pre">==</span></code> is non-fix), the
<code class="docutils literal notranslate"><span class="pre">let</span></code>-expression must terminate there. GHC simply gobbles up the
whole expression, parsing like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">True</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="expressions-and-patterns">
<span id="infelicities-exprs-pats"></span><h4><span class="section-number">14.1.1.3. </span>Expressions and patterns<a class="headerlink" href="#expressions-and-patterns" title="Permalink to this heading">¶</a></h4>
<p>By default, GHC makes some programs slightly more defined than they should be.
For example, consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">&quot;urk&quot;</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"></span>

<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="p">`</span><span class="n">seq</span><span class="p">`</span><span class="w"> </span><span class="kt">True</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This should call <code class="docutils literal notranslate"><span class="pre">error</span></code> but actually prints <code class="docutils literal notranslate"><span class="pre">True</span></code>. Reason: GHC
eta-expands <code class="docutils literal notranslate"><span class="pre">f</span></code> to</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="kt">[]</span><span class="w">     </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">&quot;urk&quot;</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
</pre></div>
</div>
<p>This improves efficiency slightly but significantly for most programs,
and is bad for only a few. To suppress this bogus “optimisation” use
<code class="docutils literal notranslate"><span class="pre">-fpedantic-bottoms</span></code>.</p>
</section>
<section id="failable-patterns">
<span id="infelicities-failable-pats"></span><h4><span class="section-number">14.1.1.4. </span>Failable patterns<a class="headerlink" href="#failable-patterns" title="Permalink to this heading">¶</a></h4>
<p>Since the <a class="reference external" href="https://gitlab.haskell.org/haskell/prime/-/wikis/libraries/proposals/monad-fail">MonadFail Proposal (MFP)</a>,
do-notation blocks that contain a failable pattern need a <a class="reference external" href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-Fail.html#t:MonadFail">MonadFail</a> constraint.</p>
<p>For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mayFail</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">MonadIO</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">mayFail</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fetchData</span><span class="w"></span>
<span class="w">  </span><span class="n">putStrLn</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
</pre></div>
</div>
<p>Will warn you with</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>• Could not deduce (MonadFail m)
    arising from a do statement
    with the failable pattern ‘(Just x)’
  from the context: MonadIO m
    bound by the type signature for:
               mayFail :: forall (m :: * -&gt; *). MonadIO m =&gt; m ()
</pre></div>
</div>
<p>And indeed, since the <a class="reference external" href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad">Monad</a> class does not have the <code class="docutils literal notranslate"><span class="pre">fail</span></code> method anymore,
we need to explicitly add <code class="docutils literal notranslate"><span class="pre">(MonadFail</span> <span class="pre">m)</span></code> to the constraints of the function.</p>
</section>
<section id="typechecking-of-recursive-binding-groups">
<span id="infelicities-recursive-groups"></span><h4><span class="section-number">14.1.1.5. </span>Typechecking of recursive binding groups<a class="headerlink" href="#typechecking-of-recursive-binding-groups" title="Permalink to this heading">¶</a></h4>
<p>The Haskell Report specifies that a group of bindings (at top level, or
in a <code class="docutils literal notranslate"><span class="pre">let</span></code> or <code class="docutils literal notranslate"><span class="pre">where</span></code>) should be sorted into strongly-connected
components, and then type-checked in dependency order
(<a class="reference external" href="http://www.haskell.org/onlinereport/decls.html#sect4.5.1">Haskell Report, Section
4.5.1</a>). As
each group is type-checked, any binders of the group that have an
explicit type signature are put in the type environment with the
specified polymorphic type, and all others are monomorphic until the
group is generalised (<a class="reference external" href="http://www.haskell.org/onlinereport/decls.html#sect4.5.2">Haskell Report, Section
4.5.2</a>).</p>
<p>Following a suggestion of Mark Jones, in his paper <a class="reference external" href="https://web.cecs.pdx.edu/~mpj/thih/">Typing Haskell in
Haskell</a>, GHC implements a
more general scheme. In GHC <em>the dependency analysis ignores references to
variables that have an explicit type signature</em>. As a result of this refined
dependency analysis, the dependency groups are smaller, and more bindings will
typecheck. For example, consider:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="s">&quot;Yes&quot;</span><span class="w"></span>

<span class="nf">g</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
<p>This is rejected by Haskell 98, but under Jones’s scheme the definition
for <code class="docutils literal notranslate"><span class="pre">g</span></code> is typechecked first, separately from that for <code class="docutils literal notranslate"><span class="pre">f</span></code>, because
the reference to <code class="docutils literal notranslate"><span class="pre">f</span></code> in <code class="docutils literal notranslate"><span class="pre">g</span></code>'s right hand side is ignored by the
dependency analysis. Then <code class="docutils literal notranslate"><span class="pre">g</span></code>'s type is generalised, to get</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
</pre></div>
</div>
<p>Now, the definition for <code class="docutils literal notranslate"><span class="pre">f</span></code> is typechecked, with this type for <code class="docutils literal notranslate"><span class="pre">g</span></code>
in the type environment.</p>
<p>The same refined dependency analysis also allows the type signatures of
mutually-recursive functions to have different contexts, something that is
illegal in Haskell 98 (Section 4.5.2, last sentence). GHC only insists that the
type signatures of a <em>refined</em> group have identical type signatures; in practice
this means that only variables bound by the same pattern binding must have the
same context. For example, this is fine:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>

<span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="default-module-headers-with-main-is">
<span id="infelicities-default-exports"></span><h4><span class="section-number">14.1.1.6. </span>Default Module headers with -main-is<a class="headerlink" href="#default-module-headers-with-main-is" title="Permalink to this heading">¶</a></h4>
<p>The Haskell2010 Report specifies in &lt;<a class="reference external" href="https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1">https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1</a>&gt; that</p>
<blockquote>
<div><dl class="simple">
<dt>“An abbreviated form of module, consisting only of the module body,</dt><dd><p>is permitted. If this is used, the header is assumed to be
<cite>module Main(main) where</cite>.”</p>
</dd>
</dl>
</div></blockquote>
<p>GHC’s <code class="docutils literal notranslate"><span class="pre">-main-is</span></code> option can be used to change the name of the top-level entry
point from <code class="docutils literal notranslate"><span class="pre">main</span></code> to any other variable.  When compiling the main module and
<code class="docutils literal notranslate"><span class="pre">-main-is</span></code> has been used to rename the default entry point, GHC will also use
the alternate name in the default export list.</p>
<p>Consider the following program:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: Main.hs</span><span class="w"></span>
<span class="nf">program</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">program</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
</pre></div>
</div>
<p>GHC will successfully compile this module with
<code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-main-is</span> <span class="pre">Main.program</span> <span class="pre">Main.hs</span></code>, because the default export list
will include <code class="docutils literal notranslate"><span class="pre">program</span></code> rather than <code class="docutils literal notranslate"><span class="pre">main</span></code>, as the Haskell Report
typically requires.</p>
<p>This change only applies to the main module.  Other modules will still export
<code class="docutils literal notranslate"><span class="pre">main</span></code> from a default export list, regardless of the <code class="docutils literal notranslate"><span class="pre">-main-is</span></code> flag.
This allows use of <code class="docutils literal notranslate"><span class="pre">-main-is</span></code> with existing modules that export <code class="docutils literal notranslate"><span class="pre">main</span></code> via
a default export list, even when <code class="docutils literal notranslate"><span class="pre">-main-is</span></code> points to a different entry
point, as in this example (compiled with <code class="docutils literal notranslate"><span class="pre">-main-is</span> <span class="pre">MainWrapper.program</span></code>).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file MainWrapper.hs</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">MainWrapper</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Main</span><span class="w"></span>

<span class="nf">program</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">program</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;Redirecting...&quot;</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">main</span><span class="w"></span>

<span class="c1">-- file Main.hs</span><span class="w"></span>
<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;I am main.&quot;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="module-system-and-interface-files">
<span id="infelicities-modules"></span><h4><span class="section-number">14.1.1.7. </span>Module system and interface files<a class="headerlink" href="#module-system-and-interface-files" title="Permalink to this heading">¶</a></h4>
<p>GHC requires the use of <code class="docutils literal notranslate"><span class="pre">hs-boot</span></code> files to cut the recursive loops
among mutually recursive modules as described in
<a class="reference internal" href="separate_compilation.html#mutual-recursion"><span class="std std-ref">How to compile mutually recursive modules</span></a>. This more of an infelicity than a bug: the
Haskell Report says (<a class="reference external" href="http://haskell.org/onlinereport/modules.html#sect5.7">Section
5.7</a>)</p>
<blockquote>
<div><p>“Depending on the Haskell implementation used, separate compilation of
mutually recursive modules may require that imported modules contain
additional information so that they may be referenced before they are
compiled. Explicit type signatures for all exported values may be
necessary to deal with mutual recursion. The precise details of separate
compilation are not defined by this Report.”</p>
</div></blockquote>
</section>
<section id="numbers-basic-types-and-built-in-classes">
<span id="infelicities-numbers"></span><h4><span class="section-number">14.1.1.8. </span>Numbers, basic types, and built-in classes<a class="headerlink" href="#numbers-basic-types-and-built-in-classes" title="Permalink to this heading">¶</a></h4>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">Num</span></code> superclasses</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">Num</span></code> class does not have <code class="docutils literal notranslate"><span class="pre">Show</span></code> or <code class="docutils literal notranslate"><span class="pre">Eq</span></code> superclasses.</p>
<p>You can make code that works with both Haskell98/Haskell2010 and GHC
by:</p>
<ul class="simple">
<li><p>Whenever you make a <code class="docutils literal notranslate"><span class="pre">Num</span></code> instance of a type, also make
<code class="docutils literal notranslate"><span class="pre">Show</span></code> and <code class="docutils literal notranslate"><span class="pre">Eq</span></code> instances, and</p></li>
<li><p>Whenever you give a function, instance or class a <code class="docutils literal notranslate"><span class="pre">Num</span> <span class="pre">t</span></code>
constraint, also give it <code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">t</span></code> constraints.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Bits</span></code> superclass</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">Bits</span></code> class does not have a <code class="docutils literal notranslate"><span class="pre">Num</span></code> superclass. It
therefore does not have default methods for the <code class="docutils literal notranslate"><span class="pre">bit</span></code>, <code class="docutils literal notranslate"><span class="pre">testBit</span></code>
and <code class="docutils literal notranslate"><span class="pre">popCount</span></code> methods.</p>
<p>You can make code that works with both Haskell 2010 and GHC by:</p>
<ul class="simple">
<li><p>Whenever you make a <code class="docutils literal notranslate"><span class="pre">Bits</span></code> instance of a type, also make a
<code class="docutils literal notranslate"><span class="pre">Num</span></code> instance, and</p></li>
<li><p>Whenever you give a function, instance or class a <code class="docutils literal notranslate"><span class="pre">Bits</span> <span class="pre">t</span></code>
constraint, also give it a <code class="docutils literal notranslate"><span class="pre">Num</span> <span class="pre">t</span></code> constraint, and</p></li>
<li><p>Always define the <code class="docutils literal notranslate"><span class="pre">bit</span></code>, <code class="docutils literal notranslate"><span class="pre">testBit</span></code> and <code class="docutils literal notranslate"><span class="pre">popCount</span></code> methods
in <code class="docutils literal notranslate"><span class="pre">Bits</span></code> instances.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Read</span></code> class methods</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">Read</span></code> class has two extra methods, <code class="docutils literal notranslate"><span class="pre">readPrec</span></code> and
<code class="docutils literal notranslate"><span class="pre">readListPrec</span></code>, that are not found in the Haskell 2010 since they rely
on the <code class="docutils literal notranslate"><span class="pre">ReadPrec</span></code> data type, which requires the <a class="reference internal" href="exts/rank_polymorphism.html#extension-RankNTypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">RankNTypes</span></code></a>
extension. GHC also derives <code class="docutils literal notranslate"><span class="pre">Read</span></code> instances by implementing <code class="docutils literal notranslate"><span class="pre">readPrec</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">readsPrec</span></code>, and relies on a default implementation of
<code class="docutils literal notranslate"><span class="pre">readsPrec</span></code> that is defined in terms of <code class="docutils literal notranslate"><span class="pre">readPrec</span></code>. GHC adds these two
extra methods simply because <code class="docutils literal notranslate"><span class="pre">ReadPrec</span></code> is more efficient than <code class="docutils literal notranslate"><span class="pre">ReadS</span></code>
(the type on which <code class="docutils literal notranslate"><span class="pre">readsPrec</span></code> is based).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Monad</span></code> superclass</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">Monad</span></code> class has an <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> superclass. You cannot write
<code class="docutils literal notranslate"><span class="pre">Monad</span></code> instances that work for GHC and also for a Haskell 2010
implementation that does not define <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>.</p>
</dd>
<dt>Extra instances</dt><dd><p>The following extra instances are defined:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="p">((,)</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="p">(</span><span class="kt">Either</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="kt">Either</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</dd>
<dt>Multiply-defined array elements not checked</dt><dd><p>This code fragment should elicit a fatal error, but it does not:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="p">(</span><span class="n">array</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span><span class="w"></span>
</pre></div>
</div>
<p>GHC’s implementation of <code class="docutils literal notranslate"><span class="pre">array</span></code> takes the value of an array slot
from the last (index,value) pair in the list, and does no checking
for duplicates. The reason for this is efficiency, pure and simple.</p>
</dd>
</dl>
</section>
<section id="in-prelude-support">
<span id="infelicities-prelude"></span><h4><span class="section-number">14.1.1.9. </span>In <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> support<a class="headerlink" href="#in-prelude-support" title="Permalink to this heading">¶</a></h4>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">splitAt</span></code> semantics</dt><dd><p><code class="docutils literal notranslate"><span class="pre">Data.List.splitAt</span></code> is more strict than specified in the Report.
Specifically, the Report specifies that</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">splitAt</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">take</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">drop</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>which implies that</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">splitAt</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">undefined</span><span class="p">,</span><span class="w"> </span><span class="n">undefined</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>but GHC’s implementation is strict in its first argument, so</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">splitAt</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"></span>
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Show</span></code>ing records</dt><dd><p>The Haskell 2010 definition of <code class="docutils literal notranslate"><span class="pre">Show</span></code> stipulates that the rendered
string should only include parentheses which are necessary to unambiguously
parse the result. For historical reasons, <code class="docutils literal notranslate"><span class="pre">Show</span></code> instances derived by GHC
include parentheses around records despite the fact that record syntax
binds more tightly than function application; e.g.,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Hello</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Hello</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">aField</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>

<span class="c1">-- GHC produces...</span><span class="w"></span>
<span class="nf">show</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="kt">Hello</span><span class="w"> </span><span class="p">{</span><span class="n">aField</span><span class="ow">=</span><span class="mi">42</span><span class="p">}))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;Just (Hello {aField=42})&quot;</span><span class="w"></span>

<span class="c1">-- whereas Haskell 2010 calls for...</span><span class="w"></span>
<span class="nf">show</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="kt">Hello</span><span class="w"> </span><span class="p">{</span><span class="n">aField</span><span class="ow">=</span><span class="mi">42</span><span class="p">}))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;Just Hello {aField=42}&quot;</span><span class="w"></span>
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Read</span></code>ing integers</dt><dd><p>GHC’s implementation of the <code class="docutils literal notranslate"><span class="pre">Read</span></code> class for integral types
accepts hexadecimal and octal literals (the code in the Haskell 98
report doesn’t). So, for example,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">read</span><span class="w"> </span><span class="s">&quot;0xf00&quot;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>works in GHC.</p>
<p>A possible reason for this is that <code class="docutils literal notranslate"><span class="pre">readLitChar</span></code> accepts hex and
octal escapes, so it seems inconsistent not to do so for integers
too.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isAlpha</span></code></dt><dd><p>The Haskell 98 definition of <code class="docutils literal notranslate"><span class="pre">isAlpha</span></code> is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">isAlpha</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">isUpper</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">isLower</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
<p>GHC’s implementation diverges from the Haskell 98 definition in the
sense that Unicode alphabetic characters which are neither upper nor
lower case will still be identified as alphabetic by <code class="docutils literal notranslate"><span class="pre">isAlpha</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hGetContents</span></code></dt><dd><p>Lazy I/O throws an exception if an error is encountered, in contrast
to the Haskell 98 spec which requires that errors are discarded (see
Section 21.2.2 of the Haskell 98 report). The exception thrown is
the usual IO exception that would be thrown if the failing IO
operation was performed in the IO monad, and can be caught by
<code class="docutils literal notranslate"><span class="pre">System.IO.Error.catch</span></code> or <code class="docutils literal notranslate"><span class="pre">Control.Exception.catch</span></code>.</p>
</dd>
</dl>
</section>
<section id="the-foreign-function-interface">
<span id="infelicities-ffi"></span><h4><span class="section-number">14.1.1.10. </span>The Foreign Function Interface<a class="headerlink" href="#the-foreign-function-interface" title="Permalink to this heading">¶</a></h4>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">hs_init()</span></code>, <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code></dt><dd><p>The FFI spec requires the implementation to support re-initialising
itself after being shut down with <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code>, but GHC does not
currently support that. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/13693">#13693</a>.</p>
</dd>
</dl>
</section>
</section>
<section id="ghc-s-interpretation-of-undefined-behaviour-in-haskell-98-and-haskell-2010">
<span id="haskell-98-2010-undefined"></span><span id="index-1"></span><h3><span class="section-number">14.1.2. </span>GHC’s interpretation of undefined behaviour in Haskell 98 and Haskell 2010<a class="headerlink" href="#ghc-s-interpretation-of-undefined-behaviour-in-haskell-98-and-haskell-2010" title="Permalink to this heading">¶</a></h3>
<p>This section documents GHC’s take on various issues that are left
undefined or implementation specific in Haskell 98.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">Char</span></code></dt><dd><p id="index-2">Following the ISO-10646 standard, <code class="docutils literal notranslate"><span class="pre">maxBound</span> <span class="pre">::</span> <span class="pre">Char</span></code> in GHC is
<code class="docutils literal notranslate"><span class="pre">0x10FFFF</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Int</span></code></dt><dd><p id="index-3">In GHC the <code class="docutils literal notranslate"><span class="pre">Int</span></code> type follows the size of an address on the host
architecture; in other words it holds 32 bits on a 32-bit machine,
and 64-bits on a 64-bit machine.</p>
<p>Arithmetic on <code class="docutils literal notranslate"><span class="pre">Int</span></code> is unchecked for overflow<code class="docutils literal notranslate"><span class="pre">Int</span></code>, so
all operations on <code class="docutils literal notranslate"><span class="pre">Int</span></code> happen modulo 2<sup>⟨n⟩</sup> where ⟨n⟩ is
the size in bits of the <code class="docutils literal notranslate"><span class="pre">Int</span></code> type.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">fromInteger</span></code> (and hence also <code class="docutils literal notranslate"><span class="pre">fromIntegral</span></code>) is a special case when
converting to <code class="docutils literal notranslate"><span class="pre">Int</span></code>. The value of <code class="docutils literal notranslate"><span class="pre">fromIntegral</span> <span class="pre">x</span> <span class="pre">::</span> <span class="pre">Int</span></code> is
given by taking the lower ⟨n⟩ bits of <code class="docutils literal notranslate"><span class="pre">(abs</span> <span class="pre">x)</span></code>, multiplied by the
sign of <code class="docutils literal notranslate"><span class="pre">x</span></code> (in 2’s complement ⟨n⟩-bit arithmetic). This behaviour
was chosen so that for example writing <code class="docutils literal notranslate"><span class="pre">0xffffffff</span> <span class="pre">::</span> <span class="pre">Int</span></code>
preserves the bit-pattern in the resulting <code class="docutils literal notranslate"><span class="pre">Int</span></code>.</p>
<p>Negative literals, such as <code class="docutils literal notranslate"><span class="pre">-3</span></code>, are specified by (a careful
reading of) the Haskell Report as meaning
<code class="docutils literal notranslate"><span class="pre">Prelude.negate</span> <span class="pre">(Prelude.fromInteger</span> <span class="pre">3)</span></code>. So <code class="docutils literal notranslate"><span class="pre">-2147483648</span></code> means
<code class="docutils literal notranslate"><span class="pre">negate</span> <span class="pre">(fromInteger</span> <span class="pre">2147483648)</span></code>. Since <code class="docutils literal notranslate"><span class="pre">fromInteger</span></code> takes the
lower 32 bits of the representation,
<code class="docutils literal notranslate"><span class="pre">fromInteger</span> <span class="pre">(2147483648::Integer)</span></code>, computed at type <code class="docutils literal notranslate"><span class="pre">Int</span></code> is
<code class="docutils literal notranslate"><span class="pre">-2147483648::Int</span></code>. The <code class="docutils literal notranslate"><span class="pre">negate</span></code> operation then overflows, but
it is unchecked, so <code class="docutils literal notranslate"><span class="pre">negate</span> <span class="pre">(-2147483648::Int)</span></code> is just
<code class="docutils literal notranslate"><span class="pre">-2147483648</span></code>. In short, one can write <code class="docutils literal notranslate"><span class="pre">minBound::Int</span></code> as a
literal with the expected meaning (but that is not in general
guaranteed).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">fromIntegral</span></code> function also preserves bit-patterns when
converting between the sized integral types (<code class="docutils literal notranslate"><span class="pre">Int8</span></code>, <code class="docutils literal notranslate"><span class="pre">Int16</span></code>,
<code class="docutils literal notranslate"><span class="pre">Int32</span></code>, <code class="docutils literal notranslate"><span class="pre">Int64</span></code> and the unsigned <code class="docutils literal notranslate"><span class="pre">Word</span></code> variants), see the
modules <code class="docutils literal notranslate"><span class="pre">Data.Int</span></code> and <code class="docutils literal notranslate"><span class="pre">Data.Word</span></code> in the library documentation.</p>
</dd>
<dt>Unchecked floating-point arithmetic</dt><dd><p>Operations on <code class="docutils literal notranslate"><span class="pre">Float</span></code> and <code class="docutils literal notranslate"><span class="pre">Double</span></code> numbers are <em>unchecked</em> for
overflow, underflow, and other sad occurrences. (note, however, that
some architectures trap floating-point overflow and
loss-of-precision and report a floating-point exception, probably
terminating the program)</p>
</dd>
<dt>Large tuple support</dt><dd><p>The Haskell Report only requires implementations to provide tuple
types and their accompanying standard instances up to size 15. GHC
limits the size of tuple types to 62 and provides instances of
<code class="docutils literal notranslate"><span class="pre">Eq</span></code>, <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, <code class="docutils literal notranslate"><span class="pre">Bounded</span></code>, <code class="docutils literal notranslate"><span class="pre">Read</span></code>, <code class="docutils literal notranslate"><span class="pre">Show</span></code>, and <code class="docutils literal notranslate"><span class="pre">Ix</span></code> for
tuples up to size 15.</p>
</dd>
</dl>
</section>
</section>
<section id="known-bugs-or-infelicities">
<span id="bugs"></span><h2><span class="section-number">14.2. </span>Known bugs or infelicities<a class="headerlink" href="#known-bugs-or-infelicities" title="Permalink to this heading">¶</a></h2>
<p>The bug tracker lists bugs that have been reported in GHC but not yet
fixed: see the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues">GHC issue tracker</a>. In
addition to those, GHC also has the following known bugs or
infelicities. These bugs are more permanent; it is unlikely that any of
them will be fixed in the short term.</p>
<section id="bugs-in-ghc">
<span id="bugs-ghc"></span><h3><span class="section-number">14.2.1. </span>Bugs in GHC<a class="headerlink" href="#bugs-in-ghc" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>GHC’s runtime system implements cooperative multitasking, with
context switching potentially occurring only when a program
allocates. This means that programs that do not allocate may never
context switch. This is especially true of programs using STM, which
may deadlock after observing inconsistent state. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/367">#367</a>
for further discussion.</p>
<p>If you are hit by this, you may want to compile the affected module
with <a class="reference internal" href="using-optimisation.html#ghc-flag-fomit-yields"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fno-omit-yields</span></code></a> (see <a class="reference internal" href="using-optimisation.html#options-f"><span class="std std-ref">-f*: platform-independent flags</span></a>).
This flag ensures that yield points are inserted at every function entrypoint
(at the expense of a bit of performance).</p>
</li>
<li><p>GHC does not allow you to have a data type with a context that
mentions type variables that are not data type parameters. For
example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>so that <code class="docutils literal notranslate"><span class="pre">MkT</span></code>'s type is</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">MkT</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>In principle, with a suitable class declaration with a functional
dependency, it’s possible that this type is not ambiguous; but GHC
nevertheless rejects it. The type variables mentioned in the context
of the data type declaration must be among the type parameters of the
data type.</p>
</li>
<li><p>GHC’s inliner can be persuaded into non-termination using the
standard way to encode recursion via a data type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">U</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkU</span><span class="w"> </span><span class="p">(</span><span class="kt">U</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"></span>

<span class="nf">russel</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">U</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">russel</span><span class="w"> </span><span class="n">u</span><span class="o">@</span><span class="p">(</span><span class="kt">MkU</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">u</span><span class="w"></span>

<span class="nf">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">russel</span><span class="w"> </span><span class="p">(</span><span class="kt">MkU</span><span class="w"> </span><span class="n">russel</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The non-termination is reported like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghc: panic! (the &#39;impossible&#39; happened)
  (GHC version 8.2.1 for x86_64-unknown-linux):
    Simplifier ticks exhausted
  When trying UnfoldingDone x_alB
  To increase the limit, use -fsimpl-tick-factor=N (default 100)
</pre></div>
</div>
<p>with the panic being reported no matter how high a
<a class="reference internal" href="using-optimisation.html#ghc-flag-fsimpl-tick-factor-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fsimpl-tick-factor</span></code></a> you supply.</p>
<p>We have never found another class of programs, other than this
contrived one, that makes GHC diverge, and fixing the problem would
impose an extra overhead on every compilation. So the bug remains
un-fixed. There is more background in <a class="reference external" href="http://research.microsoft.com/~simonpj/Papers/inlining/">Secrets of the GHC
inliner</a>.</p>
</li>
<li><p>On 32-bit x86 platforms when using the native code generator, the
<a class="reference internal" href="using-optimisation.html#ghc-flag-fexcess-precision"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fexcess-precision</span></code></a> option is always on.
This means that floating-point calculations are non-deterministic,
because depending on how the program is compiled (optimisation
settings, for example), certain calculations might be done at 80-bit
precision instead of the intended 32-bit or 64-bit precision.
Floating-point results may differ when optimisation is turned on. In
the worst case, referential transparency is violated, because for
example <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">E1</span> <span class="pre">in</span> <span class="pre">E2</span></code> can evaluate to a different value than
<code class="docutils literal notranslate"><span class="pre">E2[E1/x]</span></code>.</p>
<p id="index-5">One workaround is to use the <a class="reference internal" href="using.html#ghc-flag-msse2"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-msse2</span></code></a> option (see
<a class="reference internal" href="using.html#options-platform"><span class="std std-ref">Platform-specific Flags</span></a>), which generates code to use the SSE2
instruction set instead of the x87 instruction set. SSE2 code uses
the correct precision for all floating-point operations, and so gives
deterministic results. However, note that this only works with
processors that support SSE2 (Intel Pentium 4 or AMD Athlon 64 and
later), which is why the option is not enabled by default. The
libraries that come with GHC are probably built without this option,
unless you built GHC yourself.</p>
</li>
<li><p>The <a class="reference internal" href="using-optimisation.html#ghc-flag-fno-state-hack"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">state</span> <span class="pre">hack</span></code></a> optimization can result in
non-obvious changes in evaluation ordering which may hide exceptions, even
with <a class="reference internal" href="using-optimisation.html#ghc-flag-fpedantic-bottoms"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fpedantic-bottoms</span></code></a> (see, e.g., <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/7411">#7411</a>). For
instance,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="w"> </span><span class="nn">Control.Exception</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Control.DeepSeq</span><span class="w"></span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">evaluate</span><span class="w"> </span><span class="p">((</span><span class="sc">&#39;a&#39;</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">undefined</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="n">deepseq</span><span class="p">`</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>Compiling this program with <code class="docutils literal notranslate"><span class="pre">-O</span></code> results in <code class="docutils literal notranslate"><span class="pre">Hello</span></code> to be printed,
despite the fact that <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> should have bottomed. Compiling
with <code class="docutils literal notranslate"><span class="pre">-O</span> <span class="pre">-fno-state-hack</span></code> results in the exception one would expect.</p>
</li>
<li><p>Programs compiled with <a class="reference internal" href="using-warnings.html#ghc-flag-fdefer-type-errors"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fdefer-type-errors</span></code></a> may fail a bit
more eagerly than one might expect. For instance,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# OPTIONS_GHC -fdefer-type-errors #-}</span><span class="w"></span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;Hi there.&quot;</span><span class="w"></span>
<span class="w">  </span><span class="n">putStrLn</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
<p>Will emit no output, despite the fact that the ill-typed term appears
after the well-typed <code class="docutils literal notranslate"><span class="pre">putStrLn</span> <span class="pre">&quot;Hi</span> <span class="pre">there.&quot;</span></code>. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/11197">#11197</a>.</p>
</li>
<li><p>Despite appearances <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">Constraint</span></code> aren’t really distinct kinds
in the compiler’s internal representation and can be unified producing
unexpected results. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/11715">#11715</a> for one example.</p></li>
<li><p>Because of a toolchain limitation we are unable to support full Unicode paths
on Windows. On Windows we support up to Latin-1. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/12971">#12971</a> for more.</p></li>
</ul>
</section>
<section id="bugs-in-ghci-the-interactive-ghc">
<span id="bugs-ghci"></span><h3><span class="section-number">14.2.2. </span>Bugs in GHCi (the interactive GHC)<a class="headerlink" href="#bugs-in-ghci-the-interactive-ghc" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>GHCi does not respect the <code class="docutils literal notranslate"><span class="pre">default</span></code> declaration in the module whose
scope you are in. Instead, for expressions typed at the command line,
you always get the default default-type behaviour; that is,
<code class="docutils literal notranslate"><span class="pre">default(Int,Double)</span></code>.</p>
<p>It would be better for GHCi to record what the default settings in
each module are, and use those of the ‘current’ module (whatever that
is).</p>
</li>
<li><p>On Windows, there’s a GNU ld/BFD bug whereby it emits bogus PE object
files that have more than 0xffff relocations. When GHCi tries to load
a package affected by this bug, you get an error message of the form</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Loading package javavm ... linking ... WARNING: Overflown relocation field (# relocs found: 30765)
</pre></div>
</div>
<p>The last time we looked, this bug still wasn’t fixed in the BFD
codebase, and there wasn’t any noticeable interest in fixing it when
we reported the bug back in 2001 or so.</p>
<p>The workaround is to split up the .o files that make up your package
into two or more .o’s, along the lines of how the <code class="docutils literal notranslate"><span class="pre">base</span></code> package does
it.</p>
</li>
</ul>
</section>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="eventlog-formats.html" class="btn btn-neutral float-right" title="15. Eventlog encodings" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="win32-dlls.html" class="btn btn-neutral float-left" title="13. Running GHC on Win32 systems" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
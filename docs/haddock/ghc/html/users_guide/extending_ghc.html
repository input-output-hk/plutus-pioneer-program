

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>7. Extending and using GHC as a Library &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="8. Profiling" href="profiling.html" />
    <link rel="prev" title="6.20. Pragmas" href="exts/pragmas.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">5. Using GHC</a></li>
<li class="toctree-l1"><a class="reference internal" href="exts.html">6. Language extensions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">7. Extending and using GHC as a Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#source-annotations">7.1. Source annotations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#annotating-values">7.1.1. Annotating values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#annotating-types">7.1.2. Annotating types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#annotating-modules">7.1.3. Annotating modules</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-ghc-as-a-library">7.2. Using GHC as a Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="#compiler-plugins">7.3. Compiler Plugins</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#using-compiler-plugins">7.3.1. Using compiler plugins</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-compiler-plugins">7.3.2. Writing compiler plugins</a></li>
<li class="toctree-l3"><a class="reference internal" href="#core-plugins-in-more-detail">7.3.3. Core plugins in more detail</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#manipulating-bindings">7.3.3.1. Manipulating bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-annotations">7.3.3.2. Using Annotations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#typechecker-plugins">7.3.4. Typechecker plugins</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#constraint-solving-with-plugins">7.3.4.1. Constraint solving with plugins</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#source-plugins">7.3.5. Source plugins</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parsed-representation">7.3.5.1. Parsed representation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-checked-representation">7.3.5.2. Type checked representation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#evaluated-code">7.3.5.3. Evaluated code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interface-files">7.3.5.4. Interface files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#source-plugin-example">7.3.5.5. Source plugin example</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hole-fit-plugins">7.3.6. Hole fit plugins</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#stateful-hole-fit-plugins">7.3.6.1. Stateful hole fit plugins</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hole-fit-plugin-example">7.3.6.2. Hole fit plugin example</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#controlling-recompilation">7.3.7. Controlling Recompilation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#frontend-plugins">7.3.8. Frontend plugins</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dynflags-plugins">7.3.9. DynFlags plugins</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li><span class="section-number">7. </span>Extending and using GHC as a Library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/extending_ghc.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="extending-and-using-ghc-as-a-library">
<span id="extending-ghc"></span><h1><span class="section-number">7. </span>Extending and using GHC as a Library<a class="headerlink" href="#extending-and-using-ghc-as-a-library" title="Permalink to this heading">¶</a></h1>
<p>GHC exposes its internal APIs to users through the built-in ghc package.
It allows you to write programs that leverage GHC’s entire compilation
driver, in order to analyze or compile Haskell code programmatically.
Furthermore, GHC gives users the ability to load compiler plugins during
compilation - modules which are allowed to view and change GHC’s
internal intermediate representation, Core. Plugins are suitable for
things like experimental optimizations or analysis, and offer a lower
barrier of entry to compiler development for many common cases.</p>
<p>Furthermore, GHC offers a lightweight annotation mechanism that you can
use to annotate your source code with metadata, which you can later
inspect with either the compiler API or a compiler plugin.</p>
<section id="source-annotations">
<span id="annotation-pragmas"></span><h2><span class="section-number">7.1. </span>Source annotations<a class="headerlink" href="#source-annotations" title="Permalink to this heading">¶</a></h2>
<p>Annotations are small pragmas that allow you to attach data to
identifiers in source code, which are persisted when compiled. These
pieces of data can then inspected and utilized when using GHC as a
library or writing a compiler plugin.</p>
<section id="annotating-values">
<span id="ann-pragma"></span><h3><span class="section-number">7.1.1. </span>Annotating values<a class="headerlink" href="#annotating-values" title="Permalink to this heading">¶</a></h3>
<p id="index-0">Any expression that has both <code class="docutils literal notranslate"><span class="pre">Typeable</span></code> and <code class="docutils literal notranslate"><span class="pre">Data</span></code> instances may be
attached to a top-level value binding using an <code class="docutils literal notranslate"><span class="pre">ANN</span></code> pragma. In
particular, this means you can use <code class="docutils literal notranslate"><span class="pre">ANN</span></code> to annotate data constructors
(e.g. <code class="docutils literal notranslate"><span class="pre">Just</span></code>) as well as normal values (e.g. <code class="docutils literal notranslate"><span class="pre">take</span></code>). By way of
example, to annotate the function <code class="docutils literal notranslate"><span class="pre">foo</span></code> with the annotation
<code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">&quot;Hello&quot;</span></code> you would do this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# ANN foo (Just &quot;Hello&quot;) #-}</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>A number of restrictions apply to use of annotations:</p>
<ul>
<li><p>The binder being annotated must be at the top level (i.e. no nested
binders)</p></li>
<li><p>The binder being annotated must be declared in the current module</p></li>
<li><p>The expression you are annotating with must have a type with
<code class="docutils literal notranslate"><span class="pre">Typeable</span></code> and <code class="docutils literal notranslate"><span class="pre">Data</span></code> instances</p></li>
<li><p>The <a class="reference internal" href="exts/template_haskell.html#th-usage"><span class="std std-ref">Template Haskell staging restrictions</span></a> apply to the
expression being annotated with, so for example you cannot run a
function from the module being compiled.</p>
<p>To be precise, the annotation <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">ANN</span> <span class="pre">x</span> <span class="pre">e</span> <span class="pre">#-}</span></code> is well staged if
and only if <code class="docutils literal notranslate"><span class="pre">$(e)</span></code> would be (disregarding the usual type
restrictions of the splice syntax, and the usual restriction on
splicing inside a splice - <code class="docutils literal notranslate"><span class="pre">$([|1|])</span></code> is fine as an annotation,
albeit redundant).</p>
</li>
</ul>
<p>If you feel strongly that any of these restrictions are too onerous,
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/mailing-lists-and-irc">please give the GHC team a shout</a>.</p>
<p>However, apart from these restrictions, many things are allowed,
including expressions which are not fully evaluated! Annotation
expressions will be evaluated by the compiler just like Template Haskell
splices are. So, this annotation is fine:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# ANN f SillyAnnotation { foo = (id 10) + $([| 20 |]), bar = &#39;f } #-}</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="annotating-types">
<span id="typeann-pragma"></span><h3><span class="section-number">7.1.2. </span>Annotating types<a class="headerlink" href="#annotating-types" title="Permalink to this heading">¶</a></h3>
<p id="index-1">You can annotate types with the <code class="docutils literal notranslate"><span class="pre">ANN</span></code> pragma by using the <code class="docutils literal notranslate"><span class="pre">type</span></code>
keyword. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# ANN type Foo (Just &quot;A `Maybe String&#39; annotation&quot;) #-}</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="annotating-modules">
<span id="modann-pragma"></span><h3><span class="section-number">7.1.3. </span>Annotating modules<a class="headerlink" href="#annotating-modules" title="Permalink to this heading">¶</a></h3>
<p id="index-2">You can annotate modules with the <code class="docutils literal notranslate"><span class="pre">ANN</span></code> pragma by using the <code class="docutils literal notranslate"><span class="pre">module</span></code>
keyword. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# ANN module (Just &quot;A `Maybe String&#39; annotation&quot;) #-}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="using-ghc-as-a-library">
<span id="ghc-as-a-library"></span><h2><span class="section-number">7.2. </span>Using GHC as a Library<a class="headerlink" href="#using-ghc-as-a-library" title="Permalink to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">ghc</span></code> package exposes most of GHC’s frontend to users, and thus
allows you to write programs that leverage it. This library is actually
the same library used by GHC’s internal, frontend compilation driver,
and thus allows you to write tools that programmatically compile source
code and inspect it. Such functionality is useful in order to write
things like IDE or refactoring tools. As a simple example, here’s a
program which compiles a module, much like ghc itself does by default
when invoked:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="w"> </span><span class="nn">GHC</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Paths</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nf">libdir</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Driver.Session</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nf">defaultFatalMessager</span><span class="p">,</span><span class="w"> </span><span class="nf">defaultFlushOut</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="n">defaultErrorHandler</span><span class="w"> </span><span class="n">defaultFatalMessager</span><span class="w"> </span><span class="n">defaultFlushOut</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="n">runGhc</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">libdir</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">        </span><span class="n">dflags</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getSessionDynFlags</span><span class="w"></span>
<span class="w">        </span><span class="n">setSessionDynFlags</span><span class="w"> </span><span class="n">dflags</span><span class="w"></span>
<span class="w">        </span><span class="n">target</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">guessTarget</span><span class="w"> </span><span class="s">&quot;test_main.hs&quot;</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"></span>
<span class="w">        </span><span class="n">setTargets</span><span class="w"> </span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="n">load</span><span class="w"> </span><span class="kt">LoadAllTargets</span><span class="w"></span>
</pre></div>
</div>
<p>The argument to <code class="docutils literal notranslate"><span class="pre">runGhc</span></code> is a bit tricky. GHC needs this to find its
libraries, so the argument must refer to the directory that is printed
by <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">--print-libdir</span></code> for the same version of GHC that the program
is being compiled with. Above we therefore use the <code class="docutils literal notranslate"><span class="pre">ghc-paths</span></code> package
which provides this for us.</p>
<p>Compiling it results in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat test_main.hs
main = putStrLn &quot;hi&quot;
$ ghc -package ghc simple_ghc_api.hs
[1 of 1] Compiling Main             ( simple_ghc_api.hs, simple_ghc_api.o )
Linking simple_ghc_api ...
$ ./simple_ghc_api
$ ./test_main
hi
$
</pre></div>
</div>
<p>For more information on using the API, as well as more samples and
references, please see <a class="reference external" href="http://haskell.org/haskellwiki/GHC/As_a_library">this Haskell.org wiki
page</a>.</p>
</section>
<section id="compiler-plugins">
<span id="id1"></span><h2><span class="section-number">7.3. </span>Compiler Plugins<a class="headerlink" href="#compiler-plugins" title="Permalink to this heading">¶</a></h2>
<p>GHC has the ability to load compiler plugins at compile time. The
feature is similar to the one provided by
<a class="reference external" href="http://gcc.gnu.org/wiki/plugins">GCC</a>, and allows users to write
plugins that can adjust the behaviour of the constraint solver, inspect
and modify the compilation pipeline, as well as transform and inspect
GHC’s intermediate language, Core. Plugins are suitable for experimental
analysis or optimization, and require no changes to GHC’s source code to
use.</p>
<p>Plugins cannot optimize/inspect C-\-, nor can they implement things like
parser/front-end modifications like GCC, apart from limited changes to
the constraint solver. If you feel strongly that any of these
restrictions are too onerous,
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/mailing-lists-and-irc">please give the GHC team a shout</a>.</p>
<p>Plugins do not work with <code class="docutils literal notranslate"><span class="pre">-fexternal-interpreter</span></code>. If you need to run plugins
with <code class="docutils literal notranslate"><span class="pre">-fexternal-interpreter</span></code> let GHC developers know in <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/14335">#14335</a>.</p>
<section id="using-compiler-plugins">
<span id="id2"></span><h3><span class="section-number">7.3.1. </span>Using compiler plugins<a class="headerlink" href="#using-compiler-plugins" title="Permalink to this heading">¶</a></h3>
<p>Plugins can be added on the command line with the <a class="reference internal" href="#ghc-flag-fplugin-module"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fplugin=⟨module⟩</span></code></a>
option where ⟨module⟩ is a module in a registered package that exports the
plugin. Arguments can be passed to the plugins with the
<a class="reference internal" href="#ghc-flag-fplugin-opt-module-args"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fplugin-opt=⟨module⟩:⟨args⟩</span></code></a> option. The list of enabled plugins can
be reset with the <a class="reference internal" href="#ghc-flag-fclear-plugins"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fclear-plugins</span></code></a> option.</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fplugin-module">
<span class="sig-name descname"><span class="pre">-fplugin</span></span><span class="sig-prename descclassname"><span class="pre">=⟨module⟩</span></span><a class="headerlink" href="#ghc-flag-fplugin-module" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the plugin in the given module. The module must be a member of a
package registered in GHC’s package database.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fplugin-opt-module-args">
<span class="sig-name descname"><span class="pre">-fplugin-opt</span></span><span class="sig-prename descclassname"><span class="pre">=⟨module⟩:⟨args⟩</span></span><a class="headerlink" href="#ghc-flag-fplugin-opt-module-args" title="Permalink to this definition">¶</a></dt>
<dd><p>Give arguments to a plugin module; module must be specified with
<a class="reference internal" href="#ghc-flag-fplugin-module"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fplugin=⟨module⟩</span></code></a>.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fplugin-trustworthy">
<span class="sig-name descname"><span class="pre">-fplugin-trustworthy</span></span><a class="headerlink" href="#ghc-flag-fplugin-trustworthy" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, when a module is compiled with plugins, it will be marked as
unsafe. With this flag passed, all plugins are treated as trustworthy
and the safety inference will no longer be affected.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fclear-plugins">
<span class="sig-name descname"><span class="pre">-fclear-plugins</span></span><a class="headerlink" href="#ghc-flag-fclear-plugins" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the list of plugins previously specified with
<a class="reference internal" href="#ghc-flag-fplugin-module"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fplugin</span></code></a>. This is useful in GHCi where
simply removing the <a class="reference internal" href="#ghc-flag-fplugin-module"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fplugin</span></code></a> options from
the command line is not possible. Instead <code class="docutils literal notranslate"><span class="pre">:set</span> <span class="pre">-fclear-plugins</span></code> can be
used.</p>
</dd></dl>

<p>As an example, in order to load the plugin exported by <code class="docutils literal notranslate"><span class="pre">Foo.Plugin</span></code> in
the package <code class="docutils literal notranslate"><span class="pre">foo-ghc-plugin</span></code>, and give it the parameter “baz”, we
would invoke GHC like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ghc -fplugin Foo.Plugin -fplugin-opt Foo.Plugin:baz Test.hs
[1 of 1] Compiling Main             ( Test.hs, Test.o )
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
Loading package foo-ghc-plugin-0.1 ... linking ... done.
...
Linking Test ...
$
</pre></div>
</div>
<p>Alternatively, core plugins can be specified with Template Haskell.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">addCorePlugin</span><span class="w"> </span><span class="s">&quot;Foo.Plugin&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>This inserts the plugin as a core-to-core pass. Unlike <cite>-fplugin=(module)</cite>,
the plugin module can’t reside in the same package as the module calling
<a class="reference external" href="./../libraries/template-haskell-2.18.0.0/Language-Haskell-TH-Syntax.html#v:addCorePlugin">Language.Haskell.TH.Syntax.addCorePlugin</a>. This way, the
implementation can expect the plugin to be built by the time
it is needed.</p>
<p>Plugin modules live in a separate namespace from
the user import namespace.  By default, these two namespaces are
the same; however, there are a few command line options which
control specifically plugin packages:</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-plugin-package-pkg">
<span class="sig-name descname"><span class="pre">-plugin-package</span></span><span class="sig-prename descclassname"> <span class="pre">⟨pkg⟩</span></span><a class="headerlink" href="#ghc-flag-plugin-package-pkg" title="Permalink to this definition">¶</a></dt>
<dd><p>This option causes the installed package ⟨pkg⟩ to be exposed for plugins,
such as <a class="reference internal" href="#ghc-flag-fplugin-module"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fplugin=⟨module⟩</span></code></a>. The package ⟨pkg⟩ can be specified
in full with its version number (e.g.  <code class="docutils literal notranslate"><span class="pre">network-1.0</span></code>) or the version
number can be omitted if there is only one version of the package
installed. If there are multiple versions of ⟨pkg⟩ installed and
<a class="reference internal" href="#ghc-flag-hide-all-plugin-packages"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-hide-all-plugin-packages</span></code></a> was not specified, then all other
versions will become hidden.  <a class="reference internal" href="#ghc-flag-plugin-package-pkg"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-plugin-package</span> <span class="pre">⟨pkg⟩</span></code></a> supports
thinning and renaming described in <a class="reference internal" href="packages.html#package-thinning-and-renaming"><span class="std std-ref">Thinning and renaming modules</span></a>.</p>
<p>Unlike <a class="reference internal" href="packages.html#ghc-flag-package-pkg"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-package</span> <span class="pre">⟨pkg⟩</span></code></a>, this option does NOT cause package ⟨pkg⟩
to be linked into the resulting executable or shared object.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-plugin-package-id-pkg-id">
<span class="sig-name descname"><span class="pre">-plugin-package-id</span></span><span class="sig-prename descclassname"> <span class="pre">⟨pkg-id⟩</span></span><a class="headerlink" href="#ghc-flag-plugin-package-id-pkg-id" title="Permalink to this definition">¶</a></dt>
<dd><p>Exposes a package in the plugin namespace like <a class="reference internal" href="#ghc-flag-plugin-package-pkg"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-plugin-package</span>
<span class="pre">⟨pkg⟩</span></code></a>, but the package is named by its installed package ID rather than by
name.  This is a more robust way to name packages, and can be used to
select packages that would otherwise be shadowed. Cabal passes
<a class="reference internal" href="#ghc-flag-plugin-package-id-pkg-id"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-plugin-package-id</span> <span class="pre">⟨pkg-id⟩</span></code></a> flags to GHC.
<a class="reference internal" href="#ghc-flag-plugin-package-id-pkg-id"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-plugin-package-id</span> <span class="pre">⟨pkg-id⟩</span></code></a> supports thinning and renaming
described in <a class="reference internal" href="packages.html#package-thinning-and-renaming"><span class="std std-ref">Thinning and renaming modules</span></a>.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-hide-all-plugin-packages">
<span class="sig-name descname"><span class="pre">-hide-all-plugin-packages</span></span><a class="headerlink" href="#ghc-flag-hide-all-plugin-packages" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, all exposed packages in the normal, source import namespace are
also available for plugins.  This causes those packages to be hidden by
default.  If you use this flag, then any packages with plugins you require
need to be explicitly exposed using <a class="reference internal" href="#ghc-flag-plugin-package-pkg"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-plugin-package</span> <span class="pre">⟨pkg⟩</span></code></a>
options.</p>
</dd></dl>

<p>At the moment, the only way to specify a dependency on a plugin
in Cabal is to put it in <code class="docutils literal notranslate"><span class="pre">build-depends</span></code> (which uses the conventional
<a class="reference internal" href="packages.html#ghc-flag-package-id-unit-id"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-package-id</span> <span class="pre">⟨unit-id⟩</span></code></a> flag); however, in the future there
will be a separate field for specifying plugin dependencies specifically.</p>
</section>
<section id="writing-compiler-plugins">
<span id="id3"></span><h3><span class="section-number">7.3.2. </span>Writing compiler plugins<a class="headerlink" href="#writing-compiler-plugins" title="Permalink to this heading">¶</a></h3>
<p>Plugins are modules that export at least a single identifier,
<code class="docutils literal notranslate"><span class="pre">plugin</span></code>, of type <code class="docutils literal notranslate"><span class="pre">GHC.Plugins.Plugin</span></code>. All plugins should
<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">GHC.Plugins</span></code> as it defines the interface to the compilation
pipeline.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">Plugin</span></code> effectively holds a function which installs a compilation
pass into the compiler pipeline. By default there is the empty plugin
which does nothing, <code class="docutils literal notranslate"><span class="pre">GHC.Plugins.defaultPlugin</span></code>, which you should
override with record syntax to specify your installation function. Since
the exact fields of the <code class="docutils literal notranslate"><span class="pre">Plugin</span></code> type are open to change, this is the
best way to ensure your plugins will continue to work in the future with
minimal interface impact.</p>
<p><code class="docutils literal notranslate"><span class="pre">Plugin</span></code> exports a field, <code class="docutils literal notranslate"><span class="pre">installCoreToDos</span></code> which is a function of
type <code class="docutils literal notranslate"><span class="pre">[CommandLineOption]</span> <span class="pre">-&gt;</span> <span class="pre">[CoreToDo]</span> <span class="pre">-&gt;</span> <span class="pre">CoreM</span> <span class="pre">[CoreToDo]</span></code>. A
<code class="docutils literal notranslate"><span class="pre">CommandLineOption</span></code> is effectively just <code class="docutils literal notranslate"><span class="pre">String</span></code>, and a <code class="docutils literal notranslate"><span class="pre">CoreToDo</span></code>
is basically a function of type <code class="docutils literal notranslate"><span class="pre">Core</span> <span class="pre">-&gt;</span> <span class="pre">Core</span></code>. A <code class="docutils literal notranslate"><span class="pre">CoreToDo</span></code> gives
your pass a name and runs it over every compiled module when you invoke
GHC.</p>
<p>As a quick example, here is a simple plugin that just does nothing and
just returns the original compilation pipeline, unmodified, and says
‘Hello’:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">DoNothing.Plugin</span><span class="w"> </span><span class="p">(</span><span class="nf">plugin</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Plugins</span><span class="w"></span>

<span class="nf">plugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Plugin</span><span class="w"></span>
<span class="nf">plugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">defaultPlugin</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">installCoreToDos</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">install</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="nf">install</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">CoreToDo</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CoreM</span><span class="w"> </span><span class="p">[</span><span class="kt">CoreToDo</span><span class="p">]</span><span class="w"></span>
<span class="nf">install</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">todo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">putMsgS</span><span class="w"> </span><span class="s">&quot;Hello!&quot;</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="n">todo</span><span class="w"></span>
</pre></div>
</div>
<p>Provided you compiled this plugin and registered it in a package (with
cabal for instance,) you can then use it by just specifying
<code class="docutils literal notranslate"><span class="pre">-fplugin=DoNothing.Plugin</span></code> on the command line, and during the
compilation you should see GHC say ‘Hello’.</p>
<p>Running multiple plugins is also supported, by passing
multiple <code class="docutils literal notranslate"><span class="pre">-fplugin=...</span></code> options. GHC will load the plugins
in the order in which they are specified on the command line
and, when appropriate, compose their effects in the same
order. That is, if we had two Core plugins, <code class="docutils literal notranslate"><span class="pre">Plugin1</span></code> and
<code class="docutils literal notranslate"><span class="pre">Plugin2</span></code>, each defining an <code class="docutils literal notranslate"><span class="pre">install</span></code> function like
the one above, then GHC would first run <code class="docutils literal notranslate"><span class="pre">Plugin1.install</span></code>
on the default <code class="docutils literal notranslate"><span class="pre">[CoreToDo]</span></code>, take the result and feed it to
<code class="docutils literal notranslate"><span class="pre">Plugin2.install</span></code>. <code class="docutils literal notranslate"><span class="pre">-fplugin=Plugin1</span> <span class="pre">-fplugin=Plugin2</span></code>
will update the Core pipeline by applying
<code class="docutils literal notranslate"><span class="pre">Plugin1.install</span> <span class="pre">opts1</span> <span class="pre">&gt;=&gt;</span> <span class="pre">Plugin2.install</span> <span class="pre">opts2</span></code> (where
<code class="docutils literal notranslate"><span class="pre">opts1</span></code> and <code class="docutils literal notranslate"><span class="pre">opts2</span></code> are the options passed to each plugin
using <code class="docutils literal notranslate"><span class="pre">-fplugin-opt=...</span></code>). This is not specific to Core
plugins but holds for all the types of plugins that can be
composed or sequenced in some way: the first plugin to appear
on the GHC command line will always act first.</p>
</section>
<section id="core-plugins-in-more-detail">
<span id="id4"></span><h3><span class="section-number">7.3.3. </span>Core plugins in more detail<a class="headerlink" href="#core-plugins-in-more-detail" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">CoreToDo</span></code> is effectively a data type that describes all the kinds of
optimization passes GHC does on Core. There are passes for
simplification, CSE, etc. There is a specific case for
plugins, <code class="docutils literal notranslate"><span class="pre">CoreDoPluginPass</span> <span class="pre">::</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">PluginPass</span> <span class="pre">-&gt;</span> <span class="pre">CoreToDo</span></code> which
should be what you always use when inserting your own pass into the
pipeline. The first parameter is the name of the plugin, and the second
is the pass you wish to insert.</p>
<p><code class="docutils literal notranslate"><span class="pre">CoreM</span></code> is a monad that all of the Core optimizations live and operate
inside of.</p>
<p>A plugin’s installation function (<code class="docutils literal notranslate"><span class="pre">install</span></code> in the above example)
takes a list of <code class="docutils literal notranslate"><span class="pre">CoreToDo</span></code>s and returns a list of <code class="docutils literal notranslate"><span class="pre">CoreToDo</span></code>.
Before GHC begins compiling modules, it enumerates all the needed
plugins you tell it to load, and runs all of their installation
functions, initially on a list of passes that GHC specifies itself.
After doing this for every plugin, the final list of passes is given to
the optimizer, and are run by simply going over the list in order.</p>
<p>You should be careful with your installation function, because the list
of passes you give back isn’t questioned or double checked by GHC at the
time of this writing. An installation function like the following:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">install</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">CoreToDo</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CoreM</span><span class="w"> </span><span class="p">[</span><span class="kt">CoreToDo</span><span class="p">]</span><span class="w"></span>
<span class="nf">install</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
</pre></div>
</div>
<p>is certainly valid, but also certainly not what anyone really wants.</p>
<section id="manipulating-bindings">
<span id="id5"></span><h4><span class="section-number">7.3.3.1. </span>Manipulating bindings<a class="headerlink" href="#manipulating-bindings" title="Permalink to this heading">¶</a></h4>
<p>In the last section we saw that besides a name, a <code class="docutils literal notranslate"><span class="pre">CoreDoPluginPass</span></code>
takes a pass of type <code class="docutils literal notranslate"><span class="pre">PluginPass</span></code>. A <code class="docutils literal notranslate"><span class="pre">PluginPass</span></code> is a synonym for
<code class="docutils literal notranslate"><span class="pre">(ModGuts</span> <span class="pre">-&gt;</span> <span class="pre">CoreM</span> <span class="pre">ModGuts)</span></code>. <code class="docutils literal notranslate"><span class="pre">ModGuts</span></code> is a type that represents
the one module being compiled by GHC at any given time.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">ModGuts</span></code> holds all of the module’s top level bindings which we can
examine. These bindings are of type <code class="docutils literal notranslate"><span class="pre">CoreBind</span></code> and effectively
represent the binding of a name to body of code. Top-level module
bindings are part of a <code class="docutils literal notranslate"><span class="pre">ModGuts</span></code> in the field <code class="docutils literal notranslate"><span class="pre">mg_binds</span></code>.
Implementing a pass that manipulates the top level bindings merely needs
to iterate over this field, and return a new <code class="docutils literal notranslate"><span class="pre">ModGuts</span></code> with an updated
<code class="docutils literal notranslate"><span class="pre">mg_binds</span></code> field. Because this is such a common case, there is a
function provided named <code class="docutils literal notranslate"><span class="pre">bindsOnlyPass</span></code> which lifts a function of type
<code class="docutils literal notranslate"><span class="pre">([CoreBind]</span> <span class="pre">-&gt;</span> <span class="pre">CoreM</span> <span class="pre">[CoreBind])</span></code> to type
<code class="docutils literal notranslate"><span class="pre">(ModGuts</span> <span class="pre">-&gt;</span> <span class="pre">CoreM</span> <span class="pre">ModGuts)</span></code>.</p>
<p>Continuing with our example from the last section, we can write a simple
plugin that just prints out the name of all the non-recursive bindings
in a module it compiles:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">SayNames.Plugin</span><span class="w"> </span><span class="p">(</span><span class="nf">plugin</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Plugins</span><span class="w"></span>

<span class="nf">plugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Plugin</span><span class="w"></span>
<span class="nf">plugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">defaultPlugin</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">installCoreToDos</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">install</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="nf">install</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">CoreToDo</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CoreM</span><span class="w"> </span><span class="p">[</span><span class="kt">CoreToDo</span><span class="p">]</span><span class="w"></span>
<span class="nf">install</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">todo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="kt">CoreDoPluginPass</span><span class="w"> </span><span class="s">&quot;Say name&quot;</span><span class="w"> </span><span class="n">pass</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">todo</span><span class="p">)</span><span class="w"></span>

<span class="nf">pass</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ModGuts</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CoreM</span><span class="w"> </span><span class="kt">ModGuts</span><span class="w"></span>
<span class="nf">pass</span><span class="w"> </span><span class="n">guts</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getDynFlags</span><span class="w"></span>
<span class="w">               </span><span class="n">bindsOnlyPass</span><span class="w"> </span><span class="p">(</span><span class="n">mapM</span><span class="w"> </span><span class="p">(</span><span class="n">printBind</span><span class="w"> </span><span class="n">dflags</span><span class="p">))</span><span class="w"> </span><span class="n">guts</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="n">printBind</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">DynFlags</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CoreBind</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CoreM</span><span class="w"> </span><span class="kt">CoreBind</span><span class="w"></span>
<span class="w">        </span><span class="n">printBind</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="n">bndr</span><span class="o">@</span><span class="p">(</span><span class="kt">NonRec</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">          </span><span class="n">putMsgS</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Non-recursive binding named &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">showSDoc</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="p">(</span><span class="n">ppr</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">return</span><span class="w"> </span><span class="n">bndr</span><span class="w"></span>
<span class="w">        </span><span class="n">printBind</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">bndr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">bndr</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="using-annotations">
<span id="getting-annotations"></span><h4><span class="section-number">7.3.3.2. </span>Using Annotations<a class="headerlink" href="#using-annotations" title="Permalink to this heading">¶</a></h4>
<p>Previously we discussed annotation pragmas (<a class="reference internal" href="#annotation-pragmas"><span class="std std-ref">Source annotations</span></a>),
which we mentioned could be used to give compiler plugins extra guidance
or information. Annotations for a module can be retrieved by a plugin,
but you must go through the modules <code class="docutils literal notranslate"><span class="pre">ModGuts</span></code> in order to get it.
Because annotations can be arbitrary instances of <code class="docutils literal notranslate"><span class="pre">Data</span></code> and
<code class="docutils literal notranslate"><span class="pre">Typeable</span></code>, you need to give a type annotation specifying the proper
type of data to retrieve from the interface file, and you need to make
sure the annotation type used by your users is the same one your plugin
uses. For this reason, we advise distributing annotations as part of the
package which also provides compiler plugins if possible.</p>
<p>To get the annotations of a single binder, you can use
<code class="docutils literal notranslate"><span class="pre">getAnnotations</span></code> and specify the proper type. Here’s an example that
will print out the name of any top-level non-recursive binding with the
<code class="docutils literal notranslate"><span class="pre">SomeAnn</span></code> annotation:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE DeriveDataTypeable #-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">SayAnnNames.Plugin</span><span class="w"> </span><span class="p">(</span><span class="nf">plugin</span><span class="p">,</span><span class="w"> </span><span class="kt">SomeAnn</span><span class="p">(</span><span class="o">..</span><span class="p">))</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Plugins</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Control.Monad</span><span class="w"> </span><span class="p">(</span><span class="nf">unless</span><span class="p">)</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Data.Data</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">SomeAnn</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">SomeAnn</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Data</span><span class="w"></span>

<span class="nf">plugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Plugin</span><span class="w"></span>
<span class="nf">plugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">defaultPlugin</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">installCoreToDos</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">install</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="nf">install</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">CoreToDo</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CoreM</span><span class="w"> </span><span class="p">[</span><span class="kt">CoreToDo</span><span class="p">]</span><span class="w"></span>
<span class="nf">install</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">todo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="kt">CoreDoPluginPass</span><span class="w"> </span><span class="s">&quot;Say name&quot;</span><span class="w"> </span><span class="n">pass</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">todo</span><span class="p">)</span><span class="w"></span>

<span class="nf">pass</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ModGuts</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CoreM</span><span class="w"> </span><span class="kt">ModGuts</span><span class="w"></span>
<span class="nf">pass</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">          </span><span class="n">dflags</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getDynFlags</span><span class="w"></span>
<span class="w">          </span><span class="n">mapM_</span><span class="w"> </span><span class="p">(</span><span class="n">printAnn</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">mg_binds</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">g</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="n">printAnn</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">DynFlags</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ModGuts</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CoreBind</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CoreM</span><span class="w"> </span><span class="kt">CoreBind</span><span class="w"></span>
<span class="w">        </span><span class="n">printAnn</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="n">guts</span><span class="w"> </span><span class="n">bndr</span><span class="o">@</span><span class="p">(</span><span class="kt">NonRec</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">          </span><span class="n">anns</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">annotationsOn</span><span class="w"> </span><span class="n">guts</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CoreM</span><span class="w"> </span><span class="p">[</span><span class="kt">SomeAnn</span><span class="p">]</span><span class="w"></span>
<span class="w">          </span><span class="n">unless</span><span class="w"> </span><span class="p">(</span><span class="n">null</span><span class="w"> </span><span class="n">anns</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">putMsgS</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Annotated binding found: &quot;</span><span class="w"> </span><span class="o">++</span><span class="w">  </span><span class="n">showSDoc</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="p">(</span><span class="n">ppr</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">return</span><span class="w"> </span><span class="n">bndr</span><span class="w"></span>
<span class="w">        </span><span class="n">printAnn</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">bndr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">bndr</span><span class="w"></span>

<span class="nf">annotationsOn</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Data</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">ModGuts</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CoreBndr</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CoreM</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">annotationsOn</span><span class="w"> </span><span class="n">guts</span><span class="w"> </span><span class="n">bndr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">anns</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getAnnotations</span><span class="w"> </span><span class="n">deserializeWithData</span><span class="w"> </span><span class="n">guts</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">lookupWithDefaultUFM</span><span class="w"> </span><span class="n">anns</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="p">(</span><span class="n">varUnique</span><span class="w"> </span><span class="n">bndr</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Please see the GHC API documentation for more about how to use internal
APIs, etc.</p>
</section>
</section>
<section id="typechecker-plugins">
<span id="id6"></span><h3><span class="section-number">7.3.4. </span>Typechecker plugins<a class="headerlink" href="#typechecker-plugins" title="Permalink to this heading">¶</a></h3>
<p>In addition to Core plugins, GHC has experimental support for
typechecker plugins, which allow the behaviour of the constraint solver
to be modified. For example, they make it possible to interface the
compiler to an SMT solver, in order to support a richer theory of
type-level arithmetic expressions than the theory built into GHC (see
<a class="reference internal" href="exts/type_literals.html#typelit-tyfuns"><span class="std std-ref">Computing With Type-Level Naturals</span></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Plugin</span></code> type has a field <code class="docutils literal notranslate"><span class="pre">tcPlugin</span></code> of type
<code class="docutils literal notranslate"><span class="pre">[CommandLineOption]</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">TcPlugin</span></code>, where the <code class="docutils literal notranslate"><span class="pre">TcPlugin</span></code> type
is defined thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">TcPlugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="kt">TcPlugin</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">tcPluginInit</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">TcPluginM</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">tcPluginSolve</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcPluginSolver</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">tcPluginStop</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcPluginM</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">TcPluginSolver</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="kt">Ct</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Ct</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Ct</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcPluginM</span><span class="w"> </span><span class="kt">TcPluginResult</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">TcPluginResult</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">TcPluginContradiction</span><span class="w"> </span><span class="p">[</span><span class="kt">Ct</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">TcPluginOk</span><span class="w"> </span><span class="p">[(</span><span class="kt">EvTerm</span><span class="p">,</span><span class="kt">Ct</span><span class="p">)]</span><span class="w"> </span><span class="p">[</span><span class="kt">Ct</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>(The details of this representation are subject to change as we gain
more experience writing typechecker plugins. It should not be assumed to
be stable between GHC releases.)</p>
<p>The basic idea is as follows:</p>
<ul class="simple">
<li><p>When type checking a module, GHC calls <code class="docutils literal notranslate"><span class="pre">tcPluginInit</span></code> once before
constraint solving starts. This allows the plugin to look things up
in the context, initialise mutable state or open a connection to an
external process (e.g. an external SMT solver). The plugin can return
a result of any type it likes, and the result will be passed to the
other two fields.</p></li>
<li><p>During constraint solving, GHC repeatedly calls <code class="docutils literal notranslate"><span class="pre">tcPluginSolve</span></code>.
This function is provided with the current set of constraints, and
should return a <code class="docutils literal notranslate"><span class="pre">TcPluginResult</span></code> that indicates whether a
contradiction was found or progress was made. If the plugin solver
makes progress, GHC will re-start the constraint solving pipeline,
looping until a fixed point is reached.</p></li>
<li><p>Finally, GHC calls <code class="docutils literal notranslate"><span class="pre">tcPluginStop</span></code> after constraint solving is
finished, allowing the plugin to dispose of any resources it has
allocated (e.g. terminating the SMT solver process).</p></li>
</ul>
<p>Plugin code runs in the <code class="docutils literal notranslate"><span class="pre">TcPluginM</span></code> monad, which provides a restricted
interface to GHC API functionality that is relevant for typechecker
plugins, including <code class="docutils literal notranslate"><span class="pre">IO</span></code> and reading the environment. If you need
functionality that is not exposed in the <code class="docutils literal notranslate"><span class="pre">TcPluginM</span></code> module, you can
use <code class="docutils literal notranslate"><span class="pre">unsafeTcPluginTcM</span> <span class="pre">::</span> <span class="pre">TcM</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">TcPluginM</span> <span class="pre">a</span></code>, but are encouraged to
contact the GHC team to suggest additions to the interface. Note that
<code class="docutils literal notranslate"><span class="pre">TcPluginM</span></code> can perform arbitrary IO via
<code class="docutils literal notranslate"><span class="pre">tcPluginIO</span> <span class="pre">::</span> <span class="pre">IO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">TcPluginM</span> <span class="pre">a</span></code>, although some care must be taken
with side effects (particularly in <code class="docutils literal notranslate"><span class="pre">tcPluginSolve</span></code>). In general, it is
up to the plugin author to make sure that any IO they do is safe.</p>
<section id="constraint-solving-with-plugins">
<span id="id7"></span><h4><span class="section-number">7.3.4.1. </span>Constraint solving with plugins<a class="headerlink" href="#constraint-solving-with-plugins" title="Permalink to this heading">¶</a></h4>
<p>The key component of a typechecker plugin is a function of type
<code class="docutils literal notranslate"><span class="pre">TcPluginSolver</span></code>, like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">solve</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Ct</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Ct</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Ct</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcPluginM</span><span class="w"> </span><span class="kt">TcPluginResult</span><span class="w"></span>
<span class="nf">solve</span><span class="w"> </span><span class="n">givens</span><span class="w"> </span><span class="n">deriveds</span><span class="w"> </span><span class="n">wanteds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>This function will be invoked at two points in the constraint solving
process: after simplification of given constraints, and after
unflattening of wanted constraints. The two phases can be distinguished
because the deriveds and wanteds will be empty in the first case. In
each case, the plugin should either</p>
<ul class="simple">
<li><p>return <code class="docutils literal notranslate"><span class="pre">TcPluginContradiction</span></code> with a list of impossible
constraints (which must be a subset of those passed in), so they can
be turned into errors; or</p></li>
<li><p>return <code class="docutils literal notranslate"><span class="pre">TcPluginOk</span></code> with lists of solved and new constraints (the
former must be a subset of those passed in and must be supplied with
corresponding evidence terms).</p></li>
</ul>
<p>If the plugin cannot make any progress, it should return
<code class="docutils literal notranslate"><span class="pre">TcPluginOk</span> <span class="pre">[]</span> <span class="pre">[]</span></code>. Otherwise, if there were any new constraints, the
main constraint solver will be re-invoked to simplify them, then the
plugin will be invoked again. The plugin is responsible for making sure
that this process eventually terminates.</p>
<p>Plugins are provided with all available constraints (including
equalities and typeclass constraints), but it is easy for them to
discard those that are not relevant to their domain, because they need
return only those constraints for which they have made progress (either
by solving or contradicting them).</p>
<p>Constraints that have been solved by the plugin must be provided with
evidence in the form of an <code class="docutils literal notranslate"><span class="pre">EvTerm</span></code> of the type of the constraint.
This evidence is ignored for given and derived constraints, which GHC
“solves” simply by discarding them; typically this is used when they are
uninformative (e.g. reflexive equations). For wanted constraints, the
evidence will form part of the Core term that is generated after
typechecking, and can be checked by <code class="docutils literal notranslate"><span class="pre">-dcore-lint</span></code>. It is possible for
the plugin to create equality axioms for use in evidence terms, but GHC
does not check their consistency, and inconsistent axiom sets may lead
to segfaults or other runtime misbehaviour.</p>
</section>
</section>
<section id="source-plugins">
<span id="id8"></span><h3><span class="section-number">7.3.5. </span>Source plugins<a class="headerlink" href="#source-plugins" title="Permalink to this heading">¶</a></h3>
<p>In addition to core and type checker plugins, you can install plugins that can
access different representations of the source code. The main purpose of these
plugins is to make it easier to implement development tools.</p>
<p>There are several different access points that you can use for defining plugins
that access the representations. All these fields receive the list of
<code class="docutils literal notranslate"><span class="pre">CommandLineOption</span></code> strings that are passed to the compiler using the
<a class="reference internal" href="#ghc-flag-fplugin-opt-module-args"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fplugin-opt=⟨module⟩:⟨args⟩</span></code></a> flags.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">plugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Plugin</span><span class="w"></span>
<span class="nf">plugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">defaultPlugin</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">parsedResultAction</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">parsed</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">typeCheckResultAction</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">typechecked</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">spliceRunAction</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">spliceRun</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">interfaceLoadAction</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">interfaceLoad</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">renamedResultAction</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">renamed</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<section id="parsed-representation">
<h4><span class="section-number">7.3.5.1. </span>Parsed representation<a class="headerlink" href="#parsed-representation" title="Permalink to this heading">¶</a></h4>
<p>When you want to define a plugin that uses the syntax tree of the source code,
you would like to override the <code class="docutils literal notranslate"><span class="pre">parsedResultAction</span></code> field. This access point
enables you to get access to information about the lexical tokens and comments
in the source code as well as the original syntax tree of the compiled module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">parsed</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ModSummary</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HsParsedModule</span><span class="w"></span>
<span class="w">            </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Hsc</span><span class="w"> </span><span class="kt">HsParsedModule</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ModSummary</span></code> contains useful
meta-information about the compiled module. The <code class="docutils literal notranslate"><span class="pre">HsParsedModule</span></code> contains the
lexical and syntactical information we mentioned before. The result that you
return will change the result of the parsing. If you don’t want to change the
result, just return the <code class="docutils literal notranslate"><span class="pre">HsParsedModule</span></code> that you received as the argument.</p>
</section>
<section id="type-checked-representation">
<h4><span class="section-number">7.3.5.2. </span>Type checked representation<a class="headerlink" href="#type-checked-representation" title="Permalink to this heading">¶</a></h4>
<p>When you want to define a plugin that needs semantic information about the
source code, use the <code class="docutils literal notranslate"><span class="pre">typeCheckResultAction</span></code> field. For example, if your
plugin have to decide if two names are referencing the same definition or it has
to check the type of a function it is using semantic information. In this case
you need to access the renamed or type checked version of the syntax tree with
<code class="docutils literal notranslate"><span class="pre">typeCheckResultAction</span></code> or <code class="docutils literal notranslate"><span class="pre">renamedResultAction</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">typechecked</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ModSummary</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcGblEnv</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcM</span><span class="w"> </span><span class="kt">TcGblEnv</span><span class="w"></span>
<span class="nf">renamed</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcGblEnv</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HsGroup</span><span class="w"> </span><span class="kt">GhcRn</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcM</span><span class="w"> </span><span class="p">(</span><span class="kt">TcGblEnv</span><span class="p">,</span><span class="w"> </span><span class="kt">HsGroup</span><span class="w"> </span><span class="kt">GhcRn</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>By overriding the <code class="docutils literal notranslate"><span class="pre">renamedResultAction</span></code> field we can modify each <code class="docutils literal notranslate"><span class="pre">HsGroup</span></code>
after it has been renamed. A source file is separated into groups depending on
the location of template haskell splices so the contents of these groups may
not be intuitive. In order to save the entire renamed AST for inspection
at the end of typechecking you can set <code class="docutils literal notranslate"><span class="pre">renamedResultAction</span></code> to <code class="docutils literal notranslate"><span class="pre">keepRenamedSource</span></code>
which is provided by the <code class="docutils literal notranslate"><span class="pre">Plugins</span></code> module.
This is important because some parts of the renamed
syntax tree (for example, imports) are not found in the typechecked one.</p>
</section>
<section id="evaluated-code">
<h4><span class="section-number">7.3.5.3. </span>Evaluated code<a class="headerlink" href="#evaluated-code" title="Permalink to this heading">¶</a></h4>
<p>When the compiler type checks the source code, <a class="reference internal" href="exts/template_haskell.html#template-haskell"><span class="std std-ref">Template Haskell</span></a> Splices
and <a class="reference internal" href="exts/template_haskell.html#th-quasiquotation"><span class="std std-ref">Template Haskell Quasi-quotation</span></a> will be replaced by the syntax tree fragments
generated from them. However for tools that operate on the source code the
code generator is usually more interesting than the generated code. For this
reason we included <code class="docutils literal notranslate"><span class="pre">spliceRunAction</span></code>. This field is invoked on each expression
before they are evaluated. The input is type checked, so semantic information is
available for these syntax tree fragments. If you return a different expression
you can change the code that is generated.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">spliceRun</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">LHsExpr</span><span class="w"> </span><span class="kt">GhcTc</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcM</span><span class="w"> </span><span class="p">(</span><span class="kt">LHsExpr</span><span class="w"> </span><span class="kt">GhcTc</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>However take care that the generated definitions are still in the input of
<code class="docutils literal notranslate"><span class="pre">typeCheckResultAction</span></code>. If your don’t take care to filter the typechecked
input, the behavior of your tool might be inconsistent.</p>
</section>
<section id="interface-files">
<h4><span class="section-number">7.3.5.4. </span>Interface files<a class="headerlink" href="#interface-files" title="Permalink to this heading">¶</a></h4>
<p>Sometimes when you are writing a tool, knowing the source code is not enough,
you also have to know details about the modules that you import. In this case we
suggest using the <code class="docutils literal notranslate"><span class="pre">interfaceLoadAction</span></code>. This will be called each time when
the code of an already compiled module is loaded. It will be invoked for modules
from installed packages and even modules that are installed with GHC. It will
NOT be invoked with your own modules.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">interfaceLoad</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">lcl</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ModIface</span><span class="w"></span>
<span class="w">                                </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IfM</span><span class="w"> </span><span class="n">lcl</span><span class="w"> </span><span class="kt">ModIface</span><span class="w"></span>
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">ModIface</span></code> datatype you can find lots of useful information, including
the exported definitions and type class instances.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ModIface</span></code> datatype also contains facilities for extending it with extra
data, stored in a <code class="docutils literal notranslate"><span class="pre">Map</span></code> of serialised fields, indexed by field names and using
GHC’s internal <code class="docutils literal notranslate"><span class="pre">Binary</span></code> class. The interface to work with these fields is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">readIfaceField</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Binary</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">FieldName</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ModIface</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="nf">writeIfaceField</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Binary</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">FieldName</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ModIface</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">ModIface</span><span class="w"></span>
<span class="nf">deleteIfaceField</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FieldName</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ModIface</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ModIface</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">FieldName</span></code> is open-ended, but typically it should contain the producing
package name, along with the actual field name. Then, the version number can either
be attached to the serialised data for that field, or in cases where multiple versions
of a field could exist in the same interface file, included in the field name.</p>
<p>Depending on if the field version advances with the package version, or independently,
the version can be attached to either the package name or the field name. Examples of
each case:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">package</span><span class="o">/</span><span class="n">field</span><span class="w"></span>
<span class="nf">ghc</span><span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">n</span><span class="o">/</span><span class="n">core</span><span class="w"></span>
<span class="nf">package</span><span class="o">/</span><span class="n">field</span><span class="o">-</span><span class="n">n</span><span class="w"></span>
</pre></div>
</div>
<p>To read an interface file from an external tool without linking to GHC, the format
is described at <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/Extensible-Interface-Files">Extensible Interface Files</a>.</p>
</section>
<section id="source-plugin-example">
<h4><span class="section-number">7.3.5.5. </span>Source plugin example<a class="headerlink" href="#source-plugin-example" title="Permalink to this heading">¶</a></h4>
<p>In this example, we inspect all available details of the compiled source code.
We don’t change any of the representation, but write out the details to the
standard output. The pretty printed representation of the parsed, renamed and
type checked syntax tree will be in the output as well as the evaluated splices
and quasi quotes. The name of the interfaces that are loaded will also be
displayed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">SourcePlugin</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Control.Monad.IO.Class</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Driver.Session</span><span class="w"> </span><span class="p">(</span><span class="nf">getDynFlags</span><span class="p">)</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Driver.Plugins</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Driver.Types</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Tc.Types</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Language.Haskell.Syntax.Extension</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Hs.Decls</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Hs.Expr</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Hs.ImpExp</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Types.Avail</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Utils.Outputable</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Hs.Doc</span><span class="w"></span>

<span class="nf">plugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Plugin</span><span class="w"></span>
<span class="nf">plugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">defaultPlugin</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">parsedResultAction</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">parsedPlugin</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">renamedResultAction</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">renamedAction</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">typeCheckResultAction</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">typecheckPlugin</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">spliceRunAction</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">metaPlugin</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">interfaceLoadAction</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">interfaceLoadPlugin</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="nf">parsedPlugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ModSummary</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HsParsedModule</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Hsc</span><span class="w"> </span><span class="kt">HsParsedModule</span><span class="w"></span>
<span class="nf">parsedPlugin</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">pm</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getDynFlags</span><span class="w"></span>
<span class="w">       </span><span class="n">liftIO</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;parsePlugin: </span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">(</span><span class="n">showSDoc</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">ppr</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">hpm_module</span><span class="w"> </span><span class="n">pm</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">return</span><span class="w"> </span><span class="n">pm</span><span class="w"></span>

<span class="nf">renamedAction</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcGblEnv</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HsGroup</span><span class="w"> </span><span class="kt">GhcRn</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcM</span><span class="w"> </span><span class="p">(</span><span class="kt">TcGblEnv</span><span class="p">,</span><span class="w"> </span><span class="kt">HsGroup</span><span class="w"> </span><span class="kt">GhcRn</span><span class="p">)</span><span class="w"></span>
<span class="nf">renamedAction</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">tc</span><span class="w"> </span><span class="n">gr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">dflags</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getDynFlags</span><span class="w"></span>
<span class="w">  </span><span class="n">liftIO</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;typeCheckPlugin (rn): &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">(</span><span class="n">showSDoc</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">ppr</span><span class="w"> </span><span class="n">gr</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">tc</span><span class="p">,</span><span class="w"> </span><span class="n">gr</span><span class="p">)</span><span class="w"></span>

<span class="nf">typecheckPlugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ModSummary</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcGblEnv</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcM</span><span class="w"> </span><span class="kt">TcGblEnv</span><span class="w"></span>
<span class="nf">typecheckPlugin</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">tc</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getDynFlags</span><span class="w"></span>
<span class="w">       </span><span class="n">liftIO</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;typeCheckPlugin (rn): </span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">(</span><span class="n">showSDoc</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">ppr</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">tcg_rn_decls</span><span class="w"> </span><span class="n">tc</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">liftIO</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;typeCheckPlugin (tc): </span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">(</span><span class="n">showSDoc</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">ppr</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">tcg_binds</span><span class="w"> </span><span class="n">tc</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">return</span><span class="w"> </span><span class="n">tc</span><span class="w"></span>

<span class="nf">metaPlugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">LHsExpr</span><span class="w"> </span><span class="kt">GhcTc</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcM</span><span class="w"> </span><span class="p">(</span><span class="kt">LHsExpr</span><span class="w"> </span><span class="kt">GhcTc</span><span class="p">)</span><span class="w"></span>
<span class="nf">metaPlugin</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">meta</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getDynFlags</span><span class="w"></span>
<span class="w">       </span><span class="n">liftIO</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;meta: &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">(</span><span class="n">showSDoc</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">ppr</span><span class="w"> </span><span class="n">meta</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">return</span><span class="w"> </span><span class="n">meta</span><span class="w"></span>

<span class="nf">interfaceLoadPlugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ModIface</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IfM</span><span class="w"> </span><span class="n">lcl</span><span class="w"> </span><span class="kt">ModIface</span><span class="w"></span>
<span class="nf">interfaceLoadPlugin</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">iface</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getDynFlags</span><span class="w"></span>
<span class="w">       </span><span class="n">liftIO</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;interface loaded: &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">(</span><span class="n">showSDoc</span><span class="w"> </span><span class="n">dflags</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">ppr</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">mi_module</span><span class="w"> </span><span class="n">iface</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">return</span><span class="w"> </span><span class="n">iface</span><span class="w"></span>
</pre></div>
</div>
<p>When you compile a simple module that contains Template Haskell splice</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# OPTIONS_GHC -fplugin SourcePlugin #-}</span><span class="w"></span>
<span class="cm">{-# LANGUAGE TemplateHaskell #-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>

<span class="o">$</span><span class="p">(</span><span class="n">return</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>with the compiler flags <code class="docutils literal notranslate"><span class="pre">-fplugin</span> <span class="pre">SourcePlugin</span></code> it will give the following
output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>parsePlugin:
module A where
a = ()
$(return [])
typeCheckPlugin (rn): a = ()
interface loaded: Language.Haskell.TH.Lib.Internal
meta: return []
typeCheckPlugin (rn):
typeCheckPlugin (rn):
Nothing
typeCheckPlugin (tc):
{$trModule = Module (TrNameS &quot;main&quot;#) (TrNameS &quot;A&quot;#), a = ()}
</pre></div>
</div>
</section>
</section>
<section id="hole-fit-plugins">
<span id="id9"></span><h3><span class="section-number">7.3.6. </span>Hole fit plugins<a class="headerlink" href="#hole-fit-plugins" title="Permalink to this heading">¶</a></h3>
<p>Hole-fit plugins are plugins that are called when a typed-hole error message is
being generated, and allows you to access information about the typed-hole at
compile time, and allows you to customize valid hole fit suggestions.</p>
<p>Using hole-fit plugins, you can extend the behavior of valid hole fit
suggestions to use e.g. Hoogle or other external tools to find and/or synthesize
valid hole fits, with the same information about the typed-hole that GHC uses.</p>
<p>There are two access points are bundled together for defining hole fit plugins,
namely a candidate plugin and a fit plugin, for modifying the candidates to be
checked and fits respectively.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">CandPlugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">TypedHole</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">HoleFitCandidate</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcM</span><span class="w"> </span><span class="p">[</span><span class="kt">HoleFitCandidate</span><span class="p">]</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">FitPlugin</span><span class="w"> </span><span class="ow">=</span><span class="w">  </span><span class="kt">TypedHole</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">HoleFit</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcM</span><span class="w"> </span><span class="p">[</span><span class="kt">HoleFit</span><span class="p">]</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">HoleFitPlugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">HoleFitPlugin</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">candPlugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CandPlugin</span><span class="w"></span>
<span class="w">     </span><span class="c1">-- ^ A plugin for modifying hole fit candidates before they&#39;re checked</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">fitPlugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FitPlugin</span><span class="w"></span>
<span class="w">     </span><span class="c1">-- ^ A plugin for modifying valid hole fits after they&#39;ve been found.</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">TypedHole</span></code> contains all the information about the hole available to GHC
at error generation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">TypedHole</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">TyH</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">tyHRelevantCts</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Cts</span><span class="w"></span>
<span class="w">                      </span><span class="c1">-- ^ Any relevant Cts to the hole</span><span class="w"></span>
<span class="w">                    </span><span class="p">,</span><span class="w"> </span><span class="n">tyHImplics</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Implication</span><span class="p">]</span><span class="w"></span>
<span class="w">                      </span><span class="c1">-- ^ The nested implications of the hole with the</span><span class="w"></span>
<span class="w">                      </span><span class="c1">--   innermost implication first.</span><span class="w"></span>
<span class="w">                    </span><span class="p">,</span><span class="w"> </span><span class="n">tyHCt</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Ct</span><span class="w"></span>
<span class="w">                      </span><span class="c1">-- ^ The hole constraint itself, if available.</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">HoleFitPlugins</span></code> are then defined as follows</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">plugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Plugin</span><span class="w"></span>
<span class="nf">plugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">defaultPlugin</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">holeFitPlugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">fmap</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">fmap</span><span class="p">)</span><span class="w"> </span><span class="n">fromPureHFPlugin</span><span class="w"> </span><span class="n">hfPlugin</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="nf">hfPlugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">HoleFitPlugin</span><span class="w"></span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">fromPureHFPlugin</span> <span class="pre">::</span> <span class="pre">HoleFitPlugin</span> <span class="pre">-&gt;</span> <span class="pre">HoleFitPluginR</span></code> is a convenience
function provided in the <code class="docutils literal notranslate"><span class="pre">GHC.Tc.Errors.Hole</span></code> module, for defining plugins that do
not require internal state.</p>
<section id="stateful-hole-fit-plugins">
<h4><span class="section-number">7.3.6.1. </span>Stateful hole fit plugins<a class="headerlink" href="#stateful-hole-fit-plugins" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">HoleFitPlugins</span></code> are wrapped in a <code class="docutils literal notranslate"><span class="pre">HoleFitPluginR</span></code>, which provides a
<code class="docutils literal notranslate"><span class="pre">TcRef</span></code> for the plugin to use to track internal state, and to facilitate
communication between the candidate and fit plugin.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | HoleFitPluginR adds a TcRef to hole fit plugins so that plugins can</span><span class="w"></span>
<span class="c1">-- track internal state. Note the existential quantification, ensuring that</span><span class="w"></span>
<span class="c1">-- the state cannot be modified from outside the plugin.</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">HoleFitPluginR</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">s</span><span class="o">.</span><span class="w"> </span><span class="kt">HoleFitPluginR</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">hfPluginInit</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TcM</span><span class="w"> </span><span class="p">(</span><span class="kt">TcRef</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- ^ Initializes the TcRef to be passed to the plugin</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">hfPluginRun</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TcRef</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HoleFitPlugin</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- ^ The function defining the plugin itself</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">hfPluginStop</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TcRef</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcM</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- ^ Cleanup of state, guaranteed to be called even on error</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The plugin is then defined as by providing a value for the <code class="docutils literal notranslate"><span class="pre">holeFitPlugin</span></code>
field, a function that takes the <code class="docutils literal notranslate"><span class="pre">CommandLineOption</span></code> strings that are passed
to the compiler using the <a class="reference internal" href="#ghc-flag-fplugin-opt-module-args"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fplugin-opt=⟨module⟩:⟨args⟩</span></code></a> flags and returns a
<code class="docutils literal notranslate"><span class="pre">HoleFitPluginR</span></code>. This function can be used to pass the <code class="docutils literal notranslate"><span class="pre">CommandLineOption</span></code>
strings along to the candidate and fit plugins respectively.</p>
</section>
<section id="hole-fit-plugin-example">
<h4><span class="section-number">7.3.6.2. </span>Hole fit plugin example<a class="headerlink" href="#hole-fit-plugin-example" title="Permalink to this heading">¶</a></h4>
<p>The following plugins allows users to limit the search for valid hole fits to
certain modules, to sort the hole fits by where they originated (in ascending or
descending order), as well as allowing users to put a limit on how much time is
spent on searching for valid hole fits, after which new searches are aborted.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE TypeApplications, RecordWildCards #-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">HolePlugin</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Plugins</span><span class="w"> </span><span class="k">hiding</span><span class="w"> </span><span class="p">((</span><span class="o">&lt;&gt;</span><span class="p">))</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Tc.Errors.Hole</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Data.List</span><span class="w"> </span><span class="p">(</span><span class="nf">stripPrefix</span><span class="p">,</span><span class="w"> </span><span class="nf">sortOn</span><span class="p">)</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Tc.Types</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Tc.Utils.Monad</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Data.Time</span><span class="w"> </span><span class="p">(</span><span class="kt">UTCTime</span><span class="p">,</span><span class="w"> </span><span class="kt">NominalDiffTime</span><span class="p">)</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="k">qualified</span><span class="w"> </span><span class="nn">Data.Time</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Time</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Text.Read</span><span class="w"></span>


<span class="kr">data</span><span class="w"> </span><span class="kt">HolePluginState</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">HPS</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">timeAlloted</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">NominalDiffTime</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="n">elapsedTime</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">NominalDiffTime</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="n">timeCurStarted</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">UTCTime</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="nf">bumpElapsed</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">NominalDiffTime</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HolePluginState</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HolePluginState</span><span class="w"></span>
<span class="nf">bumpElapsed</span><span class="w"> </span><span class="n">ad</span><span class="w"> </span><span class="p">(</span><span class="kt">HPS</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">HPS</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ad</span><span class="p">)</span><span class="w"> </span><span class="n">t</span><span class="w"></span>

<span class="nf">setAlloted</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">NominalDiffTime</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HolePluginState</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HolePluginState</span><span class="w"></span>
<span class="nf">setAlloted</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">HPS</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">HPS</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">t</span><span class="w"></span>

<span class="nf">setCurStarted</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">UTCTime</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HolePluginState</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HolePluginState</span><span class="w"></span>
<span class="nf">setCurStarted</span><span class="w"> </span><span class="n">nt</span><span class="w"> </span><span class="p">(</span><span class="kt">HPS</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">HPS</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">nt</span><span class="w"></span>

<span class="nf">hpStartState</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">HolePluginState</span><span class="w"></span>
<span class="nf">hpStartState</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">HPS</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="n">undefined</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fromInteger</span><span class="w"> </span><span class="o">@</span><span class="kt">NominalDiffTime</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="nf">initPlugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcM</span><span class="w"> </span><span class="p">(</span><span class="kt">TcRef</span><span class="w"> </span><span class="kt">HolePluginState</span><span class="p">)</span><span class="w"></span>
<span class="nf">initPlugin</span><span class="w"> </span><span class="p">[</span><span class="n">msecs</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newTcRef</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">hpStartState</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">timeAlloted</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">alloted</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">errMsg</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Invalid amount of milliseconds given to plugin: &quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">msecs</span><span class="w"></span>
<span class="w">    </span><span class="n">alloted</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">readMaybe</span><span class="w"> </span><span class="o">@</span><span class="kt">Integer</span><span class="w"> </span><span class="n">msecs</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">      </span><span class="kt">Just</span><span class="w"> </span><span class="n">millisecs</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">fromInteger</span><span class="w"> </span><span class="o">@</span><span class="kt">NominalDiffTime</span><span class="w"> </span><span class="n">millisecs</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"></span>
<span class="w">      </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="n">errMsg</span><span class="w"></span>
<span class="nf">initPlugin</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newTcRef</span><span class="w"> </span><span class="n">hpStartState</span><span class="w"></span>

<span class="nf">fromModule</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">HoleFitCandidate</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w"></span>
<span class="nf">fromModule</span><span class="w"> </span><span class="p">(</span><span class="kt">GreHFCand</span><span class="w"> </span><span class="n">gre</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="n">moduleNameString</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">importSpecModule</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">gre_imp</span><span class="w"> </span><span class="n">gre</span><span class="w"></span>
<span class="nf">fromModule</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>

<span class="nf">toHoleFitCommand</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TypedHole</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">toHoleFitCommand</span><span class="w"> </span><span class="kt">TyH</span><span class="p">{</span><span class="n">tyHCt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="kt">CHoleCan</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">h</span><span class="p">)}</span><span class="w"> </span><span class="n">str</span><span class="w"></span>
<span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="n">stripPrefix</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">occNameString</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">holeOcc</span><span class="w"> </span><span class="n">h</span><span class="w"></span>
<span class="nf">toHoleFitCommand</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"></span>

<span class="c1">-- | This candidate plugin filters the candidates by module,</span><span class="w"></span>
<span class="c1">-- using the name of the hole as module to search in</span><span class="w"></span>
<span class="nf">modFilterTimeoutP</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcRef</span><span class="w"> </span><span class="kt">HolePluginState</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CandPlugin</span><span class="w"></span>
<span class="nf">modFilterTimeoutP</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="n">hole</span><span class="w"> </span><span class="n">cands</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">curTime</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">liftIO</span><span class="w"> </span><span class="kt">Time</span><span class="o">.</span><span class="n">getCurrentTime</span><span class="w"></span>
<span class="w">  </span><span class="kt">HPS</span><span class="w"> </span><span class="p">{</span><span class="o">..</span><span class="p">}</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">readTcRef</span><span class="w"> </span><span class="n">ref</span><span class="w"></span>
<span class="w">  </span><span class="n">updTcRef</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="p">(</span><span class="n">setCurStarted</span><span class="w"> </span><span class="n">curTime</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">timeAlloted</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- If we&#39;re out of time we remove all the candidates. Then nothing is checked.</span><span class="w"></span>
<span class="w">    </span><span class="kt">Just</span><span class="w"> </span><span class="n">sofar</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">elapsedTime</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sofar</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="w">    </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">toHoleFitCommand</span><span class="w"> </span><span class="n">hole</span><span class="w"> </span><span class="s">&quot;only_&quot;</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>

<span class="w">          </span><span class="kt">Just</span><span class="w"> </span><span class="n">modName</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="n">inScopeVia</span><span class="w"> </span><span class="n">modName</span><span class="p">)</span><span class="w"> </span><span class="n">cands</span><span class="w"></span>
<span class="w">          </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">cands</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="n">inScopeVia</span><span class="w"> </span><span class="n">modNameStr</span><span class="w"> </span><span class="n">cand</span><span class="o">@</span><span class="p">(</span><span class="kt">GreHFCand</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">          </span><span class="n">elem</span><span class="w"> </span><span class="p">(</span><span class="n">toModName</span><span class="w"> </span><span class="n">modNameStr</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">fromModule</span><span class="w"> </span><span class="n">cand</span><span class="w"></span>
<span class="w">        </span><span class="n">inScopeVia</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
<span class="w">        </span><span class="n">toModName</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">replace</span><span class="w"> </span><span class="sc">&#39;_&#39;</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="w"></span>
<span class="w">        </span><span class="n">replace</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="n">replace</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="w">        </span><span class="n">replace</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="kt">:</span><span class="n">replace</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>

<span class="nf">modSortP</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TcRef</span><span class="w"> </span><span class="kt">HolePluginState</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">FitPlugin</span><span class="w"></span>
<span class="nf">modSortP</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="n">hole</span><span class="w"> </span><span class="n">hfs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">curTime</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">liftIO</span><span class="w"> </span><span class="kt">Time</span><span class="o">.</span><span class="n">getCurrentTime</span><span class="w"></span>
<span class="w">  </span><span class="kt">HPS</span><span class="w"> </span><span class="p">{</span><span class="o">..</span><span class="p">}</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">readTcRef</span><span class="w"> </span><span class="n">ref</span><span class="w"></span>
<span class="w">  </span><span class="n">updTcRef</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">bumpElapsed</span><span class="w"> </span><span class="p">(</span><span class="kt">Time</span><span class="o">.</span><span class="n">diffUTCTime</span><span class="w"> </span><span class="n">curTime</span><span class="w"> </span><span class="n">timeCurStarted</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">timeAlloted</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- If we&#39;re out of time, remove any candidates, so nothing is checked.</span><span class="w"></span>
<span class="w">    </span><span class="kt">Just</span><span class="w"> </span><span class="n">sofar</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">elapsedTime</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sofar</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">RawHoleFit</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="n">msg</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">toHoleFitCommand</span><span class="w"> </span><span class="n">hole</span><span class="w"> </span><span class="s">&quot;sort_by_mod&quot;</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">            </span><span class="c1">-- If only_ is on, the fits will all be from the same module.</span><span class="w"></span>
<span class="w">            </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;_&#39;</span><span class="kt">:</span><span class="sc">&#39;d&#39;</span><span class="kt">:</span><span class="sc">&#39;e&#39;</span><span class="kt">:</span><span class="sc">&#39;s&#39;</span><span class="kt">:</span><span class="sc">&#39;c&#39;</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">reverse</span><span class="w"> </span><span class="n">hfs</span><span class="w"></span>
<span class="w">            </span><span class="kt">Just</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">orderByModule</span><span class="w"> </span><span class="n">hfs</span><span class="w"></span>
<span class="w">            </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w">  </span><span class="n">hfs</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="n">orderByModule</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">HoleFit</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">HoleFit</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="n">orderByModule</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sortOn</span><span class="w"> </span><span class="p">(</span><span class="n">fmap</span><span class="w"> </span><span class="n">fromModule</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">mbHFCand</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">mbHFCand</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">HoleFit</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">HoleFitCandidate</span><span class="w"></span>
<span class="w">        </span><span class="n">mbHFCand</span><span class="w"> </span><span class="kt">HoleFit</span><span class="w"> </span><span class="p">{</span><span class="n">hfCand</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">c</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="w">        </span><span class="n">mbHFCand</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"></span>
<span class="w">        </span><span class="n">msg</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">hang</span><span class="w"> </span><span class="p">(</span><span class="n">text</span><span class="w"> </span><span class="s">&quot;Error: The time ran out, and the search was aborted for this hole.&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">               </span><span class="mi">7</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="s">&quot;Try again with a longer timeout.&quot;</span><span class="w"></span>

<span class="nf">plugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Plugin</span><span class="w"></span>
<span class="nf">plugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">defaultPlugin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">holeFitPlugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">holeFitP</span><span class="p">,</span><span class="w"> </span><span class="n">pluginRecompile</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">purePlugin</span><span class="p">}</span><span class="w"></span>

<span class="nf">holeFitP</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">HoleFitPluginR</span><span class="w"></span>
<span class="nf">holeFitP</span><span class="w"> </span><span class="n">opts</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="kt">HoleFitPluginR</span><span class="w"> </span><span class="n">initP</span><span class="w"> </span><span class="n">pluginDef</span><span class="w"> </span><span class="n">stopP</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="n">initP</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">initPlugin</span><span class="w"> </span><span class="n">opts</span><span class="w"></span>
<span class="w">        </span><span class="n">stopP</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">        </span><span class="n">pluginDef</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">HoleFitPlugin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">candPlugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">modFilterTimeoutP</span><span class="w"> </span><span class="n">opts</span><span class="w"> </span><span class="n">ref</span><span class="w"></span>
<span class="w">                                      </span><span class="p">,</span><span class="w"> </span><span class="n">fitPlugin</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">modSortP</span><span class="w"> </span><span class="n">opts</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>When you then compile a module containing the following</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# OPTIONS -fplugin=HolePlugin</span>
<span class="cm">            -fplugin-opt=HolePlugin:600</span>
<span class="cm">            -funclutter-valid-hole-fits #-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">Main</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Prelude</span><span class="w"> </span><span class="k">hiding</span><span class="w"> </span><span class="p">(</span><span class="nf">head</span><span class="p">,</span><span class="w"> </span><span class="nf">last</span><span class="p">)</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Data.List</span><span class="w"> </span><span class="p">(</span><span class="nf">head</span><span class="p">,</span><span class="w"> </span><span class="nf">last</span><span class="p">)</span><span class="w"></span>


<span class="nf">f</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">_too_long</span><span class="w"></span>
<span class="nf">j</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">_</span><span class="w"></span>
<span class="nf">i</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">_sort_by_mod_desc</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">_only_Data_List</span><span class="w"></span>
<span class="nf">h</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">_only_Prelude</span><span class="w"></span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
</pre></div>
</div>
<p>The output is as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Main.hs:12:5: error:
    • Found hole: _too_long :: [Int] -&gt; Int
      Or perhaps ‘_too_long’ is mis-spelled, or not in scope
    • In the expression: _too_long
      In an equation for ‘f’: f = _too_long
    • Relevant bindings include
        f :: [Int] -&gt; Int (bound at Main.hs:12:1)
      Valid hole fits include
        Error: The time ran out, and the search was aborted for this hole.
               Try again with a longer timeout.
  |
12 | f = _too_long
  |     ^^^^^^^^^

Main.hs:13:5: error:
    • Found hole: _ :: [Int] -&gt; Int
    • In the expression: _
      In an equation for ‘j’: j = _
    • Relevant bindings include
        j :: [Int] -&gt; Int (bound at Main.hs:13:1)
      Valid hole fits include
        j :: [Int] -&gt; Int
        f :: [Int] -&gt; Int
        g :: [Int] -&gt; Int
        h :: [Int] -&gt; Int
        i :: [Int] -&gt; Int
        head :: forall a. [a] -&gt; a
        (Some hole fits suppressed; use -fmax-valid-hole-fits=N or -fno-max-valid-hole-fits)
  |
13 | j = _
  |     ^

Main.hs:14:5: error:
    • Found hole: _sort_by_mod_desc :: [Int] -&gt; Int
      Or perhaps ‘_sort_by_mod_desc’ is mis-spelled, or not in scope
    • In the expression: _sort_by_mod_desc
      In an equation for ‘i’: i = _sort_by_mod_desc
    • Relevant bindings include
        i :: [Int] -&gt; Int (bound at Main.hs:14:1)
      Valid hole fits include
        sum :: forall (t :: * -&gt; *) a. (Foldable t, Num a) =&gt; t a -&gt; a
        product :: forall (t :: * -&gt; *) a. (Foldable t, Num a) =&gt; t a -&gt; a
        minimum :: forall (t :: * -&gt; *) a. (Foldable t, Ord a) =&gt; t a -&gt; a
        maximum :: forall (t :: * -&gt; *) a. (Foldable t, Ord a) =&gt; t a -&gt; a
        length :: forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
        last :: forall a. [a] -&gt; a
        (Some hole fits suppressed; use -fmax-valid-hole-fits=N or -fno-max-valid-hole-fits)
  |
14 | i = _sort_by_mod_desc
  |     ^^^^^^^^^^^^^^^^^

Main.hs:15:5: error:
    • Found hole: _only_Data_List :: [Int] -&gt; Int
      Or perhaps ‘_only_Data_List’ is mis-spelled, or not in scope
    • In the expression: _only_Data_List
      In an equation for ‘g’: g = _only_Data_List
    • Relevant bindings include
        g :: [Int] -&gt; Int (bound at Main.hs:15:1)
      Valid hole fits include
        head :: forall a. [a] -&gt; a
        last :: forall a. [a] -&gt; a
  |
15 | g = _only_Data_List
  |     ^^^^^^^^^^^^^^^

Main.hs:16:5: error:
    • Found hole: _only_Prelude :: [Int] -&gt; Int
      Or perhaps ‘_only_Prelude’ is mis-spelled, or not in scope
    • In the expression: _only_Prelude
      In an equation for ‘h’: h = _only_Prelude
    • Relevant bindings include
        h :: [Int] -&gt; Int (bound at Main.hs:16:1)
      Valid hole fits include
        length :: forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
        maximum :: forall (t :: * -&gt; *) a. (Foldable t, Ord a) =&gt; t a -&gt; a
        minimum :: forall (t :: * -&gt; *) a. (Foldable t, Ord a) =&gt; t a -&gt; a
        product :: forall (t :: * -&gt; *) a. (Foldable t, Num a) =&gt; t a -&gt; a
        sum :: forall (t :: * -&gt; *) a. (Foldable t, Num a) =&gt; t a -&gt; a
  |
16 | h = _only_Prelude
  |     ^^^^^^^^^^^^^
</pre></div>
</div>
</section>
</section>
<section id="controlling-recompilation">
<span id="plugin-recompilation"></span><h3><span class="section-number">7.3.7. </span>Controlling Recompilation<a class="headerlink" href="#controlling-recompilation" title="Permalink to this heading">¶</a></h3>
<p>By default, modules compiled with plugins are always recompiled even if the source file is
unchanged. This most conservative option is taken due to the ability of plugins
to perform arbitrary IO actions. In order to control the recompilation behaviour
you can modify the <code class="docutils literal notranslate"><span class="pre">pluginRecompile</span></code> field in <code class="docutils literal notranslate"><span class="pre">Plugin</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">plugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Plugin</span><span class="w"></span>
<span class="nf">plugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">defaultPlugin</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">installCoreToDos</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">install</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">pluginRecompile</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">purePlugin</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>By inspecting the example <code class="docutils literal notranslate"><span class="pre">plugin</span></code> defined above, we can see that it is pure. This
means that if the two modules have the same fingerprint then the plugin
will always return the same result. Declaring a plugin as pure means that
the plugin will never cause a module to be recompiled.</p>
<p>In general, the <code class="docutils literal notranslate"><span class="pre">pluginRecompile</span></code> field has the following type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pluginRecompile</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">PluginRecompile</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">PluginRecompile</span></code> data type is an enumeration determining how the plugin
should affect recompilation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">PluginRecompile</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">ForceRecompile</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">NoForceRecompile</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">MaybeRecompile</span><span class="w"> </span><span class="kt">Fingerprint</span><span class="w"></span>
</pre></div>
</div>
<p>A plugin which declares itself impure using <code class="docutils literal notranslate"><span class="pre">ForceRecompile</span></code> will always
trigger a recompilation of the current module. <code class="docutils literal notranslate"><span class="pre">NoForceRecompile</span></code> is used
for “pure” plugins which don’t need to be rerun unless a module would ordinarily
be recompiled. <code class="docutils literal notranslate"><span class="pre">MaybeRecompile</span></code> computes a <code class="docutils literal notranslate"><span class="pre">Fingerprint</span></code> and if this <code class="docutils literal notranslate"><span class="pre">Fingerprint</span></code>
is different to a previously computed <code class="docutils literal notranslate"><span class="pre">Fingerprint</span></code> for the plugin, then
we recompile the module.</p>
<p>As such, <code class="docutils literal notranslate"><span class="pre">purePlugin</span></code> is defined as a function which always returns <code class="docutils literal notranslate"><span class="pre">NoForceRecompile</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">purePlugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">PluginRecompile</span><span class="w"></span>
<span class="nf">purePlugin</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="kt">NoForceRecompile</span><span class="w"></span>
</pre></div>
</div>
<p>Users can use the same functions that GHC uses internally to compute fingerprints.
The <a class="reference external" href="https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html">GHC.Fingerprint</a> module provides useful functions for constructing fingerprints. For example, combining
together <code class="docutils literal notranslate"><span class="pre">fingerprintFingerprints</span></code> and <code class="docutils literal notranslate"><span class="pre">fingerprintString</span></code> provides an easy to
to naively fingerprint the arguments to a plugin.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pluginFlagRecompile</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">PluginRecompile</span><span class="w"></span>
<span class="nf">pluginFlagRecompile</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="kt">MaybeRecompile</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">fingerprintFingerprints</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">fingerprintString</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">sort</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">defaultPlugin</span></code> defines <code class="docutils literal notranslate"><span class="pre">pluginRecompile</span></code> to be <code class="docutils literal notranslate"><span class="pre">impurePlugin</span></code> which
is the most conservative and backwards compatible option.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">impurePlugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">PluginRecompile</span><span class="w"></span>
<span class="nf">impurePlugin</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="kt">ForceRecompile</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="frontend-plugins">
<span id="id10"></span><h3><span class="section-number">7.3.8. </span>Frontend plugins<a class="headerlink" href="#frontend-plugins" title="Permalink to this heading">¶</a></h3>
<p>A frontend plugin allows you to add new major modes to GHC.  You may prefer
this over a traditional program which calls the GHC API, as GHC manages a lot
of parsing flags and administrative nonsense which can be difficult to
manage manually.  To load a frontend plugin exported by <code class="docutils literal notranslate"><span class="pre">Foo.FrontendPlugin</span></code>,
we just invoke GHC with the <a class="reference internal" href="using.html#ghc-flag-frontend-module"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">--frontend</span> <span class="pre">⟨module⟩</span></code></a> flag as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ghc --frontend Foo.FrontendPlugin ...other options...
</pre></div>
</div>
<p>Frontend plugins, like compiler plugins, are exported by registered plugins.
However, unlike compiler modules, frontend plugins are modules that export
at least a single identifier <code class="docutils literal notranslate"><span class="pre">frontendPlugin</span></code> of type
<code class="docutils literal notranslate"><span class="pre">GHC.Plugins.FrontendPlugin</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">FrontendPlugin</span></code> exports a field <code class="docutils literal notranslate"><span class="pre">frontend</span></code>, which is a function
<code class="docutils literal notranslate"><span class="pre">[String]</span> <span class="pre">-&gt;</span> <span class="pre">[(String,</span> <span class="pre">Maybe</span> <span class="pre">Phase)]</span> <span class="pre">-&gt;</span> <span class="pre">Ghc</span> <span class="pre">()</span></code>.  The first argument
is a list of extra flags passed to the frontend with <code class="docutils literal notranslate"><span class="pre">-ffrontend-opt</span></code>;
the second argument is the list of arguments, usually source files
and module names to be compiled (the <code class="docutils literal notranslate"><span class="pre">Phase</span></code> indicates if an <code class="docutils literal notranslate"><span class="pre">-x</span></code>
flag was set), and a frontend simply executes some operation in the
<code class="docutils literal notranslate"><span class="pre">Ghc</span></code> monad (which, among other things, has a <code class="docutils literal notranslate"><span class="pre">Session</span></code>).</p>
<p>As a quick example, here is a frontend plugin that prints the arguments that
were passed to it, and then exits.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">DoNothing.FrontendPlugin</span><span class="w"> </span><span class="p">(</span><span class="nf">frontendPlugin</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Plugins</span><span class="w"></span>

<span class="nf">frontendPlugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FrontendPlugin</span><span class="w"></span>
<span class="nf">frontendPlugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">defaultFrontendPlugin</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">frontend</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">doNothing</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="nf">doNothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[(</span><span class="kt">String</span><span class="p">,</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Phase</span><span class="p">)]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Ghc</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">doNothing</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">liftIO</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">flags</span><span class="w"></span>
<span class="w">    </span><span class="n">liftIO</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">args</span><span class="w"></span>
</pre></div>
</div>
<p>Provided you have compiled this plugin and registered it in a package,
you can just use it by specifying <code class="docutils literal notranslate"><span class="pre">--frontend</span> <span class="pre">DoNothing.FrontendPlugin</span></code>
on the command line to GHC.</p>
</section>
<section id="dynflags-plugins">
<span id="id11"></span><h3><span class="section-number">7.3.9. </span>DynFlags plugins<a class="headerlink" href="#dynflags-plugins" title="Permalink to this heading">¶</a></h3>
<p>A DynFlags plugin allows you to modify the <code class="docutils literal notranslate"><span class="pre">DynFlags</span></code> that GHC
is going to use when processing a given (set of) file(s).
<code class="docutils literal notranslate"><span class="pre">DynFlags</span></code> is a record containing all sorts of configuration
and command line data, from verbosity level to the integer library
to use, including compiler hooks, plugins and pretty-printing options.
DynFlags plugins allow plugin authors to update any of those values
before GHC starts doing any actual work, effectively meaning that
the updates specified by the plugin will be taken into account and
influence GHC’s behaviour.</p>
<p>One of the motivating examples was the ability to register
compiler hooks from a plugin. For example, one might want to modify
the way Template Haskell code is executed. This is achievable by
updating the <code class="docutils literal notranslate"><span class="pre">hooks</span></code> field of the <code class="docutils literal notranslate"><span class="pre">DynFlags</span></code> type, recording
our custom “meta hook” in the right place. A simple application of
this idea can be seen below:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">DynFlagsPlugin</span><span class="w"> </span><span class="p">(</span><span class="nf">plugin</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">BasicTypes</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Plugins</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Hs.Expr</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Language.Haskell.Syntax.Extension</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Hs.Lit</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Hooks</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Tc.Utils.Monad</span><span class="w"></span>

<span class="nf">plugin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Plugin</span><span class="w"></span>
<span class="nf">plugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">driverPlugin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">driverPlugin</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">hooksP</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="nf">hooksP</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HscEnv</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">HscEnv</span><span class="w"></span>
<span class="nf">hooksP</span><span class="w"> </span><span class="n">opts</span><span class="w"> </span><span class="n">hsc_env</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">dflags</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">hsc_dflags</span><span class="w"> </span><span class="n">hsc_env</span><span class="w"></span>
<span class="w">        </span><span class="n">dflags&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">dflags</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="n">hooks</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">hooks</span><span class="w"> </span><span class="n">dflags</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">{</span><span class="w"> </span><span class="n">runMetaHook</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="n">fakeRunMeta</span><span class="w"> </span><span class="n">opts</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">hsc_env&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">hsc_env</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">hsc_dflags</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">dflags&#39;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">return</span><span class="w"> </span><span class="n">hsc_env&#39;</span><span class="w"></span>

<span class="c1">-- This meta hook doesn&#39;t actually care running code in splices,</span><span class="w"></span>
<span class="c1">-- it just replaces any expression splice with the &quot;0&quot;</span><span class="w"></span>
<span class="c1">-- integer literal, and errors out on all other types of</span><span class="w"></span>
<span class="c1">-- meta requests.</span><span class="w"></span>
<span class="nf">fakeRunMeta</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">CommandLineOption</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">MetaHook</span><span class="w"> </span><span class="kt">TcM</span><span class="w"></span>
<span class="nf">fakeRunMeta</span><span class="w"> </span><span class="n">opts</span><span class="w"> </span><span class="p">(</span><span class="kt">MetaE</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">liftIO</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Options = &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">opts</span><span class="w"></span>
<span class="w">  </span><span class="n">pure</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">zero</span><span class="w"></span>

<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">LHsExpr</span><span class="w"> </span><span class="kt">GhcPs</span><span class="w"></span>
<span class="w">        </span><span class="n">zero</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">L</span><span class="w"> </span><span class="n">noSrcSpan</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">HsLit</span><span class="w"> </span><span class="kt">NoExtField</span><span class="w"> </span><span class="o">$</span><span class="w"></span>
<span class="w">          </span><span class="kt">HsInt</span><span class="w"> </span><span class="kt">NoExtField</span><span class="w"> </span><span class="p">(</span><span class="n">mkIntegralLit</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="p">))</span><span class="w"></span>

<span class="nf">fakeRunMeta</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">&quot;fakeRunMeta: unimplemented&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>This simple plugin takes over the execution of Template Haskell code,
replacing any expression splice it encounters by <code class="docutils literal notranslate"><span class="pre">0</span></code> (at type
<code class="docutils literal notranslate"><span class="pre">Int</span></code>), and errors out on any other type of splice.</p>
<p>Therefore, if we run GHC against the following code using the plugin
from above:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# OPTIONS -fplugin=DynFlagsPlugin #-}</span><span class="w"></span>
<span class="cm">{-# LANGUAGE TemplateHaskell #-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">Main</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="o">|</span><span class="mi">1</span><span class="o">|</span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This will not actually evaluate <code class="docutils literal notranslate"><span class="pre">[|1|]</span></code>, but instead replace it
with the <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">::</span> <span class="pre">Int</span></code> literal.</p>
<p>Just like the other types of plugins, you can write <code class="docutils literal notranslate"><span class="pre">DynFlags</span></code> plugins
that can take and make use of some options that you can then specify
using the <code class="docutils literal notranslate"><span class="pre">-fplugin-opt</span></code> flag. In the <code class="docutils literal notranslate"><span class="pre">DynFlagsPlugin</span></code> code from
above, the said options would be available in the <code class="docutils literal notranslate"><span class="pre">opts</span></code> argument of
<code class="docutils literal notranslate"><span class="pre">hooksP</span></code>.</p>
<p>Finally, since those <code class="docutils literal notranslate"><span class="pre">DynFlags</span></code> updates happen after the plugins are loaded,
you cannot from a <code class="docutils literal notranslate"><span class="pre">DynFlags</span></code> plugin register other plugins by just adding them
to the <code class="docutils literal notranslate"><span class="pre">plugins</span></code> field of <code class="docutils literal notranslate"><span class="pre">DynFlags</span></code>. In order to achieve this, you would
have to load them yourself and store the result into the <code class="docutils literal notranslate"><span class="pre">cachedPlugins</span></code>
field of <code class="docutils literal notranslate"><span class="pre">DynFlags</span></code>.</p>
</section>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="profiling.html" class="btn btn-neutral float-right" title="8. Profiling" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="exts/pragmas.html" class="btn btn-neutral float-left" title="6.20. Pragmas" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
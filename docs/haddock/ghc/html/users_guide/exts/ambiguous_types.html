

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.11.2. Ambiguous types and the ambiguity check &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.11.3. Explicitly-kinded quantification" href="kind_signatures.html" />
    <link rel="prev" title="6.11.1. Explicit universal quantification (forall)" href="explicit_forall.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="explicit_forall.html">6.11.1. Explicit universal quantification (forall)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.11.2. Ambiguous types and the ambiguity check</a></li>
<li class="toctree-l3"><a class="reference internal" href="kind_signatures.html">6.11.3. Explicitly-kinded quantification</a></li>
<li class="toctree-l3"><a class="reference internal" href="scoped_type_variables.html">6.11.4. Lexically scoped type variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="implicit_parameters.html">6.11.5. Implicit parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="partial_type_signatures.html">6.11.6. Partial Type Signatures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="type_signatures.html"><span class="section-number">6.11. </span>Type signatures</a> &raquo;</li>
        
      <li><span class="section-number">6.11.2. </span>Ambiguous types and the ambiguity check</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/ambiguous_types.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="ambiguous-types-and-the-ambiguity-check">
<span id="ambiguity"></span><h1><span class="section-number">6.11.2. </span>Ambiguous types and the ambiguity check<a class="headerlink" href="#ambiguous-types-and-the-ambiguity-check" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-AllowAmbiguousTypes">
<span id="ghc-flag--XAllowAmbiguousTypes"></span><span id="extension-NoAllowAmbiguousTypes"></span><span class="sig-name descname"><span class="pre">AllowAmbiguousTypes</span></span><a class="headerlink" href="#extension-AllowAmbiguousTypes" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.8.1</p>
</dd>
</dl>
<p>Allow type signatures which appear that they would result in
an unusable binding.</p>
</dd></dl>

<p>Each user-written type signature is subjected to an <em>ambiguity check</em>.
The ambiguity check rejects functions that can never be called. For
example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>The idea is there can be no legal calls to <code class="docutils literal notranslate"><span class="pre">f</span></code> because every call will
give rise to an ambiguous constraint. Indeed, the <em>only</em> purpose of the
ambiguity check is to report functions that cannot possibly be called.
We could soundly omit the ambiguity check on type signatures entirely,
at the expense of delaying ambiguity errors to call sites. Indeed, the
language extension <a class="reference internal" href="#extension-AllowAmbiguousTypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">AllowAmbiguousTypes</span></code></a> switches off the ambiguity
check.</p>
<p>Ambiguity can be subtle. Consider this example which uses functional
dependencies:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">..</span><span class="w"></span>
<span class="nf">h</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Int</span></code> may well fix <code class="docutils literal notranslate"><span class="pre">b</span></code> at the call site, so that signature
should not be rejected. Moreover, the dependencies might be hidden.
Consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="o">...</span><span class="w"></span>
<span class="nf">h</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">h</span></code>'s type looks ambiguous in <code class="docutils literal notranslate"><span class="pre">b</span></code>, but here’s a legal call:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">...</span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="p">[</span><span class="kt">True</span><span class="p">])</span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>That gives rise to a <code class="docutils literal notranslate"><span class="pre">(X</span> <span class="pre">[Bool]</span> <span class="pre">beta)</span></code> constraint, and using the
instance means we need <code class="docutils literal notranslate"><span class="pre">(D</span> <span class="pre">Bool</span> <span class="pre">beta)</span></code> and that fixes <code class="docutils literal notranslate"><span class="pre">beta</span></code> via
<code class="docutils literal notranslate"><span class="pre">D</span></code>'s fundep!</p>
<p>Behind all these special cases there is a simple guiding principle.
Consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kr">type</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="n">blah</span><span class="o">...</span><span class="w"></span>

<span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kr">type</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"></span>
</pre></div>
</div>
<p>You would think that the definition of <code class="docutils literal notranslate"><span class="pre">g</span></code> would surely typecheck!
After all <code class="docutils literal notranslate"><span class="pre">f</span></code> has exactly the same type, and <code class="docutils literal notranslate"><span class="pre">g=f</span></code>. But in fact
<code class="docutils literal notranslate"><span class="pre">f</span></code>'s type is instantiated and the instantiated constraints are solved
against the constraints bound by <code class="docutils literal notranslate"><span class="pre">g</span></code>‘s signature. So, in the case an
ambiguous type, solving will fail. For example, consider the earlier
definition <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">::</span> <span class="pre">C</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Int</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="n">blah</span><span class="o">...</span><span class="w"></span>

<span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"></span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">g</span></code>'s definition, we’ll instantiate to <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">alpha)</span></code> and try to
deduce <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">alpha)</span></code> from <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">a)</span></code>, and fail.</p>
<p>So in fact we use this as our <em>definition</em> of ambiguity: a type <code class="docutils literal notranslate"><span class="pre">ty</span></code>
is ambiguous if and only if <code class="docutils literal notranslate"><span class="pre">((undefined</span> <span class="pre">::</span> <span class="pre">ty)</span> <span class="pre">::</span> <span class="pre">ty)</span></code> would fail to
typecheck. We use a very similar test for <em>inferred</em> types, to ensure
that they too are unambiguous.</p>
<p><em>Switching off the ambiguity check.</em> Even if a function has an
ambiguous type according to the “guiding principle”, it is possible that
the function is callable. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="nf">strange</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">strange</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="n">blah</span><span class="o">...</span><span class="w"></span>

<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">strange</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">strange</span></code>'s type is ambiguous, but the call in <code class="docutils literal notranslate"><span class="pre">foo</span></code> is OK
because it gives rise to a constraint <code class="docutils literal notranslate"><span class="pre">(D</span> <span class="pre">Bool</span> <span class="pre">beta)</span></code>, which is
soluble by the <code class="docutils literal notranslate"><span class="pre">(D</span> <span class="pre">Bool</span> <span class="pre">b)</span></code> instance.</p>
<p>Another way of getting rid of the ambiguity at the call site is to use
the <a class="reference internal" href="type_applications.html#extension-TypeApplications"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TypeApplications</span></code></a> extension to specify the types. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">h</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">@</span><span class="kt">Int</span><span class="w"> </span><span class="o">@</span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">a</span></code> is ambiguous in the definition of <code class="docutils literal notranslate"><span class="pre">D</span></code> but later specified
to be <cite>Int</cite> using type applications.</p>
<p><a class="reference internal" href="#extension-AllowAmbiguousTypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">AllowAmbiguousTypes</span></code></a> allows you to switch off the ambiguity check.
However, even with ambiguity checking switched off, GHC will complain about a
function that can <em>never</em> be called, such as this one:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>Sometimes <a class="reference internal" href="#extension-AllowAmbiguousTypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">AllowAmbiguousTypes</span></code></a> does not mix well with <a class="reference internal" href="rank_polymorphism.html#extension-RankNTypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">RankNTypes</span></code></a>.
For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">r</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="kt">KnownNat</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">r</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">@</span><span class="mi">1</span><span class="w"></span>

<span class="nf">boo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">j</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="kt">KnownNat</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">boo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">....</span><span class="w"></span>

<span class="nf">h</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">h</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">boo</span><span class="w"></span>
</pre></div>
</div>
<p>This program will be rejected as ambiguous because GHC will not unify
the type variables <cite>j</cite> and <cite>i</cite>.</p>
<p>Unlike the previous examples, it is not currently possible
to resolve the ambiguity manually by using <a class="reference internal" href="type_applications.html#extension-TypeApplications"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TypeApplications</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>A historical note.</em> GHC used to impose some more restrictive and less
principled conditions on type signatures. For type
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">tv1..tvn</span> <span class="pre">(c1,</span> <span class="pre">...,cn)</span> <span class="pre">=&gt;</span> <span class="pre">type</span></code> GHC used to require</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>that each universally quantified type variable <code class="docutils literal notranslate"><span class="pre">tvi</span></code> must be “reachable”
from <code class="docutils literal notranslate"><span class="pre">type</span></code>, and</p></li>
<li><p>that every constraint <code class="docutils literal notranslate"><span class="pre">ci</span></code> mentions at least one of the universally
quantified type variables <code class="docutils literal notranslate"><span class="pre">tvi</span></code>. These ad-hoc restrictions are
completely subsumed by the new ambiguity check.</p></li>
</ol>
</div></blockquote>
</div>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="kind_signatures.html" class="btn btn-neutral float-right" title="6.11.3. Explicitly-kinded quantification" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="explicit_forall.html" class="btn btn-neutral float-left" title="6.11.1. Explicit universal quantification (forall)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
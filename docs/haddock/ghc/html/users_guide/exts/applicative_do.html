

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.2.4. Applicative do-notation &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.2.5. Qualified do-notation" href="qualified_do.html" />
    <link rel="prev" title="6.2.3. The recursive do-notation" href="recursive_do.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="syntax.html">6.2. Syntax</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="unicode_syntax.html">6.2.1. Unicode syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="magic_hash.html">6.2.2. The magic hash</a></li>
<li class="toctree-l3"><a class="reference internal" href="recursive_do.html">6.2.3. The recursive do-notation</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.2.4. Applicative do-notation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#strict-patterns">6.2.4.1. Strict patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#things-to-watch-out-for">6.2.4.2. Things to watch out for</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="qualified_do.html">6.2.5. Qualified do-notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="parallel_list_comprehensions.html">6.2.6. Parallel List Comprehensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="generalised_list_comprehensions.html">6.2.7. Generalised (SQL-like) List Comprehensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="monad_comprehensions.html">6.2.8. Monad comprehensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="overloaded_lists.html">6.2.9. Overloaded lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="rebindable_syntax.html">6.2.10. Rebindable syntax and the implicit Prelude import</a></li>
<li class="toctree-l3"><a class="reference internal" href="rebindable_syntax.html#postfix-operators">6.2.11. Postfix operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="tuple_sections.html">6.2.12. Tuple sections</a></li>
<li class="toctree-l3"><a class="reference internal" href="lambda_case.html">6.2.13. Lambda-case</a></li>
<li class="toctree-l3"><a class="reference internal" href="empty_case.html">6.2.14. Empty case alternatives</a></li>
<li class="toctree-l3"><a class="reference internal" href="multiway_if.html">6.2.15. Multi-way if-expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="local_fixity_decls.html">6.2.16. Local Fixity Declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="block_arguments.html">6.2.17. More liberal syntax for function arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="typed_holes.html">6.2.18. Typed Holes</a></li>
<li class="toctree-l3"><a class="reference internal" href="arrows.html">6.2.19. Arrow notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="lexical_negation.html">6.2.20. Lexical negation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="syntax.html"><span class="section-number">6.2. </span>Syntax</a> &raquo;</li>
        
      <li><span class="section-number">6.2.4. </span>Applicative do-notation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/applicative_do.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="applicative-do-notation">
<span id="applicative-do"></span><h1><span class="section-number">6.2.4. </span>Applicative do-notation<a class="headerlink" href="#applicative-do-notation" title="Permalink to this heading">¶</a></h1>
<span class="target" id="index-0"></span><dl class="std extension">
<dt class="sig sig-object std" id="extension-ApplicativeDo">
<span id="ghc-flag--XApplicativeDo"></span><span id="extension-NoApplicativeDo"></span><span class="sig-name descname"><span class="pre">ApplicativeDo</span></span><a class="headerlink" href="#extension-ApplicativeDo" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>8.0.1</p>
</dd>
</dl>
<p>Allow use of <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> <code class="docutils literal notranslate"><span class="pre">do</span></code> notation.</p>
</dd></dl>

<p>The language option <a class="reference internal" href="#extension-ApplicativeDo"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ApplicativeDo</span></code></a> enables an alternative translation for
the do-notation, which uses the operators <code class="docutils literal notranslate"><span class="pre">&lt;$&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code>, along with <code class="docutils literal notranslate"><span class="pre">join</span></code>
as far as possible. There are two main reasons for wanting to do this:</p>
<ul class="simple">
<li><p>We can use do-notation with types that are an instance of <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> and
<code class="docutils literal notranslate"><span class="pre">Functor</span></code>, but not <code class="docutils literal notranslate"><span class="pre">Monad</span></code></p></li>
<li><p>In some monads, using the applicative operators is more efficient than monadic
bind. For example, it may enable more parallelism.</p></li>
</ul>
<p>Applicative do-notation desugaring preserves the original semantics, provided
that the <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> instance satisfies <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span> <span class="pre">=</span> <span class="pre">ap</span></code> and <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">=</span> <span class="pre">return</span></code>
(these are true of all the common monadic types). Thus, you can normally turn on
<a class="reference internal" href="#extension-ApplicativeDo"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ApplicativeDo</span></code></a> without fear of breaking your program. There is one pitfall
to watch out for; see <a class="reference internal" href="#applicative-do-pitfall"><span class="std std-ref">Things to watch out for</span></a>.</p>
<p>There are no syntactic changes with <a class="reference internal" href="#extension-ApplicativeDo"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ApplicativeDo</span></code></a>. The only way it shows
up at the source level is that you can have a <code class="docutils literal notranslate"><span class="pre">do</span></code> expression that doesn’t
require a <code class="docutils literal notranslate"><span class="pre">Monad</span></code> constraint. For example, in GHCi:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">set</span><span class="w"> </span><span class="o">-</span><span class="kt">XApplicativeDo</span><span class="w"></span>
<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">t</span><span class="w"> </span><span class="nf">\</span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">not</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="nf">\</span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">not</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
</pre></div>
</div>
<p>This example only requires <code class="docutils literal notranslate"><span class="pre">Functor</span></code>, because it is translated into <code class="docutils literal notranslate"><span class="pre">(\x</span> <span class="pre">-&gt;</span>
<span class="pre">not</span> <span class="pre">x)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">m</span></code>. A more complex example requires <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">t</span><span class="w"> </span><span class="nf">\</span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="sc">&#39;b&#39;</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="nf">\</span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="sc">&#39;b&#39;</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Char</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
</pre></div>
</div>
<p>Here GHC has translated the expression into</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="sc">&#39;b&#39;</span><span class="w"></span>
</pre></div>
</div>
<p>It is possible to see the actual translation by using <a class="reference internal" href="../debugging.html#ghc-flag-ddump-ds"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-ds</span></code></a>, but be
warned, the output is quite verbose.</p>
<p>Note that if the expression can’t be translated into uses of <code class="docutils literal notranslate"><span class="pre">&lt;$&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code>
only, then it will incur a <code class="docutils literal notranslate"><span class="pre">Monad</span></code> constraint as usual. This happens when
there is a dependency on a value produced by an earlier statement in the
<code class="docutils literal notranslate"><span class="pre">do</span></code>-block:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">t</span><span class="w"> </span><span class="nf">\</span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">True</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="nf">\</span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">True</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span></code> depends on the value of <code class="docutils literal notranslate"><span class="pre">x</span></code> produced by the first statement, so
the expression cannot be translated using <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code>.</p>
<p>In general, the rule for when a <code class="docutils literal notranslate"><span class="pre">do</span></code> statement incurs a <code class="docutils literal notranslate"><span class="pre">Monad</span></code> constraint
is as follows. If the do-expression has the following form:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">do</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">E1</span><span class="p">;</span><span class="w"> </span><span class="o">...</span><span class="p">;</span><span class="w"> </span><span class="n">pn</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">En</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="kt">E</span><span class="w"></span>
</pre></div>
</div>
<p>where none of the variables defined by <code class="docutils literal notranslate"><span class="pre">p1...pn</span></code> are mentioned in <code class="docutils literal notranslate"><span class="pre">E1...En</span></code>,
and <code class="docutils literal notranslate"><span class="pre">p1...pn</span></code> are all variables or lazy patterns,
then the expression will only require <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>. Otherwise, the expression
will require <code class="docutils literal notranslate"><span class="pre">Monad</span></code>. The block may return a pure expression <code class="docutils literal notranslate"><span class="pre">E</span></code> depending
upon the results <code class="docutils literal notranslate"><span class="pre">p1...pn</span></code> with either <code class="docutils literal notranslate"><span class="pre">return</span></code> or <code class="docutils literal notranslate"><span class="pre">pure</span></code>.</p>
<p>Note: the final statement must match one of these patterns exactly:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">E</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">$</span> <span class="pre">E</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">E</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">$</span> <span class="pre">E</span></code></p></li>
</ul>
<p>otherwise GHC cannot recognise it as a <code class="docutils literal notranslate"><span class="pre">return</span></code> statement, and the
transformation to use <code class="docutils literal notranslate"><span class="pre">&lt;$&gt;</span></code> that we saw above does not apply.  In
particular, slight variations such as <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">.</span> <span class="pre">Just</span> <span class="pre">$</span> <span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span>
<span class="pre">=</span> <span class="pre">e</span> <span class="pre">in</span> <span class="pre">return</span> <span class="pre">x</span></code> would not be recognised.</p>
<p>If the final statement is not of one of these forms, GHC falls back to
standard <code class="docutils literal notranslate"><span class="pre">do</span></code> desugaring, and the expression will require a
<code class="docutils literal notranslate"><span class="pre">Monad</span></code> constraint.</p>
<p>When the statements of a <code class="docutils literal notranslate"><span class="pre">do</span></code> expression have dependencies between
them, and <code class="docutils literal notranslate"><span class="pre">ApplicativeDo</span></code> cannot infer an <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> type, it
uses a heuristic algorithm to try to use <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> as much as possible.
This algorithm usually finds the best solution, but in rare complex
cases it might miss an opportunity.  There is an algorithm that finds
the optimal solution, provided as an option:</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-foptimal-applicative-do">
<span class="sig-name descname"><span class="pre">-foptimal-applicative-do</span></span><a class="headerlink" href="#ghc-flag-foptimal-applicative-do" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>8.0.1</p>
</dd>
</dl>
<p>Enables an alternative algorithm for choosing where to use <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code>
in conjunction with the <code class="docutils literal notranslate"><span class="pre">ApplicativeDo</span></code> language extension.
This algorithm always finds the optimal solution, but it is
expensive: <code class="docutils literal notranslate"><span class="pre">O(n^3)</span></code>, so this option can lead to long compile
times when there are very large <code class="docutils literal notranslate"><span class="pre">do</span></code> expressions (over 100
statements).  The default <code class="docutils literal notranslate"><span class="pre">ApplicativeDo</span></code> algorithm is <code class="docutils literal notranslate"><span class="pre">O(n^2)</span></code>.</p>
</dd></dl>

<section id="strict-patterns">
<span id="applicative-do-strict"></span><h2><span class="section-number">6.2.4.1. </span>Strict patterns<a class="headerlink" href="#strict-patterns" title="Permalink to this heading">¶</a></h2>
<p>A strict pattern match in a bind statement prevents
<code class="docutils literal notranslate"><span class="pre">ApplicativeDo</span></code> from transforming that statement to use
<code class="docutils literal notranslate"><span class="pre">Applicative</span></code>.  This is because the transformation would change the
semantics by making the expression lazier.</p>
<p>For example, this code will require a <code class="docutils literal notranslate"><span class="pre">Monad</span></code> constraint:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">t</span><span class="w"> </span><span class="nf">\</span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="nf">\</span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>but making the pattern match lazy allows it to have a <code class="docutils literal notranslate"><span class="pre">Functor</span></code> constraint:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">t</span><span class="w"> </span><span class="nf">\</span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="nf">\</span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>A “strict pattern match” is any pattern match that can fail.  For
example, <code class="docutils literal notranslate"><span class="pre">()</span></code>, <code class="docutils literal notranslate"><span class="pre">(x:xs)</span></code>, <code class="docutils literal notranslate"><span class="pre">!z</span></code>, and <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span></code> are strict patterns,
but <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">~(1,2)</span></code> are not.  For the purposes of
<code class="docutils literal notranslate"><span class="pre">ApplicativeDo</span></code>, a pattern match against a <code class="docutils literal notranslate"><span class="pre">newtype</span></code> constructor
is considered strict.</p>
<p>When there’s a strict pattern match in a sequence of statements,
<code class="docutils literal notranslate"><span class="pre">ApplicativeDo</span></code> places a <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> between that statement and the one
that follows it.  The sequence may be transformed to use <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code>
elsewhere, but the strict pattern match and the following statement
will always be connected with <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, to retain the same strictness
semantics as the standard do-notation.  If you don’t want this, simply
put a <code class="docutils literal notranslate"><span class="pre">~</span></code> on the pattern match to make it lazy.</p>
</section>
<section id="things-to-watch-out-for">
<span id="applicative-do-pitfall"></span><h2><span class="section-number">6.2.4.2. </span>Things to watch out for<a class="headerlink" href="#things-to-watch-out-for" title="Permalink to this heading">¶</a></h2>
<p>Your code should just work as before when <a class="reference internal" href="#extension-ApplicativeDo"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ApplicativeDo</span></code></a> is enabled,
provided you use conventional <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> instances. However, if you define
a <code class="docutils literal notranslate"><span class="pre">Functor</span></code> or <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> instance using do-notation, then it will likely
get turned into an infinite loop by GHC. For example, if you do this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="kt">MyType</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">fmap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Then applicative desugaring will turn it into</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="kt">MyType</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">fmap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fmap</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
</pre></div>
</div>
<p>And the program will loop at runtime. Similarly, an <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> instance
like this</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="kt">MyType</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">pure</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>will result in an infinite loop when <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> is called.</p>
<p>Just as you wouldn’t define a <code class="docutils literal notranslate"><span class="pre">Monad</span></code> instance using the do-notation, you
shouldn’t define <code class="docutils literal notranslate"><span class="pre">Functor</span></code> or <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> instance using do-notation (when
using <code class="docutils literal notranslate"><span class="pre">ApplicativeDo</span></code>) either. The correct way to define these instances in
terms of <code class="docutils literal notranslate"><span class="pre">Monad</span></code> is to use the <code class="docutils literal notranslate"><span class="pre">Monad</span></code> operations directly, e.g.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Functor</span><span class="w"> </span><span class="kt">MyType</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">fmap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">f</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="kt">MyType</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">pure</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ap</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="qualified_do.html" class="btn btn-neutral float-right" title="6.2.5. Qualified do-notation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="recursive_do.html" class="btn btn-neutral float-left" title="6.2.3. The recursive do-notation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
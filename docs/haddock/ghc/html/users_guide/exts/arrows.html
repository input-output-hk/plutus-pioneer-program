

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.2.19. Arrow notation &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.2.20. Lexical negation" href="lexical_negation.html" />
    <link rel="prev" title="6.2.18. Typed Holes" href="typed_holes.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="syntax.html">6.2. Syntax</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="unicode_syntax.html">6.2.1. Unicode syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="magic_hash.html">6.2.2. The magic hash</a></li>
<li class="toctree-l3"><a class="reference internal" href="recursive_do.html">6.2.3. The recursive do-notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="applicative_do.html">6.2.4. Applicative do-notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="qualified_do.html">6.2.5. Qualified do-notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="parallel_list_comprehensions.html">6.2.6. Parallel List Comprehensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="generalised_list_comprehensions.html">6.2.7. Generalised (SQL-like) List Comprehensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="monad_comprehensions.html">6.2.8. Monad comprehensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="overloaded_lists.html">6.2.9. Overloaded lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="rebindable_syntax.html">6.2.10. Rebindable syntax and the implicit Prelude import</a></li>
<li class="toctree-l3"><a class="reference internal" href="rebindable_syntax.html#postfix-operators">6.2.11. Postfix operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="tuple_sections.html">6.2.12. Tuple sections</a></li>
<li class="toctree-l3"><a class="reference internal" href="lambda_case.html">6.2.13. Lambda-case</a></li>
<li class="toctree-l3"><a class="reference internal" href="empty_case.html">6.2.14. Empty case alternatives</a></li>
<li class="toctree-l3"><a class="reference internal" href="multiway_if.html">6.2.15. Multi-way if-expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="local_fixity_decls.html">6.2.16. Local Fixity Declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="block_arguments.html">6.2.17. More liberal syntax for function arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="typed_holes.html">6.2.18. Typed Holes</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.2.19. Arrow notation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#do-notation-for-commands">6.2.19.1. do-notation for commands</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conditional-commands">6.2.19.2. Conditional commands</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defining-your-own-control-structures">6.2.19.3. Defining your own control structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#primitive-constructs">6.2.19.4. Primitive constructs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#differences-with-the-paper">6.2.19.5. Differences with the paper</a></li>
<li class="toctree-l4"><a class="reference internal" href="#portability">6.2.19.6. Portability</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lexical_negation.html">6.2.20. Lexical negation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="syntax.html"><span class="section-number">6.2. </span>Syntax</a> &raquo;</li>
        
      <li><span class="section-number">6.2.19. </span>Arrow notation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/arrows.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="arrow-notation">
<span id="id1"></span><h1><span class="section-number">6.2.19. </span>Arrow notation<a class="headerlink" href="#arrow-notation" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-Arrows">
<span id="ghc-flag--XArrows"></span><span id="extension-NoArrows"></span><span class="sig-name descname"><span class="pre">Arrows</span></span><a class="headerlink" href="#extension-Arrows" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.8.1</p>
</dd>
</dl>
<p>Enable arrow notation.</p>
</dd></dl>

<p>Arrows are a generalisation of monads introduced by John Hughes. For
more details, see</p>
<ul class="simple">
<li><p>“Generalising Monads to Arrows”, John Hughes, in Science of Computer
Programming 37, pp. 67–111, May 2000. The paper that introduced arrows:
a friendly introduction, motivated with programming examples.</p></li>
<li><p>“<a class="reference external" href="http://www.soi.city.ac.uk/~ross/papers/notation.html">A New Notation for
Arrows</a>”,
Ross Paterson, in ICFP, Sep 2001. Introduced the notation described
here.</p></li>
<li><p>“<a class="reference external" href="http://www.soi.city.ac.uk/~ross/papers/fop.html">Arrows and
Computation</a>”,
Ross Paterson, in The Fun of Programming, Palgrave, 2003.</p></li>
<li><p>“<a class="reference external" href="http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf">Programming with
Arrows</a>”, John
Hughes, in 5th International Summer School on Advanced Functional
Programming, Lecture Notes in Computer Science vol. 3622, Springer,
2004. This paper includes another introduction to the notation, with
practical examples.</p></li>
<li><p>“<a class="reference external" href="http://www.haskell.org/ghc/docs/papers/arrow-rules.pdf">Type and Translation Rules for Arrow Notation in
GHC</a>”,
Ross Paterson and Simon Peyton Jones, September 16, 2004. A terse
enumeration of the formal rules used (extracted from comments in the
source code).</p></li>
<li><p>The arrows web page at
<code class="docutils literal notranslate"><span class="pre">http://www.haskell.org/arrows/</span></code> &lt;<a class="reference external" href="http://www.haskell.org/arrows/">http://www.haskell.org/arrows/</a>&gt;`__.</p></li>
</ul>
<p>With the <a class="reference internal" href="#extension-Arrows"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Arrows</span></code></a> extension, GHC supports the arrow notation described in
the second of these papers, translating it using combinators from the
<a class="reference external" href="../../libraries/base-4.16.3.0/Control-Arrow.html">Control.Arrow</a> module.
What follows is a brief introduction to the notation; it won’t make much
sense unless you’ve read Hughes’s paper.</p>
<p>The extension adds a new kind of expression for defining arrows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>exp10 ::= ...
       |  proc apat -&gt; cmd
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">proc</span></code> is a new keyword. The variables of the pattern are bound
in the body of the <code class="docutils literal notranslate"><span class="pre">proc</span></code>-expression, which is a new sort of thing
called a command. The syntax of commands is as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cmd   ::= exp10 -&lt;  exp
       |  exp10 -&lt;&lt; exp
       |  cmd0
</pre></div>
</div>
<p>with ⟨cmd⟩<sup>0</sup> up to ⟨cmd⟩<sup>9</sup> defined using infix operators
as for expressions, and</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cmd10 ::= \ apat ... apat -&gt; cmd
       |  let decls in cmd
       |  if exp then cmd else cmd
       |  case exp of { calts }
       |  do { cstmt ; ... cstmt ; cmd }
       |  fcmd

fcmd  ::= fcmd aexp
       |  ( cmd )
       |  (| aexp cmd ... cmd |)

cstmt ::= let decls
       |  pat &lt;- cmd
       |  rec { cstmt ; ... cstmt [;] }
       |  cmd
</pre></div>
</div>
<p>where ⟨calts⟩ are like ⟨alts⟩ except that the bodies are commands
instead of expressions.</p>
<p>Commands produce values, but (like monadic computations) may yield more
than one value, or none, and may do other things as well. For the most
part, familiarity with monadic notation is a good guide to using
commands. However the values of expressions, even monadic ones, are
determined by the values of the variables they contain; this is not
necessarily the case for commands.</p>
<p>A simple example of the new notation is the expression</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">proc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>We call this a procedure or arrow abstraction. As with a lambda
expression, the variable <code class="docutils literal notranslate"><span class="pre">x</span></code> is a new variable bound within the
<code class="docutils literal notranslate"><span class="pre">proc</span></code>-expression. It refers to the input to the arrow. In the above
example, <code class="docutils literal notranslate"><span class="pre">-&lt;</span></code> is not an identifier but a new reserved symbol used for
building commands from an expression of arrow type and an expression to
be fed as input to that arrow. (The weird look will make more sense
later.) It may be read as analogue of application for arrows. The above
example is equivalent to the Haskell expression</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"></span>
</pre></div>
</div>
<p>That would make no sense if the expression to the left of <code class="docutils literal notranslate"><span class="pre">-&lt;</span></code>
involves the bound variable <code class="docutils literal notranslate"><span class="pre">x</span></code>. More generally, the expression to the
left of <code class="docutils literal notranslate"><span class="pre">-&lt;</span></code> may not involve any local variable, i.e. a variable bound
in the current arrow abstraction. For such a situation there is a
variant <code class="docutils literal notranslate"><span class="pre">-&lt;&lt;</span></code>, as in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">proc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>which is equivalent to</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">app</span><span class="w"></span>
</pre></div>
</div>
<p>so in this case the arrow must belong to the <code class="docutils literal notranslate"><span class="pre">ArrowApply</span></code> class. Such
an arrow is equivalent to a monad, so if you’re using this form you may
find a monadic formulation more convenient.</p>
<section id="do-notation-for-commands">
<h2><span class="section-number">6.2.19.1. </span>do-notation for commands<a class="headerlink" href="#do-notation-for-commands" title="Permalink to this heading">¶</a></h2>
<p>Another form of command is a form of <code class="docutils literal notranslate"><span class="pre">do</span></code>-notation. For example, you
can write</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">proc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="n">g</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="w"></span>
<span class="w">        </span><span class="kr">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="w"></span>
<span class="w">        </span><span class="n">t</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="w"></span>
<span class="w">        </span><span class="n">returnA</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">t</span><span class="o">+</span><span class="n">z</span><span class="w"></span>
</pre></div>
</div>
<p>You can read this much like ordinary <code class="docutils literal notranslate"><span class="pre">do</span></code>-notation, but with commands
in place of monadic expressions. The first line sends the value of
<code class="docutils literal notranslate"><span class="pre">x+1</span></code> as an input to the arrow <code class="docutils literal notranslate"><span class="pre">f</span></code>, and matches its output against
<code class="docutils literal notranslate"><span class="pre">y</span></code>. In the next line, the output is discarded. The arrow <code class="docutils literal notranslate"><span class="pre">returnA</span></code>
is defined in the <a class="reference external" href="../../libraries/base-4.16.3.0/Control-Arrow.html">Control.Arrow</a> module as <code class="docutils literal notranslate"><span class="pre">arr</span> <span class="pre">id</span></code>. The above
example is treated as an abbreviation for</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">first</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)))</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">first</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">arr</span><span class="w"> </span><span class="n">snd</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">),</span><span class="w"> </span><span class="n">z</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">first</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">t</span><span class="o">+</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">returnA</span><span class="w"></span>
</pre></div>
</div>
<p>Note that variables not used later in the composition are projected out.
After simplification using rewrite rules (see <a class="reference internal" href="rewrite_rules.html#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>)
defined in the <a class="reference external" href="../../libraries/base-4.16.3.0/Control-Arrow.html">Control.Arrow</a> module, this reduces to</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">first</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)))</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">first</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">first</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">t</span><span class="o">+</span><span class="n">z</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>which is what you might have written by hand. With arrow notation, GHC
keeps track of all those tuples of variables for you.</p>
<p>Note that although the above translation suggests that <code class="docutils literal notranslate"><span class="pre">let</span></code>-bound
variables like <code class="docutils literal notranslate"><span class="pre">z</span></code> must be monomorphic, the actual translation
produces Core, so polymorphic variables are allowed.</p>
<p>It’s also possible to have mutually recursive bindings, using the new
<code class="docutils literal notranslate"><span class="pre">rec</span></code> keyword, as in the following example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">counter</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ArrowCircuit</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">counter</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">        </span><span class="n">rec</span><span class="w">     </span><span class="n">output</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">returnA</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">next</span><span class="w"></span>
<span class="w">                </span><span class="n">next</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">delay</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">output</span><span class="o">+</span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="n">returnA</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">output</span><span class="w"></span>
</pre></div>
</div>
<p>The translation of such forms uses the <code class="docutils literal notranslate"><span class="pre">loop</span></code> combinator, so the arrow
concerned must belong to the <code class="docutils literal notranslate"><span class="pre">ArrowLoop</span></code> class.</p>
</section>
<section id="conditional-commands">
<h2><span class="section-number">6.2.19.2. </span>Conditional commands<a class="headerlink" href="#conditional-commands" title="Permalink to this heading">¶</a></h2>
<p>In the previous example, we used a conditional expression to construct
the input for an arrow. Sometimes we want to conditionally execute
different commands, as in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">proc</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">        </span><span class="kr">if</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="w">        </span><span class="kr">then</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="kr">else</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">y</span><span class="o">+</span><span class="mi">2</span><span class="w"></span>
</pre></div>
</div>
<p>which is translated to</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="kt">Left</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="kt">Right</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="o">|||</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">y</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Since the translation uses <code class="docutils literal notranslate"><span class="pre">|||</span></code>, the arrow concerned must belong to
the <code class="docutils literal notranslate"><span class="pre">ArrowChoice</span></code> class.</p>
<p>There are also <code class="docutils literal notranslate"><span class="pre">case</span></code> commands, like</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">[]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="n">x1</span><span class="kt">:</span><span class="n">x2</span><span class="kt">:</span><span class="n">xs</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">x2</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">ys</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
<span class="w">        </span><span class="n">returnA</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="w"></span>
</pre></div>
</div>
<p>The syntax is the same as for <code class="docutils literal notranslate"><span class="pre">case</span></code> expressions, except that the
bodies of the alternatives are commands rather than expressions. The
translation is similar to that of <code class="docutils literal notranslate"><span class="pre">if</span></code> commands.</p>
</section>
<section id="defining-your-own-control-structures">
<h2><span class="section-number">6.2.19.3. </span>Defining your own control structures<a class="headerlink" href="#defining-your-own-control-structures" title="Permalink to this heading">¶</a></h2>
<p>As we’re seen, arrow notation provides constructs, modelled on those for
expressions, for sequencing, value recursion and conditionals. But
suitable combinators, which you can define in ordinary Haskell, may also
be used to build new commands out of existing ones. The basic idea is
that a command defines an arrow from environments to values. These
environments assign values to the free local variables of the command.
Thus combinators that produce arrows from arrows may also be used to
build commands from commands. For example, the <code class="docutils literal notranslate"><span class="pre">ArrowPlus</span></code> class
includes a combinator</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">ArrowPlus</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;+&gt;</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
<p>so we can use it to build commands:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">expr&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">                </span><span class="n">returnA</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;+&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">                </span><span class="n">symbol</span><span class="w"> </span><span class="kt">Plus</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">                </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">term</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">                </span><span class="n">expr&#39;</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;+&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">                </span><span class="n">symbol</span><span class="w"> </span><span class="kt">Minus</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">                </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">term</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">                </span><span class="n">expr&#39;</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
<p>(The <code class="docutils literal notranslate"><span class="pre">do</span></code> on the first line is needed to prevent the first <code class="docutils literal notranslate"><span class="pre">&lt;+&gt;</span> <span class="pre">...</span></code>
from being interpreted as part of the expression on the previous line.)
This is equivalent to</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">expr&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">proc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">returnA</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;+&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">proc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">                </span><span class="n">symbol</span><span class="w"> </span><span class="kt">Plus</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">                </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">term</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">                </span><span class="n">expr&#39;</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;+&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">proc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">                </span><span class="n">symbol</span><span class="w"> </span><span class="kt">Minus</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">                </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">term</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">                </span><span class="n">expr&#39;</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>We are actually using <code class="docutils literal notranslate"><span class="pre">&lt;+&gt;</span></code> here with the more specific type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">ArrowPlus</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;+&gt;</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="nb">()</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="nb">()</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="nb">()</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
<p>It is essential that this operator be polymorphic in <code class="docutils literal notranslate"><span class="pre">e</span></code> (representing
the environment input to the command and thence to its subcommands) and
satisfy the corresponding naturality property</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">&lt;+&gt;</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;+&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>at least for strict <code class="docutils literal notranslate"><span class="pre">k</span></code>. (This should be automatic if you’re not using
<code class="docutils literal notranslate"><span class="pre">seq</span></code>.) This ensures that environments seen by the subcommands are
environments of the whole command, and also allows the translation to
safely trim these environments. (The second component of the input pairs
can contain unnamed input values, as described in the next section.) The
operator must also not use any variable defined within the current arrow
abstraction.</p>
<p>We could define our own operator</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">untilA</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ArrowChoice</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">untilA</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">        </span><span class="kr">if</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">returnA</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">        </span><span class="kr">else</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">                </span><span class="n">body</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">                </span><span class="n">untilA</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>and use it in the same way. Of course this infix syntax only makes sense
for binary operators; there is also a more general syntax involving
special brackets:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">proc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="o">|</span><span class="n">untilA</span><span class="w"> </span><span class="p">(</span><span class="n">increment</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">within</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">-&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="o">|</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="primitive-constructs">
<h2><span class="section-number">6.2.19.4. </span>Primitive constructs<a class="headerlink" href="#primitive-constructs" title="Permalink to this heading">¶</a></h2>
<p>Some operators will need to pass additional inputs to their subcommands.
For example, in an arrow type supporting exceptions, the operator that
attaches an exception handler will wish to pass the exception that
occurred to the handler. Such an operator might have a type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">handleA</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="kt">Ex</span><span class="p">,</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Ex</span></code> is the type of exceptions handled. You could then use this
with arrow notation by writing a command</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">body</span><span class="w"> </span><span class="p">`</span><span class="n">handleA</span><span class="p">`</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">handler</span><span class="w"></span>
</pre></div>
</div>
<p>so that if an exception is raised in the command <code class="docutils literal notranslate"><span class="pre">body</span></code>, the variable
<code class="docutils literal notranslate"><span class="pre">ex</span></code> is bound to the value of the exception and the command
<code class="docutils literal notranslate"><span class="pre">handler</span></code>, which typically refers to <code class="docutils literal notranslate"><span class="pre">ex</span></code>, is entered. Though the
syntax here looks like a functional lambda, we are talking about
commands, and something different is going on. The input to the arrow
represented by a command consists of values for the free local variables
in the command, plus a stack of anonymous values. In all the prior
examples, we made no assumptions about this stack. In the second
argument to <code class="docutils literal notranslate"><span class="pre">handleA</span></code>, the value of the exception has been added to
the stack input to the handler. The command form of lambda merely gives
this value a name.</p>
<p>More concretely, the input to a command consists of a pair of an
environment and a stack. Each value on the stack is paired with the
remainder of the stack, with an empty stack being <code class="docutils literal notranslate"><span class="pre">()</span></code>. So operators
like <code class="docutils literal notranslate"><span class="pre">handleA</span></code> that pass extra inputs to their subcommands can be
designed for use with the notation by placing the values on the stack
paired with the environment in this way. More precisely, the type of
each argument of the operator (and its result) should have the form</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">(</span><span class="n">tn</span><span class="p">,</span><span class="w"> </span><span class="nb">()</span><span class="p">)</span><span class="o">...</span><span class="p">))</span><span class="w"> </span><span class="n">t</span><span class="w"></span>
</pre></div>
</div>
<p>where ⟨e⟩ is a polymorphic variable (representing the environment) and
⟨ti⟩ are the types of the values on the stack, with ⟨t1⟩ being the
“top”. The polymorphic variable ⟨e⟩ must not occur in ⟨a⟩, ⟨ti⟩ or ⟨t⟩.
However the arrows involved need not be the same. Here are some more
examples of suitable operators:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bracketA</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="n">b</span><span class="p">,</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
<span class="nf">runReader</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="kt">State</span><span class="p">,</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="nf">runState</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="kt">State</span><span class="p">,</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="kt">State</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>We can supply the extra input required by commands built with the last
two by applying them to ordinary expressions, as in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">proc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="o">|</span><span class="n">runReader</span><span class="w"> </span><span class="p">(</span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">})</span><span class="o">|</span><span class="p">)</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
</pre></div>
</div>
<p>which adds <code class="docutils literal notranslate"><span class="pre">s</span></code> to the stack of inputs to the command built using
<code class="docutils literal notranslate"><span class="pre">runReader</span></code>.</p>
<p>The command versions of lambda abstraction and application are analogous
to the expression versions. In particular, the beta and eta rules
describe equivalences of commands. These three features (operators,
lambda abstraction and application) are the core of the notation;
everything else can be built using them, though the results would be
somewhat clumsy. For example, we could simulate <code class="docutils literal notranslate"><span class="pre">do</span></code>-notation by
defining</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bind</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Arrow</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="n">b</span><span class="p">,</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="nf">u</span><span class="w"> </span><span class="p">`</span><span class="n">bind</span><span class="p">`</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">returnA</span><span class="w"> </span><span class="o">&amp;&amp;&amp;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"></span>

<span class="nf">bind_</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Arrow</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="nf">u</span><span class="w"> </span><span class="p">`</span><span class="n">bind_</span><span class="p">`</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="p">`</span><span class="n">bind</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>We could simulate <code class="docutils literal notranslate"><span class="pre">if</span></code> by defining</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cond</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ArrowChoice</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="kt">Bool</span><span class="p">,</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">cond</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="n">b</span><span class="p">,</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="kt">Left</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="kt">Right</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">|||</span><span class="w"> </span><span class="n">g</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="differences-with-the-paper">
<h2><span class="section-number">6.2.19.5. </span>Differences with the paper<a class="headerlink" href="#differences-with-the-paper" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>Instead of a single form of arrow application (arrow tail) with two
translations, the implementation provides two forms <code class="docutils literal notranslate"><span class="pre">-&lt;</span></code>
(first-order) and <code class="docutils literal notranslate"><span class="pre">-&lt;&lt;</span></code> (higher-order).</p></li>
<li><p>User-defined operators are flagged with banana brackets instead of a
new <code class="docutils literal notranslate"><span class="pre">form</span></code> keyword.</p></li>
<li><p>In the paper and the previous implementation, values on the stack
were paired to the right of the environment in a single argument, but
now the environment and stack are separate arguments.</p></li>
</ul>
</section>
<section id="portability">
<h2><span class="section-number">6.2.19.6. </span>Portability<a class="headerlink" href="#portability" title="Permalink to this heading">¶</a></h2>
<p>Although only GHC implements arrow notation directly, there is also a
preprocessor (available from the <a class="reference external" href="http://www.haskell.org/arrows/">arrows web
page</a>) that translates arrow notation
into Haskell 98 for use with other Haskell systems. You would still want
to check arrow programs with GHC; tracing type errors in the
preprocessor output is not easy. Modules intended for both GHC and the
preprocessor must observe some additional restrictions:</p>
<ul class="simple">
<li><p>The module must import <a class="reference external" href="../../libraries/base-4.16.3.0/Control-Arrow.html">Control.Arrow</a>.</p></li>
<li><p>The preprocessor cannot cope with other Haskell extensions. These
would have to go in separate modules.</p></li>
<li><p>Because the preprocessor targets Haskell (rather than Core),
<code class="docutils literal notranslate"><span class="pre">let</span></code>-bound variables are monomorphic.</p></li>
</ul>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="lexical_negation.html" class="btn btn-neutral float-right" title="6.2.20. Lexical negation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="typed_holes.html" class="btn btn-neutral float-left" title="6.2.18. Typed Holes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
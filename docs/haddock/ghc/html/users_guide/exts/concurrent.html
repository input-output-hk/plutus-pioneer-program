

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.15.1. Concurrent and Parallel Haskell &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.15.2. Software Transactional Memory" href="stm.html" />
    <link rel="prev" title="6.15. Parallel and Concurrent" href="parallel.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.15.1. Concurrent and Parallel Haskell</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#concurrent-haskell">6.15.1.1. Concurrent Haskell</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parallel-haskell">6.15.1.2. Parallel Haskell</a></li>
<li class="toctree-l4"><a class="reference internal" href="#annotating-pure-code-for-parallelism">6.15.1.3. Annotating pure code for parallelism</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="stm.html">6.15.2. Software Transactional Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="static_pointers.html">6.15.3. Static pointers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="parallel.html"><span class="section-number">6.15. </span>Parallel and Concurrent</a> &raquo;</li>
        
      <li><span class="section-number">6.15.1. </span>Concurrent and Parallel Haskell</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/concurrent.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="concurrent-and-parallel-haskell">
<h1><span class="section-number">6.15.1. </span>Concurrent and Parallel Haskell<a class="headerlink" href="#concurrent-and-parallel-haskell" title="Permalink to this heading">¶</a></h1>
<section id="concurrent-haskell">
<span id="id1"></span><h2><span class="section-number">6.15.1.1. </span>Concurrent Haskell<a class="headerlink" href="#concurrent-haskell" title="Permalink to this heading">¶</a></h2>
<p>Concurrent Haskell is the name given to GHC’s concurrency extension. It
is enabled by default, so no special flags are required. The <a class="reference external" href="https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz">Concurrent
Haskell
paper</a>
is still an excellent resource, as is <a class="reference external" href="http://research.microsoft.com/%7Esimonpj/papers/marktoberdorf/">Tackling the awkward
squad</a>.</p>
<p>To the programmer, Concurrent Haskell introduces no new language
constructs; rather, it appears simply as a library,
<a class="reference external" href="../../libraries/base-4.16.3.0/Control-Concurrent.html">Control.Concurrent</a>. The functions exported by this library include:</p>
<ul class="simple">
<li><p>Forking and killing threads.</p></li>
<li><p>Sleeping.</p></li>
<li><p>Synchronised mutable variables, called <code class="docutils literal notranslate"><span class="pre">MVars</span></code></p></li>
<li><p>Support for bound threads; see the paper <a class="reference external" href="http://community.haskell.org/~simonmar/papers/conc-ffi.pdf">Extending the FFI with
concurrency</a>.</p></li>
</ul>
</section>
<section id="parallel-haskell">
<h2><span class="section-number">6.15.1.2. </span>Parallel Haskell<a class="headerlink" href="#parallel-haskell" title="Permalink to this heading">¶</a></h2>
<p id="index-0">GHC includes support for running Haskell programs in parallel on
symmetric, shared-memory multi-processor (SMP). By default GHC runs
your program on one processor; if you want it to run in parallel you
must link your program with the <a class="reference internal" href="../phases.html#ghc-flag-threaded"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-threaded</span></code></a>, and run it with the RTS
<a class="reference internal" href="../using-concurrent.html#rts-flag-N-x"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-N</span> <span class="pre">⟨x⟩</span></code></a> option; see <a class="reference internal" href="../using-concurrent.html#using-smp"><span class="std std-ref">Using SMP parallelism</span></a>). The runtime will schedule the
running Haskell threads among the available OS threads, running as many in
parallel as you specified with the <a class="reference internal" href="../using-concurrent.html#rts-flag-N-x"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-N</span> <span class="pre">⟨x⟩</span></code></a> RTS option.</p>
</section>
<section id="annotating-pure-code-for-parallelism">
<h2><span class="section-number">6.15.1.3. </span>Annotating pure code for parallelism<a class="headerlink" href="#annotating-pure-code-for-parallelism" title="Permalink to this heading">¶</a></h2>
<p>Ordinary single-threaded Haskell programs will not benefit from enabling
SMP parallelism alone: you must expose parallelism to the compiler. One
way to do so is forking threads using Concurrent Haskell
(<a class="reference internal" href="#concurrent-haskell"><span class="std std-ref">Concurrent Haskell</span></a>), but the simplest mechanism for extracting
parallelism from pure code is to use the <code class="docutils literal notranslate"><span class="pre">par</span></code> combinator, which is
closely related to (and often used with) <code class="docutils literal notranslate"><span class="pre">seq</span></code>. Both of these are
available from the
<a class="reference external" href="http://hackage.haskell.org/package/parallel">parallel library</a>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">infixr</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">`</span><span class="n">par</span><span class="p">`</span><span class="w"></span>
<span class="kr">infixr</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">`</span><span class="n">pseq</span><span class="p">`</span><span class="w"></span>

<span class="nf">par</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">pseq</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>The expression <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">`par`</span> <span class="pre">y)</span></code> <em>sparks</em> the evaluation of <code class="docutils literal notranslate"><span class="pre">x</span></code> (to weak
head normal form) and returns <code class="docutils literal notranslate"><span class="pre">y</span></code>. Sparks are queued for execution in
FIFO order, but are not executed immediately. If the runtime detects
that there is an idle CPU, then it may convert a spark into a real
thread, and run the new thread on the idle CPU. In this way the
available parallelism is spread amongst the real CPUs.</p>
<p>For example, consider the following parallel version of our old nemesis,
<code class="docutils literal notranslate"><span class="pre">nfib</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="w"> </span><span class="nn">Control.Parallel</span><span class="w"></span>

<span class="nf">nfib</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">nfib</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">       </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">par</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="p">(</span><span class="n">pseq</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="p">(</span><span class="n">n1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n2</span><span class="p">))</span><span class="w"></span>
<span class="w">                     </span><span class="kr">where</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">nfib</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">                           </span><span class="n">n2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">nfib</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>For values of <code class="docutils literal notranslate"><span class="pre">n</span></code> greater than 1, we use <code class="docutils literal notranslate"><span class="pre">par</span></code> to spark a thread to
evaluate <code class="docutils literal notranslate"><span class="pre">nfib</span> <span class="pre">(n-1)</span></code>, and then we use <code class="docutils literal notranslate"><span class="pre">pseq</span></code> to force the parent
thread to evaluate <code class="docutils literal notranslate"><span class="pre">nfib</span> <span class="pre">(n-2)</span></code> before going on to add together these
two subexpressions. In this divide-and-conquer approach, we only spark a
new thread for one branch of the computation (leaving the parent to
evaluate the other branch). Also, we must use <code class="docutils literal notranslate"><span class="pre">pseq</span></code> to ensure that
the parent will evaluate <code class="docutils literal notranslate"><span class="pre">n2</span></code> <em>before</em> <code class="docutils literal notranslate"><span class="pre">n1</span></code> in the expression
<code class="docutils literal notranslate"><span class="pre">(n1</span> <span class="pre">+</span> <span class="pre">n2</span> <span class="pre">+</span> <span class="pre">1)</span></code>. It is not sufficient to reorder the expression as
<code class="docutils literal notranslate"><span class="pre">(n2</span> <span class="pre">+</span> <span class="pre">n1</span> <span class="pre">+</span> <span class="pre">1)</span></code>, because the compiler may not generate code to
evaluate the addends from left to right.</p>
<p>Note that we use <code class="docutils literal notranslate"><span class="pre">pseq</span></code> rather than <code class="docutils literal notranslate"><span class="pre">seq</span></code>. The two are almost
equivalent, but differ in their runtime behaviour in a subtle way:
<code class="docutils literal notranslate"><span class="pre">seq</span></code> can evaluate its arguments in either order, but <code class="docutils literal notranslate"><span class="pre">pseq</span></code> is
required to evaluate its first argument before its second, which makes
it more suitable for controlling the evaluation order in conjunction
with <code class="docutils literal notranslate"><span class="pre">par</span></code>.</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">par</span></code>, the general rule of thumb is that the sparked
computation should be required at a later time, but not too soon. Also,
the sparked computation should not be too small, otherwise the cost of
forking it in parallel will be too large relative to the amount of
parallelism gained. Getting these factors right is tricky in practice.</p>
<p>It is possible to glean a little information about how well <code class="docutils literal notranslate"><span class="pre">par</span></code> is
working from the runtime statistics; see <a class="reference internal" href="../runtime_control.html#rts-options-gc"><span class="std std-ref">RTS options to control the garbage collector</span></a>.</p>
<p>More sophisticated combinators for expressing parallelism are available
from the <code class="docutils literal notranslate"><span class="pre">Control.Parallel.Strategies</span></code> module in the <a class="reference external" href="http://hackage.haskell.org/package/parallel">parallel
package</a>. This module
builds functionality around <code class="docutils literal notranslate"><span class="pre">par</span></code>, expressing more elaborate patterns
of parallel computation, such as parallel <code class="docutils literal notranslate"><span class="pre">map</span></code>.</p>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="stm.html" class="btn btn-neutral float-right" title="6.15.2. Software Transactional Memory" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="parallel.html" class="btn btn-neutral float-left" title="6.15. Parallel and Concurrent" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.4.6. Existentially quantified data constructors &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.4.7. Declaring data types with explicit constructor signatures" href="gadt_syntax.html" />
    <link rel="prev" title="6.4.5. Liberalised type synonyms" href="liberal_type_synonyms.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="types.html">6.4. Types</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="nullary_types.html">6.4.1. Data types with no constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatype_contexts.html">6.4.2. Data type contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="infix_tycons.html">6.4.3. Infix type constructors, classes, and type variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_operators.html">6.4.4. Type operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="liberal_type_synonyms.html">6.4.5. Liberalised type synonyms</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.4.6. Existentially quantified data constructors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#why-existential">6.4.6.1. Why existential?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#existentials-and-type-classes">6.4.6.2. Existentials and type classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#record-constructors">6.4.6.3. Record Constructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#restrictions">6.4.6.4. Restrictions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gadt_syntax.html">6.4.7. Declaring data types with explicit constructor signatures</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadt.html">6.4.8. Generalised Algebraic Data Types (GADTs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_families.html">6.4.9. Type families</a></li>
<li class="toctree-l3"><a class="reference internal" href="data_kinds.html">6.4.10. Datatype promotion</a></li>
<li class="toctree-l3"><a class="reference internal" href="poly_kinds.html">6.4.11. Kind polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="levity_polymorphism.html">6.4.12. Levity polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_literals.html">6.4.13. Type-Level Literals</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_applications.html">6.4.14. Visible type application</a></li>
<li class="toctree-l3"><a class="reference internal" href="rank_polymorphism.html">6.4.15. Arbitrary-rank polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="impredicative_types.html">6.4.16. Impredicative polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="linear_types.html">6.4.17. Linear types</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_errors.html">6.4.18. Custom compile-time errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="defer_type_errors.html">6.4.19. Deferring type errors to runtime</a></li>
<li class="toctree-l3"><a class="reference internal" href="roles.html">6.4.20. Roles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="types.html"><span class="section-number">6.4. </span>Types</a> &raquo;</li>
        
      <li><span class="section-number">6.4.6. </span>Existentially quantified data constructors</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/existential_quantification.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="existentially-quantified-data-constructors">
<span id="existential-quantification"></span><h1><span class="section-number">6.4.6. </span>Existentially quantified data constructors<a class="headerlink" href="#existentially-quantified-data-constructors" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-ExistentialQuantification">
<span id="ghc-flag--XExistentialQuantification"></span><span id="extension-NoExistentialQuantification"></span><span class="sig-name descname"><span class="pre">ExistentialQuantification</span></span><a class="headerlink" href="#extension-ExistentialQuantification" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Implies<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExplicitForAll</span></code></a></p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>6.8.1</p>
</dd>
</dl>
<p>Allow existentially quantified type variables in types.</p>
</dd></dl>

<p>The idea of using existential quantification in data type declarations
was suggested by Perry, and implemented in Hope+ (Nigel Perry, <em>The
Implementation of Practical Functional Programming Languages</em>, PhD
Thesis, University of London, 1991). It was later formalised by Laufer
and Odersky (<em>Polymorphic type inference and abstract data types</em>,
TOPLAS, 16(5), pp. 1411-1430, 1994). It’s been in Lennart Augustsson’s
<code class="docutils literal notranslate"><span class="pre">hbc</span></code> Haskell compiler for several years, and proved very useful.
Here’s the idea. Consider the declaration:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">MkFoo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="o">|</span><span class="w"> </span><span class="kt">Nil</span><span class="w"></span>
</pre></div>
</div>
<p>The data type <code class="docutils literal notranslate"><span class="pre">Foo</span></code> has two constructors with types:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">MkFoo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Foo</span><span class="w"></span>
<span class="kt">Nil</span><span class="w">   </span><span class="ow">::</span><span class="w"> </span><span class="kt">Foo</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that the type variable <code class="docutils literal notranslate"><span class="pre">a</span></code> in the type of <code class="docutils literal notranslate"><span class="pre">MkFoo</span></code> does not
appear in the data type itself, which is plain <code class="docutils literal notranslate"><span class="pre">Foo</span></code>. For example, the
following expression is fine:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="kt">MkFoo</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">even</span><span class="p">,</span><span class="w"> </span><span class="kt">MkFoo</span><span class="w"> </span><span class="sc">&#39;c&#39;</span><span class="w"> </span><span class="n">isUpper</span><span class="p">]</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Foo</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">(MkFoo</span> <span class="pre">3</span> <span class="pre">even)</span></code> packages an integer with a function <code class="docutils literal notranslate"><span class="pre">even</span></code>
that maps an integer to <code class="docutils literal notranslate"><span class="pre">Bool</span></code>; and <code class="docutils literal notranslate"><span class="pre">MkFoo</span> <span class="pre">'c'</span>
<span class="pre">isUpper</span></code> packages a character with a compatible function. These two
things are each of type <code class="docutils literal notranslate"><span class="pre">Foo</span></code> and can be put in a list.</p>
<p>What can we do with a value of type <code class="docutils literal notranslate"><span class="pre">Foo</span></code>? In particular, what
happens when we pattern-match on <code class="docutils literal notranslate"><span class="pre">MkFoo</span></code>?</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">MkFoo</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="n">fn</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">???</span><span class="w"></span>
</pre></div>
</div>
<p>Since all we know about <code class="docutils literal notranslate"><span class="pre">val</span></code> and <code class="docutils literal notranslate"><span class="pre">fn</span></code> is that they are compatible,
the only (useful) thing we can do with them is to apply <code class="docutils literal notranslate"><span class="pre">fn</span></code> to
<code class="docutils literal notranslate"><span class="pre">val</span></code> to get a boolean. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">MkFoo</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="n">fn</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fn</span><span class="w"> </span><span class="n">val</span><span class="w"></span>
</pre></div>
</div>
<p>What this allows us to do is to package heterogeneous values together
with a bunch of functions that manipulate them, and then treat that
collection of packages in a uniform manner. You can express quite a bit
of object-oriented-like programming this way.</p>
<section id="why-existential">
<span id="existential"></span><h2><span class="section-number">6.4.6.1. </span>Why existential?<a class="headerlink" href="#why-existential" title="Permalink to this heading">¶</a></h2>
<p>What has this to do with <em>existential</em> quantification? Simply that
<code class="docutils literal notranslate"><span class="pre">MkFoo</span></code> has the (nearly) isomorphic type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">MkFoo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">exists</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">))</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Foo</span><span class="w"></span>
</pre></div>
</div>
<p>But Haskell programmers can safely think of the ordinary <em>universally</em>
quantified type given above, thereby avoiding adding a new existential
quantification construct.</p>
</section>
<section id="existentials-and-type-classes">
<span id="existential-with-context"></span><h2><span class="section-number">6.4.6.2. </span>Existentials and type classes<a class="headerlink" href="#existentials-and-type-classes" title="Permalink to this heading">¶</a></h2>
<p>An easy extension is to allow arbitrary contexts before the constructor.
For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Baz</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Baz1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">         </span><span class="o">|</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Baz2</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The two constructors have the types you’d expect:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Baz1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Baz</span><span class="w"></span>
<span class="kt">Baz2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Baz</span><span class="w"></span>
</pre></div>
</div>
<p>But when pattern matching on <code class="docutils literal notranslate"><span class="pre">Baz1</span></code> the matched values can be compared
for equality, and when pattern matching on <code class="docutils literal notranslate"><span class="pre">Baz2</span></code> the first matched
value can be converted to a string (as well as applying the function to
it). So this program is legal:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Baz</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Baz1</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">q</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Yes&quot;</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;No&quot;</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Baz2</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">fn</span><span class="p">)</span><span class="w">            </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="p">(</span><span class="n">fn</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Operationally, in a dictionary-passing implementation, the constructors
<code class="docutils literal notranslate"><span class="pre">Baz1</span></code> and <code class="docutils literal notranslate"><span class="pre">Baz2</span></code> must store the dictionaries for <code class="docutils literal notranslate"><span class="pre">Eq</span></code> and
<code class="docutils literal notranslate"><span class="pre">Show</span></code> respectively, and extract it on pattern matching.</p>
</section>
<section id="record-constructors">
<span id="existential-records"></span><h2><span class="section-number">6.4.6.3. </span>Record Constructors<a class="headerlink" href="#record-constructors" title="Permalink to this heading">¶</a></h2>
<p>GHC allows existentials to be used with records syntax as well. For
example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">self</span><span class="o">.</span><span class="w"> </span><span class="kt">NewCounter</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">_this</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="n">self</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">_inc</span><span class="w">     </span><span class="ow">::</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">self</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">_display</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="w">      </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">tag</span></code> is a public field, with a well-typed selector function
<code class="docutils literal notranslate"><span class="pre">tag</span> <span class="pre">::</span> <span class="pre">Counter</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>. See <a class="reference internal" href="field_selectors_and_type_applications.html#field-selectors-and-type-applications"><span class="std std-ref">Field selectors and TypeApplications</span></a>
for a full description of how the types of top-level field selectors are
determined.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">self</span></code> type is hidden from the outside;
any attempt to apply <code class="docutils literal notranslate"><span class="pre">_this</span></code>, <code class="docutils literal notranslate"><span class="pre">_inc</span></code> or <code class="docutils literal notranslate"><span class="pre">_display</span></code> as functions
will raise a compile-time error. In other words, <em>GHC defines a record
selector function only for fields whose type does not mention the
existentially-quantified variables</em>. (This example used an underscore in
the fields for which record selectors will not be defined, but that is
only programming style; GHC ignores them.)</p>
<p>To make use of these hidden fields, we need to create some helper
functions:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">inc</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">inc</span><span class="w"> </span><span class="p">(</span><span class="kt">NewCounter</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">NewCounter</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">_this</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">_inc</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">_display</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="nf">display</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">display</span><span class="w"> </span><span class="kt">NewCounter</span><span class="p">{</span><span class="w"> </span><span class="n">_this</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">_display</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>Now we can define counters with different underlying implementations:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">counterA</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">counterA</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">NewCounter</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">_this</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">_inc</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="p">),</span><span class="w"> </span><span class="n">_display</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="nf">counterB</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">counterB</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">NewCounter</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">_this</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">_inc</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;#&#39;</span><span class="kt">:</span><span class="p">),</span><span class="w"> </span><span class="n">_display</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">putStrLn</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">display</span><span class="w"> </span><span class="p">(</span><span class="n">inc</span><span class="w"> </span><span class="n">counterA</span><span class="p">)</span><span class="w">         </span><span class="c1">-- prints &quot;1&quot;</span><span class="w"></span>
<span class="w">    </span><span class="n">display</span><span class="w"> </span><span class="p">(</span><span class="n">inc</span><span class="w"> </span><span class="p">(</span><span class="n">inc</span><span class="w"> </span><span class="n">counterB</span><span class="p">))</span><span class="w">   </span><span class="c1">-- prints &quot;##&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>Record update syntax is supported for existentials (and GADTs):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">setTag</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">setTag</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">obj</span><span class="p">{</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The rule for record update is this:</p>
<blockquote>
<div><p>the types of the updated fields may mention only the universally-quantified
type variables of the data constructor. For GADTs, the field may mention
only types that appear as a simple type-variable argument in the
constructor’s result type.</p>
</div></blockquote>
<p>For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f1</span><span class="ow">::</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="ow">::</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">f3</span><span class="ow">::</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">-- c is existential</span><span class="w"></span>
<span class="nf">upd1</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f1</span><span class="ow">=</span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w">   </span><span class="c1">-- OK:   upd1 :: T a b -&gt; a&#39; -&gt; T a&#39; b</span><span class="w"></span>
<span class="nf">upd2</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f3</span><span class="ow">=</span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w">   </span><span class="c1">-- BAD   (f3&#39;s type mentions c, which is</span><span class="w"></span>
<span class="w">                        </span><span class="c1">--        existentially quantified)</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">G1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">g1</span><span class="ow">::</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">g2</span><span class="ow">::</span><span class="n">c</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="nf">upd3</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">g1</span><span class="ow">=</span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w">   </span><span class="c1">-- OK:   upd3 :: G a b -&gt; c -&gt; G c b</span><span class="w"></span>
<span class="nf">upd4</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">g2</span><span class="ow">=</span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w">   </span><span class="c1">-- BAD (g2&#39;s type mentions c, which is not a simple</span><span class="w"></span>
<span class="w">                        </span><span class="c1">--      type-variable argument in G1&#39;s result type)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="restrictions">
<h2><span class="section-number">6.4.6.4. </span>Restrictions<a class="headerlink" href="#restrictions" title="Permalink to this heading">¶</a></h2>
<p>There are several restrictions on the ways in which existentially-quantified
constructors can be used.</p>
<ul>
<li><p>When pattern matching, each pattern match introduces a new, distinct,
type for each existential type variable. These types cannot be
unified with any other type, nor can they escape from the scope of
the pattern match. For example, these fragments are incorrect:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f1</span><span class="w"> </span><span class="p">(</span><span class="kt">MkFoo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>Here, the type bound by <code class="docutils literal notranslate"><span class="pre">MkFoo</span></code> “escapes”, because <code class="docutils literal notranslate"><span class="pre">a</span></code> is the
result of <code class="docutils literal notranslate"><span class="pre">f1</span></code>. One way to see why this is wrong is to ask what
type <code class="docutils literal notranslate"><span class="pre">f1</span></code> has:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w">             </span><span class="c1">-- Weird!</span><span class="w"></span>
</pre></div>
</div>
<p>What is this “<code class="docutils literal notranslate"><span class="pre">a</span></code>” in the result type? Clearly we don’t mean this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w">   </span><span class="c1">-- Wrong!</span><span class="w"></span>
</pre></div>
</div>
<p>The original program is just plain wrong. Here’s another sort of
error</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f2</span><span class="w"> </span><span class="p">(</span><span class="kt">Baz1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Baz1</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="o">==</span><span class="n">q</span><span class="w"></span>
</pre></div>
</div>
<p>It’s ok to say <code class="docutils literal notranslate"><span class="pre">a==b</span></code> or <code class="docutils literal notranslate"><span class="pre">p==q</span></code>, but <code class="docutils literal notranslate"><span class="pre">a==q</span></code> is wrong because it
equates the two distinct types arising from the two <code class="docutils literal notranslate"><span class="pre">Baz1</span></code>
constructors.</p>
</li>
<li><p>You can’t pattern-match on an existentially quantified constructor in
a <code class="docutils literal notranslate"><span class="pre">let</span></code> or <code class="docutils literal notranslate"><span class="pre">where</span></code> group of bindings. So this is illegal:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f3</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">Baz1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Instead, use a <code class="docutils literal notranslate"><span class="pre">case</span></code> expression:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f3</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="kt">Baz1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>In general, you can only pattern-match on an existentially-quantified
constructor in a <code class="docutils literal notranslate"><span class="pre">case</span></code> expression or in the patterns of a function
definition. The reason for this restriction is really an
implementation one. Type-checking binding groups is already a
nightmare without existentials complicating the picture. Also an
existential pattern binding at the top level of a module doesn’t make
sense, because it’s not clear how to prevent the
existentially-quantified type “escaping”. So for now, there’s a
simple-to-state restriction. We’ll see how annoying it is.</p>
</li>
<li><p>You can’t use existential quantification for <code class="docutils literal notranslate"><span class="pre">newtype</span></code>
declarations. So this is illegal:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>Reason: a value of type <code class="docutils literal notranslate"><span class="pre">T</span></code> must be represented as a pair of a
dictionary for <code class="docutils literal notranslate"><span class="pre">Ord</span> <span class="pre">t</span></code> and a value of type <code class="docutils literal notranslate"><span class="pre">t</span></code>. That contradicts
the idea that <code class="docutils literal notranslate"><span class="pre">newtype</span></code> should have no concrete representation. You
can get just the same efficiency and effect by using <code class="docutils literal notranslate"><span class="pre">data</span></code> instead
of <code class="docutils literal notranslate"><span class="pre">newtype</span></code>. If there is no overloading involved, then there is
more of a case for allowing an existentially-quantified <code class="docutils literal notranslate"><span class="pre">newtype</span></code>,
because the <code class="docutils literal notranslate"><span class="pre">data</span></code> version does carry an implementation cost, but
single-field existentially quantified constructors aren’t much use.
So the simple restriction (no existential stuff on <code class="docutils literal notranslate"><span class="pre">newtype</span></code>)
stands, unless there are convincing reasons to change it.</p>
</li>
<li><p>You can’t use <code class="docutils literal notranslate"><span class="pre">deriving</span></code> to define instances of a data type with
existentially quantified data constructors. Reason: in most cases it
would not make sense. For example:;</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="kr">deriving</span><span class="p">(</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>To derive <code class="docutils literal notranslate"><span class="pre">Eq</span></code> in the standard way we would need to have equality
between the single component of two <code class="docutils literal notranslate"><span class="pre">MkT</span></code> constructors:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="kt">MkT</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">MkT</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">???</span><span class="w"></span>
</pre></div>
</div>
<p>But <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> have distinct types, and so can’t be compared.
It’s just about possible to imagine examples in which the derived
instance would make sense, but it seems altogether simpler simply to
prohibit such declarations. Define your own instances!</p>
</li>
</ul>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gadt_syntax.html" class="btn btn-neutral float-right" title="6.4.7. Declaring data types with explicit constructor signatures" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="liberal_type_synonyms.html" class="btn btn-neutral float-left" title="6.4.5. Liberalised type synonyms" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.17. Foreign function interface (FFI) &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.18. Safe Haskell" href="safe_haskell.html" />
    <link rel="prev" title="6.16. Unboxed types and primitive operations" href="primitives.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6.17. Foreign function interface (FFI)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ghc-differences-to-the-ffi-chapter">6.17.1. GHC differences to the FFI Chapter</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#guaranteed-call-safety">6.17.1.1. Guaranteed call safety</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interactions-between-safe-calls-and-bound-threads">6.17.1.2. Interactions between <code class="docutils literal notranslate"><span class="pre">safe</span></code> calls and bound threads</a></li>
<li class="toctree-l4"><a class="reference internal" href="#varargs-not-supported-by-ccall-calling-convention">6.17.1.3. Varargs not supported by <code class="docutils literal notranslate"><span class="pre">ccall</span></code> calling convention</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ghc-extensions-to-the-ffi-chapter">6.17.2. GHC extensions to the FFI Chapter</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#unlifted-ffi-types">6.17.2.1. Unlifted FFI Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#newtype-wrapping-of-the-io-monad">6.17.2.2. Newtype wrapping of the IO monad</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-forall-s-in-foreign-types">6.17.2.3. Explicit “forall”s in foreign types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#primitive-imports">6.17.2.4. Primitive imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interruptible-foreign-calls">6.17.2.5. Interruptible foreign calls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-capi-calling-convention">6.17.2.6. The CAPI calling convention</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hs-thread-done">6.17.2.7. <code class="docutils literal notranslate"><span class="pre">hs_thread_done()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#freeing-many-stable-pointers-efficiently">6.17.2.8. Freeing many stable pointers efficiently</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-ffi-with-ghc">6.17.3. Using the FFI with GHC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#using-foreign-export-and-foreign-import-ccall-wrapper-with-ghc">6.17.3.1. Using <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">export</span></code> and <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">ccall</span> <span class="pre">&quot;wrapper&quot;</span></code> with GHC</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-header-files">6.17.3.2. Using header files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-allocation">6.17.3.3. Memory Allocation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multi-threading-and-the-ffi">6.17.3.4. Multi-threading and the FFI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#floating-point-and-the-ffi">6.17.3.5. Floating point and the FFI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pinned-byte-arrays">6.17.3.6. Pinned Byte Arrays</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
      <li><span class="section-number">6.17. </span>Foreign function interface (FFI)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/ffi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="foreign-function-interface-ffi">
<span id="ffi"></span><h1><span class="section-number">6.17. </span>Foreign function interface (FFI)<a class="headerlink" href="#foreign-function-interface-ffi" title="Permalink to this heading">¶</a></h1>
<span class="target" id="index-0"></span><dl class="std extension">
<dt class="sig sig-object std" id="extension-ForeignFunctionInterface">
<span id="ghc-flag--XForeignFunctionInterface"></span><span id="extension-NoForeignFunctionInterface"></span><span class="sig-name descname"><span class="pre">ForeignFunctionInterface</span></span><a class="headerlink" href="#extension-ForeignFunctionInterface" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.8.1</p>
</dd>
</dl>
<p>Allow use of the Haskell foreign function interface.</p>
</dd></dl>

<p>GHC (mostly) conforms to the Haskell Foreign Function Interface as specified
in the Haskell Report. Refer to the <a class="reference external" href="https://www.haskell.org/onlinereport/haskell2010/haskellch8.html">relevant chapter</a>
of the Haskell Report for more details.</p>
<p>FFI support is enabled by default, but can be enabled or disabled
explicitly with the <a class="reference internal" href="#extension-ForeignFunctionInterface"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ForeignFunctionInterface</span></code></a> flag.</p>
<p>GHC implements a number of GHC-specific extensions to the FFI Chapter of the
Haskell 2010 Report. These extensions are described in <a class="reference internal" href="#ffi-ghcexts"><span class="std std-ref">GHC extensions to the FFI Chapter</span></a>, but
please note that programs using these features are not portable. Hence, these
features should be avoided where possible.</p>
<p>The FFI libraries are documented in the accompanying  library
documentation; see for example the <a class="reference external" href="../../libraries/base-4.16.3.0/Foreign.html">Foreign</a> module.</p>
<section id="ghc-differences-to-the-ffi-chapter">
<h2><span class="section-number">6.17.1. </span>GHC differences to the FFI Chapter<a class="headerlink" href="#ghc-differences-to-the-ffi-chapter" title="Permalink to this heading">¶</a></h2>
<section id="guaranteed-call-safety">
<h3><span class="section-number">6.17.1.1. </span>Guaranteed call safety<a class="headerlink" href="#guaranteed-call-safety" title="Permalink to this heading">¶</a></h3>
<p>The Haskell 2010 Report specifies that <code class="docutils literal notranslate"><span class="pre">safe</span></code> FFI calls must allow foreign
calls to safely call into Haskell code. In practice, this means that called
functions also have to assume heap-allocated Haskell values may move around
arbitrarily in order to allow for GC.</p>
<p>This greatly constrains library authors since it implies that it is not safe to
pass any heap object reference to a <code class="docutils literal notranslate"><span class="pre">safe</span></code> foreign function call.  For
instance, it is often desirable to pass <a class="reference internal" href="#pinned-byte-arrays"><span class="std std-ref">unpinned</span></a>
<code class="docutils literal notranslate"><span class="pre">ByteArray#</span></code>s directly to native code to avoid making an otherwise-unnecessary
copy. However, this can not be done safely for <code class="docutils literal notranslate"><span class="pre">safe</span></code> calls since the array might
be moved by the garbage collector in the middle of the call.</p>
<p>The Chapter <em>does</em> allow for implementations to move objects around during
<code class="docutils literal notranslate"><span class="pre">unsafe</span></code> calls as well. So strictly Haskell 2010-conforming programs
cannot pass heap-allocated references to <code class="docutils literal notranslate"><span class="pre">unsafe</span></code> FFI calls either.</p>
<p>GHC, since version 8.4, <strong>guarantees</strong> that garbage collection will never occur
during an <code class="docutils literal notranslate"><span class="pre">unsafe</span></code> call, even in the bytecode interpreter, and further guarantees
that <code class="docutils literal notranslate"><span class="pre">unsafe</span></code> calls will be performed in the calling thread. Making it safe to
pass heap-allocated objects to unsafe functions.</p>
<p>In previous releases, GHC would take advantage of the freedom afforded by the
Chapter by performing <code class="docutils literal notranslate"><span class="pre">safe</span></code> foreign calls in place of <code class="docutils literal notranslate"><span class="pre">unsafe</span></code> calls in
the bytecode interpreter. This meant that some packages which worked when
compiled would fail under GHCi (e.g. <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/13730">#13730</a>). But this is no
longer the case in recent releases.</p>
</section>
<section id="interactions-between-safe-calls-and-bound-threads">
<h3><span class="section-number">6.17.1.2. </span>Interactions between <code class="docutils literal notranslate"><span class="pre">safe</span></code> calls and bound threads<a class="headerlink" href="#interactions-between-safe-calls-and-bound-threads" title="Permalink to this heading">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">safe</span></code> call calling into haskell is run on a bound thread by
the RTS. This means any nesting of <code class="docutils literal notranslate"><span class="pre">safe</span></code> calls will be executed on
the same operating system thread. <em>Sequential</em> <code class="docutils literal notranslate"><span class="pre">safe</span></code> calls however
do not enjoy this luxury and may be run on arbitrary OS threads.</p>
<p>This behaviour is considered an implementation detail and code relying on
thread local state should instead use one of the interfaces provided
in <a class="reference external" href="../../libraries/base-4.16.3.0/Control-Concurrent.html">Control.Concurrent</a> to make this explicit.</p>
<p>For information on what bound threads are,
see the documentation for the <a class="reference external" href="../../libraries/base-4.16.3.0/Control-Concurrent.html">Control.Concurrent</a>.</p>
<p>For more details on the implementation see the Paper:
“Extending the Haskell Foreign Function Interface with Concurrency”.
Last known to be accessible <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2004/09/conc-ffi.pdf">here</a>.</p>
</section>
<section id="varargs-not-supported-by-ccall-calling-convention">
<h3><span class="section-number">6.17.1.3. </span>Varargs not supported by <code class="docutils literal notranslate"><span class="pre">ccall</span></code> calling convention<a class="headerlink" href="#varargs-not-supported-by-ccall-calling-convention" title="Permalink to this heading">¶</a></h3>
<p>Note that functions requiring varargs arguments are unsupported by the <code class="docutils literal notranslate"><span class="pre">ccall</span></code>
calling convention. Foreign imports needing to call such functions should rather
use the <code class="docutils literal notranslate"><span class="pre">capi</span></code> convention, giving an explicit signature for the needed
call-pattern.  For instance, one could write:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foreign</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="s">&quot;capi&quot;</span><span class="w"> </span><span class="s">&quot;printf&quot;</span><span class="w"></span>
<span class="w">    </span><span class="nn">my_printf</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ptr</span><span class="w"> </span><span class="kt">CChar</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CInt</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>

<span class="nf">printInt</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CInt</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">printInt</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">my_printf</span><span class="w"> </span><span class="s">&quot;printed number %d&quot;</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="ghc-extensions-to-the-ffi-chapter">
<span id="ffi-ghcexts"></span><h2><span class="section-number">6.17.2. </span>GHC extensions to the FFI Chapter<a class="headerlink" href="#ghc-extensions-to-the-ffi-chapter" title="Permalink to this heading">¶</a></h2>
<p>The FFI features that are described in this section are specific to GHC.
Your code will not be portable to other compilers if you use them.</p>
<section id="unlifted-ffi-types">
<span id="ffi-unlifted-types"></span><h3><span class="section-number">6.17.2.1. </span>Unlifted FFI Types<a class="headerlink" href="#unlifted-ffi-types" title="Permalink to this heading">¶</a></h3>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-UnliftedFFITypes">
<span id="ghc-flag--XUnliftedFFITypes"></span><span id="extension-NoUnliftedFFITypes"></span><span class="sig-name descname"><span class="pre">UnliftedFFITypes</span></span><a class="headerlink" href="#extension-UnliftedFFITypes" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.8.1</p>
</dd>
</dl>
</dd></dl>

<p>The following unlifted unboxed types may be used as basic foreign
types (see FFI Chapter, Section 8.6) for both <code class="docutils literal notranslate"><span class="pre">safe</span></code> and
<code class="docutils literal notranslate"><span class="pre">unsafe</span></code> foreign calls: <code class="docutils literal notranslate"><span class="pre">Int#</span></code>, <code class="docutils literal notranslate"><span class="pre">Word#</span></code>, <code class="docutils literal notranslate"><span class="pre">Char#</span></code>, <code class="docutils literal notranslate"><span class="pre">Float#</span></code>,
<code class="docutils literal notranslate"><span class="pre">Double#</span></code>, <code class="docutils literal notranslate"><span class="pre">Addr#</span></code>, and <code class="docutils literal notranslate"><span class="pre">StablePtr#</span> <span class="pre">a</span></code>. Several unlifted boxed
types may be used as arguments to FFI calls, subject to these
restrictions:</p>
<ul class="simple">
<li><p>Valid arguments for <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">unsafe</span></code> FFI calls: <code class="docutils literal notranslate"><span class="pre">Array#</span></code>,
<code class="docutils literal notranslate"><span class="pre">SmallArray#</span></code>, <code class="docutils literal notranslate"><span class="pre">ArrayArray#</span></code>, <code class="docutils literal notranslate"><span class="pre">ByteArray#</span></code>, and the mutable
counterparts of these types.</p></li>
<li><p>Valid arguments for <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">safe</span></code> FFI calls: <code class="docutils literal notranslate"><span class="pre">ByteArray#</span></code>
and <code class="docutils literal notranslate"><span class="pre">MutableByteArray#</span></code>. The byte array must be
<a class="reference internal" href="#pinned-byte-arrays"><span class="std std-ref">pinned</span></a>.</p></li>
<li><p>Mutation: In both <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">unsafe</span></code> and <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">safe</span></code>
FFI calls, it is safe to mutate a <code class="docutils literal notranslate"><span class="pre">MutableByteArray</span></code>. Mutating any
other type of array leads to undefined behavior. Reason: Mutable arrays
of heap objects record writes for the purpose of garbage collection.
An array of heap objects is passed to a foreign C function, the
runtime does not record any writes. Consequently, it is not safe to
write to an array of heap objects in a foreign function.
Since the runtime has no facilities for tracking mutation of a
<code class="docutils literal notranslate"><span class="pre">MutableByteArray#</span></code>, these can be safely mutated in any foreign
function.</p></li>
</ul>
<p>None of these restrictions are enforced at compile time. Failure
to heed these restrictions will lead to runtime errors that can be
very difficult to track down. (The errors likely will not manifest
until garbage collection happens.) In tabular form, these restrictions
are:</p>
<table class="docutils align-default" id="id9">
<caption><span class="caption-text">Restrictions on unlifted boxed arguments passed to foreign C calls.
        Cells marked as “Unsound” represent combinations that lead to
        undefined runtime behavior. GHC does not reject such unsound
        programs at compile time.</span><a class="headerlink" href="#id9" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head" colspan="4"><p>When value is used as argument to FFI call that is</p></th>
</tr>
<tr class="row-even"><th class="head"></th>
<th class="head" colspan="2"><p><code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">safe</span></code></p></th>
<th class="head" colspan="2"><p><code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">unsafe</span></code></p></th>
</tr>
<tr class="row-odd"><th class="head"><p>Argument Type</p></th>
<th class="head"><p>reads are</p></th>
<th class="head"><p>writes are</p></th>
<th class="head"><p>reads are</p></th>
<th class="head"><p>writes are</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Array#</span></code></p></td>
<td><p>Unsound</p></td>
<td><p>Unsound</p></td>
<td><p>Sound</p></td>
<td><p>Unsound</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MutableArray#</span></code></p></td>
<td><p>Unsound</p></td>
<td><p>Unsound</p></td>
<td><p>Sound</p></td>
<td><p>Unsound</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SmallArray#</span></code></p></td>
<td><p>Unsound</p></td>
<td><p>Unsound</p></td>
<td><p>Sound</p></td>
<td><p>Unsound</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MutableSmallArray#</span></code></p></td>
<td><p>Unsound</p></td>
<td><p>Unsound</p></td>
<td><p>Sound</p></td>
<td><p>Unsound</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ArrayArray#</span></code></p></td>
<td><p>Unsound</p></td>
<td><p>Unsound</p></td>
<td><p>Sound</p></td>
<td><p>Unsound</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MutableArrayArray#</span></code></p></td>
<td><p>Unsound</p></td>
<td><p>Unsound</p></td>
<td><p>Sound</p></td>
<td><p>Unsound</p></td>
</tr>
<tr class="row-even"><td><p>unpinned <code class="docutils literal notranslate"><span class="pre">ByteArray#</span></code></p></td>
<td><p>Unsound</p></td>
<td><p>Unsound</p></td>
<td><p>Sound</p></td>
<td><p>Unsound</p></td>
</tr>
<tr class="row-odd"><td><p>unpinned <code class="docutils literal notranslate"><span class="pre">MutableByteArray#</span></code></p></td>
<td><p>Unsound</p></td>
<td><p>Unsound</p></td>
<td><p>Sound</p></td>
<td><p>Sound</p></td>
</tr>
<tr class="row-even"><td><p>pinned <code class="docutils literal notranslate"><span class="pre">ByteArray#</span></code></p></td>
<td><p>Sound</p></td>
<td><p>Unsound</p></td>
<td><p>Sound</p></td>
<td><p>Unsound</p></td>
</tr>
<tr class="row-odd"><td><p>pinned <code class="docutils literal notranslate"><span class="pre">MutableByteArray#</span></code></p></td>
<td><p>Sound</p></td>
<td><p>Sound</p></td>
<td><p>Sound</p></td>
<td><p>Sound</p></td>
</tr>
</tbody>
</table>
<p>When passing any of the unlifted array types as an argument to
a foreign C call, a foreign function sees a pointer that refers to the
payload of the array, not to the
<code class="docutils literal notranslate"><span class="pre">StgArrBytes</span></code>/<code class="docutils literal notranslate"><span class="pre">StgMutArrPtrs</span></code>/<code class="docutils literal notranslate"><span class="pre">StgSmallMutArrPtrs</span></code> heap object
containing it <a class="footnote-reference brackets" href="#id5" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. By contrast, a <a class="reference internal" href="#ffi-prim"><span class="std std-ref">foreign Cmm call</span></a>,
introduced by <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">prim</span></code>, sees the heap object, not just
the payload. This means that, in some situations, the foreign C function
might not need any knowledge of the RTS closure types. The following example
sums the first three bytes in a <code class="docutils literal notranslate"><span class="pre">MutableByteArray#</span></code> <a class="footnote-reference brackets" href="#id6" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> without using
anything from <code class="docutils literal notranslate"><span class="pre">Rts.h</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">source</span><span class="w"></span>
<span class="nf">uint8_t</span><span class="w"> </span><span class="n">add_triplet</span><span class="p">(</span><span class="n">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">-- Haskell source</span><span class="w"></span>
<span class="nf">foreign</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="nn">ccall</span><span class="w"> </span><span class="n">unsafe</span><span class="w"> </span><span class="s">&quot;add_triplet&quot;</span><span class="w"></span>
<span class="w">  </span><span class="n">addTriplet</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">MutableByteArray</span><span class="o">#</span><span class="w"> </span><span class="kt">RealWorld</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Word8</span><span class="w"></span>
</pre></div>
</div>
<p>In other situations, the C function may need knowledge of the RTS
closure types. The following example sums the first element of
each <code class="docutils literal notranslate"><span class="pre">ByteArray#</span></code> (interpreting the bytes as an array of <code class="docutils literal notranslate"><span class="pre">CInt</span></code>)
element of an <code class="docutils literal notranslate"><span class="pre">ArrayArray##</span></code> <a class="footnote-reference brackets" href="#id7" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">include</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="kt">RTS</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">make</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="kt">StgArrBytes</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="n">available</span><span class="w"> </span><span class="n">along</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">fields</span><span class="kt">:</span><span class="w"> </span><span class="n">ptrs</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">payload</span><span class="o">.</span><span class="w"></span>
<span class="o">#</span><span class="n">include</span><span class="w"> </span><span class="s">&quot;Rts.h&quot;</span><span class="w"></span>
<span class="nf">int</span><span class="w"> </span><span class="n">sum_first</span><span class="w"> </span><span class="p">(</span><span class="kt">StgArrBytes</span><span class="w"> </span><span class="o">**</span><span class="n">bufs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">StgArrBytes</span><span class="w"> </span><span class="o">**</span><span class="n">bufs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">StgArrBytes</span><span class="o">**</span><span class="p">)</span><span class="n">bufsTmp</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">int</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">for</span><span class="p">(</span><span class="kt">StgWord</span><span class="w"> </span><span class="n">ix</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="n">ix</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">arr</span><span class="ow">-&gt;</span><span class="n">ptrs</span><span class="p">;</span><span class="n">ix</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="n">int</span><span class="o">*</span><span class="p">)(</span><span class="n">bufs</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="ow">-&gt;</span><span class="n">payload</span><span class="p">))[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">-- Haskell source, all elements in the argument array must be</span><span class="w"></span>
<span class="c1">-- either ByteArray# or MutableByteArray#. This is not enforced</span><span class="w"></span>
<span class="c1">-- by the type system in this example since ArrayArray is untyped.</span><span class="w"></span>
<span class="nf">foreign</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="nn">ccall</span><span class="w"> </span><span class="n">unsafe</span><span class="w"> </span><span class="s">&quot;sum_first&quot;</span><span class="w"></span>
<span class="w">  </span><span class="n">sumFirst</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ArrayArray</span><span class="o">#</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">CInt</span><span class="w"></span>
</pre></div>
</div>
<p>Although GHC allows the user to pass all unlifted boxed types to
foreign functions, some of them are not amenable to useful work.
Although <code class="docutils literal notranslate"><span class="pre">Array#</span></code> is unlifted, the elements in its payload are
lifted, and a foreign C function cannot safely force thunks. Consequently,
a foreign C function may not dereference any of the addresses that comprise
the payload of the <code class="docutils literal notranslate"><span class="pre">Array#</span></code>.</p>
</section>
<section id="newtype-wrapping-of-the-io-monad">
<span id="ffi-newtype-io"></span><h3><span class="section-number">6.17.2.2. </span>Newtype wrapping of the IO monad<a class="headerlink" href="#newtype-wrapping-of-the-io-monad" title="Permalink to this heading">¶</a></h3>
<p>The FFI spec requires the IO monad to appear in various places, but it
can sometimes be convenient to wrap the IO monad in a <code class="docutils literal notranslate"><span class="pre">newtype</span></code>, thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">MyIO</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MIO</span><span class="w"> </span><span class="p">(</span><span class="kt">IO</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>(A reason for doing so might be to prevent the programmer from calling
arbitrary IO procedures in some part of the program.)</p>
<p>The Haskell FFI already specifies that arguments and results of foreign
imports and exports will be automatically unwrapped if they are newtypes
(Section 3.2 of the FFI addendum). GHC extends the FFI by automatically
unwrapping any newtypes that wrap the IO monad itself. More precisely,
wherever the FFI specification requires an <code class="docutils literal notranslate"><span class="pre">IO</span></code> type, GHC will accept any
newtype-wrapping of an <code class="docutils literal notranslate"><span class="pre">IO</span></code> type. For example, these declarations are
OK:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foreign</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="nn">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">MyIO</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">foreign</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="s">&quot;dynamic&quot;</span><span class="w"> </span><span class="nn">baz</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">MyIO</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CInt</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">MyIO</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="explicit-forall-s-in-foreign-types">
<span id="ffi-foralls"></span><h3><span class="section-number">6.17.2.3. </span>Explicit “forall”s in foreign types<a class="headerlink" href="#explicit-forall-s-in-foreign-types" title="Permalink to this heading">¶</a></h3>
<p>The type variables in the type of a foreign declaration may be quantified with
an explicit <code class="docutils literal notranslate"><span class="pre">forall</span></code> by using the <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExplicitForAll</span></code></a> language
extension, as in the following example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE ExplicitForAll #-}</span><span class="w"></span>
<span class="nf">foreign</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="nn">ccall</span><span class="w"> </span><span class="s">&quot;mmap&quot;</span><span class="w"> </span><span class="n">c_mmap</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">CSize</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="p">(</span><span class="kt">Ptr</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Note that an explicit <code class="docutils literal notranslate"><span class="pre">forall</span></code> must appear at the front of the type signature
and is not permitted to appear nested within the type, as in the following
(erroneous) examples:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foreign</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="nn">ccall</span><span class="w"> </span><span class="s">&quot;mmap&quot;</span><span class="w"> </span><span class="n">c_mmap&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CSize</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="p">(</span><span class="kt">Ptr</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="nf">foreign</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="nn">ccall</span><span class="w"> </span><span class="n">quux</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">Ptr</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="primitive-imports">
<span id="ffi-prim"></span><h3><span class="section-number">6.17.2.4. </span>Primitive imports<a class="headerlink" href="#primitive-imports" title="Permalink to this heading">¶</a></h3>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-GHCForeignImportPrim">
<span id="ghc-flag--XGHCForeignImportPrim"></span><span id="extension-NoGHCForeignImportPrim"></span><span class="sig-name descname"><span class="pre">GHCForeignImportPrim</span></span><a class="headerlink" href="#extension-GHCForeignImportPrim" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.12.1</p>
</dd>
</dl>
</dd></dl>

<p>With <a class="reference internal" href="#extension-GHCForeignImportPrim"><code class="xref std std-extension docutils literal notranslate"><span class="pre">GHCForeignImportPrim</span></code></a>, GHC extends the FFI with an additional
calling convention <code class="docutils literal notranslate"><span class="pre">prim</span></code>, e.g.:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foreign</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="nn">prim</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ByteArray</span><span class="o">#</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="kt">Int</span><span class="o">#</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="o">#</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This is used to import functions written in Cmm code that follow an
internal GHC calling convention. The arguments and results must be
unboxed types, except that an argument may be of type <code class="docutils literal notranslate"><span class="pre">Any</span></code> (by way of
<code class="docutils literal notranslate"><span class="pre">unsafeCoerce#</span></code>) and the result type is allowed to be an unboxed tuple
or the type <code class="docutils literal notranslate"><span class="pre">Any</span></code>.</p>
<p>This feature is not intended for use outside of the core libraries that
come with GHC. For more details see the
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/commentary/prim-ops">GHC developer wiki</a>.</p>
</section>
<section id="interruptible-foreign-calls">
<span id="ffi-interruptible"></span><h3><span class="section-number">6.17.2.5. </span>Interruptible foreign calls<a class="headerlink" href="#interruptible-foreign-calls" title="Permalink to this heading">¶</a></h3>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-InterruptibleFFI">
<span id="ghc-flag--XInterruptibleFFI"></span><span id="extension-NoInterruptibleFFI"></span><span class="sig-name descname"><span class="pre">InterruptibleFFI</span></span><a class="headerlink" href="#extension-InterruptibleFFI" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.2.1</p>
</dd>
</dl>
</dd></dl>

<p>This concerns the interaction of foreign calls with
<code class="docutils literal notranslate"><span class="pre">Control.Concurrent.throwTo</span></code>. Normally when the target of a
<code class="docutils literal notranslate"><span class="pre">throwTo</span></code> is involved in a foreign call, the exception is not raised
until the call returns, and in the meantime the caller is blocked. This
can result in unresponsiveness, which is particularly undesirable in the
case of user interrupt (e.g. Control-C). The default behaviour when a
Control-C signal is received (<code class="docutils literal notranslate"><span class="pre">SIGINT</span></code> on Unix) is to raise the
<code class="docutils literal notranslate"><span class="pre">UserInterrupt</span></code> exception in the main thread; if the main thread is
blocked in a foreign call at the time, then the program will not respond
to the user interrupt.</p>
<p>The problem is that it is not possible in general to interrupt a foreign
call safely. However, GHC does provide a way to interrupt blocking
<em>system</em> calls which works for most system calls on both Unix and Windows.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">InterruptibleFFI</span></code> extension is enabled, a foreign call can
be annotated with <code class="docutils literal notranslate"><span class="pre">interruptible</span></code> instead of <code class="docutils literal notranslate"><span class="pre">safe</span></code> or <code class="docutils literal notranslate"><span class="pre">unsafe</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foreign</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="nn">ccall</span><span class="w"> </span><span class="n">interruptible</span><span class="w"></span>
<span class="w">   </span><span class="s">&quot;sleep&quot;</span><span class="w"> </span><span class="n">sleepBlock</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CUint</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">CUint</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">interruptible</span></code> behaves exactly as <code class="docutils literal notranslate"><span class="pre">safe</span></code>, except that when a
<code class="docutils literal notranslate"><span class="pre">throwTo</span></code> is directed at a thread in an interruptible foreign call,
irrespective of the masking state, the exception is added to the blocked
exceptions queue of the target thread and an OS-specific mechanism will be
used to attempt to cause the foreign call to return:</p>
<dl class="simple">
<dt>Unix systems</dt><dd><p>The thread making the foreign call is sent a <code class="docutils literal notranslate"><span class="pre">SIGPIPE</span></code> signal
using <code class="docutils literal notranslate"><span class="pre">pthread_kill()</span></code>. This is usually enough to cause a blocking
system call to return with <code class="docutils literal notranslate"><span class="pre">EINTR</span></code> (GHC by default installs an
empty signal handler for <code class="docutils literal notranslate"><span class="pre">SIGPIPE</span></code>, to override the default
behaviour which is to terminate the process immediately).</p>
</dd>
<dt>Windows systems</dt><dd><p>[Vista and later only] The RTS calls the Win32 function
<code class="docutils literal notranslate"><span class="pre">CancelSynchronousIo</span></code>, which will cause a blocking I/O operation
to return with the error <code class="docutils literal notranslate"><span class="pre">ERROR_OPERATION_ABORTED</span></code>.</p>
</dd>
</dl>
<p>Once the system call is successfully interrupted, the surrounding
code must return control out of the <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span></code>, back into Haskell code,
so that any blocked exception can be raised if the masking state
of the thread allows it. Being under mask gives the Haskell code an opportunity
to detect and react to the interrupt error code from the c call.</p>
<p>If the foreign code simply retries the system call directly without returning
back to Haskell, then the intended effect of <cite>interruptible</cite> disappears
and functions like <a class="reference external" href="../../libraries/base-4.16.3.0/System-Timeout.html#v:timeout">System.Timeout.timeout</a> will not work.</p>
<p>Finally, after the <code class="docutils literal notranslate"><span class="pre">interruptible</span></code> foreign call returns into Haskell, the
Haskell code should allow exceptions to be raised
(<code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code>’s <code class="docutils literal notranslate"><span class="pre">allowInterrupt</span></code>, or <code class="docutils literal notranslate"><span class="pre">interruptible</span> <span class="pre">yield</span></code>
for non-<code class="docutils literal notranslate"><span class="pre">-threaded</span></code>, see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/8684">https://gitlab.haskell.org/ghc/ghc/issues/8684</a>),
and implement the <code class="docutils literal notranslate"><span class="pre">EINTR</span></code>-retrying in Haskell
(e.g. using e.g. <a class="reference external" href="../../libraries/base-4.16.3.0/Foreign-C-Error.html#v:throwErrnoIfMinus1Retry">Foreign.C.Error.throwErrnoIfMinus1Retry</a>).</p>
<p>Be especially careful when using <code class="docutils literal notranslate"><span class="pre">interruptible</span></code> to check that
the called foreign function is prepared to deal with the consequences
of the call being interrupted.
On Unix it is considered good practice to always check for <code class="docutils literal notranslate"><span class="pre">EINTR</span></code> after
system calls, so you can expect it not to crash (but in that case
<code class="docutils literal notranslate"><span class="pre">interruptible</span></code> will not work as intended unless the code then returns
all the way up to Haskell as described above).
But on Windows it is not typically common practice to handle
<code class="docutils literal notranslate"><span class="pre">ERROR_OPERATION_ABORTED</span></code>.</p>
<p>The approach works <em>only</em> for foreign code that does I/O (system calls),
not for CPU-intensive computations that do not do any system calls.
This is because the only way by which the foreign code can observe
interruption is by system calls returning interruption error codes.
To be able to interrupt long-running foreign code doing no system calls,
the code must likely be changed to explicitly check for intended
early termination.</p>
</section>
<section id="the-capi-calling-convention">
<span id="ffi-capi"></span><h3><span class="section-number">6.17.2.6. </span>The CAPI calling convention<a class="headerlink" href="#the-capi-calling-convention" title="Permalink to this heading">¶</a></h3>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-CApiFFI">
<span id="ghc-flag--XCApiFFI"></span><span id="extension-NoCApiFFI"></span><span class="sig-name descname"><span class="pre">CApiFFI</span></span><a class="headerlink" href="#extension-CApiFFI" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.6.1</p>
</dd>
</dl>
</dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">CApiFFI</span></code> extension allows a calling convention of <code class="docutils literal notranslate"><span class="pre">capi</span></code> to be
used in foreign declarations, e.g.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foreign</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="nn">capi</span><span class="w"> </span><span class="s">&quot;header.h f&quot;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CInt</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">CInt</span><span class="w"></span>
</pre></div>
</div>
<p>Rather than generating code to call <code class="docutils literal notranslate"><span class="pre">f</span></code> according to the platform’s
ABI, we instead call <code class="docutils literal notranslate"><span class="pre">f</span></code> using the C API defined in the header
<code class="docutils literal notranslate"><span class="pre">header.h</span></code>. Thus <code class="docutils literal notranslate"><span class="pre">f</span></code> can be called even if it may be defined as a
CPP <code class="docutils literal notranslate"><span class="pre">#define</span></code> rather than a proper function.</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">capi</span></code>, it is also possible to import values, rather than
functions. For example,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foreign</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="nn">capi</span><span class="w"> </span><span class="s">&quot;pi.h value pi&quot;</span><span class="w"> </span><span class="n">c_pi</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CDouble</span><span class="w"></span>
</pre></div>
</div>
<p>will work regardless of whether <code class="docutils literal notranslate"><span class="pre">pi</span></code> is defined as</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>or with</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define pi 3.14</span>
</pre></div>
</div>
<p>In order to tell GHC the C type that a Haskell type corresponds to when
it is used with the CAPI, a <code class="docutils literal notranslate"><span class="pre">CTYPE</span></code> pragma can be used on the type
definition. The header which defines the type can optionally also be
specified. The syntax looks like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w">    </span><span class="cm">{-# CTYPE &quot;unistd.h&quot; &quot;useconds_t&quot; #-}</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="cm">{-# CTYPE            &quot;useconds_t&quot; #-}</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="hs-thread-done">
<h3><span class="section-number">6.17.2.7. </span><code class="docutils literal notranslate"><span class="pre">hs_thread_done()</span></code><a class="headerlink" href="#hs-thread-done" title="Permalink to this heading">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">hs_thread_done</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>GHC allocates a small amount of thread-local memory when a thread calls
a Haskell function via a <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">export</span></code>. This memory is not normally
freed until <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code>; the memory is cached so that subsequent calls
into Haskell are fast. However, if your application is long-running and
repeatedly creates new threads that call into Haskell, you probably want
to arrange that this memory is freed in those threads that have finished
calling Haskell functions. To do this, call <code class="docutils literal notranslate"><span class="pre">hs_thread_done()</span></code> from
the thread whose memory you want to free.</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">hs_thread_done()</span></code> is entirely optional. You can call it as
often or as little as you like. It is safe to call it from a thread that
has never called any Haskell functions, or one that never will. If you
forget to call it, the worst that can happen is that some memory remains
allocated until <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code> is called. If you call it too often, the
worst that can happen is that the next call to a Haskell function incurs
some extra overhead.</p>
</section>
<section id="freeing-many-stable-pointers-efficiently">
<span id="ffi-stable-ptr-extras"></span><h3><span class="section-number">6.17.2.8. </span>Freeing many stable pointers efficiently<a class="headerlink" href="#freeing-many-stable-pointers-efficiently" title="Permalink to this heading">¶</a></h3>
<p>The standard function <code class="docutils literal notranslate"><span class="pre">hs_free_stable_ptr</span></code> locks the stable pointer
table, frees the given stable pointer, and then unlocks the stable pointer
table again. When freeing many stable pointers at once, it is usually
more efficient to lock and unlock the table only once.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hs_lock_stable_ptr_table</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hs_unlock_stable_ptr_table</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hs_free_stable_ptr_unsafe</span><span class="w"> </span><span class="p">(</span><span class="n">HsStablePtr</span><span class="w"> </span><span class="n">sp</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">hs_free_stable_ptr_unsafe</span></code> must be used <em>only</em> when the table has been
locked using <code class="docutils literal notranslate"><span class="pre">hs_lock_stable_ptr_table</span></code>. It must be unlocked afterwards
using <code class="docutils literal notranslate"><span class="pre">hs_unlock_stable_ptr_table</span></code>. The Haskell garbage collector cannot
run while the table is locked, so it should be unlocked promptly. The
following operations are forbidden while the stable pointer table is locked:</p>
<ul class="simple">
<li><p>Calling any Haskell function, whether or not that function
manipulates stable pointers.</p></li>
<li><p>Calling any FFI function that deals with the stable pointer table
except for arbitrarily many calls to <code class="docutils literal notranslate"><span class="pre">hs_free_stable_ptr_unsafe</span></code>
and the final call to <code class="docutils literal notranslate"><span class="pre">hs_unlock_stable_ptr_table</span></code>.</p></li>
<li><p>Calling <code class="docutils literal notranslate"><span class="pre">hs_free_fun_ptr</span></code>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>GHC versions before 8.8 defined undocumented functions
<code class="docutils literal notranslate"><span class="pre">hs_lock_stable_tables</span></code> and <code class="docutils literal notranslate"><span class="pre">hs_unlock_stable_tables</span></code> instead
of <code class="docutils literal notranslate"><span class="pre">hs_lock_stable_ptr_table</span></code> and <code class="docutils literal notranslate"><span class="pre">hs_unlock_stable_ptr_table</span></code>.
Those names are now deprecated.</p>
</div>
</section>
</section>
<section id="using-the-ffi-with-ghc">
<span id="ffi-ghc"></span><h2><span class="section-number">6.17.3. </span>Using the FFI with GHC<a class="headerlink" href="#using-the-ffi-with-ghc" title="Permalink to this heading">¶</a></h2>
<p>The following sections also give some hints and tips on the use of the
foreign function interface in GHC.</p>
<section id="using-foreign-export-and-foreign-import-ccall-wrapper-with-ghc">
<span id="foreign-export-ghc"></span><h3><span class="section-number">6.17.3.1. </span>Using <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">export</span></code> and <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">ccall</span> <span class="pre">&quot;wrapper&quot;</span></code> with GHC<a class="headerlink" href="#using-foreign-export-and-foreign-import-ccall-wrapper-with-ghc" title="Permalink to this heading">¶</a></h3>
<p id="index-1">When GHC compiles a module (say <code class="docutils literal notranslate"><span class="pre">M.hs</span></code>) which uses <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">export</span></code>
or <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">&quot;wrapper&quot;</span></code>, it generates a <code class="docutils literal notranslate"><span class="pre">M_stub.h</span></code> for use by
C programs.</p>
<p>For a plain <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">export</span></code>, the file <code class="docutils literal notranslate"><span class="pre">M_stub.h</span></code> contains a C
prototype for the foreign exported function. For example, if we compile
the following module:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Foo</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="nf">foreign</span><span class="w"> </span><span class="n">export</span><span class="w"> </span><span class="n">ccall</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>

<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="kt">:</span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>Then <code class="docutils literal notranslate"><span class="pre">Foo_stub.h</span></code> will contain something like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;HsFFI.h&quot;</span><span class="cp"></span>
<span class="k">extern</span><span class="w"> </span><span class="n">HsInt</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">HsInt</span><span class="w"> </span><span class="n">a0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>To invoke <code class="docutils literal notranslate"><span class="pre">foo()</span></code> from C, just <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;Foo_stub.h&quot;</span></code> and call
<code class="docutils literal notranslate"><span class="pre">foo()</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Foo_stub.h</span></code> file can be redirected using the <code class="docutils literal notranslate"><span class="pre">-stubdir</span></code> option;
see <a class="reference internal" href="../separate_compilation.html#options-output"><span class="std std-ref">Redirecting the compilation output(s)</span></a>.</p>
<section id="using-your-own-main">
<span id="using-own-main"></span><h4><span class="section-number">6.17.3.1.1. </span>Using your own <code class="docutils literal notranslate"><span class="pre">main()</span></code><a class="headerlink" href="#using-your-own-main" title="Permalink to this heading">¶</a></h4>
<p>Normally, GHC’s runtime system provides a <code class="docutils literal notranslate"><span class="pre">main()</span></code>, which arranges to
invoke <code class="docutils literal notranslate"><span class="pre">Main.main</span></code> in the Haskell program. However, you might want to
link some Haskell code into a program which has a main function written
in another language, say C. In order to do this, you have to initialize
the Haskell runtime system explicitly.</p>
<p>Let’s take the example from above, and invoke it from a standalone C
program. Here’s the C code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;HsFFI.h&quot;</span><span class="cp"></span>

<span class="cp">#if defined(__GLASGOW_HASKELL__)</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Foo_stub.h&quot;</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">hs_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="mi">2500</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">hs_exit</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>We’ve surrounded the GHC-specific bits with
<code class="docutils literal notranslate"><span class="pre">#if</span> <span class="pre">defined(__GLASGOW_HASKELL__)</span></code>; the rest of the code should be portable
across Haskell implementations that support the FFI standard.</p>
<p>The call to <code class="docutils literal notranslate"><span class="pre">hs_init()</span></code> initializes GHC’s runtime system. Do NOT try
to invoke any Haskell functions before calling <code class="docutils literal notranslate"><span class="pre">hs_init()</span></code>: bad things
will undoubtedly happen.</p>
<p>We pass references to <code class="docutils literal notranslate"><span class="pre">argc</span></code> and <code class="docutils literal notranslate"><span class="pre">argv</span></code> to <code class="docutils literal notranslate"><span class="pre">hs_init()</span></code> so that it
can separate out any arguments for the RTS (i.e. those arguments between
<code class="docutils literal notranslate"><span class="pre">+RTS...-RTS</span></code>).</p>
<p>After we’ve finished invoking our Haskell functions, we can call
<code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code>, which terminates the RTS.</p>
<p>There can be multiple calls to <code class="docutils literal notranslate"><span class="pre">hs_init()</span></code>, but each one should be matched by
one (and only one) call to <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code>. The outermost <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code> will
actually de-initialise the system.  Note that currently GHC’s runtime cannot
reliably re-initialise after this has happened; see <a class="reference internal" href="../bugs.html#infelicities-ffi"><span class="std std-ref">The Foreign Function Interface</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When linking the final program, it is normally easiest to do the
link using GHC, although this isn’t essential. If you do use GHC, then
don’t forget the flag <a class="reference internal" href="../phases.html#ghc-flag-no-hs-main"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-no-hs-main</span></code></a>, otherwise GHC
will try to link to the <code class="docutils literal notranslate"><span class="pre">Main</span></code> Haskell module.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On Windows hs_init treats argv as UTF8-encoded. Passing other encodings
might lead to unexpected results. Passing NULL as argv is valid but can
lead to &lt;unknown&gt; showing up in error messages instead of the name of the
executable.</p>
</div>
<p>To use <code class="docutils literal notranslate"><span class="pre">+RTS</span></code> flags with <code class="docutils literal notranslate"><span class="pre">hs_init()</span></code>, we have to modify the example
slightly. By default, GHC’s RTS will only accept “safe” <code class="docutils literal notranslate"><span class="pre">+RTS</span></code> flags (see
<a class="reference internal" href="../phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a>), and the <a class="reference internal" href="../phases.html#ghc-flag-rtsopts-none-some-all-ignore-ignoreAll"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]</span></code></a>
link-time flag overrides this. However,
<a class="reference internal" href="../phases.html#ghc-flag-rtsopts-none-some-all-ignore-ignoreAll"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]</span></code></a> has no effect when
<a class="reference internal" href="../phases.html#ghc-flag-no-hs-main"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-no-hs-main</span></code></a> is in use (and the same goes for
<a class="reference internal" href="../phases.html#ghc-flag-with-rtsopts-opts"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-with-rtsopts=⟨opts⟩</span></code></a>). To set these options we have to call a
GHC-specific API instead of <code class="docutils literal notranslate"><span class="pre">hs_init()</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;HsFFI.h&quot;</span><span class="cp"></span>

<span class="cp">#if defined(__GLASGOW_HASKELL__)</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Foo_stub.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Rts.h&quot;</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="cp">#if __GLASGOW_HASKELL__ &gt;= 703</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">RtsConfig</span><span class="w"> </span><span class="n">conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">defaultRtsConfig</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">conf</span><span class="p">.</span><span class="n">rts_opts_enabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RtsOptsAll</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">hs_init_ghc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argv</span><span class="p">,</span><span class="w"> </span><span class="n">conf</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">  </span><span class="n">hs_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="mi">2500</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">hs_exit</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Note two changes: we included <code class="docutils literal notranslate"><span class="pre">Rts.h</span></code>, which defines the GHC-specific
external RTS interface, and we called <code class="docutils literal notranslate"><span class="pre">hs_init_ghc()</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">hs_init()</span></code>, passing an argument of type <code class="docutils literal notranslate"><span class="pre">RtsConfig</span></code>. <code class="docutils literal notranslate"><span class="pre">RtsConfig</span></code>
is a struct with various fields that affect the behaviour of the runtime
system. Its definition is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">RtsOptsEnabledEnum</span><span class="w"> </span><span class="n">rts_opts_enabled</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">rts_opts</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">RtsConfig</span><span class="p">;</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">RtsConfig</span><span class="w"> </span><span class="n">defaultRtsConfig</span><span class="p">;</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">RtsOptsNone</span><span class="p">,</span><span class="w">         </span><span class="c1">// +RTS causes an error</span>
<span class="w">    </span><span class="n">RtsOptsSafeOnly</span><span class="p">,</span><span class="w">     </span><span class="c1">// safe RTS options allowed; others cause an error</span>
<span class="w">    </span><span class="n">RtsOptsAll</span><span class="w">           </span><span class="c1">// all RTS options allowed</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">RtsOptsEnabledEnum</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>There is a default value <code class="docutils literal notranslate"><span class="pre">defaultRtsConfig</span></code> that should be used to
initialise variables of type <code class="docutils literal notranslate"><span class="pre">RtsConfig</span></code>. More fields will undoubtedly
be added to <code class="docutils literal notranslate"><span class="pre">RtsConfig</span></code> in the future, so in order to keep your code
forwards-compatible it is best to initialise with <code class="docutils literal notranslate"><span class="pre">defaultRtsConfig</span></code>
and then modify the required fields, as in the code sample above.</p>
</section>
<section id="making-a-haskell-library-that-can-be-called-from-foreign-code">
<span id="ffi-library"></span><h4><span class="section-number">6.17.3.1.2. </span>Making a Haskell library that can be called from foreign code<a class="headerlink" href="#making-a-haskell-library-that-can-be-called-from-foreign-code" title="Permalink to this heading">¶</a></h4>
<p>The scenario here is much like in <a class="reference internal" href="#using-own-main"><span class="std std-ref">Using your own main()</span></a>, except that the
aim is not to link a complete program, but to make a library from
Haskell code that can be deployed in the same way that you would deploy
a library of C code.</p>
<p>The main requirement here is that the runtime needs to be initialized
before any Haskell code can be called, so your library should provide
initialisation and deinitialisation entry points, implemented in C or
C++. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;HsFFI.h&quot;</span><span class="cp"></span>

<span class="n">HsBool</span><span class="w"> </span><span class="nf">mylib_init</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;mylib&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;+RTS&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-A32m&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">pargv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Initialize Haskell runtime</span>
<span class="w">  </span><span class="n">hs_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pargv</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// do any other initialization here and</span>
<span class="w">  </span><span class="c1">// return false if there was a problem</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">HS_BOOL_TRUE</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">mylib_end</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="n">hs_exit</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The initialisation routine, <code class="docutils literal notranslate"><span class="pre">mylib_init</span></code>, calls <code class="docutils literal notranslate"><span class="pre">hs_init()</span></code> as
normal to initialise the Haskell runtime, and the corresponding
deinitialisation function <code class="docutils literal notranslate"><span class="pre">mylib_end()</span></code> calls <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code> to shut
down the runtime.</p>
</section>
</section>
<section id="using-header-files">
<span id="glasgow-foreign-headers"></span><h3><span class="section-number">6.17.3.2. </span>Using header files<a class="headerlink" href="#using-header-files" title="Permalink to this heading">¶</a></h3>
<p id="index-2">C functions are normally declared using prototypes in a C header file.
Earlier versions of GHC (6.8.3 and earlier) <code class="docutils literal notranslate"><span class="pre">#include</span></code>d the header
file in the C source file generated from the Haskell code, and the C
compiler could therefore check that the C function being called via the
FFI was being called at the right type.</p>
<p>GHC no longer includes external header files when compiling via C, so
this checking is not performed. The change was made for compatibility
with the <a class="reference internal" href="../codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> (<a class="reference internal" href="../phases.html#ghc-flag--fllvm"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fasm</span></code></a>) and to
comply strictly with the FFI specification, which requires that FFI calls are
not subject to macro expansion and other CPP conversions that may be applied
when using C header files. This approach also simplifies the inlining of foreign
calls across module and package boundaries: there’s no need for the header file
to be available when compiling an inlined version of a foreign call, so the
compiler is free to inline foreign calls in any context.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">-#include</span></code> option is now deprecated, and the <code class="docutils literal notranslate"><span class="pre">include-files</span></code>
field in a Cabal package specification is ignored.</p>
</section>
<section id="memory-allocation">
<h3><span class="section-number">6.17.3.3. </span>Memory Allocation<a class="headerlink" href="#memory-allocation" title="Permalink to this heading">¶</a></h3>
<p>The FFI libraries provide several ways to allocate memory for use with
the FFI, and it isn’t always clear which way is the best. This decision
may be affected by how efficient a particular kind of allocation is on a
given compiler/platform, so this section aims to shed some light on how
the different kinds of allocation perform with GHC.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">alloca</span></code></dt><dd><p>Useful for short-term allocation when the allocation is intended to
scope over a given <code class="docutils literal notranslate"><span class="pre">IO</span></code> computation. This kind of allocation is
commonly used when marshalling data to and from FFI functions.</p>
<p>In GHC, <code class="docutils literal notranslate"><span class="pre">alloca</span></code> is implemented using <code class="docutils literal notranslate"><span class="pre">MutableByteArray#</span></code>, so
allocation and deallocation are fast: much faster than C’s
<code class="docutils literal notranslate"><span class="pre">malloc/free</span></code>, but not quite as fast as stack allocation in C. Use
<code class="docutils literal notranslate"><span class="pre">alloca</span></code> whenever you can.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mallocForeignPtr</span></code></dt><dd><p>Useful for longer-term allocation which requires garbage collection.
If you intend to store the pointer to the memory in a foreign data
structure, then <code class="docutils literal notranslate"><span class="pre">mallocForeignPtr</span></code> is <em>not</em> a good choice,
however.</p>
<p>In GHC, <code class="docutils literal notranslate"><span class="pre">mallocForeignPtr</span></code> is also implemented using
<code class="docutils literal notranslate"><span class="pre">MutableByteArray#</span></code>. Although the memory is pointed to by a
<code class="docutils literal notranslate"><span class="pre">ForeignPtr</span></code>, there are no actual finalizers involved (unless you
add one with <code class="docutils literal notranslate"><span class="pre">addForeignPtrFinalizer</span></code>), and the deallocation is
done using GC, so <code class="docutils literal notranslate"><span class="pre">mallocForeignPtr</span></code> is normally very cheap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">malloc/free</span></code></dt><dd><p>If all else fails, then you need to resort to <code class="docutils literal notranslate"><span class="pre">Foreign.malloc</span></code> and
<code class="docutils literal notranslate"><span class="pre">Foreign.free</span></code>. These are just wrappers around the C functions of
the same name, and their efficiency will depend ultimately on the
implementations of these functions in your platform’s C library. We
usually find <code class="docutils literal notranslate"><span class="pre">malloc</span></code> and <code class="docutils literal notranslate"><span class="pre">free</span></code> to be significantly slower than
the other forms of allocation above.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Foreign.Marshal.Pool</span></code></dt><dd><p>Pools are currently implemented using <code class="docutils literal notranslate"><span class="pre">malloc/free</span></code>, so while they
might be a more convenient way to structure your memory allocation
than using one of the other forms of allocation, they won’t be any
more efficient. We do plan to provide an improved-performance
implementation of Pools in the future, however.</p>
</dd>
</dl>
</section>
<section id="multi-threading-and-the-ffi">
<span id="ffi-threads"></span><h3><span class="section-number">6.17.3.4. </span>Multi-threading and the FFI<a class="headerlink" href="#multi-threading-and-the-ffi" title="Permalink to this heading">¶</a></h3>
<p>In order to use the FFI in a multi-threaded setting, you must use the
<a class="reference internal" href="../phases.html#ghc-flag-threaded"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-threaded</span></code></a> option (see <a class="reference internal" href="../phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a>).</p>
<section id="foreign-imports-and-multi-threading">
<h4><span class="section-number">6.17.3.4.1. </span>Foreign imports and multi-threading<a class="headerlink" href="#foreign-imports-and-multi-threading" title="Permalink to this heading">¶</a></h4>
<p>When you call a <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span></code>ed function that is annotated as
<code class="docutils literal notranslate"><span class="pre">safe</span></code> (the default), and the program was linked using <a class="reference internal" href="../phases.html#ghc-flag-threaded"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-threaded</span></code></a>,
then the call will run concurrently with other running Haskell threads.
If the program was linked without <a class="reference internal" href="../phases.html#ghc-flag-threaded"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-threaded</span></code></a>, then the other Haskell
threads will be blocked until the call returns.</p>
<p>This means that if you need to make a foreign call to a function that
takes a long time or blocks indefinitely, then you should mark it
<code class="docutils literal notranslate"><span class="pre">safe</span></code> and use <a class="reference internal" href="../phases.html#ghc-flag-threaded"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-threaded</span></code></a>. Some library functions make such calls
internally; their documentation should indicate when this is the case.</p>
<p>If you are making foreign calls from multiple Haskell threads and using
<a class="reference internal" href="../phases.html#ghc-flag-threaded"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-threaded</span></code></a>, make sure that the foreign code you are calling is
thread-safe. In particularly, some GUI libraries are not thread-safe and
require that the caller only invokes GUI methods from a single thread.
If this is the case, you may need to restrict your GUI operations to a
single Haskell thread, and possibly also use a bound thread (see
<a class="reference internal" href="#haskell-threads-and-os-threads"><span class="std std-ref">The relationship between Haskell threads and OS threads</span></a>).</p>
<p>Note that foreign calls made by different Haskell threads may execute in
<em>parallel</em>, even when the <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-N</span></code> flag is not being used
(<a class="reference internal" href="../using-concurrent.html#parallel-options"><span class="std std-ref">RTS options for SMP parallelism</span></a>). The <a class="reference internal" href="../using-concurrent.html#rts-flag-N-x"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-N</span> <span class="pre">⟨x⟩</span></code></a> flag controls parallel
execution of Haskell threads, but there may be an arbitrary number of
foreign calls in progress at any one time, regardless of the <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-N</span></code>
value.</p>
<p>If a call is annotated as <code class="docutils literal notranslate"><span class="pre">interruptible</span></code> and the program was
multithreaded, the call may be interrupted in the event that the Haskell
thread receives an exception. The mechanism by which the interrupt
occurs is platform dependent, but is intended to cause blocking system
calls to return immediately with an interrupted error code. The
underlying operating system thread is not to be destroyed. See
<a class="reference internal" href="#ffi-interruptible"><span class="std std-ref">Interruptible foreign calls</span></a> for more details.</p>
</section>
<section id="the-relationship-between-haskell-threads-and-os-threads">
<span id="haskell-threads-and-os-threads"></span><h4><span class="section-number">6.17.3.4.2. </span>The relationship between Haskell threads and OS threads<a class="headerlink" href="#the-relationship-between-haskell-threads-and-os-threads" title="Permalink to this heading">¶</a></h4>
<p>Normally there is no fixed relationship between Haskell threads and OS
threads. This means that when you make a foreign call, that call may
take place in an unspecified OS thread. Furthermore, there is no
guarantee that multiple calls made by one Haskell thread will be made by
the same OS thread.</p>
<p>This usually isn’t a problem, and it allows the GHC runtime system to
make efficient use of OS thread resources. However, there are cases
where it is useful to have more control over which OS thread is used,
for example when calling foreign code that makes use of thread-local
state. For cases like this, we provide <em>bound threads</em>, which are
Haskell threads tied to a particular OS thread. For information on bound
threads, see the documentation for the <a class="reference external" href="../../libraries/base-4.16.3.0/Control-Concurrent.html">Control.Concurrent</a> module.</p>
</section>
<section id="foreign-exports-and-multi-threading">
<h4><span class="section-number">6.17.3.4.3. </span>Foreign exports and multi-threading<a class="headerlink" href="#foreign-exports-and-multi-threading" title="Permalink to this heading">¶</a></h4>
<p>When the program is linked with <a class="reference internal" href="../phases.html#ghc-flag-threaded"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-threaded</span></code></a>, then you may invoke
<code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">export</span></code>ed functions from multiple OS threads concurrently.
The runtime system must be initialised as usual by calling
<code class="docutils literal notranslate"><span class="pre">hs_init()</span></code>, and this call must complete before invoking any
<code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">export</span></code>ed functions.</p>
</section>
<section id="on-the-use-of-hs-exit">
<span id="hs-exit"></span><h4><span class="section-number">6.17.3.4.4. </span>On the use of <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code><a class="headerlink" href="#on-the-use-of-hs-exit" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code> normally causes the termination of any running Haskell
threads in the system, and when <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code> returns, there will be no
more Haskell threads running. The runtime will then shut down the system
in an orderly way, generating profiling output and statistics if
necessary, and freeing all the memory it owns.</p>
<p>It isn’t always possible to terminate a Haskell thread forcibly: for
example, the thread might be currently executing a foreign call, and we
have no way to force the foreign call to complete. What’s more, the
runtime must assume that in the worst case the Haskell code and runtime
are about to be removed from memory (e.g. if this is a
<a class="reference internal" href="../win32-dlls.html#win32-dlls"><span class="std std-ref">Windows DLL</span></a>, <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code> is normally called before unloading
the DLL). So <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code> <em>must</em> wait until all outstanding foreign
calls return before it can return itself.</p>
<p>The upshot of this is that if you have Haskell threads that are blocked
in foreign calls, then <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code> may hang (or possibly busy-wait)
until the calls return. Therefore it’s a good idea to make sure you
don’t have any such threads in the system when calling <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code>.
This includes any threads doing I/O, because I/O may (or may not,
depending on the type of I/O and the platform) be implemented using
blocking foreign calls.</p>
<p>The GHC runtime treats program exit as a special case, to avoid the need
to wait for blocked threads when a standalone executable exits. Since
the program and all its threads are about to terminate at the same time
that the code is removed from memory, it isn’t necessary to ensure that
the threads have exited first.  If you want this fast and loose
version of <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code>, you can call:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">hs_exit_nowait</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>instead.  This is particularly useful if you have foreign libraries
that need to call <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code> at program exit (perhaps via a C++
destructor): in this case you should use <code class="docutils literal notranslate"><span class="pre">hs_exit_nowait()</span></code>, because
the thread that called <code class="docutils literal notranslate"><span class="pre">exit()</span></code> and is running C++ destructors is in
a foreign call from Haskell that will never return, so <code class="docutils literal notranslate"><span class="pre">hs_exit()</span></code>
would deadlock.</p>
</section>
<section id="waking-up-haskell-threads-from-c">
<span id="hs-try-putmvar"></span><h4><span class="section-number">6.17.3.4.5. </span>Waking up Haskell threads from C<a class="headerlink" href="#waking-up-haskell-threads-from-c" title="Permalink to this heading">¶</a></h4>
<p>Sometimes we want to be able to wake up a Haskell thread from some C
code.  For example, when using a callback-based C API, we register a C
callback and then we need to wait for the callback to run.</p>
<p>One way to do this is to create a <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">export</span></code> that will do
whatever needs to be done to wake up the Haskell thread - perhaps
<code class="docutils literal notranslate"><span class="pre">putMVar</span></code> - and then call this from our C callback.  There are a
couple of problems with this:</p>
<ol class="arabic simple">
<li><p>Calling a foreign export has a lot of overhead: it creates a
complete new Haskell thread, for example.</p></li>
<li><p>The call may block for a long time if a GC is in progress.  We
can’t use this method if the C API we’re calling doesn’t allow
blocking in the callback.</p></li>
</ol>
<p>For these reasons GHC provides an external API to <code class="docutils literal notranslate"><span class="pre">tryPutMVar</span></code>,
<code class="docutils literal notranslate"><span class="pre">hs_try_putmvar</span></code>, which you can use to cheaply and asynchronously
wake up a Haskell thread from C/C++.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">hs_try_putmvar</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">capability</span><span class="p">,</span><span class="w"> </span><span class="n">HsStablePtr</span><span class="w"> </span><span class="n">sp</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The C call <code class="docutils literal notranslate"><span class="pre">hs_try_putmvar(cap,</span> <span class="pre">mvar)</span></code> is equivalent to the Haskell
call <code class="docutils literal notranslate"><span class="pre">tryPutMVar</span> <span class="pre">mvar</span> <span class="pre">()</span></code>, except that it is</p>
<ul class="simple">
<li><p>non-blocking: takes a bounded, short, amount of time</p></li>
<li><p>asynchronous: the actual putMVar may be performed after the call
returns (for example, if the RTS is currently garbage collecting).
That’s why <code class="docutils literal notranslate"><span class="pre">hs_try_putmvar()</span></code> doesn’t return a result to say
whether the put succeeded.  It is your responsibility to ensure that
the <code class="docutils literal notranslate"><span class="pre">MVar</span></code> is empty; if it is full, <code class="docutils literal notranslate"><span class="pre">hs_try_putmvar()</span></code> will have
no effect.</p></li>
</ul>
<p><strong>Example</strong>. Suppose we have a C/C++ function to call that will return and then
invoke a callback at some point in the future, passing us some data.
We want to wait in Haskell for the callback to be called, and retrieve
the data.  We can do it like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Conc</span><span class="w"> </span><span class="p">(</span><span class="nf">newStablePtrPrimMVar</span><span class="p">,</span><span class="w"> </span><span class="kt">PrimMVar</span><span class="p">)</span><span class="w"></span>

<span class="nf">makeExternalCall</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mask_</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">mvar</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">newEmptyMVar</span><span class="w"></span>
<span class="w">  </span><span class="n">sp</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">newStablePtrPrimMVar</span><span class="w"> </span><span class="n">mvar</span><span class="w"></span>
<span class="w">  </span><span class="n">fp</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mallocForeignPtr</span><span class="w"></span>
<span class="w">  </span><span class="n">withForeignPtr</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">presult</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">cap</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">threadCapability</span><span class="w"> </span><span class="o">=&lt;&lt;</span><span class="w"> </span><span class="n">myThreadId</span><span class="w"></span>
<span class="w">    </span><span class="n">scheduleCallback</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="n">cap</span><span class="w"> </span><span class="n">presult</span><span class="w"></span>
<span class="w">    </span><span class="n">takeMVar</span><span class="w"> </span><span class="n">mvar</span><span class="w"> </span><span class="p">`</span><span class="n">onException</span><span class="p">`</span><span class="w"></span>
<span class="w">      </span><span class="n">forkIO</span><span class="w"> </span><span class="p">(</span><span class="kr">do</span><span class="w"> </span><span class="n">takeMVar</span><span class="w"> </span><span class="n">mvar</span><span class="p">;</span><span class="w"> </span><span class="n">touchForeignPtr</span><span class="w"> </span><span class="n">fp</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">peek</span><span class="w"> </span><span class="n">presult</span><span class="w"></span>

<span class="nf">foreign</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="nn">ccall</span><span class="w"> </span><span class="s">&quot;scheduleCallback&quot;</span><span class="w"></span>
<span class="w">    </span><span class="n">scheduleCallback</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">StablePtr</span><span class="w"> </span><span class="kt">PrimMVar</span><span class="w"></span>
<span class="w">                     </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">                     </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Ptr</span><span class="w"> </span><span class="kt">Result</span><span class="w"></span>
<span class="w">                     </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
</pre></div>
</div>
<p>And inside <code class="docutils literal notranslate"><span class="pre">scheduleCallback</span></code>, we create a callback that will in due
course store the result data in the <code class="docutils literal notranslate"><span class="pre">Ptr</span> <span class="pre">Result</span></code>, and then call
<code class="docutils literal notranslate"><span class="pre">hs_try_putmvar()</span></code>.</p>
<p>There are a few things to note here.</p>
<ul>
<li><p>There’s a special function to create the <code class="docutils literal notranslate"><span class="pre">StablePtr</span></code>:
<code class="docutils literal notranslate"><span class="pre">newStablePtrPrimMVar</span></code>, because the RTS needs a <code class="docutils literal notranslate"><span class="pre">StablePtr</span></code> to
the primitive <code class="docutils literal notranslate"><span class="pre">MVar#</span></code> object, and we can’t create that directly.
Do <em>not</em> just use <code class="docutils literal notranslate"><span class="pre">newStablePtr</span></code> on the <code class="docutils literal notranslate"><span class="pre">MVar</span></code>: your program
will crash.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">StablePtr</span></code> is freed by <code class="docutils literal notranslate"><span class="pre">hs_try_putmvar()</span></code>.  This is because
it would otherwise be difficult to arrange to free the <code class="docutils literal notranslate"><span class="pre">StablePtr</span></code>
reliably: we can’t free it in Haskell, because if the <code class="docutils literal notranslate"><span class="pre">takeMVar</span></code>
is interrupted by an asynchronous exception, then the callback will
fire at a later time.  We can’t free it in C, because we don’t know
when to free it (not when <code class="docutils literal notranslate"><span class="pre">hs_try_putmvar()</span></code> returns, because that
is an async call that uses the <code class="docutils literal notranslate"><span class="pre">StablePtr</span></code> at some time in the
future).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">mask_</span></code> is to avoid asynchronous exceptions before the
<code class="docutils literal notranslate"><span class="pre">scheduleCallback</span></code> call, which would leak the <code class="docutils literal notranslate"><span class="pre">StablePtr</span></code>.</p></li>
<li><p>We find out the current capability number and pass it to C.  This is
passed back to <code class="docutils literal notranslate"><span class="pre">hs_try_putmvar</span></code>, and helps the RTS to know which
capability it should try to perform the <code class="docutils literal notranslate"><span class="pre">tryPutMVar</span></code> on.  If you
don’t care, you can pass <code class="docutils literal notranslate"><span class="pre">-1</span></code> for the capability to
<code class="docutils literal notranslate"><span class="pre">hs_try_putmvar</span></code>, and it will pick an arbitrary one.</p>
<p>Picking the right capability will help avoid unnecessary context
switches.  Ideally you should pass the capability that the thread
that will be woken up last ran on, which you can find by calling
<code class="docutils literal notranslate"><span class="pre">threadCapability</span></code> in Haskell.</p>
</li>
<li><p>If you want to also pass some data back from the C callback to
Haskell, this is best done by first allocating some memory in
Haskell to receive the data, and passing the address to C, as we did
in the above example.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">takeMVar</span></code> can be interrupted by an asynchronous exception.  If
this happens, the callback in C will still run at some point in the
future, will still write the result, and will still call
<code class="docutils literal notranslate"><span class="pre">hs_try_putmvar()</span></code>.  Therefore we have to arrange that the memory
for the result stays alive until the callback has run, so if an
exception is thrown during <code class="docutils literal notranslate"><span class="pre">takeMVar</span></code> we fork another thread to
wait for the callback and hold the memory alive using
<code class="docutils literal notranslate"><span class="pre">touchForeignPtr</span></code>.</p></li>
</ul>
<p>For a fully working example, see
<code class="docutils literal notranslate"><span class="pre">testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs</span></code> in the
GHC source tree.</p>
</section>
</section>
<section id="floating-point-and-the-ffi">
<span id="ffi-floating-point"></span><h3><span class="section-number">6.17.3.5. </span>Floating point and the FFI<a class="headerlink" href="#floating-point-and-the-ffi" title="Permalink to this heading">¶</a></h3>
<p id="index-3">The standard C99 <code class="docutils literal notranslate"><span class="pre">fenv.h</span></code> header provides operations for inspecting
and modifying the state of the floating point unit. In particular, the
rounding mode used by floating point operations can be changed, and the
exception flags can be tested.</p>
<p>In Haskell, floating-point operations have pure types, and the
evaluation order is unspecified. So strictly speaking, since the
<code class="docutils literal notranslate"><span class="pre">fenv.h</span></code> functions let you change the results of, or observe the
effects of floating point operations, use of <code class="docutils literal notranslate"><span class="pre">fenv.h</span></code> renders the
behaviour of floating-point operations anywhere in the program
undefined.</p>
<p>Having said that, we <em>can</em> document exactly what GHC does with respect
to the floating point state, so that if you really need to use
<code class="docutils literal notranslate"><span class="pre">fenv.h</span></code> then you can do so with full knowledge of the pitfalls:</p>
<ul class="simple">
<li><p>GHC completely ignores the floating-point environment, the runtime
neither modifies nor reads it.</p></li>
<li><p>The floating-point environment is not saved over a normal thread
context-switch. So if you modify the floating-point state in one
thread, those changes may be visible in other threads. Furthermore,
testing the exception state is not reliable, because a context switch
may change it. If you need to modify or test the floating point state
and use threads, then you must use bound threads
(<code class="docutils literal notranslate"><span class="pre">Control.Concurrent.forkOS</span></code>), because a bound thread has its own
OS thread, and OS threads do save and restore the floating-point
state.</p></li>
<li><p>It is safe to modify the floating-point unit state temporarily during
a foreign call, because foreign calls are never pre-empted by GHC.</p></li>
</ul>
</section>
<section id="pinned-byte-arrays">
<span id="id4"></span><h3><span class="section-number">6.17.3.6. </span>Pinned Byte Arrays<a class="headerlink" href="#pinned-byte-arrays" title="Permalink to this heading">¶</a></h3>
<p>A pinned byte array is one that the garbage collector is not allowed
to move. Consequently, it has a stable address that can be safely
requested with <code class="docutils literal notranslate"><span class="pre">byteArrayContents#</span></code>. There are a handful of
primitive functions in <a class="reference external" href="../../libraries/ghc-prim-0.8.0/GHC-Prim.html">GHC.Prim</a>
used to enforce or check for pinnedness: <code class="docutils literal notranslate"><span class="pre">isByteArrayPinned#</span></code>,
<code class="docutils literal notranslate"><span class="pre">isMutableByteArrayPinned#</span></code>, and <code class="docutils literal notranslate"><span class="pre">newPinnedByteArray#</span></code>. A
byte array can be pinned as a result of three possible causes:</p>
<ol class="arabic simple">
<li><p>It was allocated by <code class="docutils literal notranslate"><span class="pre">newPinnedByteArray#</span></code>.</p></li>
<li><p>It is large. Currently, GHC defines large object to be one
that is at least as large as 80% of a 4KB block (i.e. at
least 3277 bytes).</p></li>
<li><p>It has been copied into a compact region. The documentation
for <code class="docutils literal notranslate"><span class="pre">ghc-compact</span></code> and <code class="docutils literal notranslate"><span class="pre">compact</span></code> describes this process.</p></li>
</ol>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Prior to GHC 8.10, when passing an <code class="docutils literal notranslate"><span class="pre">ArrayArray#</span></code> argument
to a foreign function, the foreign function would see a pointer
to the <code class="docutils literal notranslate"><span class="pre">StgMutArrPtrs</span></code> rather than just the payload.</p>
</aside>
<aside class="footnote brackets" id="id6" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id8">2</a>)</span>
<p>In practice, the FFI should not be used for a task as simple
as reading bytes from a <code class="docutils literal notranslate"><span class="pre">MutableByteArray#</span></code>. Users should prefer
<code class="docutils literal notranslate"><span class="pre">GHC.Exts.readWord8Array#</span></code> for this.</p>
</aside>
<aside class="footnote brackets" id="id7" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>As in <a class="footnote-reference brackets" href="#id6" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>, the FFI is not actually needed for this. <code class="docutils literal notranslate"><span class="pre">GHC.Exts</span></code>
includes primitives for reading from on <code class="docutils literal notranslate"><span class="pre">ArrayArray#</span></code>.</p>
</aside>
</aside>
</section>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="safe_haskell.html" class="btn btn-neutral float-right" title="6.18. Safe Haskell" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="primitives.html" class="btn btn-neutral float-left" title="6.16. Unboxed types and primitive operations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
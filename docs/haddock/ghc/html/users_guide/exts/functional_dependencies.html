

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.8.7. Functional dependencies &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.8.8. Instance declarations and resolution" href="instances.html" />
    <link rel="prev" title="6.8.6. Nullary type classes" href="nullary_type_classes.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="multi_param_type_classes.html">6.8.1. Multi-parameter type classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="undecidable_super_classes.html">6.8.2. Undecidable (or recursive) superclasses</a></li>
<li class="toctree-l3"><a class="reference internal" href="constrained_class_methods.html">6.8.3. Constrained class method types</a></li>
<li class="toctree-l3"><a class="reference internal" href="default_signatures.html">6.8.4. Default method signatures</a></li>
<li class="toctree-l3"><a class="reference internal" href="default_signatures.html#detailed-requirements-for-default-type-signatures">6.8.5. Detailed requirements for default type signatures</a></li>
<li class="toctree-l3"><a class="reference internal" href="nullary_type_classes.html">6.8.6. Nullary type classes</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.8.7. Functional dependencies</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rules-for-functional-dependencies">6.8.7.1. Rules for functional dependencies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#background-on-functional-dependencies">6.8.7.2. Background on functional dependencies</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="instances.html">6.8.8. Instance declarations and resolution</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="typeclasses.html"><span class="section-number">6.8. </span>Class and instances declarations</a> &raquo;</li>
        
      <li><span class="section-number">6.8.7. </span>Functional dependencies</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/functional_dependencies.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="functional-dependencies">
<span id="id1"></span><h1><span class="section-number">6.8.7. </span>Functional dependencies<a class="headerlink" href="#functional-dependencies" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-FunctionalDependencies">
<span id="ghc-flag--XFunctionalDependencies"></span><span id="extension-NoFunctionalDependencies"></span><span class="sig-name descname"><span class="pre">FunctionalDependencies</span></span><a class="headerlink" href="#extension-FunctionalDependencies" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Implies<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="multi_param_type_classes.html#extension-MultiParamTypeClasses"><code class="xref std std-extension docutils literal notranslate"><span class="pre">MultiParamTypeClasses</span></code></a></p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>6.8.1</p>
</dd>
</dl>
<p>Allow use of functional dependencies in class declarations.</p>
</dd></dl>

<p>Functional dependencies are implemented as described by Mark Jones in
<a class="reference internal" href="#jones2000" id="id2"><span>[Jones2000]</span></a>.</p>
<p>Functional dependencies are introduced by a vertical bar in the syntax
of a class declaration; e.g.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="p">(</span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MonadState</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>More documentation can be found in the <a class="reference external" href="https://wiki.haskell.org/Functional_dependencies">Haskell Wiki</a>.</p>
<div role="list" class="citation-list">
<div class="citation" id="jones2000" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Jones2000</a><span class="fn-bracket">]</span></span>
<p>“<a class="reference external" href="https://web.cecs.pdx.edu/~mpj/pubs/fundeps.html">Type Classes with Functional
Dependencies</a>”,
Mark P. Jones, In <em>Proceedings of the 9th European Symposium on Programming</em>,
ESOP 2000, Berlin, Germany, March 2000, Springer-Verlag LNCS 1782, .</p>
</div>
</div>
<section id="rules-for-functional-dependencies">
<h2><span class="section-number">6.8.7.1. </span>Rules for functional dependencies<a class="headerlink" href="#rules-for-functional-dependencies" title="Permalink to this heading">¶</a></h2>
<p>In a class declaration, all of the class type variables must be
reachable (in the sense mentioned in <a class="reference internal" href="flexible_contexts.html#flexible-contexts"><span class="std std-ref">Loosening restrictions on class contexts</span></a>) from the
free variables of each method type. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Coll</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">empty</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
<span class="w">  </span><span class="n">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
</pre></div>
</div>
<p>is not OK, because the type of <code class="docutils literal notranslate"><span class="pre">empty</span></code> doesn’t mention <code class="docutils literal notranslate"><span class="pre">a</span></code>.
Functional dependencies can make the type variable reachable:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Coll</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">empty</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
<span class="w">  </span><span class="n">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
</pre></div>
</div>
<p>Alternatively <code class="docutils literal notranslate"><span class="pre">Coll</span></code> might be rewritten</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Coll</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">empty</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="n">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>which makes the connection between the type of a collection of <code class="docutils literal notranslate"><span class="pre">a</span></code>’s
(namely <code class="docutils literal notranslate"><span class="pre">(s</span> <span class="pre">a)</span></code>) and the element type <code class="docutils literal notranslate"><span class="pre">a</span></code>. Occasionally this really
doesn’t work, in which case you can split the class like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">CollE</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">empty</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="n">s</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">CollE</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Coll</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="background-on-functional-dependencies">
<h2><span class="section-number">6.8.7.2. </span>Background on functional dependencies<a class="headerlink" href="#background-on-functional-dependencies" title="Permalink to this heading">¶</a></h2>
<p>The following description of the motivation and use of functional
dependencies is taken from the Hugs user manual, reproduced here (with
minor changes) by kind permission of Mark Jones.</p>
<p>Consider the following class, intended as part of a library for
collection types:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">empty</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="n">ce</span><span class="w"></span>
<span class="w">    </span><span class="n">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">ce</span><span class="w"></span>
<span class="w">    </span><span class="n">member</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
</pre></div>
</div>
<p>The type variable <code class="docutils literal notranslate"><span class="pre">e</span></code> used here represents the element type, while <code class="docutils literal notranslate"><span class="pre">ce</span></code> is
the type of the container itself. Within this framework, we might want to define
instances of this class for lists or characteristic functions (both of which can
be used to represent collections of any equality type), bit sets (which can be
used to represent collections of characters), or hash tables (which can be used
to represent any collection whose elements have a hash function). Omitting
standard implementation details, this would lead to the following declarations:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="kt">Char</span><span class="w"> </span><span class="kt">BitSet</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Hashable</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">ce</span><span class="p">)</span><span class="w"></span>
<span class="w">           </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="kt">Array</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">ce</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>All this looks quite promising; we have a class and a range of
interesting implementations. Unfortunately, there are some serious
problems with the class declaration. First, the empty function has an
ambiguous type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">empty</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">ce</span><span class="w"></span>
</pre></div>
</div>
<p>By “ambiguous” we mean that there is a type variable <code class="docutils literal notranslate"><span class="pre">e</span></code> that appears on
the left of the <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> symbol, but not on the right. The problem with
this is that, according to the theoretical foundations of Haskell
overloading, we cannot guarantee a well-defined semantics for any term
with an ambiguous type.</p>
<p>We can sidestep this specific problem by removing the empty member from
the class declaration. However, although the remaining members, insert
and member, do not have ambiguous types, we still run into problems when
we try to use them. For example, consider the following two functions:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="nf">g</span><span class="w">     </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="w"></span>
</pre></div>
</div>
<p>for which GHC infers the following types:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Collects</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Collects</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="kt">Char</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that the type for <code class="docutils literal notranslate"><span class="pre">f</span></code> allows the two parameters <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> to be
assigned different types, even though it attempts to insert each of the
two values, one after the other, into the same collection. If we’re
trying to model collections that contain only one type of value, then
this is clearly an inaccurate type. Worse still, the definition for g is
accepted, without causing a type error. As a result, the error in this
code will not be flagged at the point where it appears. Instead, it will
show up only when we try to use <code class="docutils literal notranslate"><span class="pre">g</span></code>, which might even be in a different
module.</p>
<section id="an-attempt-to-use-constructor-classes">
<h3><span class="section-number">6.8.7.2.1. </span>An attempt to use constructor classes<a class="headerlink" href="#an-attempt-to-use-constructor-classes" title="Permalink to this heading">¶</a></h3>
<p>Faced with the problems described above, some Haskell programmers might
be tempted to use something like the following version of the class
declaration:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="n">empty</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
<span class="w">   </span><span class="n">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
<span class="w">   </span><span class="n">member</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
</pre></div>
</div>
<p>The key difference here is that we abstract over the type constructor <code class="docutils literal notranslate"><span class="pre">c</span></code>
that is used to form the collection type <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">e</span></code>, and not over that
collection type itself, represented by <code class="docutils literal notranslate"><span class="pre">ce</span></code> in the original class
declaration. This avoids the immediate problems that we mentioned above:
empty has type <code class="docutils literal notranslate"><span class="pre">Collects</span> <span class="pre">e</span> <span class="pre">c</span> <span class="pre">=&gt;</span> <span class="pre">c</span> <span class="pre">e</span></code>, which is not ambiguous.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">f</span></code> from the previous section has a more accurate type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Collects</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">g</span></code> from the previous section is now rejected with a type
error as we would hope because the type of <code class="docutils literal notranslate"><span class="pre">f</span></code> does not allow the two
arguments to have different types. This, then, is an example of a
multiple parameter class that does actually work quite well in practice,
without ambiguity problems. There is, however, a catch. This version of
the <code class="docutils literal notranslate"><span class="pre">Collects</span></code> class is nowhere near as general as the original class
seemed to be: only one of the four instances for <code class="docutils literal notranslate"><span class="pre">Collects</span></code> given
above can be used with this version of Collects because only one of them—the
instance for lists—has a collection type that can be written in the form <code class="docutils literal notranslate"><span class="pre">c</span>
<span class="pre">e</span></code>, for some type constructor <code class="docutils literal notranslate"><span class="pre">c</span></code>, and element type <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
</section>
<section id="adding-functional-dependencies">
<h3><span class="section-number">6.8.7.2.2. </span>Adding functional dependencies<a class="headerlink" href="#adding-functional-dependencies" title="Permalink to this heading">¶</a></h3>
<p>To get a more useful version of the <code class="docutils literal notranslate"><span class="pre">Collects</span></code> class, GHC provides a
mechanism that allows programmers to specify dependencies between the
parameters of a multiple parameter class (For readers with an interest
in theoretical foundations and previous work: The use of dependency
information can be seen both as a generalisation of the proposal for
“parametric type classes” that was put forward by Chen, Hudak, and
Odersky, or as a special case of Mark Jones’s later framework for
“improvement” of qualified types. The underlying ideas are also
discussed in a more theoretical and abstract setting in a manuscript
<a class="reference internal" href="#jones1999" id="id3"><span>[Jones1999]</span></a>, where they are identified as one point in a general design
space for systems of implicit parameterisation). To start with an
abstract example, consider a declaration such as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<div role="list" class="citation-list">
<div class="citation" id="jones1999" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">Jones1999</a><span class="fn-bracket">]</span></span>
<p>“<a class="reference external" href="https://web.cecs.pdx.edu/~mpj/pubs/fdtr.html">Exploring the Design Space for Type-based Implicit Parameterization</a>”, Mark P. Jones, Oregon
Graduate Institute of Science &amp; Technology, Technical Report, July 1999.</p>
</div>
</div>
<p>which tells us simply that <code class="docutils literal notranslate"><span class="pre">C</span></code> can be thought of as a binary relation on
types (or type constructors, depending on the kinds of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>). Extra
clauses can be included in the definition of classes to add information
about dependencies between parameters, as in the following examples:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="kt">E</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>The notation <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> used here between the <code class="docutils literal notranslate"><span class="pre">|</span></code> and <code class="docutils literal notranslate"><span class="pre">where</span></code> symbols —
not to be confused with a function type — indicates that the <code class="docutils literal notranslate"><span class="pre">a</span></code>
parameter uniquely determines the <code class="docutils literal notranslate"><span class="pre">b</span></code> parameter, and might be read as “<code class="docutils literal notranslate"><span class="pre">a</span></code>
determines <code class="docutils literal notranslate"><span class="pre">b</span></code>.” Thus <code class="docutils literal notranslate"><span class="pre">D</span></code> is not just a relation, but actually a (partial)
function. Similarly, from the two dependencies that are included in the
definition of <code class="docutils literal notranslate"><span class="pre">E</span></code>, we can see that <code class="docutils literal notranslate"><span class="pre">E</span></code> represents a (partial) one-to-one
mapping between types.</p>
<p>More generally, dependencies take the form <code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span> <span class="pre">-&gt;</span> <span class="pre">y1</span> <span class="pre">...</span> <span class="pre">ym</span></code>,
where <code class="docutils literal notranslate"><span class="pre">x1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">xn</span></code>, and <code class="docutils literal notranslate"><span class="pre">y1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">yn</span></code> are type variables with n&gt;0 and m&gt;=0,
meaning that the <code class="docutils literal notranslate"><span class="pre">y</span></code> parameters are uniquely determined by the <code class="docutils literal notranslate"><span class="pre">x</span></code>
parameters. Spaces can be used as separators if more than one variable
appears on any single side of a dependency, as in <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">b</span></code>. Note
that a class may be annotated with multiple dependencies using commas as
separators, as in the definition of <code class="docutils literal notranslate"><span class="pre">E</span></code> above. Some dependencies that we
can write in this notation are redundant, and will be rejected because
they don’t serve any useful purpose, and may instead indicate an error
in the program. Examples of dependencies like this include <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>,
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span></code>, etc. There can also be some redundancy if
multiple dependencies are given, as in <code class="docutils literal notranslate"><span class="pre">a-&gt;b</span></code>, <code class="docutils literal notranslate"><span class="pre">b-&gt;c</span></code>, <code class="docutils literal notranslate"><span class="pre">a-&gt;c</span></code>, and
in which some subset implies the remaining dependencies. Examples like
this are not treated as errors. Note that dependencies appear only in
class declarations, and not in any other part of the language. In
particular, the syntax for instance declarations, class constraints, and
types is completely unchanged.</p>
<p>By including dependencies in a class declaration, we provide a mechanism
for the programmer to specify each multiple parameter class more
precisely. The compiler, on the other hand, is responsible for ensuring
that the set of instances that are in scope at any given point in the
program is consistent with any declared dependencies. For example, the
following pair of instance declarations cannot appear together in the
same scope because they violate the dependency for <code class="docutils literal notranslate"><span class="pre">D</span></code>, even though either
one on its own would be acceptable:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="kt">Char</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Note also that the following declaration is not allowed, even by itself:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>The problem here is that this instance would allow one particular choice
of <code class="docutils literal notranslate"><span class="pre">[a]</span></code> to be associated with more than one choice for <code class="docutils literal notranslate"><span class="pre">b</span></code>, which
contradicts the dependency specified in the definition of <code class="docutils literal notranslate"><span class="pre">D</span></code>. More
generally, this means that, in any instance of the form:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>for some particular types <code class="docutils literal notranslate"><span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">s</span></code>, the only variables that can appear in
<code class="docutils literal notranslate"><span class="pre">s</span></code> are the ones that appear in <code class="docutils literal notranslate"><span class="pre">t</span></code>, and hence, if the type <code class="docutils literal notranslate"><span class="pre">t</span></code> is known,
then <code class="docutils literal notranslate"><span class="pre">s</span></code> will be uniquely determined.</p>
<p>The benefit of including dependency information is that it allows us to
define more general multiple parameter classes, without ambiguity
problems, and with the benefit of more accurate types. To illustrate
this, we return to the collection class example, and annotate the
original definition of <code class="docutils literal notranslate"><span class="pre">Collects</span></code> with a simple dependency:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="n">empty</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="n">ce</span><span class="w"></span>
<span class="w">   </span><span class="n">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">ce</span><span class="w"></span>
<span class="w">   </span><span class="n">member</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
</pre></div>
</div>
<p>The dependency <code class="docutils literal notranslate"><span class="pre">ce</span> <span class="pre">-&gt;</span> <span class="pre">e</span></code> here specifies that the type <code class="docutils literal notranslate"><span class="pre">e</span></code> of elements is
uniquely determined by the type of the collection <code class="docutils literal notranslate"><span class="pre">ce</span></code>. Note that both
parameters of Collects are of kind <code class="docutils literal notranslate"><span class="pre">Type</span></code>; there are no constructor classes
here. Note too that all of the instances of <code class="docutils literal notranslate"><span class="pre">Collects</span></code> that we gave earlier
can be used together with this new definition.</p>
<p>What about the ambiguity problems that we encountered with the original
definition? The empty function still has type <code class="docutils literal notranslate"><span class="pre">Collects</span> <span class="pre">e</span> <span class="pre">ce</span> <span class="pre">=&gt;</span> <span class="pre">ce</span></code>, but
it is no longer necessary to regard that as an ambiguous type: Although
the variable <code class="docutils literal notranslate"><span class="pre">e</span></code> does not appear on the right of the <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> symbol, the
dependency for class <code class="docutils literal notranslate"><span class="pre">Collects</span></code> tells us that it is uniquely determined by
<code class="docutils literal notranslate"><span class="pre">ce</span></code>, which does appear on the right of the <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> symbol. Hence the context
in which empty is used can still give enough information to determine
types for both <code class="docutils literal notranslate"><span class="pre">ce</span></code> and <code class="docutils literal notranslate"><span class="pre">e</span></code>, without ambiguity. More generally, we need only
regard a type as ambiguous if it contains a variable on the left of the
<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> that is not uniquely determined (either directly or indirectly) by
the variables on the right.</p>
<p>Dependencies also help to produce more accurate types for user defined
functions, and hence to provide earlier detection of errors, and less
cluttered types for programmers to work with. Recall the previous
definition for a function <code class="docutils literal notranslate"><span class="pre">f</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
<p>for which we originally obtained a type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Collects</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
<p>Given the dependency information that we have for <code class="docutils literal notranslate"><span class="pre">Collects</span></code>, however, we
can deduce that <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must be equal because they both appear as the
second parameter in a <code class="docutils literal notranslate"><span class="pre">Collects</span></code> constraint with the same first parameter
<code class="docutils literal notranslate"><span class="pre">c</span></code>. Hence we can infer a shorter and more accurate type for <code class="docutils literal notranslate"><span class="pre">f</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Collects</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
<p>In a similar way, the earlier definition of <code class="docutils literal notranslate"><span class="pre">g</span></code> will now be flagged as a
type error.</p>
<p>Although we have given only a few examples here, it should be clear that
the addition of dependency information can help to make multiple
parameter classes more useful in practice, avoiding ambiguity problems,
and allowing more general sets of instance declarations.</p>
</section>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="instances.html" class="btn btn-neutral float-right" title="6.8.8. Instance declarations and resolution" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="nullary_type_classes.html" class="btn btn-neutral float-left" title="6.8.6. Nullary type classes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
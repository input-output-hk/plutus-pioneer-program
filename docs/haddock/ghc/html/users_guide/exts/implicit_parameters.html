

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.11.5. Implicit parameters &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.11.6. Partial Type Signatures" href="partial_type_signatures.html" />
    <link rel="prev" title="6.11.4. Lexically scoped type variables" href="scoped_type_variables.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="explicit_forall.html">6.11.1. Explicit universal quantification (forall)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ambiguous_types.html">6.11.2. Ambiguous types and the ambiguity check</a></li>
<li class="toctree-l3"><a class="reference internal" href="kind_signatures.html">6.11.3. Explicitly-kinded quantification</a></li>
<li class="toctree-l3"><a class="reference internal" href="scoped_type_variables.html">6.11.4. Lexically scoped type variables</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.11.5. Implicit parameters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implicit-parameter-type-constraints">6.11.5.1. Implicit-parameter type constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-parameter-bindings">6.11.5.2. Implicit-parameter bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-parameters-and-polymorphic-recursion">6.11.5.3. Implicit parameters and polymorphic recursion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-parameters-and-monomorphism">6.11.5.4. Implicit parameters and monomorphism</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="partial_type_signatures.html">6.11.6. Partial Type Signatures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="type_signatures.html"><span class="section-number">6.11. </span>Type signatures</a> &raquo;</li>
        
      <li><span class="section-number">6.11.5. </span>Implicit parameters</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/implicit_parameters.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="implicit-parameters">
<span id="id1"></span><h1><span class="section-number">6.11.5. </span>Implicit parameters<a class="headerlink" href="#implicit-parameters" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-ImplicitParams">
<span id="ghc-flag--XImplicitParams"></span><span id="extension-NoImplicitParams"></span><span class="sig-name descname"><span class="pre">ImplicitParams</span></span><a class="headerlink" href="#extension-ImplicitParams" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.8.1</p>
</dd>
</dl>
<p>Allow definition of functions expecting implicit parameters.</p>
</dd></dl>

<p>Implicit parameters are implemented as described in <a class="reference internal" href="#lewis2000" id="id2"><span>[Lewis2000]</span></a> and enabled
with the option <a class="reference internal" href="#extension-ImplicitParams"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ImplicitParams</span></code></a>. (Most of the following, still rather
incomplete, documentation is due to Jeff Lewis.)</p>
<div role="list" class="citation-list">
<div class="citation" id="lewis2000" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Lewis2000</a><span class="fn-bracket">]</span></span>
<p>“Implicit parameters: dynamic scoping with static types”,
J Lewis, MB Shields, E Meijer, J Launchbury,
<em>27th ACM Symposium on Principles of Programming Languages (POPL’00)</em>,
Boston, Jan 2000.</p>
</div>
</div>
<p>A variable is called <em>dynamically bound</em> when it is bound by the calling
context of a function and <em>statically bound</em> when bound by the callee’s
context. In Haskell, all variables are statically bound. Dynamic binding
of variables is a notion that goes back to Lisp, but was later discarded
in more modern incarnations, such as Scheme. Dynamic binding can be very
confusing in an untyped language, and unfortunately, typed languages, in
particular Hindley-Milner typed languages like Haskell, only support
static scoping of variables.</p>
<p>However, by a simple extension to the type class system of Haskell, we
can support dynamic binding. Basically, we express the use of a
dynamically bound variable as a constraint on the type. These
constraints lead to types of the form <code class="docutils literal notranslate"><span class="pre">(?x::t')</span> <span class="pre">=&gt;</span> <span class="pre">t</span></code>, which says
“this function uses a dynamically-bound variable <code class="docutils literal notranslate"><span class="pre">?x</span></code> of type <code class="docutils literal notranslate"><span class="pre">t'</span></code>”.
For example, the following expresses the type of a sort function,
implicitly parameterised by a comparison function named <code class="docutils literal notranslate"><span class="pre">cmp</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sort</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="n">cmp</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>The dynamic binding constraints are just a new form of predicate in the
type class system.</p>
<p>An implicit parameter occurs in an expression using the special form
<code class="docutils literal notranslate"><span class="pre">?x</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is any valid identifier (e.g. <code class="docutils literal notranslate"><span class="pre">ord</span> <span class="pre">?x</span></code> is a valid
expression). Use of this construct also introduces a new dynamic-binding
constraint in the type of the expression. For example, the following
definition shows how we can define an implicitly parameterised sort
function in terms of an explicitly parameterised <code class="docutils literal notranslate"><span class="pre">sortBy</span></code> function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sortBy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>

<span class="nf">sort</span><span class="w">   </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="n">cmp</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">sort</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="n">sortBy</span><span class="w"> </span><span class="o">?</span><span class="n">cmp</span><span class="w"></span>
</pre></div>
</div>
<section id="implicit-parameter-type-constraints">
<h2><span class="section-number">6.11.5.1. </span>Implicit-parameter type constraints<a class="headerlink" href="#implicit-parameter-type-constraints" title="Permalink to this heading">¶</a></h2>
<p>Dynamic binding constraints behave just like other type class
constraints in that they are automatically propagated. Thus, when a
function is used, its implicit parameters are inherited by the function
that called it. For example, our <code class="docutils literal notranslate"><span class="pre">sort</span></code> function might be used to pick
out the least value in a list:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">least</span><span class="w">   </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="n">cmp</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">least</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="p">(</span><span class="n">sort</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Without lifting a finger, the <code class="docutils literal notranslate"><span class="pre">?cmp</span></code> parameter is propagated to become
a parameter of <code class="docutils literal notranslate"><span class="pre">least</span></code> as well. With explicit parameters, the default
is that parameters must always be explicit propagated. With implicit
parameters, the default is to always propagate them.</p>
<p>An implicit-parameter type constraint differs from other type class
constraints in the following way: All uses of a particular implicit
parameter must have the same type. This means that the type of
<code class="docutils literal notranslate"><span class="pre">(?x,</span> <span class="pre">?x)</span></code> is <code class="docutils literal notranslate"><span class="pre">(?x::a)</span> <span class="pre">=&gt;</span> <span class="pre">(a,a)</span></code>, and not
<code class="docutils literal notranslate"><span class="pre">(?x::a,</span> <span class="pre">?x::b)</span> <span class="pre">=&gt;</span> <span class="pre">(a,</span> <span class="pre">b)</span></code>, as would be the case for type class
constraints.</p>
<p>You can’t have an implicit parameter in the context of a class or
instance declaration. For example, both these declarations are illegal:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="n">x</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="n">x</span><span class="ow">::</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Reason: exactly which implicit parameter you pick up depends on exactly
where you invoke a function. But the “invocation” of instance
declarations is done behind the scenes by the compiler, so it’s hard to
figure out exactly where it is done. Easiest thing is to outlaw the
offending types.</p>
<p>Implicit-parameter constraints do not cause ambiguity. For example,
consider:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">])</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">?</span><span class="n">x</span><span class="w"></span>

<span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Read</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="p">(</span><span class="n">read</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">g</span></code> has an ambiguous type, and is rejected, but <code class="docutils literal notranslate"><span class="pre">f</span></code> is fine.
The binding for <code class="docutils literal notranslate"><span class="pre">?x</span></code> at <code class="docutils literal notranslate"><span class="pre">f</span></code>‘s call site is quite unambiguous, and
fixes the type <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</section>
<section id="implicit-parameter-bindings">
<h2><span class="section-number">6.11.5.2. </span>Implicit-parameter bindings<a class="headerlink" href="#implicit-parameter-bindings" title="Permalink to this heading">¶</a></h2>
<p>An implicit parameter is <em>bound</em> using the standard <code class="docutils literal notranslate"><span class="pre">let</span></code> or <code class="docutils literal notranslate"><span class="pre">where</span></code>
binding forms. For example, we define the <code class="docutils literal notranslate"><span class="pre">min</span></code> function by binding
<code class="docutils literal notranslate"><span class="pre">cmp</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">min</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">min</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">?</span><span class="n">cmp</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;=</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">least</span><span class="w"></span>
</pre></div>
</div>
<p>A group of implicit-parameter bindings may occur anywhere a normal group
of Haskell bindings can occur, except at top level. That is, they can
occur in a <code class="docutils literal notranslate"><span class="pre">let</span></code> (including in a list comprehension, or do-notation,
or pattern guards), or a <code class="docutils literal notranslate"><span class="pre">where</span></code> clause. Note the following points:</p>
<ul>
<li><p>An implicit-parameter binding group must be a collection of simple
bindings to implicit-style variables (no function-style bindings, and
no type signatures); these bindings are neither polymorphic or
recursive.</p></li>
<li><p>You may not mix implicit-parameter bindings with ordinary bindings in
a single <code class="docutils literal notranslate"><span class="pre">let</span></code> expression; use two nested <code class="docutils literal notranslate"><span class="pre">let</span></code>s instead. (In
the case of <code class="docutils literal notranslate"><span class="pre">where</span></code> you are stuck, since you can’t nest <code class="docutils literal notranslate"><span class="pre">where</span></code>
clauses.)</p></li>
<li><p>You may put multiple implicit-parameter bindings in a single binding
group; but they are <em>not</em> treated as a mutually recursive group (as
ordinary <code class="docutils literal notranslate"><span class="pre">let</span></code> bindings are). Instead they are treated as a
non-recursive group, simultaneously binding all the implicit
parameter. The bindings are not nested, and may be re-ordered without
changing the meaning of the program. For example, consider:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">?</span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"> </span><span class="o">?</span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">?</span><span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">?</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
<p>The use of <code class="docutils literal notranslate"><span class="pre">?x</span></code> in the binding for <code class="docutils literal notranslate"><span class="pre">?y</span></code> does not “see” the
binding for <code class="docutils literal notranslate"><span class="pre">?x</span></code>, so the type of <code class="docutils literal notranslate"><span class="pre">f</span></code> is</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="n">x</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="implicit-parameters-and-polymorphic-recursion">
<h2><span class="section-number">6.11.5.3. </span>Implicit parameters and polymorphic recursion<a class="headerlink" href="#implicit-parameters-and-polymorphic-recursion" title="Permalink to this heading">¶</a></h2>
<p>Consider these two definitions:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">len1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">len1</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">?</span><span class="n">acc</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">len_acc1</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>

<span class="nf">len_acc1</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">?</span><span class="n">acc</span><span class="w"></span>
<span class="nf">len_acc1</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">?</span><span class="n">acc</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">?</span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">len_acc1</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>

<span class="c1">------------</span><span class="w"></span>

<span class="nf">len2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">len2</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">?</span><span class="n">acc</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">len_acc2</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>

<span class="nf">len_acc2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="n">acc</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">len_acc2</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">?</span><span class="n">acc</span><span class="w"></span>
<span class="nf">len_acc2</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">?</span><span class="n">acc</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">?</span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">len_acc2</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
</pre></div>
</div>
<p>The only difference between the two groups is that in the second group
<code class="docutils literal notranslate"><span class="pre">len_acc</span></code> is given a type signature. In the former case, <code class="docutils literal notranslate"><span class="pre">len_acc1</span></code>
is monomorphic in its own right-hand side, so the implicit parameter
<code class="docutils literal notranslate"><span class="pre">?acc</span></code> is not passed to the recursive call. In the latter case,
because <code class="docutils literal notranslate"><span class="pre">len_acc2</span></code> has a type signature, the recursive call is made to
the <em>polymorphic</em> version, which takes <code class="docutils literal notranslate"><span class="pre">?acc</span></code> as an implicit
parameter. So we get the following results in GHCi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Prog&gt; len1 &quot;hello&quot;
0
Prog&gt; len2 &quot;hello&quot;
5
</pre></div>
</div>
<p>Adding a type signature dramatically changes the result! This is a
rather counter-intuitive phenomenon, worth watching out for.</p>
</section>
<section id="implicit-parameters-and-monomorphism">
<h2><span class="section-number">6.11.5.4. </span>Implicit parameters and monomorphism<a class="headerlink" href="#implicit-parameters-and-monomorphism" title="Permalink to this heading">¶</a></h2>
<p>GHC applies the dreaded Monomorphism Restriction (section 4.5.5 of the
Haskell Report) to implicit parameters. For example, consider:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">?</span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="kr">in</span><span class="w"></span>
<span class="w">      </span><span class="kr">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">?</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="w">      </span><span class="kr">let</span><span class="w"> </span><span class="o">?</span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">5</span><span class="w">     </span><span class="kr">in</span><span class="w"></span>
<span class="w">      </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
<p>Since the binding for <code class="docutils literal notranslate"><span class="pre">y</span></code> falls under the Monomorphism Restriction it
is not generalised, so the type of <code class="docutils literal notranslate"><span class="pre">y</span></code> is simply <code class="docutils literal notranslate"><span class="pre">Int</span></code>, not
<code class="docutils literal notranslate"><span class="pre">(?x::Int)</span> <span class="pre">=&gt;</span> <span class="pre">Int</span></code>. Hence, <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">9)</span></code> returns result <code class="docutils literal notranslate"><span class="pre">9</span></code>. If you add
a type signature for <code class="docutils literal notranslate"><span class="pre">y</span></code>, then <code class="docutils literal notranslate"><span class="pre">y</span></code> will get type
<code class="docutils literal notranslate"><span class="pre">(?x::Int)</span> <span class="pre">=&gt;</span> <span class="pre">Int</span></code>, so the occurrence of <code class="docutils literal notranslate"><span class="pre">y</span></code> in the body of the
<code class="docutils literal notranslate"><span class="pre">let</span></code> will see the inner binding of <code class="docutils literal notranslate"><span class="pre">?x</span></code>, so <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">9)</span></code> will return
<code class="docutils literal notranslate"><span class="pre">14</span></code>.</p>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="partial_type_signatures.html" class="btn btn-neutral float-right" title="6.11.6. Partial Type Signatures" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="scoped_type_variables.html" class="btn btn-neutral float-left" title="6.11.4. Lexically scoped type variables" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
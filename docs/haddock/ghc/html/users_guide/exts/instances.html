

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.8.8. Instance declarations and resolution &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML "></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.9. Literals" href="literals.html" />
    <link rel="prev" title="6.8.7. Functional dependencies" href="functional_dependencies.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="multi_param_type_classes.html">6.8.1. Multi-parameter type classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="undecidable_super_classes.html">6.8.2. Undecidable (or recursive) superclasses</a></li>
<li class="toctree-l3"><a class="reference internal" href="constrained_class_methods.html">6.8.3. Constrained class method types</a></li>
<li class="toctree-l3"><a class="reference internal" href="default_signatures.html">6.8.4. Default method signatures</a></li>
<li class="toctree-l3"><a class="reference internal" href="default_signatures.html#detailed-requirements-for-default-type-signatures">6.8.5. Detailed requirements for default type signatures</a></li>
<li class="toctree-l3"><a class="reference internal" href="nullary_type_classes.html">6.8.6. Nullary type classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional_dependencies.html">6.8.7. Functional dependencies</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.8.8. Instance declarations and resolution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#relaxed-rules-for-the-instance-head">6.8.8.1. Relaxed rules for the instance head</a></li>
<li class="toctree-l4"><a class="reference internal" href="#formal-syntax-for-instance-declaration-types">6.8.8.2. Formal syntax for instance declaration types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#instance-termination-rules">6.8.8.3. Instance termination rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#overlapping-instances">6.8.8.4. Overlapping instances</a></li>
<li class="toctree-l4"><a class="reference internal" href="#instance-signatures-type-signatures-in-instance-declarations">6.8.8.5. Instance signatures: type signatures in instance declarations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="typeclasses.html"><span class="section-number">6.8. </span>Class and instances declarations</a> &raquo;</li>
        
      <li><span class="section-number">6.8.8. </span>Instance declarations and resolution</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/instances.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="instance-declarations-and-resolution">
<span id="instance-resolution"></span><span id="instance-decls"></span><h1><span class="section-number">6.8.8. </span>Instance declarations and resolution<a class="headerlink" href="#instance-declarations-and-resolution" title="Permalink to this heading">¶</a></h1>
<p>An instance declaration has the form</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="n">assertion1</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">,</span><span class="w"> </span><span class="n">assertionn</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kr">class</span><span class="w"> </span><span class="n">type1</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">typem</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>The part before the “<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>” is the <em>context</em>, while the part after the
“<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>” is the <em>head</em> of the instance declaration.</p>
<p>When GHC tries to resolve, say, the constraint <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">Bool</span></code>, it tries
to match every instance declaration against the constraint, by
instantiating the head of the instance declaration. Consider these
declarations:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="n">context1</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">a</span><span class="w">     </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w">  </span><span class="c1">-- (A)</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="n">context2</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w">   </span><span class="kt">Bool</span><span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w">  </span><span class="c1">-- (B)</span><span class="w"></span>
</pre></div>
</div>
<p>GHC’s default behaviour is that <em>exactly one instance must match the
constraint it is trying to resolve</em>. For example, the constraint
<code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">Bool</span></code> matches instances (A) and (B), and hence would be
rejected; while <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">Char</span></code> matches only (A) and hence (A) is chosen.</p>
<p>Notice that</p>
<ul class="simple">
<li><p>When matching, GHC takes no account of the context of the instance
declaration (<code class="docutils literal notranslate"><span class="pre">context1</span></code> etc).</p></li>
<li><p>It is fine for there to be a <em>potential</em> of overlap (by including
both declarations (A) and (B), say); an error is only reported if a
particular constraint matches more than one.</p></li>
</ul>
<p>See also <a class="reference internal" href="#instance-overlap"><span class="std std-ref">Overlapping instances</span></a> for flags that loosen the instance
resolution rules.</p>
<section id="relaxed-rules-for-the-instance-head">
<span id="flexible-instance-head"></span><h2><span class="section-number">6.8.8.1. </span>Relaxed rules for the instance head<a class="headerlink" href="#relaxed-rules-for-the-instance-head" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-TypeSynonymInstances">
<span id="ghc-flag--XTypeSynonymInstances"></span><span id="extension-NoTypeSynonymInstances"></span><span class="sig-name descname"><span class="pre">TypeSynonymInstances</span></span><a class="headerlink" href="#extension-TypeSynonymInstances" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.8.1</p>
</dd>
</dl>
<p>Allow definition of type class instances for type synonyms.</p>
</dd></dl>

<dl class="std extension">
<dt class="sig sig-object std" id="extension-FlexibleInstances">
<span id="ghc-flag--XFlexibleInstances"></span><span id="extension-NoFlexibleInstances"></span><span class="sig-name descname"><span class="pre">FlexibleInstances</span></span><a class="headerlink" href="#extension-FlexibleInstances" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Implies<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#extension-TypeSynonymInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TypeSynonymInstances</span></code></a></p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>6.8.1</p>
</dd>
</dl>
<p>Allow definition of type class instances with arbitrary nested types in the
instance head.</p>
</dd></dl>

<p>In Haskell 98 the head of an instance declaration must be of the form
<code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">(T</span> <span class="pre">a1</span> <span class="pre">...</span> <span class="pre">an)</span></code>, where <code class="docutils literal notranslate"><span class="pre">C</span></code> is the class, <code class="docutils literal notranslate"><span class="pre">T</span></code> is a data type
constructor, and the <code class="docutils literal notranslate"><span class="pre">a1</span> <span class="pre">...</span> <span class="pre">an</span></code> are distinct type variables. In the
case of multi-parameter type classes, this rule applies to each
parameter of the instance head (Arguably it should be okay if just one
has this form and the others are type variables, but that’s the rules at
the moment).</p>
<p>GHC relaxes this rule in two ways:</p>
<ul>
<li><p>With the <a class="reference internal" href="#extension-TypeSynonymInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TypeSynonymInstances</span></code></a> extension, instance heads may use type
synonyms. As always, using a type synonym is just shorthand for
writing the RHS of the type synonym definition. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="kt">Point</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>is legal. The instance declaration is equivalent to</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>As always, type synonyms must be fully applied. You cannot, for
example, write:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The <a class="reference internal" href="#extension-FlexibleInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">FlexibleInstances</span></code></a> extension allows the head of the instance
declaration to mention arbitrary nested types. For example, this
becomes a legal instance declaration</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>See also the <a class="reference external" href="#instance-overlap">rules on overlap</a>.</p>
<p>The <a class="reference internal" href="#extension-FlexibleInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">FlexibleInstances</span></code></a> extension implies
<a class="reference internal" href="#extension-TypeSynonymInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TypeSynonymInstances</span></code></a>.</p>
</li>
</ul>
<p>However, the instance declaration must still conform to the rules for
instance termination: see <a class="reference internal" href="#instance-termination"><span class="std std-ref">Instance termination rules</span></a>.</p>
</section>
<section id="formal-syntax-for-instance-declaration-types">
<span id="formal-instance-syntax"></span><h2><span class="section-number">6.8.8.2. </span>Formal syntax for instance declaration types<a class="headerlink" href="#formal-syntax-for-instance-declaration-types" title="Permalink to this heading">¶</a></h2>
<p>The top of an instance declaration only permits very specific forms of types.
To make more precise what forms of types are or are not permitted, we provide a
BNF-style grammar for the tops of instance declarations below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>inst_top ::= &#39;instance&#39; opt_forall opt_ctxt inst_head opt_where

opt_forall ::= &lt;empty&gt;
            |  &#39;forall&#39; tv_bndrs &#39;.&#39;

tv_bndrs ::= &lt;empty&gt;
          |  tv_bndr tv_bndrs

tv_bndr ::= tyvar
         |  &#39;(&#39; tyvar &#39;::&#39; ctype &#39;)&#39;

opt_ctxt ::= &lt;empty&gt;
          |  btype &#39;=&gt;&#39;
          |  &#39;(&#39; ctxt &#39;)&#39; &#39;=&gt;&#39;

ctxt ::= ctype
      |  ctype &#39;,&#39; ctxt

inst_head ::= &#39;(&#39; inst_head &#39;)&#39;
           |  prefix_cls_tycon arg_types
           |  arg_type infix_cls_tycon arg_type
           |  &#39;(&#39; arg_type infix_cls_tycon arg_type &#39;)&#39; arg_types

arg_type ::= &lt;empty&gt;
          |  arg_type arg_types

opt_where ::= &lt;empty&gt;
           |  &#39;where&#39;
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">btype</span></code> is a type that is not allowed to have an outermost
<code class="docutils literal notranslate"><span class="pre">forall</span></code>/<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> unless it is surrounded by parentheses. For example,
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code> are not legal <code class="docutils literal notranslate"><span class="pre">btype</span></code>s, but
<code class="docutils literal notranslate"><span class="pre">(forall</span> <span class="pre">a.</span> <span class="pre">a)</span></code> and <code class="docutils literal notranslate"><span class="pre">(Eq</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a)</span></code> are legal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ctype</span></code> is a <code class="docutils literal notranslate"><span class="pre">btype</span></code> that has no restrictions on an outermost
<code class="docutils literal notranslate"><span class="pre">forall</span></code>/<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>, so <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code> are legal <code class="docutils literal notranslate"><span class="pre">ctype</span></code>s.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arg_type</span></code> is a type that is not allowed to have <code class="docutils literal notranslate"><span class="pre">forall</span></code>s or <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>s</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prefix_cls_tycon</span></code> is a class type constructor written prefix (e.g.,
<code class="docutils literal notranslate"><span class="pre">Show</span></code> or <code class="docutils literal notranslate"><span class="pre">(&amp;&amp;&amp;)</span></code>), while <code class="docutils literal notranslate"><span class="pre">infix_cls_tycon</span></code> is a class type constructor
written infix (e.g., <code class="docutils literal notranslate"><span class="pre">\`Show\`</span></code> or <code class="docutils literal notranslate"><span class="pre">&amp;&amp;&amp;</span></code>).</p></li>
</ul>
<p>This is a simplified grammar that does not fully delve into all of the
implementation details of GHC’s parser (such as the placement of Haddock
comments), but it is sufficient to attain an understanding of what is
syntactically allowed. Some further various observations about this grammar:</p>
<ul>
<li><p>Instance declarations are not allowed to be declared with nested <code class="docutils literal notranslate"><span class="pre">forall</span></code>s
or <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>s. For example, this would be rejected:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="kt">Either</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>As a result, <code class="docutils literal notranslate"><span class="pre">inst_top</span></code> puts all of its quantification and constraints up
front with <code class="docutils literal notranslate"><span class="pre">opt_forall</span></code> and <code class="docutils literal notranslate"><span class="pre">opt_context</span></code>.</p>
</li>
<li><p>Furthermore, instance declarations types do not permit outermost parentheses
that surround the <code class="docutils literal notranslate"><span class="pre">opt_forall</span></code> or <code class="docutils literal notranslate"><span class="pre">opt_ctxt</span></code>, if at least one of them are
used. For example, <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">(forall</span> <span class="pre">a.</span> <span class="pre">C</span> <span class="pre">a)</span></code> would be rejected, since GHC
would treat the <code class="docutils literal notranslate"><span class="pre">forall</span></code> as being nested.</p>
<p>Note that it is acceptable to use parentheses in a <code class="docutils literal notranslate"><span class="pre">inst_head</span></code>. For
instance, <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">(C</span> <span class="pre">a)</span></code> is accepted, as is <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">(C</span> <span class="pre">a)</span></code>.</p>
</li>
</ul>
</section>
<section id="instance-termination-rules">
<span id="undecidable-instances"></span><span id="instance-termination"></span><span id="instance-rules"></span><h2><span class="section-number">6.8.8.3. </span>Instance termination rules<a class="headerlink" href="#instance-termination-rules" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-UndecidableInstances">
<span id="ghc-flag--XUndecidableInstances"></span><span id="extension-NoUndecidableInstances"></span><span class="sig-name descname"><span class="pre">UndecidableInstances</span></span><a class="headerlink" href="#extension-UndecidableInstances" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.8.1</p>
</dd>
</dl>
<p>Permit definition of instances which may lead to type-checker non-termination.</p>
</dd></dl>

<p>Regardless of <a class="reference internal" href="#extension-FlexibleInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">FlexibleInstances</span></code></a> and <a class="reference internal" href="flexible_contexts.html#extension-FlexibleContexts"><code class="xref std std-extension docutils literal notranslate"><span class="pre">FlexibleContexts</span></code></a>,
instance declarations must conform to some rules that ensure that
instance resolution will terminate. The restrictions can be lifted with
<a class="reference internal" href="#extension-UndecidableInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UndecidableInstances</span></code></a> (see <a class="reference internal" href="#undecidable-instances"><span class="std std-ref">Instance termination rules</span></a>).</p>
<p>The rules are these:</p>
<ol class="arabic simple">
<li><p>The Paterson Conditions: for each class constraint <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">t1</span> <span class="pre">...</span> <span class="pre">tn)</span></code>
in the context</p>
<ol class="arabic simple">
<li><p>No type variable has more occurrences in the constraint than in
the head</p></li>
<li><p>The constraint has fewer constructors and variables (taken
together and counting repetitions) than the head</p></li>
<li><p>The constraint mentions no type functions. A type function
application can in principle expand to a type of arbitrary size,
and so are rejected out of hand</p></li>
</ol>
</li>
<li><p>The Coverage Condition. For each functional dependency,
⟨tvs⟩<sub>left</sub> <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> ⟨tvs⟩<sub>right</sub>, of the class, every
type variable in S(⟨tvs⟩<sub>right</sub>) must appear in
S(⟨tvs⟩<sub>left</sub>), where S is the substitution mapping each type
variable in the class declaration to the corresponding type in the
instance head.</p></li>
</ol>
<p>These restrictions ensure that instance resolution terminates: each
reduction step makes the problem smaller by at least one constructor.
You can find lots of background material about the reason for these
restrictions in the paper <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf">Understanding functional dependencies via
Constraint Handling
Rules</a>.</p>
<p>For example, these are okay:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w">          </span><span class="c1">-- Multiple parameters</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">S</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">])</span><span class="w">         </span><span class="c1">-- Structured type in head</span><span class="w"></span>

<span class="w">    </span><span class="c1">-- Repeated type variable in head</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">C4</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C4</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Stateful</span><span class="w"> </span><span class="p">(</span><span class="kt">ST</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">MutVar</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">-- Head can consist of type variables only</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>

<span class="w">    </span><span class="c1">-- Non-type variables in context</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="p">(</span><span class="kt">Sized</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">C2</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C3</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">C2</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C3</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>But these are not:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">-- Context assertion no smaller than head</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- (C b b) has more occurrences of b than the head</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>The same restrictions apply to instances generated by <code class="docutils literal notranslate"><span class="pre">deriving</span></code>
clauses. Thus the following is accepted:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">MinHeap</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">H</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>because the derived instance</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="p">(</span><span class="kt">MinHeap</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>conforms to the above rules.</p>
<p>The restrictions on functional dependencies
(<a class="reference internal" href="functional_dependencies.html#functional-dependencies"><span class="std std-ref">Functional dependencies</span></a>) are particularly troublesome. It is
tempting to introduce type variables in the context that do not appear
in the head, something that is excluded by the normal rules. For
example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">HasConverter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="n">convert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkFoo</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">HasConverter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="kt">Show</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="p">(</span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="n">show</span><span class="w"> </span><span class="p">(</span><span class="kt">MkFoo</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="p">(</span><span class="n">convert</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This is dangerous territory, however. Here, for example, is a program
that would make the typechecker loop:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="ow">-&gt;</span><span class="n">b</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="p">]]</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">D</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w">   </span><span class="c1">-- &#39;c&#39; is not mentioned in the head</span><span class="w"></span>
</pre></div>
</div>
<p>Similarly, it can be tempting to lift the coverage condition:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Mul</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">.*.</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Mul</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="o">.*.</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Mul</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Float</span><span class="w"> </span><span class="kt">Float</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">.*.</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Mul</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Mul</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">.*.</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">.*.</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
</pre></div>
</div>
<p>The third instance declaration does not obey the coverage condition; and
indeed the (somewhat strange) definition:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">.*.</span><span class="w"> </span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
<p>makes instance inference go into a loop, because it requires the
constraint <code class="docutils literal notranslate"><span class="pre">(Mul</span> <span class="pre">a</span> <span class="pre">[b]</span> <span class="pre">b)</span></code>.</p>
<p>The <a class="reference internal" href="#extension-UndecidableInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UndecidableInstances</span></code></a> extension is also used to lift some of the
restrictions imposed on type family instances. See
<a class="reference internal" href="type_families.html#type-family-decidability"><span class="std std-ref">Decidability of type synonym instances</span></a>.</p>
</section>
<section id="overlapping-instances">
<span id="instance-overlap"></span><h2><span class="section-number">6.8.8.4. </span>Overlapping instances<a class="headerlink" href="#overlapping-instances" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-OverlappingInstances">
<span id="ghc-flag--XOverlappingInstances"></span><span id="extension-NoOverlappingInstances"></span><span class="sig-name descname"><span class="pre">OverlappingInstances</span></span><a class="headerlink" href="#extension-OverlappingInstances" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.8.1</p>
</dd>
</dl>
<p>Deprecated extension to weaken checks intended to ensure instance resolution
termination.</p>
</dd></dl>

<dl class="std extension">
<dt class="sig sig-object std" id="extension-IncoherentInstances">
<span id="ghc-flag--XIncoherentInstances"></span><span id="extension-NoIncoherentInstances"></span><span class="sig-name descname"><span class="pre">IncoherentInstances</span></span><a class="headerlink" href="#extension-IncoherentInstances" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.8.1</p>
</dd>
</dl>
<p>Deprecated extension to weaken checks intended to ensure instance resolution
termination.</p>
</dd></dl>

<p>In general, as discussed in <a class="reference internal" href="#instance-resolution"><span class="std std-ref">Instance declarations and resolution</span></a>, <em>GHC requires
that it be unambiguous which instance declaration should be used to
resolve a type-class constraint</em>. GHC also provides a way to loosen
the instance resolution, by allowing more than one instance to match,
<em>provided there is a most specific one</em>. Moreover, it can be loosened
further, by allowing more than one instance to match irrespective of
whether there is a most specific one. This section gives the details.</p>
<p>To control the choice of instance, it is possible to specify the overlap
behavior for individual instances with a pragma, written immediately
after the <code class="docutils literal notranslate"><span class="pre">instance</span></code> keyword. The pragma may be one of:
<code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">OVERLAPPING</span> <span class="pre">#-}</span></code>, <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">OVERLAPPABLE</span> <span class="pre">#-}</span></code>, <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">OVERLAPS</span> <span class="pre">#-}</span></code>,
or <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">INCOHERENT</span> <span class="pre">#-}</span></code>.</p>
<p>The matching behaviour is also influenced by two module-level language
extension flags: <a class="reference internal" href="#extension-OverlappingInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">OverlappingInstances</span></code></a> and
<a class="reference internal" href="#extension-IncoherentInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">IncoherentInstances</span></code></a>. These extensions are now
deprecated (since GHC 7.10) in favour of the fine-grained per-instance
pragmas.</p>
<p>A more precise specification is as follows. The willingness to be
overlapped or incoherent is a property of the <em>instance declaration</em>
itself, controlled as follows:</p>
<ul class="simple">
<li><p>An instance is <em>incoherent</em> if: it has an <code class="docutils literal notranslate"><span class="pre">INCOHERENT</span></code> pragma; or
if the instance has no pragma and it appears in a module compiled
with <a class="reference internal" href="#extension-IncoherentInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">IncoherentInstances</span></code></a>.</p></li>
<li><p>An instance is <em>overlappable</em> if: it has an <code class="docutils literal notranslate"><span class="pre">OVERLAPPABLE</span></code> or
<code class="docutils literal notranslate"><span class="pre">OVERLAPS</span></code> pragma; or if the instance has no pragma and it appears
in a module compiled with <a class="reference internal" href="#extension-OverlappingInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">OverlappingInstances</span></code></a>; or if the
instance is incoherent.</p></li>
<li><p>An instance is <em>overlapping</em> if: it has an <code class="docutils literal notranslate"><span class="pre">OVERLAPPING</span></code> or
<code class="docutils literal notranslate"><span class="pre">OVERLAPS</span></code> pragma; or if the instance has no pragma and it appears
in a module compiled with <a class="reference internal" href="#extension-OverlappingInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">OverlappingInstances</span></code></a>; or if the
instance is incoherent.</p></li>
</ul>
<p>Now suppose that, in some client module, we are searching for an
instance of the <em>target constraint</em> <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">ty1</span> <span class="pre">..</span> <span class="pre">tyn)</span></code>. The search works
like this:</p>
<ul class="simple">
<li><p>Find all instances <span class="math notranslate nohighlight">\(I\)</span> that <em>match</em> the target constraint; that is, the
target constraint is a substitution instance of <span class="math notranslate nohighlight">\(I\)</span>. These instance
declarations are the <em>candidates</em>.</p></li>
<li><p>If no candidates remain, the search fails</p></li>
<li><p>Eliminate any candidate <span class="math notranslate nohighlight">\(IX\)</span> for which there is another candidate
<span class="math notranslate nohighlight">\(IY\)</span> such that both of the following hold:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(IY\)</span> is strictly more specific than <span class="math notranslate nohighlight">\(IX\)</span>.  That
is, <span class="math notranslate nohighlight">\(IY\)</span> is a substitution instance of <span class="math notranslate nohighlight">\(IX\)</span> but not vice versa.</p></li>
<li><p>Either <span class="math notranslate nohighlight">\(IX\)</span> is <em>overlappable</em>, or <span class="math notranslate nohighlight">\(IY\)</span> is <em>overlapping</em>. (This
“either/or” design, rather than a “both/and” design, allow a
client to deliberately override an instance from a library,
without requiring a change to the library.)</p></li>
</ul>
</li>
<li><p>If all the remaining candidates are incoherent, the search succeeds, returning
an arbitrary surviving candidate.</p></li>
<li><p>If more than one non-incoherent candidate remains, the search fails.</p></li>
<li><p>Otherwise there is exactly one non-incoherent candidate; call it the
“prime candidate”.</p></li>
<li><p>Now find all instances, or in-scope given constraints, that <em>unify</em> with
the target constraint,
but do not <em>match</em> it. Such non-candidate instances might match when
the target constraint is further instantiated. If all of them are
incoherent top-level instances, the search succeeds, returning the prime candidate.
Otherwise the search fails.</p></li>
</ul>
<p>Notice that these rules are not influenced by flag settings in the
client module, where the instances are <em>used</em>. These rules make it
possible for a library author to design a library that relies on
overlapping instances without the client having to know.</p>
<p>Errors are reported <em>lazily</em> (when attempting to solve a constraint),
rather than <em>eagerly</em> (when the instances themselves are defined).
Consider, for example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">Int</span><span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">..</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">..</span><span class="w"></span>
</pre></div>
</div>
<p>These potentially overlap, but GHC will not complain about the instance
declarations themselves, regardless of flag settings. If we later try to
solve the constraint <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">Int</span> <span class="pre">Char)</span></code> then only the first instance
matches, and all is well. Similarly with <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">Bool</span> <span class="pre">Bool)</span></code>. But if we
try to solve <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">Int</span> <span class="pre">Bool)</span></code>, both instances match and an error is
reported.</p>
<p>As a more substantial example of the rules in action, consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="cm">{-# OVERLAPPABLE #-}</span><span class="w"> </span><span class="n">context1</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">b</span><span class="w">     </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w">  </span><span class="c1">-- (A)</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="cm">{-# OVERLAPPABLE #-}</span><span class="w"> </span><span class="n">context2</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w">   </span><span class="kt">Bool</span><span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w">  </span><span class="c1">-- (B)</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="cm">{-# OVERLAPPABLE #-}</span><span class="w"> </span><span class="n">context3</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w">   </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w">   </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w">  </span><span class="c1">-- (C)</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="cm">{-# OVERLAPPING  #-}</span><span class="w"> </span><span class="n">context4</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w">  </span><span class="c1">-- (D)</span><span class="w"></span>
</pre></div>
</div>
<p>(These all need <a class="reference internal" href="#extension-FlexibleInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">FlexibleInstances</span></code></a>.)
Now suppose that the type inference engine needs to solve the constraint
<code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">[Int]</span></code>. This constraint matches instances (A), (C) and (D), but
the last is more specific, and hence is chosen.</p>
<p>If (D) did not exist then (A) and (C) would still be matched, but
neither is most specific. In that case, the program would be rejected,
unless <a class="reference internal" href="#extension-IncoherentInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">IncoherentInstances</span></code></a> is enabled, in which case it would be
accepted and (A) or (C) would be chosen arbitrarily.</p>
<p>An instance declaration is <em>more specific</em> than another iff the head of
former is a substitution instance of the latter. For example (D) is
“more specific” than (C) because you can get from (C) to (D) by
substituting <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:=</span> <span class="pre">Int</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">:=</span> <span class="pre">Int</span></code>.</p>
<p>The final bullet (about unifying instances)
makes GHC conservative about committing to an
overlapping instance. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Suppose that from the RHS of <code class="docutils literal notranslate"><span class="pre">f</span></code> we get the constraint <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">b</span> <span class="pre">[b]</span></code>.
But GHC does not commit to instance (C), because in a particular call of
<code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> might be instantiated to <code class="docutils literal notranslate"><span class="pre">Int</span></code>, in which case instance (D)
would be more specific still. So GHC rejects the program.</p>
<p>If, however, you enable the extension <a class="reference internal" href="#extension-IncoherentInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">IncoherentInstances</span></code></a> when compiling
the module that contains (D), GHC will instead pick (C), without
complaining about the problem of subsequent instantiations.</p>
<p>Notice that we gave a type signature to <code class="docutils literal notranslate"><span class="pre">f</span></code>, so GHC had to <em>check</em>
that <code class="docutils literal notranslate"><span class="pre">f</span></code> has the specified type. Suppose instead we do not give a type
signature, asking GHC to <em>infer</em> it instead. In this case, GHC will
refrain from simplifying the constraint <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">[b]</span></code> (for the same
reason as before) but, rather than rejecting the program, it will infer
the type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>That postpones the question of which instance to pick to the call site
for <code class="docutils literal notranslate"><span class="pre">f</span></code> by which time more is known about the type <code class="docutils literal notranslate"><span class="pre">b</span></code>. You
will need the
<a class="reference internal" href="flexible_contexts.html#extension-FlexibleContexts"><code class="xref std std-extension docutils literal notranslate"><span class="pre">FlexibleContexts</span></code></a> extension.</p>
<p>Exactly the same situation can arise in instance declarations
themselves. Suppose we have</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>and, as before, the constraint <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">[b]</span></code> arises from <code class="docutils literal notranslate"><span class="pre">f</span></code>’s right
hand side. GHC will reject the instance, complaining as before that it
does not know how to resolve the constraint <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">Int</span> <span class="pre">[b]</span></code>, because it
matches more than one instance declaration. The solution is to postpone
the choice by adding the constraint to the context of the instance
declaration, thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>(You need <a class="reference internal" href="flexible_contexts.html#extension-FlexibleContexts"><code class="xref std std-extension docutils literal notranslate"><span class="pre">FlexibleContexts</span></code></a> to do this.)</p>
<p>In the unification check in the final bullet, GHC also uses the
“in-scope given constraints”.  Consider for example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>

<span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="o">.</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">blah</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="n">needs</span><span class="w"> </span><span class="p">(</span><span class="kt">C</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Here GHC will not solve the constraint <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">c</span> <span class="pre">Int)</span></code> from the
top-level instance, because a particular call of <code class="docutils literal notranslate"><span class="pre">g</span></code> might
instantiate both <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code> to the same type, which would
allow the constraint to be solved in a different way.  This latter
restriction is principally to make the constraint-solver complete.
(Interested folk can read <code class="docutils literal notranslate"><span class="pre">Note</span> <span class="pre">[Instance</span> <span class="pre">and</span> <span class="pre">Given</span> <span class="pre">overlap]</span></code> in <code class="docutils literal notranslate"><span class="pre">TcInteract</span></code>.)
It is easy to avoid: in a type signature avoid a constraint that
matches a top-level instance.  The flag <a class="reference internal" href="../using-warnings.html#ghc-flag-Wsimplifiable-class-constraints"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wsimplifiable-class-constraints</span></code></a> warns about such signatures.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Overlapping instances must be used with care. They can give
rise to incoherence (i.e. different instance choices are made in
different parts of the program) even without <a class="reference internal" href="#extension-IncoherentInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">IncoherentInstances</span></code></a>.
Consider:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE OverlappingInstances #-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">Help</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="w">    </span><span class="kr">class</span><span class="w"> </span><span class="kt">MyShow</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">myshow</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>

<span class="w">    </span><span class="kr">instance</span><span class="w"> </span><span class="kt">MyShow</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MyShow</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">myshow</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">concatMap</span><span class="w"> </span><span class="n">myshow</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>

<span class="w">    </span><span class="n">showHelp</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">MyShow</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">    </span><span class="n">showHelp</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">myshow</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>

<span class="cm">{-# LANGUAGE FlexibleInstances, OverlappingInstances #-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">Main</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">import</span><span class="w"> </span><span class="nn">Help</span><span class="w"></span>

<span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"></span>

<span class="w">    </span><span class="kr">instance</span><span class="w"> </span><span class="kt">MyShow</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">myshow</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Used generic instance&quot;</span><span class="w"></span>

<span class="w">    </span><span class="kr">instance</span><span class="w"> </span><span class="kt">MyShow</span><span class="w"> </span><span class="p">[</span><span class="kt">T</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">myshow</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Used more specific instance&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="p">(</span><span class="n">myshow</span><span class="w"> </span><span class="p">[</span><span class="kt">MkT</span><span class="p">]);</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="p">(</span><span class="n">showHelp</span><span class="w"> </span><span class="p">[</span><span class="kt">MkT</span><span class="p">])</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In function <code class="docutils literal notranslate"><span class="pre">showHelp</span></code> GHC sees no overlapping instances, and so uses
the <code class="docutils literal notranslate"><span class="pre">MyShow</span> <span class="pre">[a]</span></code> instance without complaint. In the call to <code class="docutils literal notranslate"><span class="pre">myshow</span></code>
in <code class="docutils literal notranslate"><span class="pre">main</span></code>, GHC resolves the <code class="docutils literal notranslate"><span class="pre">MyShow</span> <span class="pre">[T]</span></code> constraint using the
overlapping instance declaration in module <code class="docutils literal notranslate"><span class="pre">Main</span></code>. As a result, the
program prints</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;Used more specific instance&quot;
&quot;Used generic instance&quot;
</pre></div>
</div>
<p>(An alternative possible behaviour, not currently implemented, would be
to reject module <code class="docutils literal notranslate"><span class="pre">Help</span></code> on the grounds that a later instance
declaration might overlap the local one.)</p>
</div>
</section>
<section id="instance-signatures-type-signatures-in-instance-declarations">
<span id="instance-sigs"></span><h2><span class="section-number">6.8.8.5. </span>Instance signatures: type signatures in instance declarations<a class="headerlink" href="#instance-signatures-type-signatures-in-instance-declarations" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-InstanceSigs">
<span id="ghc-flag--XInstanceSigs"></span><span id="extension-NoInstanceSigs"></span><span class="sig-name descname"><span class="pre">InstanceSigs</span></span><a class="headerlink" href="#extension-InstanceSigs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.6.1</p>
</dd>
</dl>
<p>Allow type signatures for members in instance definitions.</p>
</dd></dl>

<p>In Haskell, you can’t write a type signature in an instance declaration,
but it is sometimes convenient to do so, and the language extension
<a class="reference internal" href="#extension-InstanceSigs"><code class="xref std std-extension docutils literal notranslate"><span class="pre">InstanceSigs</span></code></a> allows you to do so. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">==</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w">   </span><span class="c1">-- The signature</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">==</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">MkT</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="n">x2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">MkTy</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="n">y2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x1</span><span class="o">==</span><span class="n">y1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">x2</span><span class="o">==</span><span class="n">y2</span><span class="w"></span>
</pre></div>
</div>
<p>Some details</p>
<ul>
<li><p>The type signature in the instance declaration must be more
polymorphic than (or the same as) the one in the class declaration,
instantiated with the instance type. For example, this is fine:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="p">(</span><span class="o">==</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="w">   </span><span class="p">(</span><span class="o">==</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
<p>Here the signature in the instance declaration is more polymorphic
than that required by the instantiated class method.</p>
</li>
<li><p>The code for the method in the instance declaration is typechecked
against the type signature supplied in the instance declaration, as
you would expect. So if the instance signature is more polymorphic
than required, the code must be too.</p></li>
<li><p>One stylistic reason for wanting to write a type signature is simple
documentation. Another is that you may want to bring scoped type
variables into scope. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">])</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">])</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="kr">where</span><span class="w"></span>
<span class="w">       </span><span class="n">xs</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"></span>
<span class="w">       </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Provided that you also specify <a class="reference internal" href="scoped_type_variables.html#extension-ScopedTypeVariables"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ScopedTypeVariables</span></code></a>
(<a class="reference internal" href="scoped_type_variables.html#scoped-type-variables"><span class="std std-ref">Lexically scoped type variables</span></a>), the <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">b</span></code> scopes over the
definition of <code class="docutils literal notranslate"><span class="pre">foo</span></code>, and in particular over the type signature for
<code class="docutils literal notranslate"><span class="pre">xs</span></code>.</p>
</li>
</ul>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="literals.html" class="btn btn-neutral float-right" title="6.9. Literals" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="functional_dependencies.html" class="btn btn-neutral float-left" title="6.8.7. Functional dependencies" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
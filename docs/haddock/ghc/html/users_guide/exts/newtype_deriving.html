

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.6.5. Generalised derived instances for newtypes &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.6.6. Deriving any other class" href="derive_any_class.html" />
    <link rel="prev" title="6.6.4. Deriving instances of extra classes (Data, etc.)" href="deriving_extra.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="empty_data_deriving.html">6.6.1. Deriving instances for empty data types</a></li>
<li class="toctree-l3"><a class="reference internal" href="deriving_inferred.html">6.6.2. Inferred context for deriving clauses</a></li>
<li class="toctree-l3"><a class="reference internal" href="standalone_deriving.html">6.6.3. Stand-alone deriving declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="deriving_extra.html">6.6.4. Deriving instances of extra classes (<code class="docutils literal notranslate"><span class="pre">Data</span></code>, etc.)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.6.5. Generalised derived instances for newtypes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#generalising-the-deriving-clause">6.6.5.1. Generalising the deriving clause</a></li>
<li class="toctree-l4"><a class="reference internal" href="#a-more-precise-specification">6.6.5.2. A more precise specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#associated-type-families">6.6.5.3. Associated type families</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="derive_any_class.html">6.6.6. Deriving any other class</a></li>
<li class="toctree-l3"><a class="reference internal" href="deriving_strategies.html">6.6.7. Deriving strategies</a></li>
<li class="toctree-l3"><a class="reference internal" href="deriving_via.html">6.6.8. Deriving via</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="deriving.html"><span class="section-number">6.6. </span>Deriving mechanism</a> &raquo;</li>
        
      <li><span class="section-number">6.6.5. </span>Generalised derived instances for newtypes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/newtype_deriving.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="generalised-derived-instances-for-newtypes">
<span id="newtype-deriving"></span><h1><span class="section-number">6.6.5. </span>Generalised derived instances for newtypes<a class="headerlink" href="#generalised-derived-instances-for-newtypes" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-GeneralisedNewtypeDeriving">
<span id="ghc-flag--XGeneralisedNewtypeDeriving"></span><span id="extension-NoGeneralisedNewtypeDeriving"></span><span class="sig-name descname"><span class="pre">GeneralisedNewtypeDeriving</span></span><a class="headerlink" href="#extension-GeneralisedNewtypeDeriving" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="extension-GeneralizedNewtypeDeriving">
<span id="ghc-flag--XGeneralizedNewtypeDeriving"></span><span id="extension-NoGeneralizedNewtypeDeriving"></span><span class="sig-name descname"><span class="pre">GeneralizedNewtypeDeriving</span></span><a class="headerlink" href="#extension-GeneralizedNewtypeDeriving" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.8.1. British spelling since 8.6.1.</p>
</dd>
</dl>
<p>Enable GHC’s cunning generalised deriving mechanism for <code class="docutils literal notranslate"><span class="pre">newtype</span></code>s</p>
</dd></dl>

<p>When you define an abstract type using <code class="docutils literal notranslate"><span class="pre">newtype</span></code>, you may want the new
type to inherit some instances from its representation. In Haskell 98,
you can inherit instances of <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, <code class="docutils literal notranslate"><span class="pre">Enum</span></code> and <code class="docutils literal notranslate"><span class="pre">Bounded</span></code>
by deriving them, but for any other classes you have to write an
explicit instance declaration. For example, if you define</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">Dollars</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Dollars</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>and you want to use arithmetic on <code class="docutils literal notranslate"><span class="pre">Dollars</span></code>, you have to explicitly
define an instance of <code class="docutils literal notranslate"><span class="pre">Num</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="kt">Dollars</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">Dollars</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">Dollars</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Dollars</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>All the instance does is apply and remove the <code class="docutils literal notranslate"><span class="pre">newtype</span></code> constructor.
It is particularly galling that, since the constructor doesn’t appear at
run-time, this instance declaration defines a dictionary which is
<em>wholly equivalent</em> to the <code class="docutils literal notranslate"><span class="pre">Int</span></code> dictionary, only slower!</p>
<p><a class="reference internal" href="deriving_via.html#extension-DerivingVia"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DerivingVia</span></code></a> (see <a class="reference internal" href="deriving_via.html#deriving-via"><span class="std std-ref">Deriving via</span></a>) is a generalization of
this idea.</p>
<section id="generalising-the-deriving-clause">
<span id="generalized-newtype-deriving"></span><h2><span class="section-number">6.6.5.1. </span>Generalising the deriving clause<a class="headerlink" href="#generalising-the-deriving-clause" title="Permalink to this heading">¶</a></h2>
<p>GHC now permits such instances to be derived instead, using the extension
<a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code class="xref std std-extension docutils literal notranslate"><span class="pre">GeneralizedNewtypeDeriving</span></code></a>, so one can write</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">Dollars</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Dollars</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">getDollars</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="kt">Show</span><span class="p">,</span><span class="kt">Num</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>and the implementation uses the <em>same</em> <code class="docutils literal notranslate"><span class="pre">Num</span></code> dictionary for
<code class="docutils literal notranslate"><span class="pre">Dollars</span></code> as for <code class="docutils literal notranslate"><span class="pre">Int</span></code>. In other words, GHC will generate something that
resembles the following code</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="kt">Dollars</span><span class="w"></span>
</pre></div>
</div>
<p>and then attempt to simplify the <code class="docutils literal notranslate"><span class="pre">Num</span> <span class="pre">Int</span></code> context as much as possible.
GHC knows that there is a <code class="docutils literal notranslate"><span class="pre">Num</span> <span class="pre">Int</span></code> instance in scope, so it is able to
discharge the <code class="docutils literal notranslate"><span class="pre">Num</span> <span class="pre">Int</span></code> constraint, leaving the code that GHC actually
generates</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="kt">Dollars</span><span class="w"></span>
</pre></div>
</div>
<p>One can think of this instance being implemented with the same code as the
<code class="docutils literal notranslate"><span class="pre">Num</span> <span class="pre">Int</span></code> instance, but with <code class="docutils literal notranslate"><span class="pre">Dollars</span></code> and <code class="docutils literal notranslate"><span class="pre">getDollars</span></code> added wherever
necessary in order to make it typecheck. (In practice, GHC uses a somewhat
different approach to code generation. See the <a class="reference internal" href="#precise-gnd-specification"><span class="std std-ref">A more precise specification</span></a>
section below for more details.)</p>
<p>We can also derive instances of constructor classes in a similar way.
For example, suppose we have implemented state and failure monad
transformers, such that</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="kt">State</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="kt">Failure</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>In Haskell 98, we can define a parsing monad by</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">Parser</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="p">[</span><span class="n">tok</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">Failure</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>which is automatically a monad thanks to the instance declarations
above. With the extension, we can make the parser type abstract, without
needing to write an instance of class <code class="docutils literal notranslate"><span class="pre">Monad</span></code>, via</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">Parser</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Parser</span><span class="w"> </span><span class="p">(</span><span class="kt">State</span><span class="w"> </span><span class="p">[</span><span class="n">tok</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">Failure</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="w">                       </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Monad</span><span class="w"></span>
</pre></div>
</div>
<p>In this case the derived instance declaration is of the form</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="kt">State</span><span class="w"> </span><span class="p">[</span><span class="n">tok</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">Failure</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="kt">Parser</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that, since <code class="docutils literal notranslate"><span class="pre">Monad</span></code> is a constructor class, the instance is a
<em>partial application</em> of the newtype, not the entire left hand side. We
can imagine that the type declaration is “eta-converted” to generate the
context of the instance declaration.</p>
<p>We can even derive instances of multi-parameter classes, provided the
newtype is the last class parameter. In this case, a “partial
application” of the class appears in the <code class="docutils literal notranslate"><span class="pre">deriving</span></code> clause. For
example, given the class</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">StateMonad</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">StateMonad</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="kt">State</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>then we can derive an instance of <code class="docutils literal notranslate"><span class="pre">StateMonad</span></code> for <code class="docutils literal notranslate"><span class="pre">Parser</span></code> by</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">Parser</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Parser</span><span class="w"> </span><span class="p">(</span><span class="kt">State</span><span class="w"> </span><span class="p">[</span><span class="n">tok</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">Failure</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="w">                       </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Monad</span><span class="p">,</span><span class="w"> </span><span class="kt">StateMonad</span><span class="w"> </span><span class="p">[</span><span class="n">tok</span><span class="p">])</span><span class="w"></span>
</pre></div>
</div>
<p>The derived instance is obtained by completing the application of the
class to the new type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">StateMonad</span><span class="w"> </span><span class="p">[</span><span class="n">tok</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">State</span><span class="w"> </span><span class="p">[</span><span class="n">tok</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">Failure</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"></span>
<span class="w">         </span><span class="kt">StateMonad</span><span class="w"> </span><span class="p">[</span><span class="n">tok</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">Parser</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>As a result of this extension, all derived instances in newtype
declarations are treated uniformly (and implemented just by reusing the
dictionary for the representation type), <em>except</em> <code class="docutils literal notranslate"><span class="pre">Show</span></code> and <code class="docutils literal notranslate"><span class="pre">Read</span></code>,
which really behave differently for the newtype and its representation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is sometimes necessary to enable additional language extensions when
deriving instances via <a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code class="xref std std-extension docutils literal notranslate"><span class="pre">GeneralizedNewtypeDeriving</span></code></a>. For instance,
consider a simple class and instance using <a class="reference internal" href="primitives.html#extension-UnboxedTuples"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnboxedTuples</span></code></a>
syntax:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE UnboxedTuples #-}</span><span class="w"></span>

<span class="kr">module</span><span class="w"> </span><span class="nn">Lib</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">AClass</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">aMethod</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">AClass</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">aMethod</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The following will fail with an “Illegal unboxed tuple” error, since the
derived instance produced by the compiler makes use of unboxed tuple syntax,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Lib</span><span class="w"></span>

<span class="kr">newtype</span><span class="w"> </span><span class="kt">Int&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int&#39;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">             </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">AClass</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>However, enabling the <a class="reference internal" href="primitives.html#extension-UnboxedTuples"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnboxedTuples</span></code></a> extension allows the module
to compile. Similar errors may occur with a variety of extensions,
including:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="primitives.html#extension-UnboxedTuples"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnboxedTuples</span></code></a></p></li>
<li><p><a class="reference internal" href="poly_kinds.html#extension-PolyKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PolyKinds</span></code></a></p></li>
<li><p><a class="reference internal" href="multi_param_type_classes.html#extension-MultiParamTypeClasses"><code class="xref std std-extension docutils literal notranslate"><span class="pre">MultiParamTypeClasses</span></code></a></p></li>
<li><p><a class="reference internal" href="flexible_contexts.html#extension-FlexibleContexts"><code class="xref std std-extension docutils literal notranslate"><span class="pre">FlexibleContexts</span></code></a></p></li>
</ul>
</div></blockquote>
</div>
</section>
<section id="a-more-precise-specification">
<span id="precise-gnd-specification"></span><h2><span class="section-number">6.6.5.2. </span>A more precise specification<a class="headerlink" href="#a-more-precise-specification" title="Permalink to this heading">¶</a></h2>
<p>A derived instance is derived only for declarations of these forms
(after expansion of any type synonyms)</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">v1</span><span class="o">..</span><span class="n">vn</span><span class="w">                   </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="n">vk</span><span class="o">+</span><span class="mi">1</span><span class="o">..</span><span class="n">vn</span><span class="p">)</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">C</span><span class="w"> </span><span class="n">t1</span><span class="o">..</span><span class="n">tj</span><span class="p">)</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">s1</span><span class="o">..</span><span class="n">sk</span><span class="w"> </span><span class="n">vk</span><span class="o">+</span><span class="mi">1</span><span class="o">..</span><span class="n">vn</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="n">vk</span><span class="o">+</span><span class="mi">1</span><span class="o">..</span><span class="n">vn</span><span class="p">)</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">C</span><span class="w"> </span><span class="n">t1</span><span class="o">..</span><span class="n">tj</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v1..vn</span></code> are type variables, and <code class="docutils literal notranslate"><span class="pre">t</span></code>, <code class="docutils literal notranslate"><span class="pre">s1..sk</span></code>, <code class="docutils literal notranslate"><span class="pre">t1..tj</span></code> are
types.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">t1..tj)</span></code> is a partial applications of the class <code class="docutils literal notranslate"><span class="pre">C</span></code>,
where the arity of <code class="docutils literal notranslate"><span class="pre">C</span></code> is exactly <code class="docutils literal notranslate"><span class="pre">j+1</span></code>. That is, <code class="docutils literal notranslate"><span class="pre">C</span></code> lacks
exactly one type argument.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> is chosen so that <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">t1..tj</span> <span class="pre">(T</span> <span class="pre">v1...vk)</span></code> is well-kinded. (Or,
in the case of a <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">instance</span></code>, so that <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">t1..tj</span> <span class="pre">(T</span> <span class="pre">s1..sk)</span></code>
is well kinded.)</p></li>
<li><p>The type <code class="docutils literal notranslate"><span class="pre">t</span></code> is an arbitrary type.</p></li>
<li><p>The type variables <code class="docutils literal notranslate"><span class="pre">vk+1...vn</span></code> do not occur in the types <code class="docutils literal notranslate"><span class="pre">t</span></code>,
<code class="docutils literal notranslate"><span class="pre">s1..sk</span></code>, or <code class="docutils literal notranslate"><span class="pre">t1..tj</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code> is not <code class="docutils literal notranslate"><span class="pre">Read</span></code>, <code class="docutils literal notranslate"><span class="pre">Show</span></code>, <code class="docutils literal notranslate"><span class="pre">Typeable</span></code>, or <code class="docutils literal notranslate"><span class="pre">Data</span></code>. These
classes should not “look through” the type or its constructor. You
can still derive these classes for a newtype, but it happens in the
usual way, not via this new mechanism. Confer with
<a class="reference internal" href="deriving_strategies.html#default-deriving-strategy"><span class="std std-ref">Default deriving strategy</span></a>.</p></li>
<li><p>It is safe to coerce each of the methods of <code class="docutils literal notranslate"><span class="pre">C</span></code>. That is, the
missing last argument to <code class="docutils literal notranslate"><span class="pre">C</span></code> is not used at a nominal role in any
of the <code class="docutils literal notranslate"><span class="pre">C</span></code>’s methods. (See <a class="reference internal" href="roles.html#roles"><span class="std std-ref">Roles</span></a>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code> is allowed to have associated type families, provided they meet the
requirements laid out in the section on <a class="reference internal" href="#gnd-and-associated-types"><span class="std std-ref">GND and associated types</span></a>.</p></li>
</ul>
<p>Then the derived instance declaration is of the form</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">t1</span><span class="o">..</span><span class="n">tj</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">t1</span><span class="o">..</span><span class="n">tj</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">v1</span><span class="o">...</span><span class="n">vk</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Note that if <code class="docutils literal notranslate"><span class="pre">C</span></code> does not contain any class methods, the instance context
is wholly unnecessary, and as such GHC will instead generate:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">t1</span><span class="o">..</span><span class="n">tj</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">v1</span><span class="o">..</span><span class="n">vk</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>As an example which does <em>not</em> work, consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">NonMonad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">NonMonad</span><span class="w"> </span><span class="p">(</span><span class="kt">State</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Monad</span><span class="w"></span>
</pre></div>
</div>
<p>Here we cannot derive the instance</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="kt">State</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="kt">NonMonad</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>because the type variable <code class="docutils literal notranslate"><span class="pre">s</span></code> occurs in <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">s</span> <span class="pre">m</span></code>, and so cannot
be “eta-converted” away. It is a good thing that this <code class="docutils literal notranslate"><span class="pre">deriving</span></code>
clause is rejected, because <code class="docutils literal notranslate"><span class="pre">NonMonad</span> <span class="pre">m</span></code> is not, in fact, a monad —
for the same reason. Try defining <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> with the correct type: you
won’t be able to.</p>
<p>Notice also that the <em>order</em> of class parameters becomes important,
since we can only derive instances for the last one. If the
<code class="docutils literal notranslate"><span class="pre">StateMonad</span></code> class above were instead defined as</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">StateMonad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>then we would not have been able to derive an instance for the
<code class="docutils literal notranslate"><span class="pre">Parser</span></code> type above. We hypothesise that multi-parameter classes
usually have one “main” parameter for which deriving new instances is
most interesting.</p>
<p>Lastly, all of this applies only for classes other than <code class="docutils literal notranslate"><span class="pre">Read</span></code>,
<code class="docutils literal notranslate"><span class="pre">Show</span></code>, <code class="docutils literal notranslate"><span class="pre">Typeable</span></code>, and <code class="docutils literal notranslate"><span class="pre">Data</span></code>, for which the stock derivation
applies (section 4.3.3. of the Haskell Report). (For the standard
classes <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, <code class="docutils literal notranslate"><span class="pre">Ix</span></code>, and <code class="docutils literal notranslate"><span class="pre">Bounded</span></code> it is immaterial
whether the stock method is used or the one described here.)</p>
</section>
<section id="associated-type-families">
<span id="gnd-and-associated-types"></span><h2><span class="section-number">6.6.5.3. </span>Associated type families<a class="headerlink" href="#associated-type-families" title="Permalink to this heading">¶</a></h2>
<p><a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code class="xref std std-extension docutils literal notranslate"><span class="pre">GeneralizedNewtypeDeriving</span></code></a> also works for some type classes with
associated type families. Here is an example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">HasRing</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Ring</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="kr">newtype</span><span class="w"> </span><span class="kt">L1Norm</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">L1Norm</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">HasRing</span><span class="w"></span>
</pre></div>
</div>
<p>The derived <code class="docutils literal notranslate"><span class="pre">HasRing</span></code> instance would look like</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">HasRing</span><span class="w"> </span><span class="p">(</span><span class="kt">L1Norm</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Ring</span><span class="w"> </span><span class="p">(</span><span class="kt">L1Norm</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Ring</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>To be precise, if the class being derived is of the form</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">c_1</span><span class="w"> </span><span class="n">c_2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">c_m</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="n">t1_1</span><span class="w"> </span><span class="n">t1_2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">t1_n</span><span class="w"></span>
<span class="w">  </span><span class="o">...</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Tk</span><span class="w"> </span><span class="n">tk_1</span><span class="w"> </span><span class="n">tk_2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">tk_p</span><span class="w"></span>
</pre></div>
</div>
<p>and the newtype is of the form</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">N</span><span class="w"> </span><span class="n">n_1</span><span class="w"> </span><span class="n">n_2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">n_q</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkN</span><span class="w"> </span><span class="o">&lt;</span><span class="n">rep</span><span class="o">-</span><span class="kr">type</span><span class="o">&gt;</span><span class="w"></span>
</pre></div>
</div>
<p>then you can derive a <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">c_1</span> <span class="pre">c_2</span> <span class="pre">...</span> <span class="pre">c_(m-1)</span></code> instance for
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">n_1</span> <span class="pre">n_2</span> <span class="pre">...</span> <span class="pre">n_q</span></code>, provided that:</p>
<ul>
<li><p>The type parameter <code class="docutils literal notranslate"><span class="pre">c_m</span></code> occurs once in each of the type variables of
<code class="docutils literal notranslate"><span class="pre">T1</span></code> through <code class="docutils literal notranslate"><span class="pre">Tk</span></code>. Imagine a class where this condition didn’t hold.
For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Bad</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Bad</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Char</span><span class="w"></span>

<span class="kr">newtype</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Bad</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>For the derived <code class="docutils literal notranslate"><span class="pre">Bad</span> <span class="pre">Int</span></code> instance, GHC would need to generate something
like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Bad</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">(</span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="o">???</span><span class="w"></span>
</pre></div>
</div>
<p>Now we’re stuck, since we have no way to refer to <code class="docutils literal notranslate"><span class="pre">a</span></code> on the right-hand
side of the <code class="docutils literal notranslate"><span class="pre">B</span></code> family instance, so this instance doesn’t really make sense
in a <a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code class="xref std std-extension docutils literal notranslate"><span class="pre">GeneralizedNewtypeDeriving</span></code></a> setting.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code> does not have any associated data families (only type families). To
see why data families are forbidden, imagine the following scenario:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Ex</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Ex</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">DInt</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>

<span class="kr">newtype</span><span class="w"> </span><span class="kt">Age</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkAge</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Ex</span><span class="w"></span>
</pre></div>
</div>
<p>For the derived <code class="docutils literal notranslate"><span class="pre">Ex</span></code> instance, GHC would need to generate something like
this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Ex</span><span class="w"> </span><span class="kt">Age</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="kt">Age</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">???</span><span class="w"></span>
</pre></div>
</div>
<p>But it is not clear what GHC would fill in for <code class="docutils literal notranslate"><span class="pre">???</span></code>, as each data family
instance must generate fresh data constructors.</p>
</li>
</ul>
<p>If both of these conditions are met, GHC will generate this instance:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">c_1</span><span class="w"> </span><span class="n">c_2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">c_</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="n">rep</span><span class="o">-</span><span class="kr">type</span><span class="o">&gt;</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"></span>
<span class="w">         </span><span class="kt">C</span><span class="w"> </span><span class="n">c_1</span><span class="w"> </span><span class="n">c_2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">c_</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">N</span><span class="w"> </span><span class="n">n_1</span><span class="w"> </span><span class="n">n_2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">n_q</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="n">t1_1</span><span class="w"> </span><span class="n">t1_2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">(</span><span class="kt">N</span><span class="w"> </span><span class="n">n_1</span><span class="w"> </span><span class="n">n_2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">n_q</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">t1_n</span><span class="w"></span>
<span class="w">     </span><span class="ow">=</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="n">t1_1</span><span class="w"> </span><span class="n">t1_2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="o">&lt;</span><span class="n">rep</span><span class="o">-</span><span class="kr">type</span><span class="o">&gt;</span><span class="w">          </span><span class="o">...</span><span class="w"> </span><span class="n">t1_n</span><span class="w"></span>
<span class="w">  </span><span class="o">...</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Tk</span><span class="w"> </span><span class="n">tk_1</span><span class="w"> </span><span class="n">tk_2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">(</span><span class="kt">N</span><span class="w"> </span><span class="n">n_1</span><span class="w"> </span><span class="n">n_2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">n_q</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">tk_p</span><span class="w"></span>
<span class="w">     </span><span class="ow">=</span><span class="w"> </span><span class="kt">Tk</span><span class="w"> </span><span class="n">tk_1</span><span class="w"> </span><span class="n">tk_2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="o">&lt;</span><span class="n">rep</span><span class="o">-</span><span class="kr">type</span><span class="o">&gt;</span><span class="w">          </span><span class="o">...</span><span class="w"> </span><span class="n">tk_p</span><span class="w"></span>
</pre></div>
</div>
<p>Again, if <code class="docutils literal notranslate"><span class="pre">C</span></code> contains no class methods, the instance context will be
redundant, so GHC will instead generate
<code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">C</span> <span class="pre">c_1</span> <span class="pre">c_2</span> <span class="pre">...</span> <span class="pre">c_(m-1)</span> <span class="pre">(N</span> <span class="pre">n_1</span> <span class="pre">n_2</span> <span class="pre">...</span> <span class="pre">n_q)</span></code>.</p>
<p>Beware that in some cases, you may need to enable the
<a class="reference internal" href="instances.html#extension-UndecidableInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UndecidableInstances</span></code></a> extension in order to use this feature.
Here’s a pathological case that illustrates why this might happen:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="kr">newtype</span><span class="w"> </span><span class="kt">Loop</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkLoop</span><span class="w"> </span><span class="kt">Loop</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">C</span><span class="w"></span>
</pre></div>
</div>
<p>This will generate the derived instance:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">Loop</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Loop</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Loop</span><span class="w"></span>
</pre></div>
</div>
<p>Here, it is evident that attempting to use the type <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">Loop</span></code> will throw the
typechecker into an infinite loop, as its definition recurses endlessly. In
other cases, you might need to enable <a class="reference internal" href="instances.html#extension-UndecidableInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UndecidableInstances</span></code></a> even
if the generated code won’t put the typechecker into a loop. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>

<span class="kr">newtype</span><span class="w"> </span><span class="kt">MyInt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MyInt</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">C</span><span class="w"></span>
</pre></div>
</div>
<p>This will generate the derived instance:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">MyInt</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">MyInt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>Although typechecking <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">MyInt</span></code> will terminate, GHC’s termination checker
isn’t sophisticated enough to determine this, so you’ll need to enable
<a class="reference internal" href="instances.html#extension-UndecidableInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UndecidableInstances</span></code></a> in order to use this derived instance. If
you do go down this route, make sure you can convince yourself that all of
the type family instances you’re deriving will eventually terminate if used!</p>
<p>Note that <a class="reference internal" href="deriving_via.html#extension-DerivingVia"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DerivingVia</span></code></a> (see <a class="reference internal" href="deriving_via.html#deriving-via"><span class="std std-ref">Deriving via</span></a>) uses essentially
the same specification to derive instances of associated type families as well
(except that it uses the <code class="docutils literal notranslate"><span class="pre">via</span></code> type instead of the underlying <code class="docutils literal notranslate"><span class="pre">rep-type</span></code>
of a newtype).</p>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="derive_any_class.html" class="btn btn-neutral float-right" title="6.6.6. Deriving any other class" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="deriving_extra.html" class="btn btn-neutral float-left" title="6.6.4. Deriving instances of extra classes (Data, etc.)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
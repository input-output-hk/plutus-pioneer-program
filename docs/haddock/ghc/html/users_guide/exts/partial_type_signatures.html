

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.11.6. Partial Type Signatures &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.12. Bindings and generalisation" href="bindings.html" />
    <link rel="prev" title="6.11.5. Implicit parameters" href="implicit_parameters.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="explicit_forall.html">6.11.1. Explicit universal quantification (forall)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ambiguous_types.html">6.11.2. Ambiguous types and the ambiguity check</a></li>
<li class="toctree-l3"><a class="reference internal" href="kind_signatures.html">6.11.3. Explicitly-kinded quantification</a></li>
<li class="toctree-l3"><a class="reference internal" href="scoped_type_variables.html">6.11.4. Lexically scoped type variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="implicit_parameters.html">6.11.5. Implicit parameters</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.11.6. Partial Type Signatures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#syntax">6.11.6.1. Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#where-can-they-occur">6.11.6.2. Where can they occur?</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="type_signatures.html"><span class="section-number">6.11. </span>Type signatures</a> &raquo;</li>
        
      <li><span class="section-number">6.11.6. </span>Partial Type Signatures</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/partial_type_signatures.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="partial-type-signatures">
<span id="id1"></span><h1><span class="section-number">6.11.6. </span>Partial Type Signatures<a class="headerlink" href="#partial-type-signatures" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-PartialTypeSignatures">
<span id="ghc-flag--XPartialTypeSignatures"></span><span id="extension-NoPartialTypeSignatures"></span><span class="sig-name descname"><span class="pre">PartialTypeSignatures</span></span><a class="headerlink" href="#extension-PartialTypeSignatures" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.10.1</p>
</dd>
</dl>
<p>Type checker will allow inferred types for holes.</p>
</dd></dl>

<p>A partial type signature is a type signature containing special
placeholders called <em>wildcards</em>. A wildcard is written as an underscore (e.g. “<code class="docutils literal notranslate"><span class="pre">_</span></code>”)
or, if <a class="reference internal" href="#extension-NamedWildCards"><code class="xref std std-extension docutils literal notranslate"><span class="pre">NamedWildCards</span></code></a> is enabled, any identifier with a leading
underscore (e.g. “<code class="docutils literal notranslate"><span class="pre">_foo</span></code>”, “<code class="docutils literal notranslate"><span class="pre">_bar</span></code>”). Partial type signatures are to type
signatures what <a class="reference internal" href="typed_holes.html#typed-holes"><span class="std std-ref">Typed Holes</span></a> are to expressions. During compilation these
wildcards or holes will generate an error message that describes which type was
inferred at the hole’s location, and information about the origin of any free
type variables. GHC reports such error messages by default.</p>
<p>Unlike <a class="reference internal" href="typed_holes.html#typed-holes"><span class="std std-ref">Typed Holes</span></a>, which make the program incomplete and will
generate errors when they are evaluated, this needn’t be the case for
holes in type signatures. The type checker is capable (in most cases) of
type-checking a binding with or without a type signature. A partial type
signature bridges the gap between the two extremes, the programmer can
choose which parts of a type to annotate and which to leave over to the
type-checker to infer.</p>
<p>By default, the type-checker will report an error message for each hole
in a partial type signature, informing the programmer of the inferred
type. When the <a class="reference internal" href="#extension-PartialTypeSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PartialTypeSignatures</span></code></a> extension is enabled, the
type-checker will accept the inferred type for each hole, generating
warnings instead of errors. Additionally, these warnings can be silenced
with the <a class="reference internal" href="../using-warnings.html#ghc-flag-Wpartial-type-signatures"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wno-partial-type-signatures</span></code></a>
flag.</p>
<p>However, because GHC must <em>infer</em> the type when part of a type is left
out, it is unable to use polymorphic recursion. The same restriction
takes place when the type signature is omitted completely.</p>
<p>A partial type signature als makes GHC generalise the binding even if
<a class="reference internal" href="let_generalisation.html#extension-MonoLocalBinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">MonoLocalBinds</span></code></a> is on; see <a class="reference internal" href="let_generalisation.html#mono-local-binds"><span class="std std-ref">Let-generalisation</span></a>.</p>
<section id="syntax">
<span id="pts-syntax"></span><h2><span class="section-number">6.11.6.1. </span>Syntax<a class="headerlink" href="#syntax" title="Permalink to this heading">¶</a></h2>
<p>A (partial) type signature has the following form:
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">..</span> <span class="pre">.</span> <span class="pre">(C1,</span> <span class="pre">C2,</span> <span class="pre">..)</span> <span class="pre">=&gt;</span> <span class="pre">tau</span></code>. It consists of three parts:</p>
<ul class="simple">
<li><p>The type variables:
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">b</span> <span class="pre">..</span></code></p></li>
<li><p>The constraints:
<code class="docutils literal notranslate"><span class="pre">(C1,</span> <span class="pre">C2,</span> <span class="pre">..)</span></code></p></li>
<li><p>The (mono)type:
<code class="docutils literal notranslate"><span class="pre">tau</span></code></p></li>
</ul>
<p>We distinguish three kinds of wildcards.</p>
<section id="type-wildcards">
<span id="id2"></span><h3><span class="section-number">6.11.6.1.1. </span>Type Wildcards<a class="headerlink" href="#type-wildcards" title="Permalink to this heading">¶</a></h3>
<p>Wildcards occurring within the monotype (tau) part of the type signature
are <em>type wildcards</em> (“type” is often omitted as this is the default
kind of wildcard). Type wildcards can be instantiated to any monotype
like <code class="docutils literal notranslate"><span class="pre">Bool</span></code> or <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">[Bool]</span></code>, including functions and higher-kinded
types like <code class="docutils literal notranslate"><span class="pre">(Int</span> <span class="pre">-&gt;</span> <span class="pre">Bool)</span></code> or <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">not&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">_</span><span class="w"></span>
<span class="nf">not&#39;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="c1">-- Inferred: Bool -&gt; Bool</span><span class="w"></span>

<span class="nf">maybools</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kr">_</span><span class="w"></span>
<span class="nf">maybools</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="p">[</span><span class="kt">True</span><span class="p">]</span><span class="w"></span>
<span class="c1">-- Inferred: Maybe [Bool]</span><span class="w"></span>

<span class="nf">just1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">just1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="c1">-- Inferred: Maybe Int</span><span class="w"></span>

<span class="nf">filterInt</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"></span>
<span class="nf">filterInt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="c1">-- has type forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]</span><span class="w"></span>
<span class="c1">-- Inferred: (Int -&gt; Bool) -&gt; [Int] -&gt; [Int]</span><span class="w"></span>
</pre></div>
</div>
<p>For instance, the first wildcard in the type signature <code class="docutils literal notranslate"><span class="pre">not'</span></code> would
produce the following error message:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Test.hs:4:17: error:
    • Found type wildcard ‘_’ standing for ‘Bool’
      To use the inferred type, enable PartialTypeSignatures
    • In the type signature:
        not&#39; :: Bool -&gt; _
    • Relevant bindings include
        not&#39; :: Bool -&gt; Bool (bound at Test.hs:5:1)
</pre></div>
</div>
<p>When a wildcard is not instantiated to a monotype, it will be
generalised over, i.e. replaced by a fresh type variable, e.g.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">_</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="c1">-- Inferred: forall t. t -&gt; t</span><span class="w"></span>

<span class="nf">filter&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kr">_</span><span class="w"></span>
<span class="nf">filter&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="c1">-- has type forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]</span><span class="w"></span>
<span class="c1">-- Inferred: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="named-wildcards">
<span id="id3"></span><h3><span class="section-number">6.11.6.1.2. </span>Named Wildcards<a class="headerlink" href="#named-wildcards" title="Permalink to this heading">¶</a></h3>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-NamedWildCards">
<span id="ghc-flag--XNamedWildCards"></span><span id="extension-NoNamedWildCards"></span><span class="sig-name descname"><span class="pre">NamedWildCards</span></span><a class="headerlink" href="#extension-NamedWildCards" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.10.1</p>
</dd>
</dl>
<p>Allow naming of wildcards (e.g. <code class="docutils literal notranslate"><span class="pre">_x</span></code>) in type signatures.</p>
</dd></dl>

<p>Type wildcards can also be named by giving the underscore an identifier
as suffix, i.e. <code class="docutils literal notranslate"><span class="pre">_a</span></code>. These are called <em>named wildcards</em>. All
occurrences of the same named wildcard within one type signature will
unify to the same type. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">_x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">_x</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;d&#39;</span><span class="p">,</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">&quot;Urk&quot;</span><span class="p">)</span><span class="w"></span>
<span class="c1">-- Inferred: forall t. (Char, t) -&gt; (Char, t)</span><span class="w"></span>
</pre></div>
</div>
<p>The named wildcard forces the argument and result types to be the same.
Lacking a signature, GHC would have inferred
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a</span> <span class="pre">b.</span> <span class="pre">(Char,</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">(Char,</span> <span class="pre">b)</span></code>. A named wildcard can be
mentioned in constraints, provided it also occurs in the monotype part
of the type signature to make sure that it unifies with something:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">somethingShowable</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">_x</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">_x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">_</span><span class="w"></span>
<span class="nf">somethingShowable</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="c1">-- Inferred type: Show a =&gt; a -&gt; String</span><span class="w"></span>

<span class="nf">somethingShowable&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">_x</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">_x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">_</span><span class="w"></span>
<span class="nf">somethingShowable&#39;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="p">(</span><span class="n">not</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="c1">-- Inferred type: Bool -&gt; String</span><span class="w"></span>
</pre></div>
</div>
<p>Besides an extra-constraints wildcard (see
<a class="reference internal" href="#extra-constraints-wildcard"><span class="std std-ref">Extra-Constraints Wildcard</span></a>), only named wildcards can occur in
the constraints, e.g. the <code class="docutils literal notranslate"><span class="pre">_x</span></code> in <code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">_x</span></code>.</p>
<p>When <a class="reference internal" href="scoped_type_variables.html#extension-ScopedTypeVariables"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ScopedTypeVariables</span></code></a> is on, the named wildcards of a
function signature scope over the function body just like
explicitly-forall’d type variables (<a class="reference internal" href="scoped_type_variables.html#scoped-type-variables"><span class="std std-ref">Lexically scoped type variables</span></a>),
even though there is no explicit forall.  For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">_a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">_a</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">_a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">_a</span><span class="w"></span>
<span class="w">          </span><span class="n">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">      </span><span class="kr">in</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Here the named wildcard <code class="docutils literal notranslate"><span class="pre">_a</span></code> scopes over the body of <code class="docutils literal notranslate"><span class="pre">f</span></code>, thereby
binding the occurrences of <code class="docutils literal notranslate"><span class="pre">_a</span></code> in the signature of <code class="docutils literal notranslate"><span class="pre">g</span></code>.  All
four occurrences stand for the same type.</p>
<p>Named wildcards <em>should not be confused with type variables</em>. Even
though syntactically similar, named wildcards can unify with monotypes
as well as be generalised over (and behave as type variables).</p>
<p>In the first example above, <code class="docutils literal notranslate"><span class="pre">_x</span></code> is generalised over (and is
effectively replaced by a fresh type variable <code class="docutils literal notranslate"><span class="pre">a</span></code>). In the second
example, <code class="docutils literal notranslate"><span class="pre">_x</span></code> is unified with the <code class="docutils literal notranslate"><span class="pre">Bool</span></code> type, and as <code class="docutils literal notranslate"><span class="pre">Bool</span></code>
implements the <code class="docutils literal notranslate"><span class="pre">Show</span></code> type class, the constraint <code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">Bool</span></code> can be
simplified away.</p>
<p>By default, GHC (as the Haskell 2010 standard prescribes) parses
identifiers starting with an underscore in a type as type variables. To
treat them as named wildcards, the <a class="reference internal" href="#extension-NamedWildCards"><code class="xref std std-extension docutils literal notranslate"><span class="pre">NamedWildCards</span></code></a> extension should be
enabled. The example below demonstrated the effect.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">_a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">_a</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
</pre></div>
</div>
<p>Compiling this program without enabling <a class="reference internal" href="#extension-NamedWildCards"><code class="xref std std-extension docutils literal notranslate"><span class="pre">NamedWildCards</span></code></a> produces
the following error message complaining about the type variable <code class="docutils literal notranslate"><span class="pre">_a</span></code>
no matching the actual type <code class="docutils literal notranslate"><span class="pre">Bool</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Test.hs:5:9: error:
    • Couldn&#39;t match expected type ‘_a’ with actual type ‘Bool’
      ‘_a’ is a rigid type variable bound by
        the type signature for:
          foo :: forall _a. _a -&gt; _a
        at Test.hs:4:8
    • In the expression: False
      In an equation for ‘foo’: foo _ = False
    • Relevant bindings include foo :: _a -&gt; _a (bound at Test.hs:5:1)
</pre></div>
</div>
<p>Compiling this program with <a class="reference internal" href="#extension-NamedWildCards"><code class="xref std std-extension docutils literal notranslate"><span class="pre">NamedWildCards</span></code></a> (as well as
<a class="reference internal" href="#extension-PartialTypeSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PartialTypeSignatures</span></code></a>) enabled produces the following error
message reporting the inferred type of the named wildcard <code class="docutils literal notranslate"><span class="pre">_a</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Test.hs:4:8: warning: [-Wpartial-type-signatures]
    • Found type wildcard ‘_a’ standing for ‘Bool’
    • In the type signature:
        foo :: _a -&gt; _a
    • Relevant bindings include
        foo :: Bool -&gt; Bool (bound at Test.hs:5:1)
</pre></div>
</div>
</section>
<section id="extra-constraints-wildcard">
<span id="id4"></span><h3><span class="section-number">6.11.6.1.3. </span>Extra-Constraints Wildcard<a class="headerlink" href="#extra-constraints-wildcard" title="Permalink to this heading">¶</a></h3>
<p>The third kind of wildcard is the <em>extra-constraints wildcard</em>. The
presence of an extra-constraints wildcard indicates that an arbitrary
number of extra constraints may be inferred during type checking and
will be added to the type signature. In the example below, the
extra-constraints wildcard is used to infer three extra constraints.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>arbitCs :: _ =&gt; a -&gt; String
arbitCs x = show (succ x) ++ show (x == x)
-- Inferred:
--   forall a. (Enum a, Eq a, Show a) =&gt; a -&gt; String
-- Error:
Test.hs:5:12: error:
    Found constraint wildcard ‘_’ standing for ‘(Show a, Eq a, Enum a)’
    To use the inferred type, enable PartialTypeSignatures
    In the type signature:
      arbitCs :: _ =&gt; a -&gt; String
</pre></div>
</div>
<p>An extra-constraints wildcard shouldn’t prevent the programmer from
already listing the constraints they know or want to annotate, e.g.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>-- Also a correct partial type signature:
arbitCs&#39; :: (Enum a, _) =&gt; a -&gt; String
arbitCs&#39; x = arbitCs x
-- Inferred:
--   forall a. (Enum a, Show a, Eq a) =&gt; a -&gt; String
-- Error:
Test.hs:9:22: error:
    Found constraint wildcard ‘_’ standing for ‘()’
    To use the inferred type, enable PartialTypeSignatures
    In the type signature:
      arbitCs&#39; :: (Enum a, _) =&gt; a -&gt; String
</pre></div>
</div>
<p>An extra-constraints wildcard can also lead to zero extra constraints to
be inferred, e.g.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>noCs :: _ =&gt; String
noCs = &quot;noCs&quot;
-- Inferred: String
-- Error:
Test.hs:13:9: error:
    Found constraint wildcard ‘_’ standing for ‘()’
    To use the inferred type, enable PartialTypeSignatures
    In the type signature:
      noCs :: _ =&gt; String
</pre></div>
</div>
<p>As a single extra-constraints wildcard is enough to infer any number of
constraints, only one is allowed in a type signature and it should come
last in the list of constraints.</p>
<p>Extra-constraints wildcards cannot be named.</p>
</section>
</section>
<section id="where-can-they-occur">
<span id="pts-where"></span><h2><span class="section-number">6.11.6.2. </span>Where can they occur?<a class="headerlink" href="#where-can-they-occur" title="Permalink to this heading">¶</a></h2>
<p>Partial type signatures are allowed for bindings, pattern and expression
signatures, except that extra-constraints
wildcards are not supported in pattern or expression signatures.
In the following example a wildcard is used in each of the three possible contexts.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE ScopedTypeVariables #-}</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kr">_</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"></span>
<span class="c1">-- Inferred: forall w_. w_ -&gt; w_</span><span class="w"></span>
</pre></div>
</div>
<p>Anonymous and named wildcards <em>can</em> occur on the left hand side of a
type or data instance declaration;
see <a class="reference internal" href="type_families.html#type-wildcards-lhs"><span class="std std-ref">Wildcards on the LHS of data and type family instances</span></a>.</p>
<p>Anonymous wildcards are also allowed in visible type applications/ visible kind
applications (<a class="reference internal" href="type_applications.html#visible-type-application"><span class="std std-ref">Visible type application</span></a>). If you want to specify only the
second type argument to <code class="docutils literal notranslate"><span class="pre">wurble</span></code>, then you can say <code class="docutils literal notranslate"><span class="pre">wurble</span> <span class="pre">&#64;_</span> <span class="pre">&#64;Int</span></code> where
the first argument is a wildcard.</p>
<p>Standalone <code class="docutils literal notranslate"><span class="pre">deriving</span></code> declarations permit the use of a single,
extra-constraints wildcard, like so:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">deriving</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This denotes a derived <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">(Foo</span> <span class="pre">a)</span></code> instance where the context is inferred,
in much the same way that ordinary <code class="docutils literal notranslate"><span class="pre">deriving</span></code> clauses do. Any other use of
wildcards in a standalone <code class="docutils literal notranslate"><span class="pre">deriving</span></code> declaration is prohibited.</p>
<p>In all other contexts, type wildcards are disallowed, and a named wildcard is treated
as an ordinary type variable.  For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w">          </span><span class="c1">-- Illegal</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w">            </span><span class="c1">-- Illegal (currently; would actually make sense)</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">_a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">_a</span><span class="p">)</span><span class="w">  </span><span class="c1">-- Perfectly fine, same as  Eq a =&gt; Eq (T a)</span><span class="w"></span>
</pre></div>
</div>
<p>Partial type signatures can also be used in <a class="reference internal" href="template_haskell.html#template-haskell"><span class="std std-ref">Template Haskell</span></a>
splices.</p>
<ul>
<li><p>Declaration splices: partial type signature are fully supported.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE TemplateHaskell, NamedWildCards #-}</span><span class="w"></span>
<span class="o">$</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="n">d</span><span class="o">|</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">_a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">_a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">_</span><span class="w"></span>
<span class="w">       </span><span class="n">foo</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="o">|</span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Expression splices: anonymous and named wildcards can be used in
expression signatures. Extra-constraints wildcards are not supported,
just like in regular expression signatures.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE TemplateHaskell, NamedWildCards #-}</span><span class="w"></span>
<span class="o">$</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">_m</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Typed expression splices: the same wildcards as in (untyped)
expression splices are supported.</p></li>
<li><p>Pattern splices: anonymous and named wildcards can be used in pattern
signatures. Note that <a class="reference internal" href="scoped_type_variables.html#extension-ScopedTypeVariables"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ScopedTypeVariables</span></code></a> has to be enabled
to allow pattern signatures. Extra-constraints wildcards are not supported,
just like in regular pattern signatures.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE TemplateHaskell, ScopedTypeVariables #-}</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Type splices: only anonymous wildcards are supported in type splices.
Named and extra-constraints wildcards are not.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE TemplateHaskell #-}</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="o">|</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="o">|</span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bindings.html" class="btn btn-neutral float-right" title="6.12. Bindings and generalisation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="implicit_parameters.html" class="btn btn-neutral float-left" title="6.11.5. Implicit parameters" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
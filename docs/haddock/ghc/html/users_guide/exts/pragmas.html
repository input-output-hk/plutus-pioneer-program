

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.20. Pragmas &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="7. Extending and using GHC as a Library" href="../extending_ghc.html" />
    <link rel="prev" title="6.19.5. HasCallStack" href="callstack.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6.20. Pragmas</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#language-pragma">6.20.1. <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> pragma</a></li>
<li class="toctree-l3"><a class="reference internal" href="#options-ghc-pragma">6.20.2. <code class="docutils literal notranslate"><span class="pre">OPTIONS_GHC</span></code> pragma</a></li>
<li class="toctree-l3"><a class="reference internal" href="#include-pragma">6.20.3. <code class="docutils literal notranslate"><span class="pre">INCLUDE</span></code> pragma</a></li>
<li class="toctree-l3"><a class="reference internal" href="#warning-and-deprecated-pragmas">6.20.4. <code class="docutils literal notranslate"><span class="pre">WARNING</span></code> and <code class="docutils literal notranslate"><span class="pre">DEPRECATED</span></code> pragmas</a></li>
<li class="toctree-l3"><a class="reference internal" href="#minimal-pragma">6.20.5. <code class="docutils literal notranslate"><span class="pre">MINIMAL</span></code> pragma</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inline-and-noinline-pragmas">6.20.6. <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> and <code class="docutils literal notranslate"><span class="pre">NOINLINE</span></code> pragmas</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#inline-pragma">6.20.6.1. <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> pragma</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inlinable-pragma">6.20.6.2. <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> pragma</a></li>
<li class="toctree-l4"><a class="reference internal" href="#noinline-pragma">6.20.6.3. <code class="docutils literal notranslate"><span class="pre">NOINLINE</span></code> pragma</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conlike-modifier">6.20.6.4. <code class="docutils literal notranslate"><span class="pre">CONLIKE</span></code> modifier</a></li>
<li class="toctree-l4"><a class="reference internal" href="#phase-control">6.20.6.5. Phase control</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#line-pragma">6.20.7. <code class="docutils literal notranslate"><span class="pre">LINE</span></code> pragma</a></li>
<li class="toctree-l3"><a class="reference internal" href="#column-pragma">6.20.8. <code class="docutils literal notranslate"><span class="pre">COLUMN</span></code> pragma</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rules-pragma">6.20.9. <code class="docutils literal notranslate"><span class="pre">RULES</span></code> pragma</a></li>
<li class="toctree-l3"><a class="reference internal" href="#specialize-pragma">6.20.10. <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> pragma</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#specialize-inline">6.20.10.1. <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span> <span class="pre">INLINE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#specialize-for-imported-functions">6.20.10.2. <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> for imported functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#specialize-instance-pragma">6.20.11. <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> instance pragma</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unpack-pragma">6.20.12. <code class="docutils literal notranslate"><span class="pre">UNPACK</span></code> pragma</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nounpack-pragma">6.20.13. <code class="docutils literal notranslate"><span class="pre">NOUNPACK</span></code> pragma</a></li>
<li class="toctree-l3"><a class="reference internal" href="#source-pragma">6.20.14. <code class="docutils literal notranslate"><span class="pre">SOURCE</span></code> pragma</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complete-pragmas">6.20.15. <code class="docutils literal notranslate"><span class="pre">COMPLETE</span></code> pragmas</a></li>
<li class="toctree-l3"><a class="reference internal" href="#overlapping-overlappable-overlaps-and-incoherent-pragmas">6.20.16. <code class="docutils literal notranslate"><span class="pre">OVERLAPPING</span></code>, <code class="docutils literal notranslate"><span class="pre">OVERLAPPABLE</span></code>, <code class="docutils literal notranslate"><span class="pre">OVERLAPS</span></code>, and <code class="docutils literal notranslate"><span class="pre">INCOHERENT</span></code> pragmas</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
      <li><span class="section-number">6.20. </span>Pragmas</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/pragmas.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="pragmas">
<span id="id1"></span><h1><span class="section-number">6.20. </span>Pragmas<a class="headerlink" href="#pragmas" title="Permalink to this heading">¶</a></h1>
<p id="index-0">GHC supports several pragmas, or instructions to the compiler placed in
the source code. Pragmas don’t normally affect the meaning of the
program, but they might affect the efficiency of the generated code.</p>
<p>Pragmas all take the form <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">word</span> <span class="pre">...</span> <span class="pre">#-}</span></code> where ⟨word⟩ indicates
the type of pragma, and is followed optionally by information specific
to that type of pragma. Case is ignored in ⟨word⟩. The various values
for ⟨word⟩ that GHC understands are described in the following sections;
any pragma encountered with an unrecognised ⟨word⟩ is ignored. The
layout rule applies in pragmas, so the closing <code class="docutils literal notranslate"><span class="pre">#-}</span></code> should start in a
column to the right of the opening <code class="docutils literal notranslate"><span class="pre">{-#</span></code>.</p>
<p>Certain pragmas are <em>file-header pragmas</em>:</p>
<ul class="simple">
<li><p>A file-header pragma must precede the <code class="docutils literal notranslate"><span class="pre">module</span></code> keyword in the file.</p></li>
<li><p>There can be as many file-header pragmas as you please, and they can
be preceded or followed by comments.</p></li>
<li><p>File-header pragmas are read once only, before pre-processing the
file (e.g. with cpp).</p></li>
<li><p>The file-header pragmas are: <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">LANGUAGE</span> <span class="pre">#-}</span></code>,
<code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">OPTIONS_GHC</span> <span class="pre">#-}</span></code>, and <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">INCLUDE</span> <span class="pre">#-}</span></code>.</p></li>
</ul>
<section id="language-pragma">
<span id="id2"></span><h2><span class="section-number">6.20.1. </span><code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> pragma<a class="headerlink" href="#language-pragma" title="Permalink to this heading">¶</a></h2>
<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-LANGUAGE">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">LANGUAGE</span> <span class="pre">⟨ext⟩,</span> <span class="pre">⟨ext⟩,</span> <span class="pre">...</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-LANGUAGE" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>file header</p>
</dd>
</dl>
<p>Enable or disable a set of language extensions.</p>
</dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> pragma allows language extensions to be enabled in a
portable way. It is the intention that all Haskell compilers support the
<code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> pragma with the same syntax, although not all extensions
are supported by all compilers, of course. The <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> pragma
should be used instead of <code class="docutils literal notranslate"><span class="pre">OPTIONS_GHC</span></code>, if possible.</p>
<p>For example, to enable the FFI and preprocessing with CPP:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE ForeignFunctionInterface, CPP #-}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> is a file-header pragma (see <a class="reference internal" href="#pragmas"><span class="std std-ref">Pragmas</span></a>).</p>
<p>Every language extension can also be turned into a command-line flag by
prefixing it with “<code class="docutils literal notranslate"><span class="pre">-X</span></code>”; for example <code class="docutils literal notranslate"><span class="pre">-XForeignFunctionInterface</span></code>.
(Similarly, all “<code class="docutils literal notranslate"><span class="pre">-X</span></code>” flags can be written as <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> pragmas.)</p>
<p>A list of all supported language extensions can be obtained by invoking
<code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">--supported-extensions</span></code> (see <a class="reference internal" href="../using.html#ghc-flag-supported-extensions"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">--supported-extensions</span></code></a>).</p>
<p>Any extension from the <code class="docutils literal notranslate"><span class="pre">Extension</span></code> type defined in
<a class="reference external" href="../../libraries/Cabal-3.6.3.0/Language-Haskell-Extension.html">Language.Haskell.Extension</a> may be used. GHC will report an error
if any of the requested extensions are not supported.</p>
</section>
<section id="options-ghc-pragma">
<span id="options-pragma"></span><h2><span class="section-number">6.20.2. </span><code class="docutils literal notranslate"><span class="pre">OPTIONS_GHC</span></code> pragma<a class="headerlink" href="#options-ghc-pragma" title="Permalink to this heading">¶</a></h2>
<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-OPTIONS_GHC">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">OPTIONS_GHC</span> <span class="pre">⟨flags⟩</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-OPTIONS_GHC" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>file header</p>
</dd>
</dl>
</dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">OPTIONS_GHC</span></code> pragma is used to specify additional options that
are given to the compiler when compiling this source file. See
<a class="reference internal" href="../using.html#source-file-options"><span class="std std-ref">Command line options in source files</span></a> for details.</p>
<p>Previous versions of GHC accepted <code class="docutils literal notranslate"><span class="pre">OPTIONS</span></code> rather than
<code class="docutils literal notranslate"><span class="pre">OPTIONS_GHC</span></code>, but that is now deprecated.</p>
<p><code class="docutils literal notranslate"><span class="pre">OPTIONS_GHC</span></code> is a file-header pragma (see <a class="reference internal" href="#pragmas"><span class="std std-ref">Pragmas</span></a>).</p>
</section>
<section id="include-pragma">
<span id="id3"></span><h2><span class="section-number">6.20.3. </span><code class="docutils literal notranslate"><span class="pre">INCLUDE</span></code> pragma<a class="headerlink" href="#include-pragma" title="Permalink to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">INCLUDE</span></code> used to be necessary for specifying header files to be
included when using the FFI and compiling via C. It is no longer
required for GHC, but is accepted (and ignored) for compatibility with
other compilers.</p>
</section>
<section id="warning-and-deprecated-pragmas">
<span id="warning-deprecated-pragma"></span><h2><span class="section-number">6.20.4. </span><code class="docutils literal notranslate"><span class="pre">WARNING</span></code> and <code class="docutils literal notranslate"><span class="pre">DEPRECATED</span></code> pragmas<a class="headerlink" href="#warning-and-deprecated-pragmas" title="Permalink to this heading">¶</a></h2>
<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-WARNING">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">WARNING</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-WARNING" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>declaration</p>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">WARNING</span></code> pragma allows you to attach an arbitrary warning to a
particular function, class, or type.</p>
</dd></dl>

<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-DEPRECATED">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">DEPRECATED</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-DEPRECATED" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>declaration</p>
</dd>
</dl>
<p>A <code class="docutils literal notranslate"><span class="pre">DEPRECATED</span></code> pragma lets you specify that a particular function, class,
or type is deprecated.</p>
</dd></dl>

<p>There are two ways of using these pragmas.</p>
<ul>
<li><p>You can work on an entire module thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Wibble</span><span class="w"> </span><span class="cm">{-# DEPRECATED &quot;Use Wobble instead&quot; #-}</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Or:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Wibble</span><span class="w"> </span><span class="cm">{-# WARNING &quot;This is an unstable interface.&quot; #-}</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>When you compile any module that import <code class="docutils literal notranslate"><span class="pre">Wibble</span></code>, GHC will print
the specified message.</p>
</li>
<li><p>You can attach a warning to a function, class, type, or data
constructor, with the following top-level declarations:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# DEPRECATED f, C, T &quot;Don&#39;t use these&quot; #-}</span><span class="w"></span>
<span class="cm">{-# WARNING unsafePerformIO &quot;This is unsafe; I hope you know what you&#39;re doing&quot; #-}</span><span class="w"></span>
</pre></div>
</div>
<p>When you compile any module that imports and uses any of the
specified entities, GHC will print the specified message.</p>
<p>You can only attach to entities declared at top level in the module
being compiled, and you can only use unqualified names in the list of
entities. A capitalised name, such as <code class="docutils literal notranslate"><span class="pre">T</span></code> refers to <em>either</em> the
type constructor <code class="docutils literal notranslate"><span class="pre">T</span></code> <em>or</em> the data constructor <code class="docutils literal notranslate"><span class="pre">T</span></code>, or both if
both are in scope. If both are in scope, there is currently no way to
specify one without the other (c.f. fixities <a class="reference internal" href="infix_tycons.html#infix-tycons"><span class="std std-ref">Infix type constructors, classes, and type variables</span></a>).</p>
</li>
</ul>
<p>Also note that the argument to <code class="docutils literal notranslate"><span class="pre">DEPRECATED</span></code> and <code class="docutils literal notranslate"><span class="pre">WARNING</span></code> can also be a list
of strings, in which case the strings will be presented on separate lines in the
resulting warning message,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# DEPRECATED foo, bar [&quot;Don&#39;t use these&quot;, &quot;Use gar instead&quot;] #-}</span><span class="w"></span>
</pre></div>
</div>
<p>Warnings and deprecations are not reported for (a) uses within the
defining module, (b) defining a method in a class instance, and (c) uses
in an export list. The latter reduces spurious complaints within a
library in which one module gathers together and re-exports the exports
of several others.</p>
<p>You can suppress the warnings with the flag
<a class="reference internal" href="../using-warnings.html#ghc-flag-Wwarnings-deprecations"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wno-warnings-deprecations</span></code></a>.</p>
</section>
<section id="minimal-pragma">
<span id="id4"></span><h2><span class="section-number">6.20.5. </span><code class="docutils literal notranslate"><span class="pre">MINIMAL</span></code> pragma<a class="headerlink" href="#minimal-pragma" title="Permalink to this heading">¶</a></h2>
<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-MINIMAL">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">MINIMAL</span> <span class="pre">⟨name⟩</span> <span class="pre">|</span> <span class="pre">⟨name⟩</span> <span class="pre">,</span> <span class="pre">...</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-MINIMAL" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>in class body</p>
</dd>
</dl>
<p>Define the methods needed for a minimal complete instance of a class.</p>
</dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">MINIMAL</span></code> pragma is used to specify the minimal complete definition of
a class, i.e. specify which methods must be implemented by all
instances. If an instance does not satisfy the minimal complete
definition, then a warning is generated. This can be useful when a class
has methods with circular defaults. For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="o">==</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="o">/=</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="cm">{-# MINIMAL (==) | (/=) #-}</span><span class="w"></span>
</pre></div>
</div>
<p>Without the <code class="docutils literal notranslate"><span class="pre">MINIMAL</span></code> pragma no warning would be generated for an instance
that implements neither method.</p>
<p>The syntax for minimal complete definition is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mindef</span><span class="w"> </span><span class="kt">::=</span><span class="w"> </span><span class="n">name</span><span class="w"></span>
<span class="w">        </span><span class="o">|</span><span class="w">  </span><span class="sc">&#39;(&#39;</span><span class="w"> </span><span class="n">mindef</span><span class="w"> </span><span class="sc">&#39;)&#39;</span><span class="w"></span>
<span class="w">        </span><span class="o">|</span><span class="w">  </span><span class="n">mindef</span><span class="w"> </span><span class="sc">&#39;|&#39;</span><span class="w"> </span><span class="n">mindef</span><span class="w"></span>
<span class="w">        </span><span class="o">|</span><span class="w">  </span><span class="n">mindef</span><span class="w"> </span><span class="sc">&#39;,&#39;</span><span class="w"> </span><span class="n">mindef</span><span class="w"></span>
</pre></div>
</div>
<p>A vertical bar denotes disjunction, i.e. one of the two sides is
required. A comma denotes conjunction, i.e. both sides are required.
Conjunction binds stronger than disjunction.</p>
<p>If no <code class="docutils literal notranslate"><span class="pre">MINIMAL</span></code> pragma is given in the class declaration, it is just as if
a pragma <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">MINIMAL</span> <span class="pre">op1,</span> <span class="pre">op2,</span> <span class="pre">...,</span> <span class="pre">opn</span> <span class="pre">#-}</span></code> was given, where the
<code class="docutils literal notranslate"><span class="pre">opi</span></code> are the methods that lack a default method in the class
declaration (c.f. <a class="reference internal" href="../using-warnings.html#ghc-flag-Wmissing-methods"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wmissing-methods</span></code></a>, <a class="reference internal" href="../using-warnings.html#options-sanity"><span class="std std-ref">Warnings and sanity-checking</span></a>).</p>
<p>This warning can be turned off with the flag
<a class="reference internal" href="../using-warnings.html#ghc-flag-Wmissing-methods"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wno-missing-methods</span></code></a>.</p>
</section>
<section id="inline-and-noinline-pragmas">
<span id="inline-noinline-pragma"></span><h2><span class="section-number">6.20.6. </span><code class="docutils literal notranslate"><span class="pre">INLINE</span></code> and <code class="docutils literal notranslate"><span class="pre">NOINLINE</span></code> pragmas<a class="headerlink" href="#inline-and-noinline-pragmas" title="Permalink to this heading">¶</a></h2>
<p>These pragmas control the inlining of function definitions.</p>
<section id="inline-pragma">
<span id="id5"></span><h3><span class="section-number">6.20.6.1. </span><code class="docutils literal notranslate"><span class="pre">INLINE</span></code> pragma<a class="headerlink" href="#inline-pragma" title="Permalink to this heading">¶</a></h3>
<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-INLINE">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">INLINE</span> <span class="pre">⟨name⟩</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-INLINE" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>top-level</p>
</dd>
</dl>
<p>Force GHC to inline a value.</p>
</dd></dl>

<p>GHC (with <a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a>, as always) tries to inline (or “unfold”)
functions/values that are “small enough,” thus avoiding the call
overhead and possibly exposing other more-wonderful optimisations. GHC
has a set of heuristics, tuned over a long period of time using many
benchmarks, that decide when it is beneficial to inline a function at
its call site. The heuristics are designed to inline functions when it
appears to be beneficial to do so, but without incurring excessive code
bloat. If a function looks too big, it won’t be inlined, and functions
larger than a certain size will not even have their definition exported
in the interface file. Some of the thresholds that govern these
heuristic decisions can be changed using flags, see <a class="reference internal" href="../using-optimisation.html#options-f"><span class="std std-ref">-f*: platform-independent flags</span></a>.</p>
<p>Normally GHC will do a reasonable job of deciding by itself when it is a
good idea to inline a function. However, sometimes you might want to
override the default behaviour. For example, if you have a key function
that is important to inline because it leads to further optimisations,
but GHC judges it to be too big to inline.</p>
<p>The sledgehammer you can bring to bear is the <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> pragma, used thusly:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">key_function</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Bool</span><span class="p">,</span><span class="w"> </span><span class="kt">Double</span><span class="p">)</span><span class="w"></span>
<span class="cm">{-# INLINE key_function #-}</span><span class="w"></span>
</pre></div>
</div>
<p>The major effect of an <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> pragma is to declare a function’s
“cost” to be very low. The normal unfolding machinery will then be very
keen to inline it. However, an <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> pragma for a function “<code class="docutils literal notranslate"><span class="pre">f</span></code>”
has a number of other effects:</p>
<ul>
<li><p>While GHC is keen to inline the function, it does not do so blindly.
For example, if you write</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">map</span><span class="w"> </span><span class="n">key_function</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
</pre></div>
</div>
<p>there really isn’t any point in inlining <code class="docutils literal notranslate"><span class="pre">key_function</span></code> to get</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">body</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
</pre></div>
</div>
<p>In general, GHC only inlines the function if there is some reason (no
matter how slight) to suppose that it is useful to do so.</p>
</li>
<li><p>Moreover, GHC will only inline the function if it is <em>fully applied</em>,
where “fully applied” means applied to as many arguments as appear
(syntactically) on the LHS of the function definition. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">comp1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="cm">{-# INLINE comp1 #-}</span><span class="w"></span>
<span class="nf">comp1</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>

<span class="nf">comp2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="cm">{-# INLINE comp2 #-}</span><span class="w"></span>
<span class="nf">comp2</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The two functions <code class="docutils literal notranslate"><span class="pre">comp1</span></code> and <code class="docutils literal notranslate"><span class="pre">comp2</span></code> have the same semantics,
but <code class="docutils literal notranslate"><span class="pre">comp1</span></code> will be inlined when applied to <em>two</em> arguments, while
<code class="docutils literal notranslate"><span class="pre">comp2</span></code> requires <em>three</em>. This might make a big difference if you
say</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">map</span><span class="w"> </span><span class="p">(</span><span class="n">not</span><span class="w"> </span><span class="p">`</span><span class="n">comp1</span><span class="p">`</span><span class="w"> </span><span class="n">not</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
</pre></div>
</div>
<p>which will optimise better than the corresponding use of <code class="docutils literal notranslate"><span class="pre">comp2</span></code>.</p>
</li>
<li><p>It is useful for GHC to optimise the definition of an INLINE function
<code class="docutils literal notranslate"><span class="pre">f</span></code> just like any other non-<code class="docutils literal notranslate"><span class="pre">INLINE</span></code> function, in case the
non-inlined version of <code class="docutils literal notranslate"><span class="pre">f</span></code> is ultimately called. But we don’t want
to inline the <em>optimised</em> version of <code class="docutils literal notranslate"><span class="pre">f</span></code>; a major reason for <code class="docutils literal notranslate"><span class="pre">INLINE</span></code>
pragmas is to expose functions in <code class="docutils literal notranslate"><span class="pre">f</span></code>'s RHS that have rewrite
rules, and it’s no good if those functions have been optimised away.</p>
<p>So <em>GHC guarantees to inline precisely the code that you wrote</em>, no
more and no less. It does this by capturing a copy of the definition
of the function to use for inlining (we call this the “inline-RHS”),
which it leaves untouched, while optimising the ordinarily RHS as
usual. For externally-visible functions the inline-RHS (not the
optimised RHS) is recorded in the interface file.</p>
</li>
<li><p>An <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> function is not worker/wrappered by strictness analysis.
It’s going to be inlined wholesale instead.</p></li>
</ul>
<p>GHC ensures that inlining cannot go on forever: every mutually-recursive
group is cut by one or more <em>loop breakers</em> that is never inlined (see
<a class="reference external" href="http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm">Secrets of the GHC inliner, JFP 12(4) July
2002</a>).
GHC tries not to select a function with an <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> pragma as a loop
breaker, but when there is no choice even an INLINE function can be
selected, in which case the <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> pragma is ignored. For example, for a
self-recursive function, the loop breaker can only be the function
itself, so an <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> pragma is always ignored.</p>
<p>Syntactically, an <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> pragma for a function can be put anywhere
its type signature could be put.</p>
<p><code class="docutils literal notranslate"><span class="pre">INLINE</span></code> pragmas are a particularly good idea for the
<code class="docutils literal notranslate"><span class="pre">then</span></code>/<code class="docutils literal notranslate"><span class="pre">return</span></code> (or <code class="docutils literal notranslate"><span class="pre">bind</span></code>/<code class="docutils literal notranslate"><span class="pre">unit</span></code>) functions in a monad. For
example, in GHC’s own <code class="docutils literal notranslate"><span class="pre">UniqueSupply</span></code> monad code, we have:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINE thenUs #-}</span><span class="w"></span>
<span class="cm">{-# INLINE returnUs #-}</span><span class="w"></span>
</pre></div>
</div>
<p>See also the <code class="docutils literal notranslate"><span class="pre">NOINLINE</span></code> (<a class="reference internal" href="#noinline-pragma"><span class="std std-ref">NOINLINE pragma</span></a>) and <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code>
(<a class="reference internal" href="#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>) pragmas.</p>
</section>
<section id="inlinable-pragma">
<span id="id6"></span><h3><span class="section-number">6.20.6.2. </span><code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> pragma<a class="headerlink" href="#inlinable-pragma" title="Permalink to this heading">¶</a></h3>
<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-INLINABLE">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">INLINABLE</span> <span class="pre">⟨name⟩</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-INLINABLE" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>top-level</p>
</dd>
</dl>
<p>Suggest that the compiler always consider inlining <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</dd></dl>

<p>An <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">INLINABLE</span> <span class="pre">f</span> <span class="pre">#-}</span></code> pragma on a function <code class="docutils literal notranslate"><span class="pre">f</span></code> has the following
behaviour:</p>
<ul class="simple">
<li><p>While <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> says “please inline me”, the <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> says
“feel free to inline me; use your discretion”. In other words the
choice is left to GHC, which uses the same rules as for pragma-free
functions. Unlike <code class="docutils literal notranslate"><span class="pre">INLINE</span></code>, that decision is made at the <em>call
site</em>, and will therefore be affected by the inlining threshold,
optimisation level etc.</p></li>
<li><p>Like <code class="docutils literal notranslate"><span class="pre">INLINE</span></code>, the <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> pragma retains a copy of the
original RHS for inlining purposes, and persists it in the interface
file, regardless of the size of the RHS.</p></li>
<li><p>One way to use <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> is in conjunction with the special
function <code class="docutils literal notranslate"><span class="pre">inline</span></code> (<a class="reference internal" href="special_builtin.html#special-ids"><span class="std std-ref">Special built-in functions</span></a>). The call <code class="docutils literal notranslate"><span class="pre">inline</span> <span class="pre">f</span></code> tries
very hard to inline <code class="docutils literal notranslate"><span class="pre">f</span></code>. To make sure that <code class="docutils literal notranslate"><span class="pre">f</span></code> can be inlined, it
is a good idea to mark the definition of <code class="docutils literal notranslate"><span class="pre">f</span></code> as <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code>, so
that GHC guarantees to expose an unfolding regardless of how big it
is. Moreover, by annotating <code class="docutils literal notranslate"><span class="pre">f</span></code> as <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code>, you ensure that
<code class="docutils literal notranslate"><span class="pre">f</span></code>'s original RHS is inlined, rather than whatever random
optimised version of <code class="docutils literal notranslate"><span class="pre">f</span></code> GHC’s optimiser has produced.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> pragma also works with <code class="docutils literal notranslate"><span class="pre">SPECIALISE</span></code>: if you mark
function <code class="docutils literal notranslate"><span class="pre">f</span></code> as <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code>, then you can subsequently
<code class="docutils literal notranslate"><span class="pre">SPECIALISE</span></code> in another module (see <a class="reference internal" href="#specialize-pragma"><span class="std std-ref">SPECIALIZE pragma</span></a>).</p></li>
<li><p>Unlike <code class="docutils literal notranslate"><span class="pre">INLINE</span></code>, it is OK to use an <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> pragma on a
recursive function. The principal reason do to so to allow later use
of <code class="docutils literal notranslate"><span class="pre">SPECIALISE</span></code></p></li>
</ul>
<p>The alternative spelling <code class="docutils literal notranslate"><span class="pre">INLINEABLE</span></code> is also accepted by GHC.</p>
</section>
<section id="noinline-pragma">
<span id="id7"></span><h3><span class="section-number">6.20.6.3. </span><code class="docutils literal notranslate"><span class="pre">NOINLINE</span></code> pragma<a class="headerlink" href="#noinline-pragma" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-1"></span><dl class="std pragma">
<dt class="sig sig-object std" id="pragma-NOINLINE">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">NOINLINE</span> <span class="pre">⟨name⟩</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-NOINLINE" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>top-level</p>
</dd>
</dl>
<p>Instructs the compiler not to inline a value.</p>
</dd></dl>

<p>The <a class="reference internal" href="#pragma-NOINLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">NOINLINE</span></code></a> pragma does exactly what you’d expect: it stops the
named function from being inlined by the compiler. You shouldn’t ever
need to do this, unless you’re very cautious about code size.</p>
<p><code class="docutils literal notranslate"><span class="pre">NOTINLINE</span></code> is a synonym for <code class="docutils literal notranslate"><span class="pre">NOINLINE</span></code> (<code class="docutils literal notranslate"><span class="pre">NOINLINE</span></code> is specified
by Haskell 98 as the standard way to disable inlining, so it should be
used if you want your code to be portable).</p>
</section>
<section id="conlike-modifier">
<span id="conlike-pragma"></span><h3><span class="section-number">6.20.6.4. </span><code class="docutils literal notranslate"><span class="pre">CONLIKE</span></code> modifier<a class="headerlink" href="#conlike-modifier" title="Permalink to this heading">¶</a></h3>
<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-CONLIKE">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">CONLIKE</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-CONLIKE" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>modifies <a class="reference internal" href="#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a> or <a class="reference internal" href="#pragma-NOINLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">NOINLINE</span></code></a> pragma</p>
</dd>
</dl>
<p>Instructs GHC to consider a value to be especially cheap to inline.</p>
</dd></dl>

<p>An <a class="reference internal" href="#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a> or <a class="reference internal" href="#pragma-NOINLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">NOINLINE</span></code></a> pragma may have a <a class="reference internal" href="#pragma-CONLIKE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">CONLIKE</span></code></a> modifier, which affects
matching in <a class="reference internal" href="rewrite_rules.html#pragma-RULES"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">RULE</span></code></a>s (only). See <a class="reference internal" href="rewrite_rules.html#conlike"><span class="std std-ref">How rules interact with CONLIKE pragmas</span></a>.</p>
</section>
<section id="phase-control">
<span id="id8"></span><h3><span class="section-number">6.20.6.5. </span>Phase control<a class="headerlink" href="#phase-control" title="Permalink to this heading">¶</a></h3>
<p>Sometimes you want to control exactly when in GHC’s pipeline the <a class="reference internal" href="#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a>
pragma is switched on. Inlining happens only during runs of the
<em>simplifier</em>. Each run of the simplifier has a different <em>phase number</em>;
the phase number decreases towards zero. If you use
<a class="reference internal" href="../debugging.html#ghc-flag-dverbose-core2core"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-dverbose-core2core</span></code></a> you will see the sequence of phase numbers for
successive runs of the simplifier. In an <a class="reference internal" href="#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a> pragma you can
optionally specify a phase number, thus:</p>
<ul class="simple">
<li><p>“<code class="docutils literal notranslate"><span class="pre">INLINE[k]</span> <span class="pre">f</span></code>” means: do not inline <code class="docutils literal notranslate"><span class="pre">f</span></code> until phase <code class="docutils literal notranslate"><span class="pre">k</span></code>, but
from phase <code class="docutils literal notranslate"><span class="pre">k</span></code> onwards be very keen to inline it.</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">INLINE[~k]</span> <span class="pre">f</span></code>” means: be very keen to inline <code class="docutils literal notranslate"><span class="pre">f</span></code> until phase
<code class="docutils literal notranslate"><span class="pre">k</span></code>, but from phase <code class="docutils literal notranslate"><span class="pre">k</span></code> onwards do not inline it.</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">NOINLINE[k]</span> <span class="pre">f</span></code>” means: do not inline <code class="docutils literal notranslate"><span class="pre">f</span></code> until phase <code class="docutils literal notranslate"><span class="pre">k</span></code>, but
from phase <code class="docutils literal notranslate"><span class="pre">k</span></code> onwards be willing to inline it (as if there was no
pragma).</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">NOINLINE[~k]</span> <span class="pre">f</span></code>” means: be willing to inline <code class="docutils literal notranslate"><span class="pre">f</span></code> until phase
<code class="docutils literal notranslate"><span class="pre">k</span></code>, but from phase <code class="docutils literal notranslate"><span class="pre">k</span></code> onwards do not inline it.</p></li>
</ul>
<p>The same information is summarised here:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                         -- Before phase 2     Phase 2 and later
{-# INLINE   [2]  f #-}  --      No                 Yes
{-# INLINE   [~2] f #-}  --      Yes                No
{-# NOINLINE [2]  f #-}  --      No                 Maybe
{-# NOINLINE [~2] f #-}  --      Maybe              No

{-# INLINE   f #-}       --      Yes                Yes
{-# NOINLINE f #-}       --      No                 No
</pre></div>
</div>
<p>By “Maybe” we mean that the usual heuristic inlining rules apply (if the
function body is small, or it is applied to interesting-looking
arguments etc). Another way to understand the semantics is this:</p>
<ul class="simple">
<li><p>For both <a class="reference internal" href="#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a> and <a class="reference internal" href="#pragma-NOINLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">NOINLINE</span></code></a>, the phase number says when
inlining is allowed at all.</p></li>
<li><p>The <a class="reference internal" href="#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a> pragma has the additional effect of making the function
body look small, so that when inlining is allowed it is very likely
to happen.</p></li>
</ul>
<p>The same phase-numbering control is available for <a class="reference internal" href="rewrite_rules.html#pragma-RULES"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">RULE</span></code></a>s
(<a class="reference internal" href="rewrite_rules.html#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>).</p>
</section>
</section>
<section id="line-pragma">
<span id="id9"></span><h2><span class="section-number">6.20.7. </span><code class="docutils literal notranslate"><span class="pre">LINE</span></code> pragma<a class="headerlink" href="#line-pragma" title="Permalink to this heading">¶</a></h2>
<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-LINE">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">LINE</span> <span class="pre">⟨lineno⟩</span> <span class="pre">&quot;⟨file⟩&quot;</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-LINE" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>anywhere</p>
</dd>
</dl>
<p>Generated by preprocessors to convey source line numbers of the original
source.</p>
</dd></dl>

<p>This pragma is similar to C’s <code class="docutils literal notranslate"><span class="pre">#line</span></code> pragma, and is mainly for use in
automatically generated Haskell code. It lets you specify the line
number and filename of the original code; for example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LINE 42 &quot;Foo.vhs&quot; #-}</span><span class="w"></span>
</pre></div>
</div>
<p>if you’d generated the current file from something called <code class="docutils literal notranslate"><span class="pre">Foo.vhs</span></code>
and this line corresponds to line 42 in the original. GHC will adjust
its error messages to refer to the line/file named in the <code class="docutils literal notranslate"><span class="pre">LINE</span></code>
pragma.</p>
<p><code class="docutils literal notranslate"><span class="pre">LINE</span></code> pragmas generated from Template Haskell set the file and line
position for the duration of the splice and are limited to the splice.
Note that because Template Haskell splices abstract syntax, the file
positions are not automatically advanced.</p>
</section>
<section id="column-pragma">
<span id="id10"></span><h2><span class="section-number">6.20.8. </span><code class="docutils literal notranslate"><span class="pre">COLUMN</span></code> pragma<a class="headerlink" href="#column-pragma" title="Permalink to this heading">¶</a></h2>
<p id="index-2">This is the analogue of the <code class="docutils literal notranslate"><span class="pre">LINE</span></code> pragma and is likewise intended for
use in automatically generated Haskell code. It lets you specify the
column number of the original code; for example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="cm">{-# COLUMN 42 #-}</span><span class="n">pure</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">  </span><span class="n">pure</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
</pre></div>
</div>
<p>This adjusts all column numbers immediately after the pragma to start
at 42.  The presence of this pragma only affects the quality of the
diagnostics and does not change the syntax of the code itself.</p>
</section>
<section id="rules-pragma">
<span id="rules"></span><h2><span class="section-number">6.20.9. </span><code class="docutils literal notranslate"><span class="pre">RULES</span></code> pragma<a class="headerlink" href="#rules-pragma" title="Permalink to this heading">¶</a></h2>
<p>The <a class="reference internal" href="rewrite_rules.html#pragma-RULES"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">RULES</span></code></a> pragma lets you specify rewrite rules. It is described in
<a class="reference internal" href="rewrite_rules.html#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>.</p>
</section>
<section id="specialize-pragma">
<span id="id11"></span><h2><span class="section-number">6.20.10. </span><code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> pragma<a class="headerlink" href="#specialize-pragma" title="Permalink to this heading">¶</a></h2>
<span class="target" id="index-3"></span><dl class="std pragma">
<dt class="sig sig-object std" id="pragma-SPECIALIZE">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">SPECIALIZE</span> <span class="pre">⟨name⟩</span> <span class="pre">::</span> <span class="pre">⟨type⟩</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-SPECIALIZE" title="Permalink to this definition">¶</a></dt>
<dd><p>Ask that GHC specialize a polymorphic value to a particular type.</p>
</dd></dl>

<p>(UK spelling also accepted.) For key overloaded functions, you can
create extra versions (NB: at the cost of larger code) specialised to particular
types. Thus, if you have an overloaded function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">hammeredLookup</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
</pre></div>
</div>
<p>If it is heavily used on lists with <code class="docutils literal notranslate"><span class="pre">Widget</span></code> keys, you could
specialise it as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# SPECIALIZE hammeredLookup :: [(Widget, value)] -&gt; Widget -&gt; value #-}</span><span class="w"></span>
</pre></div>
</div>
<ul>
<li><p>A <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> pragma for a function can be put anywhere its type
signature could be put. Moreover, you can also <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> an
<em>imported</em> function provided it was given an <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> pragma at
its definition site (<a class="reference internal" href="#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>).</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> has the effect of generating (a) a specialised
version of the function and (b) a rewrite rule (see
<a class="reference internal" href="rewrite_rules.html#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>) that rewrites a call to the un-specialised
function into a call to the specialised one. Moreover, given a
<code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> pragma for a function <code class="docutils literal notranslate"><span class="pre">f</span></code>, GHC will automatically
create specialisations for any type-class-overloaded functions called
by <code class="docutils literal notranslate"><span class="pre">f</span></code>, if they are in the same module as the <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code>
pragma, or if they are <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code>; and so on, transitively.</p></li>
<li><p>You can add phase control (<a class="reference internal" href="#phase-control"><span class="std std-ref">Phase control</span></a>) to the RULE
generated by a <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> pragma, just as you can if you write a
<code class="docutils literal notranslate"><span class="pre">RULE</span></code> directly. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# SPECIALIZE [0] hammeredLookup :: [(Widget, value)] -&gt; Widget -&gt; value #-}</span><span class="w"></span>
</pre></div>
</div>
<p>generates a specialisation rule that only fires in Phase 0 (the final
phase). If you do not specify any phase control in the <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code>
pragma, the phase control is inherited from the inline pragma (if
any) of the function. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="n">blah</span><span class="o">...</span><span class="w"></span>
<span class="cm">{-# NOINLINE [0] foo #-}</span><span class="w"></span>
<span class="cm">{-# SPECIALIZE foo :: Int -&gt; Int #-}</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">NOINLINE</span></code> pragma tells GHC not to inline <code class="docutils literal notranslate"><span class="pre">foo</span></code> until Phase
0; and this property is inherited by the specialisation RULE, which
will therefore only fire in Phase 0.</p>
<p>The main reason for using phase control on specialisations is so that
you can write optimisation RULES that fire early in the compilation
pipeline, and only <em>then</em> specialise the calls to the function. If
specialisation is done too early, the optimisation rules might fail
to fire.</p>
</li>
<li><p>The type in a <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> pragma can be any type that is less
polymorphic than the type of the original function. In concrete
terms, if the original function is <code class="docutils literal notranslate"><span class="pre">f</span></code> then the pragma</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# SPECIALIZE f :: &lt;type&gt; #-}</span><span class="w"></span>
</pre></div>
</div>
<p>is valid if and only if the definition</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f_spec</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">&lt;</span><span class="kr">type</span><span class="o">&gt;</span><span class="w"></span>
<span class="nf">f_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"></span>
</pre></div>
</div>
<p>is valid. Here are some examples (where we only give the type
signature for the original function, not its code):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="cm">{-# SPECIALISE f :: Int -&gt; b -&gt; b #-}</span><span class="w"></span>

<span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Ix</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="cm">{-# SPECIALISE g :: (Eq a) =&gt; a -&gt; Int -&gt; Int #-}</span><span class="w"></span>

<span class="nf">h</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="cm">{-# SPECIALISE h :: (Eq a) =&gt; [a] -&gt; [a] -&gt; [a] #-}</span><span class="w"></span>
</pre></div>
</div>
<p>The last of these examples will generate a RULE with a
somewhat-complex left-hand side (try it yourself), so it might not
fire very well. If you use this kind of specialisation, let us know
how well it works.</p>
</li>
</ul>
<section id="specialize-inline">
<span id="id12"></span><h3><span class="section-number">6.20.10.1. </span><code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span> <span class="pre">INLINE</span></code><a class="headerlink" href="#specialize-inline" title="Permalink to this heading">¶</a></h3>
<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-SPECIALIZE-INLINE">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">SPECIALIZE</span> <span class="pre">INLINE</span> <span class="pre">⟨name⟩</span> <span class="pre">::</span> <span class="pre">⟨type⟩</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-SPECIALIZE-INLINE" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>top-level</p>
</dd>
</dl>
</dd></dl>

<p>A <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> pragma can optionally be followed with a <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> or
<code class="docutils literal notranslate"><span class="pre">NOINLINE</span></code> pragma, optionally followed by a phase, as described in
<a class="reference internal" href="#inline-noinline-pragma"><span class="std std-ref">INLINE and NOINLINE pragmas</span></a>. The <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> pragma affects the
specialised version of the function (only), and applies even if the
function is recursive. The motivating example is this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- A GADT for arrays with type-indexed representation</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Arr</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">ArrInt</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ByteArray</span><span class="o">#</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Arr</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">  </span><span class="kt">ArrPair</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Arr</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Arr</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Arr</span><span class="w"> </span><span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="n">e2</span><span class="p">)</span><span class="w"></span>

<span class="p">(</span><span class="o">!:</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Arr</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
<span class="cm">{-# SPECIALISE INLINE (!:) :: Arr Int -&gt; Int -&gt; Int #-}</span><span class="w"></span>
<span class="cm">{-# SPECIALISE INLINE (!:) :: Arr (a, b) -&gt; Int -&gt; (a, b) #-}</span><span class="w"></span>
<span class="p">(</span><span class="kt">ArrInt</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">ba</span><span class="p">)</span><span class="w">     </span><span class="o">!:</span><span class="w"> </span><span class="p">(</span><span class="kt">I</span><span class="o">#</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">I</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="n">indexIntArray</span><span class="o">#</span><span class="w"> </span><span class="n">ba</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="kt">ArrPair</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="n">a2</span><span class="p">)</span><span class="w"> </span><span class="o">!:</span><span class="w"> </span><span class="n">i</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">a1</span><span class="w"> </span><span class="o">!:</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="o">!:</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">(!:)</span></code> is a recursive function that indexes arrays of type
<code class="docutils literal notranslate"><span class="pre">Arr</span> <span class="pre">e</span></code>. Consider a call to <code class="docutils literal notranslate"><span class="pre">(!:)</span></code> at type <code class="docutils literal notranslate"><span class="pre">(Int,Int)</span></code>. The second
specialisation will fire, and the specialised function will be inlined.
It has two calls to <code class="docutils literal notranslate"><span class="pre">(!:)</span></code>, both at type <code class="docutils literal notranslate"><span class="pre">Int</span></code>. Both these calls
fire the first specialisation, whose body is also inlined. The result is
a type-based unrolling of the indexing function.</p>
<p>You can add explicit phase control (<a class="reference internal" href="#phase-control"><span class="std std-ref">Phase control</span></a>) to
<code class="docutils literal notranslate"><span class="pre">SPECIALISE</span> <span class="pre">INLINE</span></code> pragma, just like on an <a class="reference internal" href="#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a> pragma; if
you do so, the same phase is used for the rewrite rule and the INLINE control
of the specialised function.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You can make GHC diverge by using <code class="docutils literal notranslate"><span class="pre">SPECIALISE</span> <span class="pre">INLINE</span></code> on an
ordinarily-recursive function.</p>
</div>
</section>
<section id="specialize-for-imported-functions">
<h3><span class="section-number">6.20.10.2. </span><code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> for imported functions<a class="headerlink" href="#specialize-for-imported-functions" title="Permalink to this heading">¶</a></h3>
<p>Generally, you can only give a <a class="reference internal" href="#pragma-SPECIALIZE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">SPECIALIZE</span></code></a> pragma for a function
defined in the same module. However if a function <code class="docutils literal notranslate"><span class="pre">f</span></code> is given an
<a class="reference internal" href="#pragma-INLINABLE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINABLE</span></code></a> pragma at its definition site, then it can subsequently be
specialised by importing modules (see <a class="reference internal" href="#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>). For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Map</span><span class="p">(</span><span class="w"> </span><span class="n">lookup</span><span class="p">,</span><span class="w"> </span><span class="n">blah</span><span class="w"> </span><span class="n">blah</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">lookup</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[(</span><span class="n">key</span><span class="p">,</span><span class="n">a</span><span class="p">)]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="n">lookup</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">  </span><span class="cm">{-# INLINABLE lookup #-}</span><span class="w"></span>

<span class="kr">module</span><span class="w"> </span><span class="nn">Client</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">import</span><span class="w"> </span><span class="nn">Map</span><span class="p">(</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="kr">deriving</span><span class="p">(</span><span class="w"> </span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="cm">{-# SPECIALISE lookup :: [(T,a)] -&gt; T -&gt; Maybe a</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">lookup</span></code> is declared <a class="reference internal" href="#pragma-INLINABLE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINABLE</span></code></a>, but it cannot be specialised
for type <code class="docutils literal notranslate"><span class="pre">T</span></code> at its definition site, because that type does not exist
yet. Instead a client module can define <code class="docutils literal notranslate"><span class="pre">T</span></code> and then specialise
<code class="docutils literal notranslate"><span class="pre">lookup</span></code> at that type.</p>
<p>Moreover, every module that imports <code class="docutils literal notranslate"><span class="pre">Client</span></code> (or imports a module that
imports <code class="docutils literal notranslate"><span class="pre">Client</span></code>, transitively) will “see”, and make use of, the
specialised version of <code class="docutils literal notranslate"><span class="pre">lookup</span></code>. You don’t need to put a
<a class="reference internal" href="#pragma-SPECIALIZE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">SPECIALIZE</span></code></a> pragma in every module.</p>
<p>Moreover you often don’t even need the <a class="reference internal" href="#pragma-SPECIALIZE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">SPECIALIZE</span></code></a> pragma in the
first place. When compiling a module <code class="docutils literal notranslate"><span class="pre">M</span></code>, GHC’s optimiser (when given the
<a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a> flag) automatically considers each top-level overloaded function declared
in <code class="docutils literal notranslate"><span class="pre">M</span></code>, and specialises it for the different types at which it is called in
<code class="docutils literal notranslate"><span class="pre">M</span></code>. The optimiser <em>also</em> considers each <em>imported</em> <a class="reference internal" href="#pragma-INLINABLE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINABLE</span></code></a>
overloaded function, and specialises it for the different types at which
it is called in <code class="docutils literal notranslate"><span class="pre">M</span></code>. So in our example, it would be enough for <code class="docutils literal notranslate"><span class="pre">lookup</span></code>
to be called at type <code class="docutils literal notranslate"><span class="pre">T</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Client</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">import</span><span class="w"> </span><span class="nn">Map</span><span class="p">(</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="kr">deriving</span><span class="p">(</span><span class="w"> </span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">findT1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[(</span><span class="kt">T</span><span class="p">,</span><span class="n">a</span><span class="p">)]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="n">findT1</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">T1</span><span class="w">   </span><span class="c1">-- A call of lookup at type T</span><span class="w"></span>
</pre></div>
</div>
<p>However, sometimes there are no such calls, in which case the pragma can
be useful.</p>
</section>
</section>
<section id="specialize-instance-pragma">
<span id="id13"></span><h2><span class="section-number">6.20.11. </span><code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> instance pragma<a class="headerlink" href="#specialize-instance-pragma" title="Permalink to this heading">¶</a></h2>
<span class="target" id="index-4"></span><dl class="std pragma">
<dt class="sig sig-object std" id="pragma-SPECIALIZE-instance">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">SPECIALIZE</span> <span class="pre">instance</span> <span class="pre">⟨instance</span> <span class="pre">head⟩</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-SPECIALIZE-instance" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>instance body</p>
</dd>
</dl>
</dd></dl>

<p>Same idea, except for instance declarations. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="cm">{-# SPECIALIZE instance Eq (Foo [(Int, Bar)]) #-}</span><span class="w"></span>
<span class="w">   </span><span class="o">...</span><span class="w"> </span><span class="n">usual</span><span class="w"> </span><span class="n">stuff</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The pragma must occur inside the <code class="docutils literal notranslate"><span class="pre">where</span></code> part of the instance
declaration.</p>
</section>
<section id="unpack-pragma">
<span id="id14"></span><h2><span class="section-number">6.20.12. </span><code class="docutils literal notranslate"><span class="pre">UNPACK</span></code> pragma<a class="headerlink" href="#unpack-pragma" title="Permalink to this heading">¶</a></h2>
<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-UNPACK">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">UNPACK</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-UNPACK" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>data constructor field</p>
</dd>
</dl>
<p>Instructs the compiler to unpack the contents of a constructor field into
the constructor itself.</p>
</dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">UNPACK</span></code> indicates to the compiler that it should unpack the
contents of a constructor field into the constructor itself, removing a
level of indirection. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="cm">{-# UNPACK #-}</span><span class="w"> </span><span class="o">!</span><span class="kt">Float</span><span class="w"></span>
<span class="w">           </span><span class="cm">{-# UNPACK #-}</span><span class="w"> </span><span class="o">!</span><span class="kt">Float</span><span class="w"></span>
</pre></div>
</div>
<p>will create a constructor <code class="docutils literal notranslate"><span class="pre">T</span></code> containing two unboxed floats. This may
not always be an optimisation: if the <code class="docutils literal notranslate"><span class="pre">T</span></code> constructor is scrutinised
and the floats passed to a non-strict function for example, they will
have to be reboxed (this is done automatically by the compiler).</p>
<p>Unpacking constructor fields should only be used in conjunction with
<a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a> <a class="footnote-reference brackets" href="#id16" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, in order to expose unfoldings to the compiler so the
reboxing can be removed as often as possible. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Float</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="n">f2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f2</span><span class="w"></span>
</pre></div>
</div>
<p>The compiler will avoid reboxing <code class="docutils literal notranslate"><span class="pre">f1</span></code> and <code class="docutils literal notranslate"><span class="pre">f2</span></code> by inlining <code class="docutils literal notranslate"><span class="pre">+</span></code> on
floats, but only when <a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a> is on.</p>
<p>Any single-constructor data is eligible for unpacking; for example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="cm">{-# UNPACK #-}</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>will store the two <code class="docutils literal notranslate"><span class="pre">Int</span></code>s directly in the <code class="docutils literal notranslate"><span class="pre">T</span></code> constructor, by
flattening the pair. Multi-level unpacking is also supported:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="cm">{-# UNPACK #-}</span><span class="w"> </span><span class="o">!</span><span class="kt">S</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="cm">{-# UNPACK #-}</span><span class="w"> </span><span class="o">!</span><span class="kt">Int</span><span class="w"> </span><span class="cm">{-# UNPACK #-}</span><span class="w"> </span><span class="o">!</span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>will store two unboxed <code class="docutils literal notranslate"><span class="pre">Int#</span></code>s directly in the <code class="docutils literal notranslate"><span class="pre">T</span></code> constructor.
The unpacker can see through newtypes, too.</p>
<p>See also the <a class="reference internal" href="../using-optimisation.html#ghc-flag-funbox-strict-fields"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funbox-strict-fields</span></code></a> flag, which essentially has the
effect of adding <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">UNPACK</span> <span class="pre">#-}</span></code> to every strict constructor field.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id16" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">1</a><span class="fn-bracket">]</span></span>
<p>In fact, <a class="reference internal" href="#pragma-UNPACK"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">UNPACK</span></code></a> has no effect without <a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a>, for technical
reasons (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/5252">#5252</a>).</p>
</aside>
</aside>
</section>
<section id="nounpack-pragma">
<span id="id17"></span><h2><span class="section-number">6.20.13. </span><code class="docutils literal notranslate"><span class="pre">NOUNPACK</span></code> pragma<a class="headerlink" href="#nounpack-pragma" title="Permalink to this heading">¶</a></h2>
<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-NOUNPACK">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">NOUNPACK</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-NOUNPACK" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>top-level</p>
</dd>
</dl>
<p>Instructs the compiler not to unpack a constructor field.</p>
</dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">NOUNPACK</span></code> pragma indicates to the compiler that it should not
unpack the contents of a constructor field. Example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="cm">{-# NOUNPACK #-}</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Even with the flags <a class="reference internal" href="../using-optimisation.html#ghc-flag-funbox-strict-fields"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funbox-strict-fields</span></code></a> and <a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a>, the
field of the constructor <code class="docutils literal notranslate"><span class="pre">T</span></code> is not unpacked.</p>
</section>
<section id="source-pragma">
<span id="id18"></span><h2><span class="section-number">6.20.14. </span><code class="docutils literal notranslate"><span class="pre">SOURCE</span></code> pragma<a class="headerlink" href="#source-pragma" title="Permalink to this heading">¶</a></h2>
<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-SOURCE">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-SOURCE" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>after <code class="docutils literal notranslate"><span class="pre">import</span></code> statement</p>
</dd>
</dl>
<p>Import a module by <code class="docutils literal notranslate"><span class="pre">hs-boot</span></code> file to break a module loop.</p>
</dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code> pragma is used only in <code class="docutils literal notranslate"><span class="pre">import</span></code> declarations,
to break a module loop. It is described in detail in
<a class="reference internal" href="../separate_compilation.html#mutual-recursion"><span class="std std-ref">How to compile mutually recursive modules</span></a>.</p>
</section>
<section id="complete-pragmas">
<span id="complete-pragma"></span><h2><span class="section-number">6.20.15. </span><code class="docutils literal notranslate"><span class="pre">COMPLETE</span></code> pragmas<a class="headerlink" href="#complete-pragmas" title="Permalink to this heading">¶</a></h2>
<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-COMPLETE">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">COMPLETE</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-COMPLETE" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>at top level</p>
</dd>
</dl>
<p>Specify the set of constructors or pattern synonyms which constitute a total
match.</p>
</dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">COMPLETE</span></code> pragma is used to inform the pattern match checker that a
certain set of patterns is complete and that any function which matches
on all the specified patterns is total.</p>
<p>The most common usage of <code class="docutils literal notranslate"><span class="pre">COMPLETE</span></code> pragmas is with
<a class="reference internal" href="pattern_synonyms.html#pattern-synonyms"><span class="std std-ref">Pattern synonyms</span></a>.
On its own, the checker is very naive and assumes that any match involving
a pattern synonym will fail. As a result, any pattern match on a
pattern synonym is regarded as
incomplete unless the user adds a catch-all case.</p>
<p>For example, the data types <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">A</span></code> are isomorphic but some
computations are more naturally expressed in terms of one or the other. To
get the best of both worlds, we can choose one as our implementation and then
provide a set of pattern synonyms so that users can use the other representation
if they desire. We can then specify a <code class="docutils literal notranslate"><span class="pre">COMPLETE</span></code> pragma in order to
inform the pattern match checker that a function which matches on both <code class="docutils literal notranslate"><span class="pre">LeftChoice</span></code>
and <code class="docutils literal notranslate"><span class="pre">RightChoice</span></code> is total.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Choice</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Choice</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="nf">pattern</span><span class="w"> </span><span class="kt">LeftChoice</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Choice</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">LeftChoice</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Choice</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="nf">pattern</span><span class="w"> </span><span class="kt">RightChoice</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Choice</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">RightChoice</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Choice</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="cm">{-# COMPLETE LeftChoice, RightChoice #-}</span><span class="w"></span>

<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Choice</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="kt">LeftChoice</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="kt">RightChoice</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">COMPLETE</span></code> pragmas are only used by the pattern match checker. If a function
definition matches on all the constructors specified in the pragma then the
compiler will produce no warning.</p>
<p><code class="docutils literal notranslate"><span class="pre">COMPLETE</span></code> pragmas can contain any data constructors or pattern
synonyms which are in scope, but must mention at least one data
constructor or pattern synonym defined in the same module.
<code class="docutils literal notranslate"><span class="pre">COMPLETE</span></code> pragmas may only appear at the top level of a module.
Once defined, they are automatically imported and exported from
modules. <code class="docutils literal notranslate"><span class="pre">COMPLETE</span></code> pragmas should be thought of as asserting a
universal truth about a set of patterns and as a result, should not be
used to silence context specific incomplete match warnings.</p>
<p>It is also possible to restrict the types to which a <code class="docutils literal notranslate"><span class="pre">COMPLETE</span></code> pragma applies
by putting a double colon <code class="docutils literal notranslate"><span class="pre">::</span></code> after the list of constructors, followed by a
result type constructor, which will be used to restrict the cases in which the
pragma applies. GHC will compare the annotated result type constructor with the
type constructor in the head of the scrutinee type in a pattern match to see if
the <code class="docutils literal notranslate"><span class="pre">COMPLETE</span></code> pragma is meant to apply to it.</p>
<p>This is especially useful in cases that the constructors specified are
polymorphic, e.g.:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">IsEmpty</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">isEmpty</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">IsCons</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Elt</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="n">isCons</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">(</span><span class="kt">Elt</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>

<span class="nf">pattern</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IsEmpty</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">isEmpty</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">True</span><span class="p">)</span><span class="w"></span>

<span class="nf">pattern</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IsCons</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Elt</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">isCons</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">))</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">IsEmpty</span><span class="w"> </span><span class="p">(</span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">isEmpty</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">IsEmpty</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">isEmpty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">null</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">IsCons</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Elt</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="n">isCons</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"></span>
<span class="w">  </span><span class="n">isCons</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">)</span><span class="w"></span>

<span class="cm">{-# COMPLETE Empty :: Proxy #-}</span><span class="w"></span>
<span class="cm">{-# COMPLETE Empty, Cons :: [] #-}</span><span class="w"></span>

<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="nf">bar</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">bar</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="nf">bar</span><span class="w"> </span><span class="p">(</span><span class="kt">Cons</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="nf">baz</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">baz</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">foo</span></code> and <code class="docutils literal notranslate"><span class="pre">bar</span></code> will not be warned about, as their
pattern matches are covered by the two <code class="docutils literal notranslate"><span class="pre">COMPLETE</span></code> pragmas above, but
<code class="docutils literal notranslate"><span class="pre">baz</span></code> will be warned about as incomplete.</p>
</section>
<section id="overlapping-overlappable-overlaps-and-incoherent-pragmas">
<span id="overlap-pragma"></span><h2><span class="section-number">6.20.16. </span><code class="docutils literal notranslate"><span class="pre">OVERLAPPING</span></code>, <code class="docutils literal notranslate"><span class="pre">OVERLAPPABLE</span></code>, <code class="docutils literal notranslate"><span class="pre">OVERLAPS</span></code>, and <code class="docutils literal notranslate"><span class="pre">INCOHERENT</span></code> pragmas<a class="headerlink" href="#overlapping-overlappable-overlaps-and-incoherent-pragmas" title="Permalink to this heading">¶</a></h2>
<span class="target" id="index-5"></span><dl class="std pragma">
<dt class="sig sig-object std" id="pragma-OVERLAPPING">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">OVERLAPPING</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-OVERLAPPING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-OVERLAPPABLE">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">OVERLAPPABLE</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-OVERLAPPABLE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-OVERLAPS">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">OVERLAPS</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-OVERLAPS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std pragma">
<dt class="sig sig-object std" id="pragma-INCOHERENT">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">INCOHERENT</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-INCOHERENT" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>on instance head</p>
</dd>
</dl>
</dd></dl>

<p>The pragmas <code class="docutils literal notranslate"><span class="pre">OVERLAPPING</span></code>, <code class="docutils literal notranslate"><span class="pre">OVERLAPPABLE</span></code>, <code class="docutils literal notranslate"><span class="pre">OVERLAPS</span></code>,
<code class="docutils literal notranslate"><span class="pre">INCOHERENT</span></code> are used to specify the overlap behavior for individual
instances, as described in Section <a class="reference internal" href="instances.html#instance-overlap"><span class="std std-ref">Overlapping instances</span></a>. The pragmas
are written immediately after the <code class="docutils literal notranslate"><span class="pre">instance</span></code> keyword, like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="cm">{-# OVERLAPPING #-}</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../extending_ghc.html" class="btn btn-neutral float-right" title="7. Extending and using GHC as a Library" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="callstack.html" class="btn btn-neutral float-left" title="6.19.5. HasCallStack" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.16. Unboxed types and primitive operations &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.17. Foreign function interface (FFI)" href="ffi.html" />
    <link rel="prev" title="6.15.3. Static pointers" href="static_pointers.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6.16. Unboxed types and primitive operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#unboxed-types">6.16.1. Unboxed types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unboxed-type-kinds">6.16.2. Unboxed type kinds</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unboxed-tuples">6.16.3. Unboxed tuples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unboxed-sums">6.16.4. Unboxed sums</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unlifted-newtypes">6.16.5. Unlifted Newtypes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unlifted-datatypes">6.16.6. Unlifted Datatypes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
      <li><span class="section-number">6.16. </span>Unboxed types and primitive operations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/primitives.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="unboxed-types-and-primitive-operations">
<span id="primitives"></span><h1><span class="section-number">6.16. </span>Unboxed types and primitive operations<a class="headerlink" href="#unboxed-types-and-primitive-operations" title="Permalink to this heading">¶</a></h1>
<p>GHC is built on a raft of primitive data types and operations;
“primitive” in the sense that they cannot be defined in Haskell itself.
While you really can use this stuff to write fast code, we generally
find it a lot less painful, and more satisfying in the long run, to use
higher-level language features and libraries. With any luck, the code
you write will be optimised to the efficient unboxed version in any
case. And if it isn’t, we’d like to know about it.</p>
<p>All these primitive data types and operations are exported by the
library <a class="reference external" href="../../libraries/ghc-prim-0.8.0/GHC-Prim.html">GHC.Prim</a>. (This documentation is generated from
the file <code class="docutils literal notranslate"><span class="pre">compiler/GHC/Builtin/primops.txt.pp</span></code>.)</p>
<p>If you want to mention any of the primitive data types or operations in
your program, you must first import <code class="docutils literal notranslate"><span class="pre">GHC.Prim</span></code> to bring them into
scope. Many of them have names ending in <code class="docutils literal notranslate"><span class="pre">#</span></code>, and to mention such names
you need the <a class="reference internal" href="magic_hash.html#extension-MagicHash"><code class="xref std std-extension docutils literal notranslate"><span class="pre">MagicHash</span></code></a> extension.</p>
<p>The primops make extensive use of <a class="reference external" href="#glasgow-unboxed">unboxed types</a>
and <a class="reference external" href="#unboxed-tuples">unboxed tuples</a>, which we briefly summarise
here.</p>
<section id="unboxed-types">
<span id="glasgow-unboxed"></span><h2><span class="section-number">6.16.1. </span>Unboxed types<a class="headerlink" href="#unboxed-types" title="Permalink to this heading">¶</a></h2>
<p>Most types in GHC are boxed, which means that values of that type are
represented by a pointer to a heap object. The representation of a
Haskell <code class="docutils literal notranslate"><span class="pre">Int</span></code>, for example, is a two-word heap object. An unboxed
type, however, is represented by the value itself, no pointers or heap
allocation are involved.</p>
<p>Unboxed types correspond to the “raw machine” types you would use in C:
<code class="docutils literal notranslate"><span class="pre">Int#</span></code> (long int), <code class="docutils literal notranslate"><span class="pre">Double#</span></code> (double), <code class="docutils literal notranslate"><span class="pre">Addr#</span></code> (void *), etc. The
<em>primitive operations</em> (PrimOps) on these types are what you might
expect; e.g., <code class="docutils literal notranslate"><span class="pre">(+#)</span></code> is addition on <code class="docutils literal notranslate"><span class="pre">Int#</span></code>s, and is the
machine-addition that we all know and love—usually one instruction.</p>
<p>Primitive (unboxed) types cannot be defined in Haskell, and are
therefore built into the language and compiler. Primitive types are
always unlifted; that is, a value of a primitive type cannot be bottom.
(Note: a “boxed” type means that a value is represented by a pointer to a heap
object; a “lifted” type means that terms of that type may be bottom. See
the next paragraph for an example.)
We use the convention (but it is only a convention) that primitive
types, values, and operations have a <code class="docutils literal notranslate"><span class="pre">#</span></code> suffix (see
<a class="reference internal" href="magic_hash.html#magic-hash"><span class="std std-ref">The magic hash</span></a>). For some primitive types we have special syntax for
literals, also described in the <a class="reference external" href="#magic-hash">same section</a>.</p>
<p>Primitive values are often represented by a simple bit-pattern, such as
<code class="docutils literal notranslate"><span class="pre">Int#</span></code>, <code class="docutils literal notranslate"><span class="pre">Float#</span></code>, <code class="docutils literal notranslate"><span class="pre">Double#</span></code>. But this is not necessarily the case:
a primitive value might be represented by a pointer to a heap-allocated
object. Examples include <code class="docutils literal notranslate"><span class="pre">Array#</span></code>, the type of primitive arrays. Thus,
<code class="docutils literal notranslate"><span class="pre">Array#</span></code> is an unlifted, boxed type. A
primitive array is heap-allocated because it is too big a value to fit
in a register, and would be too expensive to copy around; in a sense, it
is accidental that it is represented by a pointer. If a pointer
represents a primitive value, then it really does point to that value:
no unevaluated thunks, no indirections. Nothing can be at the other end
of the pointer than the primitive value. A numerically-intensive program
using unboxed types can go a <em>lot</em> faster than its “standard”
counterpart—we saw a threefold speedup on one example.</p>
</section>
<section id="unboxed-type-kinds">
<h2><span class="section-number">6.16.2. </span>Unboxed type kinds<a class="headerlink" href="#unboxed-type-kinds" title="Permalink to this heading">¶</a></h2>
<p>Because unboxed types are represented without the use of pointers, we
cannot store them in a polymorphic data type.
For example, the <code class="docutils literal notranslate"><span class="pre">Just</span></code> node
of <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">42#</span></code> would have to be different from the <code class="docutils literal notranslate"><span class="pre">Just</span></code> node of
<code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">42</span></code>; the former stores an integer directly, while the latter
stores a pointer. GHC currently does not support this variety of <code class="docutils literal notranslate"><span class="pre">Just</span></code>
nodes (nor for any other data type). Accordingly, the <em>kind</em> of an unboxed
type is different from the kind of a boxed type.</p>
<p>The Haskell Report describes that <code class="docutils literal notranslate"><span class="pre">*</span></code> (spelled <code class="docutils literal notranslate"><span class="pre">Type</span></code> and imported from
<code class="docutils literal notranslate"><span class="pre">Data.Kind</span></code> in the GHC dialect of Haskell) is the kind of ordinary data types,
such as <code class="docutils literal notranslate"><span class="pre">Int</span></code>. Furthermore, type constructors can have kinds with arrows; for
example, <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> has kind <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code>. Unboxed types have a kind that
specifies their runtime representation. For example, the type <code class="docutils literal notranslate"><span class="pre">Int#</span></code> has kind
<code class="docutils literal notranslate"><span class="pre">TYPE</span> <span class="pre">'IntRep</span></code> and <code class="docutils literal notranslate"><span class="pre">Double#</span></code> has kind <code class="docutils literal notranslate"><span class="pre">TYPE</span> <span class="pre">'DoubleRep</span></code>. These kinds say
that the runtime representation of an <code class="docutils literal notranslate"><span class="pre">Int#</span></code> is a machine integer, and the
runtime representation of a <code class="docutils literal notranslate"><span class="pre">Double#</span></code> is a machine double-precision floating
point. In contrast, the kind <code class="docutils literal notranslate"><span class="pre">Type</span></code> is actually just a synonym for <code class="docutils literal notranslate"><span class="pre">TYPE</span>
<span class="pre">'LiftedRep</span></code>. More details of the <code class="docutils literal notranslate"><span class="pre">TYPE</span></code> mechanisms appear in the <a class="reference external" href="#runtime-rep">section
on runtime representation polymorphism</a>.</p>
<p>Given that <code class="docutils literal notranslate"><span class="pre">Int#</span></code>’s kind is not <code class="docutils literal notranslate"><span class="pre">Type</span></code>, then it follows that <code class="docutils literal notranslate"><span class="pre">Maybe</span>
<span class="pre">Int#</span></code> is disallowed. Similarly, because type variables tend to be of kind
<code class="docutils literal notranslate"><span class="pre">Type</span></code> (for example, in <code class="docutils literal notranslate"><span class="pre">(.)</span> <span class="pre">::</span> <span class="pre">(b</span> <span class="pre">-&gt;</span> <span class="pre">c)</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">c</span></code>, all the
type variables have kind <code class="docutils literal notranslate"><span class="pre">Type</span></code>), polymorphism tends not to work over
primitive types. Stepping back, this makes some sense, because a polymorphic
function needs to manipulate the pointers to its data, and most primitive types
are unboxed.</p>
<p>There are some restrictions on the use of primitive types:</p>
<ul>
<li><p>You cannot define a newtype whose representation type (the argument
type of the data constructor) is an unboxed type. Thus, this is
illegal:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkA</span><span class="w"> </span><span class="kt">Int</span><span class="o">#</span><span class="w"></span>
</pre></div>
</div>
<p>However, this restriction can be relaxed by enabling
<a class="reference internal" href="#extension-UnliftedNewtypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedNewtypes</span></code></a>.  The <a class="reference external" href="#unlifted-newtypes">section on unlifted newtypes</a> details the behavior of such types.</p>
</li>
<li><p>You cannot bind a variable with an unboxed type in a <em>top-level</em>
binding.</p></li>
<li><p>You cannot bind a variable with an unboxed type in a <em>recursive</em>
binding.</p></li>
<li><p>You may bind unboxed variables in a (non-recursive, non-top-level)
pattern binding, but you must make any such pattern-match strict.
(Failing to do so emits a warning <a class="reference internal" href="../using-warnings.html#ghc-flag-Wunbanged-strict-patterns"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wunbanged-strict-patterns</span></code></a>.)
For example, rather than:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="o">#</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">..</span><span class="n">rhs</span><span class="o">..</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">..</span><span class="n">body</span><span class="o">..</span><span class="w"></span>
</pre></div>
</div>
<p>you must write:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="o">#</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">..</span><span class="n">rhs</span><span class="o">..</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">..</span><span class="n">body</span><span class="o">..</span><span class="w"></span>
</pre></div>
</div>
<p>since <code class="docutils literal notranslate"><span class="pre">b</span></code> has type <code class="docutils literal notranslate"><span class="pre">Int#</span></code>.</p>
</li>
</ul>
</section>
<section id="unboxed-tuples">
<span id="id1"></span><h2><span class="section-number">6.16.3. </span>Unboxed tuples<a class="headerlink" href="#unboxed-tuples" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-UnboxedTuples">
<span id="ghc-flag--XUnboxedTuples"></span><span id="extension-NoUnboxedTuples"></span><span class="sig-name descname"><span class="pre">UnboxedTuples</span></span><a class="headerlink" href="#extension-UnboxedTuples" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.8.1</p>
</dd>
</dl>
</dd></dl>

<p>Unboxed tuples aren’t really exported by <code class="docutils literal notranslate"><span class="pre">GHC.Exts</span></code>; they are a
syntactic extension (<a class="reference internal" href="#extension-UnboxedTuples"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnboxedTuples</span></code></a>). An
unboxed tuple looks like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="n">e_1</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">,</span><span class="w"> </span><span class="n">e_n</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">e_1..e_n</span></code> are expressions of any type (primitive or
non-primitive). The type of an unboxed tuple looks the same.</p>
<p>Note that when unboxed tuples are enabled, <code class="docutils literal notranslate"><span class="pre">(#</span></code> is a single lexeme, so
for example when using operators like <code class="docutils literal notranslate"><span class="pre">#</span></code> and <code class="docutils literal notranslate"><span class="pre">#-</span></code> you need to write
<code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">#</span> <span class="pre">)</span></code> and <code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">#-</span> <span class="pre">)</span></code> rather than <code class="docutils literal notranslate"><span class="pre">(#)</span></code> and <code class="docutils literal notranslate"><span class="pre">(#-)</span></code>.</p>
<p>Unboxed tuples are used for functions that need to return multiple
values, but they avoid the heap allocation normally associated with
using fully-fledged tuples. When an unboxed tuple is returned, the
components are put directly into registers or on the stack; the unboxed
tuple itself does not have a composite representation. Many of the
primitive operations listed in <code class="docutils literal notranslate"><span class="pre">primops.txt.pp</span></code> return unboxed tuples.
In particular, the <code class="docutils literal notranslate"><span class="pre">IO</span></code> and <code class="docutils literal notranslate"><span class="pre">ST</span></code> monads use unboxed tuples to avoid
unnecessary allocation during sequences of operations.</p>
<p>There are some restrictions on the use of unboxed tuples:</p>
<ul>
<li><p>The typical use of unboxed tuples is simply to return multiple
values, binding those multiple results with a <code class="docutils literal notranslate"><span class="pre">case</span></code> expression,
thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>You can have an unboxed tuple in a pattern binding, thus</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">..</span><span class="n">body</span><span class="o">..</span><span class="w"></span>
</pre></div>
</div>
<p>If the types of <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> are not unboxed, the resulting
binding is lazy like any other Haskell pattern binding. The above
example desugars like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="n">p</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="n">t</span><span class="w"></span>
<span class="w">          </span><span class="n">q</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">snd</span><span class="w"> </span><span class="n">t</span><span class="w"></span>
<span class="w">      </span><span class="kr">in</span><span class="w"> </span><span class="o">..</span><span class="n">body</span><span class="o">..</span><span class="w"></span>
</pre></div>
</div>
<p>Indeed, the bindings can even be recursive.</p>
</li>
</ul>
</section>
<section id="unboxed-sums">
<span id="id2"></span><h2><span class="section-number">6.16.4. </span>Unboxed sums<a class="headerlink" href="#unboxed-sums" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-UnboxedSums">
<span id="ghc-flag--XUnboxedSums"></span><span id="extension-NoUnboxedSums"></span><span class="sig-name descname"><span class="pre">UnboxedSums</span></span><a class="headerlink" href="#extension-UnboxedSums" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>8.2.1</p>
</dd>
</dl>
<p>Enable the use of unboxed sum syntax.</p>
</dd></dl>

<p><cite>-XUnboxedSums</cite> enables new syntax for anonymous, unboxed sum types. The syntax
for an unboxed sum type with N alternatives is</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="n">t_1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">t_2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">t_N</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">t_1</span></code> … <code class="docutils literal notranslate"><span class="pre">t_N</span></code> are types (which can be unlifted, including unboxed
tuples and sums).</p>
<p>Unboxed tuples can be used for multi-arity alternatives. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The term level syntax is similar. Leading and preceding bars (<cite>|</cite>) indicate which
alternative it is. Here are two terms of the type shown above:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="c1">-- first alternative</span><span class="w"></span>

<span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="c1">-- second alternative</span><span class="w"></span>
</pre></div>
</div>
<p>The pattern syntax reflects the term syntax:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Unboxed sums are “unboxed” in the sense that, instead of allocating sums in the
heap and representing values as pointers, unboxed sums are represented as their
components, just like unboxed tuples. These “components” depend on alternatives
of a sum type. Like unboxed tuples, unboxed sums are lazy in their lifted
components.</p>
<p>The code generator tries to generate as compact layout as possible for each
unboxed sum. In the best case, size of an unboxed sum is size of its biggest
alternative plus one word (for a tag). The algorithm for generating the memory
layout for a sum type works like this:</p>
<ul>
<li><p>All types are classified as one of these classes: 32bit word, 64bit word,
32bit float, 64bit float, pointer.</p></li>
<li><p>For each alternative of the sum type, a layout that consists of these fields
is generated. For example, if an alternative has <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">Float#</span></code> and
<code class="docutils literal notranslate"><span class="pre">String</span></code> fields, the layout will have an 32bit word, 32bit float and
pointer fields.</p></li>
<li><p>Layout fields are then overlapped so that the final layout will be as compact
as possible. For example, suppose we have the unboxed sum:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="kt">Word32</span><span class="o">#</span><span class="p">,</span><span class="w"> </span><span class="kt">String</span><span class="p">,</span><span class="w"> </span><span class="kt">Float</span><span class="o">#</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"></span>
<span class="o">|</span><span class="w">  </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="kt">Float</span><span class="o">#</span><span class="p">,</span><span class="w"> </span><span class="kt">Float</span><span class="o">#</span><span class="p">,</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The final layout will be something like</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Int32</span><span class="p">,</span><span class="w"> </span><span class="kt">Float32</span><span class="p">,</span><span class="w"> </span><span class="kt">Float32</span><span class="p">,</span><span class="w"> </span><span class="kt">Word32</span><span class="p">,</span><span class="w"> </span><span class="kt">Pointer</span><span class="w"></span>
</pre></div>
</div>
<p>The first <code class="docutils literal notranslate"><span class="pre">Int32</span></code> is for the tag. There are two <code class="docutils literal notranslate"><span class="pre">Float32</span></code> fields because
floating point types can’t overlap with other types, because of limitations of
the code generator that we’re hoping to overcome in the future. The second
alternative needs two <code class="docutils literal notranslate"><span class="pre">Float32</span></code> fields: The <code class="docutils literal notranslate"><span class="pre">Word32</span></code> field is for the
<code class="docutils literal notranslate"><span class="pre">Word32#</span></code> in the first alternative. The <code class="docutils literal notranslate"><span class="pre">Pointer</span></code> field is shared between
<code class="docutils literal notranslate"><span class="pre">String</span></code> and <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Int</span></code> values of the alternatives.</p>
<p>As another example, this is the layout for the unboxed version of <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code>
type, <code class="docutils literal notranslate"><span class="pre">(#</span> <span class="pre">(#</span> <span class="pre">#)</span> <span class="pre">|</span> <span class="pre">a</span> <span class="pre">#)</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Int32</span><span class="p">,</span><span class="w"> </span><span class="kt">Pointer</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Pointer</span></code> field is not used when tag says that it’s <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.
Otherwise <code class="docutils literal notranslate"><span class="pre">Pointer</span></code> points to the value in <code class="docutils literal notranslate"><span class="pre">Just</span></code>. As mentioned
above, this type is lazy in its lifted field. Therefore, the type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Maybe&#39;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Maybe&#39;</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>is <em>precisely</em> isomorphic to the type <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code>, although its memory
representation is different.</p>
<p>In the degenerate case where all the alternatives have zero width, such
as the <code class="docutils literal notranslate"><span class="pre">Bool</span></code>-like <code class="docutils literal notranslate"><span class="pre">(#</span> <span class="pre">(#</span> <span class="pre">#)</span> <span class="pre">|</span> <span class="pre">(#</span> <span class="pre">#)</span> <span class="pre">#)</span></code>, the unboxed sum layout only
has an <code class="docutils literal notranslate"><span class="pre">Int32</span></code> tag field (i.e., the whole thing is represented by an integer).</p>
</li>
</ul>
</section>
<section id="unlifted-newtypes">
<span id="id3"></span><h2><span class="section-number">6.16.5. </span>Unlifted Newtypes<a class="headerlink" href="#unlifted-newtypes" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-UnliftedNewtypes">
<span id="ghc-flag--XUnliftedNewtypes"></span><span id="extension-NoUnliftedNewtypes"></span><span class="sig-name descname"><span class="pre">UnliftedNewtypes</span></span><a class="headerlink" href="#extension-UnliftedNewtypes" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>8.10.1</p>
</dd>
</dl>
<p>Enable the use of newtypes over types with non-lifted runtime representations.</p>
</dd></dl>

<p>GHC implements an <a class="reference internal" href="#extension-UnliftedNewtypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedNewtypes</span></code></a> extension as specified in
<a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0013-unlifted-newtypes.rst">this GHC proposal</a>.
<a class="reference internal" href="#extension-UnliftedNewtypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedNewtypes</span></code></a> relaxes the restrictions around what types can appear inside
of a <code class="docutils literal notranslate"><span class="pre">newtype</span></code>. For example, the type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkA</span><span class="w"> </span><span class="kt">Int</span><span class="o">#</span><span class="w"></span>
</pre></div>
</div>
<p>is accepted when this extension is enabled. This creates a type
<code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">::</span> <span class="pre">TYPE</span> <span class="pre">'IntRep</span></code> and a data constructor <code class="docutils literal notranslate"><span class="pre">MkA</span> <span class="pre">::</span> <span class="pre">Int#</span> <span class="pre">-&gt;</span> <span class="pre">A</span></code>.
Although the kind of <code class="docutils literal notranslate"><span class="pre">A</span></code> is inferred by GHC, there is nothing visually
distinctive about this type that indicated that is it not of kind <code class="docutils literal notranslate"><span class="pre">Type</span></code>
like newtypes typically are. <a class="reference external" href="#gadt-style">GADTSyntax</a> can be used to
provide a kind signature for additional clarity</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="kt">&#39;IntRep</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkA</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="o">#</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">A</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Coercible</span></code> machinery works with unlifted newtypes just like it does with
lifted types. In either of the equivalent formulations of <code class="docutils literal notranslate"><span class="pre">A</span></code> given above,
users would additionally have access to a coercion between <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">Int#</span></code>.</p>
<p>As a consequence of the
<a class="reference external" href="#levity-polymorphic-restrictions">levity-polymorphic binder restriction</a>,
levity-polymorphic fields are disallowed in data constructors
of data types declared using <code class="docutils literal notranslate"><span class="pre">data</span></code>. However, since <code class="docutils literal notranslate"><span class="pre">newtype</span></code> data
constructor application is implemented as a coercion instead of as function
application, this restriction does not apply to the field inside a <code class="docutils literal notranslate"><span class="pre">newtype</span></code>
data constructor. Thus, the type checker accepts</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">Identity</span><span class="o">#</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">RuntimeRep</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkIdentity</span><span class="o">#</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">RuntimeRep</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Identity</span><span class="o">#</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>And with <a class="reference external" href="#unboxed-sums">UnboxedSums</a> enabled</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">Maybe</span><span class="o">#</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">RuntimeRep</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="p">(</span><span class="kt">SumRep</span><span class="w"> </span><span class="kt">&#39;[r, TupleRep &#39;[]</span><span class="p">])</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkMaybe</span><span class="o">#</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">RuntimeRep</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="o">#</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="o">#</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>This extension also relaxes some of the restrictions around data family
instances. In particular, <a class="reference internal" href="#extension-UnliftedNewtypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedNewtypes</span></code></a> permits a
<code class="docutils literal notranslate"><span class="pre">newtype</span> <span class="pre">instance</span></code> to be given a return kind of <code class="docutils literal notranslate"><span class="pre">TYPE</span> <span class="pre">r</span></code>, not just
<code class="docutils literal notranslate"><span class="pre">Type</span></code>. For example, the following <code class="docutils literal notranslate"><span class="pre">newtype</span> <span class="pre">instance</span></code> declarations would be
permitted:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">FooKey</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="kt">&#39;IntRep</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="kt">Bar</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">RuntimeRep</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">BarType</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="n">r</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">newtype</span><span class="w"> </span><span class="kt">FooKey</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">FooKeyBoolC</span><span class="w"> </span><span class="kt">Int</span><span class="o">#</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Bar</span><span class="w"> </span><span class="kt">&#39;WordRep</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">newtype</span><span class="w"> </span><span class="kt">BarType</span><span class="w"> </span><span class="kt">&#39;WordRep</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">BarTypeWordRepC</span><span class="w"> </span><span class="kt">Word</span><span class="o">#</span><span class="w"></span>
</pre></div>
</div>
<p>It is worth noting that <a class="reference internal" href="#extension-UnliftedNewtypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedNewtypes</span></code></a> is <em>not</em> required to give
the data families themselves return kinds involving <code class="docutils literal notranslate"><span class="pre">TYPE</span></code>, such as the
<code class="docutils literal notranslate"><span class="pre">FooKey</span></code> and <code class="docutils literal notranslate"><span class="pre">BarType</span></code> examples above. The extension is
only required for <code class="docutils literal notranslate"><span class="pre">newtype</span> <span class="pre">instance</span></code> declarations, such as <code class="docutils literal notranslate"><span class="pre">FooKeyBoolC</span></code>
and <code class="docutils literal notranslate"><span class="pre">BarTypeWorkRepC</span></code> above.</p>
<p>This extension impacts the determination of whether or not a newtype has
a Complete User-Specified Kind Signature (CUSK). The exact impact is specified
<a class="reference external" href="#complete-kind-signatures">the section on CUSKs</a>.</p>
</section>
<section id="unlifted-datatypes">
<h2><span class="section-number">6.16.6. </span>Unlifted Datatypes<a class="headerlink" href="#unlifted-datatypes" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-UnliftedDatatypes">
<span id="ghc-flag--XUnliftedDatatypes"></span><span id="extension-NoUnliftedDatatypes"></span><span class="sig-name descname"><span class="pre">UnliftedDatatypes</span></span><a class="headerlink" href="#extension-UnliftedDatatypes" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Implies<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="data_kinds.html#extension-DataKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DataKinds</span></code></a>, <a class="reference internal" href="poly_kinds.html#extension-StandaloneKindSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">StandaloneKindSignatures</span></code></a></p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>9.2.1</p>
</dd>
</dl>
<p>Enable the declaration of data types with unlifted or levity-polymorphic
result kind.</p>
</dd></dl>

<p>GHC implements the <a class="reference internal" href="#extension-UnliftedDatatypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedDatatypes</span></code></a> extension as specified in
<a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0265-unlifted-datatypes.rst">this GHC proposal</a>.
<a class="reference internal" href="#extension-UnliftedDatatypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedDatatypes</span></code></a> relaxes the restrictions around what result kinds
are allowed in data declarations. For example, the type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">UList</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">UnliftedType</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">UCons</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">UList</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">UList</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="kt">UNil</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">UList</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>defines a list type that lives in kind <code class="docutils literal notranslate"><span class="pre">UnliftedType</span></code>
(e.g., <code class="docutils literal notranslate"><span class="pre">TYPE</span> <span class="pre">(BoxedRep</span> <span class="pre">Unlifted)</span></code>). As such, each occurrence of a term of that
type is assumed to be evaluated (and the compiler makes sure that is indeed the
case). In other words: Unlifted data types behave like data types in strict
languages such as OCaml or Idris. However unlike <a class="reference internal" href="strict.html#extension-StrictData"><code class="xref std std-extension docutils literal notranslate"><span class="pre">StrictData</span></code></a>,
this extension will not change whether the fields of a (perhaps unlifted)
data type are strict or lazy. For example, <code class="docutils literal notranslate"><span class="pre">UCons</span></code> is lazy in its first
argument as its field has kind <code class="docutils literal notranslate"><span class="pre">Type</span></code>.</p>
<p>The fact that unlifted types are always evaluated allows GHC to elide
evaluatedness checks at runtime. See the Motivation section of the proposal
for how this can improve performance for some programs.</p>
<p>The above data declaration in GADT syntax correctly suggests that unlifted
data types are compatible with the full GADT feature set. Somewhat conversely,
you can also declare unlifted data types in Haskell98 syntax, which requires you
to specify the result kind via <a class="reference internal" href="poly_kinds.html#extension-StandaloneKindSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">StandaloneKindSignatures</span></code></a>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">UList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">UnliftedType</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">UList</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">UCons</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">UList</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">UNil</span><span class="w"></span>
</pre></div>
</div>
<p>You may even declare levity-polymorphic data types:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">PEither</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="p">(</span><span class="kt">BoxedRep</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">PEither</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">PLeft</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">PRight</span><span class="w"> </span><span class="n">r</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">PEither</span><span class="w"> </span><span class="o">@</span><span class="kt">Unlifted</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">PRight</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="kr">_</span><span class="w">          </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
</pre></div>
</div>
<p>While <code class="docutils literal notranslate"><span class="pre">f</span></code> above could reasonably be levity-polymorphic (as it evaluates its
argument either way), GHC currently disallows the more general type
<code class="docutils literal notranslate"><span class="pre">PEither</span> <span class="pre">&#64;l</span> <span class="pre">Int</span> <span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>. This is a consequence of the
<a class="reference external" href="#levity-polymorphic-restrictions">levity-polymorphic binder restriction</a>,</p>
<p>Due to <cite>ticket 19487 &lt;https://gitlab.haskell.org/ghc/ghc/-/issues/19487&gt;</cite>, it’s
currently not possible to declare levity-polymorphic data types with nullary
data constructors. There’s a workaround, though:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="p">(</span><span class="kt">BoxedRep</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkT</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">l</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="nb">()</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Constraint</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="o">@</span><span class="n">l</span><span class="w"></span>
</pre></div>
</div>
<p>The use of <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> makes the type of <code class="docutils literal notranslate"><span class="pre">MkT</span></code> lifted.
If you want a zero-runtime-cost alternative, use <code class="docutils literal notranslate"><span class="pre">MkT</span> <span class="pre">::</span> <span class="pre">Proxy#</span> <span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">T</span> <span class="pre">&#64;l</span></code>
instead and bear with the additional <code class="docutils literal notranslate"><span class="pre">proxy#</span></code> argument at construction sites.</p>
<p>This extension also relaxes some of the restrictions around data family
instances. In particular, <a class="reference internal" href="#extension-UnliftedDatatypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedDatatypes</span></code></a> permits a
<code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">instance</span></code> to be given a return kind that unifies with
<code class="docutils literal notranslate"><span class="pre">TYPE</span> <span class="pre">(BoxedRep</span> <span class="pre">l)</span></code>, not just <code class="docutils literal notranslate"><span class="pre">Type</span></code>. For example, the following <code class="docutils literal notranslate"><span class="pre">data</span>
<span class="pre">instance</span></code> declarations would be permitted:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">UnliftedType</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">FInt</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="p">(</span><span class="kt">BoxedRep</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">GInt</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="c1">-- defaults to Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">UnliftedType</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">GBool</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="kt">Char</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">GChar</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Char</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="kt">Char</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">l</span><span class="o">.</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="p">(</span><span class="kt">BoxedRep</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">GDouble</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="o">@</span><span class="n">l</span><span class="w"> </span><span class="kt">Double</span><span class="w"></span>
</pre></div>
</div>
<p>It is worth noting that <a class="reference internal" href="#extension-UnliftedDatatypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedDatatypes</span></code></a> is <em>not</em> required to give
the data families themselves return kinds involving <code class="docutils literal notranslate"><span class="pre">TYPE</span></code>, such as the
<code class="docutils literal notranslate"><span class="pre">G</span></code> example above. The extension is only required for <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">instance</span></code>
declarations, such as <code class="docutils literal notranslate"><span class="pre">FInt</span></code> and <code class="docutils literal notranslate"><span class="pre">GBool</span></code> above.</p>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ffi.html" class="btn btn-neutral float-right" title="6.17. Foreign function interface (FFI)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="static_pointers.html" class="btn btn-neutral float-left" title="6.15.3. Static pointers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
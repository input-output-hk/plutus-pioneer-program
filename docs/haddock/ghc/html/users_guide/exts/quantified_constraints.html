

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.10.4. Quantified constraints &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.11. Type signatures" href="type_signatures.html" />
    <link rel="prev" title="6.10.3. The Constraint kind" href="constraint_kind.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="constraints.html">6.10. Constraints</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="flexible_contexts.html">6.10.1. Loosening restrictions on class contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="equality_constraints.html">6.10.2. Equality constraints and Coercible constraint</a></li>
<li class="toctree-l3"><a class="reference internal" href="constraint_kind.html">6.10.3. The <code class="docutils literal notranslate"><span class="pre">Constraint</span></code> kind</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.10.4. Quantified constraints</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#motivation">6.10.4.1. Motivation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#syntax-changes">6.10.4.2. Syntax changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#typing-changes">6.10.4.3. Typing changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#superclasses">6.10.4.4. Superclasses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#overlap">6.10.4.5. Overlap</a></li>
<li class="toctree-l4"><a class="reference internal" href="#instance-lookup">6.10.4.6. Instance lookup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#termination">6.10.4.7. Termination</a></li>
<li class="toctree-l4"><a class="reference internal" href="#coherence">6.10.4.8. Coherence</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="constraints.html"><span class="section-number">6.10. </span>Constraints</a> &raquo;</li>
        
      <li><span class="section-number">6.10.4. </span>Quantified constraints</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/quantified_constraints.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="quantified-constraints">
<span id="id1"></span><h1><span class="section-number">6.10.4. </span>Quantified constraints<a class="headerlink" href="#quantified-constraints" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-QuantifiedConstraints">
<span id="ghc-flag--XQuantifiedConstraints"></span><span id="extension-NoQuantifiedConstraints"></span><span class="sig-name descname"><span class="pre">QuantifiedConstraints</span></span><a class="headerlink" href="#extension-QuantifiedConstraints" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>8.6.1</p>
</dd>
</dl>
<p>Allow constraints to quantify over types.</p>
</dd></dl>

<p>The extension <a class="reference internal" href="#extension-QuantifiedConstraints"><code class="xref std std-extension docutils literal notranslate"><span class="pre">QuantifiedConstraints</span></code></a> introduces <strong>quantified constraints</strong>,
which give a new level of expressiveness in constraints. For example, consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Rose</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Branch</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Rose</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">???</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">Rose</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="kt">Branch</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="n">c1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">Branch</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">c2</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="ow">=</span><span class="w"> </span><span class="n">x1</span><span class="o">==</span><span class="n">x1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c1</span><span class="o">==</span><span class="n">c2</span><span class="w"></span>
</pre></div>
</div>
<p>From the <code class="docutils literal notranslate"><span class="pre">x1==x2</span></code> we need <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">a</span></code>, which is fine.  From <code class="docutils literal notranslate"><span class="pre">c1==c2</span></code> we need <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">(f</span> <span class="pre">(Rose</span> <span class="pre">f</span> <span class="pre">a))</span></code> which
is <em>not</em> fine in Haskell today; we have no way to solve such a constraint.</p>
<p><a class="reference internal" href="#extension-QuantifiedConstraints"><code class="xref std std-extension docutils literal notranslate"><span class="pre">QuantifiedConstraints</span></code></a> lets us write this</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w"></span>
<span class="w">       </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">Rose</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="kt">Branch</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="n">c1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">Branch</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">c2</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="ow">=</span><span class="w"> </span><span class="n">x1</span><span class="o">==</span><span class="n">x1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c1</span><span class="o">==</span><span class="n">c2</span><span class="w"></span>
</pre></div>
</div>
<p>Here, the quantified constraint <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">b.</span> <span class="pre">(Eq</span> <span class="pre">b)</span> <span class="pre">=&gt;</span> <span class="pre">Eq</span> <span class="pre">(f</span> <span class="pre">b)</span></code> behaves
a bit like a local instance declaration, and makes the instance typeable.</p>
<p>The paper <a class="reference external" href="https://homepages.inf.ed.ac.uk/wadler/papers/quantcc/quantcc.pdf">Quantified class constraints</a> (by Bottu, Karachalias,
Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) describes this feature in
technical detail, with examples, and so is a primary reference source for this
feature.</p>
<section id="motivation">
<h2><span class="section-number">6.10.4.1. </span>Motivation<a class="headerlink" href="#motivation" title="Permalink to this heading">¶</a></h2>
<p>Introducing quantified constraints offers two main benefits:</p>
<ul>
<li><p>Firstly, they enable terminating resolution where this was not possible before.  Consider for instance the following instance declaration for the general rose datatype</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Rose</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Rose</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Rose</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">Rose</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="kt">Rose</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="n">rs1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">Rose</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">rs2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">rs1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rs2</span><span class="w"></span>
</pre></div>
</div>
<p>This extension allows us to write constraints of the form <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">b.</span> <span class="pre">Eq</span> <span class="pre">b</span> <span class="pre">=&gt;</span>
<span class="pre">Eq</span> <span class="pre">(f</span> <span class="pre">b)</span></code>, which is needed to solve the <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">(f</span> <span class="pre">(Rose</span> <span class="pre">f</span> <span class="pre">x))</span></code> constraint
arising from the second usage of the <code class="docutils literal notranslate"><span class="pre">(==)</span></code> method.</p>
</li>
<li><p>Secondly, quantified constraints allow for more concise and precise specifications. As an example, consider the MTL type class for monad transformers:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Trans</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">lift</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>The developer knows that a monad transformer takes a monad <code class="docutils literal notranslate"><span class="pre">m</span></code> into a new monad <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">m</span></code>.
But this property is not formally specified in the above declaration.
This omission becomes an issue when defining monad transformer composition:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">runC</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="p">(</span><span class="n">t2</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Trans</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="kt">Trans</span><span class="w"> </span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Trans</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">lift</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">lift</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">lift</span><span class="w"></span>
</pre></div>
</div>
<p>The goal here is to <code class="docutils literal notranslate"><span class="pre">lift</span></code> from monad <code class="docutils literal notranslate"><span class="pre">m</span></code> to <code class="docutils literal notranslate"><span class="pre">t2</span> <span class="pre">m</span></code> and
then <code class="docutils literal notranslate"><span class="pre">lift</span></code> this again into <code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">(t2</span> <span class="pre">m)</span></code>.
However, this second <code class="docutils literal notranslate"><span class="pre">lift</span></code> can only be accepted when <code class="docutils literal notranslate"><span class="pre">(t2</span> <span class="pre">m)</span></code> is a monad
and there is no way of establishing that this fact universally holds.</p>
<p>Quantified constraints enable this property to be made explicit in the <code class="docutils literal notranslate"><span class="pre">Trans</span></code>
class declaration:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">m</span><span class="o">.</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Trans</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">lift</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
<p>This idea is very old; see Section 7 of <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/derivable-type-classes/">Derivable type classes</a>.</p>
</section>
<section id="syntax-changes">
<h2><span class="section-number">6.10.4.2. </span>Syntax changes<a class="headerlink" href="#syntax-changes" title="Permalink to this heading">¶</a></h2>
<p><a class="reference external" href="https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-18000010.5">Haskell 2010</a> defines a <code class="docutils literal notranslate"><span class="pre">context</span></code> (the bit to the left of <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> in a type) like this</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>context ::= class
        |   ( class1, ..., classn )

class ::= qtycls tyvar
        |  qtycls (tyvar atype1 ... atypen)
</pre></div>
</div>
<p>We extend <code class="docutils literal notranslate"><span class="pre">class</span></code> (warning: this is a rather confusingly named non-terminal symbol) with two extra forms, namely precisely what can appear in an instance declaration</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class ::= ...
      | [context =&gt;] qtycls inst
      | [context =&gt;] tyvar inst
</pre></div>
</div>
<p>The definition of <code class="docutils literal notranslate"><span class="pre">inst</span></code> is unchanged from the Haskell Report (roughly, just a type).
The <code class="docutils literal notranslate"><span class="pre">context</span> <span class="pre">=&gt;</span></code> part is optional.  That is the only syntactic change to the language.</p>
<p>Notes:</p>
<ul>
<li><p>Where GHC allows extensions in instance declarations we allow exactly the same extensions to this new form of <code class="docutils literal notranslate"><span class="pre">class</span></code>.  Specifically, with <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExplicitForAll</span></code></a> and <a class="reference internal" href="multi_param_type_classes.html#extension-MultiParamTypeClasses"><code class="xref std std-extension docutils literal notranslate"><span class="pre">MultiParamTypeClasses</span></code></a> the syntax becomes</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class ::= ...
       | [forall tyvars .] [context =&gt;] qtycls inst1 ... instn
       | [forall tyvars .] [context =&gt;] tyvar inst1 ... instn
</pre></div>
</div>
<p>Note that an explicit <code class="docutils literal notranslate"><span class="pre">forall</span></code> is often absolutely essential. Consider the rose-tree example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">Rose</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Without the <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">b</span></code>, the type variable <code class="docutils literal notranslate"><span class="pre">b</span></code> would be quantified over the whole instance declaration, which is not what is intended.</p>
</li>
<li><p>One of these new quantified constraints can appear anywhere that any other constraint can, not just in instance declarations.  Notably, it can appear in a type signature for a value binding, data constructor, or expression.  For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Rose</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Rose</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">t2</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The form with a type variable at the head allows this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">xx</span><span class="o">.</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="kt">Free</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">xx</span><span class="p">))</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="kt">Free</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kt">Free</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="w"></span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/14733#note_148352">Iceland Jack’s summary</a>.  The key point is that the bit to the right of the <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> may be headed by a type <em>variable</em> (<code class="docutils literal notranslate"><span class="pre">c</span></code> in this case), rather than a class.  It should not be one of the forall’d variables, though.</p>
<p>(NB: this goes beyond what is described in <a class="reference external" href="http://i.cs.hku.hk/~bruno//papers/hs2017.pdf">the paper</a>, but does not seem to introduce any new technical difficulties.)</p>
</li>
</ul>
</section>
<section id="typing-changes">
<h2><span class="section-number">6.10.4.3. </span>Typing changes<a class="headerlink" href="#typing-changes" title="Permalink to this heading">¶</a></h2>
<p>See <a class="reference external" href="http://i.cs.hku.hk/~bruno//papers/hs2017.pdf">the paper</a>.</p>
</section>
<section id="superclasses">
<h2><span class="section-number">6.10.4.4. </span>Superclasses<a class="headerlink" href="#superclasses" title="Permalink to this heading">¶</a></h2>
<p>Suppose we have:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">m</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>From the <code class="docutils literal notranslate"><span class="pre">x==x</span></code> we need an <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">(m</span> <span class="pre">Int)</span></code> constraint, but the context only gives us a way to figure out <code class="docutils literal notranslate"><span class="pre">Ord</span> <span class="pre">(m</span> <span class="pre">a)</span></code> constraints.  But from the given constraint <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">Ord</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Ord</span> <span class="pre">(m</span> <span class="pre">a)</span></code> we derive a second given constraint <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">Ord</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Eq</span> <span class="pre">(m</span> <span class="pre">a)</span></code>, and from that we can readily solve <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">(m</span> <span class="pre">Int)</span></code>.  This process is very similar to the way that superclasses already work: given an <code class="docutils literal notranslate"><span class="pre">Ord</span> <span class="pre">a</span></code> constraint we derive a second given <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">a</span></code> constraint.</p>
<p>NB: This treatment of superclasses goes beyond <a class="reference external" href="http://i.cs.hku.hk/~bruno//papers/hs2017.pdf">the paper</a>, but is specifically desired by users.</p>
</section>
<section id="overlap">
<h2><span class="section-number">6.10.4.5. </span>Overlap<a class="headerlink" href="#overlap" title="Permalink to this heading">¶</a></h2>
<p>Quantified constraints can potentially lead to overlapping local axioms.
Consider for instance the following example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="p">(</span><span class="kt">A</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="p">(</span><span class="kt">B</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">E</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">B</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">E</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
</div>
<p>When type checking the instance declaration for <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">a</span></code>,
we need to check that the superclass <code class="docutils literal notranslate"><span class="pre">C</span></code> of <code class="docutils literal notranslate"><span class="pre">F</span></code> holds.
We thus try to entail the constraint <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">a</span></code> under the theory containing:</p>
<ul class="simple">
<li><p>The instance axioms : <code class="docutils literal notranslate"><span class="pre">(B</span> <span class="pre">a,</span> <span class="pre">D</span> <span class="pre">a,</span> <span class="pre">E</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">F</span> <span class="pre">a</span></code></p></li>
<li><p>The local axioms from the instance context : <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">E</span> <span class="pre">a</span></code></p></li>
<li><p>The closure of the superclass relation over these local axioms : <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">C</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">C</span> <span class="pre">a</span></code></p></li>
</ul>
<p>However, the <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">C</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">C</span> <span class="pre">a</span></code> axioms both match the wanted constraint <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">a</span></code>.
There are several possible approaches for handling these overlapping local axioms:</p>
<ul>
<li><p><strong>Pick first</strong>.  We can simply select the <strong>first matching axiom</strong> we encounter.
In the above example, this would be <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">C</span> <span class="pre">a</span></code>.
We’d then need to entail <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">a</span></code>, for which we have no matching axioms available, causing the above program to be rejected.</p>
<p>But suppose we made a slight adjustment to the order of the instance context, putting <code class="docutils literal notranslate"><span class="pre">E</span> <span class="pre">a</span></code> before <code class="docutils literal notranslate"><span class="pre">D</span> <span class="pre">a</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">B</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">E</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
</div>
<p>The first matching axiom we encounter while entailing <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">a</span></code>, is <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">C</span> <span class="pre">a</span></code>.
We have a local axiom <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">a</span></code> available, so now the program is suddenly accepted.
This behaviour, where the ordering of an instance context determines
whether or not the program is accepted, seems rather confusing for the developer.</p>
</li>
<li><p><strong>Reject if in doubt</strong>.  An alternative approach would be to check for overlapping axioms,
when solving a constraint.
When multiple matching axioms are discovered, we <strong>reject the program</strong>.
This approach is a bit conservative, in that it may reject working programs.
But it seem much more transparent towards the developer, who
can be presented with a clear message, explaining why the program is rejected.</p></li>
<li><p><strong>Backtracking</strong>.  Lastly, a simple form of <strong>backtracking</strong> could be introduced.
We simply select the first matching axiom we encounter and when the entailment fails,
we backtrack and look for other axioms that might match the wanted constraint.</p>
<p>This seems the most intuitive and transparent approach towards the developer,
who no longer needs to concern himself with the fact that his code might contain
overlapping axioms or with the ordering of his instance contexts.  But backtracking
would apply equally to ordinary instance selection (in the presence of overlapping
instances), so it is a much more pervasive change, with substantial consequences
for the type inference engine.</p>
</li>
</ul>
<p>GHC adopts <strong>Reject if in doubt</strong> for now.  We can see how painful it
is in practice, and try something more ambitious if necessary.</p>
</section>
<section id="instance-lookup">
<h2><span class="section-number">6.10.4.6. </span>Instance lookup<a class="headerlink" href="#instance-lookup" title="Permalink to this heading">¶</a></h2>
<p>In the light of the overlap decision, instance lookup works like this when
trying to solve a class constraint <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">t</span></code></p>
<ol class="arabic simple">
<li><p>First see if there is a given un-quantified constraint <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">t</span></code>.  If so, use it to solve the constraint.</p></li>
<li><p>If not, look at all the available given quantified constraints; if exactly one matches <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">t</span></code>, choose it; if more than one matches, report an error.</p></li>
<li><p>If no quantified constraints match, look up in the global instances, as described in <a class="reference internal" href="instances.html#instance-resolution"><span class="std std-ref">Instance declarations and resolution</span></a> and <a class="reference internal" href="instances.html#instance-overlap"><span class="std std-ref">Overlapping instances</span></a>.</p></li>
</ol>
</section>
<section id="termination">
<h2><span class="section-number">6.10.4.7. </span>Termination<a class="headerlink" href="#termination" title="Permalink to this heading">¶</a></h2>
<p>GHC uses the <a class="reference internal" href="instances.html#instance-termination"><span class="std std-ref">Paterson Conditions</span></a> to ensure
that instance resolution terminates. How are those rules modified for quantified
constraints? In two ways.</p>
<ul class="simple">
<li><p>Each quantified constraint, taken by itself, must satisfy the termination rules for an instance declaration.</p></li>
<li><p>After “for each class constraint <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">t1</span> <span class="pre">...</span> <span class="pre">tn)</span></code>”, add “or each quantified constraint <code class="docutils literal notranslate"><span class="pre">(forall</span> <span class="pre">as.</span> <span class="pre">context</span> <span class="pre">=&gt;</span> <span class="pre">C</span> <span class="pre">t1</span> <span class="pre">..</span> <span class="pre">tn)</span></code>”</p></li>
</ul>
<p>Note that the second item only at the <em>head</em> of the quantified constraint, not its context.  Reason: the head is the new goal that has to be solved if we use the instance declaration.</p>
<p>Of course, <code class="docutils literal notranslate"><span class="pre">UndecidableInstances</span></code> lifts the Paterson Conditions, as now.</p>
</section>
<section id="coherence">
<h2><span class="section-number">6.10.4.8. </span>Coherence<a class="headerlink" href="#coherence" title="Permalink to this heading">¶</a></h2>
<p>Although quantified constraints are a little like local instance declarations, they differ
in one big way: the local instances are written by the compiler, not the user, and hence
cannot introduce incoherence.  Consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="n">rhs</span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">...rhs...</span></code> there is, in effect a local instance for <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">(f</span> <span class="pre">a)</span></code> for any <code class="docutils literal notranslate"><span class="pre">a</span></code>.  But
at a call site for <code class="docutils literal notranslate"><span class="pre">f</span></code> the compiler itself produces evidence to pass to <code class="docutils literal notranslate"><span class="pre">f</span></code>. For example,
if we called <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">Nothing</span></code>, then <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> and the compiler must prove (at the
call site) that <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Eq</span> <span class="pre">(Maybe</span> <span class="pre">a)</span></code> holds.  It can do this easily, by
appealing to the existing instance declaration for <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">(Maybe</span> <span class="pre">a)</span></code>.</p>
<p>In short, quantified constraints do not introduce incoherence.</p>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="type_signatures.html" class="btn btn-neutral float-right" title="6.11. Type signatures" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="constraint_kind.html" class="btn btn-neutral float-left" title="6.10.3. The Constraint kind" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
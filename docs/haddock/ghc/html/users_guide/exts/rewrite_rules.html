

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.19.1. Rewrite rules &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.19.2. Special built-in functions" href="special_builtin.html" />
    <link rel="prev" title="6.19. Miscellaneous" href="misc.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.19.1. Rewrite rules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#syntax">6.19.1.1. Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#semantics">6.19.1.2. Semantics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-rules-interact-with-inline-noinline-pragmas">6.19.1.3. How rules interact with <code class="docutils literal notranslate"><span class="pre">INLINE</span></code>/<code class="docutils literal notranslate"><span class="pre">NOINLINE</span></code> pragmas</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-rules-interact-with-conlike-pragmas">6.19.1.4. How rules interact with <code class="docutils literal notranslate"><span class="pre">CONLIKE</span></code> pragmas</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-rules-interact-with-class-methods">6.19.1.5. How rules interact with class methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-fusion">6.19.1.6. List fusion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specialisation">6.19.1.7. Specialisation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#controlling-what-s-going-on-in-rewrite-rules">6.19.1.8. Controlling what’s going on in rewrite rules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="special_builtin.html">6.19.2. Special built-in functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="generics.html">6.19.3. Generic programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="assert.html">6.19.4. Assertions</a></li>
<li class="toctree-l3"><a class="reference internal" href="callstack.html">6.19.5. HasCallStack</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="misc.html"><span class="section-number">6.19. </span>Miscellaneous</a> &raquo;</li>
        
      <li><span class="section-number">6.19.1. </span>Rewrite rules</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/rewrite_rules.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="rewrite-rules">
<span id="id1"></span><h1><span class="section-number">6.19.1. </span>Rewrite rules<a class="headerlink" href="#rewrite-rules" title="Permalink to this heading">¶</a></h1>
<span class="target" id="index-0"></span><dl class="std pragma">
<dt class="sig sig-object std" id="pragma-RULES">
<span class="sig-name descname"><span class="pre">{-#</span> <span class="pre">RULES</span> <span class="pre">&quot;⟨name⟩&quot;</span> <span class="pre">forall</span> <span class="pre">⟨binder⟩</span> <span class="pre">...</span> <span class="pre">.</span> <span class="pre">⟨expr⟩</span> <span class="pre">=</span> <span class="pre">⟨expr⟩</span> <span class="pre">...</span> <span class="pre">#-}</span></span><a class="headerlink" href="#pragma-RULES" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Where<span class="colon">:</span></dt>
<dd class="field-odd"><p>top-level</p>
</dd>
</dl>
<p>Define a rewrite rule to be used to optimize a source program.</p>
</dd></dl>

<p>The programmer can specify rewrite rules as part of the source program
(in a pragma). Here is an example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# RULES</span>
<span class="cm">      &quot;map/map&quot;    forall f g xs.  map f (map g xs) = map (f.g) xs</span>
<span class="cm">  #-}</span><span class="w"></span>
</pre></div>
</div>
<p>Use the debug flag <a class="reference internal" href="../debugging.html#ghc-flag-ddump-simpl-stats"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-simpl-stats</span></code></a> to see what rules fired. If
you need more information, then <a class="reference internal" href="../debugging.html#ghc-flag-ddump-rule-firings"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-rule-firings</span></code></a> shows you each
individual rule firing and <a class="reference internal" href="../debugging.html#ghc-flag-ddump-rule-rewrites"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-rule-rewrites</span></code></a> also shows what the
code looks like before and after the rewrite.</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fenable-rewrite-rules">
<span class="sig-name descname"><span class="pre">-fenable-rewrite-rules</span></span><a class="headerlink" href="#ghc-flag-fenable-rewrite-rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the compiler to apply rewrite rules to the source program.</p>
</dd></dl>

<section id="syntax">
<h2><span class="section-number">6.19.1.1. </span>Syntax<a class="headerlink" href="#syntax" title="Permalink to this heading">¶</a></h2>
<p>From a syntactic point of view:</p>
<ul>
<li><p>There may be zero or more rules in a <a class="reference internal" href="#pragma-RULES"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">RULES</span></code></a> pragma, separated by
semicolons (which may be generated by the layout rule).</p></li>
<li><p>The layout rule applies in a pragma. Currently no new indentation
level is set, so if you put several rules in single <code class="docutils literal notranslate"><span class="pre">RULES</span></code> pragma and
wish to use layout to separate them, you must lay out the starting in
the same column as the enclosing definitions.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# RULES</span>
<span class="cm">      &quot;map/map&quot;    forall f g xs.  map f (map g xs) = map (f.g) xs</span>
<span class="cm">      &quot;map/append&quot; forall f xs ys. map f (xs ++ ys) = map f xs ++ map f ys</span>
<span class="cm">  #-}</span><span class="w"></span>
</pre></div>
</div>
<p>Furthermore, the closing <code class="docutils literal notranslate"><span class="pre">#-}</span></code> should start in a column to the
right of the opening <code class="docutils literal notranslate"><span class="pre">{-#</span></code>.</p>
</li>
<li><p>Each rule has a name, enclosed in double quotes. The name itself has
no significance at all. It is only used when reporting how many times
the rule fired.</p></li>
<li><p>A rule may optionally have a phase-control number (see
<a class="reference internal" href="pragmas.html#phase-control"><span class="std std-ref">Phase control</span></a>), immediately after the name of the rule. Thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# RULES</span>
<span class="cm">      &quot;map/map&quot; [2]  forall f g xs. map f (map g xs) = map (f.g) xs</span>
<span class="cm">  #-}</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">[2]</span></code> means that the rule is active in Phase 2 and subsequent
phases. The inverse notation <code class="docutils literal notranslate"><span class="pre">[~2]</span></code> is also accepted, meaning that
the rule is active up to, but not including, Phase 2.</p>
<p>Rules support the special phase-control notation <code class="docutils literal notranslate"><span class="pre">[~]</span></code>, which means
the rule is never active. This feature supports plugins (see
<a class="reference internal" href="../extending_ghc.html#compiler-plugins"><span class="std std-ref">Compiler Plugins</span></a>), by making it possible to define a RULE that
is never run by GHC, but is nevertheless parsed, typechecked etc, so
that it is available to the plugin.</p>
</li>
<li><p>Each (term) variable mentioned in a rule must either be in scope (e.g.
<code class="docutils literal notranslate"><span class="pre">map</span></code>), or bound by the <code class="docutils literal notranslate"><span class="pre">forall</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">xs</span></code>). The
variables bound by the <code class="docutils literal notranslate"><span class="pre">forall</span></code> are called the <em>pattern</em> variables.
They are separated by spaces, just like in a type <code class="docutils literal notranslate"><span class="pre">forall</span></code>.</p></li>
<li><p>A pattern variable may optionally have a type signature. If the type
of the pattern variable is polymorphic, it <em>must</em> have a type
signature. For example, here is the <code class="docutils literal notranslate"><span class="pre">foldr/build</span></code> rule:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;fold/build&quot;</span><span class="w">  </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="ow">::</span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="n">b</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"></span>
<span class="w">              </span><span class="n">foldr</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="p">(</span><span class="n">build</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">z</span><span class="w"></span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">g</span></code> has a polymorphic type, it must have a type signature.</p>
</li>
<li><p>If <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExplicitForAll</span></code></a> is enabled, type/kind variables can also be
explicitly bound. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# RULES &quot;id&quot; forall a. forall (x :: a). id @a x = x #-}</span><span class="w"></span>
</pre></div>
</div>
<p>When a type-level explicit <code class="docutils literal notranslate"><span class="pre">forall</span></code> is present, each type/kind variable
mentioned must now also be either in scope or bound by the <code class="docutils literal notranslate"><span class="pre">forall</span></code>. In
particular, unlike some other places in Haskell, this means free kind
variables will not be implicitly bound. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;this_is_bad&quot;</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="s">&quot;this_is_ok&quot;</span><span class="w">  </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>When bound type/kind variables are needed, both foralls must always be
included, though if no pattern variables are needed, the second can be left
empty. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# RULES &quot;map/id&quot; forall a. forall. map (id @a) = id @[a] #-}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The left hand side of a rule must consist of a top-level variable
applied to arbitrary expressions. For example, this is <em>not</em> OK:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;wrong1&quot;</span><span class="w">   </span><span class="n">forall</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="n">e2</span><span class="o">.</span><span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e1</span><span class="p">;</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e1</span><span class="w"></span>
<span class="s">&quot;wrong2&quot;</span><span class="w">   </span><span class="n">forall</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="w">      </span><span class="n">f</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="s">&quot;wrong3&quot;</span><span class="w">   </span><span class="n">forall</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="w">      </span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"></span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">&quot;wrong1&quot;</span></code>, the LHS is not an application; in <code class="docutils literal notranslate"><span class="pre">&quot;wrong2&quot;</span></code>, the
LHS has a pattern variable in the head. In <code class="docutils literal notranslate"><span class="pre">&quot;wrong3&quot;</span></code>, the LHS consists
of a <em>constructor</em>, rather than a <em>variable</em>, applied to an argument.</p>
</li>
<li><p>A rule does not need to be in the same module as (any of) the
variables it mentions, though of course they need to be in scope.</p></li>
<li><p>All rules are implicitly exported from the module, and are therefore
in force in any module that imports the module that defined the rule,
directly or indirectly. (That is, if A imports B, which imports C,
then C’s rules are in force when compiling A.) The situation is very
similar to that for instance declarations.</p></li>
<li><p>Inside a <a class="reference internal" href="#pragma-RULES"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">RULES</span></code></a> “<code class="docutils literal notranslate"><span class="pre">forall</span></code>” is treated as a keyword, regardless of any
other flag settings. Furthermore, inside a <a class="reference internal" href="#pragma-RULES"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">RULES</span></code></a>, the language
extension <a class="reference internal" href="scoped_type_variables.html#extension-ScopedTypeVariables"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ScopedTypeVariables</span></code></a> is automatically enabled; see
<a class="reference internal" href="scoped_type_variables.html#scoped-type-variables"><span class="std std-ref">Lexically scoped type variables</span></a>.</p></li>
<li><p>Like other pragmas, <a class="reference internal" href="#pragma-RULES"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">RULES</span></code></a> pragmas are always checked for scope errors,
and are typechecked. Typechecking means that the LHS and RHS of a
rule are typechecked, and must have the same type. However, rules are
only <em>enabled</em> if the <a class="reference internal" href="#ghc-flag-fenable-rewrite-rules"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fenable-rewrite-rules</span></code></a> flag is on (see
<a class="reference internal" href="#rule-semantics"><span class="std std-ref">Semantics</span></a>).</p></li>
</ul>
</section>
<section id="semantics">
<span id="rule-semantics"></span><h2><span class="section-number">6.19.1.2. </span>Semantics<a class="headerlink" href="#semantics" title="Permalink to this heading">¶</a></h2>
<p>From a semantic point of view:</p>
<ul>
<li><p>Rules are enabled (that is, used during optimisation) by the
<a class="reference internal" href="#ghc-flag-fenable-rewrite-rules"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fenable-rewrite-rules</span></code></a> flag. This flag is implied by
<a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a>, and may be switched off (as usual) by
<a class="reference internal" href="#ghc-flag-fenable-rewrite-rules"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fno-enable-rewrite-rules</span></code></a>. (NB: enabling
<a class="reference internal" href="#ghc-flag-fenable-rewrite-rules"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fenable-rewrite-rules</span></code></a> without <a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a> may not do what you
expect, though, because without <a class="reference internal" href="../using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a> GHC ignores all optimisation
information in interface files; see <a class="reference internal" href="../using-optimisation.html#ghc-flag-fignore-interface-pragmas"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fignore-interface-pragmas</span></code></a>).
Note that <a class="reference internal" href="#ghc-flag-fenable-rewrite-rules"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fenable-rewrite-rules</span></code></a> is an
<em>optimisation</em> flag, and has no effect on parsing or typechecking.</p></li>
<li><p>Rules are regarded as left-to-right rewrite rules. When GHC finds an
expression that is a substitution instance of the LHS of a rule, it
replaces the expression by the (appropriately-substituted) RHS. By “a
substitution instance” we mean that the LHS can be made equal to the
expression by substituting for the pattern variables.</p></li>
<li><p>GHC makes absolutely no attempt to verify that the LHS and RHS of a
rule have the same meaning. That is undecidable in general, and
infeasible in most interesting cases. The responsibility is entirely
the programmer’s!</p></li>
<li><p>GHC makes no attempt to make sure that the rules are confluent or
terminating. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;loop&quot;</span><span class="w">        </span><span class="n">forall</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="o">.</span><span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>This rule will cause the compiler to go into an infinite loop.</p>
</li>
<li><p>If more than one rule matches a call, GHC will choose one arbitrarily
to apply.</p></li>
<li><p>GHC currently uses a very simple, syntactic, matching algorithm for
matching a rule LHS with an expression. It seeks a substitution which
makes the LHS and expression syntactically equal modulo alpha
conversion. The pattern (rule), but not the expression, is
eta-expanded if necessary. (Eta-expanding the expression can lead to
laziness bugs.) But not beta conversion (that’s called higher-order
matching).</p>
<p>Matching is carried out on GHC’s intermediate language, which
includes type abstractions and applications. So a rule only matches
if the types match too. See <a class="reference internal" href="#rule-spec"><span class="std std-ref">Specialisation</span></a> below.</p>
</li>
<li><p>GHC keeps trying to apply the rules as it optimises the program. For
example, consider:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">f</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">g</span><span class="w"></span>
<span class="kr">in</span><span class="w"></span>
<span class="nf">s</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The expression <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">(t</span> <span class="pre">xs)</span></code> does not match the rule <code class="docutils literal notranslate"><span class="pre">&quot;map/map&quot;</span></code>,
but GHC will substitute for <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>, giving an expression
which does match. If <code class="docutils literal notranslate"><span class="pre">s</span></code> or <code class="docutils literal notranslate"><span class="pre">t</span></code> was (a) used more than once, and
(b) large or a redex, then it would not be substituted, and the rule
would not fire.</p>
</li>
<li><p>GHC will never match a forall’d variable in a template with an expression
which contains locally bound variables. For example, it is permitted to write
a rule which contains a case expression:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# RULES</span>
<span class="cm">  &quot;test/case-tup&quot; forall (x :: (Int, Int)) (y :: Int) (z :: Int).</span>
<span class="cm">    test (case x of (l, r) -&gt; y) z = case x of (l, r) -&gt; test y z</span>
<span class="cm">  #-}</span><span class="w"></span>
</pre></div>
</div>
<p>But the rule will not match when <code class="docutils literal notranslate"><span class="pre">y</span></code> contains either of <code class="docutils literal notranslate"><span class="pre">l</span></code> or <code class="docutils literal notranslate"><span class="pre">r</span></code> because
they are locally bound. Therefore the following application will fail to trigger
the rule:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prog</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
<span class="nf">prog</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="p">(</span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
</div>
<p>because <code class="docutils literal notranslate"><span class="pre">y</span></code> would have to match against <code class="docutils literal notranslate"><span class="pre">p</span></code> (which is locally bound)
but it will fire for:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prog</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
<span class="nf">prog</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="p">(</span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
</div>
<p>because <code class="docutils literal notranslate"><span class="pre">y</span></code> can match against <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</li>
<li><p>A rule that has a forall binder with a polymorphic type, is likely to fail to fire. E. g.,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# RULES forall (x :: forall a. Num a =&gt; a -&gt; a).  f x = blah #-}</span><span class="w"></span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">x</span></code> has a polymorphic type.  This applies to a forall’d binder with a type class constraint, such as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# RULES forall @m (x :: KnownNat m =&gt; Proxy m).  g x = blah #-}</span><span class="w"></span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/issues/21093">#21093</a> for discussion.</p>
</li>
</ul>
</section>
<section id="how-rules-interact-with-inline-noinline-pragmas">
<span id="rules-inline"></span><h2><span class="section-number">6.19.1.3. </span>How rules interact with <code class="docutils literal notranslate"><span class="pre">INLINE</span></code>/<code class="docutils literal notranslate"><span class="pre">NOINLINE</span></code> pragmas<a class="headerlink" href="#how-rules-interact-with-inline-noinline-pragmas" title="Permalink to this heading">¶</a></h2>
<p>Ordinary inlining happens at the same time as rule rewriting, which may
lead to unexpected results. Consider this (artificial) example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="nf">h</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>

<span class="cm">{-# RULES &quot;f&quot; f True = False #-}</span><span class="w"></span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">f</span></code>'s right-hand side is small, it is inlined into <code class="docutils literal notranslate"><span class="pre">g</span></code>, to
give</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">g</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">g</span></code> is inlined into <code class="docutils literal notranslate"><span class="pre">h</span></code>, but <code class="docutils literal notranslate"><span class="pre">f</span></code>'s RULE has no chance to
fire. If instead GHC had first inlined <code class="docutils literal notranslate"><span class="pre">g</span></code> into <code class="docutils literal notranslate"><span class="pre">h</span></code> then there would have
been a better chance that <code class="docutils literal notranslate"><span class="pre">f</span></code>'s <a class="reference internal" href="#pragma-RULES"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">RULES</span></code></a> might fire.</p>
<p>The way to get predictable behaviour is to use a <a class="reference internal" href="pragmas.html#pragma-NOINLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">NOINLINE</span></code></a> pragma, or an
<code class="docutils literal notranslate"><span class="pre">INLINE[⟨phase⟩]</span></code> pragma, on <code class="docutils literal notranslate"><span class="pre">f</span></code>, to ensure that it is not inlined until
its <a class="reference internal" href="#pragma-RULES"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">RULES</span></code></a> have had a chance to fire. The warning flag
<a class="reference internal" href="../using-warnings.html#ghc-flag-Winline-rule-shadowing"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Winline-rule-shadowing</span></code></a> (see <a class="reference internal" href="../using-warnings.html#options-sanity"><span class="std std-ref">Warnings and sanity-checking</span></a>) warns about
this situation.</p>
</section>
<section id="how-rules-interact-with-conlike-pragmas">
<span id="conlike"></span><h2><span class="section-number">6.19.1.4. </span>How rules interact with <code class="docutils literal notranslate"><span class="pre">CONLIKE</span></code> pragmas<a class="headerlink" href="#how-rules-interact-with-conlike-pragmas" title="Permalink to this heading">¶</a></h2>
<p>GHC is very cautious about duplicating work. For example, consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">build</span><span class="w"> </span><span class="n">g</span><span class="w"></span>
<span class="w">           </span><span class="kr">in</span><span class="w"> </span><span class="o">...</span><span class="p">(</span><span class="n">foldr</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="o">...</span><span class="n">sum</span><span class="w"> </span><span class="n">xs</span><span class="o">...</span><span class="w"></span>
<span class="cm">{-# RULES &quot;foldr/build&quot; forall k z g. foldr k z (build g) = g k z #-}</span><span class="w"></span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">xs</span></code> is used twice, GHC does not fire the foldr/build rule.
Rightly so, because it might take a lot of work to compute <code class="docutils literal notranslate"><span class="pre">xs</span></code>, which
would be duplicated if the rule fired.</p>
<p>Sometimes, however, this approach is over-cautious, and we <em>do</em> want the
rule to fire, even though doing so would duplicate redex. There is no
way that GHC can work out when this is a good idea, so we provide the
<code class="docutils literal notranslate"><span class="pre">CONLIKE</span></code> pragma to declare it, thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINE CONLIKE [1] f #-}</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">blah</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CONLIKE</span></code> is a modifier to an <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> or <code class="docutils literal notranslate"><span class="pre">NOINLINE</span></code> pragma. It specifies that
an application of <code class="docutils literal notranslate"><span class="pre">f</span></code> to one argument (in general, the number of arguments
to the left of the <code class="docutils literal notranslate"><span class="pre">=</span></code> sign) should be considered cheap enough to
duplicate, if such a duplication would make rule fire. (The name
“CONLIKE” is short for “constructor-like”, because constructors
certainly have such a property.) The <a class="reference internal" href="pragmas.html#pragma-CONLIKE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">CONLIKE</span></code></a> pragma is a modifier to
<a class="reference internal" href="pragmas.html#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a>/<a class="reference internal" href="pragmas.html#pragma-NOINLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">NOINLINE</span></code></a> because it really only makes sense to match
<code class="docutils literal notranslate"><span class="pre">f</span></code> on the LHS of a rule if you are sure that <code class="docutils literal notranslate"><span class="pre">f</span></code> is not going to be inlined
before the rule has a chance to fire.</p>
</section>
<section id="how-rules-interact-with-class-methods">
<span id="rules-class-methods"></span><h2><span class="section-number">6.19.1.5. </span>How rules interact with class methods<a class="headerlink" href="#how-rules-interact-with-class-methods" title="Permalink to this heading">¶</a></h2>
<p>Giving a RULE for a class method is a bad idea:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">op</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">op</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="n">rhs</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="kt">Bool</span><span class="o">...</span><span class="w"></span>

<span class="cm">{-# RULES &quot;f&quot; op True y = False #-}</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">op</span></code> is not an ordinary top-level function; it is a
class method. GHC rapidly rewrites any occurrences of
<code class="docutils literal notranslate"><span class="pre">op</span></code>-used-at-type-Bool to a specialised function, say <code class="docutils literal notranslate"><span class="pre">opBool</span></code>,
where</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">opBool</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">opBool</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">..</span><span class="n">rhs</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="kt">Bool</span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>So the RULE never has a chance to fire, for just the same reasons as in
<a class="reference internal" href="#rules-inline"><span class="std std-ref">How rules interact with INLINE/NOINLINE pragmas</span></a>.</p>
<p>The solution is to define the instance-specific function yourself, with
a pragma to prevent it being inlined too early, and give a RULE for it:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">op</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">opBool</span><span class="w"></span>

<span class="nf">opBool</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="cm">{-# NOINLINE [1] opBool #-}</span><span class="w"></span>
<span class="nf">opBool</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">..</span><span class="n">rhs</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="kt">Bool</span><span class="o">...</span><span class="w"></span>

<span class="cm">{-# RULES &quot;f&quot; opBool True y = False #-}</span><span class="w"></span>
</pre></div>
</div>
<p>If you want a RULE that truly applies to the overloaded class method,
the only way to do it is like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">op_c</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="nf">op</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="cm">{-# NOINLINE [1] op #-}</span><span class="w"></span>
<span class="nf">op</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">op_c</span><span class="w"></span>

<span class="cm">{-# RULES &quot;reassociate&quot; op (op x y) z = op x (op y z) #-}</span><span class="w"></span>
</pre></div>
</div>
<p>Now the inlining of <code class="docutils literal notranslate"><span class="pre">op</span></code> is delayed until the rule has a chance to
fire. The down-side is that instance declarations must define <code class="docutils literal notranslate"><span class="pre">op_c</span></code>,
but all other uses should go via <code class="docutils literal notranslate"><span class="pre">op</span></code>.</p>
</section>
<section id="list-fusion">
<h2><span class="section-number">6.19.1.6. </span>List fusion<a class="headerlink" href="#list-fusion" title="Permalink to this heading">¶</a></h2>
<p>The RULES mechanism is used to implement fusion (deforestation) of
common list functions. If a “good consumer” consumes an intermediate
list constructed by a “good producer”, the intermediate list should be
eliminated entirely.</p>
<p>The following are good producers:</p>
<ul class="simple">
<li><p>List comprehensions</p></li>
<li><p>Enumerations of <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">Integer</span></code> and <code class="docutils literal notranslate"><span class="pre">Char</span></code> (e.g.
<code class="docutils literal notranslate"><span class="pre">['a'..'z']</span></code>).</p></li>
<li><p>Explicit lists (e.g. <code class="docutils literal notranslate"><span class="pre">[True,</span> <span class="pre">False]</span></code>)</p></li>
<li><p>The cons constructor (e.g <code class="docutils literal notranslate"><span class="pre">3:4:[]</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">++</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">map</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">take</span></code>, <code class="docutils literal notranslate"><span class="pre">filter</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iterate</span></code>, <code class="docutils literal notranslate"><span class="pre">repeat</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zip</span></code>, <code class="docutils literal notranslate"><span class="pre">zipWith</span></code></p></li>
</ul>
<p>The following are good consumers:</p>
<ul class="simple">
<li><p>List comprehensions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">array</span></code> (on its second argument)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">++</span></code> (on its first argument)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">foldr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">map</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">take</span></code>, <code class="docutils literal notranslate"><span class="pre">filter</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">concat</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unzip</span></code>, <code class="docutils literal notranslate"><span class="pre">unzip2</span></code>, <code class="docutils literal notranslate"><span class="pre">unzip3</span></code>, <code class="docutils literal notranslate"><span class="pre">unzip4</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zip</span></code>, <code class="docutils literal notranslate"><span class="pre">zipWith</span></code> (but on one argument only; if both are good
producers, <code class="docutils literal notranslate"><span class="pre">zip</span></code> will fuse with one but not the other)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">partition</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">head</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, <code class="docutils literal notranslate"><span class="pre">any</span></code>, <code class="docutils literal notranslate"><span class="pre">all</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sequence_</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msum</span></code></p></li>
</ul>
<p>So, for example, the following should generate no intermediate lists:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">array</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]]</span><span class="w"></span>
</pre></div>
</div>
<p>This list could readily be extended; if there are Prelude functions that
you use a lot which are not included, please tell us.</p>
<p>If you want to write your own good consumers or producers, look at the
Prelude definitions of the above functions to see how to do so.</p>
</section>
<section id="specialisation">
<span id="rule-spec"></span><h2><span class="section-number">6.19.1.7. </span>Specialisation<a class="headerlink" href="#specialisation" title="Permalink to this heading">¶</a></h2>
<p>Rewrite rules can be used to get the same effect as a feature present in
earlier versions of GHC. For example, suppose that:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">genericLookup</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Table</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w">   </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w">   </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">intLookup</span><span class="w">     </span><span class="ow">::</span><span class="w">          </span><span class="kt">Table</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">intLookup</span></code> is an implementation of <code class="docutils literal notranslate"><span class="pre">genericLookup</span></code> that works
very fast for keys of type <code class="docutils literal notranslate"><span class="pre">Int</span></code>. You might wish to tell GHC to use
<code class="docutils literal notranslate"><span class="pre">intLookup</span></code> instead of <code class="docutils literal notranslate"><span class="pre">genericLookup</span></code> whenever the latter was
called with type <code class="docutils literal notranslate"><span class="pre">Table</span> <span class="pre">Int</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>. It used to be possible to
write</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# SPECIALIZE genericLookup :: Table Int b -&gt; Int -&gt; b = intLookup #-}</span><span class="w"></span>
</pre></div>
</div>
<p>This feature is no longer in GHC, but rewrite rules let you do the same
thing:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# RULES &quot;genericLookup/Int&quot; genericLookup = intLookup #-}</span><span class="w"></span>
</pre></div>
</div>
<p>This slightly odd-looking rule instructs GHC to replace
<code class="docutils literal notranslate"><span class="pre">genericLookup</span></code> by <code class="docutils literal notranslate"><span class="pre">intLookup</span></code> <em>whenever the types match</em>. What is
more, this rule does not need to be in the same file as
<code class="docutils literal notranslate"><span class="pre">genericLookup</span></code>, unlike the <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> pragmas which currently do
(so that they have an original definition available to specialise).</p>
<p>It is <em>Your Responsibility</em> to make sure that <code class="docutils literal notranslate"><span class="pre">intLookup</span></code> really
behaves as a specialised version of <code class="docutils literal notranslate"><span class="pre">genericLookup</span></code>!!!</p>
<p>An example in which using <code class="docutils literal notranslate"><span class="pre">RULES</span></code> for specialisation will Win Big:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">toDouble</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Real</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span><span class="w"></span>
<span class="nf">toDouble</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fromRational</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">toRational</span><span class="w"></span>

<span class="cm">{-# RULES &quot;toDouble/Int&quot; toDouble = i2d #-}</span><span class="w"></span>
<span class="nf">i2d</span><span class="w"> </span><span class="p">(</span><span class="kt">I</span><span class="o">#</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">D</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="n">int2Double</span><span class="o">#</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="c1">-- uses Glasgow prim-op directly</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">i2d</span></code> function is virtually one machine instruction; the default
conversion—via an intermediate <code class="docutils literal notranslate"><span class="pre">Rational</span></code>-is obscenely expensive by
comparison.</p>
</section>
<section id="controlling-what-s-going-on-in-rewrite-rules">
<span id="controlling-rules"></span><h2><span class="section-number">6.19.1.8. </span>Controlling what’s going on in rewrite rules<a class="headerlink" href="#controlling-what-s-going-on-in-rewrite-rules" title="Permalink to this heading">¶</a></h2>
<ul>
<li><p>Use <a class="reference internal" href="../debugging.html#ghc-flag-ddump-rules"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-rules</span></code></a> to see the rules that are defined <em>in this
module</em>. This includes rules generated by the specialisation pass,
but excludes rules imported from other modules.</p></li>
<li><p>Use <a class="reference internal" href="../debugging.html#ghc-flag-ddump-simpl-stats"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-simpl-stats</span></code></a> to see what rules are being fired. If you
add <a class="reference internal" href="../debugging.html#ghc-flag-dppr-debug"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-dppr-debug</span></code></a> you get a more detailed listing.</p></li>
<li><p>Use <a class="reference internal" href="../debugging.html#ghc-flag-ddump-rule-firings"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-rule-firings</span></code></a> or <a class="reference internal" href="../debugging.html#ghc-flag-ddump-rule-rewrites"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-rule-rewrites</span></code></a> to see in
great detail what rules are being fired. If you add <a class="reference internal" href="../debugging.html#ghc-flag-dppr-debug"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-dppr-debug</span></code></a>
you get a still more detailed listing.</p></li>
<li><p>The definition of (say) <code class="docutils literal notranslate"><span class="pre">build</span></code> in <code class="docutils literal notranslate"><span class="pre">GHC/Base.hs</span></code> looks like
this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">build</span><span class="w">   </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="cm">{-# INLINE build #-}</span><span class="w"></span>
<span class="nf">build</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="p">(</span><span class="kt">:</span><span class="p">)</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
</pre></div>
</div>
<p>Notice the <a class="reference internal" href="pragmas.html#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a>! That prevents <code class="docutils literal notranslate"><span class="pre">(:)</span></code> from being inlined when
compiling <code class="docutils literal notranslate"><span class="pre">PrelBase</span></code>, so that an importing module will “see” the
<code class="docutils literal notranslate"><span class="pre">(:)</span></code>, and can match it on the LHS of a rule. <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> prevents
any inlining happening in the RHS of the <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> thing. I regret
the delicacy of this.</p>
</li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">libraries/base/GHC/Base.hs</span></code> look at the rules for <code class="docutils literal notranslate"><span class="pre">map</span></code> to
see how to write rules that will do fusion and yet give an efficient
program even if fusion doesn’t happen. More rules in
<code class="docutils literal notranslate"><span class="pre">GHC/List.hs</span></code>.</p></li>
</ul>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="special_builtin.html" class="btn btn-neutral float-right" title="6.19.2. Special built-in functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="misc.html" class="btn btn-neutral float-left" title="6.19. Miscellaneous" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
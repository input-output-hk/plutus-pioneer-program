

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.4.20. Roles &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.5. Records" href="records.html" />
    <link rel="prev" title="6.4.19. Deferring type errors to runtime" href="defer_type_errors.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="types.html">6.4. Types</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="nullary_types.html">6.4.1. Data types with no constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatype_contexts.html">6.4.2. Data type contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="infix_tycons.html">6.4.3. Infix type constructors, classes, and type variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_operators.html">6.4.4. Type operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="liberal_type_synonyms.html">6.4.5. Liberalised type synonyms</a></li>
<li class="toctree-l3"><a class="reference internal" href="existential_quantification.html">6.4.6. Existentially quantified data constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadt_syntax.html">6.4.7. Declaring data types with explicit constructor signatures</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadt.html">6.4.8. Generalised Algebraic Data Types (GADTs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_families.html">6.4.9. Type families</a></li>
<li class="toctree-l3"><a class="reference internal" href="data_kinds.html">6.4.10. Datatype promotion</a></li>
<li class="toctree-l3"><a class="reference internal" href="poly_kinds.html">6.4.11. Kind polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="levity_polymorphism.html">6.4.12. Levity polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_literals.html">6.4.13. Type-Level Literals</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_applications.html">6.4.14. Visible type application</a></li>
<li class="toctree-l3"><a class="reference internal" href="rank_polymorphism.html">6.4.15. Arbitrary-rank polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="impredicative_types.html">6.4.16. Impredicative polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="linear_types.html">6.4.17. Linear types</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_errors.html">6.4.18. Custom compile-time errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="defer_type_errors.html">6.4.19. Deferring type errors to runtime</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.4.20. Roles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#nominal-representational-and-phantom">6.4.20.1. Nominal, Representational, and Phantom</a></li>
<li class="toctree-l4"><a class="reference internal" href="#role-inference">6.4.20.2. Role inference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#role-annotations">6.4.20.3. Role annotations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="types.html"><span class="section-number">6.4. </span>Types</a> &raquo;</li>
        
      <li><span class="section-number">6.4.20. </span>Roles</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/roles.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="roles">
<span id="id1"></span><h1><span class="section-number">6.4.20. </span>Roles<a class="headerlink" href="#roles" title="Permalink to this heading">¶</a></h1>
<p id="index-0">Using <a class="reference internal" href="newtype_deriving.html#extension-GeneralizedNewtypeDeriving"><code class="xref std std-extension docutils literal notranslate"><span class="pre">GeneralizedNewtypeDeriving</span></code></a>
(<a class="reference internal" href="newtype_deriving.html#newtype-deriving"><span class="std std-ref">Generalised derived instances for newtypes</span></a>), a programmer can take existing
instances of classes and “lift” these into instances of that class for a
newtype. However, this is not always safe. For example, consider the
following:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">Age</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkAge</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">unAge</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">Inspect</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">Inspect</span><span class="w"> </span><span class="kt">Age</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">Inspect</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">BadIdea</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">bad</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Inspect</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">BadIdea</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">bad</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="kr">deriving</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">BadIdea</span><span class="w"> </span><span class="kt">Age</span><span class="w">    </span><span class="c1">-- not allowed!</span><span class="w"></span>
</pre></div>
</div>
<p>If the derived instance were allowed, what would the type of its method
<code class="docutils literal notranslate"><span class="pre">bad</span></code> be? It would seem to be <code class="docutils literal notranslate"><span class="pre">Age</span> <span class="pre">-&gt;</span> <span class="pre">Inspect</span> <span class="pre">Age</span></code>, which is
equivalent to <code class="docutils literal notranslate"><span class="pre">Age</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>, according to the type family <code class="docutils literal notranslate"><span class="pre">Inspect</span></code>.
Yet, if we simply adapt the implementation from the instance for
<code class="docutils literal notranslate"><span class="pre">Int</span></code>, the implementation for <code class="docutils literal notranslate"><span class="pre">bad</span></code> produces a <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, and we have
trouble.</p>
<p>The way to identify such situations is to have <em>roles</em> assigned to type
variables of datatypes, classes, and type synonyms.</p>
<p>Roles as implemented in GHC are a from a simplified version of the work
described in <a class="reference external" href="http://www.seas.upenn.edu/~sweirich/papers/popl163af-weirich.pdf">Generative type abstraction and type-level
computation</a>,
published at POPL 2011.</p>
<section id="nominal-representational-and-phantom">
<span id="id2"></span><h2><span class="section-number">6.4.20.1. </span>Nominal, Representational, and Phantom<a class="headerlink" href="#nominal-representational-and-phantom" title="Permalink to this heading">¶</a></h2>
<p id="index-1">The goal of the roles system is to track when two types have the same
underlying representation. In the example above, <code class="docutils literal notranslate"><span class="pre">Age</span></code> and <code class="docutils literal notranslate"><span class="pre">Int</span></code>
have the same representation. But, the corresponding instances of
<code class="docutils literal notranslate"><span class="pre">BadIdea</span></code> would <em>not</em> have the same representation, because the types
of the implementations of <code class="docutils literal notranslate"><span class="pre">bad</span></code> would be different.</p>
<p>Suppose we have two uses of a type constructor, each applied to the same
parameters except for one difference. (For example, <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">Age</span> <span class="pre">Bool</span> <span class="pre">c</span></code> and
<code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">Int</span> <span class="pre">Bool</span> <span class="pre">c</span></code> for some type <code class="docutils literal notranslate"><span class="pre">T</span></code>.) The role of a type parameter says
what we need to know about the two differing type arguments in order to
know that the two outer types have the same representation (in the
example, what must be true about <code class="docutils literal notranslate"><span class="pre">Age</span></code> and <code class="docutils literal notranslate"><span class="pre">Int</span></code> in order to show
that <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">Age</span> <span class="pre">Bool</span> <span class="pre">c</span></code> has the same representation as <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">Int</span> <span class="pre">Bool</span> <span class="pre">c</span></code>).</p>
<p>GHC supports three different roles for type parameters: nominal,
representational, and phantom. If a type parameter has a nominal role,
then the two types that differ must not actually differ at all: they
must be identical (after type family reduction). If a type parameter has
a representational role, then the two types must have the same
representation. (If <code class="docutils literal notranslate"><span class="pre">T</span></code>'s first parameter’s role is representational,
then <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">Age</span> <span class="pre">Bool</span> <span class="pre">c</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">Int</span> <span class="pre">Bool</span> <span class="pre">c</span></code> would have the same
representation, because <code class="docutils literal notranslate"><span class="pre">Age</span></code> and <code class="docutils literal notranslate"><span class="pre">Int</span></code> have the same
representation.) If a type parameter has a phantom role, then we need no
further information.</p>
<p>Here are some examples:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Simple</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkSimple</span><span class="w"> </span><span class="n">a</span><span class="w">          </span><span class="c1">-- a has role representational</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="kt">Age</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Char</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Complex</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkComplex</span><span class="w"> </span><span class="p">(</span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w">    </span><span class="c1">-- a has role nominal</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Phant</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkPhant</span><span class="w"> </span><span class="kt">Bool</span><span class="w">         </span><span class="c1">-- a has role phantom</span><span class="w"></span>
</pre></div>
</div>
<p>The type <code class="docutils literal notranslate"><span class="pre">Simple</span></code> has its parameter at role representational, which is
generally the most common case. <code class="docutils literal notranslate"><span class="pre">Simple</span> <span class="pre">Age</span></code> would have the same
representation as <code class="docutils literal notranslate"><span class="pre">Simple</span> <span class="pre">Int</span></code>. The type <code class="docutils literal notranslate"><span class="pre">Complex</span></code>, on the other
hand, has its parameter at role nominal, because <code class="docutils literal notranslate"><span class="pre">Complex</span> <span class="pre">Age</span></code> and
<code class="docutils literal notranslate"><span class="pre">Complex</span> <span class="pre">Int</span></code> are <em>not</em> the same. Lastly, <code class="docutils literal notranslate"><span class="pre">Phant</span> <span class="pre">Age</span></code> and
<code class="docutils literal notranslate"><span class="pre">Phant</span> <span class="pre">Bool</span></code> have the same representation, even though <code class="docutils literal notranslate"><span class="pre">Age</span></code> and
<code class="docutils literal notranslate"><span class="pre">Bool</span></code> are unrelated.</p>
</section>
<section id="role-inference">
<span id="id3"></span><h2><span class="section-number">6.4.20.2. </span>Role inference<a class="headerlink" href="#role-inference" title="Permalink to this heading">¶</a></h2>
<p>What role should a given type parameter should have? GHC performs role
inference to determine the correct role for every parameter. It starts
with a few base facts: <code class="docutils literal notranslate"><span class="pre">(-&gt;)</span></code> has two representational parameters;
<code class="docutils literal notranslate"><span class="pre">(~)</span></code> has two nominal parameters; all type families’ parameters are
nominal; and all GADT-like parameters are nominal. Then, these facts are
propagated to all places where these types are used. The default role
for datatypes and synonyms is phantom; the default role for classes is
nominal. Thus, for datatypes and synonyms, any parameters unused in the
right-hand side (or used only in other types in phantom positions) will
be phantom. Whenever a parameter is used in a representational position
(that is, used as a type argument to a constructor whose corresponding
variable is at role representational), we raise its role from phantom to
representational. Similarly, when a parameter is used in a nominal
position, its role is upgraded to nominal. We never downgrade a role
from nominal to phantom or representational, or from representational to
phantom. In this way, we infer the most-general role for each parameter.</p>
<p>Classes have their roles default to nominal to promote coherence of
class instances. If a <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">Int</span></code> were stored in a datatype, it would be
quite bad if that were somehow changed into a <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">Age</span></code> somewhere,
especially if another <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">Age</span></code> had been declared!</p>
<p>There is one particularly tricky case that should be explained:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Tricky</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkTricky</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>What should <code class="docutils literal notranslate"><span class="pre">Tricky</span></code>’s roles be? At first blush, it would seem that
both <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> should be at role representational, since both are
used in the right-hand side and neither is involved in a type family.
However, this would be wrong, as the following example shows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Nom</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkNom</span><span class="w"> </span><span class="p">(</span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w">   </span><span class="c1">-- type family F from example above</span><span class="w"></span>
</pre></div>
</div>
<p>Is <code class="docutils literal notranslate"><span class="pre">Tricky</span> <span class="pre">Nom</span> <span class="pre">Age</span></code> representationally equal to <code class="docutils literal notranslate"><span class="pre">Tricky</span> <span class="pre">Nom</span> <span class="pre">Int</span></code>?
No! The former stores a <code class="docutils literal notranslate"><span class="pre">Char</span></code> and the latter stores a <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. The
solution to this is to require all parameters to type variables to have
role nominal. Thus, GHC would infer role representational for <code class="docutils literal notranslate"><span class="pre">a</span></code> but
role nominal for <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</section>
<section id="role-annotations">
<span id="id4"></span><h2><span class="section-number">6.4.20.3. </span>Role annotations<a class="headerlink" href="#role-annotations" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-RoleAnnotations">
<span id="ghc-flag--XRoleAnnotations"></span><span id="extension-NoRoleAnnotations"></span><span class="sig-name descname"><span class="pre">RoleAnnotations</span></span><a class="headerlink" href="#extension-RoleAnnotations" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.8.1</p>
</dd>
</dl>
<p>Allow role annotation syntax.</p>
</dd></dl>

<p>Sometimes the programmer wants to constrain the inference process. For
example, the base library contains the following definition:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Ptr</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Ptr</span><span class="w"> </span><span class="kt">Addr</span><span class="o">#</span><span class="w"></span>
</pre></div>
</div>
<p>The idea is that <code class="docutils literal notranslate"><span class="pre">a</span></code> should really be a representational parameter,
but role inference assigns it to phantom. This makes some level of
sense: a pointer to an <code class="docutils literal notranslate"><span class="pre">Int</span></code> really is representationally the same as
a pointer to a <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. But, that’s not at all how we want to use
<code class="docutils literal notranslate"><span class="pre">Ptr</span></code>s! So, we want to be able to say</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="kt">Ptr</span><span class="w"> </span><span class="n">representational</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Ptr</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Ptr</span><span class="w"> </span><span class="kt">Addr</span><span class="o">#</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">role</span></code> (enabled with <a class="reference internal" href="#extension-RoleAnnotations"><code class="xref std std-extension docutils literal notranslate"><span class="pre">RoleAnnotations</span></code></a>) declaration
forces the parameter <code class="docutils literal notranslate"><span class="pre">a</span></code> to be at role representational, not role
phantom. GHC then checks the user-supplied roles to make sure they don’t
break any promises. It would be bad, for example, if the user could make
<code class="docutils literal notranslate"><span class="pre">BadIdea</span></code>'s role be representational.</p>
<p>As another example, we can consider a type <code class="docutils literal notranslate"><span class="pre">Set</span> <span class="pre">a</span></code> that represents a
set of data, ordered according to <code class="docutils literal notranslate"><span class="pre">a</span></code>'s <code class="docutils literal notranslate"><span class="pre">Ord</span></code> instance. While it
would generally be type-safe to consider <code class="docutils literal notranslate"><span class="pre">a</span></code> to be at role
representational, it is possible that a <code class="docutils literal notranslate"><span class="pre">newtype</span></code> and its base type
have <em>different</em> orderings encoded in their respective <code class="docutils literal notranslate"><span class="pre">Ord</span></code>
instances. This would lead to misbehavior at runtime. So, the author of
the <code class="docutils literal notranslate"><span class="pre">Set</span></code> datatype would like its parameter to be at role nominal.
This would be done with a declaration</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="n">nominal</span><span class="w"></span>
</pre></div>
</div>
<p>Role annotations can also be used should a programmer wish to write a
class with a representational (or phantom) role. However, as a class
with non-nominal roles can quickly lead to class instance incoherence,
it is necessary to also specify <a class="reference internal" href="instances.html#extension-IncoherentInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">IncoherentInstances</span></code></a> to allow
non-nominal roles for classes.</p>
<p>The other place where role annotations may be necessary are in
<code class="docutils literal notranslate"><span class="pre">hs-boot</span></code> files (<a class="reference internal" href="../separate_compilation.html#mutual-recursion"><span class="std std-ref">How to compile mutually recursive modules</span></a>), where the right-hand sides
of definitions can be omitted. As usual, the types/classes declared in
an <code class="docutils literal notranslate"><span class="pre">hs-boot</span></code> file must match up with the definitions in the <code class="docutils literal notranslate"><span class="pre">hs</span></code>
file, including down to the roles. The default role for datatypes is
representational in <code class="docutils literal notranslate"><span class="pre">hs-boot</span></code> files, corresponding to the common use
case.</p>
<p>Role annotations are allowed on data, newtype, and class declarations. A
role annotation declaration starts with <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">role</span></code> and is followed by
one role listing for each parameter of the type. (This parameter count
includes parameters implicitly specified by a kind signature in a
GADT-style data or newtype declaration.) Each role listing is a role
(<code class="docutils literal notranslate"><span class="pre">nominal</span></code>, <code class="docutils literal notranslate"><span class="pre">representational</span></code>, or <code class="docutils literal notranslate"><span class="pre">phantom</span></code>) or a <code class="docutils literal notranslate"><span class="pre">_</span></code>. Using a
<code class="docutils literal notranslate"><span class="pre">_</span></code> says that GHC should infer that role. The role annotation may go
anywhere in the same module as the datatype or class definition (much
like a value-level type signature). Here are some examples:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">phantom</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT1</span><span class="w"> </span><span class="n">a</span><span class="w">     </span><span class="c1">-- b is not used; annotation is fine but unnecessary</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">phantom</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT2</span><span class="w"> </span><span class="n">b</span><span class="w">     </span><span class="c1">-- ERROR: b is used and cannot be phantom</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="kt">T3</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">nominal</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T3</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT3</span><span class="w"> </span><span class="n">a</span><span class="w">     </span><span class="c1">-- OK: nominal is higher than necessary, but safe</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="kt">T4</span><span class="w"> </span><span class="n">nominal</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T4</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT4</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="c1">-- OK, but nominal is higher than necessary</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">representational</span><span class="w"> </span><span class="kr">_</span><span class="w">   </span><span class="c1">-- OK, with -XIncoherentInstances</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w">    </span><span class="c1">-- OK, b will get a nominal role</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="n">nominal</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w">           </span><span class="c1">-- ERROR: role annotations not allowed for type synonyms</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="records.html" class="btn btn-neutral float-right" title="6.5. Records" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="defer_type_errors.html" class="btn btn-neutral float-left" title="6.4.19. Deferring type errors to runtime" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
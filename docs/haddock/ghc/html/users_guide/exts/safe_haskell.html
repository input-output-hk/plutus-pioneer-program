

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.18. Safe Haskell &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.19. Miscellaneous" href="misc.html" />
    <link rel="prev" title="6.17. Foreign function interface (FFI)" href="ffi.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6.18. Safe Haskell</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#uses-of-safe-haskell">6.18.1. Uses of Safe Haskell</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#strict-type-safety-good-style">6.18.1.1. Strict type-safety (good style)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#building-secure-systems-restricted-io-monads">6.18.1.2. Building secure systems (restricted IO Monads)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#safe-language">6.18.2. Safe Language</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#safe-overlapping-instances">6.18.2.1. Safe Overlapping Instances</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#safe-imports">6.18.3. Safe Imports</a></li>
<li class="toctree-l3"><a class="reference internal" href="#trust-and-safe-haskell-modes">6.18.4. Trust and Safe Haskell Modes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#trust-check-fpackage-trust-disabled">6.18.4.1. Trust check (<code class="docutils literal notranslate"><span class="pre">-fpackage-trust</span></code> disabled)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#trust-check-fpackage-trust-enabled">6.18.4.2. Trust check (<code class="docutils literal notranslate"><span class="pre">-fpackage-trust</span></code> enabled)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example">6.18.4.3. Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#trustworthy-requirements">6.18.4.4. Trustworthy Requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#package-trust">6.18.4.5. Package Trust</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#safe-haskell-inference">6.18.5. Safe Haskell Inference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#safe-haskell-flag-summary">6.18.6. Safe Haskell Flag Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="#safe-compilation">6.18.7. Safe Compilation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
      <li><span class="section-number">6.18. </span>Safe Haskell</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/safe_haskell.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="safe-haskell">
<span id="id1"></span><h1><span class="section-number">6.18. </span>Safe Haskell<a class="headerlink" href="#safe-haskell" title="Permalink to this heading">¶</a></h1>
<p id="index-0">Safe Haskell is an extension to the Haskell language that is implemented
in GHC as of version 7.2. It allows for unsafe code to be securely
included in a trusted code base by restricting the features of GHC
Haskell the code is allowed to use. Put simply, it makes the types of
programs trustable.</p>
<p>While a primary use case of Safe Haskell is running untrusted code, Safe
Haskell doesn’t provide this directly. Instead, Safe Haskell provides
strict type safety. Without Safe Haskell, GHC allows many exceptions to
the type system which can subvert any abstractions. By providing strict
type safety, Safe Haskell enables developers to build their own library
level sandbox mechanisms to run untrusted code.</p>
<p>While Safe Haskell is an extension, it actually runs in the background
for every compilation with GHC. It does this to track the type
violations of modules to infer their safety, even when they aren’t
explicitly using Safe Haskell. Please refer to section
<a class="reference internal" href="#safe-inference"><span class="std std-ref">Safe Haskell Inference</span></a> for more details of this.</p>
<p>The design of Safe Haskell covers the following aspects:</p>
<ul class="simple">
<li><p>A <a class="reference internal" href="#safe-language"><span class="std std-ref">safe language</span></a> dialect of Haskell that provides
stricter guarantees about the code. It allows types and module boundaries to
be trusted.</p></li>
<li><p>A <em>safe import</em> extension that specifies that the module being imported must
be trusted.</p></li>
<li><p>A definition of <em>trust</em> (or safety) and how it operates, along with ways of
defining and changing the trust of modules and packages.</p></li>
</ul>
<p>Safe Haskell, however, <em>does not offer</em> compilation safety. During
compilation time it is possible for arbitrary processes to be launched,
using for example the <a class="reference internal" href="../phases.html#pre-processor"><span class="std std-ref">custom pre-processor</span></a> flag.
This can be manipulated to either compromise a user’s system at
compilation time, or to modify the source code just before compilation
to try to alter Safe Haskell flags. This is discussed further in section
<a class="reference internal" href="#safe-compilation"><span class="std std-ref">Safe Compilation</span></a>.</p>
<section id="uses-of-safe-haskell">
<span id="safe-use-cases"></span><h2><span class="section-number">6.18.1. </span>Uses of Safe Haskell<a class="headerlink" href="#uses-of-safe-haskell" title="Permalink to this heading">¶</a></h2>
<p id="index-1">Safe Haskell has been designed with two use cases in mind:</p>
<ul class="simple">
<li><p>Enforcing strict type safety at compile time</p></li>
<li><p>Compiling and executing untrusted code</p></li>
</ul>
<section id="strict-type-safety-good-style">
<h3><span class="section-number">6.18.1.1. </span>Strict type-safety (good style)<a class="headerlink" href="#strict-type-safety-good-style" title="Permalink to this heading">¶</a></h3>
<p>Haskell offers a powerful type system and separation of pure and effectual
functions through the <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad. However, there are several loop holes in the
type system, the most obvious being the <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span> <span class="pre">::</span> <span class="pre">IO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>
function. The safe language dialect of Safe Haskell disallows the use of such
functions. This can be useful restriction as it makes Haskell code easier to
analyse and reason about. It also codifies the existing culture in the Haskell
community of trying to avoid unsafe functions unless absolutely necessary. As
such, using the safe language (through the <code class="docutils literal notranslate"><span class="pre">-XSafe</span></code> flag) can be thought of as
a way of enforcing good style, similar to the function of <code class="docutils literal notranslate"><span class="pre">-Wall</span></code>.</p>
</section>
<section id="building-secure-systems-restricted-io-monads">
<h3><span class="section-number">6.18.1.2. </span>Building secure systems (restricted IO Monads)<a class="headerlink" href="#building-secure-systems-restricted-io-monads" title="Permalink to this heading">¶</a></h3>
<p id="index-2">Systems such as information flow control security, capability based
security systems and DSLs for working with encrypted data.. etc can be
built in the Haskell language as a library. However they require
guarantees about the properties of Haskell that aren’t true in general
due to the presence of functions like <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code>. Safe Haskell
gives users enough guarantees about the type system to allow them to
build such secure systems.</p>
<p>As an example, let’s define an interface for a plugin system where the
plugin authors are untrusted, possibly malicious third-parties. We do
this by restricting the plugin interface to pure functions or to a
restricted <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad that we have defined. The restricted <code class="docutils literal notranslate"><span class="pre">IO</span></code>
monad will only allow a safe subset of <code class="docutils literal notranslate"><span class="pre">IO</span></code> actions to be executed. We
define the plugin interface so that it requires the plugin module,
<code class="docutils literal notranslate"><span class="pre">Danger</span></code>, to export a single computation, <code class="docutils literal notranslate"><span class="pre">Danger.runMe</span></code>, of type
<code class="docutils literal notranslate"><span class="pre">RIO</span> <span class="pre">()</span></code>, where <code class="docutils literal notranslate"><span class="pre">RIO</span></code> is a monad defined as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- While we use `Safe&#39;, the `Trustworthy&#39; pragma would also be</span><span class="w"></span>
<span class="c1">-- fine. We simply want to ensure that:</span><span class="w"></span>
<span class="c1">-- 1) The module exports an interface that untrusted code can&#39;t</span><span class="w"></span>
<span class="c1">--    abuse.</span><span class="w"></span>
<span class="c1">-- 2) Untrusted code can import this module.</span><span class="w"></span>
<span class="c1">--</span><span class="w"></span>
<span class="cm">{-# LANGUAGE Safe #-}</span><span class="w"></span>

<span class="kr">module</span><span class="w"> </span><span class="nn">RIO</span><span class="w"> </span><span class="p">(</span><span class="kt">RIO</span><span class="p">(),</span><span class="w"> </span><span class="nf">runRIO</span><span class="p">,</span><span class="w"> </span><span class="nf">rioReadFile</span><span class="p">,</span><span class="w"> </span><span class="nf">rioWriteFile</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="c1">-- Notice that symbol UnsafeRIO is not exported from this module!</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">RIO</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">UnsafeRIO</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">runRIO</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="kt">RIO</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">return</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">UnsafeRIO</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">return</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="kt">UnsafeRIO</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">UnsafeRIO</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">runRIO</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"></span>

<span class="c1">-- Returns True iff access is allowed to file name</span><span class="w"></span>
<span class="nf">pathOK</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">pathOK</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="cm">{- Implement some policy based on file name -}</span><span class="w"></span>

<span class="nf">rioReadFile</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">RIO</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">rioReadFile</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">UnsafeRIO</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">ok</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">pathOK</span><span class="w"> </span><span class="n">file</span><span class="w"></span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="n">ok</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">readFile</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"></span>

<span class="nf">rioWriteFile</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">RIO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">rioWriteFile</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">UnsafeRIO</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">ok</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">pathOK</span><span class="w"> </span><span class="n">file</span><span class="w"></span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="n">ok</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">writeFile</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
</pre></div>
</div>
<p>We then compile the <code class="docutils literal notranslate"><span class="pre">Danger</span></code> plugin using the new Safe Haskell
<code class="docutils literal notranslate"><span class="pre">-XSafe</span></code> flag:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE Safe #-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">Danger</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nf">runMe</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="nf">runMe</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">RIO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">runMe</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Before going into the Safe Haskell details, let’s point out some of the
reasons this security mechanism would fail without Safe Haskell:</p>
<ul class="simple">
<li><p>The design attempts to restrict the operations that <code class="docutils literal notranslate"><span class="pre">Danger</span></code> can perform by
using types, specifically the <code class="docutils literal notranslate"><span class="pre">RIO</span></code> type wrapper around <code class="docutils literal notranslate"><span class="pre">IO</span></code> . The author
of <code class="docutils literal notranslate"><span class="pre">Danger</span></code> can subvert this though by simply writing arbitrary <code class="docutils literal notranslate"><span class="pre">IO</span></code>
actions and using <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span> <span class="pre">::</span> <span class="pre">IO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> to execute them as pure
functions.</p></li>
<li><p>The design also relies on <code class="docutils literal notranslate"><span class="pre">Danger</span></code> not being able to access the
<code class="docutils literal notranslate"><span class="pre">UnsafeRIO</span></code> constructor. Unfortunately Template Haskell can be used to
subvert module boundaries and so could be used to gain access to this
constructor.</p></li>
<li><p>There is no way to place restrictions on the modules that <code class="docutils literal notranslate"><span class="pre">Danger</span></code> can
import. This gives the author of <code class="docutils literal notranslate"><span class="pre">Danger</span></code> a very large attack surface,
essentially any package currently installed on the system. Should any of
these packages have a vulnerability, then the <code class="docutils literal notranslate"><span class="pre">Danger</span></code> module can exploit
it.</p></li>
</ul>
<p>Safe Haskell prevents all these attacks. This is done by compiling the
RIO module with the <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a> or <a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a> flag and compiling
<code class="docutils literal notranslate"><span class="pre">Danger</span></code> with the <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a> flag. We explain each below.</p>
<p>The use of <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a> to compile <code class="docutils literal notranslate"><span class="pre">Danger</span></code> restricts the features of
Haskell that can be used to a <a class="reference external" href="#safe-language">safe subset</a>. This
includes disallowing <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code>, Template Haskell, pure FFI
functions, RULES and restricting the operation of Overlapping Instances.
The <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a> flag also restricts the modules can be imported by
<code class="docutils literal notranslate"><span class="pre">Danger</span></code> to only those that are considered trusted. Trusted modules
are those compiled with <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a>, where GHC provides a mechanical
guarantee that the code is safe. Or those modules compiled with
<a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a>, where the module author claims that the module is
Safe.</p>
<p>This is why the RIO module is compiled with <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a> or
<a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a>&gt;, to allow the <code class="docutils literal notranslate"><span class="pre">Danger</span></code> module to import it. The
<a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a> flag doesn’t place any restrictions on the module like
<a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a> does (expect to restrict overlapping instances to <a class="reference external" href="#safe-overlapping-instances">safe
overlapping instances</a>). Instead the
module author claims that while code may use unsafe features internally,
it only exposes an API that can used in a safe manner.</p>
<p>However, the unrestricted use of <a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a> is a problem as an
arbitrary module can use it to mark themselves as trusted, yet
<a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a> doesn’t offer any guarantees about the module, unlike
<a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a>. To control the use of trustworthy modules it is recommended
to use the <a class="reference internal" href="#ghc-flag-fpackage-trust"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fpackage-trust</span></code></a> flag. This flag adds an extra requirement
to the trust check for trustworthy modules. It requires that for a
trustworthy modules to be considered trusted, and allowed to be used in
<a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a> compiled code, the client C compiling the code must tell GHC
that they trust the package the trustworthy module resides in. This is
essentially a way of for C to say, while this package contains
trustworthy modules that can be used by untrusted modules compiled with
<a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a>, I trust the author(s) of this package and trust the modules
only expose a safe API. The trust of a package can be changed at any
time, so if a vulnerability found in a package, C can declare that
package untrusted so that any future compilation against that package
would fail. For a more detailed overview of this mechanism see
<a class="reference internal" href="#safe-trust"><span class="std std-ref">Trust and Safe Haskell Modes</span></a>.</p>
<p>In the example, <code class="docutils literal notranslate"><span class="pre">Danger</span></code> can import module <code class="docutils literal notranslate"><span class="pre">RIO</span></code> because <code class="docutils literal notranslate"><span class="pre">RIO</span></code> is
compiled with <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a>. Thus, <code class="docutils literal notranslate"><span class="pre">Danger</span></code> can make use of the
<code class="docutils literal notranslate"><span class="pre">rioReadFile</span></code> and <code class="docutils literal notranslate"><span class="pre">rioWriteFile</span></code> functions to access permitted file
names. The main application then imports both <code class="docutils literal notranslate"><span class="pre">RIO</span></code> and <code class="docutils literal notranslate"><span class="pre">Danger</span></code>. To
run the plugin, it calls <code class="docutils literal notranslate"><span class="pre">RIO.runRIO</span> <span class="pre">Danger.runMe</span></code> within the <code class="docutils literal notranslate"><span class="pre">IO</span></code>
monad. The application is safe in the knowledge that the only <code class="docutils literal notranslate"><span class="pre">IO</span></code> to
ensue will be to files whose paths were approved by the <code class="docutils literal notranslate"><span class="pre">pathOK</span></code> test.</p>
<p>The Safe Haskell checks can be disabled for a module by passing the
<a class="reference internal" href="#ghc-flag-fno-safe-haskell"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fno-safe-haskell</span></code></a> flag. This is useful in particular when compiling
with source plugins as running a plugin marks the module as unsafe and can then
cause downstream modules to fail the safety checks.</p>
</section>
</section>
<section id="safe-language">
<span id="id2"></span><h2><span class="section-number">6.18.2. </span>Safe Language<a class="headerlink" href="#safe-language" title="Permalink to this heading">¶</a></h2>
<p id="index-3">The Safe Haskell <em>safe language</em> (enabled by <code class="docutils literal notranslate"><span class="pre">-XSafe</span></code>) guarantees the
following properties:</p>
<ul class="simple">
<li><p><em>Referential transparency</em> — The types can be trusted. Any pure function, is
guaranteed to be pure. Evaluating them is deterministic and won’t cause any
side effects. Functions in the <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad are still allowed and behave as
usual. So, for example, the <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span> <span class="pre">::</span> <span class="pre">IO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> function is
disallowed in the safe language to enforce this property.</p></li>
<li><p><em>Module boundary control</em> — Only symbols that are publicly available through
other module export lists can be accessed in the safe language. Values using
data constructors not exported by the defining module, cannot be examined or
created. As such, if a module <code class="docutils literal notranslate"><span class="pre">M</span></code> establishes some invariants through
careful use of its export list, then code written in the safe language that
imports <code class="docutils literal notranslate"><span class="pre">M</span></code> is guaranteed to respect those invariants.</p></li>
<li><p><em>Semantic consistency</em> — For any module that imports a module written in the
safe language, expressions that compile both with and without the safe import
have the same meaning in both cases. That is, importing a module written in
the safe language cannot change the meaning of existing code that isn’t
dependent on that module. So, for example, there are some restrictions placed
on the use of <a class="reference internal" href="instances.html#instance-overlap"><span class="std std-ref">OverlappingInstances</span></a>, as these can
violate this property.</p></li>
<li><p><em>Strict subset</em> — The safe language is strictly a subset of Haskell as
implemented by GHC. Any expression that compiles in the safe language has the
same meaning as it does when compiled in normal Haskell.</p></li>
</ul>
<p>These four properties guarantee that in the safe language you can trust
the types, can trust that module export lists are respected, and can
trust that code that successfully compiles has the same meaning as it
normally would.</p>
<p>To achieve these properties, in the safe language dialect we disable
completely the following features:</p>
<ul class="simple">
<li><p><a class="reference internal" href="template_haskell.html#extension-TemplateHaskell"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TemplateHaskell</span></code></a> — Can be used to gain access to constructors and
abstract data types that weren’t exported by a module, subverting module
boundaries.</p></li>
</ul>
<p>Furthermore, we restrict the following features:</p>
<ul>
<li><p><a class="reference internal" href="ffi.html#extension-ForeignFunctionInterface"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ForeignFunctionInterface</span></code></a> — Foreign import declarations that
import a function with a non-<code class="docutils literal notranslate"><span class="pre">IO</span></code> type are disallowed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RULES</span></code> — Rewrite rules defined in a module M compiled with
<a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a> are dropped. Rules defined in Trustworthy modules that
<code class="docutils literal notranslate"><span class="pre">M</span></code> imports are still valid and will fire as usual.</p></li>
<li><p><a class="reference internal" href="instances.html#extension-OverlappingInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">OverlappingInstances</span></code></a> — There is no restriction on the creation
of overlapping instances, but we do restrict their use at a particular call
site. This is a detailed restriction, please refer to <a class="reference internal" href="#safe-overlapping-instances"><span class="std std-ref">Safe Overlapping
Instances</span></a> for details.</p></li>
<li><p><a class="reference internal" href="newtype_deriving.html#extension-GeneralisedNewtypeDeriving"><code class="xref std std-extension docutils literal notranslate"><span class="pre">GeneralisedNewtypeDeriving</span></code></a> — GND is not allowed in the safe
language. This is due to the ability of it to violate module boundaries when
module authors forget to put nominal role annotations on their types as
appropriate. For this reason, the <code class="docutils literal notranslate"><span class="pre">Data.Coerce</span></code> module is also considered
unsafe. We are hoping to find a better solution here in the future.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GHC.Generics</span></code> — Hand crafted instances of the <code class="docutils literal notranslate"><span class="pre">Generic</span></code> type class are
not allowed in Safe Haskell. Such instances aren’t strictly unsafe, but
there is an important invariant that a <code class="docutils literal notranslate"><span class="pre">Generic</span></code> instance should adhere to
the structure of the data type for which the instance is defined, and
allowing manually implemented <code class="docutils literal notranslate"><span class="pre">Generic</span></code> instances would break that
invariant. Derived instances (through the <a class="reference internal" href="generics.html#extension-DeriveGeneric"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DeriveGeneric</span></code></a>
extension) are still allowed. Note that the only allowed
<a class="reference internal" href="deriving_strategies.html#deriving-strategies"><span class="std std-ref">deriving strategy</span></a> for deriving <code class="docutils literal notranslate"><span class="pre">Generic</span></code> under
Safe Haskell is <code class="docutils literal notranslate"><span class="pre">stock</span></code>, as another strategy (e.g., <code class="docutils literal notranslate"><span class="pre">anyclass</span></code>) would
produce an instance that violates the invariant.</p>
<p>Refer to the
<a class="reference internal" href="generics.html#generic-programming"><span class="std std-ref">generic programming</span></a> section for more details.</p>
</li>
</ul>
<section id="safe-overlapping-instances">
<span id="id3"></span><h3><span class="section-number">6.18.2.1. </span>Safe Overlapping Instances<a class="headerlink" href="#safe-overlapping-instances" title="Permalink to this heading">¶</a></h3>
<p>Due to the semantic consistency guarantee of Safe Haskell, we must
restrict the function of overlapping instances. We don’t restrict their
ability to be defined, as this is a global property and not something we
can determine by looking at a single module. Instead, when a module
calls a function belonging to a type-class, we check that the instance
resolution done is considered ‘safe’. This check is enforced for modules
compiled with both <code class="docutils literal notranslate"><span class="pre">-XSafe</span></code> and <code class="docutils literal notranslate"><span class="pre">-XTrustworthy</span></code>.</p>
<p>More specifically, consider the following modules:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE Safe #-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">Class</span><span class="w"> </span><span class="p">(</span><span class="kt">TC</span><span class="p">(</span><span class="o">..</span><span class="p">))</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">class</span><span class="w"> </span><span class="kt">TC</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="cm">{-# LANGUAGE Safe #-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">Dangerous</span><span class="w"> </span><span class="p">(</span><span class="kt">TC</span><span class="p">(</span><span class="o">..</span><span class="p">))</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">import</span><span class="w"> </span><span class="nn">Class</span><span class="w"></span>

<span class="w">  </span><span class="kr">instance</span><span class="w"></span>
<span class="w">    </span><span class="cm">{-# OVERLAPS #-}</span><span class="w"></span>
<span class="w">    </span><span class="kt">TC</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;[Int]&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="cm">{-# LANGUAGE Safe #-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">TCB_Runner</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">import</span><span class="w"> </span><span class="nn">Class</span><span class="w"></span>
<span class="w">  </span><span class="kr">import</span><span class="w"> </span><span class="nn">Dangerous</span><span class="w"></span>

<span class="w">  </span><span class="kr">instance</span><span class="w"></span>
<span class="w">    </span><span class="kt">TC</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;[a]&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">])</span><span class="w"></span>
</pre></div>
</div>
<p>Both module <code class="docutils literal notranslate"><span class="pre">Class</span></code> and module <code class="docutils literal notranslate"><span class="pre">Dangerous</span></code> will compile under <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a>
without issue. However, in module <code class="docutils literal notranslate"><span class="pre">TCB_Runner</span></code>, we must check if the call
to <code class="docutils literal notranslate"><span class="pre">op</span></code> in function <code class="docutils literal notranslate"><span class="pre">f</span></code> is safe.</p>
<p>What does it mean to be Safe? That importing a module compiled with
<a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a> shouldn’t change the meaning of code that compiles fine
without importing the module. This is the Safe Haskell property known as
<em>semantic consistency</em>.</p>
<p>In our situation, module <code class="docutils literal notranslate"><span class="pre">TCB_Runner</span></code> compiles fine without importing
module <code class="docutils literal notranslate"><span class="pre">Dangerous</span></code>. So when deciding which instance to use for the call to
<code class="docutils literal notranslate"><span class="pre">op</span></code>, if we determine the instance <code class="docutils literal notranslate"><span class="pre">TC</span> <span class="pre">[Int]</span></code> from module Dangerous
is the most specific, this is unsafe. This prevents code written by
third-parties we don’t trust (which is compiled using <code class="docutils literal notranslate"><span class="pre">-XSafe</span></code> in Safe
Haskell) from changing the behaviour of our existing code.</p>
<p>Specifically, we apply the following rule to determine if a type-class
method call is <em>unsafe</em> when overlapping instances are involved:</p>
<ul class="simple">
<li><p>Most specific instance, <code class="docutils literal notranslate"><span class="pre">Ix</span></code>, defined in an <code class="docutils literal notranslate"><span class="pre">-XSafe</span></code> compiled module.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Ix</span></code> is an orphan instance or a multi-parameter-type-class.</p></li>
<li><p>At least one overlapped instance, <code class="docutils literal notranslate"><span class="pre">Iy</span></code>, is both:</p>
<ul>
<li><p>From a different module than <code class="docutils literal notranslate"><span class="pre">Ix</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Iy</span></code> is not marked <code class="docutils literal notranslate"><span class="pre">OVERLAPPABLE</span></code></p></li>
</ul>
</li>
</ul>
<p>This is a slightly involved heuristic, but captures the situation of an
imported module <code class="docutils literal notranslate"><span class="pre">N</span></code> changing the behaviour of existing code. For example,
if the second condition isn’t violated, then the module author <code class="docutils literal notranslate"><span class="pre">M</span></code> must
depend either on a type-class or type defined in <code class="docutils literal notranslate"><span class="pre">N</span></code>.</p>
<p>When a particular type-class method call is considered unsafe due to
overlapping instances, and the module being compiled is using <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a>
or <a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a>, then compilation will fail. For <a class="reference internal" href="#extension-Unsafe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Unsafe</span></code></a>, no
restriction is applied, and for modules using safe inference, they will
be inferred unsafe.</p>
</section>
</section>
<section id="safe-imports">
<span id="id4"></span><h2><span class="section-number">6.18.3. </span>Safe Imports<a class="headerlink" href="#safe-imports" title="Permalink to this heading">¶</a></h2>
<p id="index-4">Safe Haskell enables a small extension to the usual import syntax of
Haskell, adding a <code class="docutils literal notranslate"><span class="pre">safe</span></code> keyword:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>impdecl -&gt; import [safe] [qualified] modid [as modid] [impspec]
</pre></div>
</div>
<p>When used, the module being imported with the safe keyword must be a
trusted module, otherwise a compilation error will occur. The safe
import extension is enabled by either of the <code class="docutils literal notranslate"><span class="pre">-XSafe</span></code> , <code class="docutils literal notranslate"><span class="pre">-XTrustworthy</span></code> , or
<code class="docutils literal notranslate"><span class="pre">-XUnsafe</span></code> flags. When the <code class="docutils literal notranslate"><span class="pre">-XSafe</span></code> flag is used, the <code class="docutils literal notranslate"><span class="pre">safe</span></code> keyword is
allowed but meaningless, as every import is treated as a safe import.</p>
</section>
<section id="trust-and-safe-haskell-modes">
<span id="safe-trust"></span><h2><span class="section-number">6.18.4. </span>Trust and Safe Haskell Modes<a class="headerlink" href="#trust-and-safe-haskell-modes" title="Permalink to this heading">¶</a></h2>
<p id="index-5">Safe Haskell introduces the following three language flags:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a> — Enables the safe language dialect, asking GHC to guarantee trust.
The safe language dialect requires that all imports be trusted or a
compilation error will occur. Safe Haskell will also infer this safety type
for modules automatically when possible. Please refer to section
<a class="reference internal" href="#safe-inference"><span class="std std-ref">Safe Haskell Inference</span></a> for more details of this.</p></li>
<li><p><a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a> — Means that while this module may invoke unsafe functions
internally, the module’s author claims that it exports an API that can’t be
used in an unsafe way. This doesn’t enable the safe language. It does however
restrict the resolution of overlapping instances to only allow <a class="reference internal" href="#safe-overlapping-instances"><span class="std std-ref">safe
overlapping instances</span></a>. The trust guarantee is
provided by the module author, not GHC. An import statement with the <code class="docutils literal notranslate"><span class="pre">safe</span></code>
keyword results in a compilation error if the imported module is not trusted.
An import statement without the keyword behaves as usual and can import any
module whether trusted or not.</p></li>
<li><p><a class="reference internal" href="#extension-Unsafe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Unsafe</span></code></a> — Marks the module being compiled as unsafe so that modules
compiled using <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a> can’t import it. You may want to explicitly mark a
module unsafe when it exports internal constructors that can be used to
violate invariants.</p></li>
</ul>
<p>While these are flags, they also correspond to Safe Haskell module types
that a module can have. You can think of using these as declaring an
explicit contract (or type) that a module must have. If it is invalid,
then compilation will fail. GHC will also infer the correct type for
Safe Haskell, please refer to section <a class="reference internal" href="#safe-inference"><span class="std std-ref">Safe Haskell Inference</span></a> for more
details.</p>
<p>The procedure to check if a module is trusted or not depends on if the
<a class="reference internal" href="#ghc-flag-fpackage-trust"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fpackage-trust</span></code></a> flag is present. The check is similar in both cases
with the <a class="reference internal" href="#ghc-flag-fpackage-trust"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fpackage-trust</span></code></a> flag enabling an extra requirement for
trustworthy modules to be regarded as trusted.</p>
<section id="trust-check-fpackage-trust-disabled">
<h3><span class="section-number">6.18.4.1. </span>Trust check (<code class="docutils literal notranslate"><span class="pre">-fpackage-trust</span></code> disabled)<a class="headerlink" href="#trust-check-fpackage-trust-disabled" title="Permalink to this heading">¶</a></h3>
<p id="index-6">A module <code class="docutils literal notranslate"><span class="pre">M</span></code> in a package <code class="docutils literal notranslate"><span class="pre">P</span></code> is trusted by a client C if and only if:</p>
<ul>
<li><p>Both of these hold:</p>
<blockquote>
<div><ul class="simple">
<li><p>The module was compiled with <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a></p></li>
<li><p>All of M’s direct imports are trusted by C</p></li>
</ul>
</div></blockquote>
</li>
<li><p><em>or</em> all of these hold:</p>
<blockquote>
<div><ul class="simple">
<li><p>The module was compiled with <a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a></p></li>
<li><p>All of <code class="docutils literal notranslate"><span class="pre">M</span></code>'s direct <em>safe imports</em> are trusted by C</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>The above definition of trust has an issue. Any module can be compiled
with <a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a> and it will be trusted. To control this, there is
an additional definition of package trust (enabled with the
<a class="reference internal" href="#ghc-flag-fpackage-trust"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fpackage-trust</span></code></a> flag). The point of package trust is to require that
the client C explicitly say which packages are allowed to contain
trustworthy modules. Trustworthy packages are only trusted if they
reside in a package trusted by C.</p>
</section>
<section id="trust-check-fpackage-trust-enabled">
<h3><span class="section-number">6.18.4.2. </span>Trust check (<code class="docutils literal notranslate"><span class="pre">-fpackage-trust</span></code> enabled)<a class="headerlink" href="#trust-check-fpackage-trust-enabled" title="Permalink to this heading">¶</a></h3>
<p id="index-7">When the <a class="reference internal" href="#ghc-flag-fpackage-trust"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fpackage-trust</span></code></a> flag is enabled, whether or not a module is
trusted depends on if certain packages are trusted. Package trust is
determined by the client C invoking GHC (i.e. you).</p>
<p>Specifically, a package <em>P is trusted</em> when one of these hold:</p>
<ul class="simple">
<li><p>C’s package database records that <code class="docutils literal notranslate"><span class="pre">P</span></code> is trusted (and no command-line
arguments override this)</p></li>
<li><p>C’s command-line flags say to trust <code class="docutils literal notranslate"><span class="pre">P</span></code> regardless of what is recorded
in the package database.</p></li>
</ul>
<p>In either case, C is the only authority on package trust. It is up to
the client to decide which <a class="reference external" href="#safe-package-trust">packages they trust</a>.</p>
<p>When the <a class="reference internal" href="#ghc-flag-fpackage-trust"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fpackage-trust</span></code></a> flag is used a <em>module M from package P is
trusted by a client C</em> if and only if:</p>
<ul class="simple">
<li><p>Both of these hold:</p>
<ul>
<li><p>The module was compiled with <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a></p></li>
<li><p>All of <code class="docutils literal notranslate"><span class="pre">M</span></code>'s direct imports are trusted by C</p></li>
</ul>
</li>
<li><p><em>or</em> all of these hold:</p>
<ul>
<li><p>The module was compiled with <a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a></p></li>
<li><p>All of <code class="docutils literal notranslate"><span class="pre">M</span></code>'s direct safe imports are trusted by C</p></li>
<li><p>Package <code class="docutils literal notranslate"><span class="pre">P</span></code> is trusted by C</p></li>
</ul>
</li>
</ul>
<p>For the first trust definition the trust guarantee is provided by GHC
through the restrictions imposed by the safe language. For the second
definition of trust, the guarantee is provided initially by the module
author. The client C then establishes that they trust the module author
by indicating they trust the package the module resides in. This trust
chain is required as GHC provides no guarantee for <a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a>
compiled modules.</p>
<p>The reason there are two modes of checking trust is that the extra
requirement enabled by <a class="reference internal" href="#ghc-flag-fpackage-trust"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fpackage-trust</span></code></a> causes the design of Safe
Haskell to be invasive. Packages using Safe Haskell when the flag is
enabled may or may not compile depending on the state of trusted
packages on a user’s machine. This is both fragile, and causes
compilation failures for everyone, even if they aren’t trying to use any
of the guarantees provided by Safe Haskell. Disabling
<a class="reference internal" href="#ghc-flag-fpackage-trust"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fpackage-trust</span></code></a> by default and turning it into a flag makes Safe
Haskell an opt-in extension rather than an always on feature.</p>
</section>
<section id="example">
<span id="safe-trust-example"></span><h3><span class="section-number">6.18.4.3. </span>Example<a class="headerlink" href="#example" title="Permalink to this heading">¶</a></h3>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Package</span><span class="w"> </span><span class="kt">Wuggle:</span><span class="w"></span>
<span class="w">    </span><span class="cm">{-# LANGUAGE Safe #-}</span><span class="w"></span>
<span class="w">    </span><span class="kr">module</span><span class="w"> </span><span class="nn">Buggle</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">        </span><span class="kr">import</span><span class="w"> </span><span class="nn">Prelude</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="n">blah</span><span class="o">...</span><span class="w"></span>

<span class="kt">Package</span><span class="w"> </span><span class="kt">P:</span><span class="w"></span>
<span class="w">    </span><span class="cm">{-# LANGUAGE Trustworthy #-}</span><span class="w"></span>
<span class="w">    </span><span class="kr">module</span><span class="w"> </span><span class="nn">M</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">        </span><span class="kr">import</span><span class="w"> </span><span class="nn">System.IO.Unsafe</span><span class="w"></span>
<span class="w">        </span><span class="kr">import</span><span class="w"> </span><span class="nn">safe</span><span class="w"> </span><span class="kt">Buggle</span><span class="w"></span>
</pre></div>
</div>
<p>Suppose a client C decides to trust package <code class="docutils literal notranslate"><span class="pre">P</span></code> and package <code class="docutils literal notranslate"><span class="pre">base</span></code>. Then
does C trust module <code class="docutils literal notranslate"><span class="pre">M</span></code>? Well <code class="docutils literal notranslate"><span class="pre">M</span></code> is marked <a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a>, so we don’t
restrict the language. However, we still must check <code class="docutils literal notranslate"><span class="pre">M</span></code>'s imports:</p>
<ul class="simple">
<li><p>First, <code class="docutils literal notranslate"><span class="pre">M</span></code> imports <code class="docutils literal notranslate"><span class="pre">System.IO.Unsafe</span></code>. This is an unsafe module, however
<code class="docutils literal notranslate"><span class="pre">M</span></code> was compiled with <a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a> , so <code class="docutils literal notranslate"><span class="pre">P</span></code>'s author takes
responsibility for that import. <code class="docutils literal notranslate"><span class="pre">C</span></code> trusts <code class="docutils literal notranslate"><span class="pre">P</span></code>'s author, so this import
is fine.</p></li>
<li><p>Second, <code class="docutils literal notranslate"><span class="pre">M</span></code> safe imports <code class="docutils literal notranslate"><span class="pre">Buggle</span></code>. For this import <code class="docutils literal notranslate"><span class="pre">P</span></code>'s author takes
no responsibility for the safety, instead asking GHC to check whether
<code class="docutils literal notranslate"><span class="pre">Buggle</span></code> is trusted by <code class="docutils literal notranslate"><span class="pre">C</span></code>. Is it?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Buggle</span></code>, is compiled with <code class="docutils literal notranslate"><span class="pre">-XSafe</span></code>, so the code is machine-checked to be
OK, but again under the assumption that all of <code class="docutils literal notranslate"><span class="pre">Buggle</span></code>'s imports are
trusted by <code class="docutils literal notranslate"><span class="pre">C</span></code>. We must recursively check all imports!</p></li>
<li><p>Buggle only imports <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>, which is compiled with <a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a>.
<code class="docutils literal notranslate"><span class="pre">Prelude</span></code> resides in the <code class="docutils literal notranslate"><span class="pre">base</span></code> package, which <code class="docutils literal notranslate"><span class="pre">C</span></code> trusts, and (we’ll
assume) all of <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>'s imports are trusted. So <code class="docutils literal notranslate"><span class="pre">C</span></code> trusts
<code class="docutils literal notranslate"><span class="pre">Prelude</span></code>, and so <code class="docutils literal notranslate"><span class="pre">C</span></code> also trusts Buggle. (While <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> is typically
imported implicitly, it still obeys the same rules outlined here).</p></li>
</ul>
<p>Notice that C didn’t need to trust package Wuggle; the machine checking
is enough. C only needs to trust packages that contain <a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a>
modules.</p>
</section>
<section id="trustworthy-requirements">
<span id="trustworthy-guarantees"></span><h3><span class="section-number">6.18.4.4. </span>Trustworthy Requirements<a class="headerlink" href="#trustworthy-requirements" title="Permalink to this heading">¶</a></h3>
<p id="index-8">Module authors using the <a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a> language extension for a
module <code class="docutils literal notranslate"><span class="pre">M</span></code> should ensure that <code class="docutils literal notranslate"><span class="pre">M</span></code>'s public API (the symbols exposed by its
export list) can’t be used in an unsafe manner. This mean that symbols exported
should respect type safety and referential transparency.</p>
</section>
<section id="package-trust">
<span id="safe-package-trust"></span><h3><span class="section-number">6.18.4.5. </span>Package Trust<a class="headerlink" href="#package-trust" title="Permalink to this heading">¶</a></h3>
<p id="index-9">Safe Haskell gives packages a new Boolean property, that of trust.
Several new options are available at the GHC command-line to specify the
trust property of packages:</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-trust-pkg">
<span class="sig-name descname"><span class="pre">-trust</span></span><span class="sig-prename descclassname"> <span class="pre">⟨pkg⟩</span></span><a class="headerlink" href="#ghc-flag-trust-pkg" title="Permalink to this definition">¶</a></dt>
<dd><p>Exposes package ⟨pkg⟩ if it was hidden and considers it a
trusted package regardless of the package database.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-distrust-pkg">
<span class="sig-name descname"><span class="pre">-distrust</span></span><span class="sig-prename descclassname"> <span class="pre">⟨pkg⟩</span></span><a class="headerlink" href="#ghc-flag-distrust-pkg" title="Permalink to this definition">¶</a></dt>
<dd><p>Exposes package ⟨pkg⟩ if it was hidden and considers it
an untrusted package regardless of the package database.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-distrust-all-packages">
<span class="sig-name descname"><span class="pre">-distrust-all-packages</span></span><a class="headerlink" href="#ghc-flag-distrust-all-packages" title="Permalink to this definition">¶</a></dt>
<dd><p>Considers all packages distrusted unless they are
explicitly set to be trusted by subsequent command-line options.</p>
</dd></dl>

<p>To set a package’s trust property in the package database please refer
to <a class="reference internal" href="../packages.html#packages"><span class="std std-ref">Packages</span></a>.</p>
</section>
</section>
<section id="safe-haskell-inference">
<span id="safe-inference"></span><h2><span class="section-number">6.18.5. </span>Safe Haskell Inference<a class="headerlink" href="#safe-haskell-inference" title="Permalink to this heading">¶</a></h2>
<p id="index-10">In the case where a module is compiled without one of <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a>,
<a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a> or <a class="reference internal" href="#extension-Unsafe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Unsafe</span></code></a> being used, GHC will try to figure out
itself if the module can be considered safe. This safety inference will
never mark a module as trustworthy, only as either unsafe or as safe.
GHC uses a simple method to determine this for a module M: If M would
compile without error under the <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a> flag, then M is marked as
safe. Otherwise, it is marked as unsafe.</p>
<p>When should you use Safe Haskell inference and when should you use an
explicit <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a> flag? The later case should be used when you have a
hard requirement that the module be safe. This is most useful for the
<a class="reference internal" href="#safe-use-cases"><span class="std std-ref">Uses of Safe Haskell</span></a> of Safe Haskell: running untrusted code. Safe
inference is meant to be used by ordinary Haskell programmers. Users who
probably don’t care about Safe Haskell.</p>
<p>Haskell library authors have a choice. Most should just use Safe
inference. Assuming you avoid any unsafe features of the language then
your modules will be marked safe. Inferred vs. Explicit has the
following trade-offs:</p>
<ul class="simple">
<li><p><em>Inferred</em> — This works well and adds no dependencies on the Safe Haskell type
of any modules in other packages. It does mean that the Safe Haskell type of
your own modules could change without warning if a dependency changes. One
way to deal with this is through the use of <a class="reference internal" href="#safe-flag-summary"><span class="std std-ref">Safe Haskell warning flags</span></a> that will warn if GHC infers a Safe Haskell type
different from expected.</p></li>
<li><p><em>Explicit</em> — This gives your library a stable Safe Haskell type that others
can depend on. However, it will increase the chance of compilation failure
when your package dependencies change.</p></li>
</ul>
</section>
<section id="safe-haskell-flag-summary">
<span id="safe-flag-summary"></span><h2><span class="section-number">6.18.6. </span>Safe Haskell Flag Summary<a class="headerlink" href="#safe-haskell-flag-summary" title="Permalink to this heading">¶</a></h2>
<p id="index-11">In summary, Safe Haskell consists of the following three language flags:</p>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-Safe">
<span id="ghc-flag--XSafe"></span><span id="extension-NoSafe"></span><span class="sig-name descname"><span class="pre">Safe</span></span><a class="headerlink" href="#extension-Safe" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.2.1</p>
</dd>
</dl>
<p>Restricts the module to the safe language. All of the module’s
direct imports must be trusted, but the module itself need not
reside in a trusted package, because the compiler vouches for its
trustworthiness. The “safe” keyword is allowed but meaningless in
import statements, as regardless, every import is required to be
safe.</p>
<ul class="simple">
<li><p><em>Module Trusted</em> — Yes</p></li>
<li><p><em>Haskell Language</em> — Restricted to Safe Language</p></li>
<li><p><em>Imported Modules</em> — All forced to be safe imports, all must be trusted.</p></li>
</ul>
</dd></dl>

<dl class="std extension">
<dt class="sig sig-object std" id="extension-Trustworthy">
<span id="ghc-flag--XTrustworthy"></span><span id="extension-NoTrustworthy"></span><span class="sig-name descname"><span class="pre">Trustworthy</span></span><a class="headerlink" href="#extension-Trustworthy" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.2.1</p>
</dd>
</dl>
<p>This establishes that the module is trusted, but the guarantee is
provided by the module’s author. A client of this module then
specifies that they trust the module author by specifying they trust
the package containing the module. <a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a> doesn’t restrict the
module to the safe language. It does however restrict the resolution of
overlapping instances to only allow <a class="reference internal" href="#safe-overlapping-instances"><span class="std std-ref">safe overlapping instances</span></a>. It also allows the use of the safe import
keyword.</p>
<ul class="simple">
<li><p><em>Module Trusted</em>  — Yes.</p></li>
<li><p><em>Module Trusted</em>  (<a class="reference internal" href="#ghc-flag-fpackage-trust"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fpackage-trust</span></code></a> enabled) — Yes but only if the package
the module resides in is also trusted.</p></li>
<li><p><em>Haskell Language</em>  — Unrestricted, except only safe overlapping instances
allowed.</p></li>
<li><p><em>Imported Modules</em> — Under control of module author which ones must be
trusted.</p></li>
</ul>
</dd></dl>

<dl class="std extension">
<dt class="sig sig-object std" id="extension-Unsafe">
<span id="ghc-flag--XUnsafe"></span><span id="extension-NoUnsafe"></span><span class="sig-name descname"><span class="pre">Unsafe</span></span><a class="headerlink" href="#extension-Unsafe" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.4.1</p>
</dd>
</dl>
<p>Mark a module as unsafe so that it can’t be imported by code
compiled with <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a>. Also enable the Safe Import extension so that a
module can require
a dependency to be trusted.</p>
<ul class="simple">
<li><p><em>Module Trusted</em> — No</p></li>
<li><p><em>Haskell Language</em> — Unrestricted</p></li>
<li><p><em>Imported Modules</em> — Under control of module author which ones must be
trusted.</p></li>
</ul>
</dd></dl>

<p>A flag to disable Safe Haskell checks:</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fno-safe-haskell">
<span class="sig-name descname"><span class="pre">-fno-safe-haskell</span></span><a class="headerlink" href="#ghc-flag-fno-safe-haskell" title="Permalink to this definition">¶</a></dt>
<dd><p>This flag can be enabled to override any declared safety property of the
module (Safe, Unsafe, Trustworthy) so compilation proceeds as if none of
these flags were specified. This is particularly useful when compiling
using plugins, which usually results in the compiled modules being marked
as unsafe.</p>
</dd></dl>

<p>And one general flag:</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fpackage-trust">
<span class="sig-name descname"><span class="pre">-fpackage-trust</span></span><a class="headerlink" href="#ghc-flag-fpackage-trust" title="Permalink to this definition">¶</a></dt>
<dd><p>When enabled, turn on an extra check for a trustworthy module <code class="docutils literal notranslate"><span class="pre">M</span></code>,
requiring the package that <code class="docutils literal notranslate"><span class="pre">M</span></code> resides in be considered trusted, for <code class="docutils literal notranslate"><span class="pre">M</span></code>
to be considered trusted.</p>
</dd></dl>

<p>And five warning flags:</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-Wunsafe">
<span class="sig-name descname"><span class="pre">-Wunsafe</span></span><a class="headerlink" href="#ghc-flag-Wunsafe" title="Permalink to this definition">¶</a></dt>
<dd><p>Issue a warning if the module being compiled is regarded to be
unsafe. Should be used to check the safety type of modules when
using safe inference.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-Wsafe">
<span class="sig-name descname"><span class="pre">-Wsafe</span></span><a class="headerlink" href="#ghc-flag-Wsafe" title="Permalink to this definition">¶</a></dt>
<dd><p>Issue a warning if the module being compiled is regarded to be safe.
Should be used to check the safety type of modules when using safe
inference. If the module is explicitly marked as safe then no warning will
be issued.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-Wtrustworthy-safe">
<span class="sig-name descname"><span class="pre">-Wtrustworthy-safe</span></span><a class="headerlink" href="#ghc-flag-Wtrustworthy-safe" title="Permalink to this definition">¶</a></dt>
<dd><p>Issue a warning if the module being compiled is marked as
-XTrustworthy but it could instead be marked as
-XSafe , a more informative bound. Can be used to detect once a Safe Haskell
bound can be improved as dependencies are updated.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-Winferred-safe-imports">
<span class="sig-name descname"><span class="pre">-Winferred-safe-imports</span></span><a class="headerlink" href="#ghc-flag-Winferred-safe-imports" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>8.10.1</p>
</dd>
</dl>
<p id="index-12">The module <code class="docutils literal notranslate"><span class="pre">A</span></code> below is annotated to be explicitly <code class="docutils literal notranslate"><span class="pre">Safe</span></code>, but it imports
<code class="docutils literal notranslate"><span class="pre">Safe-Inferred</span></code> module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE Safe #-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">B</span><span class="w"> </span><span class="p">(</span><span class="nf">double</span><span class="p">)</span><span class="w"></span>

<span class="nf">quad</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">quad</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">double</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">double</span><span class="w"></span>


<span class="kr">module</span><span class="w"> </span><span class="nn">B</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="nf">double</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">double</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
</pre></div>
</div>
<p>The inferred status is volatile: if an unsafe import is added to the module
<code class="docutils literal notranslate"><span class="pre">B</span></code>, it will cause compilation error of <code class="docutils literal notranslate"><span class="pre">A</span></code>.  When
<a class="reference internal" href="#ghc-flag-Winferred-safe-imports"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Winferred-safe-imports</span></code></a> is enabled, the compiler will emit a
warning about this.
This option is off by default.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-Wmissing-safe-haskell-mode">
<span class="sig-name descname"><span class="pre">-Wmissing-safe-haskell-mode</span></span><a class="headerlink" href="#ghc-flag-Wmissing-safe-haskell-mode" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>8.10.1</p>
</dd>
</dl>
<p id="index-13">The compiler will warn when none of  <a class="reference internal" href="#extension-Safe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Safe</span></code></a>,
<a class="reference internal" href="#extension-Trustworthy"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Trustworthy</span></code></a> or <a class="reference internal" href="#extension-Unsafe"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Unsafe</span></code></a> is specified.
This option is off by default.</p>
</dd></dl>

</section>
<section id="safe-compilation">
<span id="id5"></span><h2><span class="section-number">6.18.7. </span>Safe Compilation<a class="headerlink" href="#safe-compilation" title="Permalink to this heading">¶</a></h2>
<p id="index-14">GHC includes a variety of flags that allow arbitrary processes to be run
at compilation time. One such example is the
<a class="reference internal" href="../phases.html#pre-processor"><span class="std std-ref">custom pre-processor</span></a> flag. Another is the ability of
Template Haskell to execute Haskell code at compilation time, including
IO actions. Safe Haskell <em>does not address this danger</em> (although,
Template Haskell is a disallowed feature).</p>
<p>Due to this, it is suggested that when compiling untrusted source code
that has had no manual inspection done, the following precautions be
taken:</p>
<ul class="simple">
<li><p>Compile in a sandbox, such as a chroot or similar container
technology. Or simply as a user with very reduced system access.</p></li>
<li><p>Compile untrusted code with the <code class="docutils literal notranslate"><span class="pre">-XSafe</span></code>
flag being specified on the command line. This will ensure that
modifications to the source being compiled can’t disable the use of
the Safe Language as the command line flag takes precedence over a
source level pragma.</p></li>
<li><p>Ensure that all untrusted code is imported as a
<a class="reference internal" href="#safe-imports"><span class="std std-ref">safe import</span></a> and that the <a class="reference internal" href="#ghc-flag-fpackage-trust"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fpackage-trust</span></code></a>
flag (see <a class="reference internal" href="#safe-package-trust"><span class="std std-ref">flag</span></a>) is used with packages from
untrusted sources being marked as untrusted.</p></li>
</ul>
<p>There is a more detailed discussion of the issues involved in
compilation safety and some potential solutions on the
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/safe-haskell/safe-compilation">GHC Wiki</a>.</p>
<p>Additionally, the use of <a class="reference internal" href="../extending_ghc.html#annotation-pragmas"><span class="std std-ref">annotations</span></a> is forbidden,
as that would allow bypassing Safe Haskell restrictions. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10826">#10826</a>
for details.</p>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="misc.html" class="btn btn-neutral float-right" title="6.19. Miscellaneous" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ffi.html" class="btn btn-neutral float-left" title="6.17. Foreign function interface (FFI)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.13. Template Haskell &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.14. Bang patterns and Strict Haskell" href="strict.html" />
    <link rel="prev" title="6.12.2. Let-generalisation" href="let_generalisation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6.13. Template Haskell</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#syntax">6.13.1. Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-template-haskell">6.13.2. Using Template Haskell</a></li>
<li class="toctree-l3"><a class="reference internal" href="#viewing-template-haskell-generated-code">6.13.3. Viewing Template Haskell generated code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#a-template-haskell-worked-example">6.13.4. A Template Haskell Worked Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#template-haskell-quotes-and-rebindable-syntax">6.13.5. Template Haskell quotes and Rebindable Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-template-haskell-with-profiling">6.13.6. Using Template Haskell with Profiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#template-haskell-quasi-quotation">6.13.7. Template Haskell Quasi-quotation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
      <li><span class="section-number">6.13. </span>Template Haskell</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/template_haskell.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="template-haskell">
<span id="id1"></span><h1><span class="section-number">6.13. </span>Template Haskell<a class="headerlink" href="#template-haskell" title="Permalink to this heading">¶</a></h1>
<p>Template Haskell allows you to do compile-time meta-programming in
Haskell. The background to the main technical innovations is discussed
in “<a class="reference external" href="http://research.microsoft.com/~simonpj/papers/meta-haskell/">Template Meta-programming for
Haskell</a>”
(Proc Haskell Workshop 2002).</p>
<p>The <a class="reference external" href="http://www.haskell.org/haskellwiki/Template_Haskell">Template Haskell</a>
page on the GHC Wiki has a wealth of information. You may also consult the
Haddock reference documentation <a class="reference external" href="../../libraries/template-haskell-2.18.0.0/Language-Haskell-TH.html">Language.Haskell.TH</a>.
Many changes to the original
design are described in <a class="reference external" href="https://www.haskell.org/ghc/docs/papers/th2.ps">Notes on Template Haskell version
2</a>.
Not all of these changes are in GHC, however.</p>
<p>The first example from that paper is set out below (<a class="reference internal" href="#th-example"><span class="std std-ref">A Template Haskell Worked Example</span></a>)
as a worked example to help get you started.</p>
<p>The documentation here describes the realisation of Template Haskell in
GHC. It is not detailed enough to understand Template Haskell; see the
<a class="reference external" href="http://haskell.org/haskellwiki/Template_Haskell">Wiki page</a>.</p>
<section id="syntax">
<span id="th-syntax"></span><h2><span class="section-number">6.13.1. </span>Syntax<a class="headerlink" href="#syntax" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-TemplateHaskell">
<span id="ghc-flag--XTemplateHaskell"></span><span id="extension-NoTemplateHaskell"></span><span class="sig-name descname"><span class="pre">TemplateHaskell</span></span><a class="headerlink" href="#extension-TemplateHaskell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Implies<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#extension-TemplateHaskellQuotes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TemplateHaskellQuotes</span></code></a></p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>6.0. Typed splices introduced in GHC 7.8.1.</p>
</dd>
</dl>
<p>Enable Template Haskell’s splice and quotation syntax.</p>
</dd></dl>

<dl class="std extension">
<dt class="sig sig-object std" id="extension-TemplateHaskellQuotes">
<span id="ghc-flag--XTemplateHaskellQuotes"></span><span id="extension-NoTemplateHaskellQuotes"></span><span class="sig-name descname"><span class="pre">TemplateHaskellQuotes</span></span><a class="headerlink" href="#extension-TemplateHaskellQuotes" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>8.0.1</p>
</dd>
</dl>
<p>Enable only Template Haskell’s quotation syntax.</p>
</dd></dl>

<p>Template Haskell has the following new syntactic constructions. You need to use
the extension <a class="reference internal" href="#extension-TemplateHaskell"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TemplateHaskell</span></code></a> to switch these syntactic extensions on.
Alternatively, the <a class="reference internal" href="#extension-TemplateHaskellQuotes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TemplateHaskellQuotes</span></code></a> extension can be used to
enable the quotation subset of Template Haskell (i.e. without top-level splices).
The <a class="reference internal" href="#extension-TemplateHaskellQuotes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TemplateHaskellQuotes</span></code></a> extension is considered safe under
<a class="reference internal" href="safe_haskell.html#safe-haskell"><span class="std std-ref">Safe Haskell</span></a> while <a class="reference internal" href="#extension-TemplateHaskell"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TemplateHaskell</span></code></a> is not.</p>
<ul>
<li><p>A splice is written <code class="docutils literal notranslate"><span class="pre">$x</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is an arbitrary expression.
There must be no space between the “$” and the expression.
This use of “$” overrides its meaning as an infix operator, just as “M.x”
overrides the meaning of “.” as an infix operator. If you want the
infix operator, put spaces around it.</p>
<p>A top-level splice can occur in place of</p>
<ul class="simple">
<li><p>an expression; the spliced expression must have type <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">Exp</span></code></p></li>
<li><p>a pattern; the spliced pattern must have type <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">Pat</span></code></p></li>
<li><p>a type; the spliced expression must have type <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">Type</span></code></p></li>
<li><p>a list of declarations at top level; the spliced expression must
have type <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">[Dec]</span></code></p></li>
</ul>
<p>Inside a splice you can only call functions defined in imported
modules, not functions defined elsewhere in the same module. Note
that declaration splices are not allowed anywhere except at top level
(outside any other declarations).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Q</span></code> monad is a monad defined in <a class="reference external" href="../../libraries/template-haskell-2.18.0.0/Language-Haskell-TH-Syntax.html">Language.Haskell.TH.Syntax</a> which
supports several useful operations during code generation such as reporting
errors or looking up identifiers in the environment.</p>
</li>
<li><p>A expression quotation is written in Oxford brackets, thus:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[|</span> <span class="pre">...</span> <span class="pre">|]</span></code>, or <code class="docutils literal notranslate"><span class="pre">[e|</span> <span class="pre">...</span> <span class="pre">|]</span></code>, where the “…” is an
expression; the quotation has type <code class="docutils literal notranslate"><span class="pre">Quote</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">Exp</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[d|</span> <span class="pre">...</span> <span class="pre">|]</span></code>, where the “…” is a list of top-level
declarations; the quotation has type <code class="docutils literal notranslate"><span class="pre">Quote</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">[Dec]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[t|</span> <span class="pre">...</span> <span class="pre">|]</span></code>, where the “…” is a type; the quotation has type
<code class="docutils literal notranslate"><span class="pre">Quote</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">Type</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[p|</span> <span class="pre">...</span> <span class="pre">|]</span></code>, where the “…” is a pattern; the quotation has
type <code class="docutils literal notranslate"><span class="pre">Quote</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">Pat</span></code>.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">Quote</span></code> type class (<a class="reference external" href="../../libraries/template-haskell-2.18.0.0/Language-Haskell-TH-Syntax.html#t:Quote">Language.Haskell.TH.Syntax.Quote</a>) is
the minimal interface necessary to implement the desugaring of quotations.
The <code class="docutils literal notranslate"><span class="pre">Q</span></code> monad is an instance of <code class="docutils literal notranslate"><span class="pre">Quote</span></code> but contains many more
operations which are not needed for defining quotations.</p>
<p>See <a class="reference internal" href="partial_type_signatures.html#pts-where"><span class="std std-ref">Where can they occur?</span></a> for using partial type signatures in quotations.</p>
</li>
<li><p>Splices can be nested inside quotation brackets. For example the fragment
representing <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code> can be constructed using nested splices:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">oneC</span><span class="p">,</span><span class="w"> </span><span class="n">twoC</span><span class="p">,</span><span class="w"> </span><span class="n">plusC</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">Quote</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Exp</span><span class="w"></span>
<span class="nf">oneC</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="o">|</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="p">]</span><span class="w"></span>

<span class="nf">twoC</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="o">|</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="p">]</span><span class="w"></span>

<span class="nf">plusC</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="o">|</span><span class="w"> </span><span class="o">$</span><span class="n">oneC</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">$</span><span class="n">twoC</span><span class="w"> </span><span class="o">|</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The precise type of a quotation depends on the types of the nested splices inside it:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Add a redundant constraint to demonstrate that constraints on the</span><span class="w"></span>
<span class="c1">-- monad used to build the representation are propagated when using nested</span><span class="w"></span>
<span class="c1">-- splices.</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Quote</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Exp</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="o">|</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">]</span><span class="w"></span>

<span class="c1">-- f is used in a nested splice so the constraint on f, namely C, is propagated</span><span class="w"></span>
<span class="c1">-- to a constraint on the whole representation.</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Quote</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Exp</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="o">|</span><span class="w"> </span><span class="o">$</span><span class="n">f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">$</span><span class="n">f</span><span class="w"> </span><span class="o">|</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Remember, a top-level splice still requires its argument to be of type <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">Exp</span></code>.
So then splicing in <code class="docutils literal notranslate"><span class="pre">g</span></code> will cause <code class="docutils literal notranslate"><span class="pre">m</span></code> to be instantiated to <code class="docutils literal notranslate"><span class="pre">Q</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">h</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">h</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="c1">-- m ~ Q</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>A <em>typed</em> expression splice is written <code class="docutils literal notranslate"><span class="pre">$$x</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is
is an arbitrary expression.</p>
<p>A top-level typed expression splice can occur in place of an expression; the
spliced expression must have type <code class="docutils literal notranslate"><span class="pre">Code</span> <span class="pre">Q</span> <span class="pre">a</span></code></p>
</li>
<li><p>A <em>typed</em> expression quotation is written as <code class="docutils literal notranslate"><span class="pre">[||</span> <span class="pre">...</span> <span class="pre">||]</span></code>, or
<code class="docutils literal notranslate"><span class="pre">[e||</span> <span class="pre">...</span> <span class="pre">||]</span></code>, where the “…” is an expression; if the “…”
expression has type <code class="docutils literal notranslate"><span class="pre">a</span></code>, then the quotation has type
<code class="docutils literal notranslate"><span class="pre">Quote</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">Code</span> <span class="pre">m</span> <span class="pre">a</span></code>.</p>
<p>It is possible to extract a value of type <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">Exp</span></code> from <code class="docutils literal notranslate"><span class="pre">Code</span> <span class="pre">m</span> <span class="pre">a</span></code>
using the <code class="docutils literal notranslate"><span class="pre">unTypeCode</span> <span class="pre">::</span> <span class="pre">Code</span> <span class="pre">m</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">Exp</span></code> function.</p>
</li>
<li><p>A quasi-quotation can appear in a pattern, type, expression, or
declaration context and is also written in Oxford brackets:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[varid|</span> <span class="pre">...</span> <span class="pre">|]</span></code>, where the “…” is an arbitrary string; a full
description of the quasi-quotation facility is given in
<a class="reference internal" href="#th-quasiquotation"><span class="std std-ref">Template Haskell Quasi-quotation</span></a>.</p></li>
</ul>
</li>
<li><p>A name can be quoted with either one or two prefix single quotes:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'f</span></code> has type <code class="docutils literal notranslate"><span class="pre">Name</span></code>, and names the function <code class="docutils literal notranslate"><span class="pre">f</span></code>. Similarly
<code class="docutils literal notranslate"><span class="pre">'C</span></code> has type <code class="docutils literal notranslate"><span class="pre">Name</span></code> and names the data constructor <code class="docutils literal notranslate"><span class="pre">C</span></code>. In
general <code class="docutils literal notranslate"><span class="pre">'</span></code>⟨thing⟩ interprets ⟨thing⟩ in an expression
context.</p>
<p>A name whose second character is a single quote (sadly) cannot be
quoted in this way, because it will be parsed instead as a quoted
character. For example, if the function is called <code class="docutils literal notranslate"><span class="pre">f'7</span></code> (which
is a legal Haskell identifier), an attempt to quote it as <code class="docutils literal notranslate"><span class="pre">'f'7</span></code>
would be parsed as the character literal <code class="docutils literal notranslate"><span class="pre">'f'</span></code> followed by the
numeric literal <code class="docutils literal notranslate"><span class="pre">7</span></code>. There is no current escape mechanism in
this (unusual) situation.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">''T</span></code> has type <code class="docutils literal notranslate"><span class="pre">Name</span></code>, and names the type constructor <code class="docutils literal notranslate"><span class="pre">T</span></code>.
That is, <code class="docutils literal notranslate"><span class="pre">''</span></code>⟨thing⟩ interprets ⟨thing⟩ in a type context.</p></li>
</ul>
<p>These <code class="docutils literal notranslate"><span class="pre">Names</span></code> can be used to construct Template Haskell
expressions, patterns, declarations etc. They may also be given as an
argument to the <code class="docutils literal notranslate"><span class="pre">reify</span></code> function.</p>
</li>
<li><p>It is possible for a splice to expand to an expression that contain
names which are not in scope at the site of the splice. As an
example, consider the following code:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Bar</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Language.Haskell.TH</span><span class="w"></span>

<span class="nf">add1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Quote</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Exp</span><span class="w"></span>
<span class="nf">add1</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Now consider a splice using <code class="docutils literal notranslate"><span class="pre">add1</span></code> in a separate
module:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Foo</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Bar</span><span class="w"></span>

<span class="nf">two</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">two</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="n">add1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Template Haskell cannot know what the argument to <code class="docutils literal notranslate"><span class="pre">add1</span></code> will be at the
function’s definition site, so a lifting mechanism is used to promote
<code class="docutils literal notranslate"><span class="pre">x</span></code> into a value of type <code class="docutils literal notranslate"><span class="pre">Quote</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">Exp</span></code>. This functionality is exposed to the
user as the <code class="docutils literal notranslate"><span class="pre">Lift</span></code> typeclass in the <code class="docutils literal notranslate"><span class="pre">Language.Haskell.TH.Syntax</span></code>
module. If a type has a <code class="docutils literal notranslate"><span class="pre">Lift</span></code> instance, then any of its values can be
lifted to a Template Haskell expression:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Lift</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">lift</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Quote</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Exp</span><span class="w"></span>
<span class="w">    </span><span class="n">liftTyped</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Quote</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Code</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">t</span><span class="w"></span>
</pre></div>
</div>
<p>In general, if GHC sees an expression within Oxford brackets (e.g., <code class="docutils literal notranslate"><span class="pre">[|</span>
<span class="pre">foo</span> <span class="pre">bar</span> <span class="pre">|]</span></code>, then GHC looks up each name within the brackets. If a name
is global (e.g., suppose <code class="docutils literal notranslate"><span class="pre">foo</span></code> comes from an import or a top-level
declaration), then the fully qualified name is used directly in the
quotation. If the name is local (e.g., suppose <code class="docutils literal notranslate"><span class="pre">bar</span></code> is bound locally in
the function definition <code class="docutils literal notranslate"><span class="pre">mkFoo</span> <span class="pre">bar</span> <span class="pre">=</span> <span class="pre">[|</span> <span class="pre">foo</span> <span class="pre">bar</span> <span class="pre">|]</span></code>), then GHC uses
<code class="docutils literal notranslate"><span class="pre">lift</span></code> on it (so GHC pretends <code class="docutils literal notranslate"><span class="pre">[|</span> <span class="pre">foo</span> <span class="pre">bar</span> <span class="pre">|]</span></code> actually contains <code class="docutils literal notranslate"><span class="pre">[|</span>
<span class="pre">foo</span> <span class="pre">$(lift</span> <span class="pre">bar)</span> <span class="pre">|]</span></code>). Local names, which are not in scope at splice
locations, are actually evaluated when the quotation is processed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">template-haskell</span></code> library provides <code class="docutils literal notranslate"><span class="pre">Lift</span></code> instances for many
common data types. Furthermore, it is possible to derive <code class="docutils literal notranslate"><span class="pre">Lift</span></code>
instances automatically by using the <a class="reference internal" href="deriving_extra.html#extension-DeriveLift"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DeriveLift</span></code></a> language extension.
See <a class="reference internal" href="deriving_extra.html#deriving-lift"><span class="std std-ref">Deriving Lift instances</span></a> for more information.</p>
</li>
<li><p>You may omit the <code class="docutils literal notranslate"><span class="pre">$(...)</span></code> in a top-level declaration splice. Simply
writing an expression (rather than a declaration) implies a splice.
For example, you can write</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Foo</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Bar</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="o">$</span><span class="p">(</span><span class="n">deriveStuff</span><span class="w"> </span><span class="n">&#39;f</span><span class="p">)</span><span class="w">   </span><span class="c1">-- Uses the $(...) notation</span><span class="w"></span>

<span class="nf">g</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="w"></span>

<span class="nf">deriveStuff</span><span class="w"> </span><span class="n">&#39;g</span><span class="w">      </span><span class="c1">-- Omits the $(...)</span><span class="w"></span>

<span class="nf">h</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">z</span><span class="o">-</span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>This abbreviation makes top-level declaration slices quieter and less
intimidating.</p>
</li>
<li><p>Pattern splices introduce variable binders but scoping of variables in
expressions inside the pattern’s scope is only checked when a splice is
run.  Note that pattern splices that occur outside of any quotation
brackets are run at compile time.  Pattern splices occurring inside a
quotation bracket are <em>not</em> run at compile time; they are run when the
bracket is spliced in, sometime later.  For example,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPat</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Quote</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Pat</span><span class="w"></span>
<span class="nf">mkPat</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="p">]</span><span class="w"></span>

<span class="c1">-- in another module:</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Char</span><span class="p">,</span><span class="w"> </span><span class="kt">String</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="n">mkPat</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">z</span><span class="w"></span>

<span class="nf">bar</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Quote</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Exp</span><span class="w"></span>
<span class="nf">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="o">|</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="n">mkPat</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">|</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>will fail with <code class="docutils literal notranslate"><span class="pre">z</span></code> being out of scope in the definition of <code class="docutils literal notranslate"><span class="pre">foo</span></code> but it
will <em>not</em> fail with <code class="docutils literal notranslate"><span class="pre">w</span></code> being out of scope in the definition of <code class="docutils literal notranslate"><span class="pre">bar</span></code>.
That will only happen when <code class="docutils literal notranslate"><span class="pre">bar</span></code> is spliced.</p>
</li>
<li><p>A pattern quasiquoter <em>may</em> generate binders that scope over the
right-hand side of a definition because these binders are in scope
lexically. For example, given a quasiquoter <code class="docutils literal notranslate"><span class="pre">haskell</span></code> that parses
Haskell, in the following code, the <code class="docutils literal notranslate"><span class="pre">y</span></code> in the right-hand side of
<code class="docutils literal notranslate"><span class="pre">f</span></code> refers to the <code class="docutils literal notranslate"><span class="pre">y</span></code> bound by the <code class="docutils literal notranslate"><span class="pre">haskell</span></code> pattern
quasiquoter, <em>not</em> the top-level <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">7</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">y</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">7</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="p">[</span><span class="n">haskell</span><span class="o">|</span><span class="n">y</span><span class="o">|</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">y</span><span class="o">+</span><span class="n">n</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Top-level declaration splices break up a source file into
<em>declaration groups</em>. A <em>declaration group</em> is the group of
declarations created by a top-level declaration splice, plus those
following it, down to but not including the next top-level
declaration splice. N.B. only top-level splices delimit declaration
groups, not expression splices. The first declaration group in a module
includes all top-level definitions down to but not including the first
top-level declaration splice.</p>
<p>Each declaration group is mutually recursive only within the group.
Declaration groups can refer to definitions within previous groups,
but not later ones.</p>
<p>Accordingly, the type environment seen by <code class="docutils literal notranslate"><span class="pre">reify</span></code> includes all the
top-level declarations up to the end of the immediately preceding
declaration group, but no more.</p>
<p>Unlike normal declaration splices, declaration quasiquoters do not
cause a break. These quasiquoters are expanded before the rest of the
declaration group is processed, and the declarations they generate
are merged into the surrounding declaration group. Consequently, the
type environment seen by <code class="docutils literal notranslate"><span class="pre">reify</span></code> from a declaration quasiquoter
will not include anything from the quasiquoter’s declaration group.</p>
<p>Concretely, consider the following code</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">M</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">...</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="o">$</span><span class="p">(</span><span class="n">th1</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"></span>

<span class="nf">h</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="n">blah1</span><span class="p">)</span><span class="w"></span>

<span class="p">[</span><span class="n">qq</span><span class="o">|</span><span class="n">blah</span><span class="o">|</span><span class="p">]</span><span class="w"></span>

<span class="nf">k</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="w"></span>

<span class="o">$</span><span class="p">(</span><span class="n">th2</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>

<span class="nf">w</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="n">blah2</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, a <code class="docutils literal notranslate"><span class="pre">reify</span></code> inside…</p>
<ol class="arabic simple">
<li><p>The splice <code class="docutils literal notranslate"><span class="pre">$(th1</span> <span class="pre">...)</span></code> would see the definition of <code class="docutils literal notranslate"><span class="pre">f</span></code> - the
splice is top-level and thus all definitions in the previous
declaration group are visible (that is, all definitions in the module
up-to, but not including, the splice itself).</p></li>
<li><p>The splice <code class="docutils literal notranslate"><span class="pre">$(blah1)</span></code> cannot refer to the function <code class="docutils literal notranslate"><span class="pre">w</span></code> - <code class="docutils literal notranslate"><span class="pre">w</span></code> is
part of a later declaration group, and thus invisible, similarly,
<code class="docutils literal notranslate"><span class="pre">$(blah1)</span></code> cannot see the definition of <code class="docutils literal notranslate"><span class="pre">h</span></code> (since it is part of
the same declaration group as <code class="docutils literal notranslate"><span class="pre">$(blah1)</span></code>. However, the splice
<code class="docutils literal notranslate"><span class="pre">$(blah1)</span></code> can see the definition of <code class="docutils literal notranslate"><span class="pre">f</span></code> (since it is in the
immediately preceding declaration group).</p></li>
<li><p>The splice <code class="docutils literal notranslate"><span class="pre">$(th2</span> <span class="pre">...)</span></code> would see the definition of <code class="docutils literal notranslate"><span class="pre">f</span></code>, all the
bindings created by <code class="docutils literal notranslate"><span class="pre">$(th1</span> <span class="pre">...)</span></code>, the definition of <code class="docutils literal notranslate"><span class="pre">h</span></code> and all
bindings created by <code class="docutils literal notranslate"><span class="pre">[qq|blah|]</span></code> (they are all in previous
declaration groups).</p></li>
<li><p>The body of <code class="docutils literal notranslate"><span class="pre">h</span></code> <em>can</em> refer to the function <code class="docutils literal notranslate"><span class="pre">k</span></code> appearing on the
other side of the declaration quasiquoter, as quasiquoters do not
cause a declaration group to be broken up.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">qq</span></code> quasiquoter would be able to see the definition of <code class="docutils literal notranslate"><span class="pre">f</span></code>
from the preceding declaration group, but not the definitions of
<code class="docutils literal notranslate"><span class="pre">h</span></code> or <code class="docutils literal notranslate"><span class="pre">k</span></code>, or any definitions from subsequent declaration
groups.</p></li>
<li><p>The splice <code class="docutils literal notranslate"><span class="pre">$(blah2)</span></code> would see the same definitions as the splice
<code class="docutils literal notranslate"><span class="pre">$(th2</span> <span class="pre">...)</span></code> (but <em>not</em> any bindings it creates).</p></li>
</ol>
<p>Note that since an expression splice is unable to refer to declarations
in the same declaration group, we can introduce a top-level (empty)
splice to break up the declaration group</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">M</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">C2</span><span class="w"></span>

<span class="nf">f1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="n">th1</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"></span>

<span class="o">$</span><span class="p">(</span><span class="n">return</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"></span>

<span class="nf">f2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="n">th2</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Here</p>
<ol class="arabic simple">
<li><p>The splice <code class="docutils literal notranslate"><span class="pre">$(th1</span> <span class="pre">...)</span></code> <em>cannot</em> refer to <code class="docutils literal notranslate"><span class="pre">D</span></code> - it is in the same
declaration group.</p></li>
<li><p>The declaration group containing <code class="docutils literal notranslate"><span class="pre">D</span></code> is terminated by the empty
top-level declaration splice <code class="docutils literal notranslate"><span class="pre">$(return</span> <span class="pre">[])</span></code> (recall, <code class="docutils literal notranslate"><span class="pre">Q</span></code> is a
Monad, so we may simply <code class="docutils literal notranslate"><span class="pre">return</span></code> the empty list of declarations).</p></li>
<li><p>Since the declaration group containing <code class="docutils literal notranslate"><span class="pre">D</span></code> is in the previous
declaration group, the splice <code class="docutils literal notranslate"><span class="pre">$(th2</span> <span class="pre">...)</span></code> <em>can</em> refer to <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p></li>
</ol>
</li>
<li><p>Expression quotations accept most Haskell language constructs.
However, there are some GHC-specific extensions which expression
quotations currently do not support, including</p>
<ul class="simple">
<li><p>Type holes in typed splices (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10945">#10945</a> and
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10946">#10946</a>)</p></li>
</ul>
</li>
</ul>
<p>(Compared to the original paper, there are many differences of detail.
The syntax for a declaration splice uses “<code class="docutils literal notranslate"><span class="pre">$</span></code>” not “<code class="docutils literal notranslate"><span class="pre">splice</span></code>”. The type of
the enclosed expression must be <code class="docutils literal notranslate"><span class="pre">Quote</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">[Dec]</span></code>, not <code class="docutils literal notranslate"><span class="pre">[Q</span> <span class="pre">Dec]</span></code>. Typed expression
splices and quotations are supported.)</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fenable-th-splice-warnings">
<span class="sig-name descname"><span class="pre">-fenable-th-splice-warnings</span></span><a class="headerlink" href="#ghc-flag-fenable-th-splice-warnings" title="Permalink to this definition">¶</a></dt>
<dd><p>Template Haskell splices won’t be checked for warnings, because the code
causing the warning might originate from a third-party library and possibly
was not written by the user. If you want to have warnings for splices
anyway, pass <a class="reference internal" href="#ghc-flag-fenable-th-splice-warnings"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fenable-th-splice-warnings</span></code></a>.</p>
</dd></dl>

</section>
<section id="using-template-haskell">
<span id="th-usage"></span><h2><span class="section-number">6.13.2. </span>Using Template Haskell<a class="headerlink" href="#using-template-haskell" title="Permalink to this heading">¶</a></h2>
<ul>
<li><p>The data types and monadic constructor functions for Template Haskell
are in the library <a class="reference external" href="../../libraries/template-haskell-2.18.0.0/Language-Haskell-TH-Syntax.html">Language.Haskell.TH.Syntax</a>.</p></li>
<li><p>You can only run a function at compile time if it is imported from
another module. That is, you can’t define a function in a module, and
call it from within a splice in the same module. (It would make sense
to do so, but it’s hard to implement.)</p></li>
<li><p>You can only run a function at compile time if it is imported from
another module <em>that is not part of a mutually-recursive group of
modules that includes the module currently being compiled</em>.
Furthermore, all of the modules of the mutually-recursive group must
be reachable by non-SOURCE imports from the module where the splice
is to be run.</p>
<p>For example, when compiling module A, you can only run Template
Haskell functions imported from B if B does not import A (directly or
indirectly). The reason should be clear: to run B we must compile and
run A, but we are currently type-checking A.</p>
</li>
<li><p>If you are building GHC from source, you need at least a stage-2
bootstrap compiler to run Template Haskell splices and quasi-quotes.
A stage-1 compiler will only accept regular quotes of Haskell.
Reason: TH splices and quasi-quotes compile and run a program, and
then looks at the result. So it’s important that the program it
compiles produces results whose representations are identical to
those of the compiler itself.</p></li>
</ul>
<p>Template Haskell works in any mode (<a class="reference internal" href="../using.html#ghc-flag-make"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">--make</span></code></a>,
<a class="reference internal" href="../using.html#ghc-flag-interactive"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">--interactive</span></code></a>, or file-at-a-time). There used to be a restriction to
the former two, but that restriction has been lifted.</p>
</section>
<section id="viewing-template-haskell-generated-code">
<span id="th-view-gen-code"></span><h2><span class="section-number">6.13.3. </span>Viewing Template Haskell generated code<a class="headerlink" href="#viewing-template-haskell-generated-code" title="Permalink to this heading">¶</a></h2>
<p>The flag <a class="reference internal" href="../debugging.html#ghc-flag-ddump-splices"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-splices</span></code></a> shows the expansion of all top-level
declaration splices, both typed and untyped, as they happen. As with all
dump flags, the default is for this output to be sent to stdout. For a
non-trivial program, you may be interested in combining this with the
<a class="reference internal" href="../debugging.html#ghc-flag-ddump-to-file"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-to-file</span></code></a> flag (see <a class="reference internal" href="../debugging.html#dumping-output"><span class="std std-ref">Dumping out compiler intermediate structures</span></a>. For each file using
Template Haskell, this will show the output in a <code class="docutils literal notranslate"><span class="pre">.dump-splices</span></code> file.</p>
<p>The flag <a class="reference internal" href="../debugging.html#ghc-flag-dth-dec-file"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-dth-dec-file</span></code></a> dumps the expansions of all top-level
TH declaration splices, both typed and untyped, in the file <code class="file docutils literal notranslate"><span class="pre">M.th.hs</span></code>
for each module <cite>M</cite> being compiled. Note that other types of
splices (expressions, types, and patterns) are not shown. Application
developers can check this into their repository so that they can grep for
identifiers that were defined in Template Haskell. This is similar to using
<a class="reference internal" href="../debugging.html#ghc-flag-ddump-to-file"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-to-file</span></code></a> with <a class="reference internal" href="../debugging.html#ghc-flag-ddump-splices"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-splices</span></code></a> but it always
generates a file instead of being coupled to <a class="reference internal" href="../debugging.html#ghc-flag-ddump-to-file"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-to-file</span></code></a>. The
format is also different: it does not show code from the original file, instead
it only shows generated code and has a comment for the splice location of the
original file.</p>
<p>Below is a sample output of <a class="reference internal" href="../debugging.html#ghc-flag-ddump-splices"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-splices</span></code></a></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">TH_pragma</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">26</span><span class="p">)</span><span class="kt">:</span><span class="w"> </span><span class="kt">Splicing</span><span class="w"> </span><span class="n">declarations</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="n">d</span><span class="o">|</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">      </span><span class="n">foo</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="p">]</span><span class="w"></span>
<span class="o">======&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Below is the output of the same sample using <a class="reference internal" href="../debugging.html#ghc-flag-dth-dec-file"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-dth-dec-file</span></code></a></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- TH_pragma.hs:(6,4)-(8,26): Splicing declarations</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="a-template-haskell-worked-example">
<span id="th-example"></span><h2><span class="section-number">6.13.4. </span>A Template Haskell Worked Example<a class="headerlink" href="#a-template-haskell-worked-example" title="Permalink to this heading">¶</a></h2>
<p>To help you get over the confidence barrier, try out this skeletal
worked example. First cut and paste the two modules below into <code class="file docutils literal notranslate"><span class="pre">Main.hs</span></code>
and <code class="file docutils literal notranslate"><span class="pre">Printf.hs</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{- Main.hs -}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">Main</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="c1">-- Import our template &quot;pr&quot;</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Printf</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nf">pr</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="c1">-- The splice operator $ takes the Haskell source code</span><span class="w"></span>
<span class="c1">-- generated at compile time by &quot;pr&quot; and splices it into</span><span class="w"></span>
<span class="c1">-- the argument of &quot;putStrLn&quot;.</span><span class="w"></span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="n">pr</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>


<span class="cm">{- Printf.hs -}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">Printf</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="c1">-- Skeletal printf from the paper.</span><span class="w"></span>
<span class="c1">-- It needs to be in a separate module to the one where</span><span class="w"></span>
<span class="c1">-- you intend to use it.</span><span class="w"></span>

<span class="c1">-- Import some Template Haskell syntax</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Language.Haskell.TH</span><span class="w"></span>

<span class="c1">-- Describe a format string</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Format</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">L</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>

<span class="c1">-- Parse a format string.  This is left largely to you</span><span class="w"></span>
<span class="c1">-- as we are here interested in building our first ever</span><span class="w"></span>
<span class="c1">-- Template Haskell program and not in building printf.</span><span class="w"></span>
<span class="nf">parse</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Format</span><span class="p">]</span><span class="w"></span>
<span class="nf">parse</span><span class="w"> </span><span class="n">s</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="kt">L</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">]</span><span class="w"></span>

<span class="c1">-- Generate Haskell source code from a parsed representation</span><span class="w"></span>
<span class="c1">-- of the format string.  This code will be spliced into</span><span class="w"></span>
<span class="c1">-- the module which calls &quot;pr&quot;, at compile time.</span><span class="w"></span>
<span class="nf">gen</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Quote</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Format</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Exp</span><span class="w"></span>
<span class="nf">gen</span><span class="w"> </span><span class="p">[</span><span class="kt">D</span><span class="p">]</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="o">|</span><span class="w"> </span><span class="nf">\</span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">|</span><span class="p">]</span><span class="w"></span>
<span class="nf">gen</span><span class="w"> </span><span class="p">[</span><span class="kt">S</span><span class="p">]</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="o">|</span><span class="w"> </span><span class="nf">\</span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">|</span><span class="p">]</span><span class="w"></span>
<span class="nf">gen</span><span class="w"> </span><span class="p">[</span><span class="kt">L</span><span class="w"> </span><span class="n">s</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">stringE</span><span class="w"> </span><span class="n">s</span><span class="w"></span>

<span class="c1">-- Here we generate the Haskell code for the splice</span><span class="w"></span>
<span class="c1">-- from an input format string.</span><span class="w"></span>
<span class="nf">pr</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Quote</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Exp</span><span class="w"></span>
<span class="nf">pr</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">gen</span><span class="w"> </span><span class="p">(</span><span class="n">parse</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Now run the compiler,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ghc --make -XTemplateHaskell main.hs -o main
</pre></div>
</div>
<p>Run <code class="file docutils literal notranslate"><span class="pre">main</span></code> and here is your output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./main
Hello
</pre></div>
</div>
</section>
<section id="template-haskell-quotes-and-rebindable-syntax">
<span id="th-rs"></span><h2><span class="section-number">6.13.5. </span>Template Haskell quotes and Rebindable Syntax<a class="headerlink" href="#template-haskell-quotes-and-rebindable-syntax" title="Permalink to this heading">¶</a></h2>
<p>Rebindable syntax does not play well with untyped TH quotes:
applying the rebindable syntax rules would go against the lax
nature of untyped quotes that are accepted even in the presence of
unbound identifiers (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/18102">#18102</a>). Applying the rebindable syntax
rules to them would force the code that defines the said quotes to have all
the necessary functions (e.g <code class="docutils literal notranslate"><span class="pre">ifThenElse</span></code> or <code class="docutils literal notranslate"><span class="pre">fromInteger</span></code>) in scope,
instead of delaying the resolution of those symbols to the code that splices
the quoted Haskell syntax, as is usually done with untyped TH. For this reason,
even if a module has untyped TH quotes with <code class="docutils literal notranslate"><span class="pre">RebindableSyntax</span></code> enabled, GHC
turns off rebindable syntax while processing the quotes. The code that splices
the quotes is however free to turn on <code class="docutils literal notranslate"><span class="pre">RebindableSyntax</span></code> to have the usual
rules applied to the resulting code.</p>
<p>Typed TH quotes on the other hand are perfectly compatible with the eager
application of rebindable syntax rules, and GHC will therefore process any
such quotes according to the rebindable syntax rules whenever the
<code class="docutils literal notranslate"><span class="pre">RebindableSyntax</span></code> extension is turned on in the modules where such quotes
appear.</p>
</section>
<section id="using-template-haskell-with-profiling">
<span id="th-profiling"></span><h2><span class="section-number">6.13.6. </span>Using Template Haskell with Profiling<a class="headerlink" href="#using-template-haskell-with-profiling" title="Permalink to this heading">¶</a></h2>
<p id="index-0">Template Haskell relies on GHC’s built-in bytecode compiler and
interpreter to run the splice expressions. The bytecode interpreter runs
the compiled expression on top of the same runtime on which GHC itself
is running; this means that the compiled code referred to by the
interpreted expression must be compatible with this runtime, and in
particular this means that object code that is compiled for profiling
<em>cannot</em> be loaded and used by a splice expression, because profiled
object code is only compatible with the profiling version of the
runtime.</p>
<p>This causes difficulties if you have a multi-module program containing
Template Haskell code and you need to compile it for profiling, because
GHC cannot load the profiled object code and use it when executing the
splices.</p>
<p>Fortunately GHC provides two workarounds.</p>
<p>The first option is to compile the program twice:</p>
<ol class="arabic">
<li><p>Compile the program or library first the normal way, without
<a class="reference internal" href="../profiling.html#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a>.</p></li>
<li><p>Then compile it again with <a class="reference internal" href="../profiling.html#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a>, and additionally use <code class="docutils literal notranslate"><span class="pre">-osuf</span>
<span class="pre">p_o</span></code> to name the object files differently (you can choose any suffix that
isn’t the normal object suffix here). GHC will automatically load the object
files built in the first step when executing splice expressions. If you omit
the <a class="reference internal" href="../separate_compilation.html#ghc-flag-osuf-suffix"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-osuf</span> <span class="pre">⟨suffix⟩</span></code></a> flag when building with <a class="reference internal" href="../profiling.html#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a> and
Template Haskell is used, GHC will emit an error message.</p>
</li>
</ol>
<p id="index-1">The second option is to add the flag <a class="reference internal" href="../ghci.html#ghc-flag-fexternal-interpreter"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fexternal-interpreter</span></code></a> (see
<a class="reference internal" href="../ghci.html#external-interpreter"><span class="std std-ref">Running the interpreter in a separate process</span></a>), which runs the interpreter in a separate
process, wherein it can load and run the profiled code directly.
There’s no need to compile the code twice, just add
<a class="reference internal" href="../ghci.html#ghc-flag-fexternal-interpreter"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fexternal-interpreter</span></code></a> and it should just work.  (this option is
experimental in GHC 8.0.x, but it may become the default in future
releases).</p>
</section>
<section id="template-haskell-quasi-quotation">
<span id="th-quasiquotation"></span><h2><span class="section-number">6.13.7. </span>Template Haskell Quasi-quotation<a class="headerlink" href="#template-haskell-quasi-quotation" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-QuasiQuotes">
<span id="ghc-flag--XQuasiQuotes"></span><span id="extension-NoQuasiQuotes"></span><span class="sig-name descname"><span class="pre">QuasiQuotes</span></span><a class="headerlink" href="#extension-QuasiQuotes" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.10.1</p>
</dd>
</dl>
<p>Enable Template Haskell Quasi-quotation syntax.</p>
</dd></dl>

<p>Quasi-quotation allows patterns and expressions to be written using
programmer-defined concrete syntax; the motivation behind the extension
and several examples are documented in “<a class="reference external" href="http://www.cs.tufts.edu/comp/150FP/archive/geoff-mainland/quasiquoting.pdf">Why It’s Nice to be Quoted:
Quasiquoting for
Haskell</a>”
(Proc Haskell Workshop 2007). The example below shows how to write a
quasiquoter for a simple expression language.</p>
<p>Here are the salient features</p>
<ul>
<li><p>A quasi-quote has the form <code class="docutils literal notranslate"><span class="pre">[quoter|</span> <span class="pre">string</span> <span class="pre">|]</span></code>.</p>
<ul class="simple">
<li><p>The ⟨quoter⟩ must be the name of an imported quoter, either
qualified or unqualified; it cannot be an arbitrary expression.</p></li>
<li><p>The ⟨quoter⟩ cannot be “<code class="docutils literal notranslate"><span class="pre">e</span></code>”, “<code class="docutils literal notranslate"><span class="pre">t</span></code>”, “<code class="docutils literal notranslate"><span class="pre">d</span></code>”, or “<code class="docutils literal notranslate"><span class="pre">p</span></code>”,
since those overlap with Template Haskell quotations.</p></li>
<li><p>There must be no spaces in the token <code class="docutils literal notranslate"><span class="pre">[quoter|</span></code>.</p></li>
<li><p>The quoted ⟨string⟩ can be arbitrary, and may contain newlines.</p></li>
<li><p>The quoted ⟨string⟩ finishes at the first occurrence of the
two-character sequence <code class="docutils literal notranslate"><span class="pre">&quot;|]&quot;</span></code>. Absolutely no escaping is
performed. If you want to embed that character sequence in the
string, you must invent your own escape convention (such as, say,
using the string <code class="docutils literal notranslate"><span class="pre">&quot;|~]&quot;</span></code> instead), and make your quoter function
interpret <code class="docutils literal notranslate"><span class="pre">&quot;|~]&quot;</span></code> as <code class="docutils literal notranslate"><span class="pre">&quot;|]&quot;</span></code>. One way to implement this is to
compose your quoter with a pre-processing pass to perform your
escape conversion. See the discussion in <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/5348">#5348</a> for details.</p></li>
</ul>
</li>
<li><p>A quasiquote may appear in place of</p>
<ul class="simple">
<li><p>An expression</p></li>
<li><p>A pattern</p></li>
<li><p>A type</p></li>
<li><p>A top-level declaration</p></li>
</ul>
<p>(Only the first two are described in the paper.)</p>
</li>
<li><p>A quoter is a value of type
<a class="reference external" href="../../libraries/template-haskell-2.18.0.0/Language-Haskell-TH-Quote.html#t:QuasiQuoter">Language.Haskell.TH.Quote.QuasiQuoter</a>, which is defined thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">QuasiQuoter</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">QuasiQuoter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">quoteExp</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="kt">Exp</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">quotePat</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="kt">Pat</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">quoteType</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="kt">Type</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">quoteDec</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">[</span><span class="kt">Dec</span><span class="p">]</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>That is, a quoter is a tuple of four parsers, one for each of the
contexts in which a quasi-quote can occur.</p>
</li>
<li><p>A quasi-quote is expanded by applying the appropriate parser to the
string enclosed by the Oxford brackets. The context of the
quasi-quote (expression, pattern, type, declaration) determines which
of the parsers is called.</p></li>
<li><p>Unlike normal declaration splices of the form <code class="docutils literal notranslate"><span class="pre">$(...)</span></code>, declaration
quasi-quotes do not cause a declaration group break. See
<a class="reference internal" href="#th-syntax"><span class="std std-ref">Syntax</span></a> for more information.</p></li>
</ul>
<div class="admonition warning" id="quasi-quotes-list-comprehension-ambiguity">
<p class="admonition-title">Warning</p>
<p id="index-2"><a class="reference internal" href="#extension-QuasiQuotes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">QuasiQuotes</span></code></a> introduces an unfortunate ambiguity with list
comprehension syntax. Consider the following,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="o">|</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="p">]]</span><span class="w"></span>
</pre></div>
</div>
<p>Without <a class="reference internal" href="#extension-QuasiQuotes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">QuasiQuotes</span></code></a> this is parsed as a list comprehension.
With <a class="reference internal" href="#extension-QuasiQuotes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">QuasiQuotes</span></code></a> this is parsed as a quasi-quote; however,
this parse will fail due to the lack of a closing <code class="docutils literal notranslate"><span class="pre">|]</span></code>. See
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/11679">#11679</a>.</p>
</div>
<p>The example below shows quasi-quotation in action. The quoter <code class="docutils literal notranslate"><span class="pre">expr</span></code>
is bound to a value of type <code class="docutils literal notranslate"><span class="pre">QuasiQuoter</span></code> defined in module <code class="docutils literal notranslate"><span class="pre">Expr</span></code>.
The example makes use of an antiquoted variable <code class="docutils literal notranslate"><span class="pre">n</span></code>, indicated by the
syntax <code class="docutils literal notranslate"><span class="pre">'int:n</span></code> (this syntax for anti-quotation was defined by the
parser’s author, <em>not</em> by GHC). This binds <code class="docutils literal notranslate"><span class="pre">n</span></code> to the integer value
argument of the constructor <code class="docutils literal notranslate"><span class="pre">IntExpr</span></code> when pattern matching. Please
see the referenced paper for further details regarding anti-quotation as
well as the description of a technique that uses SYB to leverage a
single parser of type <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> to generate both an expression
parser that returns a value of type <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">Exp</span></code> and a pattern parser that
returns a value of type <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">Pat</span></code>.</p>
<p>Quasiquoters must obey the same stage restrictions as Template Haskell,
e.g., in the example, <code class="docutils literal notranslate"><span class="pre">expr</span></code> cannot be defined in <code class="docutils literal notranslate"><span class="pre">Main.hs</span></code> where it
is used, but must be imported.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{- ------------- file Main.hs --------------- -}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">Main</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Expr</span><span class="w"></span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">eval</span><span class="w"> </span><span class="p">[</span><span class="n">expr</span><span class="o">|</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="o">|</span><span class="p">]</span><span class="w"></span>
<span class="w">          </span><span class="p">;</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="kt">IntExpr</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">              </span><span class="p">{</span><span class="w"> </span><span class="p">[</span><span class="n">expr</span><span class="o">|</span><span class="n">&#39;int</span><span class="kt">:</span><span class="n">n</span><span class="o">|</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">              </span><span class="p">;</span><span class="w">  </span><span class="kr">_</span><span class="w">              </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">              </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>


<span class="cm">{- ------------- file Expr.hs --------------- -}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">Expr</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">import</span><span class="w"> </span><span class="k">qualified</span><span class="w"> </span><span class="nn">Language.Haskell.TH</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">TH</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Language.Haskell.TH.Quote</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Expr</span><span class="w">  </span><span class="ow">=</span><span class="w">  </span><span class="kt">IntExpr</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="w">           </span><span class="o">|</span><span class="w">  </span><span class="kt">AntiIntExpr</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">           </span><span class="o">|</span><span class="w">  </span><span class="kt">BinopExpr</span><span class="w"> </span><span class="kt">BinOp</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="kt">Expr</span><span class="w"></span>
<span class="w">           </span><span class="o">|</span><span class="w">  </span><span class="kt">AntiExpr</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">    </span><span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Typeable</span><span class="p">,</span><span class="w"> </span><span class="kt">Data</span><span class="p">)</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">BinOp</span><span class="w">  </span><span class="ow">=</span><span class="w">  </span><span class="kt">AddOp</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w">  </span><span class="kt">SubOp</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w">  </span><span class="kt">MulOp</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w">  </span><span class="kt">DivOp</span><span class="w"></span>
<span class="w">    </span><span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Typeable</span><span class="p">,</span><span class="w"> </span><span class="kt">Data</span><span class="p">)</span><span class="w"></span>

<span class="nf">eval</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="nf">eval</span><span class="w"> </span><span class="p">(</span><span class="kt">IntExpr</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">        </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="nf">eval</span><span class="w"> </span><span class="p">(</span><span class="kt">BinopExpr</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">opToFun</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">eval</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">eval</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">opToFun</span><span class="w"> </span><span class="kt">AddOp</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">opToFun</span><span class="w"> </span><span class="kt">SubOp</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">opToFun</span><span class="w"> </span><span class="kt">MulOp</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">opToFun</span><span class="w"> </span><span class="kt">DivOp</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">div</span><span class="w"></span>

<span class="nf">expr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">QuasiQuoter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">quoteExp</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">parseExprExp</span><span class="p">,</span><span class="w"> </span><span class="n">quotePat</span><span class="w"> </span><span class="ow">=</span><span class="w">  </span><span class="n">parseExprPat</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="c1">-- Parse an Expr, returning its representation as</span><span class="w"></span>
<span class="c1">-- either a Q Exp or a Q Pat. See the referenced paper</span><span class="w"></span>
<span class="c1">-- for how to use SYB to do this by writing a single</span><span class="w"></span>
<span class="c1">-- parser of type String -&gt; Expr instead of two</span><span class="w"></span>
<span class="c1">-- separate parsers.</span><span class="w"></span>

<span class="nf">parseExprExp</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="kt">Exp</span><span class="w"></span>
<span class="nf">parseExprExp</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="nf">parseExprPat</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="kt">Pat</span><span class="w"></span>
<span class="nf">parseExprPat</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Now run the compiler:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ghc --make -XQuasiQuotes Main.hs -o main
</pre></div>
</div>
<p>Run “main” and here is your output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./main
3
1
</pre></div>
</div>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="strict.html" class="btn btn-neutral float-right" title="6.14. Bang patterns and Strict Haskell" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="let_generalisation.html" class="btn btn-neutral float-left" title="6.12.2. Let-generalisation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
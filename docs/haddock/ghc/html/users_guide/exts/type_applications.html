

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.4.14. Visible type application &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.4.15. Arbitrary-rank polymorphism" href="rank_polymorphism.html" />
    <link rel="prev" title="6.4.13. Type-Level Literals" href="type_literals.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="types.html">6.4. Types</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="nullary_types.html">6.4.1. Data types with no constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatype_contexts.html">6.4.2. Data type contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="infix_tycons.html">6.4.3. Infix type constructors, classes, and type variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_operators.html">6.4.4. Type operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="liberal_type_synonyms.html">6.4.5. Liberalised type synonyms</a></li>
<li class="toctree-l3"><a class="reference internal" href="existential_quantification.html">6.4.6. Existentially quantified data constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadt_syntax.html">6.4.7. Declaring data types with explicit constructor signatures</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadt.html">6.4.8. Generalised Algebraic Data Types (GADTs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_families.html">6.4.9. Type families</a></li>
<li class="toctree-l3"><a class="reference internal" href="data_kinds.html">6.4.10. Datatype promotion</a></li>
<li class="toctree-l3"><a class="reference internal" href="poly_kinds.html">6.4.11. Kind polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="levity_polymorphism.html">6.4.12. Levity polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_literals.html">6.4.13. Type-Level Literals</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.4.14. Visible type application</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#inferred-vs-specified-type-variables">6.4.14.1. Inferred vs. specified type variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ordering-of-specified-variables">6.4.14.2. Ordering of specified variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#manually-defining-inferred-variables">6.4.14.3. Manually defining inferred variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-applications-in-patterns">6.4.14.4. Type Applications in Patterns</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rank_polymorphism.html">6.4.15. Arbitrary-rank polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="impredicative_types.html">6.4.16. Impredicative polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="linear_types.html">6.4.17. Linear types</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_errors.html">6.4.18. Custom compile-time errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="defer_type_errors.html">6.4.19. Deferring type errors to runtime</a></li>
<li class="toctree-l3"><a class="reference internal" href="roles.html">6.4.20. Roles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="types.html"><span class="section-number">6.4. </span>Types</a> &raquo;</li>
        
      <li><span class="section-number">6.4.14. </span>Visible type application</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/type_applications.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="visible-type-application">
<span id="id1"></span><h1><span class="section-number">6.4.14. </span>Visible type application<a class="headerlink" href="#visible-type-application" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-TypeApplications">
<span id="ghc-flag--XTypeApplications"></span><span id="extension-NoTypeApplications"></span><span class="sig-name descname"><span class="pre">TypeApplications</span></span><a class="headerlink" href="#extension-TypeApplications" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>8.0.1</p>
</dd>
</dl>
<p>Allow the use of type application syntax.</p>
</dd></dl>

<p>The <a class="reference internal" href="#extension-TypeApplications"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TypeApplications</span></code></a> extension allows you to use
<em>visible type application</em> in expressions. Here is an
example: <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">(read</span> <span class="pre">&#64;Int</span> <span class="pre">&quot;5&quot;)</span></code>. The <code class="docutils literal notranslate"><span class="pre">&#64;Int</span></code>
is the visible type application; it specifies the value of the type variable
in <code class="docutils literal notranslate"><span class="pre">read</span></code>’s type.</p>
<p>A visible type application is preceded with an <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>
sign. (To disambiguate the syntax, the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> must be
preceded with a non-identifier letter, usually a space. For example,
<code class="docutils literal notranslate"><span class="pre">read&#64;Int</span> <span class="pre">5</span></code> would not parse.) It can be used whenever
the full polymorphic type of the function is known. If the function
is an identifier (the common case), its type is considered known only when
the identifier has been given a type signature. If the identifier does
not have a type signature, visible type application cannot be used.</p>
<p>GHC also permits visible kind application, where users can declare the kind
arguments to be instantiated in kind-polymorphic cases. Its usage parallels
visible type application in the term level, as specified above.</p>
<p>In addition to visible type application in terms and types, the type application
syntax can be used in patterns matching a data constructor to bind type variables
in that constructor’s type.</p>
<section id="inferred-vs-specified-type-variables">
<span id="inferred-vs-specified"></span><h2><span class="section-number">6.4.14.1. </span>Inferred vs. specified type variables<a class="headerlink" href="#inferred-vs-specified-type-variables" title="Permalink to this heading">¶</a></h2>
<p id="index-0">GHC tracks a distinction between what we call <em>inferred</em> and <em>specified</em>
type variables. Only specified type variables are available for instantiation
with visible type application. An example illustrates this well:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>

<span class="nf">g</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The functions <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> have the same body, but only <code class="docutils literal notranslate"><span class="pre">f</span></code> is given
a type signature. When GHC is figuring out how to process a visible type application,
it must know what variable to instantiate. It thus must be able to provide
an ordering to the type variables in a function’s type.</p>
<p>If the user has supplied a type signature, as in <code class="docutils literal notranslate"><span class="pre">f</span></code>, then this is easy:
we just take the ordering from the type signature, going left to right and
using the first occurrence of a variable to choose its position within the
ordering. Thus, the variables in <code class="docutils literal notranslate"><span class="pre">f</span></code> will be <code class="docutils literal notranslate"><span class="pre">b</span></code>, then <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>In contrast, there is no reliable way to do this for <code class="docutils literal notranslate"><span class="pre">g</span></code>; we will not know
whether <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">b</span></code> will be listed first in the constraint in <code class="docutils literal notranslate"><span class="pre">g</span></code>'s
type. In order to have visible type application be robust between releases of
GHC, we thus forbid its use with <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p>
<p>We say that the type variables in <code class="docutils literal notranslate"><span class="pre">f</span></code> are <em>specified</em>, while those in
<code class="docutils literal notranslate"><span class="pre">g</span></code> are <em>inferred</em>. The general rule is this: if the user has written
a type variable in the source program, it is <em>specified</em>; if not, it is
<em>inferred</em>.</p>
<p>This rule applies in datatype declarations, too. For example, if we have
<code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">Proxy</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Proxy</span></code> (and <a class="reference internal" href="poly_kinds.html#extension-PolyKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PolyKinds</span></code></a> is enabled), then
<code class="docutils literal notranslate"><span class="pre">a</span></code> will be assigned kind <code class="docutils literal notranslate"><span class="pre">k</span></code>, where <code class="docutils literal notranslate"><span class="pre">k</span></code> is a fresh kind variable.
Because <code class="docutils literal notranslate"><span class="pre">k</span></code> was not written by the user, it will be unavailable for
type application in the type of the constructor <code class="docutils literal notranslate"><span class="pre">Proxy</span></code>; only the <code class="docutils literal notranslate"><span class="pre">a</span></code>
will be available.</p>
<p>Inferred variables are printed in braces. Thus, the type of the data
constructor <code class="docutils literal notranslate"><span class="pre">Proxy</span></code> from the previous example is
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">{k}</span> <span class="pre">(a</span> <span class="pre">::</span> <span class="pre">k).</span> <span class="pre">Proxy</span> <span class="pre">a</span></code>.
We can observe this behavior in a GHCi session:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>&gt; :set -XTypeApplications -fprint-explicit-foralls
&gt; let myLength1 :: Foldable f =&gt; f a -&gt; Int; myLength1 = length
&gt; :type +v myLength1
myLength1 :: forall (f :: * -&gt; *) a. Foldable f =&gt; f a -&gt; Int
&gt; let myLength2 = length
&gt; :type +v myLength2
myLength2 :: forall {a} {t :: * -&gt; *}. Foldable t =&gt; t a -&gt; Int
&gt; :type +v myLength2 @[]

&lt;interactive&gt;:1:1: error:
    • Cannot apply expression of type ‘t0 a0 -&gt; Int’
      to a visible type argument ‘[]’
    • In the expression: myLength2 @[]
</pre></div>
</div>
<p>Notice that since <code class="docutils literal notranslate"><span class="pre">myLength1</span></code> was defined with an explicit type signature,
<a class="reference internal" href="../ghci.html#ghci-cmd-type-v"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:type</span> <span class="pre">+v</span></code></a> reports that all of its type variables are available
for type application. On the other hand, <code class="docutils literal notranslate"><span class="pre">myLength2</span></code> was not given a type
signature. As a result, all of its type variables are surrounded with braces,
and trying to use visible type application with <code class="docutils literal notranslate"><span class="pre">myLength2</span></code> fails.</p>
<p>Also note the use of <a class="reference internal" href="../ghci.html#ghci-cmd-type-v"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:type</span> <span class="pre">+v</span></code></a> in the GHCi session above instead
of <a class="reference internal" href="../ghci.html#ghci-cmd-type"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:type</span></code></a>. This is because <a class="reference internal" href="../ghci.html#ghci-cmd-type"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:type</span></code></a> gives you the type
that would be inferred for a variable assigned to the expression provided
(that is, the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> in <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">&lt;expr&gt;</span></code>). As we saw above with
<code class="docutils literal notranslate"><span class="pre">myLength2</span></code>, this type will have no variables available to visible type
application. On the other hand, <a class="reference internal" href="../ghci.html#ghci-cmd-type-v"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:type</span> <span class="pre">+v</span></code></a> gives you the actual
type of the expression provided. To illustrate this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="kr">type</span><span class="w"> </span><span class="n">myLength1</span><span class="w"></span>
<span class="nf">myLength1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">*</span><span class="p">}</span><span class="o">.</span><span class="w"> </span><span class="kt">Foldable</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="kr">type</span><span class="w"> </span><span class="n">myLength2</span><span class="w"></span>
<span class="nf">myLength2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="n">t</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">*</span><span class="p">}</span><span class="o">.</span><span class="w"> </span><span class="kt">Foldable</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>Using <a class="reference internal" href="../ghci.html#ghci-cmd-type"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:type</span></code></a> might lead one to conclude that none of the type
variables in <code class="docutils literal notranslate"><span class="pre">myLength1</span></code>’s type signature are available for type
application. This isn’t true, however! Be sure to use <a class="reference internal" href="../ghci.html#ghci-cmd-type-v"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:type</span> <span class="pre">+v</span></code></a>
if you want the most accurate information with respect to visible type
application properties.</p>
</section>
<section id="ordering-of-specified-variables">
<span id="scopedsort"></span><span id="index-1"></span><h2><span class="section-number">6.4.14.2. </span>Ordering of specified variables<a class="headerlink" href="#ordering-of-specified-variables" title="Permalink to this heading">¶</a></h2>
<p>In the simple case of the previous section, we can say that specified variables
appear in left-to-right order. However, not all cases are so simple. Here are
the rules in the subtler cases:</p>
<ul>
<li><p>If an identifier’s type has a <code class="docutils literal notranslate"><span class="pre">forall</span></code>, then the order of type variables
as written in the <code class="docutils literal notranslate"><span class="pre">forall</span></code> is retained.</p></li>
<li><p>If any of the variables depend on other variables (that is, if some
of the variables are <em>kind</em> variables), the variables are reordered
so that kind variables come before type variables, preserving the
left-to-right order as much as possible. That is, GHC performs a
stable topological sort on the variables. Example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">h</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">))</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- as if h :: forall j k a b. ...</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">a</span></code> depends on <code class="docutils literal notranslate"><span class="pre">j</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span></code>, and <code class="docutils literal notranslate"><span class="pre">b</span></code> depends on <code class="docutils literal notranslate"><span class="pre">a</span></code>.
Even though <code class="docutils literal notranslate"><span class="pre">a</span></code> appears lexically before <code class="docutils literal notranslate"><span class="pre">j</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span></code>
are quantified first, because <code class="docutils literal notranslate"><span class="pre">a</span></code> depends on <code class="docutils literal notranslate"><span class="pre">j</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span></code>. Note further
that <code class="docutils literal notranslate"><span class="pre">j</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span></code> are not reordered with respect to each other, even
though doing so would not violate dependency conditions.</p>
<p>A “stable topological sort” here, we mean that we perform this algorithm
(which we call <em>ScopedSort</em>):</p>
<ul class="simple">
<li><p>Work left-to-right through the input list of type variables, with a cursor.</p></li>
<li><p>If variable <code class="docutils literal notranslate"><span class="pre">v</span></code> at the cursor is depended on by any earlier variable <code class="docutils literal notranslate"><span class="pre">w</span></code>,
move <code class="docutils literal notranslate"><span class="pre">v</span></code> immediately before the leftmost such <code class="docutils literal notranslate"><span class="pre">w</span></code>.</p></li>
</ul>
</li>
<li><p>Class methods’ type arguments include the class type
variables, followed by any variables an individual method is polymorphic
in. So, <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Monad</span> <span class="pre">m</span> <span class="pre">where</span> <span class="pre">return</span> <span class="pre">::</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code> means
that <code class="docutils literal notranslate"><span class="pre">return</span></code>’s type arguments are <code class="docutils literal notranslate"><span class="pre">m,</span> <span class="pre">a</span></code>.</p></li>
<li><p>With the <a class="reference internal" href="rank_polymorphism.html#extension-RankNTypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">RankNTypes</span></code></a> extension
(<a class="reference internal" href="scoped_type_variables.html#universal-quantification"><span class="std std-ref">Lexically scoped type variables</span></a>), it is possible to declare
type arguments somewhere other than the beginning of a type. For example,
we can have <code class="docutils literal notranslate"><span class="pre">pair</span> <span class="pre">::</span> <span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">forall</span> <span class="pre">b.</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">(a,</span> <span class="pre">b)</span></code>
and then say <code class="docutils literal notranslate"><span class="pre">pair</span> <span class="pre">&#64;Bool</span> <span class="pre">True</span> <span class="pre">&#64;Char</span></code> which would have
type <code class="docutils literal notranslate"><span class="pre">Char</span> <span class="pre">-&gt;</span> <span class="pre">(Bool,</span> <span class="pre">Char)</span></code>.</p></li>
<li><p>Partial type signatures (<a class="reference internal" href="partial_type_signatures.html#partial-type-signatures"><span class="std std-ref">Partial Type Signatures</span></a>)
work nicely with visible type
application. If you want to specify only the second type argument to
<code class="docutils literal notranslate"><span class="pre">wurble</span></code>, then you can say <code class="docutils literal notranslate"><span class="pre">wurble</span> <span class="pre">&#64;_</span> <span class="pre">&#64;Int</span></code>.
The first argument is a wildcard, just like in a partial type signature.
However, if used in a visible type application/visible kind application,
it is <em>not</em> necessary to specify <a class="reference internal" href="partial_type_signatures.html#extension-PartialTypeSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PartialTypeSignatures</span></code></a> and your
code will not generate a warning informing you of the omitted type.</p></li>
</ul>
<p>The section in this manual on kind polymorphism describes how variables
in type and class declarations are ordered (<a class="reference internal" href="poly_kinds.html#inferring-variable-order"><span class="std std-ref">Inferring the order of variables in a type/class declaration</span></a>).</p>
</section>
<section id="manually-defining-inferred-variables">
<span id="id2"></span><h2><span class="section-number">6.4.14.3. </span>Manually defining inferred variables<a class="headerlink" href="#manually-defining-inferred-variables" title="Permalink to this heading">¶</a></h2>
<p>While user-written type or kind variables are specified by default, GHC permits
labelling these variables as inferred. By writing the type variable binder in
braces as <code class="docutils literal notranslate"><span class="pre">{tyvar}</span></code> or <code class="docutils literal notranslate"><span class="pre">{tyvar</span> <span class="pre">::</span> <span class="pre">kind}</span></code>, the new variable will be
classified as inferred, not specified. Doing so gives the programmer control
over which variables can be manually instantiated and which can’t.
Note that the braces do not influence scoping: variables in braces are still
brought into scope just the same.
Consider for example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myConst</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">myConst</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, despite both variables appearing in a type signature, <code class="docutils literal notranslate"><span class="pre">a</span></code> is
an inferred variable while <code class="docutils literal notranslate"><span class="pre">b</span></code> is specified. This means that the expression
<code class="docutils literal notranslate"><span class="pre">myConst</span> <span class="pre">&#64;Int</span></code> has type <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">{a}.</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>.</p>
<p>The braces are allowed in the following places:</p>
<ul>
<li><p>In the type signatures of functions, variables, class methods, as well as type
annotations on expressions. Consider the example above.</p></li>
<li><p>In data constructor declarations, using the GADT syntax. Consider:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">k</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>The constructor <code class="docutils literal notranslate"><span class="pre">MkT</span></code> defined in this example is kind polymorphic, which is
emphasized to the reader by explicitly abstracting over the <code class="docutils literal notranslate"><span class="pre">k</span></code> variable.
As this variable is marked as inferred, it can not be manually instantiated.</p>
</li>
<li><p>In existential variable quantifications, e.g.:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">HList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">HNil</span><span class="w"></span>
<span class="w">           </span><span class="o">|</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="o">.</span><span class="w"> </span><span class="kt">HCons</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kt">HList</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>In pattern synonym signatures. Consider for instance:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="nf">pattern</span><span class="w"> </span><span class="kt">Pat</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="p">}</span><span class="o">.</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">d</span><span class="p">}</span><span class="o">.</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">Pat</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
<p>Note that in this example, <code class="docutils literal notranslate"><span class="pre">a</span></code> is a universal variable in the data type
<code class="docutils literal notranslate"><span class="pre">T</span></code>, where <code class="docutils literal notranslate"><span class="pre">b</span></code> is existential. When writing the pattern synonym, both
types are allowed to be specified or inferred.</p>
</li>
<li><p>On the right-hand side of a type synonym, e.g.:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">{</span><span class="n">b</span><span class="p">}</span><span class="o">.</span><span class="w"> </span><span class="kt">Either</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>In type signatures on variables bound in RULES, e.g.:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# RULES &quot;parametricity&quot; forall (f :: forall {a}. a -&gt; a). map f = id #-}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
<p>The braces are <em>not</em> allowed in the following places:</p>
<ul>
<li><p>In visible dependent quantifiers. Consider:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">k</span><span class="p">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
</pre></div>
</div>
<p>This example is rejected, as a visible argument should by definition be
explicitly applied. Making them inferred (and thus not appliable) would be
conflicting.</p>
</li>
<li><p>In SPECIALISE pragmas or in instance declaration heads, e.g.:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="o">.</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>The reason for this is, essentially, that none of these define a new
construct. This means that no new type is being defined where specificity
could play a role.</p>
</li>
<li><p>On the left-hand sides of type declarations, such as classes, data types, etc.</p></li>
</ul>
<p>Note that while specified and inferred type variables have different properties
vis-à-vis visible type application, they do not otherwise affect GHC’s notion
of equality over types. For example, given the following definitions:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">id1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">id1</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="nf">id2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="o">.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">id2</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="nf">app1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">app1</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="nf">app2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="o">.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">app2</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>GHC will deem all of <code class="docutils literal notranslate"><span class="pre">app1</span> <span class="pre">id1</span></code>, <code class="docutils literal notranslate"><span class="pre">app1</span> <span class="pre">id2</span></code>, <code class="docutils literal notranslate"><span class="pre">app2</span> <span class="pre">id1</span></code>, and <code class="docutils literal notranslate"><span class="pre">app2</span> <span class="pre">id2</span></code>
to be well typed.</p>
</section>
<section id="type-applications-in-patterns">
<span id="id3"></span><h2><span class="section-number">6.4.14.4. </span>Type Applications in Patterns<a class="headerlink" href="#type-applications-in-patterns" title="Permalink to this heading">¶</a></h2>
<p>The type application syntax can be used in patterns that match a data
constructor. The syntax can’t be used with record patterns or infix patterns.
This is useful in particular to bind existential type variables associated with
a GADT data constructor as in the following example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE AllowAmbiguousTypes #-}</span><span class="w"></span>
<span class="cm">{-# LANGUAGE GADTs #-}</span><span class="w"></span>
<span class="cm">{-# LANGUAGE RankNTypes #-}</span><span class="w"></span>
<span class="cm">{-# LANGUAGE TypeApplications #-}</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Data.Proxy</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Foo</span><span class="w"></span>

<span class="nf">test</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">test</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">  </span><span class="kt">Foo</span><span class="w"> </span><span class="o">@</span><span class="n">t</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="o">@</span><span class="n">t</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="p">(</span><span class="kt">Foo</span><span class="w"> </span><span class="o">@</span><span class="kt">Float</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, the case in <code class="docutils literal notranslate"><span class="pre">test`</span></code> is binding an existential variable introduced
by <code class="docutils literal notranslate"><span class="pre">Foo</span></code> that otherwise could not be named and used.</p>
<p>It’s possible to bind variables to any part of the type arguments to a constructor;
there is no need for them to be existential. In addition, it’s possible to “match” against
part of the type argument using type constructors.</p>
<p>For a somewhat-contrived example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="kt">Nothing</span><span class="w"> </span><span class="o">@</span><span class="p">[</span><span class="n">t</span><span class="p">])</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="o">@</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Here, we’re binding the type variable t to be the type of the elements of the list type
which is itself the argument to Maybe.</p>
<p>The order of the type arguments specified by the type applications in a pattern is the same
as that for an expression: either the order as given by the user in an explicit <code class="docutils literal notranslate"><span class="pre">forall</span></code> in the
definition of the data constructor, or if that is not present, the order in which the type
variables appear in its type signature from left to right.</p>
<p>For example if we have the following declaration in GADT syntax:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">A</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">t</span><span class="o">.</span><span class="w"> </span><span class="p">[(</span><span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="p">)]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kt">B</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Then the type arguments to <code class="docutils literal notranslate"><span class="pre">A</span></code> will match first <code class="docutils literal notranslate"><span class="pre">s</span></code> and then <code class="docutils literal notranslate"><span class="pre">t</span></code>, while the type arguments
to <code class="docutils literal notranslate"><span class="pre">B</span></code> will match first <code class="docutils literal notranslate"><span class="pre">t</span></code> and then <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<p>Type arguments appearing in patterns can influence the inferred type of a definition:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="kt">Nothing</span><span class="w"> </span><span class="o">@</span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>will have inferred type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>which is more restricted than what it would be without the application:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>For more information and detail regarding type applications in patterns, see the paper
<a class="reference external" href="https://arxiv.org/pdf/1806.03476">Type variables in patterns</a> by Eisenberg, Breitner
and Peyton Jones. Relative to that paper, the implementation in GHC for now at least makes one
additional conservative restriction, that type variables occurring in patterns must not
already be in scope, and so are always new variables that only bind whatever type is
matched, rather than ever referring to a variable from an outer scope. Type wildcards
<code class="docutils literal notranslate"><span class="pre">_</span></code> may be used in any place where no new variable needs binding.</p>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="rank_polymorphism.html" class="btn btn-neutral float-right" title="6.4.15. Arbitrary-rank polymorphism" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="type_literals.html" class="btn btn-neutral float-left" title="6.4.13. Type-Level Literals" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.4.9. Type families &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.4.10. Datatype promotion" href="data_kinds.html" />
    <link rel="prev" title="6.4.8. Generalised Algebraic Data Types (GADTs)" href="gadt.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="types.html">6.4. Types</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="nullary_types.html">6.4.1. Data types with no constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatype_contexts.html">6.4.2. Data type contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="infix_tycons.html">6.4.3. Infix type constructors, classes, and type variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_operators.html">6.4.4. Type operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="liberal_type_synonyms.html">6.4.5. Liberalised type synonyms</a></li>
<li class="toctree-l3"><a class="reference internal" href="existential_quantification.html">6.4.6. Existentially quantified data constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadt_syntax.html">6.4.7. Declaring data types with explicit constructor signatures</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadt.html">6.4.8. Generalised Algebraic Data Types (GADTs)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.4.9. Type families</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#data-families">6.4.9.1. Data families</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synonym-families">6.4.9.2. Synonym families</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wildcards-on-the-lhs-of-data-and-type-family-instances">6.4.9.3. Wildcards on the LHS of data and type family instances</a></li>
<li class="toctree-l4"><a class="reference internal" href="#associated-data-and-type-families">6.4.9.4. Associated data and type families</a></li>
<li class="toctree-l4"><a class="reference internal" href="#import-and-export">6.4.9.5. Import and export</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-families-and-instance-declarations">6.4.9.6. Type families and instance declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#injective-type-families">6.4.9.7. Injective type families</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="data_kinds.html">6.4.10. Datatype promotion</a></li>
<li class="toctree-l3"><a class="reference internal" href="poly_kinds.html">6.4.11. Kind polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="levity_polymorphism.html">6.4.12. Levity polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_literals.html">6.4.13. Type-Level Literals</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_applications.html">6.4.14. Visible type application</a></li>
<li class="toctree-l3"><a class="reference internal" href="rank_polymorphism.html">6.4.15. Arbitrary-rank polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="impredicative_types.html">6.4.16. Impredicative polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="linear_types.html">6.4.17. Linear types</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_errors.html">6.4.18. Custom compile-time errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="defer_type_errors.html">6.4.19. Deferring type errors to runtime</a></li>
<li class="toctree-l3"><a class="reference internal" href="roles.html">6.4.20. Roles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="types.html"><span class="section-number">6.4. </span>Types</a> &raquo;</li>
        
      <li><span class="section-number">6.4.9. </span>Type families</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/type_families.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="type-families">
<span id="id1"></span><h1><span class="section-number">6.4.9. </span>Type families<a class="headerlink" href="#type-families" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-TypeFamilies">
<span id="ghc-flag--XTypeFamilies"></span><span id="extension-NoTypeFamilies"></span><span class="sig-name descname"><span class="pre">TypeFamilies</span></span><a class="headerlink" href="#extension-TypeFamilies" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Implies<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="let_generalisation.html#extension-MonoLocalBinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">MonoLocalBinds</span></code></a>, <a class="reference internal" href="kind_signatures.html#extension-KindSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">KindSignatures</span></code></a>,
<a class="reference internal" href="explicit_namespaces.html#extension-ExplicitNamespaces"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExplicitNamespaces</span></code></a></p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>6.8.1</p>
</dd>
</dl>
<p>Allow use and definition of indexed type and data families.</p>
</dd></dl>

<p>Indexed type families form an extension to facilitate type-level
programming. Type families are a generalisation of associated data types
<a class="reference internal" href="#assocdatatypes2005" id="id2"><span>[AssocDataTypes2005]</span></a> and associated type synonyms
<a class="reference internal" href="#assoctypesyn2005" id="id3"><span>[AssocTypeSyn2005]</span></a> Type families themselves are described in
Schrijvers 2008 <a class="reference internal" href="#typefamilies2008" id="id4"><span>[TypeFamilies2008]</span></a>. Type families essentially provide
type-indexed data types and named functions on types, which are useful for
generic programming and highly parameterised library interfaces as well as
interfaces with enhanced static information, much like dependent types. They
might also be regarded as an alternative to functional dependencies, but provide
a more functional style of type-level programming than the relational style of
functional dependencies.</p>
<p>Indexed type families, or type families for short, are type constructors
that represent sets of types. Set members are denoted by supplying the
type family constructor with type parameters, which are called type
indices. The difference between vanilla parametrised type constructors
and family constructors is much like between parametrically polymorphic
functions and (ad-hoc polymorphic) methods of type classes. Parametric
polymorphic functions behave the same at all type instances, whereas
class methods can change their behaviour in dependence on the class type
parameters. Similarly, vanilla type constructors imply the same data
representation for all type instances, but family constructors can have
varying representation types for varying type indices.</p>
<p>Indexed type families come in three flavours: data families, open type
synonym families, and closed type synonym families. They are the indexed
family variants of algebraic data types and type synonyms, respectively.
The instances of data families can be data types and newtypes.</p>
<p>Type families are enabled by the language extension <a class="reference internal" href="#extension-TypeFamilies"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TypeFamilies</span></code></a>. Additional
information on the use of type families in GHC is available on <a class="reference external" href="http://www.haskell.org/haskellwiki/GHC/Indexed_types">the
Haskell wiki page on type
families</a>.</p>
<div role="list" class="citation-list">
<div class="citation" id="assocdatatypes2005" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">AssocDataTypes2005</a><span class="fn-bracket">]</span></span>
<p>“<a class="reference external" href="http://www.cse.unsw.edu.au/~chak/papers/CKPM05.html">Associated Types with Class</a>”, M.
Chakravarty, G. Keller, S. Peyton Jones,
and S. Marlow. In Proceedings of “The 32nd Annual
ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages (POPL’05)”, pages 1-13, ACM
Press, 2005.</p>
</div>
<div class="citation" id="assoctypesyn2005" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">AssocTypeSyn2005</a><span class="fn-bracket">]</span></span>
<p>“<a class="reference external" href="http://www.cse.unsw.edu.au/~chak/papers/CKP05.html">Type Associated Type
Synonyms</a>”. M.
Chakravarty, G. Keller, and S. Peyton Jones. In Proceedings of “The
Tenth ACM SIGPLAN International Conference on Functional Programming”,
ACM Press, pages 241-253, 2005.</p>
</div>
<div class="citation" id="typefamilies2008" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">TypeFamilies2008</a><span class="fn-bracket">]</span></span>
<p>“<a class="reference external" href="http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html">Type Checking with Open Type
Functions</a>”,
T. Schrijvers, S. Peyton-Jones, M. Chakravarty, and M. Sulzmann, in
Proceedings of “ICFP 2008: The 13th ACM SIGPLAN International Conference
on Functional Programming”, ACM Press, pages 51-62, 2008.</p>
</div>
</div>
<section id="data-families">
<span id="id5"></span><h2><span class="section-number">6.4.9.1. </span>Data families<a class="headerlink" href="#data-families" title="Permalink to this heading">¶</a></h2>
<p>Data families appear in two flavours: (1) they can be defined on the
toplevel or (2) they can appear inside type classes (in which case they
are known as associated types). The former is the more general variant,
as it lacks the requirement for the type-indexes to coincide with the
class parameters. However, the latter can lead to more clearly
structured code and compiler warnings if some type instances were -
possibly accidentally - omitted. In the following, we always discuss the
general toplevel form first and then cover the additional constraints
placed on associated types.</p>
<section id="data-family-declarations">
<span id="id6"></span><h3><span class="section-number">6.4.9.1.1. </span>Data family declarations<a class="headerlink" href="#data-family-declarations" title="Permalink to this heading">¶</a></h3>
<p>Indexed data families are introduced by a signature, such as</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">GMap</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
</pre></div>
</div>
<p>The special <code class="docutils literal notranslate"><span class="pre">family</span></code> distinguishes family from standard data
declarations. The result kind annotation is optional and, as usual,
defaults to <code class="docutils literal notranslate"><span class="pre">Type</span></code> if omitted. An example is</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">Array</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
</pre></div>
</div>
<p>Named arguments can also be given explicit kind signatures if needed.
Just as with <a class="reference internal" href="gadt.html#gadt"><span class="std std-ref">GADT declarations</span></a> named arguments are
entirely optional, so that we can declare <code class="docutils literal notranslate"><span class="pre">Array</span></code> alternatively with</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">Array</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
</pre></div>
</div>
<p>Unlike with ordinary data definitions, the result kind of a data family
does not need to be <code class="docutils literal notranslate"><span class="pre">Type</span></code>. It can alternatively be:</p>
<ul>
<li><p>Of the form <code class="docutils literal notranslate"><span class="pre">TYPE</span> <span class="pre">r</span></code> for some <code class="docutils literal notranslate"><span class="pre">r</span></code> (see <a class="reference internal" href="levity_polymorphism.html#runtime-rep"><span class="std std-ref">Levity polymorphism</span></a>).
For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">DF1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="kt">IntRep</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">DF2</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">RuntimeRep</span><span class="p">)</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="n">r</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">DF3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="kt">WordRep</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>A bare kind variable (with <a class="reference internal" href="poly_kinds.html#extension-PolyKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PolyKinds</span></code></a> enabled).
For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">DF4</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">DF5</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">DF6</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
<p>Data instances’ kinds must end in <code class="docutils literal notranslate"><span class="pre">Type</span></code>, however. This restriction is
slightly relaxed when the <a class="reference internal" href="primitives.html#extension-UnliftedNewtypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedNewtypes</span></code></a> extension is enabled,
as it permits a <code class="docutils literal notranslate"><span class="pre">newtype</span> <span class="pre">instance</span></code>’s kind to end in <code class="docutils literal notranslate"><span class="pre">TYPE</span> <span class="pre">r</span></code> for some
<code class="docutils literal notranslate"><span class="pre">r</span></code>.</p>
</section>
<section id="data-instance-declarations">
<span id="id7"></span><h3><span class="section-number">6.4.9.1.2. </span>Data instance declarations<a class="headerlink" href="#data-instance-declarations" title="Permalink to this heading">¶</a></h3>
<p>Instance declarations of data and newtype families are very similar to
standard data and newtype declarations. The only two differences are
that the keyword <code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">newtype</span></code> is followed by <code class="docutils literal notranslate"><span class="pre">instance</span></code> and
that some or all of the type arguments can be non-variable types, but
may not contain forall types or type synonym families. However, data
families are generally allowed in type parameters, and type synonyms are
allowed as long as they are fully applied and expand to a type that is
itself admissible - exactly as this is required for occurrences of type
synonyms in class instance parameters. For example, the <code class="docutils literal notranslate"><span class="pre">Either</span></code>
instance for <code class="docutils literal notranslate"><span class="pre">GMap</span></code> is</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">GMap</span><span class="w"> </span><span class="p">(</span><span class="kt">Either</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">GMapEither</span><span class="w"> </span><span class="p">(</span><span class="kt">GMap</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">GMap</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, the declaration has only one variant. In general, it
can be any number.</p>
<p>When <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExplicitForAll</span></code></a> is enabled, type and kind variables used on
the left hand side can be explicitly bound. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="p">(</span><span class="kt">Proxy</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">FProxy</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
</pre></div>
</div>
<p>When an explicit <code class="docutils literal notranslate"><span class="pre">forall</span></code> is present, <em>all</em> type and kind variables mentioned
which are not already in scope must be bound by the <code class="docutils literal notranslate"><span class="pre">forall</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="n">forall</span><span class="w">   </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">FOtherwise</span><span class="w">  </span><span class="c1">-- rejected: k not in scope</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">FOtherwise</span><span class="w">  </span><span class="c1">-- accepted</span><span class="w"></span>
</pre></div>
</div>
<p>When the flag <a class="reference internal" href="../using-warnings.html#ghc-flag-Wunused-type-patterns"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wunused-type-patterns</span></code></a> is enabled, type
variables that are mentioned in the patterns on the left hand side, but not
used on the right hand side are reported. Variables that occur multiple times
on the left hand side are also considered used. To suppress the warnings,
unused variables should be either replaced or prefixed with underscores. Type
variables starting with an underscore (<code class="docutils literal notranslate"><span class="pre">_x</span></code>) are otherwise treated as
ordinary type variables.</p>
<p>This resembles the wildcards that can be used in
<a class="reference internal" href="partial_type_signatures.html#partial-type-signatures"><span class="std std-ref">Partial Type Signatures</span></a>. However, there are some differences.
No error messages reporting the inferred types are generated, nor does
the extension <a class="reference internal" href="partial_type_signatures.html#extension-PartialTypeSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PartialTypeSignatures</span></code></a> have any effect.</p>
<p>A type or kind variable explicitly bound using <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExplicitForAll</span></code></a> but
not used on the left hand side will generate an error, not a warning.</p>
<p>Data and newtype instance declarations are only permitted when an
appropriate family declaration is in scope - just as a class instance
declaration requires the class declaration to be visible. Moreover, each
instance declaration has to conform to the kind determined by its family
declaration. This implies that the number of parameters of an instance
declaration matches the arity determined by the kind of the family.</p>
<p>A data family instance declaration can use the full expressiveness of
ordinary <code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">newtype</span></code> declarations:</p>
<ul>
<li><p>Although, a data family is <em>introduced</em> with the keyword “<code class="docutils literal notranslate"><span class="pre">data</span></code>”,
a data family <em>instance</em> can use either <code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">newtype</span></code>. For
example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kr">data</span><span class="w">    </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Int</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Char</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">TC</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">instance</span></code> can use GADT syntax for the data constructors,
and indeed can define a GADT. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="kt">G1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">   </span><span class="kt">G2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>You can use a <code class="docutils literal notranslate"><span class="pre">deriving</span></code> clause on a <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">instance</span></code> or
<code class="docutils literal notranslate"><span class="pre">newtype</span> <span class="pre">instance</span></code> declaration.</p></li>
</ul>
<p>Even if data families are defined as toplevel declarations, functions
that perform different computations for different family instances may
still need to be defined as methods of type classes. In particular, the
following is not possible:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Int</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">A</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Char</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">B</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
</pre></div>
</div>
<p>Instead, you would have to write <code class="docutils literal notranslate"><span class="pre">foo</span></code> as a class operation, thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="kt">Char</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
</pre></div>
</div>
<p>Given the functionality provided by GADTs (Generalised Algebraic Data
Types), it might seem as if a definition, such as the above, should be
feasible. However, type families - in contrast to GADTs - are
<em>open;</em> i.e., new instances can always be added, possibly in other
modules. Supporting pattern matching across different data instances
would require a form of extensible case construct.</p>
</section>
<section id="overlap-of-data-instances">
<span id="data-family-overlap"></span><h3><span class="section-number">6.4.9.1.3. </span>Overlap of data instances<a class="headerlink" href="#overlap-of-data-instances" title="Permalink to this heading">¶</a></h3>
<p>The instance declarations of a data family used in a single program may
not overlap at all, independent of whether they are associated or not.
In contrast to type class instances, this is not only a matter of
consistency, but one of type safety.</p>
</section>
</section>
<section id="synonym-families">
<span id="id8"></span><h2><span class="section-number">6.4.9.2. </span>Synonym families<a class="headerlink" href="#synonym-families" title="Permalink to this heading">¶</a></h2>
<p>Type families appear in three flavours: (1) they can be defined as open
families on the toplevel, (2) they can be defined as closed families on
the toplevel, or (3) they can appear inside type classes (in which case
they are known as associated type synonyms). Toplevel families are more
general, as they lack the requirement for the type-indexes to coincide
with the class parameters. However, associated type synonyms can lead to
more clearly structured code and compiler warnings if some type
instances were - possibly accidentally - omitted. In the following, we
always discuss the general toplevel forms first and then cover the
additional constraints placed on associated types. Note that closed
associated type synonyms do not exist.</p>
<section id="type-family-declarations">
<span id="id9"></span><h3><span class="section-number">6.4.9.2.1. </span>Type family declarations<a class="headerlink" href="#type-family-declarations" title="Permalink to this heading">¶</a></h3>
<p>Open indexed type families are introduced by a signature, such as</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">Elem</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
</pre></div>
</div>
<p>The special <code class="docutils literal notranslate"><span class="pre">family</span></code> distinguishes family from standard type
declarations. The result kind annotation is optional and, as usual,
defaults to <code class="docutils literal notranslate"><span class="pre">Type</span></code> if omitted. An example is</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">Elem</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
<p>Parameters can also be given explicit kind signatures if needed. We call
the number of parameters in a type family declaration, the family’s
arity, and all applications of a type family must be fully saturated
with respect to that arity. This requirement is unlike ordinary type synonyms
and it implies that the kind of a type family is not sufficient to
determine a family’s arity, and hence in general, also insufficient to
determine whether a type family application is well formed. As an
example, consider the following declaration:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- F&#39;s arity is 2,</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- although its overall kind is Type -&gt; Type -&gt; Type -&gt; Type</span><span class="w"></span>
</pre></div>
</div>
<p>Given this declaration the following are examples of well-formed and
malformed types:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">F</span><span class="w"> </span><span class="kt">Char</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w">       </span><span class="c1">-- OK!  Kind: Type -&gt; Type</span><span class="w"></span>
<span class="kt">F</span><span class="w"> </span><span class="kt">Char</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="kt">Bool</span><span class="w">  </span><span class="c1">-- OK!  Kind: Type</span><span class="w"></span>
<span class="kt">F</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Bool</span><span class="w">          </span><span class="c1">-- WRONG: kind mismatch in the first argument</span><span class="w"></span>
<span class="kt">F</span><span class="w"> </span><span class="kt">Bool</span><span class="w">             </span><span class="c1">-- WRONG: unsaturated application</span><span class="w"></span>
</pre></div>
</div>
<p>The result kind annotation is optional and defaults to <code class="docutils literal notranslate"><span class="pre">Type</span></code> (like
argument kinds) if omitted. Polykinded type families can be declared
using a parameter in the kind annotation:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
</pre></div>
</div>
<p>In this case the kind parameter <code class="docutils literal notranslate"><span class="pre">k</span></code> is actually an implicit parameter
of the type family.</p>
<p>At definition site, the arity determines what inputs can be matched on:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">PT</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">PT</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- OK, &#39;k&#39; can be matched on.</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F0</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">PT</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- Error:</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • Expected kind ‘forall k. k -&gt; Type’,</span><span class="w"></span>
<span class="w">  </span><span class="c1">--       but ‘PT’ has kind ‘Type -&gt; Type’</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • In the type ‘PT’</span><span class="w"></span>
<span class="w">  </span><span class="c1">--     In the type instance declaration for ‘F0’</span><span class="w"></span>
</pre></div>
</div>
<p>Both <code class="docutils literal notranslate"><span class="pre">F1</span></code> and <code class="docutils literal notranslate"><span class="pre">F0</span></code> have kind <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">k.</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code>, but their arity
differs.</p>
<p>At use sites, the arity determines if the definition can be used in a
higher-rank scenario:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">HRK</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">Maybe</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">True</span><span class="p">)</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">H1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">HRK</span><span class="w"> </span><span class="kt">F0</span><span class="w">  </span><span class="c1">-- OK</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">H2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">HRK</span><span class="w"> </span><span class="kt">F1</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- Error:</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • Expected kind ‘forall k. k -&gt; Type’,</span><span class="w"></span>
<span class="w">  </span><span class="c1">--       but ‘F1’ has kind ‘k0 -&gt; Type’</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • In the first argument of ‘HRK’, namely ‘F1’</span><span class="w"></span>
<span class="w">  </span><span class="c1">--     In the type ‘HRK F1’</span><span class="w"></span>
<span class="w">  </span><span class="c1">--     In the type declaration for ‘H2’</span><span class="w"></span>
</pre></div>
</div>
<p>This is a consequence of the requirement that all applications of a type family
must be fully saturated with respect to their arity.</p>
</section>
<section id="type-instance-declarations">
<span id="id10"></span><h3><span class="section-number">6.4.9.2.2. </span>Type instance declarations<a class="headerlink" href="#type-instance-declarations" title="Permalink to this heading">¶</a></h3>
<p>Instance declarations of type families are very similar to standard type
synonym declarations. The only two differences are that the keyword
<code class="docutils literal notranslate"><span class="pre">type</span></code> is followed by <code class="docutils literal notranslate"><span class="pre">instance</span></code> and that some or all of the type
arguments can be non-variable types, but may not contain forall types or
type synonym families. However, data families are generally allowed, and
type synonyms are allowed as long as they are fully applied and expand
to a type that is admissible - these are the exact same requirements as
for data instances. For example, the <code class="docutils literal notranslate"><span class="pre">[e]</span></code> instance for <code class="docutils literal notranslate"><span class="pre">Elem</span></code> is</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">Elem</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
</pre></div>
</div>
<p>Type arguments can be replaced with underscores (<code class="docutils literal notranslate"><span class="pre">_</span></code>) if the names of
the arguments don’t matter. This is the same as writing type variables
with unique names. Unused type arguments can be replaced or prefixed
with underscores to avoid warnings when the
<a class="reference internal" href="../using-warnings.html#ghc-flag-Wunused-type-patterns"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wunused-type-patterns</span></code></a> flag is enabled. The same rules apply
as for <a class="reference internal" href="#data-instance-declarations"><span class="std std-ref">Data instance declarations</span></a>.</p>
<p>Also in the same way as <a class="reference internal" href="#data-instance-declarations"><span class="std std-ref">Data instance declarations</span></a>, when
<a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExplicitForAll</span></code></a> is enabled, type and kind variables can be
explicitly bound in a type instance declaration.</p>
<p>Type family instance declarations are only legitimate when an
appropriate family declaration is in scope - just like class instances
require the class declaration to be visible. Moreover, each instance
declaration has to conform to the kind determined by its family
declaration, and the number of type parameters in an instance
declaration must match the number of type parameters in the family
declaration. Finally, the right-hand side of a type instance must be a
monotype (i.e., it may not include foralls) and after the expansion of
all saturated vanilla type synonyms, no synonyms, except family synonyms
may remain.</p>
</section>
<section id="closed-type-families">
<span id="id11"></span><h3><span class="section-number">6.4.9.2.3. </span>Closed type families<a class="headerlink" href="#closed-type-families" title="Permalink to this heading">¶</a></h3>
<p>A type family can also be declared with a <code class="docutils literal notranslate"><span class="pre">where</span></code> clause, defining the
full set of equations for that family. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="kt">Int</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Double</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Char</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
</pre></div>
</div>
<p>A closed type family’s equations are tried in order, from top to bottom,
when simplifying a type family application. In this example, we declare
an instance for <code class="docutils literal notranslate"><span class="pre">F</span></code> such that <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">Int</span></code> simplifies to <code class="docutils literal notranslate"><span class="pre">Double</span></code>,
<code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">Bool</span></code> simplifies to <code class="docutils literal notranslate"><span class="pre">Char</span></code>, and for any other type <code class="docutils literal notranslate"><span class="pre">a</span></code> that is
known not to be <code class="docutils literal notranslate"><span class="pre">Int</span></code> or <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">a</span></code> simplifies to <code class="docutils literal notranslate"><span class="pre">String</span></code>.
Note that GHC must be sure that <code class="docutils literal notranslate"><span class="pre">a</span></code> cannot unify with <code class="docutils literal notranslate"><span class="pre">Int</span></code> or
<code class="docutils literal notranslate"><span class="pre">Bool</span></code> in that last case; if a programmer specifies just <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">a</span></code> in
their code, GHC will not be able to simplify the type. After all, <code class="docutils literal notranslate"><span class="pre">a</span></code>
might later be instantiated with <code class="docutils literal notranslate"><span class="pre">Int</span></code>.</p>
<p>A closed type family’s equations have the same restrictions and extensions as
the equations for open type family instances. For instance, when
<a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExplicitForAll</span></code></a> is enabled, type or kind variables used on the
left hand side of an equation can be explicitly bound, such as in:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">forall</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w">   </span><span class="kt">R</span><span class="w"> </span><span class="n">a</span><span class="w">     </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>A closed type family may be declared with no equations. Such closed type
families are opaque type-level definitions that will never reduce, are
not necessarily injective (unlike empty data types), and cannot be given
any instances. This is different from omitting the equations of a closed
type family in a <code class="docutils literal notranslate"><span class="pre">hs-boot</span></code> file, which uses the syntax <code class="docutils literal notranslate"><span class="pre">where</span> <span class="pre">..</span></code>,
as in that case there may or may not be equations given in the <code class="docutils literal notranslate"><span class="pre">hs</span></code>
file.</p>
</section>
<section id="type-family-examples">
<span id="id12"></span><h3><span class="section-number">6.4.9.2.4. </span>Type family examples<a class="headerlink" href="#type-family-examples" title="Permalink to this heading">¶</a></h3>
<p>Here are some examples of admissible and illegal type instances:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w">   </span><span class="c1">-- OK!</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="kt">String</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Char</span><span class="w">  </span><span class="c1">-- OK!</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="p">(</span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w">     </span><span class="c1">-- WRONG: type parameter mentions a type family</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">b</span><span class="w">     </span><span class="c1">-- WRONG: a forall type appears in a type parameter</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="kt">Float</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="n">a</span><span class="w">          </span><span class="c1">-- WRONG: right-hand side may not be a forall type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">H</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w">          </span><span class="c1">-- OK!</span><span class="w"></span>
<span class="w">  </span><span class="kt">H</span><span class="w"> </span><span class="kt">Int</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">  </span><span class="kt">H</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="w">  </span><span class="kt">H</span><span class="w"> </span><span class="n">a</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">H</span><span class="w"> </span><span class="kt">Char</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Char</span><span class="w">    </span><span class="c1">-- WRONG: cannot have instances of closed family</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">K</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w">          </span><span class="c1">-- OK!</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="kt">Int</span><span class="w">            </span><span class="ow">=</span><span class="w"> </span><span class="p">(,)</span><span class="w">     </span><span class="c1">-- WRONG: must be two type parameters</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Char</span><span class="w"> </span><span class="kt">Float</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Double</span><span class="w">  </span><span class="c1">-- WRONG: must be two type parameters</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="compatibility-and-apartness-of-type-family-equations">
<span id="type-family-overlap"></span><h3><span class="section-number">6.4.9.2.5. </span>Compatibility and apartness of type family equations<a class="headerlink" href="#compatibility-and-apartness-of-type-family-equations" title="Permalink to this heading">¶</a></h3>
<p>There must be some restrictions on the equations of type families, lest
we define an ambiguous rewrite system. So, equations of open type
families are restricted to be compatible. Two type patterns are
compatible if</p>
<ol class="arabic simple">
<li><p>all corresponding types and implicit kinds in the patterns are apart,
or</p></li>
<li><p>the two patterns unify producing a substitution, and the right-hand
sides are equal under that substitution.</p></li>
</ol>
<p>Two types are considered apart if, for all possible substitutions, the
types cannot reduce to a common reduct.</p>
<p>The first clause of “compatible” is the more straightforward one. It
says that the patterns of two distinct type family instances cannot
overlap. For example, the following is disallowed:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Char</span><span class="w"></span>
</pre></div>
</div>
<p>The second clause is a little more interesting. It says that two
overlapping type family instances are allowed if the right-hand sides
coincide in the region of overlap. Some examples help here:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w">   </span><span class="c1">-- overlap permitted</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="p">(</span><span class="kt">Char</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w">  </span><span class="c1">-- ILLEGAL overlap, as [Char] /= [Int]</span><span class="w"></span>
</pre></div>
</div>
<p>Note that this compatibility condition is independent of whether the
type family is associated or not, and it is not only a matter of
consistency, but one of type safety.</p>
<p>For a polykinded type family, the kinds are checked for apartness just
like types. For example, the following is accepted:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">J</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">J</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">J</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"></span>
</pre></div>
</div>
<p>These instances are compatible because they differ in their implicit kind
parameter; the first uses <code class="docutils literal notranslate"><span class="pre">Type</span></code> while the second uses <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code>.</p>
<p>The definition for “compatible” uses a notion of “apart”, whose
definition in turn relies on type family reduction. This condition of
“apartness”, as stated, is impossible to check, so we use this
conservative approximation: two types are considered to be apart when
the two types cannot be unified, even by a potentially infinite unifier.
Allowing the unifier to be infinite disallows the following pair of
instances:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">H</span><span class="w"> </span><span class="n">x</span><span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">H</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
</pre></div>
</div>
<p>The type patterns in this pair equal if <code class="docutils literal notranslate"><span class="pre">x</span></code> is replaced by an infinite
nesting of lists. Rejecting instances such as these is necessary for
type soundness.</p>
<p>Compatibility also affects closed type families. When simplifying an
application of a closed type family, GHC will select an equation only
when it is sure that no incompatible previous equation will ever apply.
Here are some examples:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">Char</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">G</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">  </span><span class="kt">G</span><span class="w"> </span><span class="n">a</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>In the definition for <code class="docutils literal notranslate"><span class="pre">F</span></code>, the two equations are incompatible – their
patterns are not apart, and yet their right-hand sides do not coincide.
Thus, before GHC selects the second equation, it must be sure that the
first can never apply. So, the type <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">a</span></code> does not simplify; only a
type such as <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">Double</span></code> will simplify to <code class="docutils literal notranslate"><span class="pre">Char</span></code>. In <code class="docutils literal notranslate"><span class="pre">G</span></code>, on the
other hand, the two equations are compatible. Thus, GHC can ignore the
first equation when looking at the second. So, <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">a</span></code> will simplify to
<code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>Incompatibilities between closed type family equations can be displayed
in <a class="reference internal" href="../ghci.html#ghci-cmd-info"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:info</span></code></a> when <a class="reference internal" href="../using.html#ghc-flag-fprint-axiom-incomps"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fprint-axiom-incomps</span></code></a> is enabled.</p>
<p>However see <a class="reference internal" href="../ghci.html#ghci-decls"><span class="std std-ref">Type, class and other declarations</span></a> for the overlap rules in GHCi.</p>
</section>
<section id="decidability-of-type-synonym-instances">
<span id="type-family-decidability"></span><h3><span class="section-number">6.4.9.2.6. </span>Decidability of type synonym instances<a class="headerlink" href="#decidability-of-type-synonym-instances" title="Permalink to this heading">¶</a></h3>
<p>In order to guarantee that type inference in the presence of type
families is decidable, we need to place a number of additional restrictions
on the formation of type instance declarations (c.f., Definition 5
(Relaxed Conditions) of “<a class="reference external" href="http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html">Type Checking with Open Type
Functions</a>”).
Instance declarations have the general form</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">tn</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">t</span><span class="w"></span>
</pre></div>
</div>
<p>where we require that for every type family application <code class="docutils literal notranslate"><span class="pre">(G</span> <span class="pre">s1</span> <span class="pre">..</span> <span class="pre">sm)</span></code>
in <code class="docutils literal notranslate"><span class="pre">t</span></code>,</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s1</span> <span class="pre">..</span> <span class="pre">sm</span></code> do not contain any type family constructors,</p></li>
<li><p>the total number of symbols (data type constructors and type
variables) in <code class="docutils literal notranslate"><span class="pre">s1</span> <span class="pre">..</span> <span class="pre">sm</span></code> is strictly smaller than in <code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">..</span> <span class="pre">tn</span></code>,
and</p></li>
<li><p>for every type variable <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span></code> occurs in <code class="docutils literal notranslate"><span class="pre">s1</span> <span class="pre">..</span> <span class="pre">sm</span></code> at most
as often as in <code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">..</span> <span class="pre">tn</span></code>.</p></li>
</ol>
<p>These restrictions are easily verified and ensure termination of type
inference. However, they are not sufficient to guarantee completeness of
type inference in the presence of, so called, ‘’loopy equalities’’, such
as <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">~</span> <span class="pre">[F</span> <span class="pre">a]</span></code>, where a recursive occurrence of a type variable is
underneath a family application and data constructor application - see
the above mentioned paper for details.</p>
<p>If the option <a class="reference internal" href="instances.html#extension-UndecidableInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UndecidableInstances</span></code></a> is passed to the compiler
(see <a class="reference internal" href="instances.html#undecidable-instances"><span class="std std-ref">Instance termination rules</span></a>), the above restrictions are not enforced
and it is on the programmer to ensure termination of the normalisation
of type families during type inference.</p>
</section>
<section id="reducing-type-family-applications">
<h3><span class="section-number">6.4.9.2.7. </span>Reducing type family applications<a class="headerlink" href="#reducing-type-family-applications" title="Permalink to this heading">¶</a></h3>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ffamily-application-cache">
<span class="sig-name descname"><span class="pre">-ffamily-application-cache</span></span><a class="headerlink" href="#ghc-flag-ffamily-application-cache" title="Permalink to this definition">¶</a></dt>
<dd><p>The flag <a class="reference internal" href="#ghc-flag-ffamily-application-cache"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ffamily-application-cache</span></code></a> (on by default) instructs
GHC to use a cache when reducing type family applications. In most cases,
this will speed up compilation. The use of this flag will not affect
runtime behaviour.</p>
</dd></dl>

<p>When GHC encounters a type family application (like <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">Int</span> <span class="pre">a</span></code>) in a program,
it must often reduce it in order to complete type checking. Here is a simple
example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="kt">Int</span><span class="w">            </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Double</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Char</span><span class="w"></span>

<span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">not</span><span class="w"></span>
</pre></div>
</div>
<p>Despite the fact that <code class="docutils literal notranslate"><span class="pre">g</span></code>'s type mentions <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">Int</span></code>, GHC must recognize that
<code class="docutils literal notranslate"><span class="pre">g</span></code>'s argument really has type <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. This is done by <em>reducing</em> <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">Int</span></code>
to become <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. Sometimes, there is not enough information to reduce a type
family application; we say such an application is <em>stuck</em>. Continuing this example,
an occurrence of <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">(Maybe</span> <span class="pre">a)</span></code> (for some type variable <code class="docutils literal notranslate"><span class="pre">a</span></code>) would be stuck, as
no equation applies.</p>
<p>During type checking, GHC uses heuristics to determine which type family application
to reduce next; there is no predictable ordering among different type family applications.
The non-determinism rarely matters in practice. In most programs, type family reduction
terminates, and so these choices are immaterial. However, if a type family application
does not terminate, it is possible that type-checking may unpredictably diverge. (GHC
will always take the same path for a given source program, but small changes in that
source program may induce GHC to take a different path. Compiling a given, unchanged
source program is still deterministic.)</p>
<p>In order to speed up type family reduction, GHC normally uses a cache, remembering what
type family applications it has previously reduced. This feature can be disabled with
<a class="reference internal" href="#ghc-flag--ffamily-application-cache"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fno-family-application-cache</span></code></a>.</p>
</section>
</section>
<section id="wildcards-on-the-lhs-of-data-and-type-family-instances">
<span id="type-wildcards-lhs"></span><h2><span class="section-number">6.4.9.3. </span>Wildcards on the LHS of data and type family instances<a class="headerlink" href="#wildcards-on-the-lhs-of-data-and-type-family-instances" title="Permalink to this heading">¶</a></h2>
<p>When the name of a type argument of a data or type instance
declaration doesn’t matter, it can be replaced with an underscore
(<code class="docutils literal notranslate"><span class="pre">_</span></code>). This is the same as writing a type variable with a unique name.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="c1">-- Equivalent to  data instance F Int b = Int</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="c1">-- Equivalent to  type instance T (a,b) = a</span><span class="w"></span>
</pre></div>
</div>
<p>This use of underscore for wildcard in a type pattern is exactly like
pattern matching in the term language, but is rather different to the
use of a underscore in a partial type signature (see <a class="reference internal" href="partial_type_signatures.html#type-wildcards"><span class="std std-ref">Type Wildcards</span></a>).</p>
<p>A type variable beginning with an underscore is not treated specially in a
type or data instance declaration.  For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="n">_a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">_a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="c1">-- Equivalent to  data instance F Bool a = a -&gt; Int</span><span class="w"></span>
</pre></div>
</div>
<p>Contrast this with the special treatment of named wildcards in
type signatures (<a class="reference internal" href="partial_type_signatures.html#named-wildcards"><span class="std std-ref">Named Wildcards</span></a>).</p>
</section>
<section id="associated-data-and-type-families">
<span id="assoc-decl"></span><h2><span class="section-number">6.4.9.4. </span>Associated data and type families<a class="headerlink" href="#associated-data-and-type-families" title="Permalink to this heading">¶</a></h2>
<p>A data or type synonym family can be declared as part of a type class,
thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">GMapKey</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">GMap</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="w">  </span><span class="o">...</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Elem</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="w">  </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>When doing so, we (optionally) may drop the “<code class="docutils literal notranslate"><span class="pre">family</span></code>” keyword.</p>
<p>The type parameters must all be type variables, of course, and some (but
not necessarily all) of then can be the class parameters. Each class
parameter may only be used at most once per associated type, but some
may be omitted and they may be in an order other than in the class head.
Hence, the following contrived example is admissible:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">c</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span></code> are class parameters, but the type is also indexed
on a third parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<section id="associated-instances">
<span id="assoc-inst"></span><h3><span class="section-number">6.4.9.4.1. </span>Associated instances<a class="headerlink" href="#associated-instances" title="Permalink to this heading">¶</a></h3>
<p>When an associated data or type synonym family instance is declared
within a type class instance, we (optionally) may drop the <code class="docutils literal notranslate"><span class="pre">instance</span></code>
keyword in the family instance:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">GMapKey</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">GMapKey</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">GMapKey</span><span class="w"> </span><span class="p">(</span><span class="kt">Either</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">GMap</span><span class="w"> </span><span class="p">(</span><span class="kt">Either</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">GMapEither</span><span class="w"> </span><span class="p">(</span><span class="kt">GMap</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">GMap</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">...</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">Elem</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">])</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Elem</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
<span class="w">  </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>The data or type family instance for an associated type must follow
the rule that the type indexes corresponding to class parameters must be
precisely the same as types given in the instance head. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Elem</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">Elem</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">])</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- Choose one of the following alternatives:</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Elem</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w">       </span><span class="c1">-- OK</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Elem</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w">       </span><span class="c1">-- BAD; &#39;[x]&#39; is different to &#39;[e]&#39; from head</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Elem</span><span class="w"> </span><span class="n">x</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w">       </span><span class="c1">-- BAD; &#39;x&#39; is different to &#39;[e]&#39;</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Elem</span><span class="w"> </span><span class="p">[</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="c1">-- BAD: &#39;[Maybe x]&#39; is different to &#39;[e]&#39;</span><span class="w"></span>
</pre></div>
</div>
<p>Note the following points:</p>
<ul>
<li><p>An instance for an associated family can only appear as part of an
instance declarations of the class in which the family was declared,
just as with the equations of the methods of a class.</p></li>
<li><p>The type variables on the right hand side of the type family equation
must, as usual, be explicitly bound by the left hand side. This restriction
is relaxed for <em>kind</em> variables, however, as the right hand side is allowed
to mention kind variables that are implicitly bound. For example, these are
legitimate:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">Nat</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="c1">-- k is implicitly bound by an invisible kind pattern</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">Nat</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">Nat</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">xx</span><span class="o">.</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">xx</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Nat</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">Funct</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Codomain</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Funct</span><span class="w"> </span><span class="p">(</span><span class="kt">&#39;KProxy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">KProxy</span><span class="w"> </span><span class="n">o</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- o is implicitly bound by the kind signature</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- of the LHS type pattern (&#39;KProxy)</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Codomain</span><span class="w"> </span><span class="kt">&#39;KProxy</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">NatTr</span><span class="w"> </span><span class="p">(</span><span class="kt">Proxy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The instance for an associated type can be omitted in class
instances. In that case, unless there is a default instance (see
<a class="reference internal" href="#assoc-decl-defs"><span class="std std-ref">Associated type synonym defaults</span></a>), the corresponding instance type is not
inhabited; i.e., only diverging expressions, such as <code class="docutils literal notranslate"><span class="pre">undefined</span></code>,
can assume the type.</p></li>
<li><p>Although it is unusual, there (currently) can be <em>multiple</em> instances
for an associated family in a single instance declaration. For
example, this is legitimate:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">GMapKey</span><span class="w"> </span><span class="kt">Flob</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">GMap</span><span class="w"> </span><span class="kt">Flob</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">G1</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">GMap</span><span class="w"> </span><span class="kt">Flob</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">G2</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">  </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Here we give two data instance declarations, one in which the last
parameter is <code class="docutils literal notranslate"><span class="pre">[v]</span></code>, and one for which it is <code class="docutils literal notranslate"><span class="pre">Int</span></code>. Since you
cannot give any <em>subsequent</em> instances for <code class="docutils literal notranslate"><span class="pre">(GMap</span> <span class="pre">Flob</span> <span class="pre">...)</span></code>, this
facility is most useful when the free indexed parameter is of a kind
with a finite number of alternatives (unlike <code class="docutils literal notranslate"><span class="pre">Type</span></code>).</p>
</li>
<li><p>When <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExplicitForAll</span></code></a> is enabled, type and kind variables can be
explicitly bound in associated data or type family instances in the same way
(and with the same restrictions) as <a class="reference internal" href="#data-instance-declarations"><span class="std std-ref">Data instance declarations</span></a> or
<a class="reference internal" href="#type-instance-declarations"><span class="std std-ref">Type instance declarations</span></a>. For example, adapting the above, the
following is accepted:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">Elem</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">])</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Collects</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">e</span><span class="o">.</span><span class="w"> </span><span class="kt">Elem</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="associated-type-synonym-defaults">
<span id="assoc-decl-defs"></span><h3><span class="section-number">6.4.9.4.2. </span>Associated type synonym defaults<a class="headerlink" href="#associated-type-synonym-defaults" title="Permalink to this heading">¶</a></h3>
<p>It is possible for the class defining the associated type to specify a
default for associated type instances. So for example, this is OK:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">IsBoolMap</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Key</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">Key</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>

<span class="w">  </span><span class="n">lookupKey</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Key</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">IsBoolMap</span><span class="w"> </span><span class="p">[(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)]</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">lookupKey</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lookup</span><span class="w"></span>
</pre></div>
</div>
<p>In an <code class="docutils literal notranslate"><span class="pre">instance</span></code> declaration for the class, if no explicit
<code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">instance</span></code> declaration is given for the associated type, the
default declaration is used instead, just as with default class methods.</p>
<p>Note the following points:</p>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">instance</span></code> keyword is optional.</p></li>
<li><p>There can be at most one default declaration for an associated type
synonym.</p></li>
<li><p>A default declaration is not permitted for an associated <em>data</em> type.</p></li>
<li><p>The default declaration must mention only type <em>variables</em> on the
left hand side, and type variables may not be repeated on the left-hand
side. The right hand side must mention only type
variables that are explicitly bound on the left hand side. This restriction
is relaxed for <em>kind</em> variables, however, as the right hand side is allowed
to mention kind variables that are implicitly bound on the left hand side.</p>
<p>Like with <a class="reference internal" href="#assoc-inst"><span class="std std-ref">Associated instances</span></a>, it is possible to explicitly bind type and kind
variables in default declarations with a <code class="docutils literal notranslate"><span class="pre">forall</span></code> by using the
<a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExplicitForAll</span></code></a> language extension.</p>
</li>
<li><p>Unlike the associated type family declaration itself, the type variables of
the default instance are independent of those of the parent class.</p></li>
</ul>
<p>Here are some examples:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w">     </span><span class="c1">-- OK</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="ow">-&gt;</span><span class="n">a</span><span class="w">    </span><span class="c1">-- BAD; only one default instance is allowed</span><span class="w"></span>

<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F2</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span><span class="w">                  </span><span class="c1">-- OK; note the family has more type</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--     variables than the class</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F2</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">c</span><span class="ow">-&gt;</span><span class="n">d</span><span class="w">  </span><span class="c1">-- OK; you don&#39;t have to use &#39;a&#39; in the type instance</span><span class="w"></span>

<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F3</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F3</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">b</span><span class="w">              </span><span class="c1">-- BAD; only type variables allowed on the</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--      LHS, and the argument to F3 is</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--      instantiated to [b], which is not</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--      a bare type variable</span><span class="w"></span>

<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F4</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F4</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w">              </span><span class="c1">-- BAD; the type variable x is repeated on</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--      the LHS</span><span class="w"></span>

<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F5</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F5</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w">                </span><span class="c1">-- BAD; &#39;a&#39; is not in scope  in the RHS</span><span class="w"></span>

<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F6</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F6</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">&#39;[]</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="w">     </span><span class="c1">-- OK; the kind variable x is implicitly</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--     bound by an invisible kind pattern</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--     on the LHS</span><span class="w"></span>

<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F7</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F7</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="kt">Proxy</span><span class="w"> </span><span class="p">(</span><span class="kt">&#39;[]</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="w">         </span><span class="c1">-- BAD; the kind variable x is not bound,</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--      even by an invisible kind pattern</span><span class="w"></span>

<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F8</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F8</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">&#39;[]</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">])</span><span class="w">     </span><span class="c1">-- OK; the kind variable a is implicitly</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--     bound by the kind signature of the</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--     LHS type pattern</span><span class="w"></span>

<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F9</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F9</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w">          </span><span class="c1">-- BAD; the kind variable k is</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--      instantiated to Type, which is not</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--      a bare kind variable</span><span class="w"></span>

<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F10</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F10</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w">                  </span><span class="c1">-- BAD; the kind variable z is repeated,</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--      as both j and k are instantiated to z</span><span class="w"></span>

<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F11</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="kt">F11</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="c1">-- OK; LHS type variables can be</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--     explicitly bound with &#39;forall&#39;</span><span class="w"></span>

<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F12</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F12</span><span class="w"> </span><span class="o">@</span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w">      </span><span class="c1">-- OK; visible kind application syntax is</span><span class="w"></span>
<span class="w">                               </span><span class="c1">--     permitted in default declarations</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="scoping-of-class-parameters">
<span id="scoping-class-params"></span><h3><span class="section-number">6.4.9.4.3. </span>Scoping of class parameters<a class="headerlink" href="#scoping-of-class-parameters" title="Permalink to this heading">¶</a></h3>
<p>The visibility of class parameters in the right-hand side of associated
family instances depends <em>solely</em> on the parameters of the family. As an
example, consider the simple class declaration</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>Only one of the two class parameters is a parameter to the data family.
Hence, the following instance declaration is invalid:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w">    </span><span class="c1">-- WRONG!!  &#39;d&#39; is not in scope</span><span class="w"></span>
</pre></div>
</div>
<p>Here, the right-hand side of the data instance mentions the type
variable <code class="docutils literal notranslate"><span class="pre">d</span></code> that does not occur in its left-hand side. We cannot
admit such data instances as they would compromise type safety.</p>
<p>Bear in mind that it is also possible for the <em>right</em>-hand side of an
associated family instance to contain <em>kind</em> parameters (by using the
<a class="reference internal" href="poly_kinds.html#extension-PolyKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PolyKinds</span></code></a> extension). For instance, this class and instance are
perfectly admissible:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Nothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Here, although the right-hand side <code class="docutils literal notranslate"><span class="pre">(Nothing</span> <span class="pre">::</span> <span class="pre">Maybe</span> <span class="pre">a)</span></code> mentions a kind
variable <code class="docutils literal notranslate"><span class="pre">a</span></code> which does not occur on the left-hand side, this is acceptable,
because <code class="docutils literal notranslate"><span class="pre">a</span></code> is <em>implicitly</em> bound by <code class="docutils literal notranslate"><span class="pre">T</span></code>’s kind pattern.</p>
<p>A kind variable can also be bound implicitly in a LHS type pattern, as in this
example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">&#39;[]</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="p">])</span><span class="w"></span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">('[]</span> <span class="pre">::</span> <span class="pre">[Maybe</span> <span class="pre">a])</span></code>, the kind variable <code class="docutils literal notranslate"><span class="pre">a</span></code> is implicitly bound by the
kind signature of the LHS type pattern <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</section>
<section id="instance-contexts-and-associated-type-and-data-instances">
<h3><span class="section-number">6.4.9.4.4. </span>Instance contexts and associated type and data instances<a class="headerlink" href="#instance-contexts-and-associated-type-and-data-instances" title="Permalink to this heading">¶</a></h3>
<p>Associated type and data instance declarations do not inherit any
context specified on the enclosing instance. For type instance
declarations, it is unclear what the context would mean. For data
instance declarations, it is unlikely a user would want the context
repeated for every data constructor. The only place where the context
might likely be useful is in a <code class="docutils literal notranslate"><span class="pre">deriving</span></code> clause of an associated data
instance. However, even here, the role of the outer instance context is
murky. So, for clarity, we just stick to the rule above: the enclosing
instance context is ignored. If you need to use a non-trivial context on
a derived instance, use a <a class="reference internal" href="standalone_deriving.html#extension-StandaloneDeriving"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">standalone</span> <span class="pre">deriving</span></code></a>
clause (at the top level).</p>
</section>
</section>
<section id="import-and-export">
<span id="data-family-import-export"></span><h2><span class="section-number">6.4.9.5. </span>Import and export<a class="headerlink" href="#import-and-export" title="Permalink to this heading">¶</a></h2>
<p>The rules for export lists (Haskell Report <a class="reference external" href="http://www.haskell.org/onlinereport/modules.html#sect5.2">Section
5.2</a>) need
adjustment for type families:</p>
<ul class="simple">
<li><p>The form <code class="docutils literal notranslate"><span class="pre">T(..)</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is a data family, names the family
<code class="docutils literal notranslate"><span class="pre">T</span></code> and all the in-scope constructors (whether in scope qualified
or unqualified) that are data instances of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p></li>
<li><p>The form <code class="docutils literal notranslate"><span class="pre">T(..,</span> <span class="pre">ci,</span> <span class="pre">..,</span> <span class="pre">fj,</span> <span class="pre">..)</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is a data family,
names <code class="docutils literal notranslate"><span class="pre">T</span></code> and the specified constructors <code class="docutils literal notranslate"><span class="pre">ci</span></code> and fields <code class="docutils literal notranslate"><span class="pre">fj</span></code>
as usual. The constructors and field names must belong to some data
instance of <code class="docutils literal notranslate"><span class="pre">T</span></code>, but are not required to belong to the <em>same</em>
instance.</p></li>
<li><p>The form <code class="docutils literal notranslate"><span class="pre">C(..)</span></code>, where <code class="docutils literal notranslate"><span class="pre">C</span></code> is a class, names the class <code class="docutils literal notranslate"><span class="pre">C</span></code> and
all its methods <em>and associated types</em>.</p></li>
<li><p>The form <code class="docutils literal notranslate"><span class="pre">C(..,</span> <span class="pre">mi,</span> <span class="pre">..,</span> <span class="pre">type</span> <span class="pre">Tj,</span> <span class="pre">..)</span></code>, where <code class="docutils literal notranslate"><span class="pre">C</span></code> is a class,
names the class <code class="docutils literal notranslate"><span class="pre">C</span></code>, and the specified methods <code class="docutils literal notranslate"><span class="pre">mi</span></code> and
associated types <code class="docutils literal notranslate"><span class="pre">Tj</span></code>. The types need a keyword “<code class="docutils literal notranslate"><span class="pre">type</span></code>” to
distinguish them from data constructors.</p></li>
<li><p>Whenever there is no export list and a data instance is defined, the
corresponding data family type constructor is exported along with
the new data constructors, regardless of whether the data family
is defined locally or in another module.</p></li>
</ul>
<section id="examples">
<span id="data-family-impexp-examples"></span><h3><span class="section-number">6.4.9.5.1. </span>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h3>
<p>Recall our running <code class="docutils literal notranslate"><span class="pre">GMapKey</span></code> class example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">GMapKey</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">GMap</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="w">  </span><span class="n">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">GMap</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">GMap</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="w">  </span><span class="n">lookup</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">GMap</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="w">  </span><span class="n">empty</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">GMap</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">GMapKey</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">GMapKey</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">GMapKey</span><span class="w"> </span><span class="p">(</span><span class="kt">Either</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">GMap</span><span class="w"> </span><span class="p">(</span><span class="kt">Either</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">GMapEither</span><span class="w"> </span><span class="p">(</span><span class="kt">GMap</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">GMap</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">...</span><span class="n">method</span><span class="w"> </span><span class="n">declarations</span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Here are some export lists and their meaning:</p>
<ul>
<li><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">GMap</span><span class="p">(</span><span class="w"> </span><span class="kt">GMapKey</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Exports just the class name.</p>
</li>
<li><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">GMap</span><span class="p">(</span><span class="w"> </span><span class="kt">GMapKey</span><span class="p">(</span><span class="o">..</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Exports the class, the associated type <code class="docutils literal notranslate"><span class="pre">GMap</span></code> and the member functions
<code class="docutils literal notranslate"><span class="pre">empty</span></code>, <code class="docutils literal notranslate"><span class="pre">lookup</span></code>, and <code class="docutils literal notranslate"><span class="pre">insert</span></code>. The data constructors of <code class="docutils literal notranslate"><span class="pre">GMap</span></code> (in
this case <code class="docutils literal notranslate"><span class="pre">GMapEither</span></code>) are not exported.</p>
</li>
<li><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">GMap</span><span class="p">(</span><span class="w"> </span><span class="kt">GMapKey</span><span class="p">(</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="kt">GMap</span><span class="p">,</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span><span class="w"> </span><span class="n">lookup</span><span class="p">,</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Same as the previous item. Note the “<code class="docutils literal notranslate"><span class="pre">type</span></code>” keyword.</p>
</li>
<li><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">GMap</span><span class="p">(</span><span class="w"> </span><span class="kt">GMapKey</span><span class="p">(</span><span class="o">..</span><span class="p">),</span><span class="w"> </span><span class="kt">GMap</span><span class="p">(</span><span class="o">..</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Same as previous item, but also exports all the data constructors for
<code class="docutils literal notranslate"><span class="pre">GMap</span></code>, namely
<code class="docutils literal notranslate"><span class="pre">GMapEither</span></code>.</p>
</li>
<li><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">GMap</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">GMapKey</span><span class="p">(</span><span class="w"> </span><span class="nf">empty</span><span class="p">,</span><span class="w"> </span><span class="nf">lookup</span><span class="p">,</span><span class="w"> </span><span class="nf">insert</span><span class="p">),</span><span class="w"> </span><span class="kt">GMap</span><span class="p">(</span><span class="o">..</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Same as previous item.</p>
</li>
<li><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">GMap</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">GMapKey</span><span class="p">,</span><span class="w"> </span><span class="nf">empty</span><span class="p">,</span><span class="w"> </span><span class="nf">lookup</span><span class="p">,</span><span class="w"> </span><span class="nf">insert</span><span class="p">,</span><span class="w"> </span><span class="kt">GMap</span><span class="p">(</span><span class="o">..</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Same as previous item.</p>
</li>
</ul>
<p>Two things to watch out for:</p>
<ul>
<li><p>You cannot write <code class="docutils literal notranslate"><span class="pre">GMapKey(type</span> <span class="pre">GMap(..))</span></code> — i.e., sub-component
specifications cannot be nested. To specify <code class="docutils literal notranslate"><span class="pre">GMap</span></code>‘s data
constructors, you have to list it separately.</p></li>
<li><p>Consider this example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">X</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">D</span><span class="w"></span>

<span class="kr">module</span><span class="w"> </span><span class="nn">Y</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">import</span><span class="w"> </span><span class="nn">X</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">D1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">D2</span><span class="w"></span>
</pre></div>
</div>
<p>Module <code class="docutils literal notranslate"><span class="pre">Y</span></code> exports all the entities defined in <code class="docutils literal notranslate"><span class="pre">Y</span></code>, namely the data
constructors <code class="docutils literal notranslate"><span class="pre">D1</span></code> and <code class="docutils literal notranslate"><span class="pre">D2</span></code>, and <em>implicitly</em> the data family <code class="docutils literal notranslate"><span class="pre">D</span></code>,
even though it’s defined in <code class="docutils literal notranslate"><span class="pre">X</span></code>.
This means you can write <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">Y(</span> <span class="pre">D(D1,D2)</span> <span class="pre">)</span></code> <em>without</em>
giving an explicit export list like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">     </span><span class="kr">module</span><span class="w"> </span><span class="nn">Y</span><span class="p">(</span><span class="w"> </span><span class="kt">D</span><span class="p">(</span><span class="o">..</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="nf">or</span><span class="w">   </span><span class="kr">module</span><span class="w"> </span><span class="nn">Y</span><span class="p">(</span><span class="w"> </span><span class="kr">module</span><span class="w"> </span><span class="nn">Y</span><span class="p">,</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="instances">
<span id="data-family-impexp-instances"></span><h3><span class="section-number">6.4.9.5.2. </span>Instances<a class="headerlink" href="#instances" title="Permalink to this heading">¶</a></h3>
<p>Family instances are implicitly exported, just like class instances.
However, this applies only to the heads of instances, not to the data
constructors an instance defines.</p>
</section>
</section>
<section id="type-families-and-instance-declarations">
<span id="ty-fams-in-instances"></span><h2><span class="section-number">6.4.9.6. </span>Type families and instance declarations<a class="headerlink" href="#type-families-and-instance-declarations" title="Permalink to this heading">¶</a></h2>
<p>Type families require us to extend the rules for the form of instance
heads, which are given in <a class="reference internal" href="instances.html#flexible-instance-head"><span class="std std-ref">Relaxed rules for the instance head</span></a>. Specifically:</p>
<ul class="simple">
<li><p>Data type families may appear in an instance head</p></li>
<li><p>Type synonym families may not appear (at all) in an instance head</p></li>
</ul>
<p>The reason for the latter restriction is that there is no way to check
for instance matching. Consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Now a constraint <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">(F</span> <span class="pre">Bool))</span></code> would match both instances. The
situation is especially bad because the type instance for <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">Bool</span></code>
might be in another module, or even in a module that is not yet written.</p>
<p>However, type class instances of instances of data families can be
defined much like any other data type. For example, we can say</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="kt">T1</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">T1</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="kt">T2</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">T2</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="w"></span>
<span class="w">  </span><span class="kr">_</span><span class="w">      </span><span class="o">==</span><span class="w"> </span><span class="kr">_</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
</pre></div>
</div>
<p>Note that class instances are always for particular <em>instances</em> of a
data family and never for an entire family as a whole. This is for
essentially the same reasons that we cannot define a toplevel function
that performs pattern matching on the data constructors of <em>different</em>
instances of a single type family. It would require a form of extensible
case construct.</p>
<p>Data instance declarations can also have <code class="docutils literal notranslate"><span class="pre">deriving</span></code> clauses. For
example, we can write</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">GMap</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">GMapUnit</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="w">               </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Show</span><span class="w"></span>
</pre></div>
</div>
<p>which implicitly defines an instance of the form</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="p">(</span><span class="kt">GMap</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="injective-type-families">
<span id="injective-ty-fams"></span><h2><span class="section-number">6.4.9.7. </span>Injective type families<a class="headerlink" href="#injective-type-families" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-TypeFamilyDependencies">
<span id="ghc-flag--XTypeFamilyDependencies"></span><span id="extension-NoTypeFamilyDependencies"></span><span class="sig-name descname"><span class="pre">TypeFamilyDependencies</span></span><a class="headerlink" href="#extension-TypeFamilyDependencies" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Implies<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#extension-TypeFamilies"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TypeFamilies</span></code></a></p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>8.0.1</p>
</dd>
</dl>
<p>Allow functional dependency annotations on type families. This allows one to
define injective type families.</p>
</dd></dl>

<p>Starting with GHC 8.0 type families can be annotated with injectivity
information. This information is then used by GHC during type checking
to resolve type ambiguities in situations where a type variable appears
only under type family applications. Consider this contrived example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">Id</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">Id</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">Id</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>

<span class="nf">id</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Id</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Id</span><span class="w"> </span><span class="n">t</span><span class="w"></span>
<span class="nf">id</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>Here the definition of <code class="docutils literal notranslate"><span class="pre">id</span></code> will be rejected because type variable <code class="docutils literal notranslate"><span class="pre">t</span></code>
appears only under type family applications and is thus ambiguous.  But this
code will be accepted if we tell GHC that <code class="docutils literal notranslate"><span class="pre">Id</span></code> is injective, which means it
will be possible to infer <code class="docutils literal notranslate"><span class="pre">t</span></code> at call sites from the type of the argument:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">Id</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>Injective type families are enabled with <code class="docutils literal notranslate"><span class="pre">-XTypeFamilyDependencies</span></code> language
extension.  This extension implies <code class="docutils literal notranslate"><span class="pre">-XTypeFamilies</span></code>.</p>
<p>For full details on injective type families refer to Haskell Symposium
2015 paper <a class="reference external" href="http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf">Injective type families for
Haskell</a>.</p>
<section id="syntax-of-injectivity-annotation">
<span id="injective-ty-fams-syntax"></span><h3><span class="section-number">6.4.9.7.1. </span>Syntax of injectivity annotation<a class="headerlink" href="#syntax-of-injectivity-annotation" title="Permalink to this heading">¶</a></h3>
<p>The injectivity annotation is added after the type family head and consists of
two parts:</p>
<ul class="simple">
<li><p>a type variable that names the result of a type family. Syntax:
<code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">tyvar</span></code> or <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">(tyvar</span> <span class="pre">::</span> <span class="pre">kind)</span></code>. The type variable must be fresh.</p></li>
<li><p>an injectivity annotation of the form <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span></code>, where <code class="docutils literal notranslate"><span class="pre">A</span></code> is the
result type variable (see previous bullet) and <code class="docutils literal notranslate"><span class="pre">B</span></code> is a list of
argument type and kind variables in which type family is injective.
It is possible to omit some variables if the type family is not injective
in them.</p></li>
</ul>
<p>Examples:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">Id</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
</pre></div>
</div>
<p>For open and closed type families it is OK to name the result but skip
the injectivity annotation. This is not the case for associated type
synonyms, where the named result without injectivity annotation will be
interpreted as associated type synonym default.</p>
</section>
<section id="verifying-the-injectivity-annotation-against-type-family-equations">
<span id="injective-ty-fams-typecheck"></span><h3><span class="section-number">6.4.9.7.2. </span>Verifying the injectivity annotation against type family equations<a class="headerlink" href="#verifying-the-injectivity-annotation-against-type-family-equations" title="Permalink to this heading">¶</a></h3>
<p>Once the user declares type family to be injective GHC must verify that
this declaration is correct, i.e., that type family equations don’t violate the
injectivity annotation. A general idea is that if at least one equation
(bullets (1), (2) and (3) below) or a pair of equations (bullets (4) and
(5) below) violates the injectivity annotation then a type family is not
injective in a way the user claims and an error is reported. In the bullets
below <em>RHS</em> refers to the right-hand side of the type family equation
being checked for injectivity. <em>LHS</em> refers to the arguments of that
type family equation. Below are the rules followed when checking
injectivity of a type family:</p>
<ol class="arabic">
<li><p>If a RHS of a type family equation is a type family application GHC
reports that the type family is not injective.</p></li>
<li><p>If a RHS of a type family equation is a bare type variable we require
that all LHS variables (including implicit kind variables) are also
bare. In other words, this has to be a sole equation of that type
family and it has to cover all possible patterns. If the patterns are
not covering GHC reports that the type family is not injective.</p></li>
<li><p>If a LHS type variable that is declared as injective is not mentioned
on injective position
in the RHS GHC reports that the type family is not injective.
Injective position means either argument to a type constructor or
injective argument to a type family. Type inference can potentially
loop when looking under injective type families in the RHS, so this
requires <a class="reference internal" href="instances.html#extension-UndecidableInstances"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UndecidableInstances</span></code></a>; GHC suggests enabling
the flag when it is necessary.</p></li>
<li><p><em>Open type families</em> Open type families are typechecked
incrementally. This means that when a module is imported type family
instances contained in that module are checked against instances
present in already imported modules.</p>
<p>A pair of an open type family equations is checked by attempting to
unify their RHSs. If the RHSs don’t unify this pair does not violate
injectivity annotation. If unification succeeds with a substitution
then LHSs of unified equations must be identical under that
substitution. If they are not identical then GHC reports that the
type family is not injective.</p>
</li>
<li><p>In a <em>closed type family</em> all equations are ordered and in one place.
Equations are also checked pair-wise but this time an equation has to
be paired with all the preceding equations. Of course a
single-equation closed type family is trivially injective (unless
(1), (2) or (3) above holds).</p>
<p>When checking a pair of closed type family equations GHC tried to
unify their RHSs. If they don’t unify this pair of equations does not
violate injectivity annotation. If the RHSs can be unified under some
substitution (possibly empty) then either the LHSs unify under the
same substitution or the LHS of the latter equation is subsumed by
earlier equations. If neither condition is met GHC reports that a
type family is not injective.</p>
</li>
</ol>
<p>Note that for the purpose of injectivity check in bullets (4) and (5)
GHC uses a special variant of unification algorithm that treats type
family applications as possibly unifying with anything.</p>
</section>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="data_kinds.html" class="btn btn-neutral float-right" title="6.4.10. Datatype promotion" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="gadt.html" class="btn btn-neutral float-left" title="6.4.8. Generalised Algebraic Data Types (GADTs)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.4.13. Type-Level Literals &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.4.14. Visible type application" href="type_applications.html" />
    <link rel="prev" title="6.4.12. Levity polymorphism" href="levity_polymorphism.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="types.html">6.4. Types</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="nullary_types.html">6.4.1. Data types with no constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatype_contexts.html">6.4.2. Data type contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="infix_tycons.html">6.4.3. Infix type constructors, classes, and type variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_operators.html">6.4.4. Type operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="liberal_type_synonyms.html">6.4.5. Liberalised type synonyms</a></li>
<li class="toctree-l3"><a class="reference internal" href="existential_quantification.html">6.4.6. Existentially quantified data constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadt_syntax.html">6.4.7. Declaring data types with explicit constructor signatures</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadt.html">6.4.8. Generalised Algebraic Data Types (GADTs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_families.html">6.4.9. Type families</a></li>
<li class="toctree-l3"><a class="reference internal" href="data_kinds.html">6.4.10. Datatype promotion</a></li>
<li class="toctree-l3"><a class="reference internal" href="poly_kinds.html">6.4.11. Kind polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="levity_polymorphism.html">6.4.12. Levity polymorphism</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.4.13. Type-Level Literals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#runtime-values-for-type-level-literals">6.4.13.1. Runtime Values for Type-Level Literals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#computing-with-type-level-naturals">6.4.13.2. Computing With Type-Level Naturals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="type_applications.html">6.4.14. Visible type application</a></li>
<li class="toctree-l3"><a class="reference internal" href="rank_polymorphism.html">6.4.15. Arbitrary-rank polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="impredicative_types.html">6.4.16. Impredicative polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="linear_types.html">6.4.17. Linear types</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_errors.html">6.4.18. Custom compile-time errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="defer_type_errors.html">6.4.19. Deferring type errors to runtime</a></li>
<li class="toctree-l3"><a class="reference internal" href="roles.html">6.4.20. Roles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="types.html"><span class="section-number">6.4. </span>Types</a> &raquo;</li>
        
      <li><span class="section-number">6.4.13. </span>Type-Level Literals</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/type_literals.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="type-level-literals">
<span id="id1"></span><h1><span class="section-number">6.4.13. </span>Type-Level Literals<a class="headerlink" href="#type-level-literals" title="Permalink to this heading">¶</a></h1>
<p>GHC supports numeric, string, and character literals at the type level, giving
convenient access to a large number of predefined type-level constants.
Numeric literals are of kind <code class="docutils literal notranslate"><span class="pre">Natural</span></code>, string literals are of kind <code class="docutils literal notranslate"><span class="pre">Symbol</span></code>,
and character literals are of kind <code class="docutils literal notranslate"><span class="pre">Char</span></code>.
This feature is enabled by the <a class="reference internal" href="data_kinds.html#extension-DataKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DataKinds</span></code></a> language extension.</p>
<p>The kinds of the literals and all other low-level operations for this
feature are defined in modules <code class="docutils literal notranslate"><span class="pre">GHC.TypeLits</span></code> and <code class="docutils literal notranslate"><span class="pre">GHC.TypeNats</span></code>.
Note that these modules define some type-level operators that clash with their
value-level counterparts (e.g. <code class="docutils literal notranslate"><span class="pre">(+)</span></code>). Import and export declarations
referring to these operators require an explicit namespace annotation (see
<a class="reference internal" href="explicit_namespaces.html#explicit-namespaces"><span class="std std-ref">Explicit namespaces in import/export</span></a>).</p>
<p>Here is an example of using type-level numeric literals to provide a
safe interface to a low-level function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="w"> </span><span class="nn">GHC.TypeLits</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Data.Word</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Foreign</span><span class="w"></span>

<span class="kr">newtype</span><span class="w"> </span><span class="kt">ArrPtr</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Natural</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">ArrPtr</span><span class="w"> </span><span class="p">(</span><span class="kt">Ptr</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>

<span class="nf">clearPage</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ArrPtr</span><span class="w"> </span><span class="mi">4096</span><span class="w"> </span><span class="kt">Word8</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">clearPage</span><span class="w"> </span><span class="p">(</span><span class="kt">ArrPtr</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Also type-level naturals could be promoted from the <code class="docutils literal notranslate"><span class="pre">Natural</span></code> data type
using <cite>DataKinds</cite>, for example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkPoint</span><span class="w"> </span><span class="kt">Natural</span><span class="w"> </span><span class="kt">Natural</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">MyCoordinates</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkPoint</span><span class="w"> </span><span class="mi">95</span><span class="w"> </span><span class="mi">101</span><span class="w"></span>
</pre></div>
</div>
<p>Here is an example of using type-level string literals to simulate
simple record operations:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Label</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Symbol</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Get</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">Has</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">from</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Label</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Show</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Has</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="p">(</span><span class="kt">Point</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Has</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="s">&quot;y&quot;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="p">(</span><span class="kt">Point</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">y</span><span class="w"></span>

<span class="nf">example</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="p">(</span><span class="kt">Point</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Get</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Label</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<section id="runtime-values-for-type-level-literals">
<span id="typelit-runtime"></span><h2><span class="section-number">6.4.13.1. </span>Runtime Values for Type-Level Literals<a class="headerlink" href="#runtime-values-for-type-level-literals" title="Permalink to this heading">¶</a></h2>
<p>Sometimes it is useful to access the value-level literal associated with
a type-level literal. This is done with the functions <code class="docutils literal notranslate"><span class="pre">natVal</span></code> and
<code class="docutils literal notranslate"><span class="pre">symbolVal</span></code>. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GHC</span><span class="o">.</span><span class="kt">TypeLits</span><span class="o">&gt;</span><span class="w"> </span><span class="n">natVal</span><span class="w"> </span><span class="p">(</span><span class="kt">Proxy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="mi">2</span><span class="w"></span>
</pre></div>
</div>
<p>These functions are overloaded because they need to return a different
result, depending on the type at which they are instantiated.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">natVal</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">KnownNat</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">proxy</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Natural</span><span class="w">  </span><span class="c1">-- from GHC.TypeNats</span><span class="w"></span>
<span class="nf">natVal</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">KnownNat</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">proxy</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w">  </span><span class="c1">-- from GHC.TypeLits</span><span class="w"></span>

<span class="c1">-- instance KnownNat 0</span><span class="w"></span>
<span class="c1">-- instance KnownNat 1</span><span class="w"></span>
<span class="c1">-- instance KnownNat 2</span><span class="w"></span>
<span class="c1">-- ...</span><span class="w"></span>
</pre></div>
</div>
<p>GHC discharges the constraint as soon as it knows what concrete
type-level literal is being used in the program. Note that this works
only for <em>literals</em> and not arbitrary type expressions. For example, a
constraint of the form <code class="docutils literal notranslate"><span class="pre">KnownNat</span> <span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span></code> will <em>not</em> be simplified to
<code class="docutils literal notranslate"><span class="pre">(KnownNat</span> <span class="pre">a,</span> <span class="pre">KnownNat</span> <span class="pre">b)</span></code>; instead, GHC will keep the constraint as
is, until it can simplify <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> to a constant value.</p>
<p>It is also possible to convert a run-time integer or string value to the
corresponding type-level literal. Of course, the resulting type literal
will be unknown at compile-time, so it is hidden in an existential type.
The conversion may be performed using <code class="docutils literal notranslate"><span class="pre">someNatVal</span></code> for integers and
<code class="docutils literal notranslate"><span class="pre">someSymbolVal</span></code> for strings:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">someNatVal</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Natural</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">SomeNat</span><span class="w">  </span><span class="c1">-- from GHC.TypeNats</span><span class="w"></span>
<span class="nf">someNatVal</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">SomeNat</span><span class="w">  </span><span class="c1">-- from GHC.TypeLits</span><span class="w"></span>

<span class="kt">SomeNat</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="kt">KnownNat</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">SomeNat</span><span class="w"></span>
</pre></div>
</div>
<p>The operations on strings are similar.</p>
</section>
<section id="computing-with-type-level-naturals">
<span id="typelit-tyfuns"></span><h2><span class="section-number">6.4.13.2. </span>Computing With Type-Level Naturals<a class="headerlink" href="#computing-with-type-level-naturals" title="Permalink to this heading">¶</a></h2>
<p>GHC 7.8 can evaluate arithmetic expressions involving type-level natural
numbers. Such expressions may be constructed using the type-families
<code class="docutils literal notranslate"><span class="pre">(+),</span> <span class="pre">(*),</span> <span class="pre">(^)</span></code> for addition, multiplication, and exponentiation.
Numbers may be compared using <code class="docutils literal notranslate"><span class="pre">(&lt;=?)</span></code>, which returns a promoted
boolean value, or <code class="docutils literal notranslate"><span class="pre">(&lt;=)</span></code>, which compares numbers as a constraint. For
example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GHC.TypeLits&gt; natVal (Proxy :: Proxy (2 + 3))
5
</pre></div>
</div>
<p>At present, GHC is quite limited in its reasoning about arithmetic: it
will only evaluate the arithmetic type functions and compare the
results— in the same way that it does for any other type function. In
particular, it does not know more general facts about arithmetic, such
as the commutativity and associativity of <code class="docutils literal notranslate"><span class="pre">(+)</span></code>, for example.</p>
<p>However, it is possible to perform a bit of “backwards” evaluation. For
example, here is how we could get GHC to compute arbitrary logarithms at
the type level:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lg :: Proxy base -&gt; Proxy (base ^ pow) -&gt; Proxy pow
lg _ _ = Proxy

GHC.TypeLits&gt; natVal (lg (Proxy :: Proxy 2) (Proxy :: Proxy 8))
3
</pre></div>
</div>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="type_applications.html" class="btn btn-neutral float-right" title="6.4.14. Visible type application" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="levity_polymorphism.html" class="btn btn-neutral float-left" title="6.4.12. Levity polymorphism" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
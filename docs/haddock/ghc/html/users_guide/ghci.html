

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>3. Using GHCi &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="4. Using runghc" href="runghc.html" />
    <link rel="prev" title="2.4. Version 9.2.4" href="9.2.4-notes.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">2. Release notes</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3. Using GHCi</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-to-ghci">3.1. Introduction to GHCi</a></li>
<li class="toctree-l2"><a class="reference internal" href="#loading-source-files">3.2. Loading source files</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modules-vs-filenames">3.2.1. Modules vs. filenames</a></li>
<li class="toctree-l3"><a class="reference internal" href="#making-changes-and-recompilation">3.2.2. Making changes and recompilation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#loading-compiled-code">3.3. Loading compiled code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interactive-evaluation-at-the-prompt">3.4. Interactive evaluation at the prompt</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#i-o-actions-at-the-prompt">3.4.1. I/O actions at the prompt</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-do-notation-at-the-prompt">3.4.2. Using <code class="docutils literal notranslate"><span class="pre">do</span></code> notation at the prompt</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiline-input">3.4.3. Multiline input</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-class-and-other-declarations">3.4.4. Type, class and other declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-s-really-in-scope-at-the-prompt">3.4.5. What’s really in scope at the prompt?</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-effect-of-load-on-what-is-in-scope">3.4.5.1. The effect of <code class="docutils literal notranslate"><span class="pre">:load</span></code> on what is in scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="#controlling-what-is-in-scope-with-import">3.4.5.2. Controlling what is in scope with <code class="docutils literal notranslate"><span class="pre">import</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#controlling-what-is-in-scope-with-the-module-command">3.4.5.3. Controlling what is in scope with the <code class="docutils literal notranslate"><span class="pre">:module</span></code> command</a></li>
<li class="toctree-l4"><a class="reference internal" href="#qualified-names">3.4.5.4. Qualified names</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-and-load">3.4.5.5. <code class="docutils literal notranslate"><span class="pre">:module</span></code> and <code class="docutils literal notranslate"><span class="pre">:load</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-main-and-run-commands">3.4.6. The <code class="docutils literal notranslate"><span class="pre">:main</span></code> and <code class="docutils literal notranslate"><span class="pre">:run</span></code> commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-it-variable">3.4.7. The <code class="docutils literal notranslate"><span class="pre">it</span></code> variable</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-defaulting-in-ghci">3.4.8. Type defaulting in GHCi</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#interactive-classes">3.4.8.1. Interactive classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extended-rules-around-default-declarations">3.4.8.2. Extended rules around <code class="docutils literal notranslate"><span class="pre">default</span></code> declarations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-a-custom-interactive-printing-function">3.4.9. Using a custom interactive printing function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stack-traces-in-ghci">3.4.10. Stack Traces in GHCi</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-ghci-debugger">3.5. The GHCi Debugger</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#breakpoints-and-inspecting-variables">3.5.1. Breakpoints and inspecting variables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#setting-breakpoints">3.5.1.1. Setting breakpoints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#managing-breakpoints">3.5.1.2. Managing breakpoints</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#single-stepping">3.5.2. Single-stepping</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nested-breakpoints">3.5.3. Nested breakpoints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-result-variable">3.5.4. The <code class="docutils literal notranslate"><span class="pre">_result</span></code> variable</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tracing-and-history">3.5.5. Tracing and history</a></li>
<li class="toctree-l3"><a class="reference internal" href="#debugging-exceptions">3.5.6. Debugging exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-inspecting-functions">3.5.7. Example: inspecting functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#limitations">3.5.8. Limitations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#invoking-ghci">3.6. Invoking GHCi</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#packages">3.6.1. Packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extra-libraries">3.6.2. Extra libraries</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ghci-commands">3.7. GHCi commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-set-and-seti-commands">3.8. The <code class="docutils literal notranslate"><span class="pre">:set</span></code> and <code class="docutils literal notranslate"><span class="pre">:seti</span></code> commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ghci-options">3.8.1. GHCi options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setting-ghc-command-line-options-in-ghci">3.8.2. Setting GHC command-line options in GHCi</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setting-options-for-interactive-evaluation-only">3.8.3. Setting options for interactive evaluation only</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-ghci-and-haskeline-files">3.9. The <code class="docutils literal notranslate"><span class="pre">.ghci</span></code> and <code class="docutils literal notranslate"><span class="pre">.haskeline</span></code> files</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-ghci-files">3.9.1. The <code class="docutils literal notranslate"><span class="pre">.ghci</span></code> files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-haskeline-file">3.9.2. The <code class="docutils literal notranslate"><span class="pre">.haskeline</span></code> file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compiling-to-object-code-inside-ghci">3.10. Compiling to object code inside GHCi</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-the-interpreter-in-a-separate-process">3.11. Running the interpreter in a separate process</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-the-interpreter-on-a-different-host">3.12. Running the interpreter on a different host</a></li>
<li class="toctree-l2"><a class="reference internal" href="#faq-and-things-to-watch-out-for">3.13. FAQ and Things To Watch Out For</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">5. Using GHC</a></li>
<li class="toctree-l1"><a class="reference internal" href="exts.html">6. Language extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li><span class="section-number">3. </span>Using GHCi</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/ghci.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="using-ghci">
<span id="ghci"></span><h1><span class="section-number">3. </span>Using GHCi<a class="headerlink" href="#using-ghci" title="Permalink to this heading">¶</a></h1>
<p id="index-0">GHCi <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> is GHC’s interactive environment that includes an interactive
debugger (see <a class="reference internal" href="#ghci-debugger"><span class="std std-ref">The GHCi Debugger</span></a>).</p>
<p>GHCi can</p>
<ul class="simple">
<li><p>interactively evaluate Haskell expressions</p></li>
<li><p>interpret Haskell programs</p></li>
<li><p>load GHC-compiled modules.</p></li>
</ul>
<p>At the moment GHCi supports most of GHC’s language extensions.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>The “i” stands for “Interactive”</p>
</aside>
</aside>
<section id="introduction-to-ghci">
<span id="ghci-introduction"></span><h2><span class="section-number">3.1. </span>Introduction to GHCi<a class="headerlink" href="#introduction-to-ghci" title="Permalink to this heading">¶</a></h2>
<p>Let’s start with an example GHCi session. You can fire up GHCi with the
command <code class="docutils literal notranslate"><span class="pre">ghci</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ghci
GHCi, version 8.y.z: https://www.haskell.org/ghc/  :? for help
ghci&gt;
</pre></div>
</div>
<p>There may be a short pause while GHCi loads the prelude and standard
libraries, after which the prompt is shown. As the banner says, you can
type <a class="reference internal" href="#ghci-cmd-2"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:?</span></code></a> to see the list of commands available, and a half line
description of each of them. We’ll explain most of these commands as we
go along, and there is complete documentation for all the commands in
<a class="reference internal" href="#ghci-commands"><span class="std std-ref">GHCi commands</span></a>.</p>
<p>Haskell expressions can be typed at the prompt:</p>
<div class="highlight-none notranslate" id="index-1"><div class="highlight"><pre><span></span>ghci&gt; 1+2
3
ghci&gt; let x = 42 in x / 9
4.666666666666667
ghci&gt;
</pre></div>
</div>
<p>GHCi interprets the whole line as an expression to evaluate. The
expression may not span several lines - as soon as you press enter, GHCi
will attempt to evaluate it.</p>
<p>In Haskell, a <code class="docutils literal notranslate"><span class="pre">let</span></code> expression is followed by <code class="docutils literal notranslate"><span class="pre">in</span></code>. However, in
GHCi, since the expression can also be interpreted in the <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad,
a <code class="docutils literal notranslate"><span class="pre">let</span></code> binding with no accompanying <code class="docutils literal notranslate"><span class="pre">in</span></code> statement can be signalled
by an empty line, as in the above example.</p>
<p>Since GHC 8.0.1, you can bind values and functions to names without <code class="docutils literal notranslate"><span class="pre">let</span></code> statement:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; x = 42
ghci&gt; x
42
ghci&gt;
</pre></div>
</div>
</section>
<section id="loading-source-files">
<span id="id3"></span><h2><span class="section-number">3.2. </span>Loading source files<a class="headerlink" href="#loading-source-files" title="Permalink to this heading">¶</a></h2>
<p>Suppose we have the following Haskell source code, which we place in a
file <code class="docutils literal notranslate"><span class="pre">Main.hs</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="p">(</span><span class="n">fac</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"></span>

<span class="nf">fac</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="nf">fac</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fac</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>You can save <code class="docutils literal notranslate"><span class="pre">Main.hs</span></code> anywhere you like, but if you save it somewhere
other than the current directory <a class="footnote-reference brackets" href="#id5" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> then we will need to change to the
right directory in GHCi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :cd dir
</pre></div>
</div>
<p>where ⟨dir⟩ is the directory (or folder) in which you saved <code class="docutils literal notranslate"><span class="pre">Main.hs</span></code>.</p>
<p>To load a Haskell source file into GHCi, use the <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a> command:</p>
<div class="highlight-none notranslate" id="index-2"><div class="highlight"><pre><span></span>ghci&gt; :load Main
Compiling Main             ( Main.hs, interpreted )
Ok, modules loaded: Main.
*ghci&gt;
</pre></div>
</div>
<p>GHCi has loaded the <code class="docutils literal notranslate"><span class="pre">Main</span></code> module, and the prompt has changed to
<code class="docutils literal notranslate"><span class="pre">*ghci&gt;</span></code> to indicate that the current context for expressions
typed at the prompt is the <code class="docutils literal notranslate"><span class="pre">Main</span></code> module we just loaded (we’ll explain
what the <code class="docutils literal notranslate"><span class="pre">*</span></code> means later in <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a>). So we can now type
expressions involving the functions from <code class="docutils literal notranslate"><span class="pre">Main.hs</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; fac 17
355687428096000
</pre></div>
</div>
<p>Loading a multi-module program is just as straightforward; just give the
name of the “topmost” module to the <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a> command (hint:
<a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a> can be abbreviated to <code class="docutils literal notranslate"><span class="pre">:l</span></code>). The topmost module will
normally be <code class="docutils literal notranslate"><span class="pre">Main</span></code>, but it doesn’t have to be. GHCi will discover which
modules are required, directly or indirectly, by the topmost module, and load
them all in dependency order.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>If you started up GHCi from the command line then GHCi’s current
directory is the same as the current directory of the shell from
which it was started. If you started GHCi from the “Start” menu in
Windows, then the current directory is probably something like
<code class="docutils literal notranslate"><span class="pre">C:\Documents</span> <span class="pre">and</span> <span class="pre">Settings\user</span> <span class="pre">name</span></code>.</p>
</aside>
</aside>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fshow-loaded-modules">
<span class="sig-name descname"><span class="pre">-fshow-loaded-modules</span></span><a class="headerlink" href="#ghc-flag-fshow-loaded-modules" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>8.2.2</p>
</dd>
</dl>
<p>Typically GHCi will show only the number of modules that it loaded after a
<a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a> command. With this flag, GHC will also list the loaded
modules’ names. This was the default behavior prior to GHC 8.2.1 and can be
useful for some tooling users.</p>
</dd></dl>

<section id="modules-vs-filenames">
<span id="ghci-modules-filenames"></span><h3><span class="section-number">3.2.1. </span>Modules vs. filenames<a class="headerlink" href="#modules-vs-filenames" title="Permalink to this heading">¶</a></h3>
<p id="index-3">Question: How does GHC find the filename which contains module ⟨M⟩?
Answer: it looks for the file <code class="docutils literal notranslate"><span class="pre">M.hs</span></code>, or <code class="docutils literal notranslate"><span class="pre">M.lhs</span></code>. This means that
for most modules, the module name must match the filename. If it
doesn’t, GHCi won’t be able to find it.</p>
<p>There is one exception to this general rule: when you load a program
with <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>, or specify it when you invoke <code class="docutils literal notranslate"><span class="pre">ghci</span></code>, you can give a
filename rather than a module name. This filename is loaded if it
exists, and it may contain any module you like. This is particularly
convenient if you have several <code class="docutils literal notranslate"><span class="pre">Main</span></code> modules in the same directory
and you can’t call them all <code class="docutils literal notranslate"><span class="pre">Main.hs</span></code>.</p>
<p>The search path for finding source files is specified with the <a class="reference internal" href="separate_compilation.html#ghc-flag-i"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-i</span></code></a>
option on the GHCi command line, like so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci -idir1:...:dirn
</pre></div>
</div>
<p>or it can be set using the <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a> command from within GHCi (see
<a class="reference internal" href="#ghci-cmd-line-options"><span class="std std-ref">Setting GHC command-line options in GHCi</span></a>) <a class="footnote-reference brackets" href="#id7" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p>
<p>One consequence of the way that GHCi follows dependencies to find
modules to load is that every module must have a source file. The only
exception to the rule is modules that come from a package, including the
<code class="docutils literal notranslate"><span class="pre">Prelude</span></code> and standard libraries such as <code class="docutils literal notranslate"><span class="pre">IO</span></code> and <code class="docutils literal notranslate"><span class="pre">Complex</span></code>. If
you attempt to load a module for which GHCi can’t find a source file,
even if there are object and interface files for the module, you’ll get
an error message.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">4</a><span class="fn-bracket">]</span></span>
<p>Note that in GHCi, and <a class="reference internal" href="using.html#ghc-flag-make"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">--make</span></code></a> mode, the <a class="reference internal" href="separate_compilation.html#ghc-flag-i"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-i</span></code></a> option is used to
specify the search path for <em>source</em> files, whereas in standard
batch-compilation mode the <a class="reference internal" href="separate_compilation.html#ghc-flag-i"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-i</span></code></a> option is used to specify the
search path for interface files, see <a class="reference internal" href="separate_compilation.html#search-path"><span class="std std-ref">The search path</span></a>.</p>
</aside>
</aside>
</section>
<section id="making-changes-and-recompilation">
<h3><span class="section-number">3.2.2. </span>Making changes and recompilation<a class="headerlink" href="#making-changes-and-recompilation" title="Permalink to this heading">¶</a></h3>
<p id="index-4">If you make some changes to the source code and want GHCi to recompile
the program, give the <a class="reference internal" href="#ghci-cmd-reload"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:reload</span></code></a> command. The program will be
recompiled as necessary, with GHCi doing its best to avoid actually
recompiling modules if their external dependencies haven’t changed. This
is the same mechanism we use to avoid re-compiling modules in the batch
compilation setting (see <a class="reference internal" href="separate_compilation.html#recomp"><span class="std std-ref">The recompilation checker</span></a>).</p>
</section>
</section>
<section id="loading-compiled-code">
<span id="ghci-compiled"></span><h2><span class="section-number">3.3. </span>Loading compiled code<a class="headerlink" href="#loading-compiled-code" title="Permalink to this heading">¶</a></h2>
<p id="index-5">When you load a Haskell source module into GHCi, it is normally
converted to byte-code and run using the interpreter. However,
interpreted code can also run alongside compiled code in GHCi; indeed,
normally when GHCi starts, it loads up a compiled copy of the <code class="docutils literal notranslate"><span class="pre">base</span></code>
package, which contains the <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>.</p>
<p>Why should we want to run compiled code? Well, compiled code is roughly
10x faster than interpreted code, but takes about 2x longer to produce
(perhaps longer if optimisation is on). So it pays to compile the parts
of a program that aren’t changing very often, and use the interpreter
for the code being actively developed.</p>
<p>When loading up source modules with <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>, GHCi normally looks for
any corresponding compiled object files, and will use one in preference
to interpreting the source if possible. For example, suppose we have a 4-module
program consisting of modules <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span></code>, and <code class="docutils literal notranslate"><span class="pre">D</span></code>. Modules <code class="docutils literal notranslate"><span class="pre">B</span></code> and
<code class="docutils literal notranslate"><span class="pre">C</span></code> both import <code class="docutils literal notranslate"><span class="pre">D</span></code> only, and <code class="docutils literal notranslate"><span class="pre">A</span></code> imports both <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  A
 / \
B   C
 \ /
  D
</pre></div>
</div>
<p>We can compile <code class="docutils literal notranslate"><span class="pre">D</span></code>, then load the whole program, like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :! ghc -c -dynamic D.hs
ghci&gt; :load A
Compiling B                ( B.hs, interpreted )
Compiling C                ( C.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D (D.o).
*ghci&gt;
</pre></div>
</div>
<p>In the messages from the compiler, we see that there is no line for
<code class="docutils literal notranslate"><span class="pre">D</span></code>. This is because it isn’t necessary to compile <code class="docutils literal notranslate"><span class="pre">D</span></code>, because the
source and everything it depends on is unchanged since the last
compilation.</p>
<p>Note the <a class="reference internal" href="phases.html#ghc-flag-dynamic"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-dynamic</span></code></a> flag to GHC: GHCi uses dynamically-linked object
code (if you are on a platform that supports it), and so in order to use
compiled code with GHCi it must be compiled for dynamic linking.</p>
<p>At any time you can use the command <a class="reference internal" href="#ghci-cmd-show-modules"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">modules</span></code></a> to get a list of
the modules currently loaded into GHCi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :show modules
D                ( D.hs, D.o )
C                ( C.hs, interpreted )
B                ( B.hs, interpreted )
A                ( A.hs, interpreted )
*ghci&gt;
</pre></div>
</div>
<p>If we now modify the source of <code class="docutils literal notranslate"><span class="pre">D</span></code> (or pretend to: using the Unix command
<code class="docutils literal notranslate"><span class="pre">touch</span></code> on the source file is handy for this), the compiler will no
longer be able to use the object file, because it might be out of date:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :! touch D.hs
*ghci&gt; :reload
Compiling D                ( D.hs, interpreted )
Ok, modules loaded: A, B, C, D.
*ghci&gt;
</pre></div>
</div>
<p>Note that module <code class="docutils literal notranslate"><span class="pre">D</span></code> was compiled, but in this instance because its source
hadn’t really changed, its interface remained the same, and the
recompilation checker determined that <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code> didn’t need to be
recompiled.</p>
<p>So let’s try compiling one of the other modules:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :! ghc -c C.hs
*ghci&gt; :load A
Compiling D                ( D.hs, interpreted )
Compiling B                ( B.hs, interpreted )
Compiling C                ( C.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D.
</pre></div>
</div>
<p>We didn’t get the compiled version of <code class="docutils literal notranslate"><span class="pre">C</span></code>! What happened? Well, in GHCi a
compiled module may only depend on other compiled modules, and in this
case <code class="docutils literal notranslate"><span class="pre">C</span></code> depends on <code class="docutils literal notranslate"><span class="pre">D</span></code>, which doesn’t have an object file, so GHCi also
rejected <code class="docutils literal notranslate"><span class="pre">C</span></code>'s object file. Ok, so let’s also compile <code class="docutils literal notranslate"><span class="pre">D</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :! ghc -c D.hs
*ghci&gt; :reload
Ok, modules loaded: A, B, C, D.
</pre></div>
</div>
<p>Nothing happened! Here’s another lesson: newly compiled modules aren’t
picked up by <a class="reference internal" href="#ghci-cmd-reload"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:reload</span></code></a>, only <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :load A
Compiling B                ( B.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C (C.o), D (D.o).
</pre></div>
</div>
<p>The automatic loading of object files can sometimes lead to confusion,
because non-exported top-level definitions of a module are only
available for use in expressions at the prompt when the module is
interpreted (see <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a>). For this reason, you might
sometimes want to force GHCi to load a module using the interpreter.
This can be done by prefixing a <code class="docutils literal notranslate"><span class="pre">*</span></code> to the module name or filename
when using <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>, for example</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :load *A
Compiling A                ( A.hs, interpreted )
*ghci&gt;
</pre></div>
</div>
<p>When the <code class="docutils literal notranslate"><span class="pre">*</span></code> is used, GHCi ignores any pre-compiled object code and
interprets the module. If you have already loaded a number of modules as
object code and decide that you wanted to interpret one of them, instead
of re-loading the whole set you can use <code class="docutils literal notranslate"><span class="pre">:add</span> <span class="pre">*M</span></code> to specify that you
want <code class="docutils literal notranslate"><span class="pre">M</span></code> to be interpreted (note that this might cause other modules
to be interpreted too, because compiled modules cannot depend on
interpreted ones).</p>
<p>To always compile everything to object code and never use the
interpreter, use the <a class="reference internal" href="phases.html#ghc-flag-fobject-code"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fobject-code</span></code></a> option (see <a class="reference internal" href="#ghci-obj"><span class="std std-ref">Compiling to object code inside GHCi</span></a>).</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Since GHCi will only use a compiled object file if it can be sure
that the compiled version is up-to-date, a good technique when working
on a large program is to occasionally run <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">--make</span></code> to compile the
whole project (say before you go for lunch :-), then continue working in
the interpreter. As you modify code, the changed modules will be
interpreted, but the rest of the project will remain compiled.</p>
</div>
</section>
<section id="interactive-evaluation-at-the-prompt">
<span id="interactive-evaluation"></span><h2><span class="section-number">3.4. </span>Interactive evaluation at the prompt<a class="headerlink" href="#interactive-evaluation-at-the-prompt" title="Permalink to this heading">¶</a></h2>
<p>When you type an expression at the prompt, GHCi immediately evaluates
and prints the result:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; reverse &quot;hello&quot;
&quot;olleh&quot;
ghci&gt; 5+5
10
</pre></div>
</div>
<section id="i-o-actions-at-the-prompt">
<span id="actions-at-prompt"></span><h3><span class="section-number">3.4.1. </span>I/O actions at the prompt<a class="headerlink" href="#i-o-actions-at-the-prompt" title="Permalink to this heading">¶</a></h3>
<p>GHCi does more than simple expression evaluation at the prompt. If you
enter an expression of type <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">a</span></code> for some <code class="docutils literal notranslate"><span class="pre">a</span></code>, then GHCi
<em>executes</em> it as an IO-computation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; &quot;hello&quot;
&quot;hello&quot;
ghci&gt; putStrLn &quot;hello&quot;
hello
</pre></div>
</div>
<p>This works even if the type of the expression is more general, provided
it can be <em>instantiated</em> to <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">a</span></code>. For example</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; return True
True
</pre></div>
</div>
<p>Furthermore, GHCi will print the result of the I/O action if (and only
if):</p>
<ul class="simple">
<li><p>The result type is an instance of <code class="docutils literal notranslate"><span class="pre">Show</span></code>.</p></li>
<li><p>The result type is not <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p></li>
</ul>
<p>For example, remembering that <code class="docutils literal notranslate"><span class="pre">putStrLn</span> <span class="pre">::</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; putStrLn &quot;hello&quot;
hello
ghci&gt; do { putStrLn &quot;hello&quot;; return &quot;yes&quot; }
hello
&quot;yes&quot;
</pre></div>
</div>
</section>
<section id="using-do-notation-at-the-prompt">
<span id="ghci-stmts"></span><h3><span class="section-number">3.4.2. </span>Using <code class="docutils literal notranslate"><span class="pre">do</span></code> notation at the prompt<a class="headerlink" href="#using-do-notation-at-the-prompt" title="Permalink to this heading">¶</a></h3>
<p id="index-6">GHCi actually accepts statements rather than just expressions at the
prompt. This means you can bind values and functions to names, and use
them in future expressions or statements.</p>
<p>The syntax of a statement accepted at the GHCi prompt is exactly the
same as the syntax of a statement in a Haskell <code class="docutils literal notranslate"><span class="pre">do</span></code> expression.
However, there’s no monad overloading here: statements typed at the
prompt must be in the <code class="docutils literal notranslate"><span class="pre">IO</span></code> monad.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; x &lt;- return 42
ghci&gt; print x
42
ghci&gt;
</pre></div>
</div>
<p>The statement <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">return</span> <span class="pre">42</span></code> means “execute <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">42</span></code> in the
<code class="docutils literal notranslate"><span class="pre">IO</span></code> monad, and bind the result to <code class="docutils literal notranslate"><span class="pre">x</span></code>”. We can then use <code class="docutils literal notranslate"><span class="pre">x</span></code> in
future statements, for example to print it as we did above.</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fprint-bind-result">
<span class="sig-name descname"><span class="pre">-fprint-bind-result</span></span><a class="headerlink" href="#ghc-flag-fprint-bind-result" title="Permalink to this definition">¶</a></dt>
<dd><p>If <a class="reference internal" href="#ghc-flag-fprint-bind-result"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fprint-bind-result</span></code></a> is set then GHCi will print the result of a
statement if and only if:</p>
<ul class="simple">
<li><p>The statement is not a binding, or it is a monadic binding
(<code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&lt;-</span> <span class="pre">e</span></code>) that binds exactly one variable.</p></li>
<li><p>The variable’s type is not polymorphic, is not <code class="docutils literal notranslate"><span class="pre">()</span></code>, and is an
instance of <code class="docutils literal notranslate"><span class="pre">Show</span></code>.</p></li>
</ul>
</dd></dl>

<p>Of course, you can also bind normal non-IO expressions using the
<code class="docutils literal notranslate"><span class="pre">let</span></code>-statement:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; let x = 42
ghci&gt; x
42
ghci&gt;
</pre></div>
</div>
<p>Another important difference between the two types of binding is that
the monadic bind (<code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&lt;-</span> <span class="pre">e</span></code>) is <em>strict</em> (it evaluates <code class="docutils literal notranslate"><span class="pre">e</span></code>), whereas
with the <code class="docutils literal notranslate"><span class="pre">let</span></code> form, the expression isn’t evaluated immediately:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; let x = error &quot;help!&quot;
ghci&gt; print x
*** Exception: help!
ghci&gt;
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">let</span></code> bindings do not automatically print the value bound,
unlike monadic bindings.</p>
<p>You can also define functions at the prompt:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; add a b = a + b
ghci&gt; add 1 2
3
ghci&gt;
</pre></div>
</div>
<p>However, this quickly gets tedious when defining functions with multiple
clauses, or groups of mutually recursive functions, because the complete
definition has to be given on a single line, using explicit semicolons
instead of layout:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; f op n [] = n ; f op n (h:t) = h `op` f op n t
ghci&gt; f (+) 0 [1..3]
6
ghci&gt;
</pre></div>
</div>
<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-0">
<span class="sig-name descname"><span class="pre">:{</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-0" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="ghci-cmd-1">
<span class="sig-name descname"><span class="pre">:}</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-1" title="Permalink to this definition">¶</a></dt>
<dd><p>Begin or end a multi-line GHCi command block.</p>
</dd></dl>

<p>To alleviate this issue, GHCi commands can be split over multiple lines,
by wrapping them in <code class="docutils literal notranslate"><span class="pre">:{</span></code> and <code class="docutils literal notranslate"><span class="pre">:}</span></code> (each on a single line of its
own):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :{
ghci| g op n [] = n
ghci| g op n (h:t) = h `op` g op n t
ghci| :}
ghci&gt; g (*) 1 [1..3]
6
</pre></div>
</div>
<p>Such multiline commands can be used with any GHCi command, and note that
the layout rule is in effect. The main purpose of multiline commands is
not to replace module loading but to make definitions in .ghci-files
(see <a class="reference internal" href="#ghci-dot-files"><span class="std std-ref">The .ghci and .haskeline files</span></a>) more readable and maintainable.</p>
<p>Any exceptions raised during the evaluation or execution of the
statement are caught and printed by the GHCi command line interface (for
more information on exceptions, see the module <a class="reference external" href="./../libraries/base-4.16.3.0/Control-Exception.html">Control.Exception</a> in
the libraries documentation.</p>
<p>Every new binding shadows any existing bindings of the same name,
including entities that are in scope in the current module context.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Temporary bindings introduced at the prompt only last until the
next <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a> or <a class="reference internal" href="#ghci-cmd-reload"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:reload</span></code></a> command, at which time they
will be simply lost. However, they do survive a change of context with
<a class="reference internal" href="#ghci-cmd-module"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:module</span></code></a>: the temporary bindings just move to the new location.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>To get a list of the bindings currently in scope, use the
<a class="reference internal" href="#ghci-cmd-show-bindings"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">bindings</span></code></a> command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :show bindings
x :: Int
ghci&gt;
</pre></div>
</div>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>If you turn on the <code class="docutils literal notranslate"><span class="pre">+t</span></code> option, GHCi will show the type of each
variable bound by a statement. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :set +t
ghci&gt; let (x:xs) = [1..]
x :: Integer
xs :: [Integer]
</pre></div>
</div>
</div>
</section>
<section id="multiline-input">
<span id="ghci-multiline"></span><span id="index-7"></span><h3><span class="section-number">3.4.3. </span>Multiline input<a class="headerlink" href="#multiline-input" title="Permalink to this heading">¶</a></h3>
<p>Apart from the <code class="docutils literal notranslate"><span class="pre">:{</span> <span class="pre">...</span> <span class="pre">:}</span></code> syntax for multi-line input mentioned
above, GHCi also has a multiline mode, enabled by <code class="docutils literal notranslate"><span class="pre">:set</span> <span class="pre">+m</span></code>,
<code class="docutils literal notranslate"><span class="pre">:set</span> <span class="pre">+m</span></code> in which GHCi detects automatically when the current
statement is unfinished and allows further lines to be added. A
multi-line input is terminated with an empty line. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :set +m
ghci&gt; let x = 42
ghci|
</pre></div>
</div>
<p>Further bindings can be added to this <code class="docutils literal notranslate"><span class="pre">let</span></code> statement, so GHCi
indicates that the next line continues the previous one by changing the
prompt. Note that layout is in effect, so to add more bindings to this
<code class="docutils literal notranslate"><span class="pre">let</span></code> we have to line them up:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :set +m
ghci&gt; let x = 42
ghci|     y = 3
ghci|
ghci&gt;
</pre></div>
</div>
<p>Explicit braces and semicolons can be used instead of layout:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; do {
ghci| putStrLn &quot;hello&quot;
ghci| ;putStrLn &quot;world&quot;
ghci| }
hello
world
ghci&gt;
</pre></div>
</div>
<p>Note that after the closing brace, GHCi knows that the current statement
is finished, so no empty line is required.</p>
<p>Multiline mode is useful when entering monadic <code class="docutils literal notranslate"><span class="pre">do</span></code> statements:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; flip evalStateT 0 $ do
ghci| i &lt;- get
ghci| lift $ do
ghci|   putStrLn &quot;Hello World!&quot;
ghci|   print i
ghci|
&quot;Hello World!&quot;
0
ghci&gt;
</pre></div>
</div>
<p>During a multiline interaction, the user can interrupt and return to the
top-level prompt.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; do
ghci| putStrLn &quot;Hello, World!&quot;
ghci| ^C
ghci&gt;
</pre></div>
</div>
</section>
<section id="type-class-and-other-declarations">
<span id="ghci-decls"></span><h3><span class="section-number">3.4.4. </span>Type, class and other declarations<a class="headerlink" href="#type-class-and-other-declarations" title="Permalink to this heading">¶</a></h3>
<p>At the GHCi prompt you can also enter any top-level Haskell declaration,
including <code class="docutils literal notranslate"><span class="pre">data</span></code>, <code class="docutils literal notranslate"><span class="pre">type</span></code>, <code class="docutils literal notranslate"><span class="pre">newtype</span></code>, <code class="docutils literal notranslate"><span class="pre">class</span></code>, <code class="docutils literal notranslate"><span class="pre">instance</span></code>,
<code class="docutils literal notranslate"><span class="pre">deriving</span></code>, and <code class="docutils literal notranslate"><span class="pre">foreign</span></code> declarations. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; data T = A | B | C deriving (Eq, Ord, Show, Enum)
ghci&gt; [A ..]
[A,B,C]
ghci&gt; :i T
data T = A | B | C      -- Defined at &lt;interactive&gt;:2:6
instance Enum T -- Defined at &lt;interactive&gt;:2:45
instance Eq T -- Defined at &lt;interactive&gt;:2:30
instance Ord T -- Defined at &lt;interactive&gt;:2:34
instance Show T -- Defined at &lt;interactive&gt;:2:39
</pre></div>
</div>
<p>As with ordinary variable bindings, later definitions shadow earlier
ones, so you can re-enter a declaration to fix a problem with it or
extend it. But there’s a gotcha: when a new type declaration shadows an
older one, there might be other declarations that refer to the old type.
The thing to remember is that the old type still exists, and these other
declarations still refer to the old type. However, while the old and the
new type have the same name, GHCi will treat them as distinct. For
example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; data T = A | B
ghci&gt; let f A = True; f B = False
ghci&gt; data T = A | B | C
ghci&gt; f A

&lt;interactive&gt;:2:3:
    Couldn&#39;t match expected type `main::Interactive.T&#39;
                with actual type `T&#39;
    In the first argument of `f&#39;, namely `A&#39;
    In the expression: f A
    In an equation for `it&#39;: it = f A
ghci&gt;
</pre></div>
</div>
<p>The old, shadowed, version of <code class="docutils literal notranslate"><span class="pre">T</span></code> is displayed as
<code class="docutils literal notranslate"><span class="pre">main::Interactive.T</span></code> by GHCi in an attempt to distinguish it from the
new <code class="docutils literal notranslate"><span class="pre">T</span></code>, which is displayed as simply <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<p>Class and type-family instance declarations are simply added to the
list of available instances, with one exception. Since you might want
to re-define one, a class instance <em>replaces</em> any earlier instance
with an identical head. You aren’t allowed to re-define a type family
instance, since it might not be type safe to do so. Instead, re-define
the whole type-family. (See <a class="reference internal" href="exts/type_families.html#type-families"><span class="std std-ref">Type families</span></a>.) For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; type family T a b
ghci&gt; type instance T a b = a
ghci&gt; let uc :: a -&gt; T a b; uc = id

ghci&gt; type instance T a b = b

&lt;interactive&gt;:3:15: error:
    Conflicting family instance declarations:
      T a b = a -- Defined at &lt;interactive&gt;:3:15
      T a b = b -- Defined at &lt;interactive&gt;:5:15

-- Darn! We have to re-declare T.

ghci&gt; type family T a b
-- This is a brand-new T, unrelated to the old one
ghci&gt; type instance T a b = b
ghci&gt; uc &#39;a&#39; :: Int

&lt;interactive&gt;:8:1: error:
    • Couldn&#39;t match type ‘Char’ with ‘Int’
      Expected type: Int
        Actual type: Ghci1.T Char b0
    • In the expression: uc &#39;a&#39; :: Int
      In an equation for ‘it’: it = uc &#39;a&#39; :: Int
</pre></div>
</div>
</section>
<section id="what-s-really-in-scope-at-the-prompt">
<span id="ghci-scope"></span><h3><span class="section-number">3.4.5. </span>What’s really in scope at the prompt?<a class="headerlink" href="#what-s-really-in-scope-at-the-prompt" title="Permalink to this heading">¶</a></h3>
<p>When you type an expression at the prompt, what identifiers and types
are in scope? GHCi provides a flexible way to control exactly how the
context for an expression is constructed:</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>, <a class="reference internal" href="#ghci-cmd-add"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:add</span></code></a>, and <a class="reference internal" href="#ghci-cmd-reload"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:reload</span></code></a> commands
(<a class="reference internal" href="#ghci-load-scope"><span class="std std-ref">The effect of :load on what is in scope</span></a>).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">import</span></code> declaration (<a class="reference internal" href="#ghci-import-decl"><span class="std std-ref">Controlling what is in scope with import</span></a>).</p></li>
<li><p>The <a class="reference internal" href="#ghci-cmd-module"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:module</span></code></a> command (<a class="reference internal" href="#ghci-module-cmd"><span class="std std-ref">Controlling what is in scope with the :module command</span></a>).</p></li>
</ul>
<p>The command <a class="reference internal" href="#ghci-cmd-show-imports"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">imports</span></code></a> will show a summary of which modules
contribute to the top-level scope.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>GHCi will tab-complete names that are in scope; for example, if
you run GHCi and type <code class="docutils literal notranslate"><span class="pre">J&lt;tab&gt;</span></code> then GHCi will expand it to
<code class="docutils literal notranslate"><span class="pre">Just</span></code>.</p>
</div>
<section id="the-effect-of-load-on-what-is-in-scope">
<span id="ghci-load-scope"></span><h4><span class="section-number">3.4.5.1. </span>The effect of <code class="docutils literal notranslate"><span class="pre">:load</span></code> on what is in scope<a class="headerlink" href="#the-effect-of-load-on-what-is-in-scope" title="Permalink to this heading">¶</a></h4>
<p>The <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>, <a class="reference internal" href="#ghci-cmd-add"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:add</span></code></a>, and <a class="reference internal" href="#ghci-cmd-reload"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:reload</span></code></a> commands
(<a class="reference internal" href="#loading-source-files"><span class="std std-ref">Loading source files</span></a> and <a class="reference internal" href="#ghci-compiled"><span class="std std-ref">Loading compiled code</span></a>) affect the
top-level scope. Let’s start with the simple cases; when you start GHCi
the prompt looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt;
</pre></div>
</div>
<p>By default, this means that everything from the module <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> is currently
in scope. Should the prompt be set to <code class="docutils literal notranslate"><span class="pre">%s&gt;</span></code> in the <code class="docutils literal notranslate"><span class="pre">.ghci</span></code> configuration
file, we would be seeing <code class="docutils literal notranslate"><span class="pre">Prelude&gt;</span></code> displayed. However, it is not the default
mechanism due to the large space the prompt can take if more imports are done.</p>
<p>The syntax in the prompt <code class="docutils literal notranslate"><span class="pre">*module</span></code> indicates that it is the full
top-level scope of ⟨module⟩ that is contributing to the scope for
expressions typed at the prompt. Without the <code class="docutils literal notranslate"><span class="pre">*</span></code>, just the exports of
the module are visible.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For technical reasons, GHCi can only support the <code class="docutils literal notranslate"><span class="pre">*</span></code>-form for
modules that are interpreted. Compiled modules and package modules can
only contribute their exports to the current scope. To ensure that GHCi
loads the interpreted version of a module, add the <code class="docutils literal notranslate"><span class="pre">*</span></code> when loading
the module, e.g. <code class="docutils literal notranslate"><span class="pre">:load</span> <span class="pre">*M</span></code>.</p>
</div>
<p>In general, after a <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a> command, an automatic import is added to
the scope for the most recently loaded “target” module, in a <code class="docutils literal notranslate"><span class="pre">*</span></code>-form
if possible. For example, if you say <code class="docutils literal notranslate"><span class="pre">:load</span> <span class="pre">foo.hs</span> <span class="pre">bar.hs</span></code> and
<code class="docutils literal notranslate"><span class="pre">bar.hs</span></code> contains module <code class="docutils literal notranslate"><span class="pre">Bar</span></code>, then the scope will be set to
<code class="docutils literal notranslate"><span class="pre">*Bar</span></code> if <code class="docutils literal notranslate"><span class="pre">Bar</span></code> is interpreted, or if <code class="docutils literal notranslate"><span class="pre">Bar</span></code> is compiled it will be
set to <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> and <code class="docutils literal notranslate"><span class="pre">Bar</span></code> (GHCi automatically adds <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> if it isn’t
present and there aren’t any <code class="docutils literal notranslate"><span class="pre">*</span></code>-form modules). These
automatically-added imports can be seen with <a class="reference internal" href="#ghci-cmd-show-imports"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">imports</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :load hello.hs
[1 of 1] Compiling Main             ( hello.hs, interpreted )
Ok, modules loaded: Main.
*ghci&gt; :show imports
:module +*Main -- added automatically
*ghci&gt;
</pre></div>
</div>
<p>and the automatically-added import is replaced the next time you use
<a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>, <a class="reference internal" href="#ghci-cmd-add"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:add</span></code></a>, or <a class="reference internal" href="#ghci-cmd-reload"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:reload</span></code></a>. It can also be
removed by <a class="reference internal" href="#ghci-cmd-module"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:module</span></code></a> as with normal imports.</p>
</section>
<section id="controlling-what-is-in-scope-with-import">
<span id="ghci-import-decl"></span><h4><span class="section-number">3.4.5.2. </span>Controlling what is in scope with <code class="docutils literal notranslate"><span class="pre">import</span></code><a class="headerlink" href="#controlling-what-is-in-scope-with-import" title="Permalink to this heading">¶</a></h4>
<p>We are not limited to a single module: GHCi can combine scopes from
multiple modules, in any mixture of <code class="docutils literal notranslate"><span class="pre">*</span></code> and non-<code class="docutils literal notranslate"><span class="pre">*</span></code> forms. GHCi
combines the scopes from all of these modules to form the scope that is
in effect at the prompt.</p>
<p>To add modules to the scope, use ordinary Haskell <code class="docutils literal notranslate"><span class="pre">import</span></code> syntax:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; import System.IO
ghci&gt; hPutStrLn stdout &quot;hello\n&quot;
hello
</pre></div>
</div>
<p>The full Haskell import syntax is supported, including <code class="docutils literal notranslate"><span class="pre">hiding</span></code> and
<code class="docutils literal notranslate"><span class="pre">as</span></code> clauses. The prompt shows the modules that are currently
imported, but it omits details about <code class="docutils literal notranslate"><span class="pre">hiding</span></code>, <code class="docutils literal notranslate"><span class="pre">as</span></code>, and so on. To
see the full story, use <a class="reference internal" href="#ghci-cmd-show-imports"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">imports</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; import System.IO
ghci&gt; import Data.Map as Map
ghci Map&gt; :show imports
import Prelude -- implicit
import System.IO
import Data.Map as Map
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> import is marked as implicit. It can be
overridden with an explicit <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> import, just like in a Haskell
module.</p>
<p>With multiple modules in scope, especially multiple <code class="docutils literal notranslate"><span class="pre">*</span></code>-form modules,
it is likely that name clashes will occur. Haskell specifies that name
clashes are only reported when an ambiguous identifier is used, and GHCi
behaves in the same way for expressions typed at the prompt.</p>
</section>
<section id="controlling-what-is-in-scope-with-the-module-command">
<span id="ghci-module-cmd"></span><h4><span class="section-number">3.4.5.3. </span>Controlling what is in scope with the <code class="docutils literal notranslate"><span class="pre">:module</span></code> command<a class="headerlink" href="#controlling-what-is-in-scope-with-the-module-command" title="Permalink to this heading">¶</a></h4>
<p>Another way to manipulate the scope is to use the <a class="reference internal" href="#ghci-cmd-module"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:module</span></code></a>
command, whose syntax is this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:module +|- *mod1 ... *modn
</pre></div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">+</span></code> form of the <code class="docutils literal notranslate"><span class="pre">module</span></code> commands adds modules to the
current scope, and <code class="docutils literal notranslate"><span class="pre">-</span></code> removes them. Without either <code class="docutils literal notranslate"><span class="pre">+</span></code> or <code class="docutils literal notranslate"><span class="pre">-</span></code>,
the current scope is replaced by the set of modules specified. Note that
if you use this form and leave out <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>, an implicit <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>
import will be added automatically.</p>
<p>The <a class="reference internal" href="#ghci-cmd-module"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:module</span></code></a> command provides a way to do two things that cannot be
done with ordinary <code class="docutils literal notranslate"><span class="pre">import</span></code> declarations:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#ghci-cmd-module"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:module</span></code></a> supports the <code class="docutils literal notranslate"><span class="pre">*</span></code> modifier on modules, which opens the
full top-level scope of a module, rather than just its exports.</p></li>
<li><p>Imports can be <em>removed</em> from the context, using the syntax
<code class="docutils literal notranslate"><span class="pre">:module</span> <span class="pre">-M</span></code>. The <code class="docutils literal notranslate"><span class="pre">import</span></code> syntax is cumulative (as in a Haskell
module), so this is the only way to subtract from the scope.</p></li>
</ul>
</section>
<section id="qualified-names">
<span id="ghci-import-qualified"></span><h4><span class="section-number">3.4.5.4. </span>Qualified names<a class="headerlink" href="#qualified-names" title="Permalink to this heading">¶</a></h4>
<p>To make life slightly easier, the GHCi prompt also behaves as if there
is an implicit <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">qualified</span></code> declaration for every module in
every package, and every module currently loaded into GHCi. This
behaviour can be disabled with the <code class="docutils literal notranslate"><span class="pre">-fno-implicit-import-qualified</span></code> flag.</p>
</section>
<section id="module-and-load">
<span id="index-8"></span><h4><span class="section-number">3.4.5.5. </span><code class="docutils literal notranslate"><span class="pre">:module</span></code> and <code class="docutils literal notranslate"><span class="pre">:load</span></code><a class="headerlink" href="#module-and-load" title="Permalink to this heading">¶</a></h4>
<p>It might seem that <a class="reference internal" href="#ghci-cmd-module"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:module</span></code></a>/<code class="docutils literal notranslate"><span class="pre">import</span></code> and
<a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>/<a class="reference internal" href="#ghci-cmd-add"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:add</span></code></a>/<a class="reference internal" href="#ghci-cmd-reload"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:reload</span></code></a> do similar things: you
can use both to bring a module into scope. However, there is a very important
difference. GHCi is concerned with two sets of modules:</p>
<ul class="simple">
<li><p>The set of modules that are currently <em>loaded</em>. This set is modified
by <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>, <a class="reference internal" href="#ghci-cmd-add"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:add</span></code></a> and <a class="reference internal" href="#ghci-cmd-reload"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:reload</span></code></a>, and can be shown with
<a class="reference internal" href="#ghci-cmd-show-modules"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">modules</span></code></a>.</p></li>
<li><p>The set of modules that are currently <em>in scope</em> at the prompt. This set is
modified by <code class="docutils literal notranslate"><span class="pre">import</span></code> and <a class="reference internal" href="#ghci-cmd-module"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:module</span></code></a>, and it is also modified
automatically after <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>, <a class="reference internal" href="#ghci-cmd-add"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:add</span></code></a>, and
<a class="reference internal" href="#ghci-cmd-reload"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:reload</span></code></a>, as described above. The set of modules in scope can be
shown with <a class="reference internal" href="#ghci-cmd-show-imports"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">imports</span></code></a>.</p></li>
</ul>
<p>You can add a module to the scope (via <a class="reference internal" href="#ghci-cmd-module"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:module</span></code></a> or <code class="docutils literal notranslate"><span class="pre">import</span></code>) only
if either (a) it is loaded, or (b) it is a module from a package that
GHCi knows about. Using <a class="reference internal" href="#ghci-cmd-module"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:module</span></code></a> or <code class="docutils literal notranslate"><span class="pre">import</span></code> to try bring into
scope a non-loaded module may result in the message
<code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">M</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">loaded</span></code>.</p>
</section>
</section>
<section id="the-main-and-run-commands">
<h3><span class="section-number">3.4.6. </span>The <code class="docutils literal notranslate"><span class="pre">:main</span></code> and <code class="docutils literal notranslate"><span class="pre">:run</span></code> commands<a class="headerlink" href="#the-main-and-run-commands" title="Permalink to this heading">¶</a></h3>
<p>When a program is compiled and executed, it can use the <code class="docutils literal notranslate"><span class="pre">getArgs</span></code>
function to access the command-line arguments. However, we cannot simply
pass the arguments to the <code class="docutils literal notranslate"><span class="pre">main</span></code> function while we are testing in
ghci, as the <code class="docutils literal notranslate"><span class="pre">main</span></code> function doesn’t take its directly.</p>
<p>Instead, we can use the <a class="reference internal" href="#ghci-cmd-main"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:main</span></code></a> command. This runs whatever <code class="docutils literal notranslate"><span class="pre">main</span></code>
is in scope, with any arguments being treated the same as command-line
arguments, e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; main = System.Environment.getArgs &gt;&gt;= print
ghci&gt; :main foo bar
[&quot;foo&quot;,&quot;bar&quot;]
</pre></div>
</div>
<p>We can also quote arguments which contains characters like spaces, and
they are treated like Haskell strings, or we can just use Haskell list
syntax:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :main foo &quot;bar baz&quot;
[&quot;foo&quot;,&quot;bar baz&quot;]
ghci&gt; :main [&quot;foo&quot;, &quot;bar baz&quot;]
[&quot;foo&quot;,&quot;bar baz&quot;]
</pre></div>
</div>
<p>Finally, other functions can be called, either with the <code class="docutils literal notranslate"><span class="pre">-main-is</span></code>
flag or the <a class="reference internal" href="#ghci-cmd-run"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:run</span></code></a> command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; foo = putStrLn &quot;foo&quot; &gt;&gt; System.Environment.getArgs &gt;&gt;= print
ghci&gt; bar = putStrLn &quot;bar&quot; &gt;&gt; System.Environment.getArgs &gt;&gt;= print
ghci&gt; :set -main-is foo
ghci&gt; :main foo &quot;bar baz&quot;
foo
[&quot;foo&quot;,&quot;bar baz&quot;]
ghci&gt; :run bar [&quot;foo&quot;, &quot;bar baz&quot;]
bar
[&quot;foo&quot;,&quot;bar baz&quot;]
</pre></div>
</div>
</section>
<section id="the-it-variable">
<h3><span class="section-number">3.4.7. </span>The <code class="docutils literal notranslate"><span class="pre">it</span></code> variable<a class="headerlink" href="#the-it-variable" title="Permalink to this heading">¶</a></h3>
<p id="index-9">Whenever an expression (or a non-binding statement, to be precise) is
typed at the prompt, GHCi implicitly binds its value to the variable
<code class="docutils literal notranslate"><span class="pre">it</span></code>. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; 1+2
3
ghci&gt; it * 2
6
</pre></div>
</div>
<p>What actually happens is that GHCi typechecks the expression, and if it
doesn’t have an <code class="docutils literal notranslate"><span class="pre">IO</span></code> type, then it transforms it as follows: an
expression <code class="docutils literal notranslate"><span class="pre">e</span></code> turns into</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>let it = e;
print it
</pre></div>
</div>
<p>which is then run as an IO-action.</p>
<p>Hence, the original expression must have a type which is an instance of
the <code class="docutils literal notranslate"><span class="pre">Show</span></code> class, or GHCi will complain:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; id

&lt;interactive&gt;:1:0:
    No instance for (Show (a -&gt; a))
      arising from use of `print&#39; at &lt;interactive&gt;:1:0-1
    Possible fix: add an instance declaration for (Show (a -&gt; a))
    In the expression: print it
    In a &#39;do&#39; expression: print it
</pre></div>
</div>
<p>The error message contains some clues as to the transformation happening
internally.</p>
<p>If the expression was instead of type <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">a</span></code> for some <code class="docutils literal notranslate"><span class="pre">a</span></code>, then
<code class="docutils literal notranslate"><span class="pre">it</span></code> will be bound to the result of the <code class="docutils literal notranslate"><span class="pre">IO</span></code> computation, which is
of type <code class="docutils literal notranslate"><span class="pre">a</span></code>. eg.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; Data.Time.getZonedTime
2017-04-10 12:34:56.93213581 UTC
ghci&gt; print it
2017-04-10 12:34:56.93213581 UTC
</pre></div>
</div>
<p>The corresponding translation for an IO-typed <code class="docutils literal notranslate"><span class="pre">e</span></code> is</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>it &lt;- e
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">it</span></code> is shadowed by the new value each time you evaluate a
new expression, and the old value of <code class="docutils literal notranslate"><span class="pre">it</span></code> is lost.</p>
<p>In order to stop the value <code class="docutils literal notranslate"><span class="pre">it</span></code> being bound on each command, the flag
<a class="reference internal" href="#ghc-flag-fno-it"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fno-it</span></code></a> can be set. The <code class="docutils literal notranslate"><span class="pre">it</span></code> variable can be the source
of space leaks due to how shadowed declarations are handled by
GHCi (see <a class="reference internal" href="#ghci-decls"><span class="std std-ref">Type, class and other declarations</span></a>).</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fno-it">
<span class="sig-name descname"><span class="pre">-fno-it</span></span><a class="headerlink" href="#ghc-flag-fno-it" title="Permalink to this definition">¶</a></dt>
<dd><p>When this flag is set, the variable <code class="docutils literal notranslate"><span class="pre">it</span></code> will no longer be set
to the result of the previously evaluated expression.</p>
</dd></dl>

</section>
<section id="type-defaulting-in-ghci">
<span id="extended-default-rules"></span><h3><span class="section-number">3.4.8. </span>Type defaulting in GHCi<a class="headerlink" href="#type-defaulting-in-ghci" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-10"></span><dl class="std extension">
<dt class="sig sig-object std" id="extension-ExtendedDefaultRules">
<span id="ghc-flag--XExtendedDefaultRules"></span><span id="extension-NoExtendedDefaultRules"></span><span class="sig-name descname"><span class="pre">ExtendedDefaultRules</span></span><a class="headerlink" href="#extension-ExtendedDefaultRules" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.8.1</p>
</dd>
</dl>
<p>Allow defaulting to take place for more than just numeric classes.</p>
</dd></dl>

<p>Consider this GHCi session:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; reverse []
</pre></div>
</div>
<p>What should GHCi do? Strictly speaking, the program is ambiguous.
<code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">(reverse</span> <span class="pre">[])</span></code> (which is what GHCi computes here) has type
<code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">String</span></code> and how that displays depends on the type <code class="docutils literal notranslate"><span class="pre">a</span></code>.
For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; reverse ([] :: String)
&quot;&quot;
ghci&gt; reverse ([] :: [Int])
[]
</pre></div>
</div>
<p>However, it is tiresome for the user to have to specify the type, so
GHCi extends Haskell’s type-defaulting rules (Section 4.3.4 of the
Haskell 2010 Report) as follows. The standard rules take each group of
constraints <code class="docutils literal notranslate"><span class="pre">(C1</span> <span class="pre">a,</span> <span class="pre">C2</span> <span class="pre">a,</span> <span class="pre">...,</span> <span class="pre">Cn</span> <span class="pre">a)</span></code> for each type variable <code class="docutils literal notranslate"><span class="pre">a</span></code>,
and defaults the type variable if</p>
<ol class="arabic simple">
<li><p>The type variable <code class="docutils literal notranslate"><span class="pre">a</span></code> appears in no other constraints</p></li>
<li><p>All the classes <code class="docutils literal notranslate"><span class="pre">Ci</span></code> are standard.</p></li>
<li><p>At least one of the classes <code class="docutils literal notranslate"><span class="pre">Ci</span></code> is numeric.</p></li>
</ol>
<p>At the GHCi prompt, or with GHC if the <a class="reference internal" href="#extension-ExtendedDefaultRules"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExtendedDefaultRules</span></code></a> flag
is given, the types are instead resolved with the following method:</p>
<p>Find all the unsolved constraints. Then:</p>
<ul class="simple">
<li><p>Find those that are of form <code class="docutils literal notranslate"><span class="pre">(C</span> <span class="pre">a)</span></code> where <code class="docutils literal notranslate"><span class="pre">a</span></code> is a type variable, and
partition those constraints into groups that share a common type variable <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></li>
<li><p>Keep only the groups in which at least one of the classes is an
<strong>interactive class</strong> (defined below).</p></li>
<li><p>Now, for each remaining group G, try each type <code class="docutils literal notranslate"><span class="pre">ty</span></code> from the default-type list
in turn; if setting <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">ty</span></code> would allow the constraints in G to be completely
solved. If so, default <code class="docutils literal notranslate"><span class="pre">a</span></code> to <code class="docutils literal notranslate"><span class="pre">ty</span></code>.</p></li>
<li><p>The unit type <code class="docutils literal notranslate"><span class="pre">()</span></code> and the list type <code class="docutils literal notranslate"><span class="pre">[]</span></code> are added to the start of
the standard list of types which are tried when doing type defaulting.</p></li>
</ul>
<p>Note that any multi-parameter constraints <code class="docutils literal notranslate"><span class="pre">(D</span> <span class="pre">a</span> <span class="pre">b)</span></code> or <code class="docutils literal notranslate"><span class="pre">(D</span> <span class="pre">[a]</span> <span class="pre">Int)</span></code> do not
participate in the process (either to help or to hinder); but they must of course
be soluble once the defaulting process is complete.</p>
<p>The last point means that, for example, this program:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">def</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>

<span class="nf">def</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Enum</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">def</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">toEnum</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
</div>
<p>prints <code class="docutils literal notranslate"><span class="pre">()</span></code> rather than <code class="docutils literal notranslate"><span class="pre">0</span></code> as the type is defaulted to <code class="docutils literal notranslate"><span class="pre">()</span></code>
rather than <code class="docutils literal notranslate"><span class="pre">Integer</span></code>.</p>
<p>The motivation for the change is that it means <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">a</span></code> actions default
to <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">()</span></code>, which in turn means that ghci won’t try to print a result
when running them. This is particularly important for <code class="docutils literal notranslate"><span class="pre">printf</span></code>, which
has an instance that returns <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">a</span></code>. However, it is only able to
return <code class="docutils literal notranslate"><span class="pre">undefined</span></code> (the reason for the instance having this type is so
that printf doesn’t require extensions to the class system), so if the
type defaults to <code class="docutils literal notranslate"><span class="pre">Integer</span></code> then ghci gives an error when running a
printf.</p>
<p>See also <a class="reference internal" href="#actions-at-prompt"><span class="std std-ref">I/O actions at the prompt</span></a> for how the monad of a computational
expression defaults to <code class="docutils literal notranslate"><span class="pre">IO</span></code> if possible.</p>
<section id="interactive-classes">
<h4><span class="section-number">3.4.8.1. </span>Interactive classes<a class="headerlink" href="#interactive-classes" title="Permalink to this heading">¶</a></h4>
<p id="index-11">The interactive classes (only relevant when <a class="reference internal" href="#extension-ExtendedDefaultRules"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExtendedDefaultRules</span></code></a>
is in effect) are: any numeric class, <code class="docutils literal notranslate"><span class="pre">Show</span></code>, <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, <code class="docutils literal notranslate"><span class="pre">Ord</span></code>,
<code class="docutils literal notranslate"><span class="pre">Foldable</span></code> or <code class="docutils literal notranslate"><span class="pre">Traversable</span></code>.</p>
<p>As long as a type variable is constrained by one of these classes, defaulting
will occur, as outlined above.</p>
</section>
<section id="extended-rules-around-default-declarations">
<h4><span class="section-number">3.4.8.2. </span>Extended rules around <code class="docutils literal notranslate"><span class="pre">default</span></code> declarations<a class="headerlink" href="#extended-rules-around-default-declarations" title="Permalink to this heading">¶</a></h4>
<p id="index-12">Since the rules for defaulting are relaxed under
<a class="reference internal" href="#extension-ExtendedDefaultRules"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExtendedDefaultRules</span></code></a>, the rules for <code class="docutils literal notranslate"><span class="pre">default</span></code> declarations
are also relaxed. According to Section 4.3.4 of the Haskell 2010 Report,
a <code class="docutils literal notranslate"><span class="pre">default</span></code> declaration looks like <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">(t1,</span> <span class="pre">...,</span> <span class="pre">tn)</span></code> where, for
each <code class="docutils literal notranslate"><span class="pre">ti</span></code>, <code class="docutils literal notranslate"><span class="pre">Num</span> <span class="pre">ti</span></code> must hold. This is relaxed to say that for each
<code class="docutils literal notranslate"><span class="pre">ti</span></code>, there must exist an interactive class <code class="docutils literal notranslate"><span class="pre">C</span></code> such that <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">ti</span></code> holds.
This means that type <em>constructors</em> can be allowed in these lists.
For example, the following works if you wish your <code class="docutils literal notranslate"><span class="pre">Foldable</span></code> constraints
to default to <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> but your <code class="docutils literal notranslate"><span class="pre">Num</span></code> constraints to still default
to <code class="docutils literal notranslate"><span class="pre">Integer</span></code> or <code class="docutils literal notranslate"><span class="pre">Double</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">default</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="p">,</span><span class="w"> </span><span class="kt">Integer</span><span class="p">,</span><span class="w"> </span><span class="kt">Double</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="using-a-custom-interactive-printing-function">
<span id="ghci-interactive-print"></span><h3><span class="section-number">3.4.9. </span>Using a custom interactive printing function<a class="headerlink" href="#using-a-custom-interactive-printing-function" title="Permalink to this heading">¶</a></h3>
<p id="index-13">Since GHC 7.6.1, GHCi prints the result of expressions typed at the prompt
using the function <code class="docutils literal notranslate"><span class="pre">System.IO.print</span></code>. Its type signature is <code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span>
<span class="pre">IO</span> <span class="pre">()</span></code>, and it works by converting the value to <code class="docutils literal notranslate"><span class="pre">String</span></code> using <code class="docutils literal notranslate"><span class="pre">show</span></code>.</p>
<p>This is not ideal in certain cases, like when the output is long, or
contains strings with non-ascii characters.</p>
<p>The <a class="reference internal" href="#ghc-flag-interactive-print-name"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-interactive-print</span> <span class="pre">⟨name⟩</span></code></a> flag allows to specify any function
of type <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></code>, for some constraint <code class="docutils literal notranslate"><span class="pre">C</span></code>, as the function for
printing evaluated expressions. The function can reside in any loaded module or
any registered package, but only when it resides in a registered package will
it survive a <a class="reference internal" href="#ghci-cmd-cd"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:cd</span></code></a>, <a class="reference internal" href="#ghci-cmd-add"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:add</span></code></a>, <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>,
<a class="reference internal" href="#ghci-cmd-reload"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:reload</span></code></a> or, <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a>.</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-interactive-print-name">
<span class="sig-name descname"><span class="pre">-interactive-print</span></span><span class="sig-prename descclassname"> <span class="pre">⟨name⟩</span></span><a class="headerlink" href="#ghc-flag-interactive-print-name" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the function used by GHCi to print evaluation results. Given name
must be of type <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></code>.</p>
</dd></dl>

<p>As an example, suppose we have following special printing module:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">SpecPrinter</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">System.IO</span><span class="w"></span>

<span class="nf">sprint</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;!&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">sprint</span></code> function adds an exclamation mark at the end of any
printed value. Running GHCi with the command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci -interactive-print=SpecPrinter.sprint SpecPrinter
</pre></div>
</div>
<p>will start an interactive session where values with be printed using
<code class="docutils literal notranslate"><span class="pre">sprint</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*SpecPrinter&gt; [1,2,3]
[1,2,3]!
*SpecPrinter&gt; 42
42!
</pre></div>
</div>
<p>A custom pretty printing function can be used, for example, to format
tree-like and nested structures in a more readable way.</p>
<p>The <a class="reference internal" href="#ghc-flag-interactive-print-name"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-interactive-print</span> <span class="pre">⟨name⟩</span></code></a> flag can also be used when running
GHC in <code class="docutils literal notranslate"><span class="pre">-e</span> <span class="pre">mode</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% ghc -e &quot;[1,2,3]&quot; -interactive-print=SpecPrinter.sprint SpecPrinter
[1,2,3]!
</pre></div>
</div>
</section>
<section id="stack-traces-in-ghci">
<span id="ghci-stack-traces"></span><h3><span class="section-number">3.4.10. </span>Stack Traces in GHCi<a class="headerlink" href="#stack-traces-in-ghci" title="Permalink to this heading">¶</a></h3>
<p id="index-14">[ This is an experimental feature enabled by the new
<code class="docutils literal notranslate"><span class="pre">-fexternal-interpreter</span></code> flag that was introduced in GHC 8.0.1.  It
is currently not supported on Windows.]</p>
<p>GHCi can use the profiling system to collect stack trace information
when running interpreted code.  To gain access to stack traces, start
GHCi like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci -fexternal-interpreter -prof
</pre></div>
</div>
<p>This runs the interpreted code in a separate process (see
<a class="reference internal" href="#external-interpreter"><span class="std std-ref">Running the interpreter in a separate process</span></a>) and runs it in profiling mode to collect
call stack information.  Note that because we’re running the
interpreted code in profiling mode, all packages that you use must be
compiled for profiling.  The <code class="docutils literal notranslate"><span class="pre">-prof</span></code> flag to GHCi only works in
conjunction with <code class="docutils literal notranslate"><span class="pre">-fexternal-interpreter</span></code>.</p>
<p>There are three ways to get access to the current call stack.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">error</span></code> and <code class="docutils literal notranslate"><span class="pre">undefined</span></code> automatically attach the current stack
to the error message.  This often complements the <code class="docutils literal notranslate"><span class="pre">HasCallStack</span></code>
stack (see <a class="reference internal" href="exts/callstack.html#hascallstack"><span class="std std-ref">HasCallStack</span></a>), so both call stacks are
shown.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Debug.Trace.traceStack</span></code> is a version of <code class="docutils literal notranslate"><span class="pre">Debug.Trace.trace</span></code>
that also prints the current call stack.</p></li>
<li><p>Functions in the module <code class="docutils literal notranslate"><span class="pre">GHC.Stack</span></code> can be used to get the current
stack and render it.</p></li>
</ul>
<p>You don’t need to use <code class="docutils literal notranslate"><span class="pre">-fprof-auto</span></code> for interpreted modules,
annotations are automatically added at a granularity fine enough to
distinguish individual call sites.  However, you won’t see any call
stack information for compiled code unless it was compiled with
<code class="docutils literal notranslate"><span class="pre">-fprof-auto</span></code> or has explicit <code class="docutils literal notranslate"><span class="pre">SCC</span></code> annotations (see
<a class="reference internal" href="profiling.html#scc-pragma"><span class="std std-ref">Inserting cost centres by hand</span></a>).</p>
</section>
</section>
<section id="the-ghci-debugger">
<span id="ghci-debugger"></span><h2><span class="section-number">3.5. </span>The GHCi Debugger<a class="headerlink" href="#the-ghci-debugger" title="Permalink to this heading">¶</a></h2>
<p id="index-15">GHCi contains a simple imperative-style debugger in which you can stop a
running computation in order to examine the values of variables. The
debugger is integrated into GHCi, and is turned on by default: no flags
are required to enable the debugging facilities. There is one major
restriction: breakpoints and single-stepping are only available in
interpreted modules; compiled code is invisible to the debugger <a class="footnote-reference brackets" href="#id14" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.</p>
<p>The debugger provides the following:</p>
<ul class="simple">
<li><p>The ability to set a breakpoint on a function definition or
expression in the program. When the function is called, or the
expression evaluated, GHCi suspends execution and returns to the
prompt, where you can inspect the values of local variables before
continuing with the execution.</p></li>
<li><p>Execution can be single-stepped: the evaluator will suspend execution
approximately after every reduction, allowing local variables to be
inspected. This is equivalent to setting a breakpoint at every point
in the program.</p></li>
<li><p>Execution can take place in tracing mode, in which the evaluator
remembers each evaluation step as it happens, but doesn’t suspend
execution until an actual breakpoint is reached. When this happens,
the history of evaluation steps can be inspected.</p></li>
<li><p>Exceptions (e.g. pattern matching failure and <code class="docutils literal notranslate"><span class="pre">error</span></code>) can be
treated as breakpoints, to help locate the source of an exception in
the program.</p></li>
</ul>
<p>There is currently no support for obtaining a “stack trace”, but the
tracing and history features provide a useful second-best, which will
often be enough to establish the context of an error. For instance, it
is possible to break automatically when an exception is thrown, even if
it is thrown from within compiled code (see
<a class="reference internal" href="#ghci-debugger-exceptions"><span class="std std-ref">Debugging exceptions</span></a>).</p>
<section id="breakpoints-and-inspecting-variables">
<span id="breakpoints"></span><h3><span class="section-number">3.5.1. </span>Breakpoints and inspecting variables<a class="headerlink" href="#breakpoints-and-inspecting-variables" title="Permalink to this heading">¶</a></h3>
<p>Let’s use quicksort as a running example. Here’s the code:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">qsort</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">qsort</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="kt">:</span><span class="n">as</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">qsort</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">qsort</span><span class="w"> </span><span class="n">right</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;=</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">as</span><span class="p">,</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">as</span><span class="p">)</span><span class="w"></span>

<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="p">(</span><span class="n">qsort</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">])</span><span class="w"></span>
</pre></div>
</div>
<p>First, load the module into GHCi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :l qsort.hs
[1 of 1] Compiling Main             ( qsort.hs, interpreted )
Ok, modules loaded: Main.
*ghci&gt;
</pre></div>
</div>
<p>Now, let’s set a breakpoint on the right-hand-side of the second
equation of qsort:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :break 2
Breakpoint 0 activated at qsort.hs:2:15-46
*ghci&gt;
</pre></div>
</div>
<p>The command <code class="docutils literal notranslate"><span class="pre">:break</span> <span class="pre">2</span></code> sets a breakpoint on line 2 of the most
recently-loaded module, in this case <code class="docutils literal notranslate"><span class="pre">qsort.hs</span></code>. Specifically, it
picks the leftmost complete subexpression on that line on which to set
the breakpoint, which in this case is the expression
<code class="docutils literal notranslate"><span class="pre">(qsort</span> <span class="pre">left</span> <span class="pre">++</span> <span class="pre">[a]</span> <span class="pre">++</span> <span class="pre">qsort</span> <span class="pre">right)</span></code>.</p>
<p>Now, we run the program:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; main
Stopped at qsort.hs:2:15-46
_result :: [a]
a :: a
left :: [a]
right :: [a]
[qsort.hs:2:15-46] *ghci&gt;
</pre></div>
</div>
<p>Execution has stopped at the breakpoint. The prompt has changed to
indicate that we are currently stopped at a breakpoint, and the
location: <code class="docutils literal notranslate"><span class="pre">[qsort.hs:2:15-46]</span></code>. To further clarify the location, we
can use the <a class="reference internal" href="#ghci-cmd-list"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:list</span></code></a> command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[qsort.hs:2:15-46] *ghci&gt; :list
1  qsort [] = []
2  qsort (a:as) = qsort left ++ [a] ++ qsort right
3    where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)
</pre></div>
</div>
<p>The <a class="reference internal" href="#ghci-cmd-list"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:list</span></code></a> command lists the source code around the current
breakpoint. If your output device supports it, then GHCi will highlight
the active subexpression in bold.</p>
<p>GHCi has provided bindings for the free variables <a class="footnote-reference brackets" href="#id15" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> of the expression
on which the breakpoint was placed (<code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">left</span></code>, <code class="docutils literal notranslate"><span class="pre">right</span></code>), and
additionally a binding for the result of the expression (<code class="docutils literal notranslate"><span class="pre">_result</span></code>).
These variables are just like other variables that you might define in
GHCi; you can use them in expressions that you type at the prompt, you
can ask for their types with <a class="reference internal" href="#ghci-cmd-type"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:type</span></code></a>, and so on. There is one
important difference though: these variables may only have partial
types. For example, if we try to display the value of <code class="docutils literal notranslate"><span class="pre">left</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[qsort.hs:2:15-46] *ghci&gt; left

&lt;interactive&gt;:1:0:
    Ambiguous type variable `a&#39; in the constraint:
      `Show a&#39; arising from a use of `print&#39; at &lt;interactive&gt;:1:0-3
    Cannot resolve unknown runtime types: a
    Use :print or :force to determine these types
</pre></div>
</div>
<p>This is because <code class="docutils literal notranslate"><span class="pre">qsort</span></code> is a polymorphic function, and because GHCi
does not carry type information at runtime, it cannot determine the
runtime types of free variables that involve type variables. Hence, when
you ask to display <code class="docutils literal notranslate"><span class="pre">left</span></code> at the prompt, GHCi can’t figure out which
instance of <code class="docutils literal notranslate"><span class="pre">Show</span></code> to use, so it emits the type error above.</p>
<p>Fortunately, the debugger includes a generic printing command,
<a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a>, which can inspect the actual runtime value of a variable and
attempt to reconstruct its type. If we try it on <code class="docutils literal notranslate"><span class="pre">left</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[qsort.hs:2:15-46] *ghci&gt; :set -fprint-evld-with-show
[qsort.hs:2:15-46] *ghci&gt; :print left
left = (_t1::[a])
</pre></div>
</div>
<p>This isn’t particularly enlightening. What happened is that <code class="docutils literal notranslate"><span class="pre">left</span></code> is
bound to an unevaluated computation (a suspension, or thunk), and
<a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a> does not force any evaluation. The idea is that
<a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a> can be used to inspect values at a breakpoint without any
unfortunate side effects. It won’t force any evaluation, which could cause the
program to give a different answer than it would normally, and hence it won’t
cause any exceptions to be raised, infinite loops, or further breakpoints to be
triggered (see <a class="reference internal" href="#nested-breakpoints"><span class="std std-ref">Nested breakpoints</span></a>). Rather than forcing thunks,
<a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a> binds each thunk to a fresh variable beginning with an
underscore, in this case <code class="docutils literal notranslate"><span class="pre">_t1</span></code>.</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fprint-evld-with-show">
<span class="sig-name descname"><span class="pre">-fprint-evld-with-show</span></span><a class="headerlink" href="#ghc-flag-fprint-evld-with-show" title="Permalink to this definition">¶</a></dt>
<dd><p>The flag <a class="reference internal" href="#ghc-flag-fprint-evld-with-show"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fprint-evld-with-show</span></code></a> instructs <a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a> to reuse
available <code class="docutils literal notranslate"><span class="pre">Show</span></code> instances when possible. This happens only when the
contents of the variable being inspected are completely evaluated.</p>
</dd></dl>

<p>If we aren’t concerned about preserving the evaluatedness of a variable, we can
use <a class="reference internal" href="#ghci-cmd-force"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:force</span></code></a> instead of <a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a>. The <a class="reference internal" href="#ghci-cmd-force"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:force</span></code></a>
command behaves exactly like <a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a>, except that it forces the
evaluation of any thunks it encounters:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[qsort.hs:2:15-46] *ghci&gt; :force left
left = [4,0,3,1]
</pre></div>
</div>
<p>Now, since <a class="reference internal" href="#ghci-cmd-force"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:force</span></code></a> has inspected the runtime value of <code class="docutils literal notranslate"><span class="pre">left</span></code>, it
has reconstructed its type. We can see the results of this type
reconstruction:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[qsort.hs:2:15-46] *ghci&gt; :show bindings
_result :: [Integer]
a :: Integer
left :: [Integer]
right :: [Integer]
_t1 :: [Integer]
</pre></div>
</div>
<p>Not only do we now know the type of <code class="docutils literal notranslate"><span class="pre">left</span></code>, but all the other partial
types have also been resolved. So we can ask for the value of <code class="docutils literal notranslate"><span class="pre">a</span></code>, for
example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[qsort.hs:2:15-46] *ghci&gt; a
8
</pre></div>
</div>
<p>You might find it useful to use Haskell’s <code class="docutils literal notranslate"><span class="pre">seq</span></code> function to evaluate
individual thunks rather than evaluating the whole expression with
<a class="reference internal" href="#ghci-cmd-force"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:force</span></code></a>. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[qsort.hs:2:15-46] *ghci&gt; :print right
right = (_t1::[Integer])
[qsort.hs:2:15-46] *ghci&gt; seq _t1 ()
()
[qsort.hs:2:15-46] *ghci&gt; :print right
right = 23 : (_t2::[Integer])
</pre></div>
</div>
<p>We evaluated only the <code class="docutils literal notranslate"><span class="pre">_t1</span></code> thunk, revealing the head of the list, and
the tail is another thunk now bound to <code class="docutils literal notranslate"><span class="pre">_t2</span></code>. The <code class="docutils literal notranslate"><span class="pre">seq</span></code> function is
a little inconvenient to use here, so you might want to use <a class="reference internal" href="#ghci-cmd-def"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:def</span></code></a> to
make a nicer interface (left as an exercise for the reader!).</p>
<p>Finally, we can continue the current execution:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[qsort.hs:2:15-46] *ghci&gt; :continue
Stopped at qsort.hs:2:15-46
_result :: [a]
a :: a
left :: [a]
right :: [a]
[qsort.hs:2:15-46] *ghci&gt;
</pre></div>
</div>
<p>The execution continued at the point it previously stopped, and has now
stopped at the breakpoint for a second time.</p>
<section id="setting-breakpoints">
<span id="id10"></span><h4><span class="section-number">3.5.1.1. </span>Setting breakpoints<a class="headerlink" href="#setting-breakpoints" title="Permalink to this heading">¶</a></h4>
<p>Breakpoints can be set in various ways. Perhaps the easiest way to set a
breakpoint is to name a top-level function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:break identifier
</pre></div>
</div>
<p>Where ⟨identifier⟩ names any top-level function in an interpreted module
currently loaded into GHCi (qualified names may be used). The breakpoint
will be set on the body of the function, when it is fully applied.
If the function has several patterns, then a breakpoint will be set on
each of them.</p>
<p>By using qualified names, one can set breakpoints on all functions
(top-level and nested) in every loaded and interpreted module:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:break [ModQual.]topLevelIdent[.nestedIdent]...[.nestedIdent]
</pre></div>
</div>
<p>⟨ModQual⟩ is optional and is either the effective name of a module or
the local alias of a qualified import statement.</p>
<p>⟨topLevelIdent⟩ is the name of a top level function in the module
referenced by ⟨ModQual⟩.</p>
<p>⟨nestedIdent⟩ is optional and the name of a function nested in a let or
where clause inside the previously mentioned function ⟨nestedIdent⟩ or
⟨topLevelIdent⟩.</p>
<p>If ⟨ModQual⟩ is a module name, then ⟨topLevelIdent⟩ can be any top level
identifier in this module. If ⟨ModQual⟩ is missing or a local alias of a
qualified import, then ⟨topLevelIdent⟩ must be in scope.</p>
<p>Breakpoints can be set on arbitrarily deeply nested functions, but the
whole chain of nested function names must be specified.</p>
<p>Consider the function <code class="docutils literal notranslate"><span class="pre">foo</span></code> in a module <code class="docutils literal notranslate"><span class="pre">Main</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo s = &#39;a&#39; : add s
    where add = (++&quot;z&quot;)
</pre></div>
</div>
<p>The breakpoint on the function <code class="docutils literal notranslate"><span class="pre">add</span></code> can be set with one of the
following commands:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:break Main.foo.add
:break foo.add
</pre></div>
</div>
<p>Breakpoints can also be set by line (and optionally column) number:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:break line
:break line column
:break module line
:break module line column
</pre></div>
</div>
<p>When a breakpoint is set on a particular line, GHCi sets the breakpoint
on the leftmost subexpression that begins and ends on that line. If two
complete subexpressions start at the same column, the longest one is
picked. If there is no complete subexpression on the line, then the
leftmost expression starting on the line is picked, and failing that the
rightmost expression that partially or completely covers the line.</p>
<p>When a breakpoint is set on a particular line and column, GHCi picks the
smallest subexpression that encloses that location on which to set the
breakpoint. Note: GHC considers the TAB character to have a width of 1,
wherever it occurs; in other words it counts characters, rather than
columns. This matches what some editors do, and doesn’t match others.
The best advice is to avoid tab characters in your source code
altogether (see <a class="reference internal" href="using-warnings.html#ghc-flag-Wtabs"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wtabs</span></code></a> in <a class="reference internal" href="using-warnings.html#options-sanity"><span class="std std-ref">Warnings and sanity-checking</span></a>).</p>
<p>If the module is omitted, then the most recently-loaded module is used.</p>
<p>Not all subexpressions are potential breakpoint locations. Single
variables are typically not considered to be breakpoint locations
(unless the variable is the right-hand-side of a function definition,
lambda, or case alternative). The rule of thumb is that all redexes are
breakpoint locations, together with the bodies of functions, lambdas,
case alternatives and binding statements. There is normally no
breakpoint on a let expression, but there will always be a breakpoint on
its body, because we are usually interested in inspecting the values of
the variables bound by the let.</p>
</section>
<section id="managing-breakpoints">
<h4><span class="section-number">3.5.1.2. </span>Managing breakpoints<a class="headerlink" href="#managing-breakpoints" title="Permalink to this heading">¶</a></h4>
<p>The list of breakpoints currently defined can be displayed using
<a class="reference internal" href="#ghci-cmd-show-breaks"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">breaks</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :show breaks
[0] Main qsort.hs:1:11-12 enabled
[1] Main qsort.hs:2:15-46 enabled
</pre></div>
</div>
<p>To disable one or several defined breakpoint, use the <a class="reference internal" href="#ghci-cmd-disable"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:disable</span></code></a> command with
one or several blank separated numbers
given in the output from <a class="reference internal" href="#ghci-cmd-show-breaks"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">breaks</span></code></a>:.
To disable all breakpoints at once, use <code class="docutils literal notranslate"><span class="pre">:disable</span> <span class="pre">*</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :disable 0
*ghci&gt; :show breaks
[0] Main qsort.hs:1:11-12 disabled
[1] Main qsort.hs:2:15-46 enabled
</pre></div>
</div>
<p>Disabled breakpoints can be (re-)enabled with the <a class="reference internal" href="#ghci-cmd-enable"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:enable</span></code></a> command.
The parameters of the <a class="reference internal" href="#ghci-cmd-disable"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:disable</span></code></a> and <a class="reference internal" href="#ghci-cmd-enable"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:enable</span></code></a> commands are identical.</p>
<p>To delete a breakpoint, use the <a class="reference internal" href="#ghci-cmd-delete"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:delete</span></code></a> command with the number
given in the output from <a class="reference internal" href="#ghci-cmd-show-breaks"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">breaks</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :delete 0
*ghci&gt; :show breaks
[1] Main qsort.hs:2:15-46 disabled
</pre></div>
</div>
<p>To delete all breakpoints at once, use <code class="docutils literal notranslate"><span class="pre">:delete</span> <span class="pre">*</span></code>.</p>
</section>
</section>
<section id="single-stepping">
<span id="id11"></span><h3><span class="section-number">3.5.2. </span>Single-stepping<a class="headerlink" href="#single-stepping" title="Permalink to this heading">¶</a></h3>
<p>Single-stepping is a great way to visualise the execution of your
program, and it is also a useful tool for identifying the source of a
bug. GHCi offers two variants of stepping. Use <a class="reference internal" href="#ghci-cmd-step"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:step</span></code></a> to enable all
the breakpoints in the program, and execute until the next breakpoint is
reached. Use <a class="reference internal" href="#ghci-cmd-steplocal"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:steplocal</span></code></a> to limit the set of enabled breakpoints to
those in the current top level function. Similarly, use <a class="reference internal" href="#ghci-cmd-stepmodule"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:stepmodule</span></code></a>
to single step only on breakpoints contained in the current module. For
example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :step main
Stopped at qsort.hs:5:7-47
_result :: IO ()
</pre></div>
</div>
<p>The command <a class="reference internal" href="#ghci-cmd-step"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:step</span> <span class="pre">expr</span></code></a> begins the evaluation of ⟨expr⟩ in
single-stepping mode. If ⟨expr⟩ is omitted, then it single-steps from
the current breakpoint. <a class="reference internal" href="#ghci-cmd-steplocal"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:steplocal</span></code></a> and <a class="reference internal" href="#ghci-cmd-stepmodule"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:stepmodule</span></code></a>
commands work similarly.</p>
<p>The <a class="reference internal" href="#ghci-cmd-list"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:list</span></code></a> command is particularly useful when single-stepping, to
see where you currently are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[qsort.hs:5:7-47] *ghci&gt; :list
4
5  main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
6
[qsort.hs:5:7-47] *ghci&gt;
</pre></div>
</div>
<p>In fact, GHCi provides a way to run a command when a breakpoint is hit,
so we can make it automatically do <a class="reference internal" href="#ghci-cmd-list"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:list</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[qsort.hs:5:7-47] *ghci&gt; :set stop :list
[qsort.hs:5:7-47] *ghci&gt; :step
Stopped at qsort.hs:5:14-46
_result :: [Integer]
4
5  main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
6
[qsort.hs:5:14-46] *ghci&gt;
</pre></div>
</div>
</section>
<section id="nested-breakpoints">
<span id="id12"></span><h3><span class="section-number">3.5.3. </span>Nested breakpoints<a class="headerlink" href="#nested-breakpoints" title="Permalink to this heading">¶</a></h3>
<p>When GHCi is stopped at a breakpoint, and an expression entered at the
prompt triggers a second breakpoint, the new breakpoint becomes the
“current” one, and the old one is saved on a stack. An arbitrary number
of breakpoint contexts can be built up in this way. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[qsort.hs:2:15-46] *ghci&gt; :st qsort [1,3]
Stopped at qsort.hs:(1,0)-(3,55)
_result :: [a]
... [qsort.hs:(1,0)-(3,55)] *ghci&gt;
</pre></div>
</div>
<p>While stopped at the breakpoint on line 2 that we set earlier, we
started a new evaluation with <code class="docutils literal notranslate"><span class="pre">:step</span> <span class="pre">qsort</span> <span class="pre">[1,3]</span></code>. This new evaluation
stopped after one step (at the definition of <code class="docutils literal notranslate"><span class="pre">qsort</span></code>). The prompt has
changed, now prefixed with <code class="docutils literal notranslate"><span class="pre">...</span></code>, to indicate that there are saved
breakpoints beyond the current one. To see the stack of contexts, use
<a class="reference internal" href="#ghci-cmd-show-context"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">context</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>... [qsort.hs:(1,0)-(3,55)] *ghci&gt; :show context
--&gt; main
  Stopped at qsort.hs:2:15-46
--&gt; qsort [1,3]
  Stopped at qsort.hs:(1,0)-(3,55)
... [qsort.hs:(1,0)-(3,55)] *ghci&gt;
</pre></div>
</div>
<p>To abandon the current evaluation, use <a class="reference internal" href="#ghci-cmd-abandon"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:abandon</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>... [qsort.hs:(1,0)-(3,55)] *ghci&gt; :abandon
[qsort.hs:2:15-46] *ghci&gt; :abandon
*ghci&gt;
</pre></div>
</div>
</section>
<section id="the-result-variable">
<span id="ghci-debugger-result"></span><h3><span class="section-number">3.5.4. </span>The <code class="docutils literal notranslate"><span class="pre">_result</span></code> variable<a class="headerlink" href="#the-result-variable" title="Permalink to this heading">¶</a></h3>
<p>When stopped at a breakpoint or single-step, GHCi binds the variable
<code class="docutils literal notranslate"><span class="pre">_result</span></code> to the value of the currently active expression. The value
of <code class="docutils literal notranslate"><span class="pre">_result</span></code> is presumably not available yet, because we stopped its
evaluation, but it can be forced: if the type is known and showable,
then just entering <code class="docutils literal notranslate"><span class="pre">_result</span></code> at the prompt will show it. However,
there’s one caveat to doing this: evaluating <code class="docutils literal notranslate"><span class="pre">_result</span></code> will be likely
to trigger further breakpoints, starting with the breakpoint we are
currently stopped at (if we stopped at a real breakpoint, rather than
due to <a class="reference internal" href="#ghci-cmd-step"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:step</span></code></a>). So it will probably be necessary to issue a
<a class="reference internal" href="#ghci-cmd-continue"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:continue</span></code></a> immediately when evaluating <code class="docutils literal notranslate"><span class="pre">_result</span></code>. Alternatively,
you can use <a class="reference internal" href="#ghci-cmd-force"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:force</span></code></a> which ignores breakpoints.</p>
</section>
<section id="tracing-and-history">
<span id="tracing"></span><h3><span class="section-number">3.5.5. </span>Tracing and history<a class="headerlink" href="#tracing-and-history" title="Permalink to this heading">¶</a></h3>
<p>A question that we often want to ask when debugging a program is “how
did I get here?”. Traditional imperative debuggers usually provide some
kind of stack-tracing feature that lets you see the stack of active
function calls (sometimes called the “lexical call stack”), describing a
path through the code to the current location. Unfortunately this is
hard to provide in Haskell, because execution proceeds on a
demand-driven basis, rather than a depth-first basis as in strict
languages. The “stack“ in GHC’s execution engine bears little
resemblance to the lexical call stack. Ideally GHCi would maintain a
separate lexical call stack in addition to the dynamic call stack, and
in fact this is exactly what our profiling system does
(<a class="reference internal" href="profiling.html#profiling"><span class="std std-ref">Profiling</span></a>), and what some other Haskell debuggers do. For the
time being, however, GHCi doesn’t maintain a lexical call stack (there
are some technical challenges to be overcome). Instead, we provide a way
to backtrack from a breakpoint to previous evaluation steps: essentially
this is like single-stepping backwards, and should in many cases provide
enough information to answer the “how did I get here?” question.</p>
<p>To use tracing, evaluate an expression with the <a class="reference internal" href="#ghci-cmd-trace"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:trace</span></code></a> command. For
example, if we set a breakpoint on the base case of <code class="docutils literal notranslate"><span class="pre">qsort</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :list qsort
1  qsort [] = []
2  qsort (a:as) = qsort left ++ [a] ++ qsort right
3    where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)
4
*ghci&gt; :b 1
Breakpoint 1 activated at qsort.hs:1:11-12
*ghci&gt;
</pre></div>
</div>
<p>and then run a small <code class="docutils literal notranslate"><span class="pre">qsort</span></code> with tracing:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :trace qsort [3,2,1]
Stopped at qsort.hs:1:11-12
_result :: [a]
[qsort.hs:1:11-12] *ghci&gt;
</pre></div>
</div>
<p>We can now inspect the history of evaluation steps:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[qsort.hs:1:11-12] *ghci&gt; :hist
-1  : qsort.hs:3:24-38
-2  : qsort.hs:3:23-55
-3  : qsort.hs:(1,0)-(3,55)
-4  : qsort.hs:2:15-24
-5  : qsort.hs:2:15-46
-6  : qsort.hs:3:24-38
-7  : qsort.hs:3:23-55
-8  : qsort.hs:(1,0)-(3,55)
-9  : qsort.hs:2:15-24
-10 : qsort.hs:2:15-46
-11 : qsort.hs:3:24-38
-12 : qsort.hs:3:23-55
-13 : qsort.hs:(1,0)-(3,55)
-14 : qsort.hs:2:15-24
-15 : qsort.hs:2:15-46
-16 : qsort.hs:(1,0)-(3,55)
&lt;end of history&gt;
</pre></div>
</div>
<p>To examine one of the steps in the history, use <a class="reference internal" href="#ghci-cmd-back"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:back</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[qsort.hs:1:11-12] *ghci&gt; :back
Logged breakpoint at qsort.hs:3:24-38
_result :: [a]
as :: [a]
a :: a
[-1: qsort.hs:3:24-38] *ghci&gt;
</pre></div>
</div>
<p>Note that the local variables at each step in the history have been
preserved, and can be examined as usual. Also note that the prompt has
changed to indicate that we’re currently examining the first step in the
history: <code class="docutils literal notranslate"><span class="pre">-1</span></code>. The command <a class="reference internal" href="#ghci-cmd-forward"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:forward</span></code></a> can be used to traverse
forward in the history.</p>
<p>The <a class="reference internal" href="#ghci-cmd-trace"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:trace</span></code></a> command can be used with or without an expression. When
used without an expression, tracing begins from the current breakpoint,
just like <a class="reference internal" href="#ghci-cmd-step"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:step</span></code></a>.</p>
<p>The history is only available when using <a class="reference internal" href="#ghci-cmd-trace"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:trace</span></code></a>; the reason for this
is we found that logging each breakpoint in the history cuts performance
by a factor of 2 or more.</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fghci-hist-size-n">
<span class="sig-name descname"><span class="pre">-fghci-hist-size</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fghci-hist-size-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>50</p>
</dd>
</dl>
<p>Modify the depth of the evaluation history tracked by GHCi.</p>
</dd></dl>

</section>
<section id="debugging-exceptions">
<span id="ghci-debugger-exceptions"></span><h3><span class="section-number">3.5.6. </span>Debugging exceptions<a class="headerlink" href="#debugging-exceptions" title="Permalink to this heading">¶</a></h3>
<p>Another common question that comes up when debugging is “where did this
exception come from?”. Exceptions such as those raised by <code class="docutils literal notranslate"><span class="pre">error</span></code> or
<code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">[]</span></code> have no context information attached to them. Finding which
particular call to <code class="docutils literal notranslate"><span class="pre">head</span></code> in your program resulted in the error can be
a painstaking process, usually involving <code class="docutils literal notranslate"><span class="pre">Debug.Trace.trace</span></code>, or
compiling with profiling and using <code class="docutils literal notranslate"><span class="pre">Debug.Trace.traceStack</span></code> or
<code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-xc</span></code> (see <a class="reference internal" href="runtime_control.html#rts-flag-xc"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-xc</span></code></a>).</p>
<p>The GHCi debugger offers a way to hopefully shed some light on these
errors quickly and without modifying or recompiling the source code. One
way would be to set a breakpoint on the location in the source code that
throws the exception, and then use <a class="reference internal" href="#ghci-cmd-trace"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:trace</span></code></a> and <a class="reference internal" href="#ghci-cmd-history"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:history</span></code></a> to
establish the context. However, <code class="docutils literal notranslate"><span class="pre">head</span></code> is in a library and we can’t
set a breakpoint on it directly. For this reason, GHCi provides the
flags <a class="reference internal" href="#ghc-flag-fbreak-on-exception"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fbreak-on-exception</span></code></a> which causes the evaluator to stop when
an exception is thrown, and <a class="reference internal" href="#ghc-flag-fbreak-on-error"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fbreak-on-error</span></code></a>, which works similarly
but stops only on uncaught exceptions. When stopping at an exception,
GHCi will act just as it does when a breakpoint is hit, with the
deviation that it will not show you any source code location. Due to
this, these commands are only really useful in conjunction with
<a class="reference internal" href="#ghci-cmd-trace"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:trace</span></code></a>, in order to log the steps leading up to the exception. For
example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :set -fbreak-on-exception
*ghci&gt; :trace qsort (&quot;abc&quot; ++ undefined)
“Stopped at &lt;exception thrown&gt;
_exception :: e
[&lt;exception thrown&gt;] *ghci&gt; :hist
-1  : qsort.hs:3:24-38
-2  : qsort.hs:3:23-55
-3  : qsort.hs:(1,0)-(3,55)
-4  : qsort.hs:2:15-24
-5  : qsort.hs:2:15-46
-6  : qsort.hs:(1,0)-(3,55)
&lt;end of history&gt;
[&lt;exception thrown&gt;] *ghci&gt; :back
Logged breakpoint at qsort.hs:3:24-38
_result :: [a]
as :: [a]
a :: a
[-1: qsort.hs:3:24-38] *ghci&gt; :force as
*** Exception: Prelude.undefined
[-1: qsort.hs:3:24-38] *ghci&gt; :print as
as = &#39;b&#39; : &#39;c&#39; : (_t1::[Char])
</pre></div>
</div>
<p>The exception itself is bound to a new variable, <code class="docutils literal notranslate"><span class="pre">_exception</span></code>.</p>
<p>Breaking on exceptions is particularly useful for finding out what your
program was doing when it was in an infinite loop. Just hit Control-C,
and examine the history to find out what was going on.</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fbreak-on-exception">
<span class="sig-name descname"><span class="pre">-fbreak-on-exception</span></span><a class="headerlink" href="#ghc-flag-fbreak-on-exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Causes GHCi to halt evaluation and return to the interactive prompt
in the event of an exception. <a class="reference internal" href="#ghc-flag-fbreak-on-exception"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fbreak-on-exception</span></code></a> breaks
on all exceptions.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fbreak-on-error">
<span class="sig-name descname"><span class="pre">-fbreak-on-error</span></span><a class="headerlink" href="#ghc-flag-fbreak-on-error" title="Permalink to this definition">¶</a></dt>
<dd><p>Causes GHCi to halt evaluation and return to the interactive prompt in the
event of an exception.  <a class="reference internal" href="#ghc-flag-fbreak-on-error"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fbreak-on-error</span></code></a> breaks on only those
exceptions which would otherwise be uncaught.</p>
</dd></dl>

</section>
<section id="example-inspecting-functions">
<h3><span class="section-number">3.5.7. </span>Example: inspecting functions<a class="headerlink" href="#example-inspecting-functions" title="Permalink to this heading">¶</a></h3>
<p>It is possible to use the debugger to examine function values. When we
are at a breakpoint and a function is in scope, the debugger cannot show
you the source code for it; however, it is possible to get some
information by applying it to some arguments and observing the result.</p>
<p>The process is slightly complicated when the binding is polymorphic. We
show the process by means of an example. To keep things simple, we will
use the well known <code class="docutils literal notranslate"><span class="pre">map</span></code> function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="w"> </span><span class="nn">Prelude</span><span class="w"> </span><span class="k">hiding</span><span class="w"> </span><span class="p">(</span><span class="nf">map</span><span class="p">)</span><span class="w"></span>

<span class="nf">map</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"></span>
<span class="nf">map</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">map</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
</pre></div>
</div>
<p>We set a breakpoint on <code class="docutils literal notranslate"><span class="pre">map</span></code>, and call it.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :break 5
Breakpoint 0 activated at  map.hs:5:15-28
*ghci&gt; map Just [1..5]
Stopped at map.hs:(4,0)-(5,12)
_result :: [b]
x :: a
f :: a -&gt; b
xs :: [a]
</pre></div>
</div>
<p>GHCi tells us that, among other bindings, <code class="docutils literal notranslate"><span class="pre">f</span></code> is in scope. However,
its type is not fully known yet, and thus it is not possible to apply it
to any arguments. Nevertheless, observe that the type of its first
argument is the same as the type of <code class="docutils literal notranslate"><span class="pre">x</span></code>, and its result type is shared
with <code class="docutils literal notranslate"><span class="pre">_result</span></code>.</p>
<p>As we demonstrated earlier (<a class="reference internal" href="#breakpoints"><span class="std std-ref">Breakpoints and inspecting variables</span></a>), the debugger has some
intelligence built-in to update the type of <code class="docutils literal notranslate"><span class="pre">f</span></code> whenever the types of
<code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">_result</span></code> are discovered. So what we do in this scenario is
force <code class="docutils literal notranslate"><span class="pre">x</span></code> a bit, in order to recover both its type and the argument
part of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; seq x ()
*ghci&gt; :print x
x = 1
</pre></div>
</div>
<p>We can check now that as expected, the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> has been
reconstructed, and with it the type of <code class="docutils literal notranslate"><span class="pre">f</span></code> has been too:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :t x
x :: Integer
*ghci&gt; :t f
f :: Integer -&gt; b
</pre></div>
</div>
<p>From here, we can apply f to any argument of type Integer and observe
the results.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; let b = f 10
*ghci&gt; :t b
b :: b
*ghci&gt; b
&lt;interactive&gt;:1:0:
    Ambiguous type variable `b&#39; in the constraint:
      `Show b&#39; arising from a use of `print&#39; at &lt;interactive&gt;:1:0
*ghci&gt; :p b
b = (_t2::a)
*ghci&gt; seq b ()
()
*ghci&gt; :t b
b :: a
*ghci&gt; :p b
b = Just 10
*ghci&gt; :t b
b :: Maybe Integer
*ghci&gt; :t f
f :: Integer -&gt; Maybe Integer
*ghci&gt; f 20
Just 20
*ghci&gt; map f [1..5]
[Just 1, Just 2, Just 3, Just 4, Just 5]
</pre></div>
</div>
<p>In the first application of <code class="docutils literal notranslate"><span class="pre">f</span></code>, we had to do some more type
reconstruction in order to recover the result type of <code class="docutils literal notranslate"><span class="pre">f</span></code>. But after
that, we are free to use <code class="docutils literal notranslate"><span class="pre">f</span></code> normally.</p>
</section>
<section id="limitations">
<h3><span class="section-number">3.5.8. </span>Limitations<a class="headerlink" href="#limitations" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>When stopped at a breakpoint, if you try to evaluate a variable that
is already under evaluation, the second evaluation will hang. The
reason is that GHC knows the variable is under evaluation, so the new
evaluation just waits for the result before continuing, but of course
this isn’t going to happen because the first evaluation is stopped at
a breakpoint. Control-C can interrupt the hung evaluation and return
to the prompt.</p>
<p>The most common way this can happen is when you’re evaluating a CAF
(e.g. main), stop at a breakpoint, and ask for the value of the CAF
at the prompt again.</p>
</li>
<li><p>Implicit parameters (see <a class="reference internal" href="exts/implicit_parameters.html#implicit-parameters"><span class="std std-ref">Implicit parameters</span></a>) are only
available at the scope of a breakpoint if there is an explicit type
signature.</p></li>
</ul>
</section>
</section>
<section id="invoking-ghci">
<span id="ghci-invocation"></span><h2><span class="section-number">3.6. </span>Invoking GHCi<a class="headerlink" href="#invoking-ghci" title="Permalink to this heading">¶</a></h2>
<p id="index-16">GHCi is invoked with the command <code class="docutils literal notranslate"><span class="pre">ghci</span></code> or <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">--interactive</span></code>. One
or more modules or filenames can also be specified on the command line;
this instructs GHCi to load the specified modules or filenames (and all
the modules they depend on), just as if you had said <code class="docutils literal notranslate"><span class="pre">:load</span> <span class="pre">modules</span></code>
at the GHCi prompt (see <a class="reference internal" href="#ghci-commands"><span class="std std-ref">GHCi commands</span></a>). For example, to start
GHCi and load the program whose topmost module is in the file
<code class="docutils literal notranslate"><span class="pre">Main.hs</span></code>, we could say:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ghci Main.hs
</pre></div>
</div>
<p>Most of the command-line options accepted by GHC (see <a class="reference internal" href="using.html#using-ghc"><span class="std std-ref">Using GHC</span></a>)
also make sense in interactive mode. The ones that don’t make sense are
mostly obvious.</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-flocal-ghci-history">
<span class="sig-name descname"><span class="pre">-flocal-ghci-history</span></span><a class="headerlink" href="#ghc-flag-flocal-ghci-history" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, GHCi keeps global history in <code class="docutils literal notranslate"><span class="pre">$XDG_DATA_HOME/ghc/ghci_history</span></code> or
<code class="docutils literal notranslate"><span class="pre">%APPDATA%/&lt;app&gt;/ghci_history</span></code>, but you can use current directory, e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ghci -flocal-ghci-history
</pre></div>
</div>
<p>It will create <code class="docutils literal notranslate"><span class="pre">.ghci-history</span></code> in current folder where GHCi is launched.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fghci-leak-check">
<span class="sig-name descname"><span class="pre">-fghci-leak-check</span></span><a class="headerlink" href="#ghc-flag-fghci-leak-check" title="Permalink to this definition">¶</a></dt>
<dd><p>(Debugging only) When loading new modules with <code class="docutils literal notranslate"><span class="pre">:load</span></code>, check
that any previously loaded modules have been correctly garbage
collected. Emits messages if a leak is detected.</p>
</dd></dl>

<section id="packages">
<h3><span class="section-number">3.6.1. </span>Packages<a class="headerlink" href="#packages" title="Permalink to this heading">¶</a></h3>
<p id="index-17">Most packages (see <a class="reference internal" href="packages.html#using-packages"><span class="std std-ref">Using Packages</span></a>) are available without needing
to specify any extra flags at all: they will be automatically loaded the
first time they are needed.</p>
<p>For hidden packages, however, you need to request the package be loaded
by using the <a class="reference internal" href="packages.html#ghc-flag-package-pkg"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-package</span> <span class="pre">⟨pkg⟩</span></code></a> flag:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ghci -package readline
GHCi, version 8.y.z: https://www.haskell.org/ghc/  :? for help
Loading package base ... linking ... done.
Loading package readline-1.0 ... linking ... done.
ghci&gt;
</pre></div>
</div>
<p>The following command works to load new packages into a running GHCi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :set -package name
</pre></div>
</div>
<p>But note that doing this will cause all currently loaded modules to be
unloaded, and you’ll be dumped back into the <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>.</p>
</section>
<section id="extra-libraries">
<h3><span class="section-number">3.6.2. </span>Extra libraries<a class="headerlink" href="#extra-libraries" title="Permalink to this heading">¶</a></h3>
<p id="index-18">Extra libraries may be specified on the command line using the normal
<code class="docutils literal notranslate"><span class="pre">-llib</span></code> option. (The term <em>library</em> here refers to libraries of
foreign object code; for using libraries of Haskell source code, see
<a class="reference internal" href="#ghci-modules-filenames"><span class="std std-ref">Modules vs. filenames</span></a>.) For example, to load the “m” library:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ghci -lm
</pre></div>
</div>
<p>On systems with <code class="docutils literal notranslate"><span class="pre">.so</span></code>-style shared libraries, the actual library
loaded will the <code class="docutils literal notranslate"><span class="pre">liblib.so</span></code>. GHCi searches the following places for
libraries, in this order:</p>
<ul class="simple">
<li><p>Paths specified using the <a class="reference internal" href="phases.html#ghc-flag-L-dir"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-L</span> <span class="pre">⟨dir⟩</span></code></a> command-line option,</p></li>
<li><p>The standard library search path for your system loader, which on some
systems may be overridden by setting the <span class="target" id="index-19"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code>
environment variable.</p></li>
<li><p>The linker standard library search can also be overridden on some systems using
the <span class="target" id="index-20"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LIBRARY_PATH</span></code> environment variable. Because of some
implementation detail on Windows, setting <code class="docutils literal notranslate"><span class="pre">LIBRARY_PATH</span></code> will also extend
the system loader path for any library it finds. So often setting
<span class="target" id="index-21"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LIBRARY_PATH</span></code> is enough.</p></li>
</ul>
<p>On systems with <code class="docutils literal notranslate"><span class="pre">.dll</span></code>-style shared libraries, the actual library
loaded will be <code class="docutils literal notranslate"><span class="pre">lib.dll</span></code>, <code class="docutils literal notranslate"><span class="pre">liblib.dll</span></code>. GHCi also has full support for
import libraries, either Microsoft style <code class="docutils literal notranslate"><span class="pre">.lib</span></code>, or GNU GCC style <code class="docutils literal notranslate"><span class="pre">.a</span></code> and
<code class="docutils literal notranslate"><span class="pre">.dll.a</span></code> libraries. If you have an import library it is advisable to always
specify the import library instead of the <code class="docutils literal notranslate"><span class="pre">.dll</span></code>. e.g. use <code class="docutils literal notranslate"><span class="pre">-lgcc`</span> <span class="pre">instead</span> <span class="pre">of</span>
<span class="pre">``-llibgcc_s_seh-1</span></code>. Again, GHCi will signal an error if it can’t find the
library.</p>
<p>GHCi can also load plain object files (<code class="docutils literal notranslate"><span class="pre">.o</span></code> or <code class="docutils literal notranslate"><span class="pre">.obj</span></code> depending on
your platform) or static archives (<code class="docutils literal notranslate"><span class="pre">.a</span></code>) from the command-line. Just add the
name the object file or library to the command line.
On Windows GHCi also supports the <code class="docutils literal notranslate"><span class="pre">big-obj</span></code> format.</p>
<p>Ordering of <code class="docutils literal notranslate"><span class="pre">-l</span></code> options matters: a library should be mentioned
<em>before</em> the libraries it depends on (see <a class="reference internal" href="phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a>).</p>
</section>
</section>
<section id="ghci-commands">
<span id="id13"></span><h2><span class="section-number">3.7. </span>GHCi commands<a class="headerlink" href="#ghci-commands" title="Permalink to this heading">¶</a></h2>
<p>GHCi commands all begin with “<code class="docutils literal notranslate"><span class="pre">:</span></code>” and consist of a single command
name followed by zero or more parameters. The command name may be
abbreviated, with ambiguities being resolved in favour of the more
commonly used commands.</p>
<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-abandon">
<span class="sig-name descname"><span class="pre">:abandon</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-abandon" title="Permalink to this definition">¶</a></dt>
<dd><p>Abandons the current evaluation (only available when stopped at a
breakpoint).</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-add">
<span class="sig-name descname"><span class="pre">:add</span></span><span class="sig-prename descclassname"><span class="pre">[*]</span> <span class="pre">⟨module⟩</span></span><a class="headerlink" href="#ghci-cmd-add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add ⟨module⟩(s) to the current target set, and perform a reload.
Normally pre-compiled code for the module will be loaded if
available, or otherwise the module will be compiled to byte-code.
Using the <code class="docutils literal notranslate"><span class="pre">*</span></code> prefix forces the module to be loaded as byte-code.</p>
<p>⟨module⟩ may be a file path. A “<code class="docutils literal notranslate"><span class="pre">~</span></code>” symbol at the beginning of
⟨module⟩  will be replaced by the contents of the environment variable
<span class="target" id="index-22"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">HOME</span></code>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-all-types">
<span class="sig-name descname"><span class="pre">:all-types</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-all-types" title="Permalink to this definition">¶</a></dt>
<dd><p>List all types collected for expressions and (local) bindings
currently loaded (while <a class="reference internal" href="#ghci-cmd-set-c"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span> <span class="pre">+c</span></code></a> was active) with their respective
source-code span, e.g.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GhciTypes</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">all</span><span class="o">-</span><span class="n">types</span><span class="w"></span>
<span class="kt">GhciTypes</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="p">(</span><span class="mi">38</span><span class="p">,</span><span class="mi">13</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">38</span><span class="p">,</span><span class="mi">24</span><span class="p">)</span><span class="kt">:</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Id</span><span class="w"></span>
<span class="kt">GhciTypes</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">29</span><span class="p">)</span><span class="kt">:</span><span class="w"> </span><span class="kt">Outputable</span><span class="w"> </span><span class="kt">SpanInfo</span><span class="w"></span>
<span class="kt">GhciTypes</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">29</span><span class="p">)</span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="kt">Rational</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">SpanInfo</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">SDoc</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Outputable</span><span class="w"> </span><span class="kt">SpanInfo</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-back">
<span class="sig-name descname"><span class="pre">:back</span></span><span class="sig-prename descclassname"> <span class="pre">⟨n⟩</span></span><a class="headerlink" href="#ghci-cmd-back" title="Permalink to this definition">¶</a></dt>
<dd><p>Travel back ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See
<a class="reference internal" href="#tracing"><span class="std std-ref">Tracing and history</span></a> for more about GHCi’s debugging facilities. See also:
<a class="reference internal" href="#ghci-cmd-trace"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:trace</span></code></a>, <a class="reference internal" href="#ghci-cmd-history"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:history</span></code></a>, <a class="reference internal" href="#ghci-cmd-forward"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:forward</span></code></a>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-break">
<span class="sig-name descname"><span class="pre">:break</span></span><span class="sig-prename descclassname"> <span class="pre">[⟨identifier⟩</span> <span class="pre">|</span> <span class="pre">[⟨module⟩]</span> <span class="pre">⟨line⟩</span> <span class="pre">[⟨column⟩]]</span></span><a class="headerlink" href="#ghci-cmd-break" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a breakpoint on the specified function or line and column. See
<a class="reference internal" href="#setting-breakpoints"><span class="std std-ref">Setting breakpoints</span></a>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-browse">
<span class="sig-name descname"><span class="pre">:browse</span></span><span class="sig-prename descclassname"><span class="pre">[!]</span> <span class="pre">[[*]</span> <span class="pre">⟨module⟩]</span></span><a class="headerlink" href="#ghci-cmd-browse" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays the identifiers exported by the module ⟨module⟩, which must
be either loaded into GHCi or be a member of a package. If ⟨module⟩
is omitted, the most recently-loaded module is used.</p>
<p>Like all other GHCi commands, the output is always displayed in the
current GHCi scope (<a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a>).</p>
<p>There are two variants of the browse command:</p>
<ul>
<li><p>If the <code class="docutils literal notranslate"><span class="pre">*</span></code> symbol is placed before the module name, then <em>all</em>
the identifiers in scope in ⟨module⟩ (rather that just its
exports) are shown.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">*</span></code>-form is only available for modules which are
interpreted; for compiled modules (including modules from
packages) only the non-<code class="docutils literal notranslate"><span class="pre">*</span></code> form of <a class="reference internal" href="#ghci-cmd-browse"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:browse</span></code></a> is available.</p>
</li>
<li><p>Data constructors and class methods are usually displayed in the
context of their data type or class declaration. However, if the
<code class="docutils literal notranslate"><span class="pre">!</span></code> symbol is appended to the command, thus <code class="docutils literal notranslate"><span class="pre">:browse!</span></code>, they
are listed individually. The <code class="docutils literal notranslate"><span class="pre">!</span></code>-form also annotates the
listing with comments giving possible imports for each group of
entries. Here is an example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">browse</span><span class="o">!</span><span class="w"> </span><span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="w"></span>
<span class="c1">-- not currently imported</span><span class="w"></span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">catMaybes</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">fromJust</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">fromMaybe</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">isJust</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">isNothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">listToMaybe</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">mapMaybe</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"></span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">maybeToList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="c1">-- imported via Prelude</span><span class="w"></span>
<span class="kt">Just</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kt">Nothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">maybe</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>This output shows that, in the context of the current session (ie
in the scope of <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>), the first group of items from
<code class="docutils literal notranslate"><span class="pre">Data.Maybe</span></code> are not in scope (although they are available in
fully qualified form in the GHCi session - see
<a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a>), whereas the second group of items are in
scope (via <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>) and are therefore available either
unqualified, or with a <code class="docutils literal notranslate"><span class="pre">Prelude.</span></code> qualifier.</p>
</li>
</ul>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-cd">
<span class="sig-name descname"><span class="pre">:cd</span></span><span class="sig-prename descclassname"> <span class="pre">⟨dir⟩</span></span><a class="headerlink" href="#ghci-cmd-cd" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the current working directory to ⟨dir⟩. A “<code class="docutils literal notranslate"><span class="pre">~</span></code>” symbol
at the beginning of ⟨dir⟩ will be replaced by the contents of the
environment variable <span class="target" id="index-23"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">HOME</span></code>. See also the <a class="reference internal" href="#ghci-cmd-show-paths"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">paths</span></code></a>
command for showing the current working directory.</p>
<p>Note: changing directories causes all currently loaded modules to be
unloaded. This is because the search path is usually expressed using
relative directories, and changing the search path in the middle of
a session is not supported.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-cmd">
<span class="sig-name descname"><span class="pre">:cmd</span></span><span class="sig-prename descclassname"> <span class="pre">⟨expr⟩</span></span><a class="headerlink" href="#ghci-cmd-cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes ⟨expr⟩ as a computation of type <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">String</span></code>, and then
executes the resulting string as a list of GHCi commands. Multiple
commands are separated by newlines. The <a class="reference internal" href="#ghci-cmd-cmd"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:cmd</span></code></a> command is useful
with <a class="reference internal" href="#ghci-cmd-def"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:def</span></code></a> and <a class="reference internal" href="#ghci-cmd-set-stop"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span> <span class="pre">stop</span></code></a>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-complete">
<span class="sig-name descname"><span class="pre">:complete</span></span><span class="sig-prename descclassname"> <span class="pre">⟨type⟩</span> <span class="pre">[⟨n⟩-][⟨m⟩]</span> <span class="pre">⟨string-literal⟩</span></span><a class="headerlink" href="#ghci-cmd-complete" title="Permalink to this definition">¶</a></dt>
<dd><p>This command allows to request command completions from GHCi even
when interacting over a pipe instead of a proper terminal and is
designed for integrating GHCi’s completion with text editors and
IDEs.</p>
<p>When called, <a class="reference internal" href="#ghci-cmd-complete"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:complete</span></code></a> prints the ⟨n⟩<sup>th</sup> to
⟨m⟩<sup>th</sup> completion candidates for the partial input
⟨string-literal⟩ for the completion domain denoted by ⟨type⟩.
Currently, only the <code class="docutils literal notranslate"><span class="pre">repl</span></code> domain is supported which denotes the
kind of completion that would be provided interactively by GHCi at
the input prompt.</p>
<p>If omitted, ⟨n⟩ and ⟨m⟩ default to the first or last available
completion candidate respectively. If there are less candidates than
requested via the range argument, ⟨n⟩ and ⟨m⟩ are implicitly capped
to the number of available completion candidates.</p>
<p>The output of <a class="reference internal" href="#ghci-cmd-complete"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:complete</span></code></a> begins with a header line containing
three space-delimited fields:</p>
<ul class="simple">
<li><p>An integer denoting the number <code class="docutils literal notranslate"><span class="pre">l</span></code> of printed completions,</p></li>
<li><p>an integer denoting the total number of completions available,
and finally</p></li>
<li><p>a string literal denoting a common prefix to be added to the
returned completion candidates.</p></li>
</ul>
<p>The header line is followed by ⟨l⟩ lines each containing one
completion candidate encoded as (quoted) string literal. Here are
some example invocations showing the various cases:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :complete repl 0 &quot;&quot;
0 470 &quot;&quot;
ghci&gt; :complete repl 5 &quot;import For&quot;
5 21 &quot;import &quot;
&quot;Foreign&quot;
&quot;Foreign.C&quot;
&quot;Foreign.C.Error&quot;
&quot;Foreign.C.String&quot;
&quot;Foreign.C.Types&quot;
ghci&gt; :complete repl 5-10 &quot;import For&quot;
6 21 &quot;import &quot;
&quot;Foreign.C.Types&quot;
&quot;Foreign.Concurrent&quot;
&quot;Foreign.ForeignPtr&quot;
&quot;Foreign.ForeignPtr.Safe&quot;
&quot;Foreign.ForeignPtr.Unsafe&quot;
&quot;Foreign.Marshal&quot;
ghci&gt; :complete repl 20- &quot;import For&quot;
2 21 &quot;import &quot;
&quot;Foreign.StablePtr&quot;
&quot;Foreign.Storable&quot;
ghci&gt; :complete repl &quot;map&quot;
3 3 &quot;&quot;
&quot;map&quot;
&quot;mapM&quot;
&quot;mapM_&quot;
ghci&gt; :complete repl 5-10 &quot;map&quot;
0 3 &quot;&quot;
</pre></div>
</div>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-continue">
<span class="sig-name descname"><span class="pre">:continue</span></span><span class="sig-prename descclassname"> <span class="pre">[⟨ignoreCount⟩]</span></span><a class="headerlink" href="#ghci-cmd-continue" title="Permalink to this definition">¶</a></dt>
<dd><p>Continue the current evaluation, when stopped at a breakpoint.</p>
<p>If an <code class="docutils literal notranslate"><span class="pre">⟨ignoreCount⟩</span></code> is specified, the program will ignore
the current breakpoint for the next <code class="docutils literal notranslate"><span class="pre">⟨ignoreCount⟩</span></code> iterations.
See command <a class="reference internal" href="#ghci-cmd-ignore"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:ignore</span></code></a>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-ctags">
<span class="sig-name descname"><span class="pre">:ctags</span></span><span class="sig-prename descclassname"> <span class="pre">[⟨filename⟩]</span></span><a class="headerlink" href="#ghci-cmd-ctags" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a “tags” file for Vi-style editors (<a class="reference internal" href="#ghci-cmd-ctags"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:ctags</span></code></a>) or
Emacs-style editors (<a class="reference internal" href="#ghci-cmd-etags"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:etags</span></code></a>). If no filename is specified, the
default <code class="docutils literal notranslate"><span class="pre">tags</span></code> or <code class="docutils literal notranslate"><span class="pre">TAGS</span></code> is used, respectively. Tags for all the
functions, constructors and types in the currently loaded modules
are created. All modules must be interpreted for these commands to
work.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-def">
<span class="sig-name descname"><span class="pre">:def</span></span><span class="sig-prename descclassname"><span class="pre">[!]</span> <span class="pre">⟨name⟩</span> <span class="pre">⟨expr⟩</span></span><a class="headerlink" href="#ghci-cmd-def" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#ghci-cmd-def"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:def</span></code></a> is used to define new commands, or macros, in GHCi. The
command <code class="docutils literal notranslate"><span class="pre">:def</span> <span class="pre">⟨name⟩</span> <span class="pre">⟨expr⟩</span></code> defines a new GHCi command <code class="docutils literal notranslate"><span class="pre">:name</span></code>,
implemented by the Haskell expression ⟨expr⟩, which must have type
<code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">String</span></code>. When <code class="docutils literal notranslate"><span class="pre">:name</span> <span class="pre">args</span></code> is typed at the prompt,
GHCi will run the expression <code class="docutils literal notranslate"><span class="pre">(name</span> <span class="pre">args)</span></code>, take the resulting
<code class="docutils literal notranslate"><span class="pre">String</span></code>, and feed it back into GHCi as a new sequence of
commands. Separate commands in the result must be separated by
“<code class="docutils literal notranslate"><span class="pre">\n</span></code>”.</p>
<p>That’s all a little confusing, so here’s a few examples. To start
with, here’s a new GHCi command which doesn’t take any arguments or
produce any results, it just outputs the current date and time:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; let date _ = Data.Time.getZonedTime &gt;&gt;= print &gt;&gt; return &quot;&quot;
ghci&gt; :def date date
ghci&gt; :date
2017-04-10 12:34:56.93213581 UTC
</pre></div>
</div>
<p>Here’s an example of a command that takes an argument. It’s a
re-implementation of <a class="reference internal" href="#ghci-cmd-cd"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:cd</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; let mycd d = System.Directory.setCurrentDirectory d &gt;&gt; return &quot;&quot;
ghci&gt; :def mycd mycd
ghci&gt; :mycd ..
</pre></div>
</div>
<p>Or I could define a simple way to invoke “<code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">--make</span> <span class="pre">Main</span></code>”
in the current directory:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :def make (\_ -&gt; return &quot;:! ghc --make Main&quot;)
</pre></div>
</div>
<p>We can define a command that reads GHCi input from a file. This
might be useful for creating a set of bindings that we want to
repeatedly load into the GHCi session:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :def . readFile
ghci&gt; :. cmds.ghci
</pre></div>
</div>
<p>Notice that we named the command <code class="docutils literal notranslate"><span class="pre">:.</span></code>, by analogy with the
“<code class="docutils literal notranslate"><span class="pre">.</span></code>” Unix shell command that does the same thing.</p>
<p>Typing <code class="docutils literal notranslate"><span class="pre">:def</span></code> on its own lists the currently-defined macros.
Attempting to redefine an existing command name results in an error
unless the <code class="docutils literal notranslate"><span class="pre">:def!</span></code> form is used, in which case the old command
with that name is silently overwritten. However for builtin commands
the old command can still be used by preceding the command name with
a double colon (eg <code class="docutils literal notranslate"><span class="pre">::load</span></code>).
It’s not possible to redefine the commands <code class="docutils literal notranslate"><span class="pre">:{</span></code>, <code class="docutils literal notranslate"><span class="pre">:}</span></code> and <code class="docutils literal notranslate"><span class="pre">:!</span></code>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-delete">
<span class="sig-name descname"><span class="pre">:delete</span></span><span class="sig-prename descclassname"> <span class="pre">*</span> <span class="pre">|</span> <span class="pre">⟨num⟩</span> <span class="pre">...</span></span><a class="headerlink" href="#ghci-cmd-delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete one or more breakpoints by number (use <a class="reference internal" href="#ghci-cmd-show-breaks"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">breaks</span></code></a> to
see the number of each breakpoint). The <code class="docutils literal notranslate"><span class="pre">*</span></code> form deletes all the
breakpoints.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-disable">
<span class="sig-name descname"><span class="pre">:disable</span></span><span class="sig-prename descclassname"> <span class="pre">*</span> <span class="pre">|</span> <span class="pre">⟨num⟩</span> <span class="pre">...</span></span><a class="headerlink" href="#ghci-cmd-disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable one or more breakpoints by number (use <a class="reference internal" href="#ghci-cmd-show-breaks"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">breaks</span></code></a> to
see the number and state of each breakpoint). The <code class="docutils literal notranslate"><span class="pre">*</span></code> form disables all the
breakpoints.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-doc">
<span class="sig-name descname"><span class="pre">:doc</span></span><span class="sig-prename descclassname"> <span class="pre">⟨name⟩</span></span><a class="headerlink" href="#ghci-cmd-doc" title="Permalink to this definition">¶</a></dt>
<dd><p>(Experimental: This command will likely change significantly in GHC 8.8.)</p>
<p>Displays the documentation for the given name. Currently the command is
restricted to displaying the documentation directly on the declaration
in question, ignoring documentation for arguments, constructors etc.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-edit">
<span class="sig-name descname"><span class="pre">:edit</span></span><span class="sig-prename descclassname"> <span class="pre">⟨file⟩</span></span><a class="headerlink" href="#ghci-cmd-edit" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens an editor to edit the file ⟨file⟩, or the most recently loaded
module if ⟨file⟩ is omitted. If there were errors during the last
loading, the cursor will be positioned at the line of the first
error. The editor to invoke is taken from the <span class="target" id="index-24"></span><a class="reference internal" href="#envvar-VISUAL"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">VISUAL</span></code></a> or
<span class="target" id="index-25"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">EDITOR</span></code> environment variables, or a default editor on your system
if neither is not set. You can change the editor using <a class="reference internal" href="#ghci-cmd-set-editor"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span>
<span class="pre">editor</span></code></a>.</p>
</dd></dl>

<dl class="std envvar">
<dt class="sig sig-object std" id="envvar-VISUAL">
<span class="sig-name descname"><span class="pre">VISUAL</span></span><a class="headerlink" href="#envvar-VISUAL" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Hidden<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-enable">
<span class="sig-name descname"><span class="pre">:enable</span></span><span class="sig-prename descclassname"> <span class="pre">*</span> <span class="pre">|</span> <span class="pre">⟨num⟩</span> <span class="pre">...</span></span><a class="headerlink" href="#ghci-cmd-enable" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable one or more disabled breakpoints by number (use <a class="reference internal" href="#ghci-cmd-show-breaks"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:show</span> <span class="pre">breaks</span></code></a> to
see the number and state of each breakpoint). The <code class="docutils literal notranslate"><span class="pre">*</span></code> form enables all the
disabled breakpoints. Enabling a break point will reset its <code class="docutils literal notranslate"><span class="pre">ignore</span> <span class="pre">count</span></code>
to 0. (See <a class="reference internal" href="#ghci-cmd-ignore"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:ignore</span></code></a>)</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-etags">
<span class="sig-name descname"><span class="pre">:etags</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-etags" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#ghci-cmd-ctags"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:ctags</span></code></a>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-force">
<span class="sig-name descname"><span class="pre">:force</span></span><span class="sig-prename descclassname"> <span class="pre">⟨identifier⟩</span> <span class="pre">...</span></span><a class="headerlink" href="#ghci-cmd-force" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the value of ⟨identifier⟩ in the same way as <a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a>.
Unlike <a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a>, <a class="reference internal" href="#ghci-cmd-force"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:force</span></code></a> evaluates each thunk that it
encounters while traversing the value. This may cause exceptions or
infinite loops, or further breakpoints (which are ignored, but
displayed).</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-forward">
<span class="sig-name descname"><span class="pre">:forward</span></span><span class="sig-prename descclassname"> <span class="pre">⟨n⟩</span></span><a class="headerlink" href="#ghci-cmd-forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Move forward ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See
<a class="reference internal" href="#tracing"><span class="std std-ref">Tracing and history</span></a> for more about GHCi’s debugging facilities. See also:
<a class="reference internal" href="#ghci-cmd-trace"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:trace</span></code></a>, <a class="reference internal" href="#ghci-cmd-history"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:history</span></code></a>, <a class="reference internal" href="#ghci-cmd-back"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:back</span></code></a>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-help">
<span class="sig-name descname"><span class="pre">:help</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-help" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="ghci-cmd-2">
<span class="sig-name descname"><span class="pre">:?</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-2" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays a list of the available commands.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-3">
<span class="sig-name descname"><span class="pre">:</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-3" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-26">Repeat the previous command.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-history">
<span class="sig-name descname"><span class="pre">:history</span></span><span class="sig-prename descclassname"> <span class="pre">[num]</span></span><a class="headerlink" href="#ghci-cmd-history" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the history of evaluation steps. With a number, displays
that many steps (default: 20). For use with <a class="reference internal" href="#ghci-cmd-trace"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:trace</span></code></a>; see
<a class="reference internal" href="#tracing"><span class="std std-ref">Tracing and history</span></a>. To set the number of history entries stored by GHCi,
use the <a class="reference internal" href="#ghc-flag-fghci-hist-size-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fghci-hist-size=⟨n⟩</span></code></a> flag.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-info">
<span class="sig-name descname"><span class="pre">:info</span></span><span class="sig-prename descclassname"><span class="pre">[!]</span> <span class="pre">⟨name⟩</span></span><a class="headerlink" href="#ghci-cmd-info" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays information about the given name(s). For example, if ⟨name⟩
is a class, then the class methods and their types will be printed;
if ⟨name⟩ is a type constructor, then its definition will be
printed; if ⟨name⟩ is a function, then its type will be printed. If
⟨name⟩ has been loaded from a source file, then GHCi will also
display the location of its definition in the source.</p>
<p>For types and classes, GHCi also summarises instances that mention
them. To avoid showing irrelevant information, an instance is shown
only if (a) its head mentions ⟨name⟩, and (b) all the other things
mentioned in the instance are in scope (either qualified or
otherwise) as a result of a <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a> or <a class="reference internal" href="#ghci-cmd-module"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:module</span></code></a>
commands.</p>
<p>The command <code class="docutils literal notranslate"><span class="pre">:info!</span></code> works in a similar fashion but it removes
restriction (b), showing all instances that are in scope and mention
⟨name⟩ in their head.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-instances">
<span class="sig-name descname"><span class="pre">:instances</span></span><span class="sig-prename descclassname"> <span class="pre">⟨type⟩</span></span><a class="headerlink" href="#ghci-cmd-instances" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays all the class instances available to the argument ⟨type⟩.
The command will match ⟨type⟩ with the first parameter of every
instance and then check that all constraints are satisfiable.</p>
<p>When combined with <a class="reference internal" href="exts/partial_type_signatures.html#extension-PartialTypeSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PartialTypeSignatures</span></code></a>, a user can insert
wildcards into a query and learn the constraints required of each
wildcard for ⟨type⟩ match with an instance.</p>
<p>The output is a listing of all matching instances, simplified and
instantiated as much as possible.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; :instances Maybe (Maybe Int)
instance Eq (Maybe (Maybe Int)) -- Defined in ‘GHC.Maybe’
instance Ord (Maybe (Maybe Int)) -- Defined in ‘GHC.Maybe’
instance Show (Maybe (Maybe Int)) -- Defined in ‘GHC.Show’
instance Read (Maybe (Maybe Int)) -- Defined in ‘GHC.Read’

&gt; :set -XPartialTypeSignatures -fno-warn-partial-type-signatures

&gt; :instances Maybe _
instance Eq _ =&gt; Eq (Maybe _) -- Defined in ‘GHC.Maybe’
instance Semigroup _ =&gt; Monoid (Maybe _) -- Defined in ‘GHC.Base’
instance Ord _ =&gt; Ord (Maybe _) -- Defined in ‘GHC.Maybe’
instance Semigroup _ =&gt; Semigroup (Maybe _) -- Defined in ‘GHC.Base’
instance Show _ =&gt; Show (Maybe _) -- Defined in ‘GHC.Show’
instance Read _ =&gt; Read (Maybe _) -- Defined in ‘GHC.Read’
</pre></div>
</div>
<p>Only instances which could potentially be used will be displayed in the results.
Instances which require unsatisfiable constraints such as <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> will not be
included. In the following example, the instance for <code class="docutils literal notranslate"><span class="pre">A</span></code> is not shown because it cannot
be used.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt;:set -XDataKinds -XUndecidableInstances
ghci&gt;import GHC.TypeLits
ghci&gt;class A a
ghci&gt;instance (TypeError (Text &quot;Not possible&quot;)) =&gt; A Bool
ghci&gt;:instances Bool
instance Eq Bool -- Defined in ‘GHC.Classes’
instance Ord Bool -- Defined in ‘GHC.Classes’
instance Enum Bool -- Defined in ‘GHC.Enum’
instance Show Bool -- Defined in ‘GHC.Show’
instance Read Bool -- Defined in ‘GHC.Read’
instance Bounded Bool -- Defined in ‘GHC.Enum’
</pre></div>
</div>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-issafe">
<span class="sig-name descname"><span class="pre">:issafe</span></span><span class="sig-prename descclassname"> <span class="pre">[⟨module⟩]</span></span><a class="headerlink" href="#ghci-cmd-issafe" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays Safe Haskell information about the given module (or the
current module if omitted). This includes the trust type of the
module and its containing package.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-ignore">
<span class="sig-name descname"><span class="pre">:ignore</span></span><span class="sig-prename descclassname"> <span class="pre">⟨break⟩</span> <span class="pre">⟨ignoreCount⟩</span></span><a class="headerlink" href="#ghci-cmd-ignore" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the ignore count of the breakpoint with number <code class="docutils literal notranslate"><span class="pre">⟨break⟩</span></code> to
<code class="docutils literal notranslate"><span class="pre">⟨ignoreCount⟩</span></code>.</p>
<p>The next <code class="docutils literal notranslate"><span class="pre">⟨ignoreCount⟩</span></code> times the program hits the breakpoint
<code class="docutils literal notranslate"><span class="pre">⟨break⟩</span></code>, this breakpoint is ignored and the program doesn’t
stop. Every time the breakpoint is ignored, the <code class="docutils literal notranslate"><span class="pre">ignore</span> <span class="pre">count</span></code>
is decremented by 1. When the <code class="docutils literal notranslate"><span class="pre">ignore</span> <span class="pre">count</span></code> is zero, the program
again stops at the break point.</p>
<p>You can also specify an <code class="docutils literal notranslate"><span class="pre">⟨ignoreCount⟩</span></code> on a <a class="reference internal" href="#ghci-cmd-continue"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:continue</span></code></a>
command when you resume execution of your program.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-kind">
<span class="sig-name descname"><span class="pre">:kind</span></span><span class="sig-prename descclassname"><span class="pre">[!]</span> <span class="pre">⟨type⟩</span></span><a class="headerlink" href="#ghci-cmd-kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Infers and prints the kind of ⟨type⟩. The latter can be an arbitrary
type expression, including a partial application of a type
constructor, such as <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">Int</span></code>. In fact, <a class="reference internal" href="#ghci-cmd-kind"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:kind</span></code></a> even allows
you to write a partial application of a type synonym (usually
disallowed), so that this works:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; type T a b = (a,b,a)
ghci&gt; :k T Int Bool
T Int Bool :: *
ghci&gt; :k T
T :: * -&gt; * -&gt; *
ghci&gt; :k T Int
T Int :: * -&gt; *
</pre></div>
</div>
<p>If you specify the optional “<code class="docutils literal notranslate"><span class="pre">!</span></code>”, GHC will in addition normalise
the type by expanding out type synonyms and evaluating type-function
applications, and display the normalised result.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-list">
<span class="sig-name descname"><span class="pre">:list</span></span><span class="sig-prename descclassname"> <span class="pre">⟨identifier⟩</span></span><a class="headerlink" href="#ghci-cmd-list" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists the source code around the definition of ⟨identifier⟩ or the
current breakpoint if not given. This requires that the identifier
be defined in an interpreted module. If your output device supports
it, then GHCi will highlight the active subexpression in bold.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-list-module">
<span class="sig-name descname"><span class="pre">:list</span> <span class="pre">[⟨module⟩]</span></span><span class="sig-prename descclassname"> <span class="pre">⟨line⟩</span></span><a class="headerlink" href="#ghci-cmd-list-module" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists the source code around the given line number of ⟨module⟩. This
requires that the module be interpreted. If your output device
supports it, then GHCi will highlight the active subexpression in
bold.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-load">
<span class="sig-name descname"><span class="pre">:load</span></span><span class="sig-prename descclassname"><span class="pre">[!]</span> <span class="pre">[*]⟨module⟩</span></span><a class="headerlink" href="#ghci-cmd-load" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively loads the specified ⟨module⟩s, and all the modules they
depend on. Here, each ⟨module⟩ must be a module name or filename,
but may not be the name of a module in a package.</p>
<p>All previously loaded modules, except package modules, are
forgotten. The new set of modules is known as the target set. Note
that <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a> can be used without any arguments to unload all the
currently loaded modules and bindings.</p>
<p>Normally pre-compiled code for a module will be loaded if available,
or otherwise the module will be compiled to byte-code. Using the
<code class="docutils literal notranslate"><span class="pre">*</span></code> prefix forces a module to be loaded as byte-code.</p>
<p>Adding the optional “<code class="docutils literal notranslate"><span class="pre">!</span></code>” turns type errors into warnings while
loading. This allows to use the portions of the module that are
correct, even if there are type errors in some definitions.
Effectively, the “-fdefer-type-errors” flag is set before loading
and unset after loading if the flag has not already been set before.
See <a class="reference internal" href="exts/defer_type_errors.html#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a> for further motivation and details.</p>
<p>After a <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a> command, the current context is set to:</p>
<ul class="simple">
<li><p>⟨module⟩, if it was loaded successfully, or</p></li>
<li><p>the most recently successfully loaded module, if any other
modules were loaded as a result of the current <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>, or</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Prelude</span></code> otherwise.</p></li>
</ul>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-loc-at">
<span class="sig-name descname"><span class="pre">:loc-at</span></span><span class="sig-prename descclassname"> <span class="pre">⟨module⟩</span> <span class="pre">⟨line⟩</span> <span class="pre">⟨col⟩</span> <span class="pre">⟨end-line⟩</span> <span class="pre">⟨end-col⟩</span> <span class="pre">[⟨name⟩]</span></span><a class="headerlink" href="#ghci-cmd-loc-at" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to find the definition site of the name at the given
source-code span, e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X&gt; :loc-at X.hs 6 14 6 16 mu
X.hs:(8,7)-(8,9)
</pre></div>
</div>
<p>This command is useful when integrating GHCi with text editors and
IDEs for providing a goto-definition facility.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">:loc-at</span></code> command requires <a class="reference internal" href="#ghci-cmd-set-c"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span> <span class="pre">+c</span></code></a> to be set.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-main">
<span class="sig-name descname"><span class="pre">:main</span></span><span class="sig-prename descclassname"> <span class="pre">⟨arg1⟩</span> <span class="pre">...</span> <span class="pre">⟨argn⟩</span></span><a class="headerlink" href="#ghci-cmd-main" title="Permalink to this definition">¶</a></dt>
<dd><p>When a program is compiled and executed, it can use the <code class="docutils literal notranslate"><span class="pre">getArgs</span></code>
function to access the command-line arguments. However, we cannot
simply pass the arguments to the <code class="docutils literal notranslate"><span class="pre">main</span></code> function while we are
testing in ghci, as the <code class="docutils literal notranslate"><span class="pre">main</span></code> function doesn’t take its arguments
directly.</p>
<p>Instead, we can use the <a class="reference internal" href="#ghci-cmd-main"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:main</span></code></a> command. This runs whatever
<code class="docutils literal notranslate"><span class="pre">main</span></code> is in scope, with any arguments being treated the same as
command-line arguments, e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; main = System.Environment.getArgs &gt;&gt;= print
ghci&gt; :main foo bar
[&quot;foo&quot;,&quot;bar&quot;]
</pre></div>
</div>
<p>We can also quote arguments which contains characters like spaces,
and they are treated like Haskell strings, or we can just use
Haskell list syntax:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :main foo &quot;bar baz&quot;
[&quot;foo&quot;,&quot;bar baz&quot;]
ghci&gt; :main [&quot;foo&quot;, &quot;bar baz&quot;]
[&quot;foo&quot;,&quot;bar baz&quot;]
</pre></div>
</div>
<p>Finally, other functions can be called, either with the <code class="docutils literal notranslate"><span class="pre">-main-is</span></code>
flag or the <a class="reference internal" href="#ghci-cmd-run"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:run</span></code></a> command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; foo = putStrLn &quot;foo&quot; &gt;&gt; System.Environment.getArgs &gt;&gt;= print
ghci&gt; bar = putStrLn &quot;bar&quot; &gt;&gt; System.Environment.getArgs &gt;&gt;= print
ghci&gt; :set -main-is foo
ghci&gt; :main foo &quot;bar baz&quot;
foo
[&quot;foo&quot;,&quot;bar baz&quot;]
ghci&gt; :run bar [&quot;foo&quot;, &quot;bar baz&quot;]
bar
[&quot;foo&quot;,&quot;bar baz&quot;]
</pre></div>
</div>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-module">
<span class="sig-name descname"><span class="pre">:module</span></span><span class="sig-prename descclassname"> <span class="pre">+|-</span> <span class="pre">[*]⟨mod1⟩</span> <span class="pre">...</span></span><a class="headerlink" href="#ghci-cmd-module" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-import">
<span class="sig-name descname"><span class="pre">import</span></span><span class="sig-prename descclassname"> <span class="pre">⟨mod⟩</span></span><a class="headerlink" href="#ghci-cmd-import" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets or modifies the current context for statements typed at the
prompt. The form <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">mod</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">:module</span> <span class="pre">+mod</span></code>.
See <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a> for more details.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-print">
<span class="sig-name descname"><span class="pre">:print</span></span><span class="sig-prename descclassname"> <span class="pre">⟨names⟩</span></span><a class="headerlink" href="#ghci-cmd-print" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints a value without forcing its evaluation. <a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a> may be
used on values whose types are unknown or partially known, which
might be the case for local variables with polymorphic types at a
breakpoint. While inspecting the runtime value, <a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a> attempts
to reconstruct the type of the value, and will elaborate the type in
GHCi’s environment if possible. If any unevaluated components
(thunks) are encountered, then <a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a> binds a fresh variable
with a name beginning with <code class="docutils literal notranslate"><span class="pre">_t</span></code> to each thunk. See
<a class="reference internal" href="#breakpoints"><span class="std std-ref">Breakpoints and inspecting variables</span></a> for more information. See also the <a class="reference internal" href="#ghci-cmd-sprint"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:sprint</span></code></a>
command, which works like <a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a> but does not bind new
variables.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-quit">
<span class="sig-name descname"><span class="pre">:quit</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-quit" title="Permalink to this definition">¶</a></dt>
<dd><p>Quits GHCi. You can also quit by typing <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">D</kbd></kbd> at the prompt.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-reload">
<span class="sig-name descname"><span class="pre">:reload</span></span><span class="sig-prename descclassname"><span class="pre">[!]</span></span><a class="headerlink" href="#ghci-cmd-reload" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to reload the current target set (see <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>) if any of
the modules in the set, or any dependent module, has changed. Note
that this may entail loading new modules, or dropping modules which
are no longer indirectly required by the target.</p>
<p>Adding the optional “<code class="docutils literal notranslate"><span class="pre">!</span></code>” turns type errors into warnings while
loading. This allows to use the portions of the module that are
correct, even if there are type errors in some definitions.
Effectively, the “-fdefer-type-errors” flag is set before loading
and unset after loading if the flag has not already been set before.
See <a class="reference internal" href="exts/defer_type_errors.html#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a> for further motivation and details.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-run">
<span class="sig-name descname"><span class="pre">:run</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-run" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#ghci-cmd-main"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:main</span></code></a>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-script">
<span class="sig-name descname"><span class="pre">:script</span></span><span class="sig-prename descclassname"> <span class="pre">[⟨n⟩]</span> <span class="pre">⟨filename⟩</span></span><a class="headerlink" href="#ghci-cmd-script" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the lines of a file as a series of GHCi commands. The syntax for
file-name arguments respects shell quoting rules, i.e., file names
containing spaces can be enclosed in double quotes or with spaces escaped
with a backslash. This command is compatible with multiline statements as
set by <a class="reference internal" href="#ghci-cmd-set-m"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span> <span class="pre">+m</span></code></a></p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set">
<span class="sig-name descname"><span class="pre">:set</span></span><span class="sig-prename descclassname"> <span class="pre">[⟨option⟩</span> <span class="pre">...]</span></span><a class="headerlink" href="#ghci-cmd-set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets various options. See <a class="reference internal" href="#ghci-set"><span class="std std-ref">The :set and :seti commands</span></a> for a list of available
options and <a class="reference internal" href="flags.html#interactive-mode-options"><span class="std std-ref">Interactive-mode options</span></a> for a list of
GHCi-specific flags. The <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a> command by itself shows which
options are currently set. It also lists the current dynamic flag
settings, with GHCi-specific flags listed separately.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-args">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">args</span></span><span class="sig-prename descclassname"> <span class="pre">⟨arg⟩</span></span><a class="headerlink" href="#ghci-cmd-set-args" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-27">Sets the list of arguments which are returned when the program calls
<code class="docutils literal notranslate"><span class="pre">System.getArgs</span></code>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-editor">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">editor</span></span><span class="sig-prename descclassname"> <span class="pre">⟨cmd⟩</span></span><a class="headerlink" href="#ghci-cmd-set-editor" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the command used by <a class="reference internal" href="#ghci-cmd-edit"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:edit</span></code></a> to ⟨cmd⟩.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-local-config">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">local-config</span></span><span class="sig-prename descclassname"> <span class="pre">⟨source|ignore⟩</span></span><a class="headerlink" href="#ghci-cmd-set-local-config" title="Permalink to this definition">¶</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">ignore</span></code>, <code class="file docutils literal notranslate"><span class="pre">./.ghci</span></code> files will be ignored (sourcing
untrusted local scripts is a security risk).   The default is
<code class="docutils literal notranslate"><span class="pre">source</span></code>.  Set this directive in your user <code class="file docutils literal notranslate"><span class="pre">.ghci</span></code>
script, i.e. before the local script would be sourced.</p>
<p>Even when set to <code class="docutils literal notranslate"><span class="pre">ignore</span></code>, a local script will still be
processed if given by <a class="reference internal" href="#ghc-flag-ghci-script"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ghci-script</span></code></a> on the command
line, or sourced via <a class="reference internal" href="#ghci-cmd-script"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:script</span></code></a>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-prog">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">prog</span></span><span class="sig-prename descclassname"> <span class="pre">⟨prog⟩</span></span><a class="headerlink" href="#ghci-cmd-set-prog" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-28">Sets the string to be returned when the program calls
<code class="docutils literal notranslate"><span class="pre">System.getProgName</span></code>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-prompt">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">prompt</span></span><span class="sig-prename descclassname"> <span class="pre">⟨prompt⟩</span></span><a class="headerlink" href="#ghci-cmd-set-prompt" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-29">Sets the string to be used as the prompt in GHCi. Inside ⟨prompt⟩,
the next sequences are replaced:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">%s</span></code> by the names of the modules currently in scope.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%l</span></code> by the line number (as referenced in compiler messages) of the
current prompt.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%d</span></code> by the date in “Weekday Month Date” format (e.g., “Tue May 26”) .</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%t</span></code> by the current time in 24-hour HH:MM:SS format.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%T</span></code> by the current time in 12-hour HH:MM:SS format.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%&#64;</span></code> by the current time in 12-hour am/pm format.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%A</span></code> by the current time in 24-hour HH:MM format.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%u</span></code> by the username of the current user.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%w</span></code> by the current working directory.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%o</span></code> by the operating system.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%a</span></code> by the machine architecture.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%N</span></code> by the compiler name.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%V</span></code> by the compiler version.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%call(cmd</span> <span class="pre">[args])</span></code> by the result of calling <code class="docutils literal notranslate"><span class="pre">cmd</span> <span class="pre">args</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%%</span></code> by <code class="docutils literal notranslate"><span class="pre">%</span></code>.</p></li>
</ul>
<p>If ⟨prompt⟩ starts with <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> then it is parsed as a Haskell String;
otherwise it is treated as a literal string.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-prompt-cont">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">prompt-cont</span></span><span class="sig-prename descclassname"> <span class="pre">⟨prompt⟩</span></span><a class="headerlink" href="#ghci-cmd-set-prompt-cont" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the string to be used as the continuation prompt (used when
using the <a class="reference internal" href="#ghci-cmd-0"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:{</span></code></a> command) in GHCi.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-prompt-function">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">prompt-function</span></span><span class="sig-prename descclassname"> <span class="pre">⟨prompt-function⟩</span></span><a class="headerlink" href="#ghci-cmd-set-prompt-function" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-30">Sets the function to be used for the prompt displaying in GHCi. The
function should be of the type <code class="docutils literal notranslate"><span class="pre">[String]</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">String</span></code>. This
function is called each time the prompt is being made. The first argument
stands for the names of the modules currently in scope(the name of the
“topmost” module  will begin with a <code class="docutils literal notranslate"><span class="pre">*</span></code>; see  <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a> for
more information). The second arguments is the line number (as referenced
in compiler  messages) of the current prompt.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-prompt-cont-function">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">prompt-cont-function</span></span><span class="sig-prename descclassname"> <span class="pre">⟨prompt-function⟩</span></span><a class="headerlink" href="#ghci-cmd-set-prompt-cont-function" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the function to be used for the continuation prompt (used when
using the <a class="reference internal" href="#ghci-cmd-0"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:{</span></code></a> command) displaying in GHCi.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-stop">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">stop</span></span><span class="sig-prename descclassname"> <span class="pre">⟨num⟩</span> <span class="pre">⟨cmd⟩</span></span><a class="headerlink" href="#ghci-cmd-set-stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a command to be executed when a breakpoint is hit, or a new item
in the history is selected. The most common use of <a class="reference internal" href="#ghci-cmd-set-stop"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span> <span class="pre">stop</span></code></a> is
to display the source code at the current location, e.g.
<code class="docutils literal notranslate"><span class="pre">:set</span> <span class="pre">stop</span> <span class="pre">:list</span></code>.</p>
<p>If a number is given before the command, then the commands are run
when the specified breakpoint (only) is hit. This can be quite
useful: for example, <code class="docutils literal notranslate"><span class="pre">:set</span> <span class="pre">stop</span> <span class="pre">1</span> <span class="pre">:continue</span></code> effectively disables
breakpoint 1, by running <a class="reference internal" href="#ghci-cmd-continue"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:continue</span></code></a> whenever it is hit
In this case GHCi will still emit a message to say the breakpoint was hit.
If you don’t want such a message, you can use the <a class="reference internal" href="#ghci-cmd-disable"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:disable</span></code></a>
command. What’s more,
with cunning use of <a class="reference internal" href="#ghci-cmd-def"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:def</span></code></a> and <a class="reference internal" href="#ghci-cmd-cmd"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:cmd</span></code></a> you can use
<a class="reference internal" href="#ghci-cmd-set-stop"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span> <span class="pre">stop</span></code></a> to implement conditional breakpoints:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*ghci&gt; :def cond \expr -&gt; return (&quot;:cmd if (&quot; ++ expr ++ &quot;) then return \&quot;\&quot; else return \&quot;:continue\&quot;&quot;)
*ghci&gt; :set stop 0 :cond (x &lt; 3)
</pre></div>
</div>
<p>To ignore breakpoints for a specified number of iterations use
the <a class="reference internal" href="#ghci-cmd-ignore"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:ignore</span></code></a> or the <code class="docutils literal notranslate"><span class="pre">⟨ignoreCount⟩</span></code> parameter of the
<a class="reference internal" href="#ghci-cmd-continue"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:continue</span></code></a> command.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-seti">
<span class="sig-name descname"><span class="pre">:seti</span></span><span class="sig-prename descclassname"> <span class="pre">[⟨option⟩</span> <span class="pre">...]</span></span><a class="headerlink" href="#ghci-cmd-seti" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a>, but options set with <a class="reference internal" href="#ghci-cmd-seti"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:seti</span></code></a> affect only
expressions and commands typed at the prompt, and not modules loaded
with <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a> (in contrast, options set with <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a> apply
everywhere). See <a class="reference internal" href="#ghci-interactive-options"><span class="std std-ref">Setting options for interactive evaluation only</span></a>.</p>
<p>Without any arguments, displays the current set of options that are
applied to expressions and commands typed at the prompt.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-show-bindings">
<span class="sig-name descname"><span class="pre">:show</span> <span class="pre">bindings</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-show-bindings" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the bindings made at the prompt and their types.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-show-breaks">
<span class="sig-name descname"><span class="pre">:show</span> <span class="pre">breaks</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-show-breaks" title="Permalink to this definition">¶</a></dt>
<dd><p>List the active breakpoints.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-show-context">
<span class="sig-name descname"><span class="pre">:show</span> <span class="pre">context</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-show-context" title="Permalink to this definition">¶</a></dt>
<dd><p>List the active evaluations that are stopped at breakpoints.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-show-imports">
<span class="sig-name descname"><span class="pre">:show</span> <span class="pre">imports</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-show-imports" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the imports that are currently in force, as created by
<code class="docutils literal notranslate"><span class="pre">import</span></code> and <a class="reference internal" href="#ghci-cmd-module"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:module</span></code></a> commands.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-show-modules">
<span class="sig-name descname"><span class="pre">:show</span> <span class="pre">modules</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-show-modules" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the list of modules currently loaded.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-show-packages">
<span class="sig-name descname"><span class="pre">:show</span> <span class="pre">packages</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-show-packages" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the currently active package flags, as well as the list of
packages currently loaded.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-show-paths">
<span class="sig-name descname"><span class="pre">:show</span> <span class="pre">paths</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-show-paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the current working directory (as set via <a class="reference internal" href="#ghci-cmd-cd"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:cd</span></code></a> command), as
well as the list of directories searched for source files (as set by the
<code class="docutils literal notranslate"><span class="pre">-i</span></code> option).</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-show-language">
<span class="sig-name descname"><span class="pre">:show</span> <span class="pre">language</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-show-language" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the currently active language flags for source files.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-showi-language">
<span class="sig-name descname"><span class="pre">:showi</span> <span class="pre">language</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-showi-language" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the currently active language flags for expressions typed at
the prompt (see also <a class="reference internal" href="#ghci-cmd-seti"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:seti</span></code></a>).</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-show">
<span class="sig-name descname"><span class="pre">:show</span></span><span class="sig-prename descclassname"> <span class="pre">[args|prog|prompt|editor|stop]</span></span><a class="headerlink" href="#ghci-cmd-show" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays the specified setting (see <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a>).</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-sprint">
<span class="sig-name descname"><span class="pre">:sprint</span></span><span class="sig-prename descclassname"> <span class="pre">⟨expr⟩</span></span><a class="headerlink" href="#ghci-cmd-sprint" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints a value without forcing its evaluation. <a class="reference internal" href="#ghci-cmd-sprint"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:sprint</span></code></a> is
similar to <a class="reference internal" href="#ghci-cmd-print"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:print</span></code></a>, with the difference that unevaluated subterms
are not bound to new variables, they are simply denoted by <code class="docutils literal notranslate"><span class="pre">_</span></code>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-step">
<span class="sig-name descname"><span class="pre">:step</span></span><span class="sig-prename descclassname"> <span class="pre">[⟨expr⟩]</span></span><a class="headerlink" href="#ghci-cmd-step" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable all breakpoints and begin evaluating an expression in
single-stepping mode. In this mode evaluation will be stopped after
every reduction, allowing local variables to be inspected. If ⟨expr⟩
is not given, evaluation will resume at the last breakpoint. See
<a class="reference internal" href="#single-stepping"><span class="std std-ref">Single-stepping</span></a>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-steplocal">
<span class="sig-name descname"><span class="pre">:steplocal</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-steplocal" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable only breakpoints in the current top-level binding and resume
evaluation at the last breakpoint. Continuation with
<a class="reference internal" href="#ghci-cmd-steplocal"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:steplocal</span></code></a> is not possible if this last breakpoint was
hit by an error (<a class="reference internal" href="#ghc-flag-fbreak-on-error"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fbreak-on-error</span></code></a>) or an
exception (<a class="reference internal" href="#ghc-flag-fbreak-on-exception"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fbreak-on-exception</span></code></a>).</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-stepmodule">
<span class="sig-name descname"><span class="pre">:stepmodule</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-stepmodule" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable only breakpoints in the current module and resume evaluation
at the last breakpoint.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-trace">
<span class="sig-name descname"><span class="pre">:trace</span></span><span class="sig-prename descclassname"> <span class="pre">⟨expr⟩</span></span><a class="headerlink" href="#ghci-cmd-trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the given expression (or from the last breakpoint if no
expression is given), and additionally logs the evaluation steps for
later inspection using <a class="reference internal" href="#ghci-cmd-history"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:history</span></code></a>. See <a class="reference internal" href="#tracing"><span class="std std-ref">Tracing and history</span></a>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-type">
<span class="sig-name descname"><span class="pre">:type</span></span><span class="sig-prename descclassname"> <span class="pre">⟨expression⟩</span></span><a class="headerlink" href="#ghci-cmd-type" title="Permalink to this definition">¶</a></dt>
<dd><p>Infers and prints the type of ⟨expression⟩.  For polymorphic types
it instantiates the ‘inferred’ forall quantifiers (but not the
‘specified’ ones; see <a class="reference internal" href="exts/type_applications.html#inferred-vs-specified"><span class="std std-ref">Inferred vs. specified type variables</span></a>), solves constraints,
re-generalises, and then reduces type families as much as possible.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*X&gt; :type length
length :: Foldable t =&gt; t a -&gt; Int
</pre></div>
</div>
<p>Type family reduction is skipped if the function is not fully instantiated,
as this has been observed to give more intuitive results.
You may want to use <a class="reference internal" href="#ghci-cmd-info"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:info</span></code></a> if you are not applying any arguments,
as that will return the original type of the function without instantiating.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-type-v">
<span class="sig-name descname"><span class="pre">:type</span> <span class="pre">+v</span></span><span class="sig-prename descclassname"> <span class="pre">⟨expression⟩</span></span><a class="headerlink" href="#ghci-cmd-type-v" title="Permalink to this definition">¶</a></dt>
<dd><p>Infers and prints the type of ⟨expression⟩, binding inferred type variables
with <a class="reference internal" href="exts/type_applications.html#inferred-vs-specified"><span class="std std-ref">*specified* visibility</span></a>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-type-d">
<span class="sig-name descname"><span class="pre">:type</span> <span class="pre">+d</span></span><span class="sig-prename descclassname"> <span class="pre">⟨expression⟩</span></span><a class="headerlink" href="#ghci-cmd-type-d" title="Permalink to this definition">¶</a></dt>
<dd><p>Infers and prints the type of ⟨expression⟩, instantiating <em>all</em> the forall
quantifiers, solving constraints, defaulting, and generalising.
In this mode, if the inferred type is constrained by
any interactive class (<code class="docutils literal notranslate"><span class="pre">Num</span></code>, <code class="docutils literal notranslate"><span class="pre">Show</span></code>, <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, <code class="docutils literal notranslate"><span class="pre">Foldable</span></code>,
or <code class="docutils literal notranslate"><span class="pre">Traversable</span></code>), the constrained type variable(s) are defaulted
according to the rules described under <a class="reference internal" href="#extension-ExtendedDefaultRules"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ExtendedDefaultRules</span></code></a>.
This mode is quite useful when the inferred type is quite general (such
as for <code class="docutils literal notranslate"><span class="pre">foldr</span></code>) and it may be helpful to see a more concrete
instantiation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*X&gt; :type +d length
length :: [a] -&gt; Int
</pre></div>
</div>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-type-at">
<span class="sig-name descname"><span class="pre">:type-at</span></span><span class="sig-prename descclassname"> <span class="pre">⟨path⟩</span> <span class="pre">⟨line⟩</span> <span class="pre">⟨col⟩</span> <span class="pre">⟨end-line⟩</span> <span class="pre">⟨end-col⟩</span> <span class="pre">[⟨name⟩]</span></span><a class="headerlink" href="#ghci-cmd-type-at" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the inferred type at the given span/position in the module, e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*X&gt; :type-at X.hs 6 6 6 7 f
Int -&gt; Int
</pre></div>
</div>
<p>This command is useful when integrating GHCi with text editors and
IDEs for providing a show-type-under-point facility.</p>
<p>The first parameter (path) must be a file path and not a module name.
The type of this path is dependent on how the module was loaded into GHCi:
If the module was loaded by name, then the path name calculated by GHCi
as described in <a class="reference internal" href="#ghci-modules-filenames"><span class="std std-ref">Modules vs. filenames</span></a> must be used.
If the module was loaded with an absolute or a relative path,
then the same path must be specified.</p>
<p>The last string parameter is useful for when the span is out of
date, i.e. the file changed and the code has moved. In which case
<a class="reference internal" href="#ghci-cmd-type-at"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:type-at</span></code></a> falls back to a general <a class="reference internal" href="#ghci-cmd-type"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:type</span></code></a> like lookup.</p>
<p>The <a class="reference internal" href="#ghci-cmd-type-at"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:type-at</span></code></a> command requires <a class="reference internal" href="#ghci-cmd-set-c"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span> <span class="pre">+c</span></code></a> to be set.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-undef">
<span class="sig-name descname"><span class="pre">:undef</span></span><span class="sig-prename descclassname"> <span class="pre">⟨name⟩</span></span><a class="headerlink" href="#ghci-cmd-undef" title="Permalink to this definition">¶</a></dt>
<dd><p>Undefines the user-defined command ⟨name⟩ (see <a class="reference internal" href="#ghci-cmd-def"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:def</span></code></a> above).</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-unset">
<span class="sig-name descname"><span class="pre">:unset</span></span><span class="sig-prename descclassname"> <span class="pre">⟨option⟩</span></span><a class="headerlink" href="#ghci-cmd-unset" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsets certain options. See <a class="reference internal" href="#ghci-set"><span class="std std-ref">The :set and :seti commands</span></a> for a list of available
options.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-uses">
<span class="sig-name descname"><span class="pre">:uses</span></span><span class="sig-prename descclassname"> <span class="pre">⟨module⟩</span> <span class="pre">⟨line⟩</span> <span class="pre">⟨col⟩</span> <span class="pre">⟨end-line⟩</span> <span class="pre">⟨end-col⟩</span> <span class="pre">[⟨name⟩]</span></span><a class="headerlink" href="#ghci-cmd-uses" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports all module-local uses of the thing at the given position
in the module, e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:uses GhciFind.hs 53 66 53 70 name
GhciFind.hs:(46,25)-(46,29)
GhciFind.hs:(47,37)-(47,41)
GhciFind.hs:(53,66)-(53,70)
GhciFind.hs:(57,62)-(57,66)
</pre></div>
</div>
<p>This command is useful for highlighting and navigating all uses of
an identifier in editors and IDEs.</p>
<p>The <a class="reference internal" href="#ghci-cmd-uses"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:uses</span></code></a> command requires <a class="reference internal" href="#ghci-cmd-set-c"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span> <span class="pre">+c</span></code></a> to be set.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-builtin-command">
<span class="sig-name descname"><span class="pre">::</span> <span class="pre">⟨builtin-command⟩</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-builtin-command" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the GHCi built-in command (e.g. <code class="docutils literal notranslate"><span class="pre">::type</span> <span class="pre">3</span></code>). That is,
look up on the list of builtin commands, excluding defined macros.
See also: <a class="reference internal" href="#ghci-cmd-def"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:def</span></code></a>.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-command">
<span class="sig-name descname"><span class="pre">:!</span> <span class="pre">⟨command⟩</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-command" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-31">Executes the shell command ⟨command⟩.</p>
</dd></dl>

</section>
<section id="the-set-and-seti-commands">
<span id="ghci-set"></span><h2><span class="section-number">3.8. </span>The <code class="docutils literal notranslate"><span class="pre">:set</span></code> and <code class="docutils literal notranslate"><span class="pre">:seti</span></code> commands<a class="headerlink" href="#the-set-and-seti-commands" title="Permalink to this heading">¶</a></h2>
<p id="index-32">The <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a> command sets two types of options: GHCi options, which
begin with “<code class="docutils literal notranslate"><span class="pre">+</span></code>”, and “command-line” options, which begin with “<code class="docutils literal notranslate"><span class="pre">-</span></code>“.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>At the moment, the <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a> command doesn’t support any kind of
quoting in its arguments: quotes will not be removed and cannot be used
to group words together. For example, <code class="docutils literal notranslate"><span class="pre">:set</span> <span class="pre">-DFOO='BAR</span> <span class="pre">BAZ'</span></code> will not
do what you expect.</p>
</div>
<section id="ghci-options">
<h3><span class="section-number">3.8.1. </span>GHCi options<a class="headerlink" href="#ghci-options" title="Permalink to this heading">¶</a></h3>
<p id="index-33">GHCi options may be set using <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a> and unset using <a class="reference internal" href="#ghci-cmd-unset"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:unset</span></code></a>.</p>
<p>The available GHCi options are:</p>
<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-c">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">+c</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-set-c" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect type and location information after loading modules.
The commands <a class="reference internal" href="#ghci-cmd-all-types"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:all-types</span></code></a>, <a class="reference internal" href="#ghci-cmd-loc-at"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:loc-at</span></code></a>,
<a class="reference internal" href="#ghci-cmd-type-at"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:type-at</span></code></a>, and <a class="reference internal" href="#ghci-cmd-uses"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:uses</span></code></a> require <code class="docutils literal notranslate"><span class="pre">+c</span></code> to be active.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-m">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">+m</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-set-m" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-34">Enable parsing of multiline commands. A multiline command is
prompted for when the current input line contains open layout
contexts (see <a class="reference internal" href="#ghci-multiline"><span class="std std-ref">Multiline input</span></a>).</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-r">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">+r</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-set-r" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-35">Normally, any evaluation of top-level expressions (otherwise known
as CAFs or Constant Applicative Forms) in loaded modules is retained
between evaluations. Turning on <code class="docutils literal notranslate"><span class="pre">+r</span></code> causes all evaluation of
top-level expressions to be discarded after each evaluation (they
are still retained <em>during</em> a single evaluation).</p>
<p>This option may help if the evaluated top-level expressions are
consuming large amounts of space, or if you need repeatable
performance measurements.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-s">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">+s</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-set-s" title="Permalink to this definition">¶</a></dt>
<dd><p>Display some stats after evaluating each expression, including the
elapsed time and number of bytes allocated. NOTE: the allocation
figure is only accurate to the size of the storage manager’s
allocation area, because it is calculated at every GC. Hence, you
might see values of zero if no GC has occurred.</p>
</dd></dl>

<dl class="std ghci-cmd">
<dt class="sig sig-object std" id="ghci-cmd-set-t">
<span class="sig-name descname"><span class="pre">:set</span> <span class="pre">+t</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#ghci-cmd-set-t" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-36">Display the type of each variable bound after a statement is entered
at the prompt. If the statement is a single expression, then the
only variable binding will be for the variable <code class="docutils literal notranslate"><span class="pre">it</span></code>.</p>
</dd></dl>

</section>
<section id="setting-ghc-command-line-options-in-ghci">
<span id="ghci-cmd-line-options"></span><h3><span class="section-number">3.8.2. </span>Setting GHC command-line options in GHCi<a class="headerlink" href="#setting-ghc-command-line-options-in-ghci" title="Permalink to this heading">¶</a></h3>
<p>Normal GHC command-line options may also be set using <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a>. For
example, to turn on <a class="reference internal" href="using-warnings.html#ghc-flag-Wmissing-signatures"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wmissing-signatures</span></code></a>, you would say:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :set -Wmissing-signatures
</pre></div>
</div>
<p>Any GHC command-line option that is designated as dynamic (see the table
in <a class="reference internal" href="flags.html#flag-reference"><span class="std std-ref">Flag reference</span></a>), may be set using <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a>. To unset an
option, you can set the reverse option:</p>
<div class="highlight-none notranslate" id="index-37"><div class="highlight"><pre><span></span>ghci&gt; :set -Wno-incomplete-patterns -XNoMultiParamTypeClasses
</pre></div>
</div>
<p><a class="reference internal" href="flags.html#flag-reference"><span class="std std-ref">Flag reference</span></a> lists the reverse for each option where
applicable.</p>
<p>Certain static options (<a class="reference internal" href="packages.html#ghc-flag-package-pkg"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-package</span> <span class="pre">⟨pkg⟩</span></code></a>, <a class="reference internal" href="phases.html#ghc-flag-Idir"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-I⟨dir⟩</span></code></a>,
<a class="reference internal" href="separate_compilation.html#ghc-flag-idir-dir"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-i⟨dir⟩[:⟨dir⟩]*</span></code></a>, and <a class="reference internal" href="phases.html#ghc-flag-l-lib"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-l</span> <span class="pre">⟨lib⟩</span></code></a> in particular) will also
work, but some may not take effect until the next reload.</p>
</section>
<section id="setting-options-for-interactive-evaluation-only">
<span id="ghci-interactive-options"></span><span id="index-38"></span><h3><span class="section-number">3.8.3. </span>Setting options for interactive evaluation only<a class="headerlink" href="#setting-options-for-interactive-evaluation-only" title="Permalink to this heading">¶</a></h3>
<p>GHCi actually maintains <em>two</em> sets of options:</p>
<ul class="simple">
<li><p>The <em>loading options</em> apply when loading modules</p></li>
<li><p>The <em>interactive options</em> apply when evaluating expressions and
commands typed at the GHCi prompt.</p></li>
</ul>
<p>The <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a> command modifies both, but there is also a
<a class="reference internal" href="#ghci-cmd-seti"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:seti</span></code></a> command (for “set interactive”) that affects only the
interactive options set.</p>
<p>It is often useful to change the interactive options, without having
that option apply to loaded modules too. For example</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:seti -XMonoLocalBinds
</pre></div>
</div>
<p>It would be undesirable if <a class="reference internal" href="exts/let_generalisation.html#extension-MonoLocalBinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">MonoLocalBinds</span></code></a> were to apply to loaded
modules too: that might cause a compilation error, but more commonly it
will cause extra recompilation, because GHC will think that it needs to
recompile the module because the flags have changed.</p>
<p>If you are setting language options in your <code class="docutils literal notranslate"><span class="pre">.ghci</span></code> file, it is good
practice to use <a class="reference internal" href="#ghci-cmd-seti"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:seti</span></code></a> rather than <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a>, unless you
really do want them to apply to all modules you load in GHCi.</p>
<p>The two sets of options can be inspected using the <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a> and
<a class="reference internal" href="#ghci-cmd-seti"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:seti</span></code></a> commands respectively, with no arguments. For example, in a
clean GHCi session we might see something like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :seti
base language is: GHC2021
with the following modifiers:
  -XExtendedDefaultRules
  -XNoMonomorphismRestriction
GHCi-specific dynamic flag settings:
other dynamic, non-language, flag settings:
  -fexternal-dynamic-refs
  -fignore-optim-changes
  -fignore-hpc-changes
  -fimplicit-import-qualified
warning settings:
</pre></div>
</div>
<p>The two sets of options are initialised as follows. First, both sets of
options are initialised as described in <a class="reference internal" href="#ghci-dot-files"><span class="std std-ref">The .ghci and .haskeline files</span></a>. Then the
interactive options are modified as follows:</p>
<ul class="simple">
<li><p>The option <code class="docutils literal notranslate"><span class="pre">-XExtendedDefaultRules</span></code> is enabled, in order to apply
special defaulting rules to expressions typed at the prompt (see
<a class="reference internal" href="#extended-default-rules"><span class="std std-ref">Type defaulting in GHCi</span></a>).</p></li>
<li><p>The Monomorphism Restriction is disabled (see <a class="reference internal" href="exts/monomorphism.html#monomorphism"><span class="std std-ref">Switching off the Monomorphism Restriction</span></a>).</p></li>
</ul>
</section>
</section>
<section id="the-ghci-and-haskeline-files">
<span id="ghci-dot-files"></span><h2><span class="section-number">3.9. </span>The <code class="docutils literal notranslate"><span class="pre">.ghci</span></code> and <code class="docutils literal notranslate"><span class="pre">.haskeline</span></code> files<a class="headerlink" href="#the-ghci-and-haskeline-files" title="Permalink to this heading">¶</a></h2>
<section id="the-ghci-files">
<span id="dot-ghci-files"></span><h3><span class="section-number">3.9.1. </span>The <code class="docutils literal notranslate"><span class="pre">.ghci</span></code> files<a class="headerlink" href="#the-ghci-files" title="Permalink to this heading">¶</a></h3>
<p id="index-39">When it starts, unless the <a class="reference internal" href="#ghc-flag-ignore-dot-ghci"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ignore-dot-ghci</span></code></a> flag is given, GHCi
reads and executes commands from the following files, in this order, if
they exist:</p>
<ol class="arabic simple">
<li><p><code class="file docutils literal notranslate"><em><span class="pre">ghcappdata</span></em><span class="pre">/ghci.conf</span></code>, where ⟨ghcappdata⟩ depends on
your system, but is usually something like <code class="file docutils literal notranslate"><span class="pre">$HOME/.ghc</span></code> on
Unix or <code class="file docutils literal notranslate"><span class="pre">C:/Documents</span> <span class="pre">and</span> <span class="pre">Settings/user/Application</span>
<span class="pre">Data/ghc</span></code> on Windows.</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">$XDG_CONFIG_HOME/.ghci</span></code></p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">./.ghci</span></code></p></li>
</ol>
<p>The <code class="file docutils literal notranslate"><span class="pre">ghci.conf</span></code> file is most useful for turning on favourite options
(e.g. <code class="docutils literal notranslate"><span class="pre">:set</span> <span class="pre">+s</span></code>), and defining useful macros.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When setting language options in this file it is usually desirable to use
<a class="reference internal" href="#ghci-cmd-seti"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:seti</span></code></a> rather than <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a> (see <a class="reference internal" href="#ghci-interactive-options"><span class="std std-ref">Setting options for interactive evaluation only</span></a>).</p>
</div>
<p>Placing a <code class="file docutils literal notranslate"><span class="pre">.ghci</span></code> file in a directory with a Haskell project is a
useful way to set certain project-wide options so you don’t have to type
them every time you start GHCi: eg. if your project uses multi-parameter
type classes, scoped type variables, and CPP, and has source files in
three subdirectories A, B and C, you might put the following lines in
<code class="file docutils literal notranslate"><span class="pre">.ghci</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:set -XMultiParamTypeClasses -XScopedTypeVariables -cpp
:set -iA:B:C
</pre></div>
</div>
<p>(Note that strictly speaking the <a class="reference internal" href="separate_compilation.html#ghc-flag-i"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-i</span></code></a> flag is a static one, but in
fact it works to set it using <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a> like this. The changes won’t take
effect until the next <a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a>, though.)</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Sourcing untrusted <code class="file docutils literal notranslate"><span class="pre">./.ghci</span></code> files is a security risk.
They can contain arbitrary commands that will be executed as the
user.  Use <a class="reference internal" href="#ghci-cmd-set-local-config"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span> <span class="pre">local-config</span></code></a> to inhibit the
processing of <code class="file docutils literal notranslate"><span class="pre">./.ghci</span></code> files.</p>
</div>
<p>Once you have a library of GHCi macros, you may want to source them from
separate files, or you may want to source your <code class="docutils literal notranslate"><span class="pre">.ghci</span></code> file into your
running GHCi session while debugging it</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:def source readFile
</pre></div>
</div>
<p>With this macro defined in your <code class="docutils literal notranslate"><span class="pre">.ghci</span></code> file, you can use
<code class="docutils literal notranslate"><span class="pre">:source</span> <span class="pre">file</span></code> to read GHCi commands from <code class="docutils literal notranslate"><span class="pre">file</span></code>. You can find (and
contribute!-) other suggestions for <code class="docutils literal notranslate"><span class="pre">.ghci</span></code> files on this Haskell wiki
page: <a class="reference external" href="http://haskell.org/haskellwiki/GHC/GHCi">GHC/GHCi</a></p>
<p>Additionally, any files specified with <a class="reference internal" href="#ghc-flag-ghci-script"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ghci-script</span></code></a> flags will be
read after the standard files, allowing the use of custom .ghci files.</p>
<p>Two command-line options control whether the startup files files are
read:</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ignore-dot-ghci">
<span class="sig-name descname"><span class="pre">-ignore-dot-ghci</span></span><a class="headerlink" href="#ghc-flag-ignore-dot-ghci" title="Permalink to this definition">¶</a></dt>
<dd><p>Don’t read either <code class="file docutils literal notranslate"><span class="pre">./.ghci</span></code> or the other startup files when
starting up.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ghci-script">
<span class="sig-name descname"><span class="pre">-ghci-script</span></span><a class="headerlink" href="#ghc-flag-ghci-script" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a specific file after the usual startup files.  May be
specified repeatedly for multiple inputs.
<a class="reference internal" href="#ghc-flag-ignore-dot-ghci"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ignore-dot-ghci</span></code></a> does not apply to these files.</p>
</dd></dl>

<p>When defining GHCi macros, there is some important behavior you should
be aware of when names may conflict with built-in commands, especially
regarding tab completion.</p>
<p>For example, consider if you had a macro named <code class="docutils literal notranslate"><span class="pre">:time</span></code> and in the
shell, typed <code class="docutils literal notranslate"><span class="pre">:t</span> <span class="pre">3</span></code> — what should happen? The current algorithm we use
for completing commands is:</p>
<ol class="arabic simple">
<li><p>First, look up an exact match on the name from the defined macros.</p></li>
<li><p>Look for the exact match on the name in the built-in command list.</p></li>
<li><p>Do a prefix lookup on the list of built-in commands - if a built-in
command matches, but a macro is defined with the same name as the
built-in defined, pick the macro.</p></li>
<li><p>Do a prefix lookup on the list of built-in commands.</p></li>
<li><p>Do a prefix lookup on the list of defined macros.</p></li>
</ol>
<p>Here are some examples:</p>
<ol class="arabic">
<li><p>You have a macro <code class="docutils literal notranslate"><span class="pre">:time</span></code> and enter <code class="docutils literal notranslate"><span class="pre">:t</span> <span class="pre">3</span></code></p>
<p>You get <code class="docutils literal notranslate"><span class="pre">:type</span> <span class="pre">3</span></code></p>
</li>
<li><p>You have a macro <code class="docutils literal notranslate"><span class="pre">:type</span></code> and enter <code class="docutils literal notranslate"><span class="pre">:t</span> <span class="pre">3</span></code></p>
<p>You get <code class="docutils literal notranslate"><span class="pre">:type</span> <span class="pre">3</span></code> with your defined macro, not the builtin.</p>
</li>
<li><p>You have a macro <code class="docutils literal notranslate"><span class="pre">:time</span></code> and a macro <code class="docutils literal notranslate"><span class="pre">:type</span></code>, and enter <code class="docutils literal notranslate"><span class="pre">:t</span> <span class="pre">3</span></code></p>
<p>You get <code class="docutils literal notranslate"><span class="pre">:type</span> <span class="pre">3</span></code> with your defined macro.</p>
</li>
</ol>
<p>When giving priority to built-in commands, you can use
<a class="reference internal" href="#ghci-cmd-builtin-command"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">::</span> <span class="pre">⟨builtin-command⟩</span></code></a>, like <code class="docutils literal notranslate"><span class="pre">::type</span> <span class="pre">3</span></code>.</p>
</section>
<section id="the-haskeline-file">
<span id="dot-haskeline-file"></span><h3><span class="section-number">3.9.2. </span>The <code class="docutils literal notranslate"><span class="pre">.haskeline</span></code> file<a class="headerlink" href="#the-haskeline-file" title="Permalink to this heading">¶</a></h3>
<p id="index-40">GHCi uses <a class="reference external" href="https://hackage.haskell.org/package/haskeline">Haskeline</a> under
the hood. You can configure it to, among other
things, prune duplicates from GHCi history. See:
<a class="reference external" href="https://github.com/judah/haskeline/wiki/UserPreferences">Haskeline user preferences</a>.</p>
</section>
</section>
<section id="compiling-to-object-code-inside-ghci">
<span id="ghci-obj"></span><h2><span class="section-number">3.10. </span>Compiling to object code inside GHCi<a class="headerlink" href="#compiling-to-object-code-inside-ghci" title="Permalink to this heading">¶</a></h2>
<p>By default, GHCi compiles Haskell source code into byte-code that is
interpreted by the runtime system. GHCi can also compile Haskell code to
object code: to turn on this feature, use the <a class="reference internal" href="phases.html#ghc-flag-fobject-code"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fobject-code</span></code></a> flag
either on the command line or with <a class="reference internal" href="#ghci-cmd-set"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:set</span></code></a> (the option <a class="reference internal" href="phases.html#ghc-flag-fbyte-code"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fbyte-code</span></code></a>
restores byte-code compilation again). Compiling to object code takes
longer, but typically the code will execute 10-20 times faster than
byte-code.</p>
<p>Compiling to object code inside GHCi is particularly useful if you are
developing a compiled application, because the <a class="reference internal" href="#ghci-cmd-reload"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:reload</span></code></a> command
typically runs much faster than restarting GHC with <a class="reference internal" href="using.html#ghc-flag-make"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">--make</span></code></a> from the
command-line, because all the interface files are already cached in
memory.</p>
<p>There are disadvantages to compiling to object-code: you can’t set
breakpoints in object-code modules, for example. Only the exports of an
object-code module will be visible in GHCi, rather than all top-level
bindings as in interpreted modules.</p>
</section>
<section id="running-the-interpreter-in-a-separate-process">
<span id="external-interpreter"></span><h2><span class="section-number">3.11. </span>Running the interpreter in a separate process<a class="headerlink" href="#running-the-interpreter-in-a-separate-process" title="Permalink to this heading">¶</a></h2>
<p>Normally GHCi runs the interpreted code in the same process as GHC
itself, on top of the same RTS and sharing the same heap.  However, if
the flag <a class="reference internal" href="#ghc-flag-fexternal-interpreter"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fexternal-interpreter</span></code></a> is given, then GHC will spawn a
separate process for running interpreted code, and communicate with it
using messages over a pipe.</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fexternal-interpreter">
<span class="sig-name descname"><span class="pre">-fexternal-interpreter</span></span><a class="headerlink" href="#ghc-flag-fexternal-interpreter" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>8.0.1</p>
</dd>
</dl>
<p>Run interpreted code (for GHCi, Template Haskell, Quasi-quoting,
or Annotations) in a separate process.  The interpreter will run
in profiling mode if <a class="reference internal" href="profiling.html#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a> is in effect, and in
dynamically-linked mode if <a class="reference internal" href="phases.html#ghc-flag-dynamic"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-dynamic</span></code></a> is in effect.</p>
<p>There are a couple of caveats that will hopefully be removed in
the future: this option is currently not implemented on Windows
(it is a no-op), and the external interpreter does not support the
GHCi debugger, so breakpoints and single-stepping don’t work with
<a class="reference internal" href="#ghc-flag-fexternal-interpreter"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fexternal-interpreter</span></code></a>.</p>
<p>See also the <a class="reference internal" href="phases.html#ghc-flag-pgmi-cmd"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-pgmi</span> <span class="pre">⟨cmd⟩</span></code></a> (<a class="reference internal" href="phases.html#replacing-phases"><span class="std std-ref">Replacing the program for one or more phases</span></a>) and
<a class="reference internal" href="phases.html#ghc-flag-opti-option"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-opti</span> <span class="pre">⟨option⟩</span></code></a> (<a class="reference internal" href="phases.html#forcing-options-through"><span class="std std-ref">Forcing options to a particular phase</span></a>) flags.</p>
</dd></dl>

<p>Why might we want to do this?  The main reason is that the RTS running
the interpreted code can be a different flavour (profiling or
dynamically-linked) from GHC itself.  So for example:</p>
<ul class="simple">
<li><p>We can use the profiler to collect stack traces when using GHCi (see
<a class="reference internal" href="#ghci-stack-traces"><span class="std std-ref">Stack Traces in GHCi</span></a>).</p></li>
<li><p>When compiling Template Haskell code with <a class="reference internal" href="profiling.html#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a> we don’t need to
compile the modules without <a class="reference internal" href="profiling.html#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a> first (see <a class="reference internal" href="exts/template_haskell.html#th-profiling"><span class="std std-ref">Using Template Haskell with Profiling</span></a>)
because we can run the profiled object code in the interpreter.</p></li>
</ul>
<p>This feature is experimental in GHC 8.0.x, but it may become the
default in future releases.</p>
</section>
<section id="running-the-interpreter-on-a-different-host">
<span id="external-interpreter-proxy"></span><h2><span class="section-number">3.12. </span>Running the interpreter on a different host<a class="headerlink" href="#running-the-interpreter-on-a-different-host" title="Permalink to this heading">¶</a></h2>
<p>When using the flag <a class="reference internal" href="#ghc-flag-fexternal-interpreter"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fexternal-interpreter</span></code></a> GHC will
spawn and communicate with the separate process using pipes.  There
are scenarios (e.g. when cross compiling) where it is favourable to
have the communication happen over the network. GHC provides two
utilities for this, which can be found in the <code class="docutils literal notranslate"><span class="pre">utils</span></code> directory.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">remote-iserv</span></code> needs to be built with the cross compiler to be
executed on the remote host. Or in the case of using it on the
same host the stage2 compiler will do as well.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iserv-proxy</span></code> needs to be built on the build machine by the
build compiler.</p></li>
</ul>
<p>After starting <code class="docutils literal notranslate"><span class="pre">remote-iserv</span> <span class="pre">⟨tmp_dir⟩</span> <span class="pre">⟨port⟩</span></code> on the target and
providing it with a temporary folder (where it will copy the
necessary libraries to load to) and port it will listen for
the proxy to connect.</p>
<p>Providing <a class="reference internal" href="phases.html#ghc-flag-pgmi-cmd"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-pgmi</span> <span class="pre">⟨/path/to/iserv-proxy⟩</span></code></a> and
<a class="reference internal" href="phases.html#ghc-flag-opti-option"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-opti</span> <span class="pre">⟨slave-ip⟩</span> <span class="pre">-opti</span> <span class="pre">⟨slave-port⟩</span> <span class="pre">[-opti</span> <span class="pre">-v]</span></code></a> in
addition to <a class="reference internal" href="#ghc-flag-fexternal-interpreter"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fexternal-interpreter</span></code></a> will then make ghc go through the
proxy instead.</p>
<p>There are some limitations when using this. File and process IO
will be executed on the target. As such packages like <code class="docutils literal notranslate"><span class="pre">git-embed</span></code>,
<code class="docutils literal notranslate"><span class="pre">file-embed</span></code> and others might not behave as expected if the target
and host do not share the same filesystem.</p>
</section>
<section id="faq-and-things-to-watch-out-for">
<span id="ghci-faq"></span><h2><span class="section-number">3.13. </span>FAQ and Things To Watch Out For<a class="headerlink" href="#faq-and-things-to-watch-out-for" title="Permalink to this heading">¶</a></h2>
<dl class="simple">
<dt>The interpreter can’t load modules with foreign export declarations!</dt><dd><p>Unfortunately not. We haven’t implemented it yet. Please compile any
offending modules by hand before loading them into GHCi.</p>
</dd>
</dl>
<p><a class="reference internal" href="using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a> doesn’t work with GHCi!</p>
<blockquote>
<div><p id="index-41">For technical reasons, the bytecode compiler doesn’t interact well
with one of the optimisation passes, so we have disabled
optimisation when using the interpreter. This isn’t a great loss:
you’ll get a much bigger win by compiling the bits of your code that
need to go fast, rather than interpreting them with optimisation
turned on.</p>
</div></blockquote>
<p>Modules using unboxed tuples or sums will automatically enable <a class="reference internal" href="phases.html#ghc-flag-fobject-code"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fobject-code</span></code></a></p>
<blockquote>
<div><p id="index-42">The bytecode interpreter doesn’t support most uses of unboxed tuples or
sums, so GHCi will automatically compile these modules, and all modules
they depend on, to object code instead of bytecode.</p>
<p>GHCi checks for the presence of unboxed tuples and sums in a somewhat
conservative fashion: it simply checks to see if a module enables the
<a class="reference internal" href="exts/primitives.html#extension-UnboxedTuples"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnboxedTuples</span></code></a> or <a class="reference internal" href="exts/primitives.html#extension-UnboxedSums"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnboxedSums</span></code></a> language extensions.
It is not always the case that code which enables <a class="reference internal" href="exts/primitives.html#extension-UnboxedTuples"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnboxedTuples</span></code></a>
or <a class="reference internal" href="exts/primitives.html#extension-UnboxedSums"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnboxedSums</span></code></a> requires <a class="reference internal" href="phases.html#ghc-flag-fobject-code"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fobject-code</span></code></a>, so if you
<em>really</em> want to compile
<a class="reference internal" href="exts/primitives.html#extension-UnboxedTuples"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnboxedTuples</span></code></a>/<a class="reference internal" href="exts/primitives.html#extension-UnboxedSums"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnboxedSums</span></code></a>-using code to
bytecode, you can do so explicitly by enabling the <a class="reference internal" href="phases.html#ghc-flag-fbyte-code"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fbyte-code</span></code></a>
flag. If you do this, do note that bytecode interpreter will throw an error
if it encounters unboxed tuple/sum–related code that it cannot handle.</p>
<p>Incidentally, the previous point, that <a class="reference internal" href="using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a> is
incompatible with GHCi, is because the bytecode compiler can’t
deal with unboxed tuples or sums.</p>
</div></blockquote>
<dl>
<dt>Concurrent threads don’t carry on running when GHCi is waiting for input.</dt><dd><p>This should work, as long as your GHCi was built with the
<a class="reference internal" href="phases.html#ghc-flag-threaded"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-threaded</span></code></a> switch, which is the default. Consult whoever supplied
your GHCi installation.</p>
</dd>
<dt>After using <code class="docutils literal notranslate"><span class="pre">getContents</span></code>, I can’t use <code class="docutils literal notranslate"><span class="pre">stdin</span></code>, until I do <code class="docutils literal notranslate"><span class="pre">:load</span></code> or <code class="docutils literal notranslate"><span class="pre">:reload</span></code></dt><dd><p>This is the defined behaviour of <code class="docutils literal notranslate"><span class="pre">getContents</span></code>: it puts the stdin
Handle in a state known as semi-closed, wherein any further I/O
operations on it are forbidden. Because I/O state is retained
between computations, the semi-closed state persists until the next
<a class="reference internal" href="#ghci-cmd-load"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:load</span></code></a> or <a class="reference internal" href="#ghci-cmd-reload"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:reload</span></code></a> command.</p>
<p>You can make <code class="docutils literal notranslate"><span class="pre">stdin</span></code> reset itself after every evaluation by giving
GHCi the command <code class="docutils literal notranslate"><span class="pre">:set</span> <span class="pre">+r</span></code>. This works because <code class="docutils literal notranslate"><span class="pre">stdin</span></code> is just a
top-level expression that can be reverted to its unevaluated state
in the same way as any other top-level expression (CAF).</p>
</dd>
<dt>I can’t use <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> to interrupt computations in GHCi on Windows.</dt><dd><p>See <a class="reference internal" href="win32-dlls.html#ghci-windows"><span class="std std-ref">Running GHCi on Windows</span></a>.</p>
</dd>
<dt>The default buffering mode is different in GHCi to GHC.</dt><dd><p>In GHC, the stdout handle is line-buffered by default. However, in
GHCi we turn off the buffering on stdout, because this is normally
what you want in an interpreter: output appears as it is generated.</p>
<p>If you want line-buffered behaviour, as in GHC, you can start your
program thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">hSetBuffering</span><span class="w"> </span><span class="n">stdout</span><span class="w"> </span><span class="kt">LineBuffering</span><span class="p">;</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</dd>
</dl>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id14" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">5</a><span class="fn-bracket">]</span></span>
<p>Note that packages only contain compiled code, so debugging a package
requires finding its source and loading that directly.</p>
</aside>
<aside class="footnote brackets" id="id15" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">6</a><span class="fn-bracket">]</span></span>
<p>We originally provided bindings for all variables in scope, rather
than just the free variables of the expression, but found that this
affected performance considerably, hence the current restriction to
just the free variables.</p>
</aside>
</aside>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="runghc.html" class="btn btn-neutral float-right" title="4. Using runghc" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="9.2.4-notes.html" class="btn btn-neutral float-left" title="2.4. Version 9.2.4" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
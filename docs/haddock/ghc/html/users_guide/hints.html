

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>11. Hints &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML "></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="12. Other Haskell utility programs" href="utils.html" />
    <link rel="prev" title="10. What to do when something goes wrong" href="gone_wrong.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">5. Using GHC</a></li>
<li class="toctree-l1"><a class="reference internal" href="exts.html">6. Language extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">11. Hints</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#sooner-producing-a-program-more-quickly">11.1. Sooner: producing a program more quickly</a></li>
<li class="toctree-l2"><a class="reference internal" href="#faster-producing-a-program-that-runs-quicker">11.2. Faster: producing a program that runs quicker</a></li>
<li class="toctree-l2"><a class="reference internal" href="#smaller-producing-a-program-that-is-smaller">11.3. Smaller: producing a program that is smaller</a></li>
<li class="toctree-l2"><a class="reference internal" href="#thriftier-producing-a-program-that-gobbles-less-heap-space">11.4. Thriftier: producing a program that gobbles less heap space</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-inlining-via-optimisation-flags">11.5. Controlling inlining via optimisation flags.</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#unfolding-creation">11.5.1. Unfolding creation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inlining-decisions">11.5.2. Inlining decisions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inlining-generics">11.5.3. Inlining generics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#understanding-how-os-memory-usage-corresponds-to-live-data">11.6. Understanding how OS memory usage corresponds to live data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li><span class="section-number">11. </span>Hints</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/hints.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="hints">
<span id="sooner-faster-quicker"></span><h1><span class="section-number">11. </span>Hints<a class="headerlink" href="#hints" title="Permalink to this heading">¶</a></h1>
<p>Please advise us of other “helpful hints” that should go here!</p>
<section id="sooner-producing-a-program-more-quickly">
<span id="sooner"></span><h2><span class="section-number">11.1. </span>Sooner: producing a program more quickly<a class="headerlink" href="#sooner-producing-a-program-more-quickly" title="Permalink to this heading">¶</a></h2>
<dl id="index-0">
<dt>Don’t use <a class="reference internal" href="using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a> or (especially) <a class="reference internal" href="using-optimisation.html#ghc-flag-O2"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O2</span></code></a>:</dt><dd><p>By using them, you are telling GHC that you are willing to suffer
longer compilation times for better-quality code.</p>
<p>GHC is surprisingly zippy for normal compilations without <a class="reference internal" href="using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a>!</p>
</dd>
<dt>Use more memory:</dt><dd><p>Within reason, more memory for heap space means less garbage
collection for GHC, which means less compilation time. If you use
the <code class="docutils literal notranslate"><span class="pre">-Rghc-timing</span></code> option, you’ll get a garbage-collector report.
(Again, you can use the cheap-and-nasty <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-S</span> <span class="pre">-RTS</span></code> option to
send the GC stats straight to standard error.)</p>
<p id="index-1">If it says you’re using more than 20% of total time in garbage collecting,
then more memory might help: use the <code class="docutils literal notranslate"><span class="pre">-H⟨size⟩</span></code> (see
<a class="reference internal" href="runtime_control.html#rts-flag-H-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-H</span> <span class="pre">[⟨size⟩]</span></code></a>) option. Increasing the default allocation area
size used by the compiler’s RTS might also help: use the <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-A⟨size⟩</span>
<span class="pre">-RTS</span></code> option (see <a class="reference internal" href="runtime_control.html#rts-flag-A-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-A</span> <span class="pre">⟨size⟩</span></code></a>).</p>
<p id="index-2">If GHC persists in being a bad memory citizen, please report it as a
bug.</p>
</dd>
<dt>Don’t use too much memory!</dt><dd><p>As soon as GHC plus its “fellow citizens” (other processes on your
machine) start using more than the <em>real memory</em> on your machine,
and the machine starts “thrashing,” <em>the party is over</em>. Compile
times will be worse than terrible! Use something like the csh
builtin <strong class="command">time</strong> command to get a report on how many page faults
you’re getting.</p>
<p>If you don’t know what virtual memory, thrashing, and page faults
are, or you don’t know the memory configuration of your machine,
<em>don’t</em> try to be clever about memory use: you’ll just make your
life a misery (and for other people, too, probably).</p>
</dd>
<dt>Try to use local disks when linking:</dt><dd><p>Because Haskell objects and libraries tend to be large, it can take
many real seconds to slurp the bits to/from a remote filesystem.</p>
<p>It would be quite sensible to <em>compile</em> on a fast machine using
remotely-mounted disks; then <em>link</em> on a slow machine that had your
disks directly mounted.</p>
</dd>
<dt>Don’t derive/use <code class="docutils literal notranslate"><span class="pre">Read</span></code> unnecessarily:</dt><dd><p>It’s ugly and slow.</p>
</dd>
<dt>GHC compiles some program constructs slowly:</dt><dd><p>We’d rather you reported such behaviour as a bug, so that we can try
to correct it.</p>
<p id="index-3">To figure out which part of the compiler is badly behaved, the
<code class="docutils literal notranslate"><span class="pre">-v2</span></code> option is your friend.</p>
</dd>
</dl>
</section>
<section id="faster-producing-a-program-that-runs-quicker">
<span id="faster"></span><h2><span class="section-number">11.2. </span>Faster: producing a program that runs quicker<a class="headerlink" href="#faster-producing-a-program-that-runs-quicker" title="Permalink to this heading">¶</a></h2>
<p id="index-4">The key tool to use in making your Haskell program run faster are GHC’s
profiling facilities, described separately in <a class="reference internal" href="profiling.html#profiling"><span class="std std-ref">Profiling</span></a>. There is
<em>no substitute</em> for finding where your program’s time/space is <em>really</em>
going, as opposed to where you imagine it is going.</p>
<p>Another point to bear in mind: By far the best way to improve a
program’s performance <em>dramatically</em> is to use better algorithms. Once
profiling has thrown the spotlight on the guilty time-consumer(s), it
may be better to re-think your program than to try all the tweaks listed
below.</p>
<p>Another extremely efficient way to make your program snappy is to use
library code that has been Seriously Tuned By Someone Else. You <em>might</em>
be able to write a better quicksort than the one in <code class="docutils literal notranslate"><span class="pre">Data.List</span></code>, but
it will take you much longer than typing <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">Data.List</span></code>.</p>
<p>Please report any overly-slow GHC-compiled programs. Since GHC doesn’t
have any credible competition in the performance department these days
it’s hard to say what overly-slow means, so just use your judgement! Of
course, if a GHC compiled program runs slower than the same program
compiled with NHC or Hugs, then it’s definitely a bug.</p>
<dl>
<dt>Optimise, using <code class="docutils literal notranslate"><span class="pre">-O</span></code> or <code class="docutils literal notranslate"><span class="pre">-O2</span></code>:</dt><dd><p>This is the most basic way to make your program go faster.
Compilation time will be slower, especially with <code class="docutils literal notranslate"><span class="pre">-O2</span></code>.</p>
<p>At present, <code class="docutils literal notranslate"><span class="pre">-O2</span></code> is nearly indistinguishable from <code class="docutils literal notranslate"><span class="pre">-O</span></code>.</p>
</dd>
<dt>Compile via LLVM:</dt><dd><p>The <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM code generator</span></a> can sometimes do a far
better job at producing fast code than the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a>. This is not universal and depends on the code. Numeric
heavy code seems to show the best improvement when compiled via LLVM. You
can also experiment with passing specific flags to LLVM with the
<a class="reference internal" href="phases.html#ghc-flag-optlo-option"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-optlo</span> <span class="pre">⟨option⟩</span></code></a> and <a class="reference internal" href="phases.html#ghc-flag-optlc-option"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-optlc</span> <span class="pre">⟨option⟩</span></code></a> flags. Be
careful though as setting these flags stops GHC from setting its usual
flags for the LLVM optimiser and compiler.</p>
</dd>
<dt>Overloaded functions are not your friend:</dt><dd><p>Haskell’s overloading (using type classes) is elegant, neat, etc.,
etc., but it is death to performance if left to linger in an inner
loop. How can you squash it?</p>
</dd>
<dt>Give explicit type signatures:</dt><dd><p>Signatures are the basic trick; putting them on exported, top-level
functions is good software-engineering practice, anyway. (Tip: using
the <a class="reference internal" href="using-warnings.html#ghc-flag-Wmissing-signatures"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wmissing-signatures</span></code></a> option can
help enforce good signature-practice).</p>
<p>The automatic specialisation of overloaded functions (with <code class="docutils literal notranslate"><span class="pre">-O</span></code>)
should take care of overloaded local and/or unexported functions.</p>
</dd>
<dt>Use <code class="docutils literal notranslate"><span class="pre">SPECIALIZE</span></code> pragmas:</dt><dd><span class="target" id="index-5"></span><p id="index-6">Specialize the overloading on key functions in your program. See
<a class="reference internal" href="exts/pragmas.html#specialize-pragma"><span class="std std-ref">SPECIALIZE pragma</span></a> and <a class="reference internal" href="exts/pragmas.html#specialize-instance-pragma"><span class="std std-ref">SPECIALIZE instance pragma</span></a>.</p>
</dd>
<dt>“But how do I know where overloading is creeping in?”</dt><dd><p>A low-tech way: grep (search) your interface files for overloaded
type signatures. You can view interface files using the
<a class="reference internal" href="using.html#ghc-flag-show-iface-file"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">--show-iface</span> <span class="pre">⟨file⟩</span></code></a> option (see <a class="reference internal" href="separate_compilation.html#hi-options"><span class="std std-ref">Other options related to interface files</span></a>).</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ ghc --show-iface Foo.hi <span class="p">|</span> egrep <span class="s1">&#39;^[a-z].*::.*=&gt;&#39;</span>
</pre></div>
</div>
</dd>
<dt>Strict functions are your dear friends:</dt><dd><p>And, among other things, lazy pattern-matching is your enemy.</p>
<p>(If you don’t know what a “strict function” is, please consult a
functional-programming textbook. A sentence or two of explanation
here probably would not do much good.)</p>
<p>Consider these two code fragments:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Wibble</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w">  </span><span class="o">...</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">strict</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="kt">Wibble</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">lazy</span><span class="w"></span>
</pre></div>
</div>
<p>The former will result in far better code.</p>
<p>A less contrived example shows the use of <code class="docutils literal notranslate"><span class="pre">BangPatterns</span></code> on
<code class="docutils literal notranslate"><span class="pre">lets</span></code> to get stricter code (a good thing):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Wibble</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">unpackFoo</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="p">,</span><span class="w"> </span><span class="n">c2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">unpackFoo</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="w">        </span><span class="kr">in</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
</dd>
<dt>GHC loves single-constructor data-types:</dt><dd><p>It’s all the better if a function is strict in a single-constructor
type (a type with only one data-constructor; for example, tuples are
single-constructor types).</p>
</dd>
<dt>Newtypes are better than datatypes:</dt><dd><p>If your datatype has a single constructor with a single field, use a
<code class="docutils literal notranslate"><span class="pre">newtype</span></code> declaration instead of a <code class="docutils literal notranslate"><span class="pre">data</span></code> declaration. The
<code class="docutils literal notranslate"><span class="pre">newtype</span></code> will be optimised away in most cases.</p>
</dd>
<dt>“How do I find out a function’s strictness?”</dt><dd><p>Don’t guess—look it up.</p>
<p>Look for your function in the interface file, then for the third
field in the pragma; it should say <code class="docutils literal notranslate"><span class="pre">Strictness:</span> <span class="pre">⟨string⟩</span></code>. The
⟨string⟩ gives the strictness of the function’s arguments: see
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/demand">the GHC Commentary</a>
for a description of the strictness notation.</p>
<p>For an “unpackable” <code class="docutils literal notranslate"><span class="pre">U(...)</span></code> argument, the info inside tells the
strictness of its components. So, if the argument is a pair, and it
says <code class="docutils literal notranslate"><span class="pre">U(AU(LSS))</span></code>, that means “the first component of the pair
isn’t used; the second component is itself unpackable, with three
components (lazy in the first, strict in the second \&amp; third).”</p>
<p>If the function isn’t exported, just compile with the extra flag
<a class="reference internal" href="debugging.html#ghc-flag-ddump-simpl"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-simpl</span></code></a>; next to the signature for any binder, it will
print the self-same pragmatic information as would be put in an
interface file. (Besides, Core syntax is fun to look at!)</p>
</dd>
<dt>Force key functions to be <code class="docutils literal notranslate"><span class="pre">INLINE</span></code>d (esp. monads):</dt><dd><p>Placing <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> pragmas on certain functions that are used a lot
can have a dramatic effect. See <a class="reference internal" href="exts/pragmas.html#inline-pragma"><span class="std std-ref">INLINE pragma</span></a>.</p>
</dd>
<dt>Explicit <code class="docutils literal notranslate"><span class="pre">export</span></code> list:</dt><dd><p>If you do not have an explicit export list in a module, GHC must
assume that everything in that module will be exported. This has
various pessimising effects. For example, if a bit of code is
actually <em>unused</em> (perhaps because of unfolding effects), GHC will
not be able to throw it away, because it is exported and some other
module may be relying on its existence.</p>
<p>GHC can be quite a bit more aggressive with pieces of code if it
knows they are not exported.</p>
</dd>
<dt>Look at the Core syntax!</dt><dd><p>(The form in which GHC manipulates your code.) Just run your
compilation with <a class="reference internal" href="debugging.html#ghc-flag-ddump-simpl"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-simpl</span></code></a> (don’t forget the <a class="reference internal" href="using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a>).</p>
<p>If profiling has pointed the finger at particular functions, look at
their Core code. <code class="docutils literal notranslate"><span class="pre">lets</span></code> are bad, <code class="docutils literal notranslate"><span class="pre">cases</span></code> are good, dictionaries
(<code class="docutils literal notranslate"><span class="pre">d.⟨Class⟩.⟨Unique⟩</span></code>) [or anything overloading-ish] are bad,
nested lambdas are bad, explicit data constructors are good,
primitive operations (e.g., <code class="docutils literal notranslate"><span class="pre">eqInt#</span></code>) are good, …</p>
</dd>
<dt>Use strictness annotations:</dt><dd><p>Putting a strictness annotation (<code class="docutils literal notranslate"><span class="pre">!</span></code>) on a constructor field helps
in two ways: it adds strictness to the program, which gives the
strictness analyser more to work with, and it might help to reduce
space leaks.</p>
<p>It can also help in a third way: when used with
<a class="reference internal" href="using-optimisation.html#ghc-flag-funbox-strict-fields"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funbox-strict-fields</span></code></a> (see <a class="reference internal" href="using-optimisation.html#options-f"><span class="std std-ref">-f*: platform-independent flags</span></a>), a strict field can
be unpacked or unboxed in the constructor, and one or more levels of
indirection may be removed. Unpacking only happens for
single-constructor datatypes (<code class="docutils literal notranslate"><span class="pre">Int</span></code> is a good candidate, for
example).</p>
<p>Using <a class="reference internal" href="using-optimisation.html#ghc-flag-funbox-strict-fields"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funbox-strict-fields</span></code></a> is only really a good idea in
conjunction with <a class="reference internal" href="using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a>, because otherwise the extra packing and
unpacking won’t be optimised away. In fact, it is possible that
<a class="reference internal" href="using-optimisation.html#ghc-flag-funbox-strict-fields"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funbox-strict-fields</span></code></a> may worsen performance even <em>with</em> <a class="reference internal" href="using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a>,
but this is unlikely (let us know if it happens to you).</p>
</dd>
<dt>Use unboxed types (a GHC extension):</dt><dd><p>When you are <em>really</em> desperate for speed, and you want to get right
down to the “raw bits.” Please see <a class="reference internal" href="exts/primitives.html#glasgow-unboxed"><span class="std std-ref">Unboxed types</span></a> for some
information about using unboxed types.</p>
<p>Before resorting to explicit unboxed types, try using strict
constructor fields and <a class="reference internal" href="using-optimisation.html#ghc-flag-funbox-strict-fields"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funbox-strict-fields</span></code></a> first (see above).
That way, your code stays portable.</p>
</dd>
<dt>Use <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span></code> (a GHC extension) to plug into fast libraries:</dt><dd><p>This may take real work, but… There exist piles of massively-tuned
library code, and the best thing is not to compete with it, but link
with it.</p>
<p><a class="reference internal" href="exts/ffi.html#ffi"><span class="std std-ref">Foreign function interface (FFI)</span></a> describes the foreign function interface.</p>
</dd>
<dt>Don’t use <code class="docutils literal notranslate"><span class="pre">Float</span></code>s:</dt><dd><p>If you’re using <code class="docutils literal notranslate"><span class="pre">Complex</span></code>, definitely use <code class="docutils literal notranslate"><span class="pre">Complex</span> <span class="pre">Double</span></code>
rather than <code class="docutils literal notranslate"><span class="pre">Complex</span> <span class="pre">Float</span></code> (the former is specialised heavily,
but the latter isn’t).</p>
<p><code class="docutils literal notranslate"><span class="pre">Floats</span></code> (probably 32-bits) are almost always a bad idea, anyway,
unless you Really Know What You Are Doing. Use <code class="docutils literal notranslate"><span class="pre">Double</span></code>s.
There’s rarely a speed disadvantage—modern machines will use the
same floating-point unit for both. With <code class="docutils literal notranslate"><span class="pre">Double</span></code>s, you are much
less likely to hang yourself with numerical errors.</p>
<p>One time when <code class="docutils literal notranslate"><span class="pre">Float</span></code> might be a good idea is if you have a <em>lot</em>
of them, say a giant array of <code class="docutils literal notranslate"><span class="pre">Float</span></code>s. They take up half the
space in the heap compared to <code class="docutils literal notranslate"><span class="pre">Doubles</span></code>. However, this isn’t true
on a 64-bit machine.</p>
</dd>
<dt>Use unboxed arrays (<code class="docutils literal notranslate"><span class="pre">UArray</span></code>)</dt><dd><p>GHC supports arrays of unboxed elements, for several basic
arithmetic element types including <code class="docutils literal notranslate"><span class="pre">Int</span></code> and <code class="docutils literal notranslate"><span class="pre">Char</span></code>: see the
<a class="reference external" href="./../libraries/array-0.5.4.0/Data-Array-Unboxed.html">Data.Array.Unboxed</a> library for details. These arrays are
likely to be much faster than using standard Haskell 98 arrays from the
<a class="reference external" href="./../libraries/array-0.5.4.0/Data-Array.html">Data.Array</a> library.</p>
</dd>
<dt>Use a bigger heap!</dt><dd><p>If your program’s GC stats (<a class="reference internal" href="runtime_control.html#rts-flag-S-file"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-S</span> <span class="pre">[⟨file⟩]</span></code></a> RTS option) indicate
that it’s doing lots of garbage-collection (say, more than 20% of execution
time), more memory might help — with the <a class="reference internal" href="runtime_control.html#rts-flag-H-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-H</span> <span class="pre">[⟨size⟩]</span></code></a> or
<a class="reference internal" href="runtime_control.html#rts-flag-A-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-A</span> <span class="pre">⟨size⟩</span></code></a> RTS options (see <a class="reference internal" href="runtime_control.html#rts-options-gc"><span class="std std-ref">RTS options to control the garbage collector</span></a>). As a rule
of thumb, try setting <a class="reference internal" href="runtime_control.html#rts-flag-H-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-H</span> <span class="pre">[⟨size⟩]</span></code></a> to the amount of memory
you’re willing to let your process consume, or perhaps try passing
<a class="reference internal" href="runtime_control.html#rts-flag-H-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-H</span> <span class="pre">[⟨size⟩]</span></code></a> without any argument to let GHC calculate a value
based on the amount of live data.</p>
</dd>
<dt>Compact your data:</dt><dd><p>The <a class="reference external" href="./../libraries/ghc-compact-0.1.0.0/GHC-Compact.html">GHC.Compact</a> module
provides a way to make garbage collection more efficient for
long-lived data structures. Compacting a data structure collects
the objects together in memory, where they are treated as a single
object by the garbage collector and not traversed individually.</p>
</dd>
</dl>
</section>
<section id="smaller-producing-a-program-that-is-smaller">
<span id="smaller"></span><h2><span class="section-number">11.3. </span>Smaller: producing a program that is smaller<a class="headerlink" href="#smaller-producing-a-program-that-is-smaller" title="Permalink to this heading">¶</a></h2>
<p id="index-7">Decrease the “go-for-it” threshold for unfolding smallish expressions.
Give a <a class="reference internal" href="using-optimisation.html#ghc-flag-funfolding-use-threshold-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-use-threshold=0</span></code></a>
option for the extreme case. (“Only unfoldings with zero cost should proceed.”)
Warning: except in certain specialised cases (like Happy parsers) this is likely
to actually <em>increase</em> the size of your program, because unfolding generally
enables extra simplifying optimisations to be performed.</p>
<p>Avoid <a class="reference external" href="./../libraries/base-4.16.3.0/Prelude.html#t:Read">Prelude.Read</a>.</p>
<p>Use <strong class="command">strip</strong> on your executables.</p>
</section>
<section id="thriftier-producing-a-program-that-gobbles-less-heap-space">
<span id="thriftier"></span><h2><span class="section-number">11.4. </span>Thriftier: producing a program that gobbles less heap space<a class="headerlink" href="#thriftier-producing-a-program-that-gobbles-less-heap-space" title="Permalink to this heading">¶</a></h2>
<p id="index-8">“I think I have a space leak…”</p>
<p>Re-run your program with <a class="reference internal" href="runtime_control.html#rts-flag-S-file"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-S</span></code></a>, and remove all
doubt! (You’ll see the heap usage get bigger and bigger…) (Hmmm… this might
be even easier with the <a class="reference internal" href="runtime_control.html#rts-flag-G-generations"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-G1</span></code></a> RTS option; so…
<code class="docutils literal notranslate"><span class="pre">./a.out</span> <span class="pre">+RTS</span> <span class="pre">-S</span> <span class="pre">-G1</span></code>)</p>
<p id="index-9">Once again, the profiling facilities (<a class="reference internal" href="profiling.html#profiling"><span class="std std-ref">Profiling</span></a>) are the basic
tool for demystifying the space behaviour of your program.</p>
<p>Strict functions are good for space usage, as they are for time, as
discussed in the previous section. Strict functions get right down to
business, rather than filling up the heap with closures (the system’s
notes to itself about how to evaluate something, should it eventually be
required).</p>
</section>
<section id="controlling-inlining-via-optimisation-flags">
<span id="control-inlining"></span><h2><span class="section-number">11.5. </span>Controlling inlining via optimisation flags.<a class="headerlink" href="#controlling-inlining-via-optimisation-flags" title="Permalink to this heading">¶</a></h2>
<p id="index-10">Inlining is one of the major optimizations GHC performs. Partially
because inlining often allows other optimizations to be triggered.
Sadly this is also a double edged sword. While inlining can often
cut through runtime overheads this usually comes at the cost
of not just program size, but also compiler performance. In
extreme cases making it impossible to compile certain code.</p>
<p>For this reason GHC offers various ways to tune inlining
behaviour.</p>
<section id="unfolding-creation">
<h3><span class="section-number">11.5.1. </span>Unfolding creation<a class="headerlink" href="#unfolding-creation" title="Permalink to this heading">¶</a></h3>
<p>In order for a function from a different module to be inlined
GHC requires the functions unfolding. The following flags can
be used to control unfolding creation. Making their creation more
or less likely:</p>
<ul class="simple">
<li><p><a class="reference internal" href="using-optimisation.html#ghc-flag-fexpose-all-unfoldings"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fexpose-all-unfoldings</span></code></a></p></li>
<li><p><a class="reference internal" href="using-optimisation.html#ghc-flag-funfolding-creation-threshold-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-creation-threshold=⟨n⟩</span></code></a></p></li>
</ul>
</section>
<section id="inlining-decisions">
<h3><span class="section-number">11.5.2. </span>Inlining decisions<a class="headerlink" href="#inlining-decisions" title="Permalink to this heading">¶</a></h3>
<p>If a unfolding is available the following flags can impact GHC’s
decision about inlining a specific binding.</p>
<ul class="simple">
<li><p><a class="reference internal" href="using-optimisation.html#ghc-flag-funfolding-use-threshold-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-use-threshold=⟨n⟩</span></code></a></p></li>
<li><p><a class="reference internal" href="using-optimisation.html#ghc-flag-funfolding-case-threshold-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-case-threshold=⟨n⟩</span></code></a></p></li>
<li><p><a class="reference internal" href="using-optimisation.html#ghc-flag-funfolding-case-scaling-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-case-scaling=⟨n⟩</span></code></a></p></li>
<li><p><a class="reference internal" href="using-optimisation.html#ghc-flag-funfolding-dict-discount-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-dict-discount=⟨n⟩</span></code></a></p></li>
<li><p><a class="reference internal" href="using-optimisation.html#ghc-flag-funfolding-fun-discount-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-fun-discount=⟨n⟩</span></code></a></p></li>
</ul>
<p>Should the simplifier run out of ticks because of a inlining loop
users are encouraged to try decreasing <a class="reference internal" href="using-optimisation.html#ghc-flag-funfolding-case-threshold-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-case-threshold=⟨n⟩</span></code></a>
or <a class="reference internal" href="using-optimisation.html#ghc-flag-funfolding-case-scaling-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-case-scaling=⟨n⟩</span></code></a> to limit inlining into
deeply nested expressions while allowing a higher tick factor.</p>
<p>The defaults of these are tuned such that we don’t expect regressions for most
user programs. Using a <a class="reference internal" href="using-optimisation.html#ghc-flag-funfolding-case-threshold-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-case-threshold=⟨n⟩</span></code></a> of 1-2 with a
<a class="reference internal" href="using-optimisation.html#ghc-flag-funfolding-case-scaling-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-case-scaling=⟨n⟩</span></code></a> of 15-25 can cause usually small runtime
regressions but will prevent most inlining loops from getting out of control.</p>
<p>In extreme cases lowering scaling and treshold further can be useful, but at that
point it’s very likely that beneficial inlining is prevented as well resulting
in significant runtime regressions.</p>
<p>In such cases it’s recommended to move the problematic piece of code into it’s own
module and changing inline parameters for the offending module only.</p>
</section>
<section id="inlining-generics">
<h3><span class="section-number">11.5.3. </span>Inlining generics<a class="headerlink" href="#inlining-generics" title="Permalink to this heading">¶</a></h3>
<p>There are also flags specific to the inlining of generics:</p>
<ul class="simple">
<li><p><a class="reference internal" href="using-optimisation.html#ghc-flag-finline-generics"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-finline-generics</span></code></a></p></li>
<li><p><a class="reference internal" href="using-optimisation.html#ghc-flag-finline-generics-aggressively"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-finline-generics-aggressively</span></code></a></p></li>
</ul>
</section>
</section>
<section id="understanding-how-os-memory-usage-corresponds-to-live-data">
<span id="hints-os-memory"></span><h2><span class="section-number">11.6. </span>Understanding how OS memory usage corresponds to live data<a class="headerlink" href="#understanding-how-os-memory-usage-corresponds-to-live-data" title="Permalink to this heading">¶</a></h2>
<p>A confusing aspect about the RTS is the sometimes big difference between
OS reported memory usage and
the amount of live data reported by heap profiling or <code class="docutils literal notranslate"><span class="pre">GHC.Stats</span></code>.</p>
<p>There are two main factors which determine OS memory usage.</p>
<p>Firstly the collection strategy used by the oldest generation. By default a copying
strategy is used which requires at least 2 times the amount of currently live
data in order to perform a major collection. For example, if your program’s live data
is 1G then you would expect the OS to report at minimum 2G.</p>
<p>If instead you are using the compacting (<a class="reference internal" href="runtime_control.html#rts-flag-c"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-c</span></code></a>) or nonmoving (<a class="reference internal" href="runtime_control.html#rts-flag-xn"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-xn</span></code></a>) strategies
for the
oldest generation then less overhead is required as the strategy immediately
reuses already allocated memory by overwriting. For a program with heap size
1G then you might expect the OS to report at minimum a small percentage above 1G.</p>
<p>Secondly, after doing some allocation GHC is quite reluctant to return
the memory to the OS. This is because after performing a major collection the program might
still be allocating a lot and it costs to have to request
more memory. Therefore the RTS keeps an extra amount to reuse which
depends on the <a class="reference internal" href="runtime_control.html#rts-flag-F-factor"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-F</span> <span class="pre">⟨factor⟩</span></code></a> option. By default
the RTS will keep up to <code class="docutils literal notranslate"><span class="pre">(2</span> <span class="pre">+</span> <span class="pre">F)</span> <span class="pre">*</span> <span class="pre">live_bytes</span></code> after performing a major collection due to
exhausting the available heap. The default value is <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">=</span> <span class="pre">2</span></code> so you
can see OS memory usage reported to be as high as 4 times the amount used by your
program.</p>
<p>Without further intervention, once your program has topped out at this high
threshold, no more memory would be returned to the OS so memory usage would always remain
at 4 times the live data. If you had a server with 1.5G live data, then if there was a memory
spike up to 6G for a short period, then OS reported memory would never dip below 6G. This
is what happened before GHC 9.2. In GHC 9.2 memory is gradually returned to the OS so OS memory
usage returns closer to the theoretical minimums.</p>
<p>The <a class="reference internal" href="runtime_control.html#rts-flag-Fd-factor"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-Fd</span> <span class="pre">⟨factor⟩</span></code></a> option controls the rate at which memory is returned to
the OS. On consecutive major collections which are not triggered by heap overflows, a
counter (<code class="docutils literal notranslate"><span class="pre">t</span></code>) is increased and the <code class="docutils literal notranslate"><span class="pre">F</span></code> factor is inversly scaled according to the
value of <code class="docutils literal notranslate"><span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">Fd</span></code>. The factor is scaled by the equation:</p>
<div class="math notranslate nohighlight">
\[\texttt{F}' = \texttt{F} \times {2 ^ \frac{- \texttt{t}}{\texttt{Fd}}}\]</div>
<p>By default <code class="docutils literal notranslate"><span class="pre">Fd</span> <span class="pre">=</span> <span class="pre">4</span></code>, increasing <code class="docutils literal notranslate"><span class="pre">Fd</span></code> decreases the rate memory is returned.</p>
<p>Major collections which are not triggered by heap overflows arise mainly in two ways.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Idle collections (controlled by <a class="reference internal" href="runtime_control.html#rts-flag-I-seconds"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-I</span>&#160; <span class="pre">⟨seconds⟩</span></code></a>)</p></li>
<li><p>Explicit trigger using <code class="docutils literal notranslate"><span class="pre">performMajorGC</span></code>.</p></li>
</ol>
</div></blockquote>
<p>For example, idle collections happen by default after 0.3 seconds of inactivity.
If you are running your application and have also set <code class="docutils literal notranslate"><span class="pre">-Iw30</span></code>, so that the minimum
period between idle GCs is 30 seconds, then say you do a small amount of work every 5 seconds,
there will be about 10 idle collections about 5 minutes. This number of consecutive
idle collections will scale the <code class="docutils literal notranslate"><span class="pre">F</span></code> factor as follows:</p>
<div class="math notranslate nohighlight">
\[\texttt{F}' = 2 \times {2^{\frac{-10}{4}}} \approx 0.35\]</div>
<p>and hence we will only retain <code class="docutils literal notranslate"><span class="pre">(0.35</span> <span class="pre">+</span> <span class="pre">2)</span> <span class="pre">*</span> <span class="pre">live_bytes</span></code>
rather than the original 4 times. If you want less frequent idle collections then
you should also decrease <code class="docutils literal notranslate"><span class="pre">Fd</span></code> so that more memory is returned each time
a collection takes place.</p>
<p>If you set <code class="docutils literal notranslate"><span class="pre">-Fd0</span></code> then GHC will not attempt to return memory, which corresponds
with the behaviour from releases prior to 9.2. You probably don’t want to do this as
unless you have idle periods in your program the behaviour will be similar anyway.
If you want to retain a specific amount of memory then it’s better to set <code class="docutils literal notranslate"><span class="pre">-H1G</span></code>
in order to communicate that you are happy with a heap size of <code class="docutils literal notranslate"><span class="pre">1G</span></code>. If you do this
then OS reported memory will never decrease below this amount if it ever reaches this
threshold.</p>
<p>The collecting strategy also affects the fragmentation of the heap and hence how easy
it is to return memory to a theoretical baseline. Memory is allocated firstly
in the unit of megablocks which is then further divided into blocks. Block-level
fragmentation is how much unused space within the allocated megablocks there is.
In a fragmented heap there will be many megablocks which are only partially full.</p>
<p>In theory the compacting
strategy has a lower memory baseline but practically it can be hard to reach the
baseline due to how compacting never defragments. On the other hand, the copying
collecting has a higher theoretical baseline but we can often get very close to
it because the act of copying leads to lower fragmentation.</p>
<p>There are some other flags which affect the amount of retained memory as well.
Setting the maximum heap size using <a class="reference internal" href="runtime_control.html#rts-flag-M-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-M</span> <span class="pre">⟨size⟩</span></code></a> will make sure we don’t try
and retain more memory than the maximum size and explicitly setting <a class="reference internal" href="runtime_control.html#rts-flag-H-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-H</span> <span class="pre">[⟨size⟩]</span></code></a>
will mean that we will always try and retain at least <code class="docutils literal notranslate"><span class="pre">H</span></code> bytes irrespective of
the amount of live data.</p>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="utils.html" class="btn btn-neutral float-right" title="12. Other Haskell utility programs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="gone_wrong.html" class="btn btn-neutral float-left" title="10. What to do when something goes wrong" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>5.7. Running a compiled program &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5.8. Filenames and separate compilation" href="separate_compilation.html" />
    <link rel="prev" title="5.6. Flag reference" href="flags.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="runghc.html">4. Using runghc</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="usage.html">5. Using GHC</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="using.html">5.1. Using GHC</a></li>
<li class="toctree-l2"><a class="reference internal" href="using-warnings.html">5.2. Warnings and sanity-checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="using-optimisation.html">5.3. Optimisation (code improvement)</a></li>
<li class="toctree-l2"><a class="reference internal" href="using-concurrent.html">5.4. Using Concurrent Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="using-concurrent.html#using-smp-parallelism">5.5. Using SMP parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="flags.html">5.6. Flag reference</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5.7. Running a compiled program</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#setting-rts-options">5.7.1. Setting RTS options</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#setting-rts-options-on-the-command-line">5.7.1.1. Setting RTS options on the command line</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setting-rts-options-at-compile-time">5.7.1.2. Setting RTS options at compile time</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setting-rts-options-with-the-ghcrts-environment-variable">5.7.1.3. Setting RTS options with the <code class="docutils literal notranslate"><span class="pre">GHCRTS</span></code> environment variable</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hooks-to-change-rts-behaviour">5.7.1.4. “Hooks” to change RTS behaviour</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#miscellaneous-rts-options">5.7.2. Miscellaneous RTS options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rts-options-to-control-the-garbage-collector">5.7.3. RTS options to control the garbage collector</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rts-options-to-produce-runtime-statistics">5.7.4. RTS options to produce runtime statistics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rts-options-for-concurrency-and-parallelism">5.7.5. RTS options for concurrency and parallelism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rts-options-for-profiling">5.7.6. RTS options for profiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tracing">5.7.7. Tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rts-options-for-hackers-debuggers-and-over-interested-souls">5.7.8. RTS options for hackers, debuggers, and over-interested souls</a></li>
<li class="toctree-l3"><a class="reference internal" href="#getting-information-about-the-rts">5.7.9. Getting information about the RTS</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="separate_compilation.html">5.8. Filenames and separate compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html">5.9. Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="codegens.html">5.10. GHC Backends</a></li>
<li class="toctree-l2"><a class="reference internal" href="phases.html">5.11. Options related to a particular phase</a></li>
<li class="toctree-l2"><a class="reference internal" href="shared_libs.html">5.12. Using shared libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging.html">5.13. Debugging the compiler</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="exts.html">6. Language extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="usage.html"><span class="section-number">5. </span>Using GHC</a> &raquo;</li>
        
      <li><span class="section-number">5.7. </span>Running a compiled program</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/runtime_control.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="running-a-compiled-program">
<span id="runtime-control"></span><h1><span class="section-number">5.7. </span>Running a compiled program<a class="headerlink" href="#running-a-compiled-program" title="Permalink to this heading">¶</a></h1>
<p id="index-0">To make an executable program, the GHC system compiles your code and
then links it with a non-trivial runtime system (RTS), which handles
storage management, thread scheduling, profiling, and so on.</p>
<p>The RTS has a lot of options to control its behaviour. For example, you
can change the context-switch interval, the default size of the heap,
and enable heap profiling. These options can be passed to the runtime
system in a variety of different ways; the next section
(<a class="reference internal" href="#setting-rts-options"><span class="std std-ref">Setting RTS options</span></a>) describes the various methods, and the
following sections describe the RTS options themselves.</p>
<section id="setting-rts-options">
<span id="id1"></span><h2><span class="section-number">5.7.1. </span>Setting RTS options<a class="headerlink" href="#setting-rts-options" title="Permalink to this heading">¶</a></h2>
<p id="index-1">There are four ways to set RTS options:</p>
<ul class="simple">
<li><p>on the command line between <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">...</span> <span class="pre">-RTS</span></code>, when running the
program (<a class="reference internal" href="#rts-opts-cmdline"><span class="std std-ref">Setting RTS options on the command line</span></a>)</p></li>
<li><p>at compile-time, using <a class="reference internal" href="phases.html#ghc-flag-with-rtsopts-opts"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-with-rtsopts=⟨opts⟩</span></code></a>
(<a class="reference internal" href="#rts-opts-compile-time"><span class="std std-ref">Setting RTS options at compile time</span></a>)</p></li>
<li><p>with the environment variable <span class="target" id="index-2"></span><a class="reference internal" href="#envvar-GHCRTS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">GHCRTS</span></code></a>
(<a class="reference internal" href="#rts-options-environment"><span class="std std-ref">Setting RTS options with the GHCRTS environment variable</span></a>)</p></li>
<li><p>by overriding “hooks” in the runtime system (<a class="reference internal" href="#rts-hooks"><span class="std std-ref">“Hooks” to change RTS behaviour</span></a>)</p></li>
</ul>
<section id="setting-rts-options-on-the-command-line">
<span id="rts-opts-cmdline"></span><h3><span class="section-number">5.7.1.1. </span>Setting RTS options on the command line<a class="headerlink" href="#setting-rts-options-on-the-command-line" title="Permalink to this heading">¶</a></h3>
<p id="index-3">If you set the <a class="reference internal" href="phases.html#ghc-flag-rtsopts-none-some-all-ignore-ignoreAll"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]</span></code></a> flag
appropriately when linking (see <a class="reference internal" href="phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a>), you can give RTS
options on the command line when running your program.</p>
<p>When your Haskell program starts up, the RTS extracts command-line
arguments bracketed between <code class="docutils literal notranslate"><span class="pre">+RTS</span></code> and <code class="docutils literal notranslate"><span class="pre">-RTS</span></code> as its own. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ghc prog.hs -rtsopts
[1 of 1] Compiling Main             ( prog.hs, prog.o )
Linking prog ...
$ ./prog -f +RTS -H32m -S -RTS -h foo bar
</pre></div>
</div>
<p>The RTS will snaffle <code class="docutils literal notranslate"><span class="pre">-H32m</span> <span class="pre">-S</span></code> for itself, and the remaining
arguments <code class="docutils literal notranslate"><span class="pre">-f</span> <span class="pre">-h</span> <span class="pre">foo</span> <span class="pre">bar</span></code> will be available to your program if/when it
calls <code class="docutils literal notranslate"><span class="pre">System.Environment.getArgs</span></code>.</p>
<p>No <code class="docutils literal notranslate"><span class="pre">-RTS</span></code> option is required if the runtime-system options extend to
the end of the command line, as in this example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% hls -ltr /usr/etc +RTS -A5m
</pre></div>
</div>
<p>If you absolutely positively want all the rest of the options in a
command line to go to the program (and not the RTS), use a
<code class="docutils literal notranslate"><span class="pre">--RTS</span></code> or <code class="docutils literal notranslate"><span class="pre">--</span></code>.  The difference is that <code class="docutils literal notranslate"><span class="pre">--RTS</span></code> will not be passed to
the program, while <code class="docutils literal notranslate"><span class="pre">--</span></code> will.</p>
<p>As always, for RTS options that take ⟨size⟩s: If the last character of
⟨size⟩ is a K or k, multiply by 1024; if an M or m, by 1024*1024; if a G
or G, by 1024^3. (And any wraparound in the counters is <em>your</em>
fault!)</p>
<p>Giving a <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-?</span></code> RTS option will print out the RTS
options actually available in your program (which vary, depending on how
you compiled).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since GHC is itself compiled by GHC, you can change RTS options in
the compiler using the normal <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">...</span> <span class="pre">-RTS</span></code> combination. For instance, to set
the maximum heap size for a compilation to 128M, you would add
<code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-M128m</span> <span class="pre">-RTS</span></code> to the command line.</p>
</div>
</section>
<section id="setting-rts-options-at-compile-time">
<span id="rts-opts-compile-time"></span><h3><span class="section-number">5.7.1.2. </span>Setting RTS options at compile time<a class="headerlink" href="#setting-rts-options-at-compile-time" title="Permalink to this heading">¶</a></h3>
<p>GHC lets you change the default RTS options for a program at compile
time, using the <code class="docutils literal notranslate"><span class="pre">-with-rtsopts</span></code> flag (<a class="reference internal" href="phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a>). A common
use for this is to give your program a default heap and/or stack size
that is greater than the default. For example, to set <code class="docutils literal notranslate"><span class="pre">-H128m</span> <span class="pre">-K64m</span></code>,
link with <code class="docutils literal notranslate"><span class="pre">-with-rtsopts=&quot;-H128m</span> <span class="pre">-K64m&quot;</span></code>.</p>
</section>
<section id="setting-rts-options-with-the-ghcrts-environment-variable">
<span id="rts-options-environment"></span><h3><span class="section-number">5.7.1.3. </span>Setting RTS options with the <code class="docutils literal notranslate"><span class="pre">GHCRTS</span></code> environment variable<a class="headerlink" href="#setting-rts-options-with-the-ghcrts-environment-variable" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-4"></span><dl class="std envvar">
<dt class="sig sig-object std" id="envvar-GHCRTS">
<span class="sig-name descname"><span class="pre">GHCRTS</span></span><a class="headerlink" href="#envvar-GHCRTS" title="Permalink to this definition">¶</a></dt>
<dd><p>If the <code class="docutils literal notranslate"><span class="pre">-rtsopts</span></code> flag is set to something other than <code class="docutils literal notranslate"><span class="pre">none</span></code> or <code class="docutils literal notranslate"><span class="pre">ignoreAll</span></code>
when linking, RTS options are also taken from the environment variable
<span class="target" id="index-5"></span><a class="reference internal" href="#envvar-GHCRTS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">GHCRTS</span></code></a>. For example, to set the maximum heap size to 2G
for all GHC-compiled programs (using an <code class="docutils literal notranslate"><span class="pre">sh</span></code>-like shell):</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="nv">GHCRTS</span><span class="o">=</span><span class="s1">&#39;-M2G&#39;</span>
<span class="nb">export</span> GHCRTS
</pre></div>
</div>
<p>RTS options taken from the <span class="target" id="index-6"></span><a class="reference internal" href="#envvar-GHCRTS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">GHCRTS</span></code></a> environment variable can be
overridden by options given on the command line.</p>
</dd></dl>

<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Setting something like <code class="docutils literal notranslate"><span class="pre">GHCRTS=-M2G</span></code> in your environment is a
handy way to avoid Haskell programs growing beyond the real memory in
your machine, which is easy to do by accident and can cause the machine
to slow to a crawl until the OS decides to kill the process (and you
hope it kills the right one).</p>
</div>
</section>
<section id="hooks-to-change-rts-behaviour">
<span id="rts-hooks"></span><h3><span class="section-number">5.7.1.4. </span>“Hooks” to change RTS behaviour<a class="headerlink" href="#hooks-to-change-rts-behaviour" title="Permalink to this heading">¶</a></h3>
<p id="index-7">GHC lets you exercise rudimentary control over certain RTS settings for
any given program, by compiling in a “hook” that is called by the
run-time system. The RTS contains stub definitions for these hooks, but
by writing your own version and linking it on the GHC command line, you
can override the defaults.</p>
<p>Owing to the vagaries of DLL linking, these hooks don’t work under
Windows when the program is built dynamically.</p>
<section id="runtime-events">
<h4><span class="section-number">5.7.1.4.1. </span>Runtime events<a class="headerlink" href="#runtime-events" title="Permalink to this heading">¶</a></h4>
<p>You can change the messages printed when the runtime system “blows up,”
e.g., on stack overflow. The hooks for these are as follows:</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.OutOfHeapHook">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">OutOfHeapHook</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.OutOfHeapHook" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The heap-overflow message.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.StackOverflowHook">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">StackOverflowHook</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.StackOverflowHook" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The stack-overflow message.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.MallocFailHook">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">MallocFailHook</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.MallocFailHook" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The message printed if <code class="docutils literal notranslate"><span class="pre">malloc</span></code> fails.</p>
</dd></dl>

</section>
<section id="event-log-output">
<span id="event-log-output-api"></span><h4><span class="section-number">5.7.1.4.2. </span>Event log output<a class="headerlink" href="#event-log-output" title="Permalink to this heading">¶</a></h4>
<p>Furthermore GHC lets you specify the way event log data (see <a class="reference internal" href="#rts-flag-l-flags"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-l</span>
<span class="pre">⟨flags⟩</span></code></a>) is written through a custom <a class="reference internal" href="#c.EventLogWriter" title="EventLogWriter"><code class="xref c c-type docutils literal notranslate"><span class="pre">EventLogWriter</span></code></a>:</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.size_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size_t</span></span></span><a class="headerlink" href="#c.size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Hidden<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.EventLogWriter">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EventLogWriter</span></span></span><a class="headerlink" href="#c.EventLogWriter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A sink of event-log data.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.EventLogWriter.initEventLogWriter">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">initEventLogWriter</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.EventLogWriter.initEventLogWriter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initializes your <a class="reference internal" href="#c.EventLogWriter" title="EventLogWriter"><code class="xref c c-type docutils literal notranslate"><span class="pre">EventLogWriter</span></code></a>. This is optional.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.EventLogWriter.writeEventLog">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">writeEventLog</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">eventlog</span></span>, <a class="reference internal" href="#c.size_t" title="size_t"><span class="n"><span class="pre">size_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">eventlog_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.EventLogWriter.writeEventLog" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Hands buffered event log data to your event log writer. Return true on success.
Required for a custom <a class="reference internal" href="#c.EventLogWriter" title="EventLogWriter"><code class="xref c c-type docutils literal notranslate"><span class="pre">EventLogWriter</span></code></a>.</p>
<p>Note that this function may be called by multiple threads
simultaneously.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.EventLogWriter.flushEventLog">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flushEventLog</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.EventLogWriter.flushEventLog" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flush buffers (if any) of your custom <a class="reference internal" href="#c.EventLogWriter" title="EventLogWriter"><code class="xref c c-type docutils literal notranslate"><span class="pre">EventLogWriter</span></code></a>. This can
be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>Note that this function may be called by multiple threads
simultaneously.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.EventLogWriter.stopEventLogWriter">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">stopEventLogWriter</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.EventLogWriter.stopEventLogWriter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Called when event logging is about to stop. This can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd></dl>

</dd></dl>

<p>To use an <a class="reference internal" href="#c.EventLogWriter" title="EventLogWriter"><code class="xref c c-type docutils literal notranslate"><span class="pre">EventLogWriter</span></code></a> the RTS API provides the following functions:</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.eventLogStatus">
<a class="reference internal" href="#c.EventLogStatus" title="EventLogStatus"><span class="n"><span class="pre">EventLogStatus</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eventLogStatus</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.eventLogStatus" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Query whether the current runtime system supports the eventlog (e.g. whether
the current executable was linked with <a class="reference internal" href="phases.html#ghc-flag-eventlog"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-eventlog</span></code></a>) and, if it
is supported, whether it is currently logging.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.startEventLogging">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">startEventLogging</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.EventLogWriter" title="EventLogWriter"><span class="n"><span class="pre">EventLogWriter</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">writer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.startEventLogging" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Start logging events to the given <a class="reference internal" href="#c.EventLogWriter" title="EventLogWriter"><code class="xref c c-type docutils literal notranslate"><span class="pre">EventLogWriter</span></code></a>. Returns true on
success or false if another writer has already been configured.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.endEventLogging">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">endEventLogging</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.endEventLogging" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tear down the active <a class="reference internal" href="#c.EventLogWriter" title="EventLogWriter"><code class="xref c c-type docutils literal notranslate"><span class="pre">EventLogWriter</span></code></a>.</p>
</dd></dl>

<p>where the <code class="docutils literal notranslate"><span class="pre">enum</span></code> <a class="reference internal" href="#c.EventLogStatus" title="EventLogStatus"><code class="xref c c-type docutils literal notranslate"><span class="pre">EventLogStatus</span></code></a> is:</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.EventLogStatus">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EventLogStatus</span></span></span><a class="headerlink" href="#c.EventLogStatus" title="Permalink to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EVENTLOG_NOT_SUPPORTED</span></code>: The runtime system wasn’t compiled with
eventlog support.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EVENTLOG_NOT_CONFIGURED</span></code>: An <a class="reference internal" href="#c.EventLogWriter" title="EventLogWriter"><code class="xref c c-type docutils literal notranslate"><span class="pre">EventLogWriter</span></code></a> has not yet been
configured.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EVENTLOG_RUNNING</span></code>: An <a class="reference internal" href="#c.EventLogWriter" title="EventLogWriter"><code class="xref c c-type docutils literal notranslate"><span class="pre">EventLogWriter</span></code></a> has been configured and
is running.</p></li>
</ul>
</dd></dl>

</section>
</section>
</section>
<section id="miscellaneous-rts-options">
<span id="rts-options-misc"></span><h2><span class="section-number">5.7.2. </span>Miscellaneous RTS options<a class="headerlink" href="#miscellaneous-rts-options" title="Permalink to this heading">¶</a></h2>
<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-install-signal-handlers-yes-no">
<span class="sig-name descname"><span class="pre">--install-signal-handlers</span></span><span class="sig-prename descclassname"><span class="pre">=⟨yes|no⟩</span></span><a class="headerlink" href="#rts-flag-install-signal-handlers-yes-no" title="Permalink to this definition">¶</a></dt>
<dd><p>If yes (the default), the RTS installs signal handlers to catch
things like <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd>. This option is primarily useful for when you are
using the Haskell code as a DLL, and want to set your own signal
handlers.</p>
<p>Note that even with <code class="docutils literal notranslate"><span class="pre">--install-signal-handlers=no</span></code>, the RTS
interval timer signal is still enabled. The timer signal is either
SIGVTALRM or SIGALRM, depending on the RTS configuration and OS
capabilities. To disable the timer signal, use the <code class="docutils literal notranslate"><span class="pre">-V0</span></code> RTS
option (see <a class="reference internal" href="profiling.html#rts-flag-V-secs"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-V</span> <span class="pre">⟨secs⟩</span></code></a>).</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-install-seh-handlers-yes-no">
<span class="sig-name descname"><span class="pre">--install-seh-handlers</span></span><span class="sig-prename descclassname"><span class="pre">=⟨yes|no⟩</span></span><a class="headerlink" href="#rts-flag-install-seh-handlers-yes-no" title="Permalink to this definition">¶</a></dt>
<dd><p>If yes (the default), the RTS on Windows installs exception handlers to
catch unhandled exceptions using the Windows exception handling mechanism.
This option is primarily useful for when you are using the Haskell code as a
DLL, and don’t want the RTS to ungracefully terminate your application on
errors such as segfaults.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-generate-crash-dumps">
<span class="sig-name descname"><span class="pre">--generate-crash-dumps</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-generate-crash-dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>If yes (the default), the RTS on Windows will generate a core dump on
any crash. These dumps can be inspected using debuggers such as WinDBG.
The dumps record all code, registers and threading information at the time
of the crash. Note that this implies <code class="docutils literal notranslate"><span class="pre">--install-seh-handlers=yes</span></code>.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-generate-stack-traces-yes-no">
<span class="sig-name descname"><span class="pre">--generate-stack-traces</span></span><span class="sig-prename descclassname"><span class="pre">=&lt;yes|no&gt;</span></span><a class="headerlink" href="#rts-flag-generate-stack-traces-yes-no" title="Permalink to this definition">¶</a></dt>
<dd><p>If yes (the default), the RTS on Windows will generate a stack trace on
crashes if exception handling are enabled. In order to get more information
in compiled executables, C code or DLLs symbols need to be available.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-disable-delayed-os-memory-return">
<span class="sig-name descname"><span class="pre">--disable-delayed-os-memory-return</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-disable-delayed-os-memory-return" title="Permalink to this definition">¶</a></dt>
<dd><p>If given, uses <code class="docutils literal notranslate"><span class="pre">MADV_DONTNEED</span></code> instead of <code class="docutils literal notranslate"><span class="pre">MADV_FREE</span></code> on platforms where
this results in more accurate resident memory usage of the program as shown
in memory usage reporting tools (e.g. the <code class="docutils literal notranslate"><span class="pre">RSS</span></code> column in <code class="docutils literal notranslate"><span class="pre">top</span></code> and <code class="docutils literal notranslate"><span class="pre">htop</span></code>).</p>
<p>Using this is expected to make the program slightly slower.</p>
<p>On Linux, MADV_FREE is newer and faster because it can avoid zeroing
pages if they are re-used by the process later (see <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">2</span> <span class="pre">madvise</span></code>),
but for the trade-off that memory inspection tools like <code class="docutils literal notranslate"><span class="pre">top</span></code> will
not immediately reflect the freeing in their display of resident memory
(RSS column): Only under memory pressure will Linux actually remove
the freed pages from the process and update its RSS statistics.
Until then, the pages show up as <code class="docutils literal notranslate"><span class="pre">LazyFree</span></code> in <code class="docutils literal notranslate"><span class="pre">/proc/PID/smaps</span></code>
(see <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">5</span> <span class="pre">proc</span></code>).</p>
<p>The delayed RSS update can confuse programmers debugging memory issues,
production memory monitoring tools, and end users who may complain about
undue memory usage shown in reporting tools, so with this flag it can
be turned off.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-xp">
<span class="sig-name descname"><span class="pre">-xp</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-xp" title="Permalink to this definition">¶</a></dt>
<dd><p>On 64-bit machines, the runtime linker usually needs to map object code
into the low 2Gb of the address space, due to the x86_64 small memory model
where most symbol references are 32 bits. The problem is that this 2Gb of
address space can fill up, especially if you’re loading a very large number
of object files into GHCi.</p>
<p>This flag offers a workaround, albeit a slightly convoluted one. To be able
to load an object file outside of the low 2Gb, the object code needs to be
compiled with <code class="docutils literal notranslate"><span class="pre">-fPIC</span> <span class="pre">-fexternal-dynamic-refs</span></code>. When the <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-xp</span></code> flag
is passed, the linker will assume that all object files were compiled with
<code class="docutils literal notranslate"><span class="pre">-fPIC</span> <span class="pre">-fexternal-dynamic-refs</span></code> and load them anywhere in the address
space. It’s up to you to arrange that the object files you load (including
all packages) were compiled in the right way. If this is not the case for
an object, the linker will probably fail with an error message when the
problem is detected.</p>
<p>On some platforms where PIC is always the case, e.g. macOS and OpenBSD on
x86_64, and macOS and Linux on aarch64 this flag is enabled by default.
One repercussion of this is that referenced system libraries also need to be
compiled with <code class="docutils literal notranslate"><span class="pre">-fPIC</span></code> if we need to load them in the runtime linker.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-xm-address">
<span class="sig-name descname"><span class="pre">-xm</span></span><span class="sig-prename descclassname"> <span class="pre">⟨address⟩</span></span><a class="headerlink" href="#rts-flag-xm-address" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning" id="index-8">
<p class="admonition-title">Warning</p>
<p>This option is for working around memory allocation
problems only. Do not use unless GHCi fails with a message like
“<code class="docutils literal notranslate"><span class="pre">failed</span> <span class="pre">to</span> <span class="pre">mmap()</span> <span class="pre">memory</span> <span class="pre">below</span> <span class="pre">2Gb</span></code>”. Consider recompiling
the objects with <code class="docutils literal notranslate"><span class="pre">-fPIC</span> <span class="pre">-fexternal-dynamic-refs</span></code> and using the
<code class="docutils literal notranslate"><span class="pre">-xp</span></code> flag instead. If you need to use this option to get GHCi
working on your machine, please file a bug.</p>
</div>
<p>On 64-bit machines, the RTS needs to allocate memory in the low 2Gb
of the address space. Support for this across different operating
systems is patchy, and sometimes fails. This option is there to give
the RTS a hint about where it should be able to allocate memory in
the low 2Gb of the address space. For example,
<code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-xm20000000</span> <span class="pre">-RTS</span></code> would hint that the RTS should allocate
starting at the 0.5Gb mark. The default is to use the OS’s built-in
support for allocating memory in the low 2Gb if available (e.g.
<code class="docutils literal notranslate"><span class="pre">mmap</span></code> with <code class="docutils literal notranslate"><span class="pre">MAP_32BIT</span></code> on Linux), or otherwise <code class="docutils literal notranslate"><span class="pre">-xm40000000</span></code>.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-xq-size">
<span class="sig-name descname"><span class="pre">-xq</span></span><span class="sig-prename descclassname"> <span class="pre">⟨size⟩</span></span><a class="headerlink" href="#rts-flag-xq-size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>100k</p>
</dd>
</dl>
<p>This option relates to allocation limits; for more about this see
<a class="reference external" href="./../libraries/base-4.16.3.0/GHC-Conc.html#v:enableAllocationLimit">GHC.Conc.enableAllocationLimit</a>.
When a thread hits its allocation limit, the RTS throws an exception
to the thread, and the thread gets an additional quota of allocation
before the exception is raised again, the idea being so that the
thread can execute its exception handlers. The <code class="docutils literal notranslate"><span class="pre">-xq</span></code> controls the
size of this additional quota.</p>
</dd></dl>

</section>
<section id="rts-options-to-control-the-garbage-collector">
<span id="rts-options-gc"></span><h2><span class="section-number">5.7.3. </span>RTS options to control the garbage collector<a class="headerlink" href="#rts-options-to-control-the-garbage-collector" title="Permalink to this heading">¶</a></h2>
<p id="index-9">There are several options to give you precise control over garbage
collection. Hopefully, you won’t need any of these in normal operation,
but there are several things that can be tweaked for maximum
performance.</p>
<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-copying-gc">
<span class="sig-name descname"><span class="pre">--copying-gc</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-copying-gc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>8.10.2</p>
</dd>
<dt class="field-odd">Reverse<span class="colon">:</span></dt>
<dd class="field-odd"><p>–nonmoving-gc</p>
</dd>
</dl>
<p>Uses the generational copying garbage collector for all generations.
This is the default.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-nonmoving-gc">
<span class="sig-name descname"><span class="pre">--nonmoving-gc</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-nonmoving-gc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>8.10.1</p>
</dd>
<dt class="field-odd">Reverse<span class="colon">:</span></dt>
<dd class="field-odd"><p>–copying-gc</p>
</dd>
</dl>
<p id="index-10">Enable the concurrent mark-and-sweep garbage collector for old generation
collectors. Typically GHC uses a stop-the-world copying garbage collector
for all generations. This can cause long pauses in execution during major
garbage collections. <a class="reference internal" href="#rts-flag-nonmoving-gc"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">--nonmoving-gc</span></code></a> enables the use of a
concurrent mark-and-sweep garbage collector for oldest generation
collections. Under this collection strategy oldest-generation garbage
collection can proceed concurrently with mutation.</p>
<p>Note that <a class="reference internal" href="#rts-flag-nonmoving-gc"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">--nonmoving-gc</span></code></a> cannot be used with <code class="docutils literal notranslate"><span class="pre">-G1</span></code>,
<a class="reference internal" href="profiling.html#rts-flag-hc"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">profiling</span></code></a> nor <a class="reference internal" href="#rts-flag-c"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-c</span></code></a>.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-w">
<span class="sig-name descname"><span class="pre">-w</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-w" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>a long time ago</p>
</dd>
<dt class="field-odd">Reverse<span class="colon">:</span></dt>
<dd class="field-odd"><p>none</p>
</dd>
</dl>
<p>Uses a mark-region garbage collection strategy for the oldest-generation heap.
Note that this cannot be used in conjunction with heap profiling
(<a class="reference internal" href="#rts-flag-hT"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-hT</span></code></a>) unless linked against the profiling runtime system with
<a class="reference internal" href="profiling.html#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a>.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-xn">
<span class="sig-name descname"><span class="pre">-xn</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-xn" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>8.10.1</p>
</dd>
</dl>
<p>An alias for <a class="reference internal" href="#rts-flag-nonmoving-gc"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">--nonmoving-gc</span></code></a></p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-A-size">
<span class="sig-name descname"><span class="pre">-A</span></span><span class="sig-prename descclassname"> <span class="pre">⟨size⟩</span></span><a class="headerlink" href="#rts-flag-A-size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>4MB</p>
</dd>
</dl>
<p id="index-11">Set the allocation area size used by the garbage
collector. The allocation area (actually generation 0 step 0) is
fixed and is never resized (unless you use <a class="reference internal" href="#rts-flag-H-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-H</span> <span class="pre">[⟨size⟩]</span></code></a>, below).</p>
<p>Optimal settings depend on the actual machine, program, and other RTS options.
Increasing the allocation area size means worse cache behaviour
but fewer garbage collections and less promotion.</p>
<p>In general settings &gt;= 4MB can reduce performance in some cases, in particular for single
threaded operation. However in a parallel setting increasing the allocation area
to <code class="docutils literal notranslate"><span class="pre">16MB</span></code>, or even <code class="docutils literal notranslate"><span class="pre">64MB</span></code> can increase gc throughput significantly.</p>
<p>With only 1 generation (e.g. <code class="docutils literal notranslate"><span class="pre">-G1</span></code>, see <a class="reference internal" href="#rts-flag-G-generations"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-G</span> <span class="pre">⟨generations⟩</span></code></a>) the
<code class="docutils literal notranslate"><span class="pre">-A</span></code> option specifies the minimum allocation area, since the actual size
of the allocation area will be resized according to the amount of data in
the heap (see <a class="reference internal" href="#rts-flag-F-factor"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-F</span> <span class="pre">⟨factor⟩</span></code></a>, below).</p>
<p>When heap profiling using a smaller allocation area can increase accuracy as more frequent
major garbage collections also results in more frequent heap snapshots</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-AL-size">
<span class="sig-name descname"><span class="pre">-AL</span></span><span class="sig-prename descclassname"> <span class="pre">⟨size⟩</span></span><a class="headerlink" href="#rts-flag-AL-size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#rts-flag-A-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-A</span></code></a> value</p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>8.2.1</p>
</dd>
</dl>
<p id="index-12">Sets the limit on the total size of “large objects” (objects
larger than about 3KB) that can be allocated before a GC is
triggered. By default this limit is the same as the <a class="reference internal" href="#rts-flag-A-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-A</span></code></a> value.</p>
<p>Large objects are not allocated from the normal allocation area
set by the <code class="docutils literal notranslate"><span class="pre">-A</span></code> flag, which is why there is a separate limit for
these.  Large objects tend to be much rarer than small objects, so
most programs hit the <code class="docutils literal notranslate"><span class="pre">-A</span></code> limit before the <code class="docutils literal notranslate"><span class="pre">-AL</span></code> limit.  However,
the <code class="docutils literal notranslate"><span class="pre">-A</span></code> limit is per-capability, whereas the <code class="docutils literal notranslate"><span class="pre">-AL</span></code> limit is global,
so as <code class="docutils literal notranslate"><span class="pre">-N</span></code> gets larger it becomes more likely that we hit the
<code class="docutils literal notranslate"><span class="pre">-AL</span></code> limit first.  To counteract this, it might be necessary to
use a larger <code class="docutils literal notranslate"><span class="pre">-AL</span></code> limit when using a large <code class="docutils literal notranslate"><span class="pre">-N</span></code>.</p>
<p>To see whether you’re making good use of all the memory reseverd
for the allocation area (<code class="docutils literal notranslate"><span class="pre">-A</span></code> times <code class="docutils literal notranslate"><span class="pre">-N</span></code>), look at the output of
<code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-S</span></code> and check whether the amount of memory allocated between
GCs is equal to <code class="docutils literal notranslate"><span class="pre">-A</span></code> times <code class="docutils literal notranslate"><span class="pre">-N</span></code>. If not, there are two possible
remedies: use <code class="docutils literal notranslate"><span class="pre">-n</span></code> to set a nursery chunk size, or use <code class="docutils literal notranslate"><span class="pre">-AL</span></code> to
increase the limit for large objects.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-O-size">
<span class="sig-name descname"><span class="pre">-O</span></span><span class="sig-prename descclassname"> <span class="pre">⟨size⟩</span></span><a class="headerlink" href="#rts-flag-O-size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>1m</p>
</dd>
</dl>
<p id="index-13">Set the minimum size of the old generation. The old generation is collected
whenever it grows to this size or the value of the <a class="reference internal" href="#rts-flag-F-factor"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-F</span> <span class="pre">⟨factor⟩</span></code></a>
option multiplied by the size of the live data at the previous major
collection, whichever is larger.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-n-size">
<span class="sig-name descname"><span class="pre">-n</span></span><span class="sig-prename descclassname"> <span class="pre">⟨size⟩</span></span><a class="headerlink" href="#rts-flag-n-size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>4m with <a class="reference internal" href="#rts-flag-A-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-A16m</span></code></a> or larger, otherwise 0.</p>
</dd>
</dl>
<p id="index-14">[Example: <code class="docutils literal notranslate"><span class="pre">-n4m</span></code> ] When set to a non-zero value, this
option divides the allocation area (<code class="docutils literal notranslate"><span class="pre">-A</span></code> value) into chunks of the
specified size. During execution, when a processor exhausts its
current chunk, it is given another chunk from the pool until the
pool is exhausted, at which point a collection is triggered.</p>
<p>This option is only useful when running in parallel (<code class="docutils literal notranslate"><span class="pre">-N2</span></code> or
greater). It allows the processor cores to make better use of the
available allocation area, even when cores are allocating at
different rates. Without <code class="docutils literal notranslate"><span class="pre">-n</span></code>, each core gets a fixed-size
allocation area specified by the <code class="docutils literal notranslate"><span class="pre">-A</span></code>, and the first core to
exhaust its allocation area triggers a GC across all the cores. This
can result in a collection happening when the allocation areas of
some cores are only partially full, so the purpose of the <code class="docutils literal notranslate"><span class="pre">-n</span></code> is
to allow cores that are allocating faster to get more of the
allocation area. This means less frequent GC, leading a lower GC
overhead for the same heap size.</p>
<p>This is particularly useful in conjunction with larger <code class="docutils literal notranslate"><span class="pre">-A</span></code>
values, for example <code class="docutils literal notranslate"><span class="pre">-A64m</span> <span class="pre">-n4m</span></code> is a useful combination on larger core
counts (8+).</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-c">
<span class="sig-name descname"><span class="pre">-c</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-c" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-15">Use a compacting algorithm for collecting the oldest generation. By
default, the oldest generation is collected using a copying
algorithm; this option causes it to be compacted in-place instead.
The compaction algorithm is slower than the copying algorithm, but
the savings in memory use can be considerable.</p>
<p>For a given heap size (using the <a class="reference internal" href="#rts-flag-H-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-H</span> <span class="pre">[⟨size⟩]</span></code></a> option),
compaction can in fact reduce the GC cost by allowing fewer GCs to be
performed. This is more likely when the ratio of live data to heap size is
high, say greater than 30%.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Compaction doesn’t currently work when a single generation is
requested using the <code class="docutils literal notranslate"><span class="pre">-G1</span></code> option.</p>
</div>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-c-n">
<span class="sig-name descname"><span class="pre">-c</span></span><span class="sig-prename descclassname"> <span class="pre">⟨n⟩</span></span><a class="headerlink" href="#rts-flag-c-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>30</p>
</dd>
</dl>
<p>Automatically enable compacting collection when the live data exceeds ⟨n⟩%
of the maximum heap size (see the <a class="reference internal" href="#rts-flag-M-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-M</span> <span class="pre">⟨size⟩</span></code></a> option). Note that
the maximum heap size is unlimited by default, so this option has no effect
unless the maximum heap size is set with <a class="reference internal" href="#rts-flag-M-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-M</span> <span class="pre">⟨size⟩</span></code></a>.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-F-factor">
<span class="sig-name descname"><span class="pre">-F</span></span><span class="sig-prename descclassname"> <span class="pre">⟨factor⟩</span></span><a class="headerlink" href="#rts-flag-F-factor" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>2</p>
</dd>
</dl>
<p id="index-16">This option controls the amount of memory reserved for
the older generations (and in the case of a two space collector the
size of the allocation area) as a factor of the amount of live data.
For example, if there was 2M of live data in the oldest generation
when we last collected it, then by default we’ll wait until it grows
to 4M before collecting it again.</p>
<p>The default seems to work well here. If you have plenty of memory, it is
usually better to use <code class="docutils literal notranslate"><span class="pre">-H</span> <span class="pre">⟨size⟩</span></code> (see <a class="reference internal" href="#rts-flag-H-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-H</span> <span class="pre">[⟨size⟩]</span></code></a>) than to
increase <a class="reference internal" href="#rts-flag-F-factor"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-F</span> <span class="pre">⟨factor⟩</span></code></a>.</p>
<p>The <a class="reference internal" href="#rts-flag-F-factor"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-F</span> <span class="pre">⟨factor⟩</span></code></a> setting will be automatically reduced by the garbage
collector when the maximum heap size (the <a class="reference internal" href="#rts-flag-M-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-M</span> <span class="pre">⟨size⟩</span></code></a> setting) is approaching.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Fd-factor">
<span class="sig-name descname"><span class="pre">-Fd</span></span><span class="sig-prename descclassname"> <span class="pre">⟨factor⟩</span></span><a class="headerlink" href="#rts-flag-Fd-factor" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>4</p>
</dd>
</dl>
<p id="index-17">The inverse rate at which unused memory is returned to the OS when it is no longer
needed. After a large amount of allocation the RTS will start by retaining
a lot of allocated blocks in case it will need them again shortly but then
it will gradually release them based on the <a class="reference internal" href="#rts-flag-Fd-factor"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-Fd</span> <span class="pre">⟨factor⟩</span></code></a>. On
each subsequent major collection which is not caused by a heap overflow a little
more memory will attempt to be returned until the amount retained is similar to
the amount of live bytes.</p>
<p>Increasing this factor will make the rate memory is returned slower, decreasing
it will make memory be returned more eagerly. Setting it to 0 will disable the
memory return (which will emulate the behaviour in releases prior to 9.2).</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-G-generations">
<span class="sig-name descname"><span class="pre">-G</span></span><span class="sig-prename descclassname"> <span class="pre">⟨generations⟩</span></span><a class="headerlink" href="#rts-flag-G-generations" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>2</p>
</dd>
</dl>
<p id="index-18">Set the number of generations used by the garbage
collector. The default of 2 seems to be good, but the garbage
collector can support any number of generations. Anything larger
than about 4 is probably not a good idea unless your program runs
for a <em>long</em> time, because the oldest generation will hardly ever
get collected.</p>
<p>Specifying 1 generation with <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-G1</span></code> gives you a simple 2-space
collector, as you would expect. In a 2-space collector, the <a class="reference internal" href="#rts-flag-A-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-A</span>
<span class="pre">⟨size⟩</span></code></a> option specifies the <em>minimum</em> allocation area size, since the
allocation area will grow with the amount of live data in the heap. In a
multi-generational collector the allocation area is a fixed size (unless
you use the <a class="reference internal" href="#rts-flag-H-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-H</span> <span class="pre">[⟨size⟩]</span></code></a> option).</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-qg-gen">
<span class="sig-name descname"><span class="pre">-qg</span></span><span class="sig-prename descclassname"> <span class="pre">⟨gen⟩</span></span><a class="headerlink" href="#rts-flag-qg-gen" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>0</p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>6.12.1</p>
</dd>
</dl>
<p>Use parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ turns off the
parallel GC completely, reverting to sequential GC.</p>
<p>The default parallel GC settings are usually suitable for parallel programs
(i.e. those using <a class="reference external" href="./../libraries/base-4.16.3.0/GHC-Conc.html#v:par">GHC.Conc.par</a>, Strategies, or with
multiple threads). However, it is sometimes beneficial to enable the
parallel GC for a single-threaded sequential program too, especially if the
program has a large amount of heap data and GC is a significant fraction of
runtime. To use the parallel GC in a sequential program, enable the parallel
runtime with a suitable <a class="reference internal" href="using-concurrent.html#rts-flag-N-x"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-N</span> <span class="pre">⟨x⟩</span></code></a> option, and additionally it might
be beneficial to restrict parallel GC to the old generation with <code class="docutils literal notranslate"><span class="pre">-qg1</span></code>.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-qb-gen">
<span class="sig-name descname"><span class="pre">-qb</span></span><span class="sig-prename descclassname"> <span class="pre">⟨gen⟩</span></span><a class="headerlink" href="#rts-flag-qb-gen" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>1 for <a class="reference internal" href="#rts-flag-A-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-A</span></code></a> &lt; 32M, 0 otherwise</p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>6.12.1</p>
</dd>
</dl>
<p>Use load-balancing in the parallel GC in generation ⟨gen⟩ and higher.
Omitting ⟨gen⟩ disables load-balancing entirely.</p>
<p>Load-balancing shares out the work of GC between the available
cores. This is a good idea when the heap is large and we need to
parallelise the GC work, however it is also pessimal for the short
young-generation collections in a parallel program, because it can
harm locality by moving data from the cache of the CPU where is it
being used to the cache of another CPU. Hence the default is to do
load-balancing only in the old-generation. In fact, for a parallel
program it is sometimes beneficial to disable load-balancing
entirely with <code class="docutils literal notranslate"><span class="pre">-qb</span></code>.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-qn-x">
<span class="sig-name descname"><span class="pre">-qn</span></span><span class="sig-prename descclassname"> <span class="pre">⟨x⟩</span></span><a class="headerlink" href="#rts-flag-qn-x" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>the value of <a class="reference internal" href="using-concurrent.html#rts-flag-N-x"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-N</span></code></a> or the number of CPU cores,
whichever is smaller.</p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>8.2.1</p>
</dd>
</dl>
<p id="index-19">By default, all of the capabilities participate in parallel
garbage collection.  If we want to use a very large <code class="docutils literal notranslate"><span class="pre">-N</span></code> value,
however, this can reduce the performance of the GC.  For this
reason, the <code class="docutils literal notranslate"><span class="pre">-qn</span></code> flag can be used to specify a lower number for
the threads that should participate in GC.  During GC, if there
are more than this number of workers active, some of them will
sleep for the duration of the GC.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">-qn</span></code> flag may be useful when running with a large <code class="docutils literal notranslate"><span class="pre">-A</span></code> value
(so that GC is infrequent), and a large <code class="docutils literal notranslate"><span class="pre">-N</span></code> value (so as to make
use of hyperthreaded cores, for example).  For example, on a
24-core machine with 2 hyperthreads per core, we might use
<code class="docutils literal notranslate"><span class="pre">-N48</span> <span class="pre">-qn24</span> <span class="pre">-A128m</span></code> to specify that the mutator should use
hyperthreads but the GC should only use real cores.  Note that
this configuration would use 6GB for the allocation area.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-H-size">
<span class="sig-name descname"><span class="pre">-H</span></span><span class="sig-prename descclassname"> <span class="pre">[⟨size⟩]</span></span><a class="headerlink" href="#rts-flag-H-size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>0</p>
</dd>
</dl>
<p id="index-20">This option provides a “suggested heap size” for the garbage collector.
Think of <code class="docutils literal notranslate"><span class="pre">-Hsize</span></code> as a variable <a class="reference internal" href="#rts-flag-A-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-A</span> <span class="pre">⟨size⟩</span></code></a> option.  It says: I
want to use at least ⟨size⟩ bytes, so use whatever is left over to increase
the <code class="docutils literal notranslate"><span class="pre">-A</span></code> value.</p>
<p>This option does not put a <em>limit</em> on the heap size: the heap may
grow beyond the given size as usual.</p>
<p>If ⟨size⟩ is omitted, then the garbage collector will take the size
of the heap at the previous GC as the ⟨size⟩. This has the effect of
allowing for a larger <code class="docutils literal notranslate"><span class="pre">-A</span></code> value but without increasing the
overall memory requirements of the program. It can be useful when
the default small <code class="docutils literal notranslate"><span class="pre">-A</span></code> value is suboptimal, as it can be in
programs that create large amounts of long-lived data.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-I-seconds">
<span class="sig-name descname"><span class="pre">-I</span></span><span class="sig-prename descclassname"> <span class="pre">⟨seconds⟩</span></span><a class="headerlink" href="#rts-flag-I-seconds" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>0.3 seconds in the threaded runtime, 0 in the non-threaded runtime</p>
</dd>
</dl>
<p id="index-21">In the threaded and SMP versions of the RTS (see
<a class="reference internal" href="phases.html#ghc-flag-threaded"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-threaded</span></code></a>, <a class="reference internal" href="phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a>), a major GC is automatically
performed if the runtime has been idle (no Haskell computation has
been running) for a period of time. The amount of idle time which
must pass before a GC is performed is set by the <code class="docutils literal notranslate"><span class="pre">-I</span> <span class="pre">⟨seconds⟩</span></code>
option. Specifying <code class="docutils literal notranslate"><span class="pre">-I0</span></code> disables the idle GC.</p>
<p>For an interactive application, it is probably a good idea to use
the idle GC, because this will allow finalizers to run and
deadlocked threads to be detected in the idle time when no Haskell
computation is happening. Also, it will mean that a GC is less
likely to happen when the application is busy, and so responsiveness
may be improved. However, if the amount of live data in the heap is
particularly large, then the idle GC can cause a significant delay,
and too small an interval could adversely affect interactive
responsiveness.</p>
<p>The idle period timer only resets after some activity
by a Haskell thread. If your program is doing literally nothing then
after the first idle collection is triggered then no more future collections
will be scheduled until more work is performed.</p>
<p>This is an experimental feature, please let us know if it causes
problems and/or could benefit from further tuning.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Iw-seconds">
<span class="sig-name descname"><span class="pre">-Iw</span></span><span class="sig-prename descclassname"> <span class="pre">⟨seconds⟩</span></span><a class="headerlink" href="#rts-flag-Iw-seconds" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>0 seconds</p>
</dd>
</dl>
<p id="index-22">By default, if idle GC is enabled in the threaded runtime, a major
GC will be performed every time the process goes idle for a
sufficiently long duration (see <a class="reference internal" href="#rts-flag-I-seconds"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-I</span> <span class="pre">⟨seconds⟩</span></code></a>).  For
large server processes accepting regular but infrequent requests
(e.g., once per second), an expensive, major GC may run after
every request.  As an alternative to shutting off idle GC entirely
(with <code class="docutils literal notranslate"><span class="pre">-I0</span></code>), a minimum wait time between idle GCs can be
specified with this flag.  For example, <code class="docutils literal notranslate"><span class="pre">-Iw60</span></code> will ensure that
an idle GC runs at most once per minute.</p>
<p>This is an experimental feature, please let us know if it causes
problems and/or could benefit from further tuning.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-ki-size">
<span class="sig-name descname"><span class="pre">-ki</span></span><span class="sig-prename descclassname"> <span class="pre">⟨size⟩</span></span><a class="headerlink" href="#rts-flag-ki-size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>1k</p>
</dd>
</dl>
<p id="index-23">Set the initial stack size for new threads.</p>
<p>Thread stacks (including the main thread’s stack) live on the heap.
As the stack grows, new stack chunks are added as required; if the
stack shrinks again, these extra stack chunks are reclaimed by the
garbage collector. The default initial stack size is deliberately
small, in order to keep the time and space overhead for thread
creation to a minimum, and to make it practical to spawn threads for
even tiny pieces of work.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This flag used to be simply <code class="docutils literal notranslate"><span class="pre">-k</span></code>, but was renamed to <code class="docutils literal notranslate"><span class="pre">-ki</span></code> in
GHC 7.2.1. The old name is still accepted for backwards
compatibility, but that may be removed in a future version.</p>
</div>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-kc-size">
<span class="sig-name descname"><span class="pre">-kc</span></span><span class="sig-prename descclassname"> <span class="pre">⟨size⟩</span></span><a class="headerlink" href="#rts-flag-kc-size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>32k</p>
</dd>
</dl>
<p id="index-24">Set the size of “stack chunks”. When a thread’s current stack overflows, a
new stack chunk is created and added to the thread’s stack, until the limit
set by <a class="reference internal" href="#rts-flag-K-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-K</span> <span class="pre">⟨size⟩</span></code></a> is reached.</p>
<p>The advantage of smaller stack chunks is that the garbage collector can
avoid traversing stack chunks if they are known to be unmodified since the
last collection, so reducing the chunk size means that the garbage
collector can identify more stack as unmodified, and the GC overhead might
be reduced. On the other hand, making stack chunks too small adds some
overhead as there will be more overflow/underflow between chunks. The
default setting of 32k appears to be a reasonable compromise in most cases.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-kb-size">
<span class="sig-name descname"><span class="pre">-kb</span></span><span class="sig-prename descclassname"> <span class="pre">⟨size⟩</span></span><a class="headerlink" href="#rts-flag-kb-size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>1k</p>
</dd>
</dl>
<p id="index-25">Sets the stack chunk buffer size. When a stack chunk
overflows and a new stack chunk is created, some of the data from
the previous stack chunk is moved into the new chunk, to avoid an
immediate underflow and repeated overflow/underflow at the boundary.
The amount of stack moved is set by the <code class="docutils literal notranslate"><span class="pre">-kb</span></code> option.</p>
<p>Note that to avoid wasting space, this value should typically be less than
10% of the size of a stack chunk (<a class="reference internal" href="#rts-flag-kc-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-kc</span> <span class="pre">⟨size⟩</span></code></a>), because in a
chain of stack chunks, each chunk will have a gap of unused space of this
size.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-K-size">
<span class="sig-name descname"><span class="pre">-K</span></span><span class="sig-prename descclassname"> <span class="pre">⟨size⟩</span></span><a class="headerlink" href="#rts-flag-K-size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>80% of physical memory</p>
</dd>
</dl>
<p id="index-26">Set the maximum stack size for
an individual thread to ⟨size⟩ bytes. If the thread attempts to
exceed this limit, it will be sent the <code class="docutils literal notranslate"><span class="pre">StackOverflow</span></code> exception.
The limit can be disabled entirely by specifying a size of zero.</p>
<p>This option is there mainly to stop the program eating up all the
available memory in the machine if it gets into an infinite loop.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-m-n">
<span class="sig-name descname"><span class="pre">-m</span></span><span class="sig-prename descclassname"> <span class="pre">⟨n⟩</span></span><a class="headerlink" href="#rts-flag-m-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>3%</p>
</dd>
</dl>
<p id="index-27">Minimum % ⟨n⟩ of heap which must be available for allocation.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-M-size">
<span class="sig-name descname"><span class="pre">-M</span></span><span class="sig-prename descclassname"> <span class="pre">⟨size⟩</span></span><a class="headerlink" href="#rts-flag-M-size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>unlimited</p>
</dd>
</dl>
<p id="index-28">Set the maximum heap size to ⟨size⟩ bytes. The
heap normally grows and shrinks according to the memory requirements
of the program. The only reason for having this option is to stop
the heap growing without bound and filling up all the available swap
space, which at the least will result in the program being summarily
killed by the operating system.</p>
<p>The maximum heap size also affects other garbage collection
parameters: when the amount of live data in the heap exceeds a
certain fraction of the maximum heap size, compacting collection
will be automatically enabled for the oldest generation, and the
<code class="docutils literal notranslate"><span class="pre">-F</span></code> parameter will be reduced in order to avoid exceeding the
maximum heap size.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Mgrace-size">
<span class="sig-name descname"><span class="pre">-Mgrace</span></span><span class="sig-prename descclassname"><span class="pre">=⟨size⟩</span></span><a class="headerlink" href="#rts-flag-Mgrace-size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>1M</p>
</dd>
</dl>
<p id="index-29">If the program’s heap exceeds the value set by <a class="reference internal" href="#rts-flag-M-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-M</span> <span class="pre">⟨size⟩</span></code></a>, the
RTS throws an exception to the program, and the program gets an
additional quota of allocation before the exception is raised
again, the idea being so that the program can execute its
exception handlers. <code class="docutils literal notranslate"><span class="pre">-Mgrace=</span></code> controls the size of this
additional quota.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-numa">
<span class="sig-name descname"><span class="pre">--numa</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-numa" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="rts-flag-numa-mask">
<span class="sig-name descname"><span class="pre">--numa</span></span><span class="sig-prename descclassname"><span class="pre">=&lt;mask&gt;</span></span><a class="headerlink" href="#rts-flag-numa-mask" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-30">Enable NUMA-aware memory allocation in the runtime (only available
with <code class="docutils literal notranslate"><span class="pre">-threaded</span></code>, and only on Linux and Windows currently).</p>
<p>Background: some systems have a Non-Uniform Memory Architecture,
whereby main memory is split into banks which are “local” to
specific CPU cores.  Accessing local memory is faster than
accessing remote memory.  The OS provides APIs for allocating
local memory and binding threads to particular CPU cores, so that
we can ensure certain memory accesses are using local memory.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">--numa</span></code> option tells the RTS to tune its memory usage to
maximize local memory accesses.  In particular, the RTS will:</p>
<blockquote>
<div><ul class="simple">
<li><p>Determine the number of NUMA nodes (N) by querying the OS.</p></li>
<li><p>Manage separate memory pools for each node.</p></li>
<li><p>Map capabilities to NUMA nodes.  Capability C is mapped to
NUMA node C mod N.</p></li>
<li><p>Bind worker threads on a capability to the appropriate node.</p></li>
<li><p>Allocate the nursery from node-local memory.</p></li>
<li><p>Perform other memory allocation, including in the GC, from
node-local memory.</p></li>
<li><p>When load-balancing, we prefer to migrate threads to another
Capability on the same node.</p></li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">--numa</span></code> flag is typically beneficial when a program is
using all cores of a large multi-core NUMA system, with a large
allocation area (<code class="docutils literal notranslate"><span class="pre">-A</span></code>).  All memory accesses to the allocation
area will go to local memory, which can save a significant amount
of remote memory access.  A runtime speedup on the order of 10%
is typical, but can vary a lot depending on the hardware and the
memory behaviour of the program.</p>
<p>Note that the RTS will not set CPU affinity for bound threads and
threads entering Haskell from C/C++, so if your program uses bound
threads you should ensure that each bound thread calls the RTS API
<cite>rts_setInCallCapability(c,1)</cite> from C/C++ before calling into
Haskell.  Otherwise there could be a mismatch between the CPU that
the thread is running on and the memory it is using while running
Haskell code, which will negate any benefits of <code class="docutils literal notranslate"><span class="pre">--numa</span></code>.</p>
<p>If given an explicit &lt;mask&gt;, the &lt;mask&gt; is interpreted as a bitmap
that indicates the NUMA nodes on which to run the program.  For
example, <code class="docutils literal notranslate"><span class="pre">--numa=3</span></code> would run the program on NUMA nodes 0 and 1.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-long-gc-sync">
<span class="sig-name descname"><span class="pre">--long-gc-sync</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-long-gc-sync" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="rts-flag-long-gc-sync-seconds">
<span class="sig-name descname"><span class="pre">--long-gc-sync</span></span><span class="sig-prename descclassname"><span class="pre">=&lt;seconds&gt;</span></span><a class="headerlink" href="#rts-flag-long-gc-sync-seconds" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-31">When a GC starts, all the running mutator threads have to stop and
synchronise.  The period between when the GC is initiated and all
the mutator threads are stopped is called the GC synchronisation
phase. If this phase is taking a long time (longer than 1ms is
considered long), then it can have a severe impact on overall
throughput.</p>
<p>A long GC sync can be caused by a mutator thread that is inside an
<code class="docutils literal notranslate"><span class="pre">unsafe</span></code> FFI call, or running in a loop that doesn’t allocate
memory and so doesn’t yield.  To fix the former, make the call
<code class="docutils literal notranslate"><span class="pre">safe</span></code>, and to fix the latter, either avoid calling the code in
question or compile it with <a class="reference internal" href="using-optimisation.html#ghc-flag-fomit-yields"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fomit-yields</span></code></a>.</p>
<p>By default, the flag will cause a warning to be emitted to stderr
when the sync time exceeds the specified time.  This behaviour can
be overridden, however: the <code class="docutils literal notranslate"><span class="pre">longGCSync()</span></code> hook is called when
the sync time is exceeded during the sync period, and the
<code class="docutils literal notranslate"><span class="pre">longGCSyncEnd()</span></code> hook at the end. Both of these hooks can be
overridden in the <code class="docutils literal notranslate"><span class="pre">RtsConfig</span></code> when the runtime is started with
<code class="docutils literal notranslate"><span class="pre">hs_init_ghc()</span></code>. The default implementations of these hooks
(<code class="docutils literal notranslate"><span class="pre">LongGcSync()</span></code> and <code class="docutils literal notranslate"><span class="pre">LongGCSyncEnd()</span></code> respectively) print
warnings to stderr.</p>
<p>One way to use this flag is to set a breakpoint on
<code class="docutils literal notranslate"><span class="pre">LongGCSync()</span></code> in the debugger, and find the thread that is
delaying the sync. You probably want to use <a class="reference internal" href="debug-info.html#ghc-flag-g"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-g</span></code></a> to
provide more info to the debugger.</p>
<p>The GC sync time, along with other GC stats, are available by
calling the <code class="docutils literal notranslate"><span class="pre">getRTSStats()</span></code> function from C, or
<code class="docutils literal notranslate"><span class="pre">GHC.Stats.getRTSStats</span></code> from Haskell.</p>
</dd></dl>

</section>
<section id="rts-options-to-produce-runtime-statistics">
<span id="rts-options-statistics"></span><h2><span class="section-number">5.7.4. </span>RTS options to produce runtime statistics<a class="headerlink" href="#rts-options-to-produce-runtime-statistics" title="Permalink to this heading">¶</a></h2>
<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-T">
<span class="sig-name descname"><span class="pre">-T</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-T" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="rts-flag-t-file">
<span class="sig-name descname"><span class="pre">-t</span></span><span class="sig-prename descclassname"> <span class="pre">[⟨file⟩]</span></span><a class="headerlink" href="#rts-flag-t-file" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="rts-flag-s-file">
<span class="sig-name descname"><span class="pre">-s</span></span><span class="sig-prename descclassname"> <span class="pre">[⟨file⟩]</span></span><a class="headerlink" href="#rts-flag-s-file" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="rts-flag-S-file">
<span class="sig-name descname"><span class="pre">-S</span></span><span class="sig-prename descclassname"> <span class="pre">[⟨file⟩]</span></span><a class="headerlink" href="#rts-flag-S-file" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="rts-flag-machine-readable">
<span class="sig-name descname"><span class="pre">--machine-readable</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-machine-readable" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="rts-flag-internal-counters">
<span class="sig-name descname"><span class="pre">--internal-counters</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-internal-counters" title="Permalink to this definition">¶</a></dt>
<dd><p>These options produce runtime-system statistics, such as the amount
of time spent executing the program and in the garbage collector,
the amount of memory allocated, the maximum size of the heap, and so
on. The three variants give different levels of detail: <code class="docutils literal notranslate"><span class="pre">-T</span></code>
collects the data but produces no output <code class="docutils literal notranslate"><span class="pre">-t</span></code> produces a single
line of output in the same format as GHC’s <code class="docutils literal notranslate"><span class="pre">-Rghc-timing</span></code> option,
<code class="docutils literal notranslate"><span class="pre">-s</span></code> produces a more detailed summary at the end of the program,
and <code class="docutils literal notranslate"><span class="pre">-S</span></code> additionally produces information about each and every
garbage collection. Passing <code class="docutils literal notranslate"><span class="pre">--internal-counters</span></code> to a threaded
runtime will cause a detailed summary to include various internal
counts accumulated during the run; note that these are unspecified
and may change between releases.</p>
<p>The output is placed in ⟨file⟩. If ⟨file⟩ is omitted, then the
output is sent to <code class="docutils literal notranslate"><span class="pre">stderr</span></code>.</p>
<p>If you use the <code class="docutils literal notranslate"><span class="pre">-T</span></code> flag then, you should access the statistics
using <a class="reference external" href="./../libraries/base-4.16.3.0/GHC-Stats.html">GHC.Stats</a>.</p>
<p>If you use the <code class="docutils literal notranslate"><span class="pre">-t</span></code> flag then, when your program finishes, you
will see something like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;&lt;ghc: 36169392 bytes, 69 GCs, 603392/1065272 avg/max bytes residency (2 samples), 3M in use, 0.00 INIT (0.00 elapsed), 0.02 MUT (0.02 elapsed), 0.07 GC (0.07 elapsed) :ghc&gt;&gt;
</pre></div>
</div>
<p>This tells you:</p>
<ul class="simple">
<li><p>The total number of bytes allocated by the program over the whole
run.</p></li>
<li><p>The total number of garbage collections performed.</p></li>
<li><p>The average and maximum “residency”, which is the amount of live
data in bytes. The runtime can only determine the amount of live
data during a major GC, which is why the number of samples
corresponds to the number of major GCs (and is usually relatively
small). To get a better picture of the heap profile of your
program, use the <a class="reference internal" href="#rts-flag-hT"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-hT</span></code></a> RTS option (<a class="reference internal" href="#rts-profiling"><span class="std std-ref">RTS options for profiling</span></a>).</p></li>
<li><p>The peak memory the RTS has allocated from the OS.</p></li>
<li><p>The amount of CPU time and elapsed wall clock time while
initialising the runtime system (INIT), running the program
itself (MUT, the mutator), and garbage collecting (GC).</p></li>
</ul>
<p>You can also get this in a more future-proof, machine readable
format, with <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">--machine-readable</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="s">&quot;bytes allocated&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;36169392&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">,(</span><span class="s">&quot;num_GCs&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;69&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">,(</span><span class="s">&quot;average_bytes_used&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;603392&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">,(</span><span class="s">&quot;max_bytes_used&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;1065272&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">,(</span><span class="s">&quot;num_byte_usage_samples&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;2&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">,(</span><span class="s">&quot;peak_megabytes_allocated&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;3&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">,(</span><span class="s">&quot;init_cpu_seconds&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;0.00&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">,(</span><span class="s">&quot;init_wall_seconds&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;0.00&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">,(</span><span class="s">&quot;mutator_cpu_seconds&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;0.02&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">,(</span><span class="s">&quot;mutator_wall_seconds&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;0.02&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">,(</span><span class="s">&quot;GC_cpu_seconds&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;0.07&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">,(</span><span class="s">&quot;GC_wall_seconds&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;0.07&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>If you use the <code class="docutils literal notranslate"><span class="pre">-s</span></code> flag then, when your program finishes, you
will see something like this (the exact details will vary depending
on what sort of RTS you have, e.g. you will only see profiling data
if your RTS is compiled for profiling):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    36,169,392 bytes allocated in the heap
     4,057,632 bytes copied during GC
     1,065,272 bytes maximum residency (2 sample(s))
        54,312 bytes maximum slop
             3 MB total memory in use (0 MB lost due to fragmentation)

Generation 0:    67 collections,     0 parallel,  0.04s,  0.03s elapsed
Generation 1:     2 collections,     0 parallel,  0.03s,  0.04s elapsed

SPARKS: 359207 (557 converted, 149591 pruned)

INIT  time    0.00s  (  0.00s elapsed)
MUT   time    0.01s  (  0.02s elapsed)
GC    time    0.07s  (  0.07s elapsed)
EXIT  time    0.00s  (  0.00s elapsed)
Total time    0.08s  (  0.09s elapsed)

%GC time      89.5%  (75.3% elapsed)

Alloc rate    4,520,608,923 bytes per MUT second

Productivity  10.5% of total user, 9.1% of total elapsed
</pre></div>
</div>
<ul>
<li><p>The “bytes allocated in the heap” is the total bytes allocated by
the program over the whole run.</p></li>
<li><p>GHC uses a copying garbage collector by default. “bytes copied
during GC” tells you how many bytes it had to copy during garbage
collection.</p></li>
<li><p>The maximum space actually used by your program is the “bytes
maximum residency” figure. This is only checked during major
garbage collections, so it is only an approximation; the number
of samples tells you how many times it is checked.</p></li>
<li><p>The “bytes maximum slop” tells you the most space that is ever
wasted due to the way GHC allocates memory in blocks. Slop is
memory at the end of a block that was wasted. There’s no way to
control this; we just like to see how much memory is being lost
this way.</p></li>
<li><p>The “total memory in use” tells you the peak memory the RTS has
allocated from the OS.</p></li>
<li><p>Next there is information about the garbage collections done. For
each generation it says how many garbage collections were done,
how many of those collections were done in parallel, the total
CPU time used for garbage collecting that generation, and the
total wall clock time elapsed while garbage collecting that
generation.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">SPARKS</span></code> statistic refers to the use of
<code class="docutils literal notranslate"><span class="pre">Control.Parallel.par</span></code> and related functionality in the
program. Each spark represents a call to <code class="docutils literal notranslate"><span class="pre">par</span></code>; a spark is
“converted” when it is executed in parallel; and a spark is
“pruned” when it is found to be already evaluated and is
discarded from the pool by the garbage collector. Any remaining
sparks are discarded at the end of execution, so “converted” plus
“pruned” does not necessarily add up to the total.</p></li>
<li><p>Next there is the CPU time and wall clock time elapsed broken
down by what the runtime system was doing at the time. INIT is
the runtime system initialisation. MUT is the mutator time, i.e.
the time spent actually running your code. GC is the time spent
doing garbage collection. RP is the time spent doing retainer
profiling. PROF is the time spent doing other profiling. EXIT is
the runtime system shutdown time. And finally, Total is, of
course, the total.</p>
<p>%GC time tells you what percentage GC is of Total. “Alloc rate”
tells you the “bytes allocated in the heap” divided by the MUT
CPU time. “Productivity” tells you what percentage of the Total
CPU and wall clock elapsed times are spent in the mutator (MUT).</p>
</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">-S</span></code> flag, as well as giving the same output as the <code class="docutils literal notranslate"><span class="pre">-s</span></code>
flag, prints information about each GC as it happens:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    Alloc    Copied     Live    GC    GC     TOT     TOT  Page Flts
    bytes     bytes     bytes  user  elap    user    elap
   528496     47728    141512  0.01  0.02    0.02    0.02    0    0  (Gen:  1)
[...]
   524944    175944   1726384  0.00  0.00    0.08    0.11    0    0  (Gen:  0)
</pre></div>
</div>
<p>For each garbage collection, we print:</p>
<ul class="simple">
<li><p>How many bytes we allocated this garbage collection.</p></li>
<li><p>How many bytes we copied this garbage collection.</p></li>
<li><p>How many bytes are currently live.</p></li>
<li><p>How long this garbage collection took (CPU time and elapsed wall
clock time).</p></li>
<li><p>How long the program has been running (CPU time and elapsed wall
clock time).</p></li>
<li><p>How many page faults occurred this garbage collection.</p></li>
<li><p>How many page faults occurred since the end of the last garbage
collection.</p></li>
<li><p>Which generation is being garbage collected.</p></li>
</ul>
</dd></dl>

</section>
<section id="rts-options-for-concurrency-and-parallelism">
<h2><span class="section-number">5.7.5. </span>RTS options for concurrency and parallelism<a class="headerlink" href="#rts-options-for-concurrency-and-parallelism" title="Permalink to this heading">¶</a></h2>
<p>The RTS options related to concurrency are described in
<a class="reference internal" href="using-concurrent.html#using-concurrent"><span class="std std-ref">Using Concurrent Haskell</span></a>, and those for parallelism in
<a class="reference internal" href="using-concurrent.html#parallel-options"><span class="std std-ref">RTS options for SMP parallelism</span></a>.</p>
</section>
<section id="rts-options-for-profiling">
<span id="rts-profiling"></span><h2><span class="section-number">5.7.6. </span>RTS options for profiling<a class="headerlink" href="#rts-options-for-profiling" title="Permalink to this heading">¶</a></h2>
<p>Most profiling runtime options are only available when you compile your
program for profiling (see <a class="reference internal" href="profiling.html#prof-compiler-options"><span class="std std-ref">Compiler options for profiling</span></a>, and
<a class="reference internal" href="profiling.html#rts-options-heap-prof"><span class="std std-ref">RTS options for heap profiling</span></a> for the runtime options). However, there is
one profiling option that is available for ordinary non-profiled
executables:</p>
<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-hT">
<span class="sig-name descname"><span class="pre">-hT</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-hT" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="rts-flag-h">
<span class="sig-name descname"><span class="pre">-h</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-h" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a basic heap profile, in the file <code class="file docutils literal notranslate"><span class="pre">prog.hp</span></code>. To produce the
heap profile graph, use <strong class="command">hp2ps</strong> (see <a class="reference internal" href="profiling.html#hp2ps"><span class="std std-ref">hp2ps – Rendering heap profiles to PostScript</span></a>). The basic heap
profile is broken down by data constructor, with other types of closures
(functions, thunks, etc.) grouped into broad categories (e.g. <code class="docutils literal notranslate"><span class="pre">FUN</span></code>,
<code class="docutils literal notranslate"><span class="pre">THUNK</span></code>). To get a more detailed profile, use the full profiling support
(<a class="reference internal" href="profiling.html#profiling"><span class="std std-ref">Profiling</span></a>). Can be shortened to <a class="reference internal" href="#rts-flag-h"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-h</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The meaning of the shortened <a class="reference internal" href="#rts-flag-h"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-h</span></code></a> is dependent on whether
your program was compiled for profiling.
(See <a class="reference internal" href="profiling.html#rts-options-heap-prof"><span class="std std-ref">RTS options for heap profiling</span></a> for details.)</p>
</div>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-L-n">
<span class="sig-name descname"><span class="pre">-L</span></span><span class="sig-prename descclassname"> <span class="pre">⟨n⟩</span></span><a class="headerlink" href="#rts-flag-L-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>25 characters</p>
</dd>
</dl>
<p>Sets the maximum length of the cost-centre names listed in the heap profile.</p>
</dd></dl>

</section>
<section id="tracing">
<span id="rts-eventlog"></span><h2><span class="section-number">5.7.7. </span>Tracing<a class="headerlink" href="#tracing" title="Permalink to this heading">¶</a></h2>
<p id="index-32">When the program is linked with the <a class="reference internal" href="phases.html#ghc-flag-eventlog"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-eventlog</span></code></a> option
(<a class="reference internal" href="phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a>), runtime events can be logged in several ways:</p>
<ul class="simple">
<li><p>In binary format to a file for later analysis by a variety of tools.
One such tool is
<a class="reference external" href="http://www.haskell.org/haskellwiki/ThreadScope">ThreadScope</a>,
which interprets the event log to produce a visual parallel execution
profile of the program.</p></li>
<li><p>In binary format to customized event log writer. This enables live
analysis of the events while the program is running.</p></li>
<li><p>As text to standard output, for debugging purposes.</p></li>
</ul>
<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-l-flags">
<span class="sig-name descname"><span class="pre">-l</span></span><span class="sig-prename descclassname"> <span class="pre">⟨flags⟩</span></span><a class="headerlink" href="#rts-flag-l-flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Log events in binary format. Without any ⟨flags⟩ specified, this
logs a default set of events, suitable for use with tools like ThreadScope.</p>
<p>Per default the events are written to <code class="file docutils literal notranslate"><em><span class="pre">program</span></em><span class="pre">.eventlog</span></code> though
the mechanism for writing event log data can be overridden with a custom
<cite>EventLogWriter</cite>.</p>
<p>For some special use cases you may want more control over which
events are included. The ⟨flags⟩ is a sequence of zero or more
characters indicating which classes of events to log. Currently
these the classes of events that can be enabled/disabled:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> — scheduler events, including Haskell thread creation and start/stop
events. Enabled by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> — GC events, including GC start/stop. Enabled by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> — non-moving garbage collector (see <a class="reference internal" href="#rts-flag-nonmoving-gc"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">--nonmoving-gc</span></code></a>)
events including start and end of the concurrent mark and census
information to characterise heap fragmentation. Disabled by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code> — parallel sparks (sampled). Enabled by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> — parallel sparks (fully accurate). Disabled by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code> — <a class="reference internal" href="profiling.html#ghc-flag-ticky"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">ticky-ticky</span> <span class="pre">profiler</span></code></a> events. Disabled by
default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> — user events. These are events emitted from Haskell code using
functions such as <code class="docutils literal notranslate"><span class="pre">Debug.Trace.traceEvent</span></code>. Enabled by default.</p></li>
</ul>
<p>You can disable specific classes, or enable/disable all classes at
once:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> — enable all event classes listed above</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-⟨x⟩</span></code> — disable the given class of events, for any event class listed above</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-a</span></code> — disable all classes</p></li>
</ul>
<p>For example, <code class="docutils literal notranslate"><span class="pre">-l-ag</span></code> would disable all event classes (<code class="docutils literal notranslate"><span class="pre">-a</span></code>) except for
GC events (<code class="docutils literal notranslate"><span class="pre">g</span></code>).</p>
<p>For spark events there are two modes: sampled and fully accurate.
There are various events in the life cycle of each spark, usually
just creating and running, but there are some more exceptional
possibilities. In the sampled mode the number of occurrences of each
kind of spark event is sampled at frequent intervals. In the fully
accurate mode every spark event is logged individually. The latter
has a higher runtime overhead and is not enabled by default.</p>
<p>The format of the log file is described in this users guide in
<a class="reference internal" href="eventlog-formats.html#eventlog-encodings"><span class="std std-ref">Eventlog encodings</span></a> It can be parsed in Haskell using the
<a class="reference external" href="http://hackage.haskell.org/package/ghc-events">ghc-events</a>
library. To dump the contents of a <code class="docutils literal notranslate"><span class="pre">.eventlog</span></code> file as text, use
the tool <code class="docutils literal notranslate"><span class="pre">ghc-events</span> <span class="pre">show</span></code> that comes with the
<a class="reference external" href="http://hackage.haskell.org/package/ghc-events">ghc-events</a>
package.</p>
<p>Each event is associated with a timestamp which is the number of
nanoseconds since the start of executation of the running program.
This is the elapsed time, not the CPU time.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-olfilename">
<span class="sig-name descname"><span class="pre">-ol⟨filename⟩</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-olfilename" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="file docutils literal notranslate"><span class="pre">⟨program⟩.eventlog</span></code></p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>8.8</p>
</dd>
</dl>
<p>Sets the destination for the eventlog produced with the
<a class="reference internal" href="#rts-flag-l-flags"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-l</span> <span class="pre">⟨flags⟩</span></code></a> flag.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-eventlog-flush-interval-seconds">
<span class="sig-name descname"><span class="pre">--eventlog-flush-interval</span></span><span class="sig-prename descclassname"><span class="pre">=⟨seconds⟩</span></span><a class="headerlink" href="#rts-flag-eventlog-flush-interval-seconds" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>disabled</p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>9.2</p>
</dd>
</dl>
<p>When enabled, the eventlog will be flushed periodically every
⟨seconds⟩. This can be useful in live-monitoring situations where the
eventlog is consumed in real-time by another process.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-v-flags">
<span class="sig-name descname"><span class="pre">-v</span></span><span class="sig-prename descclassname"> <span class="pre">[⟨flags⟩]</span></span><a class="headerlink" href="#rts-flag-v-flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Log events as text to standard output, instead of to the
<code class="docutils literal notranslate"><span class="pre">.eventlog</span></code> file. The ⟨flags⟩ are the same as for <code class="docutils literal notranslate"><span class="pre">-l</span></code>, with the
additional option <code class="docutils literal notranslate"><span class="pre">t</span></code> which indicates that the each event printed
should be preceded by a timestamp value (in the binary <code class="docutils literal notranslate"><span class="pre">.eventlog</span></code>
file, all events are automatically associated with a timestamp).</p>
</dd></dl>

<p>The debugging options <code class="docutils literal notranslate"><span class="pre">-Dx</span></code> also generate events which are logged
using the tracing framework. By default those events are dumped as text
to stdout (<code class="docutils literal notranslate"><span class="pre">-Dx</span></code> implies <code class="docutils literal notranslate"><span class="pre">-v</span></code>), but they may instead be stored in
the binary eventlog file by using the <code class="docutils literal notranslate"><span class="pre">-l</span></code> option.</p>
</section>
<section id="rts-options-for-hackers-debuggers-and-over-interested-souls">
<span id="rts-options-debugging"></span><h2><span class="section-number">5.7.8. </span>RTS options for hackers, debuggers, and over-interested souls<a class="headerlink" href="#rts-options-for-hackers-debuggers-and-over-interested-souls" title="Permalink to this heading">¶</a></h2>
<p id="index-33">These RTS options might be used (a) to avoid a GHC bug, (b) to see
“what’s really happening”, or (c) because you feel like it. Not
recommended for everyday use!</p>
<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-B">
<span class="sig-name descname"><span class="pre">-B</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-B" title="Permalink to this definition">¶</a></dt>
<dd><p>Sound the bell at the start of each garbage collection.</p>
<p>Oddly enough, people really do use this option! Our pal in Durham
(England), Paul Callaghan, writes: “Some people here use it for a
variety of purposes—honestly!—e.g., confirmation that the
code/machine is doing something, infinite loop detection, gauging
cost of recently added code. Certain people can even tell what stage
[the program] is in by the beep pattern. But the major use is for
annoying others in the same office…”</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-D-x">
<span class="sig-name descname"><span class="pre">-D</span></span><span class="sig-prename descclassname"> <span class="pre">⟨x⟩</span></span><a class="headerlink" href="#rts-flag-D-x" title="Permalink to this definition">¶</a></dt>
<dd><p>An RTS debugging flag; only available if the program was linked with
the <a class="reference internal" href="phases.html#ghc-flag-debug"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-debug</span></code></a> option. Various values of ⟨x⟩ are provided to enable
debug messages and additional runtime sanity checks in different
subsystems in the RTS, for example <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-Ds</span> <span class="pre">-RTS</span></code> enables debug
messages from the scheduler. Use <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-?</span></code> to find out which debug
flags are supported.</p>
<p>Full list of currently supported flags:</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Ds-DEBUG-scheduler">
<span class="sig-name descname"><span class="pre">-Ds</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">scheduler</span></span><a class="headerlink" href="#rts-flag-Ds-DEBUG-scheduler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Di-DEBUG-interpreter">
<span class="sig-name descname"><span class="pre">-Di</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">interpreter</span></span><a class="headerlink" href="#rts-flag-Di-DEBUG-interpreter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Dw-DEBUG-weak">
<span class="sig-name descname"><span class="pre">-Dw</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">weak</span></span><a class="headerlink" href="#rts-flag-Dw-DEBUG-weak" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-DG-DEBUG-gccafs">
<span class="sig-name descname"><span class="pre">-DG</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">gccafs</span></span><a class="headerlink" href="#rts-flag-DG-DEBUG-gccafs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Dg-DEBUG-gc">
<span class="sig-name descname"><span class="pre">-Dg</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">gc</span></span><a class="headerlink" href="#rts-flag-Dg-DEBUG-gc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Db-DEBUG-block">
<span class="sig-name descname"><span class="pre">-Db</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">block</span></span><a class="headerlink" href="#rts-flag-Db-DEBUG-block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-DS-DEBUG-sanity">
<span class="sig-name descname"><span class="pre">-DS</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">sanity</span></span><a class="headerlink" href="#rts-flag-DS-DEBUG-sanity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-DZ-DEBUG-zero-freed-memory-on-GC">
<span class="sig-name descname"><span class="pre">-DZ</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">zero</span> <span class="pre">freed</span> <span class="pre">memory</span> <span class="pre">on</span> <span class="pre">GC</span></span><a class="headerlink" href="#rts-flag-DZ-DEBUG-zero-freed-memory-on-GC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Dt-DEBUG-stable">
<span class="sig-name descname"><span class="pre">-Dt</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">stable</span></span><a class="headerlink" href="#rts-flag-Dt-DEBUG-stable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Dp-DEBUG-prof">
<span class="sig-name descname"><span class="pre">-Dp</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">prof</span></span><a class="headerlink" href="#rts-flag-Dp-DEBUG-prof" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Da-DEBUG-apply">
<span class="sig-name descname"><span class="pre">-Da</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">apply</span></span><a class="headerlink" href="#rts-flag-Da-DEBUG-apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Dl-DEBUG-linker">
<span class="sig-name descname"><span class="pre">-Dl</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">linker</span></span><a class="headerlink" href="#rts-flag-Dl-DEBUG-linker" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Dm-DEBUG-stm">
<span class="sig-name descname"><span class="pre">-Dm</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">stm</span></span><a class="headerlink" href="#rts-flag-Dm-DEBUG-stm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Dz-DEBUG-stack-squeezing">
<span class="sig-name descname"><span class="pre">-Dz</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">stack</span> <span class="pre">squeezing</span></span><a class="headerlink" href="#rts-flag-Dz-DEBUG-stack-squeezing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Dc-DEBUG-program-coverage">
<span class="sig-name descname"><span class="pre">-Dc</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">program</span> <span class="pre">coverage</span></span><a class="headerlink" href="#rts-flag-Dc-DEBUG-program-coverage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Dr-DEBUG-sparks">
<span class="sig-name descname"><span class="pre">-Dr</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">sparks</span></span><a class="headerlink" href="#rts-flag-Dr-DEBUG-sparks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-DC-DEBUG-compact">
<span class="sig-name descname"><span class="pre">-DC</span></span><span class="sig-prename descclassname">&#160; <span class="pre">DEBUG:</span> <span class="pre">compact</span></span><a class="headerlink" href="#rts-flag-DC-DEBUG-compact" title="Permalink to this definition">¶</a></dt>
<dd><p>Debug messages will be sent to the binary event log file instead of
stdout if the <a class="reference internal" href="#rts-flag-l-flags"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-l</span> <span class="pre">⟨flags⟩</span></code></a> option is added. This might be useful
for reducing the overhead of debug tracing.</p>
<p>To figure out what exactly they do, the least bad way is to grep the rts/ directory in
the ghc code for macros like <code class="docutils literal notranslate"><span class="pre">DEBUG(scheduler</span></code> or <code class="docutils literal notranslate"><span class="pre">DEBUG_scheduler</span></code>.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-r-file">
<span class="sig-name descname"><span class="pre">-r</span></span><span class="sig-prename descclassname"> <span class="pre">⟨file⟩</span></span><a class="headerlink" href="#rts-flag-r-file" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-34">Produce “ticky-ticky” statistics at the end of the program run (only
available if the program was linked with <a class="reference internal" href="phases.html#ghc-flag-debug"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-debug</span></code></a>). The ⟨file⟩
business works just like on the <a class="reference internal" href="#rts-flag-S-file"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-S</span> <span class="pre">[⟨file⟩]</span></code></a> RTS option, above.</p>
<p>For more information on ticky-ticky profiling, see
<a class="reference internal" href="profiling.html#ticky-ticky"><span class="std std-ref">Using “ticky-ticky” profiling (for implementors)</span></a>.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-xc">
<span class="sig-name descname"><span class="pre">-xc</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-xc" title="Permalink to this definition">¶</a></dt>
<dd><p>(Only available when the program is compiled for profiling.) When an
exception is raised in the program, this option causes a stack trace
to be dumped to <code class="docutils literal notranslate"><span class="pre">stderr</span></code>.</p>
<p>This can be particularly useful for debugging: if your program is
complaining about a <code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">[]</span></code> error and you haven’t got a clue
which bit of code is causing it, compiling with
<code class="docutils literal notranslate"><span class="pre">-prof</span> <span class="pre">-fprof-auto</span></code> (see <a class="reference internal" href="profiling.html#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a>) and running with <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-xc</span>
<span class="pre">-RTS</span></code> will tell you exactly the call stack at the point the error was
raised.</p>
<p>The output contains one report for each exception raised in the
program (the program might raise and catch several exceptions during
its execution), where each report looks something like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*** Exception raised (reporting due to +RTS -xc), stack trace:
  GHC.List.CAF
  --&gt; evaluated by: Main.polynomial.table_search,
  called from Main.polynomial.theta_index,
  called from Main.polynomial,
  called from Main.zonal_pressure,
  called from Main.make_pressure.p,
  called from Main.make_pressure,
  called from Main.compute_initial_state.p,
  called from Main.compute_initial_state,
  called from Main.CAF
  ...
</pre></div>
</div>
<p>The stack trace may often begin with something uninformative like
<code class="docutils literal notranslate"><span class="pre">GHC.List.CAF</span></code>; this is an artifact of GHC’s optimiser, which
lifts out exceptions to the top-level where the profiling system
assigns them to the cost centre “CAF”. However, <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-xc</span></code> doesn’t
just print the current stack, it looks deeper and reports the stack
at the time the CAF was evaluated, and it may report further stacks
until a non-CAF stack is found. In the example above, the next stack
(after <code class="docutils literal notranslate"><span class="pre">--&gt;</span> <span class="pre">evaluated</span> <span class="pre">by</span></code>) contains plenty of information about
what the program was doing when it evaluated <code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">[]</span></code>.</p>
<p>Implementation details aside, the function names in the stack should
hopefully give you enough clues to track down the bug.</p>
<p>See also the function <code class="docutils literal notranslate"><span class="pre">traceStack</span></code> in the module <code class="docutils literal notranslate"><span class="pre">Debug.Trace</span></code>
for another way to view call stacks.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-Z">
<span class="sig-name descname"><span class="pre">-Z</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-Z" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn <em>off</em> update frame squeezing on context switch.
(There’s no particularly good reason to turn it off, except to
ensure the accuracy of certain data collected regarding thunk entry
counts.)</p>
</dd></dl>

</section>
<section id="getting-information-about-the-rts">
<span id="ghc-info"></span><h2><span class="section-number">5.7.9. </span>Getting information about the RTS<a class="headerlink" href="#getting-information-about-the-rts" title="Permalink to this heading">¶</a></h2>
<span class="target" id="index-35"></span><dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-info">
<span class="sig-name descname"><span class="pre">--info</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-info" title="Permalink to this definition">¶</a></dt>
<dd><p>It is possible to ask the RTS to give some information about itself. To
do this, use the <a class="reference internal" href="#rts-flag-info"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">--info</span></code></a> flag, e.g.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./a.out +RTS --info
[(&quot;GHC RTS&quot;, &quot;YES&quot;)
,(&quot;GHC version&quot;, &quot;6.7&quot;)
,(&quot;RTS way&quot;, &quot;rts_p&quot;)
,(&quot;Host platform&quot;, &quot;x86_64-unknown-linux&quot;)
,(&quot;Host architecture&quot;, &quot;x86_64&quot;)
,(&quot;Host OS&quot;, &quot;linux&quot;)
,(&quot;Host vendor&quot;, &quot;unknown&quot;)
,(&quot;Build platform&quot;, &quot;x86_64-unknown-linux&quot;)
,(&quot;Build architecture&quot;, &quot;x86_64&quot;)
,(&quot;Build OS&quot;, &quot;linux&quot;)
,(&quot;Build vendor&quot;, &quot;unknown&quot;)
,(&quot;Target platform&quot;, &quot;x86_64-unknown-linux&quot;)
,(&quot;Target architecture&quot;, &quot;x86_64&quot;)
,(&quot;Target OS&quot;, &quot;linux&quot;)
,(&quot;Target vendor&quot;, &quot;unknown&quot;)
,(&quot;Word size&quot;, &quot;64&quot;)
,(&quot;Compiler unregisterised&quot;, &quot;NO&quot;)
,(&quot;Tables next to code&quot;, &quot;YES&quot;)
,(&quot;Flag -with-rtsopts&quot;, &quot;&quot;)
]
</pre></div>
</div>
<p>The information is formatted such that it can be read as a of type
<code class="docutils literal notranslate"><span class="pre">[(String,</span> <span class="pre">String)]</span></code>. Currently the following fields are present:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GHC</span> <span class="pre">RTS</span></code></dt><dd><p>Is this program linked against the GHC RTS? (always “YES”).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GHC</span> <span class="pre">version</span></code></dt><dd><p>The version of GHC used to compile this program.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RTS</span> <span class="pre">way</span></code></dt><dd><p>The variant (“way”) of the runtime. The most common values are
<code class="docutils literal notranslate"><span class="pre">rts_v</span></code> (vanilla), <code class="docutils literal notranslate"><span class="pre">rts_thr</span></code> (threaded runtime, i.e. linked
using the <a class="reference internal" href="phases.html#ghc-flag-threaded"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-threaded</span></code></a> option) and <code class="docutils literal notranslate"><span class="pre">rts_p</span></code> (profiling runtime,
i.e. linked using the <a class="reference internal" href="profiling.html#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a> option). Other variants include
<code class="docutils literal notranslate"><span class="pre">debug</span></code> (linked using <a class="reference internal" href="phases.html#ghc-flag-debug"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-debug</span></code></a>), and <code class="docutils literal notranslate"><span class="pre">dyn</span></code> (the RTS is linked
in dynamically, i.e. a shared library, rather than statically linked
into the executable itself). These can be combined, e.g. you might
have <code class="docutils literal notranslate"><span class="pre">rts_thr_debug_p</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Target</span> <span class="pre">platform</span></code><code class="docutils literal notranslate"><span class="pre">Target</span> <span class="pre">architecture</span></code><code class="docutils literal notranslate"><span class="pre">Target</span> <span class="pre">OS</span></code><code class="docutils literal notranslate"><span class="pre">Target</span> <span class="pre">vendor</span></code></dt><dd><p>These are the platform the program is compiled to run on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Build</span> <span class="pre">platform</span></code><code class="docutils literal notranslate"><span class="pre">Build</span> <span class="pre">architecture</span></code><code class="docutils literal notranslate"><span class="pre">Build</span> <span class="pre">OS</span></code><code class="docutils literal notranslate"><span class="pre">Build</span> <span class="pre">vendor</span></code></dt><dd><p>These are the platform where the program was built on. (That is, the
target platform of GHC itself.) Ordinarily this is identical to the
target platform. (It could potentially be different if
cross-compiling.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Host</span> <span class="pre">platform</span></code><code class="docutils literal notranslate"><span class="pre">Host</span> <span class="pre">architecture</span></code><code class="docutils literal notranslate"><span class="pre">Host</span> <span class="pre">OS</span></code><code class="docutils literal notranslate"><span class="pre">Host</span> <span class="pre">vendor</span></code></dt><dd><p>These are the platform where GHC itself was compiled. Again, this
would normally be identical to the build and target platforms.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Word</span> <span class="pre">size</span></code></dt><dd><p>Either <code class="docutils literal notranslate"><span class="pre">&quot;32&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;64&quot;</span></code>, reflecting the word size of the target
platform.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Compiler</span> <span class="pre">unregistered</span></code></dt><dd><p>Was this program compiled with an <a class="reference internal" href="codegens.html#unreg"><span class="std std-ref">“unregistered”</span></a>
version of GHC? (I.e., a version of GHC that has no
platform-specific optimisations compiled in, usually because this is
a currently unsupported platform.) This value will usually be no,
unless you’re using an experimental build of GHC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Tables</span> <span class="pre">next</span> <span class="pre">to</span> <span class="pre">code</span></code></dt><dd><p>Putting info tables directly next to entry code is a useful
performance optimisation that is not available on all platforms.
This field tells you whether the program has been compiled with this
optimisation. (Usually yes, except on unusual platforms.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Flag</span> <span class="pre">-with-rtsopts</span></code></dt><dd><p>The value of the GHC flag <a class="reference internal" href="phases.html#ghc-flag-with-rtsopts-opts"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-with-rtsopts=⟨opts⟩</span></code></a> at compile/link time.</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="separate_compilation.html" class="btn btn-neutral float-right" title="5.8. Filenames and separate compilation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="flags.html" class="btn btn-neutral float-left" title="5.6. Flag reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
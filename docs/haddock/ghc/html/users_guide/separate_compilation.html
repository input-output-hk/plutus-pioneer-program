

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>5.8. Filenames and separate compilation &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5.9. Packages" href="packages.html" />
    <link rel="prev" title="5.7. Running a compiled program" href="runtime_control.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="runghc.html">4. Using runghc</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="usage.html">5. Using GHC</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="using.html">5.1. Using GHC</a></li>
<li class="toctree-l2"><a class="reference internal" href="using-warnings.html">5.2. Warnings and sanity-checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="using-optimisation.html">5.3. Optimisation (code improvement)</a></li>
<li class="toctree-l2"><a class="reference internal" href="using-concurrent.html">5.4. Using Concurrent Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="using-concurrent.html#using-smp-parallelism">5.5. Using SMP parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="flags.html">5.6. Flag reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="runtime_control.html">5.7. Running a compiled program</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5.8. Filenames and separate compilation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#haskell-source-files">5.8.1. Haskell source files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#output-files">5.8.2. Output files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-search-path">5.8.3. The search path</a></li>
<li class="toctree-l3"><a class="reference internal" href="#redirecting-the-compilation-output-s">5.8.4. Redirecting the compilation output(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#keeping-intermediate-files">5.8.5. Keeping Intermediate Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#redirecting-temporary-files">5.8.6. Redirecting temporary files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-options-related-to-interface-files">5.8.7. Other options related to interface files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#options-related-to-extended-interface-files">5.8.8. Options related to extended interface files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-recompilation-checker">5.8.9. The recompilation checker</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-to-compile-mutually-recursive-modules">5.8.10. How to compile mutually recursive modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-signatures">5.8.11. Module signatures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-make">5.8.12. Using <code class="docutils literal notranslate"><span class="pre">make</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#dependency-generation">5.8.13. Dependency generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#orphan-modules-and-instance-declarations">5.8.14. Orphan modules and instance declarations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="packages.html">5.9. Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="codegens.html">5.10. GHC Backends</a></li>
<li class="toctree-l2"><a class="reference internal" href="phases.html">5.11. Options related to a particular phase</a></li>
<li class="toctree-l2"><a class="reference internal" href="shared_libs.html">5.12. Using shared libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging.html">5.13. Debugging the compiler</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="exts.html">6. Language extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="usage.html"><span class="section-number">5. </span>Using GHC</a> &raquo;</li>
        
      <li><span class="section-number">5.8. </span>Filenames and separate compilation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/separate_compilation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="filenames-and-separate-compilation">
<span id="separate-compilation"></span><h1><span class="section-number">5.8. </span>Filenames and separate compilation<a class="headerlink" href="#filenames-and-separate-compilation" title="Permalink to this heading">¶</a></h1>
<p id="index-0">This section describes what files GHC expects to find, what files it
creates, where these files are stored, and what options affect this
behaviour.</p>
<p>Pathname conventions vary from system to system. In particular, the
directory separator is “<code class="docutils literal notranslate"><span class="pre">/</span></code>” on Unix systems and “<code class="docutils literal notranslate"><span class="pre">\</span></code>” on
Windows systems. In the sections that follow, we shall consistently use
“<code class="docutils literal notranslate"><span class="pre">/</span></code>” as the directory separator; substitute this for the
appropriate character for your system.</p>
<section id="haskell-source-files">
<span id="source-files"></span><h2><span class="section-number">5.8.1. </span>Haskell source files<a class="headerlink" href="#haskell-source-files" title="Permalink to this heading">¶</a></h2>
<p id="index-1">Each Haskell source module should be placed in a file on its own.</p>
<p>Usually, the file should be named after the module name, replacing dots
in the module name by directory separators. For example, on a Unix
system, the module <code class="docutils literal notranslate"><span class="pre">A.B.C</span></code> should be placed in the file <code class="docutils literal notranslate"><span class="pre">A/B/C.hs</span></code>,
relative to some base directory. If the module is not going to be
imported by another module (<code class="docutils literal notranslate"><span class="pre">Main</span></code>, for example), then you are free to
use any filename for it.</p>
<p id="index-2">GHC assumes that source files are ASCII or UTF-8 only, other
encoding are not recognised. However, invalid UTF-8 sequences
will be ignored in comments, so it is possible to use other encodings
such as Latin-1, as long as the non-comment source code is ASCII
only.</p>
</section>
<section id="output-files">
<span id="id1"></span><h2><span class="section-number">5.8.2. </span>Output files<a class="headerlink" href="#output-files" title="Permalink to this heading">¶</a></h2>
<p id="index-3">When asked to compile a source file, GHC normally generates two files:
an object file, and an interface file.</p>
<p>The object file, which normally ends in a <code class="docutils literal notranslate"><span class="pre">.o</span></code> suffix, contains the
compiled code for the module.</p>
<p>The interface file, which normally ends in a <code class="docutils literal notranslate"><span class="pre">.hi</span></code> suffix, contains the
information that GHC needs in order to compile further modules that depend on
this module. It contains things like the types of exported functions,
definitions of data types, and so on. It is stored in a binary format, so don’t
try to read one; use the <a class="reference internal" href="using.html#ghc-flag-show-iface-file"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">--show-iface</span> <span class="pre">⟨file⟩</span></code></a> option instead (see
<a class="reference internal" href="#hi-options"><span class="std std-ref">Other options related to interface files</span></a>).</p>
<p>You should think of the object file and the interface file as a pair,
since the interface file is in a sense a compiler-readable description
of the contents of the object file. If the interface file and object
file get out of sync for any reason, then the compiler may end up making
assumptions about the object file that aren’t true; trouble will almost
certainly follow. For this reason, we recommend keeping object files and
interface files in the same place (GHC does this by default, but it is
possible to override the defaults as we’ll explain shortly).</p>
<p>Every module has a <em>module name</em> defined in its source code
(<code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">A.B.C</span> <span class="pre">where</span> <span class="pre">...</span></code>).</p>
<p>The name of the object file generated by GHC is derived according to the
following rules, where ⟨osuf⟩ is the object-file suffix (this can be
changed with the <code class="docutils literal notranslate"><span class="pre">-osuf</span></code> option).</p>
<ul class="simple">
<li><p>If there is no <code class="docutils literal notranslate"><span class="pre">-odir</span></code> option (the default), then the object
filename is derived from the source filename (ignoring the module
name) by replacing the suffix with ⟨osuf⟩.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">-odir</span> <span class="pre">⟨dir⟩</span></code> has been specified, then the object filename is
⟨dir⟩/⟨mod⟩.⟨osuf⟩, where ⟨mod⟩ is the module name with dots replaced
by slashes. GHC will silently create the necessary directory
structure underneath ⟨dir⟩, if it does not already exist.</p></li>
</ul>
<p>The name of the interface file is derived using the same rules, except that the
suffix is ⟨hisuf⟩ (<code class="docutils literal notranslate"><span class="pre">.hi</span></code> by default) instead of ⟨osuf⟩, and the relevant
options are <a class="reference internal" href="#ghc-flag-hidir-dir"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-hidir</span> <span class="pre">⟨dir⟩</span></code></a> and <a class="reference internal" href="#ghc-flag-hisuf-suffix"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-hisuf</span> <span class="pre">⟨suffix⟩</span></code></a> instead of
<a class="reference internal" href="#ghc-flag-odir-dir"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-odir</span> <span class="pre">⟨dir⟩</span></code></a> and <a class="reference internal" href="#ghc-flag-osuf-suffix"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-osuf</span> <span class="pre">⟨suffix⟩</span></code></a> respectively.</p>
<p>For example, if GHC compiles the module <code class="docutils literal notranslate"><span class="pre">A.B.C</span></code> in the file
<code class="docutils literal notranslate"><span class="pre">src/A/B/C.hs</span></code>, with no <code class="docutils literal notranslate"><span class="pre">-odir</span></code> or <code class="docutils literal notranslate"><span class="pre">-hidir</span></code> flags, the interface
file will be put in <code class="docutils literal notranslate"><span class="pre">src/A/B/C.hi</span></code> and the object file in
<code class="docutils literal notranslate"><span class="pre">src/A/B/C.o</span></code>.</p>
<p>For any module that is imported, GHC requires that the name of the
module in the import statement exactly matches the name of the module in
the interface file (or source file) found using the strategy specified
in <a class="reference internal" href="#search-path"><span class="std std-ref">The search path</span></a>. This means that for most modules, the source file
name should match the module name.</p>
<p>However, note that it is reasonable to have a module <code class="docutils literal notranslate"><span class="pre">Main</span></code> in a file
named <code class="docutils literal notranslate"><span class="pre">foo.hs</span></code>, but this only works because GHC never needs to search
for the interface for module <code class="docutils literal notranslate"><span class="pre">Main</span></code> (because it is never imported). It
is therefore possible to have several <code class="docutils literal notranslate"><span class="pre">Main</span></code> modules in separate
source files in the same directory, and GHC will not get confused.</p>
<p>In batch compilation mode, the name of the object file can also be overridden
using the <a class="reference internal" href="#ghc-flag-o-file"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-o</span> <span class="pre">⟨file⟩</span></code></a> option, and the name of the interface file can
be specified directly using the <a class="reference internal" href="#ghc-flag-ohi-file"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ohi</span> <span class="pre">⟨file⟩</span></code></a> option.</p>
</section>
<section id="the-search-path">
<span id="search-path"></span><h2><span class="section-number">5.8.3. </span>The search path<a class="headerlink" href="#the-search-path" title="Permalink to this heading">¶</a></h2>
<p id="index-4">In your program, you import a module <code class="docutils literal notranslate"><span class="pre">Foo</span></code> by saying <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">Foo</span></code>.
In <a class="reference internal" href="using.html#ghc-flag-make"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">--make</span></code></a> mode or GHCi, GHC will look for a source file for <code class="docutils literal notranslate"><span class="pre">Foo</span></code>
and arrange to compile it first. Without <a class="reference internal" href="using.html#ghc-flag-make"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">--make</span></code></a>, GHC will look for
the interface file for <code class="docutils literal notranslate"><span class="pre">Foo</span></code>, which should have been created by an
earlier compilation of <code class="docutils literal notranslate"><span class="pre">Foo</span></code>. GHC uses the same strategy in each of
these cases for finding the appropriate file.</p>
<p>This strategy is as follows: GHC keeps a list of directories called the
search path. For each of these directories, it tries appending
<code class="docutils literal notranslate"><span class="pre">⟨basename⟩.⟨extension⟩</span></code> to the directory, and checks whether the
file exists. The value of ⟨basename⟩ is the module name with dots
replaced by the directory separator (”<code class="docutils literal notranslate"><span class="pre">/</span></code>” or “<code class="docutils literal notranslate"><span class="pre">\\&quot;</span></code>, depending on the
system), and ⟨extension⟩ is a source extension (<code class="docutils literal notranslate"><span class="pre">hs</span></code>, <code class="docutils literal notranslate"><span class="pre">lhs</span></code>) if we
are in <a class="reference internal" href="using.html#ghc-flag-make"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">--make</span></code></a> mode or GHCi, or ⟨hisuf⟩ otherwise.</p>
<p>For example, suppose the search path contains directories <code class="docutils literal notranslate"><span class="pre">d1</span></code>,
<code class="docutils literal notranslate"><span class="pre">d2</span></code>, and <code class="docutils literal notranslate"><span class="pre">d3</span></code>, and we are in <a class="reference internal" href="using.html#ghc-flag-make"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">--make</span></code></a> mode looking for the source
file for a module <code class="docutils literal notranslate"><span class="pre">A.B.C</span></code>. GHC will look in <code class="docutils literal notranslate"><span class="pre">d1/A/B/C.hs</span></code>,
<code class="docutils literal notranslate"><span class="pre">d1/A/B/C.lhs</span></code>, <code class="docutils literal notranslate"><span class="pre">d2/A/B/C.hs</span></code>, and so on.</p>
<p>The search path by default contains a single directory: “<code class="docutils literal notranslate"><span class="pre">.</span></code>” (i.e. the
current directory). The following options can be used to add to or change the
contents of the search path:</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-idir-dir">
<span class="sig-name descname"><span class="pre">-i⟨dir⟩</span></span><span class="sig-prename descclassname"><span class="pre">[:⟨dir⟩]*</span></span><a class="headerlink" href="#ghc-flag-idir-dir" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-5">This flag appends a colon-separated list of <code class="docutils literal notranslate"><span class="pre">dirs</span></code> to
the search path.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-i">
<span class="sig-name descname"><span class="pre">-i</span></span><a class="headerlink" href="#ghc-flag-i" title="Permalink to this definition">¶</a></dt>
<dd><p>resets the search path back to nothing.</p>
</dd></dl>

<p>This isn’t the whole story: GHC also looks for modules in pre-compiled
libraries, known as packages. See the section on packages
(<a class="reference internal" href="packages.html#packages"><span class="std std-ref">Packages</span></a>) for details.</p>
</section>
<section id="redirecting-the-compilation-output-s">
<span id="options-output"></span><h2><span class="section-number">5.8.4. </span>Redirecting the compilation output(s)<a class="headerlink" href="#redirecting-the-compilation-output-s" title="Permalink to this heading">¶</a></h2>
<span class="target" id="index-6"></span><dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-o-file">
<span class="sig-name descname"><span class="pre">-o</span></span><span class="sig-prename descclassname"> <span class="pre">⟨file⟩</span></span><a class="headerlink" href="#ghc-flag-o-file" title="Permalink to this definition">¶</a></dt>
<dd><p>GHC’s compiled output normally goes into a <code class="docutils literal notranslate"><span class="pre">.hc</span></code>, <code class="docutils literal notranslate"><span class="pre">.o</span></code>, etc.,
file, depending on the last-run compilation phase. The option
<code class="docutils literal notranslate"><span class="pre">-o</span> <span class="pre">file</span></code> re-directs the output of that last-run phase to ⟨file⟩.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This “feature” can be counterintuitive: <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-C</span> <span class="pre">-o</span> <span class="pre">foo.o</span> <span class="pre">foo.hs</span></code>
will put the intermediate C code in the file <code class="docutils literal notranslate"><span class="pre">foo.o</span></code>, name
notwithstanding!</p>
</div>
<p>This option is most often used when creating an executable file, to
set the filename of the executable. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghc -o prog --make Main
</pre></div>
</div>
<p>will compile the program starting with module <code class="docutils literal notranslate"><span class="pre">Main</span></code> and put the
executable in the file <code class="docutils literal notranslate"><span class="pre">prog</span></code>.</p>
<p>Note: on Windows, if the result is an executable file, the extension
“<code class="docutils literal notranslate"><span class="pre">.exe</span></code>” is added if the specified filename does not already have
an extension. Thus</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghc -o foo Main.hs
</pre></div>
</div>
<p>will compile and link the module <code class="docutils literal notranslate"><span class="pre">Main.hs</span></code>, and put the resulting
executable in <code class="docutils literal notranslate"><span class="pre">foo.exe</span></code> (not <code class="docutils literal notranslate"><span class="pre">foo</span></code>).</p>
<p>If you use <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">--make</span></code> and you don’t use the <code class="docutils literal notranslate"><span class="pre">-o</span></code>, the name GHC
will choose for the executable will be based on the name of the file
containing the module <code class="docutils literal notranslate"><span class="pre">Main</span></code>. Note that with GHC the <code class="docutils literal notranslate"><span class="pre">Main</span></code>
module doesn’t have to be put in file <code class="docutils literal notranslate"><span class="pre">Main.hs</span></code>. Thus both</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghc --make Prog
</pre></div>
</div>
<p>and</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghc --make Prog.hs
</pre></div>
</div>
<p>will produce <code class="docutils literal notranslate"><span class="pre">Prog</span></code> (or <code class="docutils literal notranslate"><span class="pre">Prog.exe</span></code> if you are on Windows).</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-dyno-file">
<span class="sig-name descname"><span class="pre">-dyno</span></span><span class="sig-prename descclassname"> <span class="pre">⟨file⟩</span></span><a class="headerlink" href="#ghc-flag-dyno-file" title="Permalink to this definition">¶</a></dt>
<dd><p>When using <code class="docutils literal notranslate"><span class="pre">-dynamic-too</span></code>, option <code class="docutils literal notranslate"><span class="pre">-dyno</span></code> ⟨suffix⟩ is the
counterpart of <code class="docutils literal notranslate"><span class="pre">-o</span></code>. It redirects the dynamic output to ⟨file⟩.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-odir-dir">
<span class="sig-name descname"><span class="pre">-odir</span></span><span class="sig-prename descclassname"> <span class="pre">⟨dir⟩</span></span><a class="headerlink" href="#ghc-flag-odir-dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Redirects object files to directory ⟨dir⟩. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ghc -c parse/Foo.hs parse/Bar.hs gurgle/Bumble.hs -odir `uname -m`
</pre></div>
</div>
<p>The object files, <code class="docutils literal notranslate"><span class="pre">Foo.o</span></code>, <code class="docutils literal notranslate"><span class="pre">Bar.o</span></code>, and <code class="docutils literal notranslate"><span class="pre">Bumble.o</span></code> would be
put into a subdirectory named after the architecture of the
executing machine (<code class="docutils literal notranslate"><span class="pre">x86</span></code>, <code class="docutils literal notranslate"><span class="pre">mips</span></code>, etc).</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">-odir</span></code> option does <em>not</em> affect where the interface
files are put; use the <code class="docutils literal notranslate"><span class="pre">-hidir</span></code> option for that. In the above
example, they would still be put in <code class="docutils literal notranslate"><span class="pre">parse/Foo.hi</span></code>,
<code class="docutils literal notranslate"><span class="pre">parse/Bar.hi</span></code>, and <code class="docutils literal notranslate"><span class="pre">gurgle/Bumble.hi</span></code>.</p>
<p>Please also note that when doing incremental compilation, this directory is
where GHC looks into to find object files from previous builds.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ohi-file">
<span class="sig-name descname"><span class="pre">-ohi</span></span><span class="sig-prename descclassname"> <span class="pre">⟨file⟩</span></span><a class="headerlink" href="#ghc-flag-ohi-file" title="Permalink to this definition">¶</a></dt>
<dd><p>The interface output may be directed to another file
<code class="docutils literal notranslate"><span class="pre">bar2/Wurble.iface</span></code> with the option <code class="docutils literal notranslate"><span class="pre">-ohi</span> <span class="pre">bar2/Wurble.iface</span></code>
(not recommended).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If you redirect the interface file somewhere that GHC can’t
find it, then the recompilation checker may get confused (at the
least, you won’t get any recompilation avoidance). We recommend
using a combination of <code class="docutils literal notranslate"><span class="pre">-hidir</span></code> and <code class="docutils literal notranslate"><span class="pre">-hisuf</span></code> options instead, if
possible.</p>
</div>
<p>To avoid generating an interface at all, you could use this option
to redirect the interface into the bit bucket: <code class="docutils literal notranslate"><span class="pre">-ohi</span> <span class="pre">/dev/null</span></code>,
for example.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-dynohi-file">
<span class="sig-name descname"><span class="pre">-dynohi</span></span><span class="sig-prename descclassname"> <span class="pre">⟨file⟩</span></span><a class="headerlink" href="#ghc-flag-dynohi-file" title="Permalink to this definition">¶</a></dt>
<dd><p>When using <code class="docutils literal notranslate"><span class="pre">-dynamic-too</span></code>, option <code class="docutils literal notranslate"><span class="pre">-dynohi</span></code> ⟨file⟩ is the counterpart
of <code class="docutils literal notranslate"><span class="pre">-ohi</span></code>. It redirects the dynamic interface output to ⟨file⟩.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-hidir-dir">
<span class="sig-name descname"><span class="pre">-hidir</span></span><span class="sig-prename descclassname"> <span class="pre">⟨dir⟩</span></span><a class="headerlink" href="#ghc-flag-hidir-dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Redirects all generated interface files into ⟨dir⟩, instead of the
default.</p>
<p>Please also note that when doing incremental compilation (by <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">--make</span></code>
or <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-c</span></code>), this directory is where GHC looks into to find interface
files.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-hiedir-dir">
<span class="sig-name descname"><span class="pre">-hiedir</span></span><span class="sig-prename descclassname"> <span class="pre">⟨dir⟩</span></span><a class="headerlink" href="#ghc-flag-hiedir-dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Redirects all generated extended interface files into ⟨dir⟩, instead of
the default.</p>
<p>Please also note that when doing incremental compilation (by <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">--make</span></code>
or <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-c</span></code>), this directory is where GHC looks into to find extended
interface files.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-stubdir-dir">
<span class="sig-name descname"><span class="pre">-stubdir</span></span><span class="sig-prename descclassname"> <span class="pre">⟨dir⟩</span></span><a class="headerlink" href="#ghc-flag-stubdir-dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Redirects all generated FFI stub files into ⟨dir⟩. Stub files are
generated when the Haskell source contains a <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">export</span></code> or
<code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">&quot;&amp;wrapper&quot;</span></code> declaration (see
<a class="reference internal" href="exts/ffi.html#foreign-export-ghc"><span class="std std-ref">Using foreign export and foreign import ccall &quot;wrapper&quot; with GHC</span></a>). The <code class="docutils literal notranslate"><span class="pre">-stubdir</span></code> option behaves in
exactly the same way as <code class="docutils literal notranslate"><span class="pre">-odir</span></code> and <code class="docutils literal notranslate"><span class="pre">-hidir</span></code> with respect to
hierarchical modules.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-dumpdir-dir">
<span class="sig-name descname"><span class="pre">-dumpdir</span></span><span class="sig-prename descclassname"> <span class="pre">⟨dir⟩</span></span><a class="headerlink" href="#ghc-flag-dumpdir-dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Redirects all dump files into ⟨dir⟩. Dump files are generated when
<code class="docutils literal notranslate"><span class="pre">-ddump-to-file</span></code> is used with other <code class="docutils literal notranslate"><span class="pre">-ddump-*</span></code> flags.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-outputdir-dir">
<span class="sig-name descname"><span class="pre">-outputdir</span></span><span class="sig-prename descclassname"> <span class="pre">⟨dir⟩</span></span><a class="headerlink" href="#ghc-flag-outputdir-dir" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">-outputdir</span></code> option is shorthand for the combination of
<a class="reference internal" href="#ghc-flag-odir-dir"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-odir</span> <span class="pre">⟨dir⟩</span></code></a>, <a class="reference internal" href="#ghc-flag-hidir-dir"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-hidir</span> <span class="pre">⟨dir⟩</span></code></a>, <a class="reference internal" href="#ghc-flag-hiedir-dir"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-hiedir</span> <span class="pre">⟨dir⟩</span></code></a>,
<a class="reference internal" href="#ghc-flag-stubdir-dir"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-stubdir</span> <span class="pre">⟨dir⟩</span></code></a> and <a class="reference internal" href="#ghc-flag-dumpdir-dir"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-dumpdir</span> <span class="pre">⟨dir⟩</span></code></a>.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-osuf-suffix">
<span class="sig-name descname"><span class="pre">-osuf</span></span><span class="sig-prename descclassname"> <span class="pre">⟨suffix⟩</span></span><a class="headerlink" href="#ghc-flag-osuf-suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">-osuf</span></code> ⟨suffix⟩ will change the <code class="docutils literal notranslate"><span class="pre">.o</span></code> file suffix for object
files to whatever you specify. We use this when compiling libraries,
so that objects for the profiling versions of the libraries don’t
clobber the normal ones.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-dynosuf-suffix">
<span class="sig-name descname"><span class="pre">-dynosuf</span></span><span class="sig-prename descclassname"> <span class="pre">⟨suffix⟩</span></span><a class="headerlink" href="#ghc-flag-dynosuf-suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>When using <code class="docutils literal notranslate"><span class="pre">-dynamic-too</span></code>, option <code class="docutils literal notranslate"><span class="pre">-dynosuf</span></code> ⟨suffix⟩ is the
counterpart of <code class="docutils literal notranslate"><span class="pre">-osuf</span></code>. It changes the <code class="docutils literal notranslate"><span class="pre">.dyn_o</span></code> file suffix
for dynamic object files.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-hisuf-suffix">
<span class="sig-name descname"><span class="pre">-hisuf</span></span><span class="sig-prename descclassname"> <span class="pre">⟨suffix⟩</span></span><a class="headerlink" href="#ghc-flag-hisuf-suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Similarly, the <code class="docutils literal notranslate"><span class="pre">-hisuf</span></code> ⟨suffix⟩ will change the <code class="docutils literal notranslate"><span class="pre">.hi</span></code> file
suffix for non-system interface files (see <a class="reference internal" href="#hi-options"><span class="std std-ref">Other options related to interface files</span></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">-hisuf</span></code>/<code class="docutils literal notranslate"><span class="pre">-osuf</span></code> game is particularly useful if you want to
compile a program both with and without profiling, in the same
directory. You can say:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghc ...
</pre></div>
</div>
<p>to get the ordinary version, and</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghc ... -osuf prof.o -hisuf prof.hi -prof -fprof-auto
</pre></div>
</div>
<p>to get the profiled version.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-dynhisuf-suffix">
<span class="sig-name descname"><span class="pre">-dynhisuf</span></span><span class="sig-prename descclassname"> <span class="pre">⟨suffix⟩</span></span><a class="headerlink" href="#ghc-flag-dynhisuf-suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>When using <code class="docutils literal notranslate"><span class="pre">-dynamic-too</span></code>, option <code class="docutils literal notranslate"><span class="pre">-dynhisuf</span></code> ⟨suffix⟩ is the
counterpart of <code class="docutils literal notranslate"><span class="pre">-hisuf</span></code>. It changes the <code class="docutils literal notranslate"><span class="pre">.dyn_hi</span></code> file suffix
for dynamic interface files.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-hiesuf-suffix">
<span class="sig-name descname"><span class="pre">-hiesuf</span></span><span class="sig-prename descclassname"> <span class="pre">⟨suffix⟩</span></span><a class="headerlink" href="#ghc-flag-hiesuf-suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">-hiesuf</span></code> ⟨suffix⟩ will change the <code class="docutils literal notranslate"><span class="pre">.hie</span></code> file suffix for
extended interface files to whatever you specify.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-hcsuf-suffix">
<span class="sig-name descname"><span class="pre">-hcsuf</span></span><span class="sig-prename descclassname"> <span class="pre">⟨suffix⟩</span></span><a class="headerlink" href="#ghc-flag-hcsuf-suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Finally, the option <code class="docutils literal notranslate"><span class="pre">-hcsuf</span></code> ⟨suffix⟩ will change the <code class="docutils literal notranslate"><span class="pre">.hc</span></code> file
suffix for compiler-generated intermediate C files.</p>
</dd></dl>

</section>
<section id="keeping-intermediate-files">
<span id="keeping-intermediates"></span><h2><span class="section-number">5.8.5. </span>Keeping Intermediate Files<a class="headerlink" href="#keeping-intermediate-files" title="Permalink to this heading">¶</a></h2>
<p id="index-7">The following options are useful for keeping (or not keeping) certain
intermediate files around, when normally GHC would throw these away after
compilation:</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-keep-hc-file">
<span class="sig-name descname"><span class="pre">-keep-hc-file</span></span><a class="headerlink" href="#ghc-flag-keep-hc-file" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="ghc-flag-keep-hc-files">
<span class="sig-name descname"><span class="pre">-keep-hc-files</span></span><a class="headerlink" href="#ghc-flag-keep-hc-files" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep intermediate <code class="docutils literal notranslate"><span class="pre">.hc</span></code> files when doing <code class="docutils literal notranslate"><span class="pre">.hs</span></code>-to-<code class="docutils literal notranslate"><span class="pre">.o</span></code>
compilations via <a class="reference internal" href="codegens.html#c-code-gen"><span class="std std-ref">C</span></a> (Note: <code class="docutils literal notranslate"><span class="pre">.hc</span></code> files are only
generated by <a class="reference internal" href="codegens.html#unreg"><span class="std std-ref">unregisterised</span></a> compilers).</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-keep-hi-files">
<span class="sig-name descname"><span class="pre">-keep-hi-files</span></span><a class="headerlink" href="#ghc-flag-keep-hi-files" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-8">Keep intermediate <code class="docutils literal notranslate"><span class="pre">.hi</span></code> files. This is the default. You may use
<code class="docutils literal notranslate"><span class="pre">-no-keep-hi-files</span></code> if you are not interested in the <code class="docutils literal notranslate"><span class="pre">.hi</span></code> files.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-keep-hscpp-file">
<span class="sig-name descname"><span class="pre">-keep-hscpp-file</span></span><a class="headerlink" href="#ghc-flag-keep-hscpp-file" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="ghc-flag-keep-hscpp-files">
<span class="sig-name descname"><span class="pre">-keep-hscpp-files</span></span><a class="headerlink" href="#ghc-flag-keep-hscpp-files" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-9">Keep the output of the <code class="docutils literal notranslate"><span class="pre">CPP</span></code> pre-processor phase as <code class="docutils literal notranslate"><span class="pre">.hscpp</span></code> files.
A <code class="docutils literal notranslate"><span class="pre">.hscpp</span></code> file is only created, if a module gets compiled and uses the
C pre-processor.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-keep-llvm-file">
<span class="sig-name descname"><span class="pre">-keep-llvm-file</span></span><a class="headerlink" href="#ghc-flag-keep-llvm-file" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="ghc-flag-keep-llvm-files">
<span class="sig-name descname"><span class="pre">-keep-llvm-files</span></span><a class="headerlink" href="#ghc-flag-keep-llvm-files" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Implies<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="phases.html#ghc-flag-fllvm"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fllvm</span></code></a></p>
</dd>
</dl>
<p>Keep intermediate <code class="docutils literal notranslate"><span class="pre">.ll</span></code> files when doing <code class="docutils literal notranslate"><span class="pre">.hs</span></code>-to-<code class="docutils literal notranslate"><span class="pre">.o</span></code>
compilations via <a class="reference internal" href="codegens.html#llvm-code-gen"><span class="std std-ref">LLVM</span></a> (Note: <code class="docutils literal notranslate"><span class="pre">.ll</span></code> files
aren’t generated when using the native code generator, you may need
to use <a class="reference internal" href="phases.html#ghc-flag-fllvm"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fllvm</span></code></a> to force them to be produced).</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-keep-o-files">
<span class="sig-name descname"><span class="pre">-keep-o-files</span></span><a class="headerlink" href="#ghc-flag-keep-o-files" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-10">Keep intermediate <code class="docutils literal notranslate"><span class="pre">.o</span></code> files. This is the default. You may use
<code class="docutils literal notranslate"><span class="pre">-no-keep-o-files</span></code> if you are not interested in the <code class="docutils literal notranslate"><span class="pre">.o</span></code> files.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-keep-s-file">
<span class="sig-name descname"><span class="pre">-keep-s-file</span></span><a class="headerlink" href="#ghc-flag-keep-s-file" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="ghc-flag-keep-s-files">
<span class="sig-name descname"><span class="pre">-keep-s-files</span></span><a class="headerlink" href="#ghc-flag-keep-s-files" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep intermediate <code class="docutils literal notranslate"><span class="pre">.s</span></code> files.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-keep-tmp-files">
<span class="sig-name descname"><span class="pre">-keep-tmp-files</span></span><a class="headerlink" href="#ghc-flag-keep-tmp-files" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-11">Instructs the GHC driver not to delete any of its temporary files,
which it normally keeps in <code class="docutils literal notranslate"><span class="pre">/tmp</span></code> (or possibly elsewhere; see
<a class="reference internal" href="#temp-files"><span class="std std-ref">Redirecting temporary files</span></a>). Running GHC with <code class="docutils literal notranslate"><span class="pre">-v</span></code> will show you what
temporary files were generated along the way.</p>
</dd></dl>

</section>
<section id="redirecting-temporary-files">
<span id="temp-files"></span><h2><span class="section-number">5.8.6. </span>Redirecting temporary files<a class="headerlink" href="#redirecting-temporary-files" title="Permalink to this heading">¶</a></h2>
<span class="target" id="index-12"></span><dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-tmpdir-dir">
<span class="sig-name descname"><span class="pre">-tmpdir</span></span><span class="sig-prename descclassname"> <span class="pre">⟨dir⟩</span></span><a class="headerlink" href="#ghc-flag-tmpdir-dir" title="Permalink to this definition">¶</a></dt>
<dd><p>If you have trouble because of running out of space in <code class="docutils literal notranslate"><span class="pre">/tmp</span></code> (or
wherever your installation thinks temporary files should go), you
may use the <a class="reference internal" href="#ghc-flag-tmpdir-dir"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-tmpdir</span> <span class="pre">⟨dir⟩</span></code></a> option to specify an
alternate directory. For example, <code class="docutils literal notranslate"><span class="pre">-tmpdir</span> <span class="pre">.</span></code> says to put temporary files
in the current working directory.</p>
<p id="index-13">Alternatively, use your <span class="target" id="index-14"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">TMPDIR</span></code> environment variable. Set it to the
name of the directory where temporary files should be put. GCC and other
programs will honour the <span class="target" id="index-15"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">TMPDIR</span></code> variable as well.</p>
</dd></dl>

</section>
<section id="other-options-related-to-interface-files">
<span id="hi-options"></span><h2><span class="section-number">5.8.7. </span>Other options related to interface files<a class="headerlink" href="#other-options-related-to-interface-files" title="Permalink to this heading">¶</a></h2>
<span class="target" id="index-16"></span><dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ddump-hi">
<span class="sig-name descname"><span class="pre">-ddump-hi</span></span><a class="headerlink" href="#ghc-flag-ddump-hi" title="Permalink to this definition">¶</a></dt>
<dd><p>Dumps the new interface to standard output.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ddump-hi-diffs">
<span class="sig-name descname"><span class="pre">-ddump-hi-diffs</span></span><a class="headerlink" href="#ghc-flag-ddump-hi-diffs" title="Permalink to this definition">¶</a></dt>
<dd><p>The compiler does not overwrite an existing <code class="docutils literal notranslate"><span class="pre">.hi</span></code> interface file
if the new one is the same as the old one; this is friendly to
<strong class="command">make</strong>. When an interface does change, it is often enlightening to
be informed. The <a class="reference internal" href="#ghc-flag-ddump-hi-diffs"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-hi-diffs</span></code></a> option will make GHC report the
differences between the old and new <code class="docutils literal notranslate"><span class="pre">.hi</span></code> files.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ddump-minimal-imports">
<span class="sig-name descname"><span class="pre">-ddump-minimal-imports</span></span><a class="headerlink" href="#ghc-flag-ddump-minimal-imports" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump to the file <code class="file docutils literal notranslate"><em><span class="pre">M</span></em><span class="pre">.imports</span></code> (where ⟨M⟩ is the name of the module
being compiled) a “minimal” set of import declarations. The
directory where the <code class="docutils literal notranslate"><span class="pre">.imports</span></code> files are created can be controlled
via the <a class="reference internal" href="#ghc-flag-dumpdir-dir"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-dumpdir</span> <span class="pre">⟨dir⟩</span></code></a> option.</p>
<p>You can safely replace all the import declarations in <code class="file docutils literal notranslate"><em><span class="pre">M</span></em><span class="pre">.hs</span></code> with
those found in its respective <code class="docutils literal notranslate"><span class="pre">.imports</span></code> file. Why would you want
to do that? Because the “minimal” imports (a) import everything
explicitly, by name, and (b) import nothing that is not required. It
can be quite painful to maintain this property by hand, so this flag
is intended to reduce the labour.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-show-iface-file">
<span class="sig-name descname"><span class="pre">--show-iface</span></span><span class="sig-prename descclassname"> <span class="pre">⟨file⟩</span></span><a class="headerlink" href="#ghc-flag-show-iface-file" title="Permalink to this definition">¶</a></dt>
<dd><p>where ⟨file⟩ is the name of an interface file, dumps the contents of
that interface in a human-readable format. See <a class="reference internal" href="using.html#modes"><span class="std std-ref">Modes of operation</span></a>.</p>
</dd></dl>

</section>
<section id="options-related-to-extended-interface-files">
<span id="hie-options"></span><h2><span class="section-number">5.8.8. </span>Options related to extended interface files<a class="headerlink" href="#options-related-to-extended-interface-files" title="Permalink to this heading">¶</a></h2>
<p id="index-17">GHC builds up a wealth of information about a Haskell source file as it compiles
it. Extended interface files are a way of persisting some of this information to
disk so that external tools, such as IDE’s, can avoid parsing, typechecking, and
renaming all over again. These files contain</p>
<blockquote>
<div><ul>
<li><p>a simplified AST</p>
<blockquote>
<div><ul class="simple">
<li><p>nodes are annotated with source positions and types</p></li>
<li><p>identifiers are annotated with scope information</p></li>
</ul>
</div></blockquote>
</li>
<li><p>the raw bytes of the initial Haskell source</p></li>
</ul>
</div></blockquote>
<p>The GHC API exposes functions for reading and writing these files.</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fwrite-ide-info">
<span class="sig-name descname"><span class="pre">-fwrite-ide-info</span></span><a class="headerlink" href="#ghc-flag-fwrite-ide-info" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes out extended interface files alongside regular interface files.
Just like regular interface files, GHC has a recompilation check to detect
out of date or missing extended interface files.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fvalidate-ide-info">
<span class="sig-name descname"><span class="pre">-fvalidate-ide-info</span></span><a class="headerlink" href="#ghc-flag-fvalidate-ide-info" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs a series of sanity checks and lints on the extended interface files
that are being written out. These include testing things properties such as
variables not occurring outside of their expected scopes.</p>
</dd></dl>

<p>The format in which GHC currently stores its typechecked AST, makes it costly
to collect the types for some expressions nodes. For the sake of performance,
GHC currently chooses to skip over these, so not all expression nodes should be
expected to have type information on them. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/16233">#16233</a> for more.</p>
</section>
<section id="the-recompilation-checker">
<span id="recomp"></span><h2><span class="section-number">5.8.9. </span>The recompilation checker<a class="headerlink" href="#the-recompilation-checker" title="Permalink to this heading">¶</a></h2>
<span class="target" id="index-18"></span><dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fforce-recomp">
<span class="sig-name descname"><span class="pre">-fforce-recomp</span></span><a class="headerlink" href="#ghc-flag-fforce-recomp" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn off recompilation checking (which is on by default).
Recompilation checking normally stops compilation early, leaving an
existing <code class="docutils literal notranslate"><span class="pre">.o</span></code> file in place, if it can be determined that the
module does not need to be recompiled.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fignore-optim-changes">
<span class="sig-name descname"><span class="pre">-fignore-optim-changes</span></span><a class="headerlink" href="#ghc-flag-fignore-optim-changes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fignore-hpc-changes">
<span class="sig-name descname"><span class="pre">-fignore-hpc-changes</span></span><a class="headerlink" href="#ghc-flag-fignore-hpc-changes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>In the olden days, GHC compared the newly-generated <code class="docutils literal notranslate"><span class="pre">.hi</span></code> file with
the previous version; if they were identical, it left the old one alone
and didn’t change its modification date. In consequence, importers of a
module with an unchanged output <code class="docutils literal notranslate"><span class="pre">.hi</span></code> file were not recompiled.</p>
<p>This doesn’t work any more. Suppose module <code class="docutils literal notranslate"><span class="pre">C</span></code> imports module <code class="docutils literal notranslate"><span class="pre">B</span></code>,
and <code class="docutils literal notranslate"><span class="pre">B</span></code> imports module <code class="docutils literal notranslate"><span class="pre">A</span></code>. So changes to module <code class="docutils literal notranslate"><span class="pre">A</span></code> might require
module <code class="docutils literal notranslate"><span class="pre">C</span></code> to be recompiled, and hence when <code class="docutils literal notranslate"><span class="pre">A.hi</span></code> changes we should
check whether <code class="docutils literal notranslate"><span class="pre">C</span></code> should be recompiled. However, the dependencies of
<code class="docutils literal notranslate"><span class="pre">C</span></code> will only list <code class="docutils literal notranslate"><span class="pre">B.hi</span></code>, not <code class="docutils literal notranslate"><span class="pre">A.hi</span></code>, and some changes to <code class="docutils literal notranslate"><span class="pre">A</span></code>
(changing the definition of a function that appears in an inlining of a
function exported by <code class="docutils literal notranslate"><span class="pre">B</span></code>, say) may conceivably not change <code class="docutils literal notranslate"><span class="pre">B.hi</span></code> one
jot. So now…</p>
<p>GHC calculates a fingerprint (in fact an MD5 hash) of each interface
file, and of each declaration within the interface file. It also keeps
in every interface file a list of the fingerprints of everything it used
when it last compiled the file. If the source file’s modification date
is earlier than the <code class="docutils literal notranslate"><span class="pre">.o</span></code> file’s date (i.e. the source hasn’t changed
since the file was last compiled), and the recompilation checking is on,
GHC will be clever. It compares the fingerprints on the things it needs
this time with the fingerprints on the things it needed last time
(gleaned from the interface file of the module being compiled); if they
are all the same it stops compiling early in the process saying
“Compilation IS NOT required”. What a beautiful sight!</p>
<p>You can read about <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/recompilation-avoidance">how all this works</a> in the GHC commentary.</p>
</section>
<section id="how-to-compile-mutually-recursive-modules">
<span id="mutual-recursion"></span><h2><span class="section-number">5.8.10. </span>How to compile mutually recursive modules<a class="headerlink" href="#how-to-compile-mutually-recursive-modules" title="Permalink to this heading">¶</a></h2>
<p id="index-19">GHC supports the compilation of mutually recursive modules. This section
explains how.</p>
<p>Every cycle in the module import graph must be broken by a <code class="docutils literal notranslate"><span class="pre">hs-boot</span></code>
file. Suppose that modules <code class="docutils literal notranslate"><span class="pre">A.hs</span></code> and <code class="docutils literal notranslate"><span class="pre">B.hs</span></code> are Haskell source
files, thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>module A where
    import B( TB(..) )

    newtype TA = MkTA Int

    f :: TB -&gt; TA
    f (MkTB x) = MkTA x

module B where
    import {-# SOURCE #-} A( TA(..) )

    data TB = MkTB !Int

    g :: TA -&gt; TB
    g (MkTA x) = MkTB x
</pre></div>
</div>
<p id="index-20">Here <code class="docutils literal notranslate"><span class="pre">A</span></code> imports <code class="docutils literal notranslate"><span class="pre">B</span></code>, but <code class="docutils literal notranslate"><span class="pre">B</span></code> imports <code class="docutils literal notranslate"><span class="pre">A</span></code> with a
<code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code> pragma, which breaks the circular dependency. Every
loop in the module import graph must be broken by a <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code>
import; or, equivalently, the module import graph must be acyclic if
<code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code> imports are ignored.</p>
<p>For every module <code class="docutils literal notranslate"><span class="pre">A.hs</span></code> that is <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code>-imported in this
way there must exist a source file <code class="docutils literal notranslate"><span class="pre">A.hs-boot</span></code>. This file contains an
abbreviated version of <code class="docutils literal notranslate"><span class="pre">A.hs</span></code>, thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">newtype</span><span class="w"> </span><span class="kt">TA</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkTA</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>To compile these three files, issue the following commands:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghc -c A.hs-boot    -- Produces A.hi-boot, A.o-boot
ghc -c B.hs         -- Consumes A.hi-boot, produces B.hi, B.o
ghc -c A.hs         -- Consumes B.hi, produces A.hi, A.o
ghc -o foo A.o B.o  -- Linking the program
</pre></div>
</div>
<p>There are several points to note here:</p>
<ul>
<li><p>The file <code class="docutils literal notranslate"><span class="pre">A.hs-boot</span></code> is a programmer-written source file. It must
live in the same directory as its parent source file <code class="docutils literal notranslate"><span class="pre">A.hs</span></code>.
Currently, if you use a literate source file <code class="docutils literal notranslate"><span class="pre">A.lhs</span></code> you must also
use a literate boot file, <code class="docutils literal notranslate"><span class="pre">A.lhs-boot</span></code>; and vice versa.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">hs-boot</span></code> file is compiled by GHC, just like a <code class="docutils literal notranslate"><span class="pre">hs</span></code> file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghc -c A.hs-boot
</pre></div>
</div>
<p>When a hs-boot file <code class="docutils literal notranslate"><span class="pre">A.hs-boot</span></code> is compiled, it is checked for
scope and type errors. When its parent module <code class="docutils literal notranslate"><span class="pre">A.hs</span></code> is compiled,
the two are compared, and an error is reported if the two are
inconsistent.</p>
</li>
<li><p>Just as compiling <code class="docutils literal notranslate"><span class="pre">A.hs</span></code> produces an interface file <code class="docutils literal notranslate"><span class="pre">A.hi</span></code>, and
an object file <code class="docutils literal notranslate"><span class="pre">A.o</span></code>, so compiling <code class="docutils literal notranslate"><span class="pre">A.hs-boot</span></code> produces an
interface file <code class="docutils literal notranslate"><span class="pre">A.hi-boot</span></code>, and a pseudo-object file <code class="docutils literal notranslate"><span class="pre">A.o-boot</span></code>:</p>
<ul class="simple">
<li><p>The pseudo-object file <code class="docutils literal notranslate"><span class="pre">A.o-boot</span></code> is empty (don’t link it!), but
it is very useful when using a Makefile, to record when the
<code class="docutils literal notranslate"><span class="pre">A.hi-boot</span></code> was last brought up to date (see <a class="reference internal" href="#using-make"><span class="std std-ref">Using make</span></a>).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">hi-boot</span></code> generated by compiling a <code class="docutils literal notranslate"><span class="pre">hs-boot</span></code> file is in
the same machine-generated binary format as any other
GHC-generated interface file (e.g. <code class="docutils literal notranslate"><span class="pre">B.hi</span></code>). You can display its
contents with <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">--show-iface</span></code>. If you specify a directory for
interface files, the <code class="docutils literal notranslate"><span class="pre">-hidir</span></code> flag, then that affects <code class="docutils literal notranslate"><span class="pre">hi-boot</span></code> files
too.</p></li>
</ul>
</li>
<li><p>If hs-boot files are considered distinct from their parent source
files, and if a <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code> import is considered to refer to
the hs-boot file, then the module import graph must have no cycles.
The command <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-M</span></code> will report an error if a cycle is found.</p></li>
<li><p>A module <code class="docutils literal notranslate"><span class="pre">M</span></code> that is <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code>-imported in a program will
usually also be ordinarily imported elsewhere. If not, <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">--make</span></code>
automatically adds <code class="docutils literal notranslate"><span class="pre">M</span></code> to the set of modules it tries to compile
and link, to ensure that <code class="docutils literal notranslate"><span class="pre">M</span></code>'s implementation is included in the
final program.</p></li>
</ul>
<p>A hs-boot file need only contain the bare minimum of information needed
to get the bootstrapping process started. For example, it doesn’t need
to contain declarations for <em>everything</em> that module <code class="docutils literal notranslate"><span class="pre">A</span></code> exports, only
the things required by the module(s) that import <code class="docutils literal notranslate"><span class="pre">A</span></code> recursively.</p>
<p>A hs-boot file is written in a subset of Haskell:</p>
<ul>
<li><p>The module header (including the export list), and import statements,
are exactly as in Haskell, and so are the scoping rules. Hence, to
mention a non-Prelude type or class, you must import it.</p></li>
<li><p>There must be no value declarations, but there can be type signatures
for values. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">double</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Fixity declarations are exactly as in Haskell.</p></li>
<li><p>Vanilla type synonym declarations are exactly as in Haskell.</p></li>
<li><p>Open type and data family declarations are exactly as in Haskell.</p></li>
<li><p>A closed type family may optionally omit its equations, as in the
following example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">ClosedFam</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">..</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">..</span></code> is meant literally – you should write two dots in your
file. Note that the <code class="docutils literal notranslate"><span class="pre">where</span></code> clause is still necessary to
distinguish closed families from open ones. If you give any equations
of a closed family, you must give all of them, in the same order as
they appear in the accompanying Haskell file.</p>
</li>
<li><p>A data type declaration can either be given in full, exactly as in
Haskell, or it can be given abstractly, by omitting the ‘=’ sign and
everything that follows. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>In a <em>source</em> program this would declare TA to have no constructors
(a GHC extension: see <a class="reference internal" href="exts/nullary_types.html#nullary-types"><span class="std std-ref">Data types with no constructors</span></a>), but in an hi-boot file
it means “I don’t know or care what the constructors are”. This is
the most common form of data type declaration, because it’s easy to
get right. You <em>can</em> also write out the constructors but, if you do
so, you must write it out precisely as in its real definition.</p>
<p>If you do not write out the constructors, you may need to give a kind
annotation (<a class="reference internal" href="exts/kind_signatures.html#kinding"><span class="std std-ref">Explicitly-kinded quantification</span></a>), to tell GHC the kind of the type
variable, if it is not “*”. (In source files, this is worked out
from the way the type variable is used in the constructors.) For
example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
<p>You cannot use <code class="docutils literal notranslate"><span class="pre">deriving</span></code> on a data type declaration; write an
<code class="docutils literal notranslate"><span class="pre">instance</span></code> declaration instead.</p>
</li>
<li><p>Class declarations is exactly as in Haskell, except that you may not
put default method declarations. You can also omit all the
superclasses and class methods entirely; but you must either omit
them all or put them all in.</p></li>
<li><p>You can include instance declarations just as in Haskell; but omit
the “where” part.</p></li>
<li><p>The default role for abstract datatype parameters is now
representational. (An abstract datatype is one with no constructors
listed.) To get another role, use a role annotation. (See
<a class="reference internal" href="exts/roles.html#roles"><span class="std std-ref">Roles</span></a>.)</p></li>
</ul>
</section>
<section id="module-signatures">
<span id="id2"></span><h2><span class="section-number">5.8.11. </span>Module signatures<a class="headerlink" href="#module-signatures" title="Permalink to this heading">¶</a></h2>
<p id="index-21">GHC 8.2 supports module signatures (<code class="docutils literal notranslate"><span class="pre">hsig</span></code> files), which allow you to
write a signature in place of a module implementation, deferring the
choice of implementation until a later point in time.  This feature is
not intended to be used without <a class="reference external" href="http://www.haskell.org/cabal/">Cabal</a>; this manual entry will focus
on the syntax and semantics of signatures.</p>
<p>To start with an example, suppose you had a module <code class="docutils literal notranslate"><span class="pre">A</span></code> which made use of some
string operations.  Using normal module imports, you would only
be able to pick a particular implementation of strings:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Str</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">type</span><span class="w"> </span><span class="kt">Str</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>

<span class="w">    </span><span class="n">empty</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Str</span><span class="w"></span>
<span class="w">    </span><span class="n">empty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">toString</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Str</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">    </span><span class="n">toString</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"></span>

<span class="kr">module</span><span class="w"> </span><span class="nn">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">import</span><span class="w"> </span><span class="nn">Str</span><span class="w"></span>
<span class="w">    </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">toString</span><span class="w"> </span><span class="n">empty</span><span class="w"></span>
</pre></div>
</div>
<p>By replacing <code class="docutils literal notranslate"><span class="pre">Str.hs</span></code> with a signature <code class="docutils literal notranslate"><span class="pre">Str.hsig</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code> (and
any other modules in this package) are now parametrized by
a string implementation:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signature</span><span class="w"> </span><span class="kt">Str</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">Str</span><span class="w"></span>
<span class="w">    </span><span class="n">empty</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Str</span><span class="w"></span>
<span class="w">    </span><span class="n">toString</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Str</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
</pre></div>
</div>
<p>We can typecheck <code class="docutils literal notranslate"><span class="pre">A</span></code> against this signature, or we can instantiate
<code class="docutils literal notranslate"><span class="pre">Str</span></code> with a module that provides the following declarations.  Refer
to Cabal’s documentation for a more in-depth discussion on how to
instantiate signatures.</p>
<p>Module signatures actually consist of two closely related features:</p>
<ul class="simple">
<li><p>The ability to define an <code class="docutils literal notranslate"><span class="pre">hsig</span></code> file, containing type definitions
and type signature for values which can be used by modules that
import the signature, and must be provided by the eventual
implementing module, and</p></li>
<li><p>The ability to <em>inherit</em> required signatures from packages we
depend upon, combining the signatures into a single merged
signature which reflects the requirements of any locally defined
signature, as well as the requirements of our dependencies.</p></li>
</ul>
<p>A signature file is denoted by an <code class="docutils literal notranslate"><span class="pre">hsig</span></code> file; every required
signature must have an <code class="docutils literal notranslate"><span class="pre">hsig</span></code> file (even if it is an empty one),
including required signatures inherited from dependencies.  Signatures
can be imported using an ordinary <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">Sig</span></code> declaration.</p>
<p><code class="docutils literal notranslate"><span class="pre">hsig</span></code> files are written in a variant of Haskell similar
to <code class="docutils literal notranslate"><span class="pre">hs-boot</span></code> files, but with some slight changes:</p>
<ul>
<li><p>The header of a signature is <code class="docutils literal notranslate"><span class="pre">signature</span> <span class="pre">A</span> <span class="pre">where</span> <span class="pre">...</span></code> (instead
of the usual <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">A</span> <span class="pre">where</span> <span class="pre">...</span></code>).</p></li>
<li><p>Import statements and scoping rules are exactly as in Haskell.
To mention a non-Prelude type or class, you must import it.</p></li>
<li><p>Unlike regular modules, the defined entities of
a signature include not only those written in the local
<code class="docutils literal notranslate"><span class="pre">hsig</span></code> file, but also those from inherited signatures
(as inferred from the <a class="reference internal" href="packages.html#ghc-flag-package-id-unit-id"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-package-id</span> <span class="pre">⟨unit-id⟩</span></code></a> flags).
These entities are not considered in scope when typechecking
the local <code class="docutils literal notranslate"><span class="pre">hsig</span></code> file, but are available for import by
any module or signature which imports the signature.  The
one exception to this rule is the export list, described
below.</p>
<p>If a declaration occurs in multiple inherited signatures,
they will be <em>merged</em> together.  For values, we require
that the types from both signatures match exactly; however,
other declarations may merge in more interesting ways.
The merging operation in these cases has the effect of
textually replacing all occurrences of the old name with
a reference to the new, merged declaration.  For example,
if we have the following two signatures:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signature</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"></span>

<span class="nf">signature</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"></span>
<span class="w">    </span><span class="n">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"></span>
</pre></div>
</div>
<p>the resulting merged signature would be:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signature</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"></span>
<span class="w">    </span><span class="n">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>If no export list is provided for a signature, the exports of
a signature are all of its defined entities merged with the
exports of all inherited signatures.</p>
<p>If you want to reexport an entity from a signature, you must
also include a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">SigName</span></code> export, so that all of the
entities defined in the signature are exported.  For example,
the following module exports both <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">Int</span></code> from
<code class="docutils literal notranslate"><span class="pre">Prelude</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signature</span><span class="w"> </span><span class="kt">A</span><span class="p">(</span><span class="kr">module</span><span class="w"> </span><span class="nn">A</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">import</span><span class="w"> </span><span class="nn">Prelude</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>Reexports merge with local declarations; thus, the signature above
would successfully merge with:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signature</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>The only permissible implementation of such a signature is a module
which reexports precisely the same entity:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">A</span><span class="w"> </span><span class="p">(</span><span class="nf">f</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">import</span><span class="w"> </span><span class="nn">Prelude</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>Conversely, any entity requested by a signature can be provided
by a reexport from the implementing module.  This is different from
<code class="docutils literal notranslate"><span class="pre">hs-boot</span></code> files, which require every entity to be defined
locally in the implementing module.</p>
</li>
<li><p>GHC has experimental support for <em>signature thinning</em>, which is used
when a signature has an explicit export list without a module export of the
signature itself.  In this case, the export list applies to the final export
list <em>after</em> merging, in particular, you may refer to entities which are not
declared in the body of the local <code class="docutils literal notranslate"><span class="pre">hsig</span></code> file.</p>
<p>The semantics in this case is that the set of required entities is defined
exclusively by its exports; if an entity is not mentioned in the export list,
it is not required.  The motivation behind this feature is to allow a library
author to provide an omnibus signature containing the type of every function
someone might want to use, while a client thins down the exports to the ones
they actually require.  For example, supposing that you have inherited a
signature for strings, you might write a local signature of this form, listing
only the entities that you need:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signature</span><span class="w"> </span><span class="kt">Str</span><span class="w"> </span><span class="p">(</span><span class="kt">Str</span><span class="p">,</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span><span class="w"> </span><span class="n">append</span><span class="p">,</span><span class="w"> </span><span class="n">concat</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- empty</span><span class="w"></span>
</pre></div>
</div>
<p>A few caveats apply here.  First, it is illegal to export an entity
which refers to a locally defined type which itself is not exported
(GHC will report an error in this case).  Second, signatures which
come from dependencies which expose modules cannot be thinned in this
way (after all, the dependency itself may need the entity); these
requirements are unconditionally exported.  Finally, any module
reexports must refer to modules imported by the local signature
(even if an inherited signature exported the module).</p>
<p>We may change the syntax and semantics of this feature in the future.</p>
</li>
<li><p>The declarations and types from signatures of dependencies
that will be merged in are not in scope when type checking
an <code class="docutils literal notranslate"><span class="pre">hsig</span></code> file.  To refer to any such type, you must
declare it yourself:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- OK, assuming we inherited an A that defines T</span><span class="w"></span>
<span class="nf">signature</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- empty</span><span class="w"></span>

<span class="c1">-- Not OK</span><span class="w"></span>
<span class="nf">signature</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"></span>

<span class="c1">-- OK</span><span class="w"></span>
<span class="nf">signature</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>There must be no value declarations, but there can be type signatures
for values.  For example, we might define the signature:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signature</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">double</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>A module implementing <code class="docutils literal notranslate"><span class="pre">A</span></code> would have to export the function
<code class="docutils literal notranslate"><span class="pre">double</span></code> with a type definitionally equal to the signature.
Note that this means you can’t implement <code class="docutils literal notranslate"><span class="pre">double</span></code> using
a polymorphic function <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">::</span> <span class="pre">Num</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>.</p>
<p>Note that signature matching does check if <em>fixity</em> matches, so be
sure specify fixity of ordinary identifiers if you intend to use them
with backticks.</p>
</li>
<li><p>Fixity, type synonym, open type/data family declarations
are permitted as in normal Haskell.</p></li>
<li><p>Closed type family declarations are permitted as in normal
Haskell.  They can also be given abstractly, as in the
following example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">ClosedFam</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">..</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">..</span></code> is meant literally – you should write two dots in
your file.  The <code class="docutils literal notranslate"><span class="pre">where</span></code> clause distinguishes closed families
from open ones.</p>
</li>
<li><p>A data type declaration can either be given in full, exactly
as in Haskell, or it can be given abstractly, by omitting the ‘=’
sign and everything that follows.  For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signature</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>Abstract data types can be implemented not only with data
declarations, but also newtypes and type synonyms (with the
restriction that a type synonym must be fully eta-reduced,
e.g., <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">T</span> <span class="pre">=</span> <span class="pre">...</span></code> to be accepted.)  For example,
the following are all valid implementations of the T above:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Algebraic data type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>

<span class="c1">-- Newtype</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>

<span class="c1">-- Type synonym</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">T2</span><span class="w"></span>
</pre></div>
</div>
<p>Data type declarations merge only with other data type
declarations which match exactly, except abstract data,
which can merge with <code class="docutils literal notranslate"><span class="pre">data</span></code>, <code class="docutils literal notranslate"><span class="pre">newtype</span></code> or <code class="docutils literal notranslate"><span class="pre">type</span></code>
declarations.  Merges with type synonyms are especially useful:
suppose you are using a package of strings which has left the type of
characters in the string unspecified:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signature</span><span class="w"> </span><span class="kt">Str</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">Str</span><span class="w"></span>
<span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">Elem</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Str</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Elem</span><span class="w"></span>
</pre></div>
</div>
<p>If you locally define a signature which specifies
<code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">Elem</span> <span class="pre">=</span> <span class="pre">Char</span></code>, you can now use <code class="docutils literal notranslate"><span class="pre">head</span></code> from the
inherited signature as if it returned a <code class="docutils literal notranslate"><span class="pre">Char</span></code>.</p>
<p>If you do not write out the constructors, you may need to give a kind to tell
GHC what the kinds of the type variables are, if they are not the default
<code class="docutils literal notranslate"><span class="pre">*</span></code>.  Unlike regular data type declarations, the return kind of an
abstract data declaration can be anything (in which case it probably
will be implemented using a type synonym.)  This can be used
to allow compile-time representation polymorphism (as opposed to
<a class="reference external" href="#runtime-rep">run-time representation polymorphism</a>),
as in this example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signature</span><span class="w"> </span><span class="kt">Number</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Types</span><span class="w"></span>
<span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">Rep</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">RuntimeRep</span><span class="w"></span>
<span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">Number</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="kt">Rep</span><span class="w"></span>
<span class="w">    </span><span class="n">plus</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Number</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Number</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Number</span><span class="w"></span>
</pre></div>
</div>
<p>Roles of type parameters are subject to the subtyping
relation <code class="docutils literal notranslate"><span class="pre">phantom</span> <span class="pre">&lt;</span> <span class="pre">representational</span> <span class="pre">&lt;</span> <span class="pre">nominal</span></code>: for example,
an abstract type with a nominal type parameter can be implemented
using a concrete type with a representational type parameter.
Merging respects this subtyping relation (e.g., <code class="docutils literal notranslate"><span class="pre">nominal</span></code>
merged with <code class="docutils literal notranslate"><span class="pre">representational</span></code> is <code class="docutils literal notranslate"><span class="pre">representational</span></code>.)
Roles in signatures default to <code class="docutils literal notranslate"><span class="pre">nominal</span></code>, which gives maximum
flexibility on the implementor’s side.  You should only need to
give an explicit role annotation if a client of the signature
would like to coerce the abstract type in a type parameter (in which case you
should specify <code class="docutils literal notranslate"><span class="pre">representational</span></code> explicitly.)  Unlike
regular data types, we do <em>not</em> assume that abstract
data types are representationally injective: if we have
<code class="docutils literal notranslate"><span class="pre">Coercible</span> <span class="pre">(T</span> <span class="pre">a)</span> <span class="pre">(T</span> <span class="pre">b)</span></code>, and <code class="docutils literal notranslate"><span class="pre">T</span></code> has role <code class="docutils literal notranslate"><span class="pre">nominal</span></code>,
this does not imply that <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">~</span> <span class="pre">b</span></code>.</p>
</li>
<li><p>A class declarations can either be abstract or concrete.  An
abstract class is one with no superclasses or class methods:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signature</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">class</span><span class="w"> </span><span class="kt">Key</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
</pre></div>
</div>
<p>It can be implemented in any way, with any set of superclasses
and methods; however, modules depending on an abstract class
are not permitted to define instances (as of GHC 8.2, this
restriction is not checked, see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/13086">#13086</a>.)
These declarations can be implemented by type synonyms
of kind <code class="docutils literal notranslate"><span class="pre">Constraint</span></code>; this can be useful if you want to parametrize
over a constraint in functions.  For example, with the
<code class="docutils literal notranslate"><span class="pre">ConstraintKinds</span></code> extension, this type synonym is a valid
implementation of the signature above:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">type</span><span class="w"> </span><span class="kt">Key</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Eq</span><span class="w"></span>
</pre></div>
</div>
<p>A concrete class specifies its superclasses, methods,
default method signatures (but not their implementations)
and a <code class="docutils literal notranslate"><span class="pre">MINIMAL</span></code> pragma.  Unlike regular Haskell classes,
you don’t have to explicitly declare a default for a method
to make it optional vis-a-vis the <code class="docutils literal notranslate"><span class="pre">MINIMAL</span></code> pragma.</p>
<p>When merging class declarations, we require that the superclasses
and methods match exactly; however, <code class="docutils literal notranslate"><span class="pre">MINIMAL</span></code> pragmas are logically
ORed together, and a method with a default signature will merge
successfully against one that does not.</p>
</li>
<li><p>You can include instance declarations as in Haskell; just omit the
“where” part.  An instance declaration need not be implemented directly;
if an instance can be derived based on instances in the environment,
it is considered implemented.  For example, the following signature:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signature</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">Str</span><span class="w"></span>
<span class="w">    </span><span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="kt">Str</span><span class="w"></span>
</pre></div>
</div>
<p>is considered implemented by the following module, since there
are instances of <code class="docutils literal notranslate"><span class="pre">Eq</span></code> for <code class="docutils literal notranslate"><span class="pre">[]</span></code> and <code class="docutils literal notranslate"><span class="pre">Char</span></code> which can be combined
to form an instance <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">[Char]</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kr">type</span><span class="w"> </span><span class="kt">Str</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="kt">Char</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Unlike other declarations, for which only the entities declared
in a signature file are brought into scope, instances from the
implementation are always brought into scope, even if they were
not declared in the signature file.  This means that a module may
typecheck against a signature, but not against a matching
implementation.  You can avoid situations like this by never
defining orphan instances inside a package that has signatures.</p>
<p>Instance declarations are only merged if their heads are exactly
the same, so it is possible to get into a situation where GHC
thinks that instances in a signature are overlapping, even if
they are implemented in a non-overlapping way.  If this is
giving you problems give us a shout.</p>
</li>
<li><p>Any orphan instances which are brought into scope by an import
from a signature are unconditionally considered in scope, even
if the eventual implementing module doesn’t actually import the
same orphans.</p></li>
</ul>
<p>Known limitations:</p>
<ul class="simple">
<li><p>Pattern synonyms are not supported.</p></li>
<li><p>Algebraic data types specified in a signature cannot be implemented using
pattern synonyms.  See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/12717">#12717</a></p></li>
</ul>
</section>
<section id="using-make">
<span id="id3"></span><h2><span class="section-number">5.8.12. </span>Using <code class="docutils literal notranslate"><span class="pre">make</span></code><a class="headerlink" href="#using-make" title="Permalink to this heading">¶</a></h2>
<p id="index-22">It is reasonably straightforward to set up a <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> to use with
GHC, assuming you name your source files the same as your modules. Thus:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nv">HC</span>      <span class="o">=</span> ghc
<span class="nv">HC_OPTS</span> <span class="o">=</span> -cpp <span class="k">$(</span>EXTRA_HC_OPTS<span class="k">)</span>

<span class="nv">SRCS</span> <span class="o">=</span> Main.lhs Foo.lhs Bar.lhs
<span class="nv">OBJS</span> <span class="o">=</span> Main.o   Foo.o   Bar.o

<span class="nf">.SUFFIXES </span><span class="o">:</span> .<span class="n">o</span> .<span class="n">hs</span> .<span class="n">hi</span> .<span class="n">lhs</span> .<span class="n">hc</span> .<span class="n">s</span>

<span class="nf">cool_pgm </span><span class="o">:</span> <span class="k">$(</span><span class="nv">OBJS</span><span class="k">)</span>
        rm -f <span class="nv">$@</span>
        <span class="k">$(</span>HC<span class="k">)</span> -o <span class="nv">$@</span> <span class="k">$(</span>HC_OPTS<span class="k">)</span> <span class="k">$(</span>OBJS<span class="k">)</span>

<span class="c"># Standard suffix rules</span>
<span class="nf">.o.hi</span><span class="o">:</span>
        @:

<span class="nf">.lhs.o</span><span class="o">:</span>
        <span class="k">$(</span>HC<span class="k">)</span> -c $&lt; <span class="k">$(</span>HC_OPTS<span class="k">)</span>

<span class="nf">.hs.o</span><span class="o">:</span>
        <span class="k">$(</span>HC<span class="k">)</span> -c $&lt; <span class="k">$(</span>HC_OPTS<span class="k">)</span>

<span class="nf">.o-boot.hi-boot</span><span class="o">:</span>
        @:

<span class="nf">.lhs-boot.o-boot</span><span class="o">:</span>
        <span class="k">$(</span>HC<span class="k">)</span> -c $&lt; <span class="k">$(</span>HC_OPTS<span class="k">)</span>

<span class="nf">.hs-boot.o-boot</span><span class="o">:</span>
        <span class="k">$(</span>HC<span class="k">)</span> -c $&lt; <span class="k">$(</span>HC_OPTS<span class="k">)</span>

<span class="c"># Inter-module dependencies</span>
<span class="nf">Foo.o Foo.hc Foo.s    </span><span class="o">:</span> <span class="n">Baz</span>.<span class="n">hi</span>          <span class="c"># Foo imports Baz</span>
<span class="nf">Main.o Main.hc Main.s </span><span class="o">:</span> <span class="n">Foo</span>.<span class="n">hi</span> <span class="n">Baz</span>.<span class="n">hi</span>   <span class="c"># Main imports Foo and Baz</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Sophisticated <strong class="command">make</strong> variants may achieve some of the above more
elegantly. Notably, <strong class="command">gmake</strong>'s pattern rules let you write the more
comprehensible:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nf">%.o </span><span class="o">:</span> %.<span class="n">lhs</span>
        <span class="k">$(</span>HC<span class="k">)</span> -c $&lt; <span class="k">$(</span>HC_OPTS<span class="k">)</span>
</pre></div>
</div>
<p>What we’ve shown should work with any <code class="docutils literal notranslate"><span class="pre">make</span></code>.</p>
</div>
<p>Note the cheesy <code class="docutils literal notranslate"><span class="pre">.o.hi</span></code> rule: It records the dependency of the
interface (<code class="docutils literal notranslate"><span class="pre">.hi</span></code>) file on the source. The rule says a <code class="docutils literal notranslate"><span class="pre">.hi</span></code> file can
be made from a <code class="docutils literal notranslate"><span class="pre">.o</span></code> file by doing…nothing. Which is true.</p>
<p>Note that the suffix rules are all repeated twice, once for normal
Haskell source files, and once for <code class="docutils literal notranslate"><span class="pre">hs-boot</span></code> files (see
<a class="reference internal" href="#mutual-recursion"><span class="std std-ref">How to compile mutually recursive modules</span></a>).</p>
<p>Note also the inter-module dependencies at the end of the Makefile,
which take the form</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nf">Foo.o Foo.hc Foo.s    </span><span class="o">:</span> <span class="n">Baz</span>.<span class="n">hi</span>          <span class="c"># Foo imports Baz</span>
</pre></div>
</div>
<p>They tell <code class="docutils literal notranslate"><span class="pre">make</span></code> that if any of <code class="docutils literal notranslate"><span class="pre">Foo.o</span></code>, <code class="docutils literal notranslate"><span class="pre">Foo.hc</span></code> or <code class="docutils literal notranslate"><span class="pre">Foo.s</span></code>
have an earlier modification date than <code class="docutils literal notranslate"><span class="pre">Baz.hi</span></code>, then the out-of-date
file must be brought up to date. To bring it up to date, <code class="docutils literal notranslate"><span class="pre">make</span></code> looks
for a rule to do so; one of the preceding suffix rules does the job
nicely. These dependencies can be generated automatically by <code class="docutils literal notranslate"><span class="pre">ghc</span></code>;
see <a class="reference internal" href="#makefile-dependencies"><span class="std std-ref">Dependency generation</span></a></p>
</section>
<section id="dependency-generation">
<span id="makefile-dependencies"></span><h2><span class="section-number">5.8.13. </span>Dependency generation<a class="headerlink" href="#dependency-generation" title="Permalink to this heading">¶</a></h2>
<p id="index-23">Putting inter-dependencies of the form <code class="docutils literal notranslate"><span class="pre">Foo.o</span> <span class="pre">:</span> <span class="pre">Bar.hi</span></code> into your
<code class="docutils literal notranslate"><span class="pre">Makefile</span></code> by hand is rather error-prone. Don’t worry, GHC has support
for automatically generating the required dependencies. Add the
following to your <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nf">depend </span><span class="o">:</span>
        ghc -dep-suffix <span class="s1">&#39;&#39;</span> -M <span class="k">$(</span>HC_OPTS<span class="k">)</span> <span class="k">$(</span>SRCS<span class="k">)</span>
</pre></div>
</div>
<p>Now, before you start compiling, and any time you change the <code class="docutils literal notranslate"><span class="pre">imports</span></code>
in your program, do <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">depend</span></code> before you do <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">cool_pgm</span></code>. The command
<code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-M</span></code> will append the needed dependencies to your <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>.</p>
<p>In general, <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-M</span> <span class="pre">Foo</span></code> does the following. For each module <code class="docutils literal notranslate"><span class="pre">M</span></code> in
the set <code class="docutils literal notranslate"><span class="pre">Foo</span></code> plus all its imports (transitively), it adds to the
Makefile:</p>
<ul>
<li><p>A line recording the dependence of the object file on the source
file.</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nf">M.o </span><span class="o">:</span> <span class="n">M</span>.<span class="n">hs</span>
</pre></div>
</div>
<p>(or <code class="docutils literal notranslate"><span class="pre">M.lhs</span></code> if that is the filename you used).</p>
</li>
<li><p>For each import declaration <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">X</span></code> in <code class="docutils literal notranslate"><span class="pre">M</span></code>, a line recording
the dependence of <code class="docutils literal notranslate"><span class="pre">M</span></code> on <code class="docutils literal notranslate"><span class="pre">X</span></code>:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nf">M.o </span><span class="o">:</span> <span class="n">X</span>.<span class="n">hi</span>
</pre></div>
</div>
</li>
<li><p>For each import declaration <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span> <span class="pre">X</span></code> in <code class="docutils literal notranslate"><span class="pre">M</span></code>, a
line recording the dependence of <code class="docutils literal notranslate"><span class="pre">M</span></code> on <code class="docutils literal notranslate"><span class="pre">X</span></code>:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nf">M.o </span><span class="o">:</span> <span class="n">X</span>.<span class="n">hi</span>-<span class="n">boot</span>
</pre></div>
</div>
<p>(See <a class="reference internal" href="#mutual-recursion"><span class="std std-ref">How to compile mutually recursive modules</span></a> for details of <code class="docutils literal notranslate"><span class="pre">hi-boot</span></code> style
interface files.)</p>
</li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">M</span></code> imports multiple modules, then there will be multiple lines
with <code class="docutils literal notranslate"><span class="pre">M.o</span></code> as the target.</p>
<p>There is no need to list all of the source files as arguments to the
<code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-M</span></code> command; <code class="docutils literal notranslate"><span class="pre">ghc</span></code> traces the dependencies, just like
<code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">--make</span></code> (a new feature in GHC 6.4).</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-M</span></code> needs to find a <em>source file</em> for each module in
the dependency graph, so that it can parse the import declarations and
follow dependencies. Any pre-compiled modules without source files must
therefore belong to a package <a class="footnote-reference brackets" href="#id5" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p>By default, <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-M</span></code> generates all the dependencies, and then
concatenates them onto the end of <code class="docutils literal notranslate"><span class="pre">makefile</span></code> (or <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> if
<code class="docutils literal notranslate"><span class="pre">makefile</span></code> doesn’t exist) bracketed by the lines
“<code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">DO</span> <span class="pre">NOT</span> <span class="pre">DELETE:</span> <span class="pre">Beginning</span> <span class="pre">of</span> <span class="pre">Haskell</span> <span class="pre">dependencies</span></code>” and
“<code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">DO</span> <span class="pre">NOT</span> <span class="pre">DELETE:</span> <span class="pre">End</span> <span class="pre">of</span> <span class="pre">Haskell</span> <span class="pre">dependencies</span></code>”. If these lines
already exist in the <code class="docutils literal notranslate"><span class="pre">makefile</span></code>, then the old dependencies are deleted
first.</p>
<p>Don’t forget to use the same <code class="docutils literal notranslate"><span class="pre">-package</span></code> options on the <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-M</span></code>
command line as you would when compiling; this enables the dependency
generator to locate any imported modules that come from packages. The
package modules won’t be included in the dependencies generated, though
(but see the <code class="docutils literal notranslate"><span class="pre">-include-pkg-deps</span></code> option below).</p>
<p>The dependency generation phase of GHC can take some additional options,
which you may find useful. The options which affect dependency
generation are:</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ddump-mod-cycles">
<span class="sig-name descname"><span class="pre">-ddump-mod-cycles</span></span><a class="headerlink" href="#ghc-flag-ddump-mod-cycles" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a list of the cycles in the module graph. This is useful
when trying to eliminate such cycles.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std">
<span class="sig-name descname"><span class="pre">-v2</span></span></dt>
<dd><p>Print a full list of the module dependencies to stdout. (This is the
standard verbosity flag, so the list will also be displayed with
<code class="docutils literal notranslate"><span class="pre">-v3</span></code> and <code class="docutils literal notranslate"><span class="pre">-v4</span></code>; see <a class="reference internal" href="using.html#options-help"><span class="std std-ref">Verbosity options</span></a>.)</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-dep-makefile-file">
<span class="sig-name descname"><span class="pre">-dep-makefile</span></span><span class="sig-prename descclassname"> <span class="pre">⟨file⟩</span></span><a class="headerlink" href="#ghc-flag-dep-makefile-file" title="Permalink to this definition">¶</a></dt>
<dd><p>Use ⟨file⟩ as the makefile, rather than <code class="docutils literal notranslate"><span class="pre">makefile</span></code> or
<code class="docutils literal notranslate"><span class="pre">Makefile</span></code>. If ⟨file⟩ doesn’t exist, <code class="docutils literal notranslate"><span class="pre">mkdependHS</span></code> creates it. We
often use <code class="docutils literal notranslate"><span class="pre">-dep-makefile</span> <span class="pre">.depend</span></code> to put the dependencies in
<code class="docutils literal notranslate"><span class="pre">.depend</span></code> and then <code class="docutils literal notranslate"><span class="pre">include</span></code> the file <code class="docutils literal notranslate"><span class="pre">.depend</span></code> into
<code class="docutils literal notranslate"><span class="pre">Makefile</span></code>.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-dep-suffix-suffix">
<span class="sig-name descname"><span class="pre">-dep-suffix</span></span><span class="sig-prename descclassname"> <span class="pre">⟨suffix⟩</span></span><a class="headerlink" href="#ghc-flag-dep-suffix-suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Make dependencies that declare that files with suffix
<code class="docutils literal notranslate"><span class="pre">.⟨suf⟩⟨osuf⟩</span></code> depend on interface files with suffix
<code class="docutils literal notranslate"><span class="pre">.⟨suf⟩hi</span></code>, or (for <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">SOURCE</span> <span class="pre">#-}</span></code> imports) on <code class="docutils literal notranslate"><span class="pre">.hi-boot</span></code>.
Multiple <code class="docutils literal notranslate"><span class="pre">-dep-suffix</span></code> flags are permitted. For example,
<code class="docutils literal notranslate"><span class="pre">-dep-suffix</span> <span class="pre">a_</span> <span class="pre">-dep-suffix</span> <span class="pre">b_</span></code> will make dependencies for <code class="docutils literal notranslate"><span class="pre">.hs</span></code>
on <code class="docutils literal notranslate"><span class="pre">.hi</span></code>, <code class="docutils literal notranslate"><span class="pre">.a_hs</span></code> on <code class="docutils literal notranslate"><span class="pre">.a_hi</span></code>, and <code class="docutils literal notranslate"><span class="pre">.b_hs</span></code> on <code class="docutils literal notranslate"><span class="pre">.b_hi</span></code>.
Note that you must provide at least one suffix; if you do not want a suffix
then pass <code class="docutils literal notranslate"><span class="pre">-dep-suffix</span> <span class="pre">''</span></code>.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-exclude-module-file">
<span class="sig-name descname"><span class="pre">--exclude-module</span></span><span class="sig-prename descclassname"><span class="pre">=⟨file⟩</span></span><a class="headerlink" href="#ghc-flag-exclude-module-file" title="Permalink to this definition">¶</a></dt>
<dd><p>Regard <code class="docutils literal notranslate"><span class="pre">⟨file⟩</span></code> as “stable”; i.e., exclude it from having
dependencies on it.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-include-pkg-deps">
<span class="sig-name descname"><span class="pre">-include-pkg-deps</span></span><a class="headerlink" href="#ghc-flag-include-pkg-deps" title="Permalink to this definition">¶</a></dt>
<dd><p>Regard modules imported from packages as unstable, i.e., generate
dependencies on any imported package modules (including <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>,
and all other standard Haskell libraries). Dependencies are not
traced recursively into packages; dependencies are only generated
for home-package modules on external-package modules directly
imported by the home package module. This option is normally only
used by the various system libraries.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-include-cpp-deps">
<span class="sig-name descname"><span class="pre">-include-cpp-deps</span></span><a class="headerlink" href="#ghc-flag-include-cpp-deps" title="Permalink to this definition">¶</a></dt>
<dd><p>Output preprocessor dependencies. This only has an effect when the CPP
language extension is enabled. These dependencies are files included with
the <code class="docutils literal notranslate"><span class="pre">#include</span></code> preprocessor directive (as well as transitive includes) and
implicitly included files such as standard c preprocessor headers and a GHC
version header. One exception to this is that GHC generates a temporary
header file (during compilation) containing package version macros. As this
is only a temporary file that GHC will always generate, it is not output as
a dependency.</p>
</dd></dl>

</section>
<section id="orphan-modules-and-instance-declarations">
<span id="orphan-modules"></span><h2><span class="section-number">5.8.14. </span>Orphan modules and instance declarations<a class="headerlink" href="#orphan-modules-and-instance-declarations" title="Permalink to this heading">¶</a></h2>
<p>Haskell specifies that when compiling module <code class="docutils literal notranslate"><span class="pre">M</span></code>, any instance declaration
in any module “below” <code class="docutils literal notranslate"><span class="pre">M</span></code> is visible. (Module <code class="docutils literal notranslate"><span class="pre">A</span></code> is “below” <code class="docutils literal notranslate"><span class="pre">M</span></code> if <code class="docutils literal notranslate"><span class="pre">A</span></code> is
imported directly by <code class="docutils literal notranslate"><span class="pre">M</span></code>, or if <code class="docutils literal notranslate"><span class="pre">A</span></code> is below a module that <code class="docutils literal notranslate"><span class="pre">M</span></code> imports
directly.) In principle, GHC must therefore read the interface files of
every module below <code class="docutils literal notranslate"><span class="pre">M</span></code>, just in case they contain an instance declaration
that matters to <code class="docutils literal notranslate"><span class="pre">M</span></code>. This would be a disaster in practice, so GHC tries to
be clever.</p>
<p>In particular, if an instance declaration is in the same module as the
definition of any type or class mentioned in the <em>head</em> of the instance
declaration (the part after the “<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>”; see <a class="reference internal" href="exts/instances.html#instance-rules"><span class="std std-ref">Instance termination rules</span></a>), then GHC
has to visit that interface file anyway. Example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">A</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>The instance declaration is only relevant if the type <code class="docutils literal notranslate"><span class="pre">T</span></code> is in use, and
if so, GHC will have visited <code class="docutils literal notranslate"><span class="pre">A</span></code>'s interface file to find <code class="docutils literal notranslate"><span class="pre">T</span></code>'s definition.</p>
<p>The only problem comes when a module contains an instance declaration
and GHC has no other reason for visiting the module. Example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Orphan</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">  </span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Here, neither <code class="docutils literal notranslate"><span class="pre">D</span></code> nor <code class="docutils literal notranslate"><span class="pre">T</span></code> is declared in module <code class="docutils literal notranslate"><span class="pre">Orphan</span></code>. We call such modules
“orphan modules”. GHC identifies orphan modules, and visits the
interface file of every orphan module below the module being compiled.
This is usually wasted work, but there is no avoiding it. You should
therefore do your best to have as few orphan modules as possible.</p>
<p>Functional dependencies complicate matters. Suppose we have:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">B</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">instance</span><span class="w"> </span><span class="kt">E</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Is this an orphan module? Apparently not, because <code class="docutils literal notranslate"><span class="pre">T</span></code> is declared in
the same module. But suppose class <code class="docutils literal notranslate"><span class="pre">E</span></code> had a functional dependency:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Lib</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">class</span><span class="w"> </span><span class="kt">E</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Then in some importing module <code class="docutils literal notranslate"><span class="pre">M</span></code>, the constraint <code class="docutils literal notranslate"><span class="pre">(E</span> <span class="pre">a</span> <span class="pre">Int)</span></code> should be
“improved” by setting <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">T</span></code>, <em>even though there is no explicit
mention</em> of <code class="docutils literal notranslate"><span class="pre">T</span></code> in <code class="docutils literal notranslate"><span class="pre">M</span></code>.</p>
<p>These considerations lead to the following definition of an orphan
module:</p>
<ul>
<li><p>An <em>orphan module</em> orphan module contains at least one <em>orphan
instance</em> or at least one <em>orphan rule</em>.</p></li>
<li><p>An instance declaration in a module <code class="docutils literal notranslate"><span class="pre">M</span></code> is an <em>orphan instance</em> if</p>
<ul class="simple">
<li><p>The class of the instance declaration is not declared in <code class="docutils literal notranslate"><span class="pre">M</span></code>, and</p></li>
<li><p><em>Either</em> the class has no functional dependencies, and none of the
type constructors in the instance head is declared in <code class="docutils literal notranslate"><span class="pre">M</span></code>; <em>or</em>
there is a functional dependency for which none of the type
constructors mentioned in the <em>non-determined</em> part of the
instance head is defined in <code class="docutils literal notranslate"><span class="pre">M</span></code>.</p></li>
</ul>
<p>Only the instance head counts. In the example above, it is not good
enough for <code class="docutils literal notranslate"><span class="pre">C</span></code>'s declaration to be in module <code class="docutils literal notranslate"><span class="pre">A</span></code>; it must be the
declaration of <code class="docutils literal notranslate"><span class="pre">D</span></code> or <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
</li>
<li><p>A rewrite rule in a module <code class="docutils literal notranslate"><span class="pre">M</span></code> is an <em>orphan rule</em> orphan rule if none
of the variables, type constructors, or classes that are free in the
left hand side of the rule are declared in <code class="docutils literal notranslate"><span class="pre">M</span></code>.</p></li>
</ul>
<p>If you use the flag <a class="reference internal" href="using-warnings.html#ghc-flag-Worphans"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Worphans</span></code></a>, GHC will warn you if you are
creating an orphan module. Like any warning, you can switch the warning
off with <a class="reference internal" href="using-warnings.html#ghc-flag-Worphans"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wno-orphans</span></code></a>, and <a class="reference internal" href="using-warnings.html#ghc-flag--Wwarn"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Werror</span></code></a> will make
the compilation fail if the warning is issued.</p>
<p>You can identify an orphan module by looking in its interface file, <code class="docutils literal notranslate"><span class="pre">M.hi</span></code>,
using the <a class="reference internal" href="using.html#ghc-flag-show-iface-file"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">--show-iface</span> <span class="pre">⟨file⟩</span></code></a> <a class="reference internal" href="using.html#modes"><span class="std std-ref">mode</span></a>. If there is a
<code class="docutils literal notranslate"><span class="pre">[orphan</span> <span class="pre">module]</span></code> on the first line, GHC considers it an orphan module.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">1</a><span class="fn-bracket">]</span></span>
<p>This is a change in behaviour relative to 6.2 and earlier.</p>
</aside>
</aside>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="packages.html" class="btn btn-neutral float-right" title="5.9. Packages" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="runtime_control.html" class="btn btn-neutral float-left" title="5.7. Running a compiled program" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>5.3. Optimisation (code improvement) &mdash; Glasgow Haskell Compiler 9.2.4 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.4 User&#39;s Guide"
          href="_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5.4. Using Concurrent Haskell" href="using-concurrent.html" />
    <link rel="prev" title="5.2. Warnings and sanity-checking" href="using-warnings.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="runghc.html">4. Using runghc</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="usage.html">5. Using GHC</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="using.html">5.1. Using GHC</a></li>
<li class="toctree-l2"><a class="reference internal" href="using-warnings.html">5.2. Warnings and sanity-checking</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5.3. Optimisation (code improvement)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#o-convenient-packages-of-optimisation-flags">5.3.1. <code class="docutils literal notranslate"><span class="pre">-O*</span></code>: convenient “packages” of optimisation flags.</a></li>
<li class="toctree-l3"><a class="reference internal" href="#f-platform-independent-flags">5.3.2. <code class="docutils literal notranslate"><span class="pre">-f*</span></code>: platform-independent flags</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="using-concurrent.html">5.4. Using Concurrent Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="using-concurrent.html#using-smp-parallelism">5.5. Using SMP parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="flags.html">5.6. Flag reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="runtime_control.html">5.7. Running a compiled program</a></li>
<li class="toctree-l2"><a class="reference internal" href="separate_compilation.html">5.8. Filenames and separate compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html">5.9. Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="codegens.html">5.10. GHC Backends</a></li>
<li class="toctree-l2"><a class="reference internal" href="phases.html">5.11. Options related to a particular phase</a></li>
<li class="toctree-l2"><a class="reference internal" href="shared_libs.html">5.12. Using shared libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging.html">5.13. Debugging the compiler</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="exts.html">6. Language extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="usage.html"><span class="section-number">5. </span>Using GHC</a> &raquo;</li>
        
      <li><span class="section-number">5.3. </span>Optimisation (code improvement)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/using-optimisation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="optimisation-code-improvement">
<span id="options-optimise"></span><h1><span class="section-number">5.3. </span>Optimisation (code improvement)<a class="headerlink" href="#optimisation-code-improvement" title="Permalink to this heading">¶</a></h1>
<p id="index-0">The <code class="docutils literal notranslate"><span class="pre">-O*</span></code> options specify convenient “packages” of optimisation flags;
the <code class="docutils literal notranslate"><span class="pre">-f*</span></code> options described later on specify <em>individual</em>
optimisations to be turned on/off; the <code class="docutils literal notranslate"><span class="pre">-m*</span></code> options specify
<em>machine-specific</em> optimisations to be turned on/off.</p>
<p>Most of these options are boolean and have options to turn them both “on” and
“off” (beginning with the prefix <code class="docutils literal notranslate"><span class="pre">no-</span></code>). For instance, while <code class="docutils literal notranslate"><span class="pre">-fspecialise</span></code>
enables specialisation, <code class="docutils literal notranslate"><span class="pre">-fno-specialise</span></code> disables it. When multiple flags for
the same option appear in the command-line they are evaluated from left to
right. For instance, <code class="docutils literal notranslate"><span class="pre">-fno-specialise</span> <span class="pre">-fspecialise</span></code> will enable
specialisation.</p>
<p>It is important to note that the <code class="docutils literal notranslate"><span class="pre">-O*</span></code> flags are roughly equivalent to
combinations of <code class="docutils literal notranslate"><span class="pre">-f*</span></code> flags. For this reason, the effect of the
<code class="docutils literal notranslate"><span class="pre">-O*</span></code> and <code class="docutils literal notranslate"><span class="pre">-f*</span></code> flags is dependent upon the order in which they
occur on the command line.</p>
<p>For instance, take the example of <code class="docutils literal notranslate"><span class="pre">-fno-specialise</span> <span class="pre">-O1</span></code>. Despite the
<code class="docutils literal notranslate"><span class="pre">-fno-specialise</span></code> appearing in the command line, specialisation will
still be enabled. This is the case as <code class="docutils literal notranslate"><span class="pre">-O1</span></code> implies <code class="docutils literal notranslate"><span class="pre">-fspecialise</span></code>,
overriding the previous flag. By contrast, <code class="docutils literal notranslate"><span class="pre">-O1</span> <span class="pre">-fno-specialise</span></code> will
compile without specialisation, as one would expect.</p>
<section id="o-convenient-packages-of-optimisation-flags">
<span id="optimise-pkgs"></span><h2><span class="section-number">5.3.1. </span><code class="docutils literal notranslate"><span class="pre">-O*</span></code>: convenient “packages” of optimisation flags.<a class="headerlink" href="#o-convenient-packages-of-optimisation-flags" title="Permalink to this heading">¶</a></h2>
<p>There are <em>many</em> options that affect the quality of code produced by
GHC. Most people only have a general goal, something like “Compile
quickly” or “Make my program run like greased lightning.” The following
“packages” of optimisations (or lack thereof) should suffice.</p>
<p>Note that higher optimisation levels cause more cross-module
optimisation to be performed, which can have an impact on how much of
your program needs to be recompiled when you change something. This is
one reason to stick to no-optimisation when developing code.</p>
<p><strong>No ``-O*``-type option specified:</strong> This is taken to mean “Please
compile quickly; I’m not over-bothered about compiled-code quality.”
So, for example, <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-c</span> <span class="pre">Foo.hs</span></code></p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-O0">
<span class="sig-name descname"><span class="pre">-O0</span></span><a class="headerlink" href="#ghc-flag-O0" title="Permalink to this definition">¶</a></dt>
<dd><p>Means “turn off all optimisation”, reverting to the same settings as
if no <code class="docutils literal notranslate"><span class="pre">-O</span></code> options had been specified. Saying <code class="docutils literal notranslate"><span class="pre">-O0</span></code> can be
useful if e.g. <code class="docutils literal notranslate"><span class="pre">make</span></code> has inserted a <code class="docutils literal notranslate"><span class="pre">-O</span></code> on the command line
already.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-O">
<span class="sig-name descname"><span class="pre">-O</span></span><a class="headerlink" href="#ghc-flag-O" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="ghc-flag-O1">
<span class="sig-name descname"><span class="pre">-O1</span></span><a class="headerlink" href="#ghc-flag-O1" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-1">Means: “Generate good-quality code without taking too long about
it.” Thus, for example: <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">-c</span> <span class="pre">-O</span> <span class="pre">Main.lhs</span></code></p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-O2">
<span class="sig-name descname"><span class="pre">-O2</span></span><a class="headerlink" href="#ghc-flag-O2" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-2">Means: “Apply every non-dangerous optimisation, even if it means
significantly longer compile times.”</p>
<p>The avoided “dangerous” optimisations are those that can make
runtime or space <em>worse</em> if you’re unlucky. They are normally turned
on or off individually.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-On">
<span class="sig-name descname"><span class="pre">-O⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-On" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-3">Any -On where n &gt; 2 is the same as -O2.</p>
</dd></dl>

<p>We don’t use a <code class="docutils literal notranslate"><span class="pre">-O*</span></code> flag for day-to-day work. We use <code class="docutils literal notranslate"><span class="pre">-O</span></code> to get
respectable speed; e.g., when we want to measure something. When we want
to go for broke, we tend to use <code class="docutils literal notranslate"><span class="pre">-O2</span></code> (and we go for lots of coffee
breaks).</p>
<p>The easiest way to see what <code class="docutils literal notranslate"><span class="pre">-O</span></code> (etc.) “really mean” is to run with
<a class="reference internal" href="using.html#ghc-flag-v"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-v</span></code></a>, then stand back in amazement.</p>
</section>
<section id="f-platform-independent-flags">
<span id="options-f"></span><h2><span class="section-number">5.3.2. </span><code class="docutils literal notranslate"><span class="pre">-f*</span></code>: platform-independent flags<a class="headerlink" href="#f-platform-independent-flags" title="Permalink to this heading">¶</a></h2>
<p id="index-4">These flags turn on and off individual optimisations. Flags marked as
on by default are enabled by <code class="docutils literal notranslate"><span class="pre">-O</span></code>, and as such you shouldn’t
need to set any of them explicitly. A flag <code class="docutils literal notranslate"><span class="pre">-fwombat</span></code> can be negated
by saying <code class="docutils literal notranslate"><span class="pre">-fno-wombat</span></code>.</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fcase-merge">
<span class="sig-name descname"><span class="pre">-fcase-merge</span></span><a class="headerlink" href="#ghc-flag-fcase-merge" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Merge immediately-nested case expressions that scrutinise the same variable.
For example,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">   </span><span class="kt">Red</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e1</span><span class="w"></span>
<span class="w">   </span><span class="kr">_</span><span class="w">   </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">            </span><span class="kt">Blue</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e2</span><span class="w"></span>
<span class="w">            </span><span class="kt">Green</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e3</span><span class="w"></span>
</pre></div>
</div>
<p>Is transformed to,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">   </span><span class="kt">Red</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e1</span><span class="w"></span>
<span class="w">   </span><span class="kt">Blue</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e2</span><span class="w"></span>
<span class="w">   </span><span class="kt">Green</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e2</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fcase-folding">
<span class="sig-name descname"><span class="pre">-fcase-folding</span></span><a class="headerlink" href="#ghc-flag-fcase-folding" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Allow constant folding in case expressions that scrutinise some primops:
For example,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">`</span><span class="n">minusWord</span><span class="o">#</span><span class="p">`</span><span class="w"> </span><span class="mi">10</span><span class="o">##</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">   </span><span class="mi">10</span><span class="o">##</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e1</span><span class="w"></span>
<span class="w">   </span><span class="mi">20</span><span class="o">##</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e2</span><span class="w"></span>
<span class="w">   </span><span class="n">v</span><span class="w">    </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e3</span><span class="w"></span>
</pre></div>
</div>
<p>Is transformed to,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">   </span><span class="mi">20</span><span class="o">##</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e1</span><span class="w"></span>
<span class="w">   </span><span class="mi">30</span><span class="o">##</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e2</span><span class="w"></span>
<span class="w">   </span><span class="kr">_</span><span class="w">    </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">`</span><span class="n">minusWord</span><span class="o">#</span><span class="p">`</span><span class="w"> </span><span class="mi">10</span><span class="o">##</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">e3</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fcall-arity">
<span class="sig-name descname"><span class="pre">-fcall-arity</span></span><a class="headerlink" href="#ghc-flag-fcall-arity" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Enable call-arity analysis.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fexitification">
<span class="sig-name descname"><span class="pre">-fexitification</span></span><a class="headerlink" href="#ghc-flag-fexitification" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Enables the floating of exit paths out of recursive functions.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fcmm-elim-common-blocks">
<span class="sig-name descname"><span class="pre">-fcmm-elim-common-blocks</span></span><a class="headerlink" href="#ghc-flag-fcmm-elim-common-blocks" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Enables the common block elimination optimisation
in the code generator. This optimisation attempts to find identical
Cmm blocks and eliminate the duplicates.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fcmm-sink">
<span class="sig-name descname"><span class="pre">-fcmm-sink</span></span><a class="headerlink" href="#ghc-flag-fcmm-sink" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Enables the sinking pass in the code generator.
This optimisation attempts to find identical Cmm blocks and
eliminate the duplicates attempts to move variable bindings closer
to their usage sites. It also inlines simple expressions like
literals or registers.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fcmm-static-pred">
<span class="sig-name descname"><span class="pre">-fcmm-static-pred</span></span><a class="headerlink" href="#ghc-flag-fcmm-static-pred" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off but enabled with <a class="reference internal" href="#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a>.</p>
</dd>
</dl>
<p>This enables static control flow prediction on the final Cmm
code. If enabled GHC will apply certain heuristics to identify
loops and hot code paths. This information is then used by the
register allocation and code layout passes.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fasm-shortcutting">
<span class="sig-name descname"><span class="pre">-fasm-shortcutting</span></span><a class="headerlink" href="#ghc-flag-fasm-shortcutting" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>This enables shortcutting at the assembly stage of the code generator.
In simpler terms shortcutting means if a block of instructions A only consists
of a unconditionally jump, we replace all jumps to A by jumps to the successor
of A.</p>
<p>This is mostly done during Cmm passes. However this can miss corner cases. So at -O2
we run the pass again at the asm stage to catch these.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fblock-layout-cfg">
<span class="sig-name descname"><span class="pre">-fblock-layout-cfg</span></span><a class="headerlink" href="#ghc-flag-fblock-layout-cfg" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off but enabled with <a class="reference internal" href="#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a>.</p>
</dd>
</dl>
<p>The new algorithm considers all outgoing edges of a basic blocks for
code layout instead of only the last jump instruction.
It also builds a control flow graph for functions, tries to find
hot code paths and place them sequentially leading to better cache utilization
and performance.</p>
<p>This is expected to improve performance on average, but actual performance
difference can vary.</p>
<p>If you find cases of significant performance regressions, which can
be traced back to obviously bad code layout please open a ticket.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fblock-layout-weights">
<span class="sig-name descname"><span class="pre">-fblock-layout-weights</span></span><a class="headerlink" href="#ghc-flag-fblock-layout-weights" title="Permalink to this definition">¶</a></dt>
<dd><p>This flag is hacker territory. The main purpose of this flag is to make
it easy to debug and tune the new code layout algorithm. There is no
guarantee that values giving better results now won’t be worse with
the next release.</p>
<p>If you feel your code warrants modifying these settings please consult
the source code for default values and documentation. But I strongly
advise against this.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fblock-layout-weightless">
<span class="sig-name descname"><span class="pre">-fblock-layout-weightless</span></span><a class="headerlink" href="#ghc-flag-fblock-layout-weightless" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>When not using the cfg based blocklayout layout is determined either
by the last jump in a basic block or the heaviest outgoing edge of the
block in the cfg.</p>
<p>With this flag enabled we use the last jump instruction in blocks.
Without this flags the old algorithm also uses the heaviest outgoing
edge.</p>
<p>When this flag is enabled and <a class="reference internal" href="#ghc-flag-fblock-layout-cfg"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fblock-layout-cfg</span></code></a> is disabled
block layout behaves the same as in 8.6 and earlier.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fcpr-anal">
<span class="sig-name descname"><span class="pre">-fcpr-anal</span></span><a class="headerlink" href="#ghc-flag-fcpr-anal" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Turn on CPR analysis in the demand analyser.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fcse">
<span class="sig-name descname"><span class="pre">-fcse</span></span><a class="headerlink" href="#ghc-flag-fcse" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Enables the common-sub-expression elimination
optimisation. Switching this off can be useful if you have some
<code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code> expressions that you don’t want commoned-up.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fstg-cse">
<span class="sig-name descname"><span class="pre">-fstg-cse</span></span><a class="headerlink" href="#ghc-flag-fstg-cse" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Enables the common-sub-expression elimination optimisation on the STG
intermediate language, where it is able to common up some subexpressions
that differ in their types, but not their representation.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fdicts-cheap">
<span class="sig-name descname"><span class="pre">-fdicts-cheap</span></span><a class="headerlink" href="#ghc-flag-fdicts-cheap" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>A very experimental flag that makes dictionary-valued expressions
seem cheap to the optimiser.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fdicts-strict">
<span class="sig-name descname"><span class="pre">-fdicts-strict</span></span><a class="headerlink" href="#ghc-flag-fdicts-strict" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>Make dictionaries strict.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fdmd-tx-dict-sel">
<span class="sig-name descname"><span class="pre">-fdmd-tx-dict-sel</span></span><a class="headerlink" href="#ghc-flag-fdmd-tx-dict-sel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Use a special demand transformer for dictionary selectors.
Behaviour is unconditionally enabled starting with 9.2</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fdo-eta-reduction">
<span class="sig-name descname"><span class="pre">-fdo-eta-reduction</span></span><a class="headerlink" href="#ghc-flag-fdo-eta-reduction" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Eta-reduce lambda expressions, if doing so gets rid of a whole group of
lambdas.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fdo-lambda-eta-expansion">
<span class="sig-name descname"><span class="pre">-fdo-lambda-eta-expansion</span></span><a class="headerlink" href="#ghc-flag-fdo-lambda-eta-expansion" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Eta-expand let-bindings to increase their arity.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-feager-blackholing">
<span class="sig-name descname"><span class="pre">-feager-blackholing</span></span><a class="headerlink" href="#ghc-flag-feager-blackholing" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>Usually GHC black-holes a thunk only when it switches threads. This
flag makes it do so as soon as the thunk is entered. See <a class="reference external" href="http://community.haskell.org/~simonmar/papers/multiproc.pdf">Haskell on
a shared-memory
multiprocessor</a>.</p>
<p>See <a class="reference internal" href="using-concurrent.html#parallel-compile-options"><span class="std std-ref">Compile-time options for SMP parallelism</span></a> for a discussion on its use.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fexcess-precision">
<span class="sig-name descname"><span class="pre">-fexcess-precision</span></span><a class="headerlink" href="#ghc-flag-fexcess-precision" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>When this option is given, intermediate floating point values can
have a <em>greater</em> precision/range than the final type. Generally this
is a good thing, but some programs may rely on the exact
precision/range of <code class="docutils literal notranslate"><span class="pre">Float</span></code>/<code class="docutils literal notranslate"><span class="pre">Double</span></code> values and should not use
this option for their compilation.</p>
<p>Note that the 32-bit x86 native code generator only supports
excess-precision mode, so neither <code class="docutils literal notranslate"><span class="pre">-fexcess-precision</span></code> nor
<code class="docutils literal notranslate"><span class="pre">-fno-excess-precision</span></code> has any effect. This is a known bug, see
<a class="reference internal" href="bugs.html#bugs-ghc"><span class="std std-ref">Bugs in GHC</span></a>.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fexpose-all-unfoldings">
<span class="sig-name descname"><span class="pre">-fexpose-all-unfoldings</span></span><a class="headerlink" href="#ghc-flag-fexpose-all-unfoldings" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>An experimental flag to expose all unfoldings, even for very large
or recursive functions. This allows for all functions to be inlined
while usually GHC would avoid inlining larger functions.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ffloat-in">
<span class="sig-name descname"><span class="pre">-ffloat-in</span></span><a class="headerlink" href="#ghc-flag-ffloat-in" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Float let-bindings inwards, nearer their binding
site. See <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz">Let-floating: moving bindings to give faster programs
(ICFP’96)</a>.</p>
<p>This optimisation moves let bindings closer to their use site. The
benefit here is that this may avoid unnecessary allocation if the
branch the let is now on is never executed. It also enables other
optimisation passes to work more effectively as they have more
information locally.</p>
<p>This optimisation isn’t always beneficial though (so GHC applies
some heuristics to decide when to apply it). The details get
complicated but a simple example is that it is often beneficial to
move let bindings outwards so that multiple let bindings can be
grouped into a larger single let binding, effectively batching their
allocation and helping the garbage collector and allocator.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ffull-laziness">
<span class="sig-name descname"><span class="pre">-ffull-laziness</span></span><a class="headerlink" href="#ghc-flag-ffull-laziness" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Run the full laziness optimisation (also known as
let-floating), which floats let-bindings outside enclosing lambdas,
in the hope they will be thereby be computed less often. See
<a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz">Let-floating: moving bindings to give faster programs
(ICFP’96)</a>.
Full laziness increases sharing, which can lead to increased memory
residency.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>GHC doesn’t implement complete full laziness. Although GHC’s
full-laziness optimisation does enable some transformations
which would be performed by a fully lazy implementation (such as
extracting repeated computations from loops), these
transformations are not applied consistently, so don’t rely on
them.</p>
</div>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ffun-to-thunk">
<span class="sig-name descname"><span class="pre">-ffun-to-thunk</span></span><a class="headerlink" href="#ghc-flag-ffun-to-thunk" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>Worker-wrapper removes unused arguments, but usually we do not
remove them all, lest it turn a function closure into a thunk,
thereby perhaps creating a space leak and/or disrupting inlining.
This flag allows worker/wrapper to remove <em>all</em> value lambdas.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fignore-asserts">
<span class="sig-name descname"><span class="pre">-fignore-asserts</span></span><a class="headerlink" href="#ghc-flag-fignore-asserts" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Causes GHC to ignore uses of the function <code class="docutils literal notranslate"><span class="pre">Exception.assert</span></code> in source
code (in other words, rewriting <code class="docutils literal notranslate"><span class="pre">Exception.assert</span> <span class="pre">p</span> <span class="pre">e</span></code> to <code class="docutils literal notranslate"><span class="pre">e</span></code> (see
<a class="reference internal" href="exts/assert.html#assertions"><span class="std std-ref">Assertions</span></a>).</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fignore-interface-pragmas">
<span class="sig-name descname"><span class="pre">-fignore-interface-pragmas</span></span><a class="headerlink" href="#ghc-flag-fignore-interface-pragmas" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>Tells GHC to ignore all inessential information when reading
interface files. That is, even if <code class="file docutils literal notranslate"><span class="pre">M.hi</span></code> contains unfolding or
strictness information for a function, GHC will ignore that
information.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-flate-dmd-anal">
<span class="sig-name descname"><span class="pre">-flate-dmd-anal</span></span><a class="headerlink" href="#ghc-flag-flate-dmd-anal" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>Run demand analysis again, at the end of the simplification
pipeline. We found some opportunities for discovering strictness
that were not visible earlier; and optimisations like
<a class="reference internal" href="#ghc-flag-fspec-constr"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fspec-constr</span></code></a> can create functions with unused arguments which
are eliminated by late demand analysis. Improvements are modest, but
so is the cost. See notes on the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/late-dmd">wiki page</a>.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fliberate-case">
<span class="sig-name descname"><span class="pre">-fliberate-case</span></span><a class="headerlink" href="#ghc-flag-fliberate-case" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off but enabled with <a class="reference internal" href="#ghc-flag-O2"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O2</span></code></a>.</p>
</dd>
</dl>
<p>Turn on the liberate-case transformation. This unrolls recursive function
once in its own RHS, to avoid repeated case analysis of free variables. It’s
a bit like the call-pattern specialiser (<a class="reference internal" href="#ghc-flag-fspec-constr"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fspec-constr</span></code></a>) but for
free variables rather than arguments.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fliberate-case-threshold-n">
<span class="sig-name descname"><span class="pre">-fliberate-case-threshold</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fliberate-case-threshold-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>2000</p>
</dd>
</dl>
<p>Set the size threshold for the liberate-case transformation.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-floopification">
<span class="sig-name descname"><span class="pre">-floopification</span></span><a class="headerlink" href="#ghc-flag-floopification" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>When this optimisation is enabled the code generator will turn all
self-recursive saturated tail calls into local jumps rather than
function calls.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fllvm-pass-vectors-in-regs">
<span class="sig-name descname"><span class="pre">-fllvm-pass-vectors-in-regs</span></span><a class="headerlink" href="#ghc-flag-fllvm-pass-vectors-in-regs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>This flag has no effect since GHC 8.8 - its behavior is always on.
It used to instruct GHC to use the platform’s native vector registers
to pass vector arguments during function calls.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fmax-inline-alloc-size-n">
<span class="sig-name descname"><span class="pre">-fmax-inline-alloc-size</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fmax-inline-alloc-size-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>128</p>
</dd>
</dl>
<p>Set the maximum size of inline array allocations to n bytes.
GHC will allocate non-pinned arrays of statically known size in the current
nursery block if they’re no bigger than n bytes, ignoring GC overheap. This
value should be quite a bit smaller than the block size (typically: 4096).</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fmax-inline-memcpy-insns-n">
<span class="sig-name descname"><span class="pre">-fmax-inline-memcpy-insns</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fmax-inline-memcpy-insns-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>32</p>
</dd>
</dl>
<p>Inline <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> calls if they would generate no more than ⟨n⟩ pseudo-instructions.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fmax-inline-memset-insns-n">
<span class="sig-name descname"><span class="pre">-fmax-inline-memset-insns</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fmax-inline-memset-insns-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>32</p>
</dd>
</dl>
<p>Inline <code class="docutils literal notranslate"><span class="pre">memset</span></code> calls if they would generate no more than n pseudo
instructions.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fmax-relevant-binds-n">
<span class="sig-name descname"><span class="pre">-fmax-relevant-binds</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fmax-relevant-binds-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>6</p>
</dd>
</dl>
<p>The type checker sometimes displays a fragment of the type
environment in error messages, but only up to some maximum number,
set by this flag. Turning it off with
<code class="docutils literal notranslate"><span class="pre">-fno-max-relevant-binds</span></code> gives an unlimited number.
Syntactically top-level bindings are also usually excluded (since
they may be numerous), but <code class="docutils literal notranslate"><span class="pre">-fno-max-relevant-binds</span></code> includes
them too.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fmax-uncovered-patterns-n">
<span class="sig-name descname"><span class="pre">-fmax-uncovered-patterns</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fmax-uncovered-patterns-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>4</p>
</dd>
</dl>
<p>Maximum number of unmatched patterns to be shown in warnings generated by
<a class="reference internal" href="using-warnings.html#ghc-flag-Wincomplete-patterns"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wincomplete-patterns</span></code></a> and <a class="reference internal" href="using-warnings.html#ghc-flag-Wincomplete-uni-patterns"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wincomplete-uni-patterns</span></code></a>.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fmax-simplifier-iterations-n">
<span class="sig-name descname"><span class="pre">-fmax-simplifier-iterations</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fmax-simplifier-iterations-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>4</p>
</dd>
</dl>
<p>Sets the maximal number of iterations for the simplifier.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fmax-worker-args-n">
<span class="sig-name descname"><span class="pre">-fmax-worker-args</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fmax-worker-args-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>10</p>
</dd>
</dl>
<p>A function will not be split into worker and wrapper if the number of
value arguments of the resulting worker exceeds both that of the original
function and this setting.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fno-opt-coercion">
<span class="sig-name descname"><span class="pre">-fno-opt-coercion</span></span><a class="headerlink" href="#ghc-flag-fno-opt-coercion" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>coercion optimisation enabled.</p>
</dd>
</dl>
<p>Turn off the coercion optimiser.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fno-pre-inlining">
<span class="sig-name descname"><span class="pre">-fno-pre-inlining</span></span><a class="headerlink" href="#ghc-flag-fno-pre-inlining" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>pre-inlining enabled</p>
</dd>
</dl>
<p>Turn off pre-inlining.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fno-state-hack">
<span class="sig-name descname"><span class="pre">-fno-state-hack</span></span><a class="headerlink" href="#ghc-flag-fno-state-hack" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>state hack is enabled</p>
</dd>
</dl>
<p>Turn off the “state hack” whereby any lambda with a <code class="docutils literal notranslate"><span class="pre">State#</span></code> token
as argument is considered to be single-entry, hence it is considered
okay to inline things inside it. This can improve performance of IO
and ST monad code, but it runs the risk of reducing sharing.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fomit-interface-pragmas">
<span class="sig-name descname"><span class="pre">-fomit-interface-pragmas</span></span><a class="headerlink" href="#ghc-flag-fomit-interface-pragmas" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>Implied by <a class="reference internal" href="#ghc-flag--O⟨n⟩"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O0</span></code></a>, otherwise off.</p>
</dd>
</dl>
<p>Tells GHC to omit all inessential information from the interface
file generated for the module being compiled (say M). This means
that a module importing M will see only the <em>types</em> of the functions
that M exports, but not their unfoldings, strictness info, etc.
Hence, for example, no function exported by M will be inlined into
an importing module. The benefit is that modules that import M will
need to be recompiled less often (only when M’s exports change their
type, not when they change their implementation).</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fomit-yields">
<span class="sig-name descname"><span class="pre">-fomit-yields</span></span><a class="headerlink" href="#ghc-flag-fomit-yields" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on (yields are <em>not</em> inserted)</p>
</dd>
</dl>
<p>Tells GHC to omit heap checks when no allocation is
being performed. While this improves binary sizes by about 5%, it
also means that threads run in tight non-allocating loops will not
get preempted in a timely fashion. If it is important to always be
able to interrupt such threads, you should turn this optimization
off. Consider also recompiling all libraries with this optimization
turned off, if you need to guarantee interruptibility.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fpedantic-bottoms">
<span class="sig-name descname"><span class="pre">-fpedantic-bottoms</span></span><a class="headerlink" href="#ghc-flag-fpedantic-bottoms" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>Make GHC be more precise about its treatment of bottom (but see also
<a class="reference internal" href="#ghc-flag-fno-state-hack"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fno-state-hack</span></code></a>). In particular, stop GHC eta-expanding through
a case expression, which is good for performance, but bad if you are
using <code class="docutils literal notranslate"><span class="pre">seq</span></code> on partial applications.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fregs-graph">
<span class="sig-name descname"><span class="pre">-fregs-graph</span></span><a class="headerlink" href="#ghc-flag-fregs-graph" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off due to a performance regression bug (<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/7679">#7679</a>)</p>
</dd>
</dl>
<p><em>Only applies in combination with the native code generator.</em> Use the graph
colouring register allocator for register allocation in the native code
generator. By default, GHC uses a simpler, faster linear register allocator.
The downside being that the linear register allocator usually generates
worse code.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fregs-iterative">
<span class="sig-name descname"><span class="pre">-fregs-iterative</span></span><a class="headerlink" href="#ghc-flag-fregs-iterative" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p><em>Only applies in combination with the native code generator.</em> Use the
iterative coalescing graph colouring register allocator for register
allocation in the native code generator. This is the same register allocator
as the <a class="reference internal" href="#ghc-flag-fregs-graph"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fregs-graph</span></code></a> one but also enables iterative coalescing
during register allocation.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fsimplifier-phases-n">
<span class="sig-name descname"><span class="pre">-fsimplifier-phases</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fsimplifier-phases-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>2</p>
</dd>
</dl>
<p>Set the number of phases for the simplifier. Ignored with <code class="docutils literal notranslate"><span class="pre">-O0</span></code>.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fsimpl-tick-factor-n">
<span class="sig-name descname"><span class="pre">-fsimpl-tick-factor</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fsimpl-tick-factor-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>100</p>
</dd>
</dl>
<p>GHC’s optimiser can diverge if you write rewrite rules
(<a class="reference internal" href="exts/rewrite_rules.html#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>) that don’t terminate, or (less satisfactorily)
if you code up recursion through data types (<a class="reference internal" href="bugs.html#bugs-ghc"><span class="std std-ref">Bugs in GHC</span></a>). To
avoid making the compiler fall into an infinite loop, the optimiser
carries a “tick count” and stops inlining and applying rewrite rules
when this count is exceeded. The limit is set as a multiple of the
program size, so bigger programs get more ticks. The
<code class="docutils literal notranslate"><span class="pre">-fsimpl-tick-factor</span></code> flag lets you change the multiplier. The
default is 100; numbers larger than 100 give more ticks, and numbers
smaller than 100 give fewer.</p>
<p>If the tick-count expires, GHC summarises what simplifier steps it
has done; you can use <code class="docutils literal notranslate"><span class="pre">-fddump-simpl-stats</span></code> to generate a much
more detailed list. Usually that identifies the loop quite
accurately, because some numbers are very large.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fspec-constr">
<span class="sig-name descname"><span class="pre">-fspec-constr</span></span><a class="headerlink" href="#ghc-flag-fspec-constr" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off but enabled by <a class="reference internal" href="#ghc-flag-O2"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O2</span></code></a>.</p>
</dd>
</dl>
<p>Turn on call-pattern specialisation; see <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/">Call-pattern specialisation for
Haskell programs</a>.</p>
<p>This optimisation specializes recursive functions according to their
argument “shapes”. This is best explained by example so consider:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">last</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">last</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">&quot;last&quot;</span><span class="w"></span>
<span class="nf">last</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="nf">last</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
</pre></div>
</div>
<p>In this code, once we pass the initial check for an empty list we
know that in the recursive case this pattern match is redundant. As
such <code class="docutils literal notranslate"><span class="pre">-fspec-constr</span></code> will transform the above code to:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">last</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">last</span><span class="w"> </span><span class="kt">[]</span><span class="w">       </span><span class="ow">=</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">&quot;last&quot;</span><span class="w"></span>
<span class="nf">last</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">last&#39;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
<span class="w">    </span><span class="kr">where</span><span class="w"></span>
<span class="w">      </span><span class="n">last&#39;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">[]</span><span class="w">       </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">      </span><span class="n">last&#39;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">ys</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">last&#39;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">ys</span><span class="w"></span>
</pre></div>
</div>
<p>As well avoid unnecessary pattern matching it also helps avoid
unnecessary allocation. This applies when a argument is strict in
the recursive call to itself but not on the initial entry. As strict
recursive branch of the function is created similar to the above
example.</p>
<p>It is also possible for library writers to instruct GHC to perform
call-pattern specialisation extremely aggressively. This is
necessary for some highly optimized libraries, where we may want to
specialize regardless of the number of specialisations, or the size
of the code. As an example, consider a simplified use-case from the
<code class="docutils literal notranslate"><span class="pre">vector</span></code> library:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="w"> </span><span class="nn">GHC.Types</span><span class="w"> </span><span class="p">(</span><span class="kt">SPEC</span><span class="p">(</span><span class="o">..</span><span class="p">))</span><span class="w"></span>

<span class="nf">foldl</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Stream</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="cm">{-# INLINE foldl #-}</span><span class="w"></span>
<span class="nf">foldl</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="p">(</span><span class="kt">Stream</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl_loop</span><span class="w"> </span><span class="kt">SPEC</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">foldl_loop</span><span class="w"> </span><span class="o">!</span><span class="n">sPEC</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">                            </span><span class="kt">Yield</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">s&#39;</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">foldl_loop</span><span class="w"> </span><span class="n">sPEC</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">s&#39;</span><span class="w"></span>
<span class="w">                            </span><span class="kt">Skip</span><span class="w">       </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">foldl_loop</span><span class="w"> </span><span class="n">sPEC</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">s&#39;</span><span class="w"></span>
<span class="w">                            </span><span class="kt">Done</span><span class="w">       </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">z</span><span class="w"></span>
</pre></div>
</div>
<p>Here, after GHC inlines the body of <code class="docutils literal notranslate"><span class="pre">foldl</span></code> to a call site, it
will perform call-pattern specialisation very aggressively on
<code class="docutils literal notranslate"><span class="pre">foldl_loop</span></code> due to the use of <code class="docutils literal notranslate"><span class="pre">SPEC</span></code> in the argument of the
loop body. <code class="docutils literal notranslate"><span class="pre">SPEC</span></code> from <code class="docutils literal notranslate"><span class="pre">GHC.Types</span></code> is specifically recognised by
the compiler.</p>
<p>(NB: it is extremely important you use <code class="docutils literal notranslate"><span class="pre">seq</span></code> or a bang pattern on
the <code class="docutils literal notranslate"><span class="pre">SPEC</span></code> argument!)</p>
<p>In particular, after inlining this will expose <code class="docutils literal notranslate"><span class="pre">f</span></code> to the loop
body directly, allowing heavy specialisation over the recursive
cases.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fspec-constr-keen">
<span class="sig-name descname"><span class="pre">-fspec-constr-keen</span></span><a class="headerlink" href="#ghc-flag-fspec-constr-keen" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>If this flag is on, call-pattern specialisation will specialise a call
<code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">(Just</span> <span class="pre">x))</span></code> with an explicit constructor argument, even if the argument
is not scrutinised in the body of the function. This is sometimes
beneficial; e.g. the argument might be given to some other function
that can itself be specialised.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fspec-constr-count-n">
<span class="sig-name descname"><span class="pre">-fspec-constr-count</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fspec-constr-count-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>3</p>
</dd>
</dl>
<p>Set the maximum number of specialisations that will be created for
any one function by the SpecConstr transformation.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fspec-constr-threshold-n">
<span class="sig-name descname"><span class="pre">-fspec-constr-threshold</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fspec-constr-threshold-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>2000</p>
</dd>
</dl>
<p>Set the size threshold for the SpecConstr transformation.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fspecialise">
<span class="sig-name descname"><span class="pre">-fspecialise</span></span><a class="headerlink" href="#ghc-flag-fspecialise" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Specialise each type-class-overloaded function
defined in this module for the types at which it is called in this
module. If <a class="reference internal" href="#ghc-flag-fcross-module-specialise"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fcross-module-specialise</span></code></a> is set imported functions
that have an INLINABLE pragma (<a class="reference internal" href="exts/pragmas.html#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>) will be
specialised as well.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fspecialise-aggressively">
<span class="sig-name descname"><span class="pre">-fspecialise-aggressively</span></span><a class="headerlink" href="#ghc-flag-fspecialise-aggressively" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>By default only type class methods and methods marked <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> or
<code class="docutils literal notranslate"><span class="pre">INLINE</span></code> are specialised. This flag will specialise any overloaded function
regardless of size if its unfolding is available. This flag is not
included in any optimisation level as it can massively increase code
size. It can be used in conjunction with <a class="reference internal" href="#ghc-flag-fexpose-all-unfoldings"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fexpose-all-unfoldings</span></code></a>
if you want to ensure all calls are specialised.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fcross-module-specialise">
<span class="sig-name descname"><span class="pre">-fcross-module-specialise</span></span><a class="headerlink" href="#ghc-flag-fcross-module-specialise" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Specialise <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> (<a class="reference internal" href="exts/pragmas.html#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>)
type-class-overloaded functions imported from other modules for the types at
which they are called in this module. Note that specialisation must be
enabled (by <code class="docutils literal notranslate"><span class="pre">-fspecialise</span></code>) for this to have any effect.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-flate-specialise">
<span class="sig-name descname"><span class="pre">-flate-specialise</span></span><a class="headerlink" href="#ghc-flag-flate-specialise" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>Runs another specialisation pass towards the end of the optimisation
pipeline. This can catch specialisation opportunities which arose from
the previous specialisation pass or other inlining.</p>
<p>You might want to use this if you are you have a type class method
which returns a constrained type. For example, a type class where one
of the methods implements a traversal.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-finline-generics">
<span class="sig-name descname"><span class="pre">-finline-generics</span></span><a class="headerlink" href="#ghc-flag-finline-generics" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>9.2.1</p>
</dd>
</dl>
<p id="index-5">Annotate methods of derived Generic and Generic1 instances with INLINE[1]
pragmas based on heuristics dependent on the size of the data type in
question. Improves performance of generics-based algorithms as GHC is able
to optimize away intermediate representation more often.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-finline-generics-aggressively">
<span class="sig-name descname"><span class="pre">-finline-generics-aggressively</span></span><a class="headerlink" href="#ghc-flag-finline-generics-aggressively" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>9.2.1</p>
</dd>
</dl>
<p id="index-6">Annotate methods of all derived Generic and Generic1 instances with
INLINE[1] pragmas.</p>
<p>This flag should only be used in modules deriving Generic instances that
weren’t considered appropriate for INLINE[1] annotations by heuristics of
<a class="reference internal" href="#ghc-flag-finline-generics"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-finline-generics</span></code></a>, yet you know that doing so would be
beneficial.</p>
<p>When enabled globally it will most likely lead to worse compile times and
code size blowup without runtime performance gains.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fsolve-constant-dicts">
<span class="sig-name descname"><span class="pre">-fsolve-constant-dicts</span></span><a class="headerlink" href="#ghc-flag-fsolve-constant-dicts" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>When solving constraints, try to eagerly solve
super classes using available dictionaries.</p>
<p>For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">M</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">M</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>The body of <cite>f</cite> requires a <cite>Num Int</cite> instance. We could solve this
constraint from the context  because we have <cite>C Int b</cite> and that provides us
a
solution for <cite>Num Int</cite>. However, we can often produce much better code
by directly solving for an available <cite>Num Int</cite> dictionary we might have at
hand. This removes potentially many layers of indirection and crucially
allows other optimisations to fire as the dictionary will be statically
known and selector functions can be inlined.</p>
<p>The optimisation also works for GADTs which bind dictionaries. If we
statically know which class dictionary we need then we will solve it
directly rather than indirectly using the one passed in at run time.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fstatic-argument-transformation">
<span class="sig-name descname"><span class="pre">-fstatic-argument-transformation</span></span><a class="headerlink" href="#ghc-flag-fstatic-argument-transformation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>Turn on the static argument transformation, which turns a recursive function
into a non-recursive one with a local recursive loop. See Chapter 7 of
<a class="reference external" href="https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/">Andre Santos’s PhD thesis</a>.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fstg-lift-lams">
<span class="sig-name descname"><span class="pre">-fstg-lift-lams</span></span><a class="headerlink" href="#ghc-flag-fstg-lift-lams" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Enables the late lambda lifting optimisation on the STG
intermediate language. This selectively lifts local functions to
top-level by converting free variables into function parameters.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fstg-lift-lams-known">
<span class="sig-name descname"><span class="pre">-fstg-lift-lams-known</span></span><a class="headerlink" href="#ghc-flag-fstg-lift-lams-known" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p>Allow turning known into unknown calls while performing
late lambda lifting. This is deemed non-beneficial, so it’s
off by default.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fstg-lift-lams-non-rec-args">
<span class="sig-name descname"><span class="pre">-fstg-lift-lams-non-rec-args</span></span><a class="headerlink" href="#ghc-flag-fstg-lift-lams-non-rec-args" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>5</p>
</dd>
</dl>
<p>Create top-level non-recursive functions with at most &lt;n&gt; parameters
while performing late lambda lifting. The default is 5, the number of
available parameter registers on x86_64.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fstg-lift-lams-rec-args">
<span class="sig-name descname"><span class="pre">-fstg-lift-lams-rec-args</span></span><a class="headerlink" href="#ghc-flag-fstg-lift-lams-rec-args" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>5</p>
</dd>
</dl>
<p>Create top-level recursive functions with at most &lt;n&gt; parameters
while performing late lambda lifting. The default is 5, the number of
available parameter registers on x86_64.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fstrictness">
<span class="sig-name descname"><span class="pre">-fstrictness</span></span><a class="headerlink" href="#ghc-flag-fstrictness" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p>Turn on demand analysis.</p>
<p>A <em>Demand</em> describes an evaluation context of an expression.  <em>Demand
analysis</em> tries to find out what demands a function puts on its arguments
when called: If an argument is scrutinised on every code path, the function
is strict in that argument and GHC is free to use the more efficient
call-by-value calling convention, as well as pass parameters unboxed.</p>
<p>Apart from <em>strictness analysis</em>, demand analysis also performs <em>usage
analysis</em>: Where <em>strict</em> translates to “evaluated at least once”, usage
analysis asks whether arguments and bindings are “evaluated at most once”
or not at all (“evaluated at most zero times”), e.g. <em>absent</em>. For the
former, GHC may use call-by-name instead of call-by-need, effectively
turning thunks into non-memoised functions. For the latter, no code needs
to be generated at all: An absent argument can simply be replaced by a
dummy value at the call site or omitted altogether.</p>
<p>The worker/wrapper transformation (<a class="reference internal" href="#ghc-flag-fworker-wrapper"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fworker-wrapper</span></code></a>) is
responsible for exploiting unboxing opportunities and replacing absent
arguments by dummies. For arguments that can’t be unboxed, opportunities
for call-by-value and call-by-name are exploited in CorePrep when
translating to STG.</p>
<p>It’s not only interesting to look at how often a binding is <em>evaluated</em>,
but also how often a function <em>is called</em>. If a function is called at most
once, we may freely eta-expand it, even if doing so destroys shared work
if the function was called multiple times. This information translates
into <code class="docutils literal notranslate"><span class="pre">OneShotInfo</span></code> annotations that the Simplifier acts on.</p>
<p><strong>Notation</strong></p>
<p>So demand analysis is about conservatively inferring lower and upper
bounds about how many times something is evaluated/called. We call the
“how many times” part a <em>cardinality</em>. In the compiler and debug output
we differentiate the following cardinality intervals as approximations
to cardinality:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Interval</p></th>
<th class="head"><p>Set of denoted cardinalities</p></th>
<th class="head"><p>Syntax</p></th>
<th class="head"><p>Explanation tying syntax to semantics</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>[1,0]</p></td>
<td><p>{}</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">B</span></code></p></td>
<td><p>Bottom element</p></td>
</tr>
<tr class="row-odd"><td><p>[0,0]</p></td>
<td><p>{0}</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">A</span></code></p></td>
<td><p>Absent</p></td>
</tr>
<tr class="row-even"><td><p>[0,1]</p></td>
<td><p>{0,1}</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">M</span></code></p></td>
<td><p>Used at most once (“Maybe”)</p></td>
</tr>
<tr class="row-odd"><td><p>[0,ω]</p></td>
<td><p>{0,1,ω}</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">L</span></code></p></td>
<td><p>Lazy. Top element, no information,
used at least 0, at most many times</p></td>
</tr>
<tr class="row-even"><td><p>[1,1]</p></td>
<td><p>{1}</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">1</span></code></p></td>
<td><p>Strict, used exactly once</p></td>
</tr>
<tr class="row-odd"><td><p>[1,ω]</p></td>
<td><p>{1,ω}</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">S</span></code></p></td>
<td><p>Strict, used possibly many times</p></td>
</tr>
</tbody>
</table>
<p>Note that it’s never interesting to differentiate between a cardinality
of 2 and 3, or even 4232123. We just approximate the &gt;1 case with ω,
standing for “many times”.</p>
<p>Apart from the cardinality describing <em>how often</em> an argument is evaluated,
a demand also carries a <em>sub-demand</em>, describing <em>how deep</em> something
is evaluated beyond a simple <code class="docutils literal notranslate"><span class="pre">seq</span></code>-like evaluation.</p>
<p>This is the full syntax for cardinalities, demands and sub-demands in BNF:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>card ::= B | A | M | L | 1 | S    semantics as in the table above

d    ::= card sd                  card = how often, sd = how deep
      |  card                     abbreviation: Same as &quot;card card&quot;

sd   ::= card                     polymorphic sub-demand, card at every level
      |  P(d,d,..)                product sub-demand
      |  Ccard(sd)                call sub-demand
</pre></div>
</div>
<p>For example, <code class="docutils literal notranslate"><span class="pre">fst</span></code> is strict in its argument, and also in the first
component of the argument.  It will not evaluate the argument’s second
component. That is expressed by the demand <code class="docutils literal notranslate"><span class="pre">1P(1L,A)</span></code>. The <code class="docutils literal notranslate"><span class="pre">P</span></code> is for
“product sub-demand”, which has a <em>demand</em> for each product field. The
notation <code class="docutils literal notranslate"><span class="pre">1L</span></code> just says “evaluated strictly (<code class="docutils literal notranslate"><span class="pre">1</span></code>), with everything
nested inside evaluated according to <code class="docutils literal notranslate"><span class="pre">L</span></code>” – e.g., no information,
because that would depend on the evaluation context of the call site of
<code class="docutils literal notranslate"><span class="pre">fst</span></code>. The role of <code class="docutils literal notranslate"><span class="pre">L</span></code> in <code class="docutils literal notranslate"><span class="pre">1L</span></code> is that of a <em>polymorphic</em> sub-demand,
being semantically equivalent to the sub-demand <code class="docutils literal notranslate"><span class="pre">P(LP(..))</span></code>, which we
simply abbreviate by the (consequently overloaded) cardinality notation
<code class="docutils literal notranslate"><span class="pre">L</span></code>.</p>
<p>For another example, the expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> evaluates <code class="docutils literal notranslate"><span class="pre">x</span></code> according to
demand <code class="docutils literal notranslate"><span class="pre">1P(L)</span></code>. We have seen single letters stand for cardinalities and
polymorphic sub-demands, but what does the single letter <code class="docutils literal notranslate"><span class="pre">L</span></code> mean for a
<em>demand</em>? Such a single letter demand simply expands to a cardinality and
a polymorphic sub-demand of the same letter: E.g. <code class="docutils literal notranslate"><span class="pre">L</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">LL</span></code> by expansion of the single letter demand, which is equivalent to
<code class="docutils literal notranslate"><span class="pre">LP(LP(..))</span></code>, so <code class="docutils literal notranslate"><span class="pre">L</span></code>s all the way down. It is always clear from
context whether we talk about about a cardinality, sub-demand or demand.</p>
<p><strong>Demand signatures</strong></p>
<p>We summarise a function’s demand properties in its <em>demand signature</em>.
This is the general syntax:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{x-&gt;dx,y-&gt;dy,z-&gt;dz...}&lt;d1&gt;&lt;d2&gt;&lt;d3&gt;...&lt;dn&gt;div
        ^              ^   ^   ^      ^   ^
        |              |   |   |      |   |
        |              \---+---+------/   |
        |                  |              |
   demand on free        demand on      divergence
     variables           arguments      information
 (omitted if empty)                     (omitted if
                                      no information)
</pre></div>
</div>
<p>We summarise <code class="docutils literal notranslate"><span class="pre">fst</span></code>’s demand properties in its <em>demand signature</em>
<code class="docutils literal notranslate"><span class="pre">&lt;1P(1L,A)&gt;</span></code>, which just says “If <code class="docutils literal notranslate"><span class="pre">fst</span></code> is applied to one argument,
that argument is evaluated according to <code class="docutils literal notranslate"><span class="pre">1P(1L,A)</span></code>”. For another
example, the demand signature of <code class="docutils literal notranslate"><span class="pre">seq</span></code> would be <code class="docutils literal notranslate"><span class="pre">&lt;1A&gt;&lt;1L&gt;</span></code> and that of
<code class="docutils literal notranslate"><span class="pre">+</span></code> would be <code class="docutils literal notranslate"><span class="pre">&lt;1P(L)&gt;&lt;1P(L)&gt;</span></code>.</p>
<p>If not omitted, the divergence information can be <code class="docutils literal notranslate"><span class="pre">b</span></code> (surely diverges)
or <code class="docutils literal notranslate"><span class="pre">x</span></code> (surely diverges or throws a precise exception).  For example,
<code class="docutils literal notranslate"><span class="pre">error</span></code> has demand signature <code class="docutils literal notranslate"><span class="pre">&lt;S&gt;b</span></code> and <code class="docutils literal notranslate"><span class="pre">throwIO</span></code> (which is the
only way to throw precise exceptions) has demand signature <code class="docutils literal notranslate"><span class="pre">&lt;_&gt;&lt;L&gt;&lt;L&gt;x</span></code>
(leaving out the complicated demand on the <code class="docutils literal notranslate"><span class="pre">Exception</span></code> dictionary).</p>
<p><strong>Call sub-demands</strong></p>
<p>Consider <code class="docutils literal notranslate"><span class="pre">maybe</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">maybe</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">maybe</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">Nothing</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="nf">maybe</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>We give it demand signature <code class="docutils literal notranslate"><span class="pre">&lt;L&gt;&lt;MCM(L)&gt;&lt;1L&gt;</span></code>.  The <code class="docutils literal notranslate"><span class="pre">CM(L)</span></code> is a <em>call
sub-demand</em> that says “Called at most once, where the result is used
according to <code class="docutils literal notranslate"><span class="pre">L</span></code>”. The expression <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">`seq`</span> <span class="pre">f</span> <span class="pre">1</span></code> puts <code class="docutils literal notranslate"><span class="pre">f</span></code> under
demand <code class="docutils literal notranslate"><span class="pre">SC1(L)</span></code> and serves as an example where the upper bound on
evaluation cardinality doesn’t conincide with that of the call cardinality.</p>
<p>Cardinality is always relative to the enclosing call cardinality, so
<code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">1</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">g</span> <span class="pre">3</span> <span class="pre">4</span></code> puts <code class="docutils literal notranslate"><span class="pre">g</span></code> under demand <code class="docutils literal notranslate"><span class="pre">SCS(C1(L))</span></code>, which says
“called multiple times (<code class="docutils literal notranslate"><span class="pre">S</span></code>), but every time it is called with one
argument, it is applied exactly once to another argument (<code class="docutils literal notranslate"><span class="pre">1</span></code>)”.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fstrictness-before-n">
<span class="sig-name descname"><span class="pre">-fstrictness-before</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fstrictness-before-n" title="Permalink to this definition">¶</a></dt>
<dd><p>Run an additional demand analysis before simplifier phase ⟨n⟩.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-funbox-small-strict-fields">
<span class="sig-name descname"><span class="pre">-funbox-small-strict-fields</span></span><a class="headerlink" href="#ghc-flag-funbox-small-strict-fields" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>on</p>
</dd>
</dl>
<p id="index-7">This option causes all constructor fields which
are marked strict (i.e. “!”) and which representation is smaller or
equal to the size of a pointer to be unpacked, if possible. It is
equivalent to adding an <code class="docutils literal notranslate"><span class="pre">UNPACK</span></code> pragma (see <a class="reference internal" href="exts/pragmas.html#unpack-pragma"><span class="std std-ref">UNPACK pragma</span></a>)
to every strict constructor field that fulfils the size restriction.</p>
<p>For example, the constructor fields in the following data types</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="o">!</span><span class="kt">Int</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="o">!</span><span class="kt">A</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="kt">B</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="o">!</span><span class="kt">C</span><span class="w"></span>
</pre></div>
</div>
<p>would all be represented by a single <code class="docutils literal notranslate"><span class="pre">Int#</span></code> (see
<a class="reference internal" href="exts/primitives.html#primitives"><span class="std std-ref">Unboxed types and primitive operations</span></a>) value with <code class="docutils literal notranslate"><span class="pre">-funbox-small-strict-fields</span></code>
enabled.</p>
<p>This option is less of a sledgehammer than
<code class="docutils literal notranslate"><span class="pre">-funbox-strict-fields</span></code>: it should rarely make things worse. If
you use <code class="docutils literal notranslate"><span class="pre">-funbox-small-strict-fields</span></code> to turn on unboxing by
default you can disable it for certain constructor fields using the
<code class="docutils literal notranslate"><span class="pre">NOUNPACK</span></code> pragma (see <a class="reference internal" href="exts/pragmas.html#nounpack-pragma"><span class="std std-ref">NOUNPACK pragma</span></a>).</p>
<p>Note that for consistency <code class="docutils literal notranslate"><span class="pre">Double</span></code>, <code class="docutils literal notranslate"><span class="pre">Word64</span></code>, and <code class="docutils literal notranslate"><span class="pre">Int64</span></code>
constructor fields are unpacked on 32-bit platforms, even though
they are technically larger than a pointer on those platforms.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-funbox-strict-fields">
<span class="sig-name descname"><span class="pre">-funbox-strict-fields</span></span><a class="headerlink" href="#ghc-flag-funbox-strict-fields" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>off</p>
</dd>
</dl>
<p id="index-8">This option causes all constructor fields which are marked strict
(i.e. <code class="docutils literal notranslate"><span class="pre">!</span></code>) to be unpacked if possible. It is equivalent to adding an
<code class="docutils literal notranslate"><span class="pre">UNPACK</span></code> pragma to every strict constructor field (see
<a class="reference internal" href="exts/pragmas.html#unpack-pragma"><span class="std std-ref">UNPACK pragma</span></a>).</p>
<p>This option is a bit of a sledgehammer: it might sometimes make
things worse. Selectively unboxing fields by using <code class="docutils literal notranslate"><span class="pre">UNPACK</span></code>
pragmas might be better. An alternative is to use
<code class="docutils literal notranslate"><span class="pre">-funbox-strict-fields</span></code> to turn on unboxing by default but disable
it for certain constructor fields using the <code class="docutils literal notranslate"><span class="pre">NOUNPACK</span></code> pragma (see
<a class="reference internal" href="exts/pragmas.html#nounpack-pragma"><span class="std std-ref">NOUNPACK pragma</span></a>).</p>
<p>Alternatively you can use <a class="reference internal" href="#ghc-flag-funbox-small-strict-fields"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funbox-small-strict-fields</span></code></a> to only
unbox strict fields which are “small”.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-funfolding-creation-threshold-n">
<span class="sig-name descname"><span class="pre">-funfolding-creation-threshold</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-funfolding-creation-threshold-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>750</p>
</dd>
</dl>
<p id="index-9">Governs the maximum size that GHC will allow a
function unfolding to be. (An unfolding has a “size” that reflects
the cost in terms of “code bloat” of expanding (aka inlining) that
unfolding at a call site. A bigger function would be assigned a
bigger cost.)</p>
<p>Consequences:</p>
<ol class="loweralpha simple">
<li><p>nothing larger than this will be inlined (unless it has an <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> pragma)</p></li>
<li><p>nothing larger than this will be spewed into an interface file.</p></li>
</ol>
<p>Increasing this figure is more likely to result in longer compile times
than faster code. The <a class="reference internal" href="#ghc-flag-funfolding-use-threshold-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-use-threshold=⟨n⟩</span></code></a> is more
useful.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-funfolding-dict-discount-n">
<span class="sig-name descname"><span class="pre">-funfolding-dict-discount</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-funfolding-dict-discount-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>30</p>
</dd>
</dl>
<p id="index-10">How eager should the compiler be to inline dictionaries?</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-funfolding-fun-discount-n">
<span class="sig-name descname"><span class="pre">-funfolding-fun-discount</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-funfolding-fun-discount-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>60</p>
</dd>
</dl>
<p id="index-11">How eager should the compiler be to inline functions?</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-funfolding-keeness-factor-n">
<span class="sig-name descname"><span class="pre">-funfolding-keeness-factor</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-funfolding-keeness-factor-n" title="Permalink to this definition">¶</a></dt>
<dd><p>This factor was deprecated in GHC 9.0.1. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/15304">#15304</a> for
details. Users who need to control inlining should rather consider
<a class="reference internal" href="#ghc-flag-funfolding-use-threshold-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-use-threshold=⟨n⟩</span></code></a>.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-funfolding-use-threshold-n">
<span class="sig-name descname"><span class="pre">-funfolding-use-threshold</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-funfolding-use-threshold-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>80</p>
</dd>
</dl>
<p id="index-12">This is the magic cut-off figure for unfolding (aka
inlining): below this size, a function definition will be unfolded
at the call-site, any bigger and it won’t. The size computed for a
function depends on two things: the actual size of the expression
minus any discounts that apply depending on the context into which
the expression is to be inlined.</p>
<p>The difference between this and
<a class="reference internal" href="#ghc-flag-funfolding-creation-threshold-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-creation-threshold=⟨n⟩</span></code></a> is that this one determines
if a function definition will be inlined <em>at a call site</em>. The other option
determines if a function definition will be kept around at all for
potential inlining.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-funfolding-case-threshold-n">
<span class="sig-name descname"><span class="pre">-funfolding-case-threshold</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-funfolding-case-threshold-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>2</p>
</dd>
</dl>
<p id="index-13">GHC is in general quite eager to inline small functions. However sometimes
these functions will be expanded by more inlining after inlining. Since
they are now applied to “interesting” arguments. Even worse, their expanded
form might reference again a small function, which will be inlined and expanded
afterwards. This can repeat often and lead to explosive growth of programs.</p>
<p>As it happened in #18730.</p>
<p>Starting with GHC 9.0 we will be less eager to inline deep into nested cases.
We achieve this by applying a inlining penalty that increases as the nesting
gets deeper. However sometimes a specific (maybe quite high!) threshold of nesting
is to be expected.</p>
<p>In such cases this flag can be used to ignore the first ⟨n⟩ levels of nesting
when computing the penalty.</p>
<p>This flag in combination with <a class="reference internal" href="#ghc-flag-funfolding-case-scaling-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-case-scaling=⟨n⟩</span></code></a> can
be used to break inlining loops without disabling inlining completely. For
this purpose a smaller value is more likely to break such loops although
often adjusting the scaling is enough and preferably.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-funfolding-case-scaling-n">
<span class="sig-name descname"><span class="pre">-funfolding-case-scaling</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-funfolding-case-scaling-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>30</p>
</dd>
</dl>
<p id="index-14">GHC is in general quite eager to inline small functions. However sometimes
these functions will be expanded by more inlining after inlining. Since
they are now applied to “interesting” arguments. Even worse, their expanded
form might reference again a small function, which will be inlined and expanded
afterwards. This can repeat often and lead to explosive growth of programs.</p>
<p>As it happened in #18730.</p>
<p>Starting with GHC 9.0 we will be less eager to inline deep into nested cases.
We achieve this by applying a inlining penalty that increases as the nesting
gets deeper. However sometimes we are ok with inlining a lot in the name of
performance.</p>
<p>In such cases this flag can be used to tune how hard we penalize inlining into
deeply nested cases beyond the threshold set by <a class="reference internal" href="#ghc-flag-funfolding-case-threshold-n"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-funfolding-case-threshold=⟨n⟩</span></code></a>.
Cases are only counted against the nesting level if they have more than one alternative.</p>
<p>We use 1/n to scale the penalty. That is a higher value gives a lower penalty.</p>
<p>This can be used to break inlining loops. For this purpose a lower value is
recommended. Values in the range 10 &lt;= n &lt;= 20 allow some inlining to take place
while still allowing GHC to compile modules containing such inlining loops.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fworker-wrapper">
<span class="sig-name descname"><span class="pre">-fworker-wrapper</span></span><a class="headerlink" href="#ghc-flag-fworker-wrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the worker/wrapper transformation after a demand analysis pass.</p>
<p>Exploits strictness and absence information by unboxing strict arguments
and replacing absent fields by dummy values in a wrapper function that
will inline in all relevant scenarios and thus expose a specialised,
unboxed calling convention of the worker function.</p>
<p>Implied by <a class="reference internal" href="#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a>, and by <a class="reference internal" href="#ghc-flag-fstrictness"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fstrictness</span></code></a>.
Disabled by <a class="reference internal" href="#ghc-flag--fstrictness"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fno-strictness</span></code></a>. Enabling <a class="reference internal" href="#ghc-flag-fworker-wrapper"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fworker-wrapper</span></code></a>
while demand analysis is disabled (by <a class="reference internal" href="#ghc-flag--fstrictness"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fno-strictness</span></code></a>)
has no effect.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fbinary-blob-threshold-n">
<span class="sig-name descname"><span class="pre">-fbinary-blob-threshold</span></span><span class="sig-prename descclassname"><span class="pre">=⟨n⟩</span></span><a class="headerlink" href="#ghc-flag-fbinary-blob-threshold-n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>500000</p>
</dd>
</dl>
<p>The native code-generator can either dump binary blobs (e.g. string
literals) into the assembly file (by using “.asciz” or “.string” assembler
directives) or it can dump them as binary data into a temporary file which
is then included by the assembler (using the “.incbin” assembler directive).</p>
<p>This flag sets the size (in bytes) threshold above which the second approach
is used. You can disable the second approach entirely by setting the
threshold to 0.</p>
</dd></dl>

</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="using-concurrent.html" class="btn btn-neutral float-right" title="5.4. Using Concurrent Haskell" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="using-warnings.html" class="btn btn-neutral float-left" title="5.2. Warnings and sanity-checking" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
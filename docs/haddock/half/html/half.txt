-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Half-precision floating-point
--   
--   Half-precision floating-point.
@package half
@version 0.3.1


-- | Half-precision floating-point values. These arise commonly in GPU work
--   and it is useful to be able to compute them and compute with them on
--   the CPU as well.
module Numeric.Half.Internal
newtype {-# CTYPE "unsigned short" #-} Half
Half :: CUShort -> Half
[getHalf] :: Half -> CUShort

-- | Is this <a>Half</a> equal to 0?
isZero :: Half -> Bool

-- | Convert a <a>Half</a> to a <a>Float</a> while preserving NaN
fromHalf :: Half -> Float

-- | Convert a <a>Float</a> to a <a>Half</a> with proper rounding, while
--   preserving NaN and dealing appropriately with infinity
toHalf :: Float -> Half

-- | Positive infinity
pattern POS_INF :: Half

-- | Negative infinity
pattern NEG_INF :: Half

-- | Quiet NaN
pattern QNaN :: Half

-- | Signalling NaN
pattern SNaN :: Half

-- | Smallest positive half
pattern HALF_MIN :: Half

-- | Smallest positive normalized half
pattern HALF_NRM_MIN :: Half

-- | Largest positive half
pattern HALF_MAX :: Half

-- | Smallest positive e for which half (1.0 + e) != half (1.0)
pattern HALF_EPSILON :: Half

-- | Number of base 10 digits that can be represented without change
pattern HALF_DIG :: (Eq a, Num a) => a
pattern HALF_MIN_10_EXP :: (Eq a, Num a) => a
pattern HALF_MAX_10_EXP :: (Eq a, Num a) => a

-- | Naive pure-Haskell implementation of <a>toHalf</a>.
pure_floatToHalf :: Float -> Half

-- | Naive pure-Haskell implementation of <a>fromHalf</a>.
pure_halfToFloat :: Half -> Float
instance GHC.Generics.Generic Numeric.Half.Internal.Half
instance Control.DeepSeq.NFData Numeric.Half.Internal.Half
instance Data.Binary.Class.Binary Numeric.Half.Internal.Half
instance Foreign.Storable.Storable Numeric.Half.Internal.Half
instance GHC.Show.Show Numeric.Half.Internal.Half
instance GHC.Read.Read Numeric.Half.Internal.Half
instance GHC.Classes.Eq Numeric.Half.Internal.Half
instance GHC.Classes.Ord Numeric.Half.Internal.Half
instance GHC.Real.Real Numeric.Half.Internal.Half
instance GHC.Real.Fractional Numeric.Half.Internal.Half
instance GHC.Real.RealFrac Numeric.Half.Internal.Half
instance GHC.Float.Floating Numeric.Half.Internal.Half
instance GHC.Float.RealFloat Numeric.Half.Internal.Half
instance GHC.Num.Num Numeric.Half.Internal.Half
instance Language.Haskell.TH.Syntax.Lift Numeric.Half.Internal.Half


-- | Half-precision floating-point values. These arise commonly in GPU work
--   and it is useful to be able to compute them and compute with them on
--   the CPU as well.
module Numeric.Half
newtype {-# CTYPE "unsigned short" #-} Half
Half :: CUShort -> Half
[getHalf] :: Half -> CUShort

-- | Is this <a>Half</a> equal to 0?
isZero :: Half -> Bool

-- | Convert a <a>Half</a> to a <a>Float</a> while preserving NaN
fromHalf :: Half -> Float

-- | Convert a <a>Float</a> to a <a>Half</a> with proper rounding, while
--   preserving NaN and dealing appropriately with infinity
toHalf :: Float -> Half

-- | Positive infinity
pattern POS_INF :: Half

-- | Negative infinity
pattern NEG_INF :: Half

-- | Quiet NaN
pattern QNaN :: Half

-- | Signalling NaN
pattern SNaN :: Half

-- | Smallest positive half
pattern HALF_MIN :: Half

-- | Smallest positive normalized half
pattern HALF_NRM_MIN :: Half

-- | Largest positive half
pattern HALF_MAX :: Half

-- | Smallest positive e for which half (1.0 + e) != half (1.0)
pattern HALF_EPSILON :: Half

-- | Number of base 10 digits that can be represented without change
pattern HALF_DIG :: (Eq a, Num a) => a
pattern HALF_MIN_10_EXP :: (Eq a, Num a) => a
pattern HALF_MAX_10_EXP :: (Eq a, Num a) => a

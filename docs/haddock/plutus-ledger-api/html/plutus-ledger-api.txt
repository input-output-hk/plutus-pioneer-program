-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Interface to the Plutus ledger for the Cardano ledger.
--   
--   Interface to the Plutus scripting support for the Cardano ledger.
@package plutus-ledger-api
@version 1.1.1.0


-- | This module contains the protocol versions and plutus versions as
--   witnessed by the cardano ledger.
module PlutusLedgerApi.Common.Versions

-- | This represents the Cardano protocol version, with its major and minor
--   components. This relies on careful understanding between us and the
--   ledger as to what this means.
data ProtocolVersion
ProtocolVersion :: Int -> Int -> ProtocolVersion

-- | the major component
[pvMajor] :: ProtocolVersion -> Int

-- | the minor component
[pvMinor] :: ProtocolVersion -> Int

-- | Shelley era was introduced in protocol version 2.0
shelleyPV :: ProtocolVersion

-- | Allegra era was introduced in protocol version 3.0
allegraPV :: ProtocolVersion

-- | Mary era was introduced in protocol version 4.0
maryPV :: ProtocolVersion

-- | Alonzo era was introduced in protocol version 5.0
alonzoPV :: ProtocolVersion

-- | Vasil era was introduced in protocol version 7.0
vasilPV :: ProtocolVersion

-- | Chang era is not yet published. It will probably be introduced in
--   protocol version 8.0
changPV :: ProtocolVersion

-- | The ledger Plutus versions. These are entirely different script
--   languages from the ledger's perspective, which on our side are
--   interpreted in very similar ways.
--   
--   It is a simple enumerated datatype (there is no major and minor
--   components as in protocol version) and the <b>ordering of
--   constructors</b> is essential for deriving Enum,Ord,Bounded.
--   
--   IMPORTANT: this is different from the AST's <a>Version</a>
data LedgerPlutusVersion

-- | introduced in shelley era
PlutusV1 :: LedgerPlutusVersion

-- | introduced in vasil era
PlutusV2 :: LedgerPlutusVersion

-- | not yet enabled, probably will be introduced in chang era
PlutusV3 :: LedgerPlutusVersion

-- | Query the protocol version that a specific ledger Plutus version was
--   first introduced in.
--   
--   <i>Introduction</i> in this context means the enablement/allowance of
--   scripts of that ledger Plutus version to be executed on-chain.
languageIntroducedIn :: LedgerPlutusVersion -> ProtocolVersion

-- | Given a protocol version return a set of all available ledger Plutus
--   versions that are enabled/allowed to run.
--   
--   Assumes that the ledger Plutus versions once introduced/enabled, will
--   never be disabled in the future.
languagesAvailableIn :: ProtocolVersion -> Set LedgerPlutusVersion

-- | A map indicating which builtin functions were introduced in which
--   <a>ProtocolVersion</a>. Each builtin function should appear at most
--   once.
--   
--   This <b>must</b> be updated when new builtins are added. See Note [New
--   builtins and protocol versions]
builtinsIntroducedIn :: Map (LedgerPlutusVersion, ProtocolVersion) (Set DefaultFun)

-- | Which builtin functions are available in the given
--   <a>ProtocolVersion</a>?
--   
--   See Note [New builtins and protocol versions]
builtinsAvailableIn :: LedgerPlutusVersion -> ProtocolVersion -> Set DefaultFun
instance GHC.Enum.Bounded PlutusLedgerApi.Common.Versions.LedgerPlutusVersion
instance GHC.Enum.Enum PlutusLedgerApi.Common.Versions.LedgerPlutusVersion
instance GHC.Generics.Generic PlutusLedgerApi.Common.Versions.LedgerPlutusVersion
instance GHC.Show.Show PlutusLedgerApi.Common.Versions.LedgerPlutusVersion
instance GHC.Classes.Ord PlutusLedgerApi.Common.Versions.LedgerPlutusVersion
instance GHC.Classes.Eq PlutusLedgerApi.Common.Versions.LedgerPlutusVersion
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.Common.Versions.LedgerPlutusVersion


-- | The types and functions that are common among all ledger Plutus
--   versions.
module PlutusLedgerApi.Common

-- | Scripts to the ledger are serialised bytestrings.
type SerialisedScript = ShortByteString

-- | Turns a program which was compiled using the 'PlutusTx' toolchain into
--   a binary format that is understood by the network and can be stored
--   on-chain.
serialiseCompiledCode :: forall a. CompiledCode a -> SerialisedScript

-- | Turns a program's AST (most likely manually constructed) into a binary
--   format that is understood by the network and can be stored on-chain.
serialiseUPLC :: Program DeBruijn DefaultUni DefaultFun () -> SerialisedScript

-- | Deserialises a <a>SerialisedScript</a> back into an AST.
deserialiseUPLC :: SerialisedScript -> Program DeBruijn DefaultUni DefaultFun ()

-- | An error that occurred during script deserialization.
data ScriptDecodeError

-- | an error from the underlying CBOR/serialise library
CBORDeserialiseError :: DeserialiseFailure -> ScriptDecodeError

-- | Script was successfully parsed, but more (runaway) bytes encountered
--   after script's position
RemainderError :: ByteString -> ScriptDecodeError

-- | the plutus version of the given script is not enabled yet
LanguageNotAvailableError :: LedgerPlutusVersion -> ProtocolVersion -> ProtocolVersion -> ScriptDecodeError

-- | the script's plutus version
[sdeAffectedLang] :: ScriptDecodeError -> LedgerPlutusVersion

-- | the protocol version that will first introduce/enable the plutus
--   version
[sdeIntroPv] :: ScriptDecodeError -> ProtocolVersion

-- | the protocol version in which the error occurred
[sdeThisPv] :: ScriptDecodeError -> ProtocolVersion

-- | Check if a <tt>Script</tt> is "valid" according to a protocol version.
--   At the moment this means "deserialises correctly", which in particular
--   implies that it is (almost certainly) an encoded script and the script
--   does not mention any builtins unavailable in the given protocol
--   version.
--   
--   Note: Parameterized over the ledger-plutus-version since the builtins
--   allowed (during decoding) differs.
assertScriptWellFormed :: MonadError ScriptDecodeError m => LedgerPlutusVersion -> ProtocolVersion -> SerialisedScript -> m ()

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. This will take as long as the script
--   takes, if you need to limit the execution time of the script also, you
--   can use <a>evaluateScriptRestricting</a>, which also returns the used
--   budget.
--   
--   Note: Parameterized over the ledger-plutus-version since the builtins
--   allowed (during decoding) differs.
evaluateScriptCounting :: LedgerPlutusVersion -> ProtocolVersion -> VerboseMode -> EvaluationContext -> SerialisedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
--   
--   Note: Parameterized over the ledger-plutus-version since the builtins
--   allowed (during decoding) differs.
evaluateScriptRestricting :: LedgerPlutusVersion -> ProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> SerialisedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | A simple toggle indicating whether or not we should accumulate logs
--   during script execution.
data VerboseMode

-- | accumulate all traces
Verbose :: VerboseMode

-- | don't accumulate anything
Quiet :: VerboseMode

-- | The type of the executed script's accumulated log output: a list of
--   <a>Text</a>.
--   
--   It will be an empty list if the <a>VerboseMode</a> is set to
--   <a>Quiet</a>.
type LogOutput = [Text]

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: FreeVariableError -> EvaluationError

-- | A deserialisation error
CodecError :: ScriptDecodeError -> EvaluationError

-- | An error indicating a version tag that we don't support TODO: make
--   this error more informative when we have more information about what
--   went wrong
IncompatibleVersionError :: Version () -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError

-- | This represents the Cardano protocol version, with its major and minor
--   components. This relies on careful understanding between us and the
--   ledger as to what this means.
data ProtocolVersion
ProtocolVersion :: Int -> Int -> ProtocolVersion

-- | the major component
[pvMajor] :: ProtocolVersion -> Int

-- | the minor component
[pvMinor] :: ProtocolVersion -> Int

-- | The ledger Plutus versions. These are entirely different script
--   languages from the ledger's perspective, which on our side are
--   interpreted in very similar ways.
--   
--   It is a simple enumerated datatype (there is no major and minor
--   components as in protocol version) and the <b>ordering of
--   constructors</b> is essential for deriving Enum,Ord,Bounded.
--   
--   IMPORTANT: this is different from the AST's <a>Version</a>
data LedgerPlutusVersion

-- | introduced in shelley era
PlutusV1 :: LedgerPlutusVersion

-- | introduced in vasil era
PlutusV2 :: LedgerPlutusVersion

-- | not yet enabled, probably will be introduced in chang era
PlutusV3 :: LedgerPlutusVersion

-- | A map indicating which builtin functions were introduced in which
--   <a>ProtocolVersion</a>. Each builtin function should appear at most
--   once.
--   
--   This <b>must</b> be updated when new builtins are added. See Note [New
--   builtins and protocol versions]
builtinsIntroducedIn :: Map (LedgerPlutusVersion, ProtocolVersion) (Set DefaultFun)

-- | Which builtin functions are available in the given
--   <a>ProtocolVersion</a>?
--   
--   See Note [New builtins and protocol versions]
builtinsAvailableIn :: LedgerPlutusVersion -> ProtocolVersion -> Set DefaultFun

-- | A raw representation of the ledger's cost model parameters.
--   
--   The associated keys/names to the parameter values are arbitrarily set
--   by the plutus team; the ledger does not hold any such names.
--   
--   See Note [Cost model parameters]
type CostModelParams = Map Text Integer

-- | Untags the plutus version from the typed cost model parameters and
--   returns their raw textual form (internally used by
--   CostModelInterface).
toCostModelParams :: IsParamName k => [(k, Integer)] -> CostModelParams
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | A parameter name for different plutus versions.
--   
--   Each Plutus version should expose such an enumeration as an ADT and
--   create an instance of <tt>ParamName</tt> out of it.
--   
--   A valid parameter name has to be enumeration, bounded, ordered, and
--   prettyprintable to a "lower-Kebab" string.
class IsParamName a

-- | Take the raw textual form for a given typed-by-plutus-version cost
--   model parameter
showParamName :: IsParamName a => a -> String

-- | A Generic wrapper for use with deriving via
data GenericParamName a

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   There are two sets of parameters: one is with immediate unlifting and
--   the other one is with deferred unlifting. We have to keep both of
--   them, because depending on the language version either one has to be
--   used or the other. We also compile them separately due to all the
--   inlining and optimization that need to happen for things to be
--   efficient.
data EvaluationContext
EvaluationContext :: DefaultMachineParameters -> DefaultMachineParameters -> EvaluationContext
[machineParametersImmediate] :: EvaluationContext -> DefaultMachineParameters
[machineParametersDeferred] :: EvaluationContext -> DefaultMachineParameters

-- | Create an <a>EvaluationContext</a> for a given plutus-builtins'
--   version.
--   
--   The input is a <a>Map</a> of <a>Text</a>s to cost integer values (aka
--   <a>CostModelParams</a>, <a>CostModel</a>) See Note [Inlining meanings
--   of builtins].
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkDynEvaluationContext :: MonadError CostModelApplyError m => BuiltinVersion DefaultFun -> CostModelParams -> m EvaluationContext

-- | Get the raw machine parameters (as understood by the CEK evaluator)
--   stored inside an <a>EvaluationContext</a>.
toMachineParameters :: ProtocolVersion -> EvaluationContext -> DefaultMachineParameters


-- | A type for intervals and associated functions.
module PlutusLedgerApi.V1.Interval

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
--   
--   The <a>Eq</a>uality of two intervals is specified as the canonical,
--   structural equality and not the equality of the elements of their two
--   underlying sets; the same holds for <a>Ord</a>.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | Check whether a value is in an interval.
member :: Ord a => a -> Interval a -> Bool

-- | <tt>interval a b</tt> includes all values that are greater than or
--   equal to <tt>a</tt> and smaller than or equal to <tt>b</tt>. Therefore
--   it includes <tt>a</tt> and <tt>b</tt>. In math. notation: [a,b]
interval :: a -> a -> Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>. In math. notation: [a,+∞]
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>. In math. notation: [-∞,a]
to :: a -> Interval a

-- | An <a>Interval</a> that covers every slot. In math. notation [-∞,+∞]
always :: Interval a

-- | An <a>Interval</a> that is empty.
--   
--   There can be many empty intervals, see <a>isEmpty</a>. The empty
--   interval <a>never</a> is arbitrarily set to [+∞,-∞].
never :: Interval a

-- | Create an interval that includes just a single concrete point
--   <tt>a</tt>, i.e. having the same non-strict lower and upper bounds. In
--   math.notation: [a,a]
singleton :: a -> Interval a

-- | 'hull a b' is the smallest interval containing <tt>a</tt> and
--   <tt>b</tt>.
hull :: Ord a => Interval a -> Interval a -> Interval a

-- | 'intersection a b' is the largest interval that is contained in
--   <tt>a</tt> and in <tt>b</tt>, if it exists.
intersection :: Ord a => Interval a -> Interval a -> Interval a

-- | Check whether two intervals overlap, that is, whether there is a value
--   that is a member of both intervals.
overlaps :: (Enum a, Ord a) => Interval a -> Interval a -> Bool

-- | <tt>a <a>contains</a> b</tt> is true if the <a>Interval</a> <tt>b</tt>
--   is entirely contained in <tt>a</tt>. That is, <tt>a <a>contains</a>
--   b</tt> if for every entry <tt>s</tt>, if <tt>member s b</tt> then
--   <tt>member s a</tt>.
contains :: Ord a => Interval a -> Interval a -> Bool

-- | Check if an <a>Interval</a> is empty.
--   
--   There can be many empty intervals, given a set of values. Two
--   <a>Interval</a>s being empty does not imply that they are <a>Eq</a>ual
--   to each other.
isEmpty :: (Enum a, Ord a) => Interval a -> Bool

-- | Check if a value is earlier than the beginning of an <a>Interval</a>.
before :: Ord a => a -> Interval a -> Bool

-- | Check if a value is later than the end of an <a>Interval</a>.
after :: Ord a => a -> Interval a -> Bool

-- | Construct a lower bound from a value.
--   
--   The resulting bound includes all values that are equal or greater than
--   the input value.
lowerBound :: a -> LowerBound a

-- | Construct an upper bound from a value.
--   
--   The resulting bound includes all values that are equal or smaller than
--   the input value.
upperBound :: a -> UpperBound a

-- | Construct a strict lower bound from a value.
--   
--   The resulting bound includes all values that are (strictly) greater
--   than the input value.
strictLowerBound :: a -> LowerBound a

-- | Construct a strict upper bound from a value.
--   
--   The resulting bound includes all values that are (strictly) smaller
--   than the input value.
strictUpperBound :: a -> UpperBound a
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Interval.Interval
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.LowerBound a), PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.UpperBound a)) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (PlutusLedgerApi.V1.Interval.Extended a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (PlutusLedgerApi.V1.Interval.Extended a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (PlutusLedgerApi.V1.Interval.UpperBound a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (PlutusLedgerApi.V1.Interval.UpperBound a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (PlutusLedgerApi.V1.Interval.LowerBound a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (PlutusLedgerApi.V1.Interval.LowerBound a)
instance PlutusTx.Ord.Ord a => PlutusTx.Lattice.JoinSemiLattice (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.Ord.Ord a => PlutusTx.Lattice.BoundedJoinSemiLattice (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.Ord.Ord a => PlutusTx.Lattice.MeetSemiLattice (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.Ord.Ord a => PlutusTx.Lattice.BoundedMeetSemiLattice (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Interval.UpperBound
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.Extended a)) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.UpperBound a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Interval.LowerBound
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.Extended a)) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.LowerBound a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Interval.Extended
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni a) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.Extended a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (PlutusLedgerApi.V1.Interval.LowerBound a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (PlutusLedgerApi.V1.Interval.LowerBound a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (PlutusLedgerApi.V1.Interval.LowerBound a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (PlutusLedgerApi.V1.Interval.UpperBound a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (PlutusLedgerApi.V1.Interval.UpperBound a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (PlutusLedgerApi.V1.Interval.UpperBound a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (PlutusLedgerApi.V1.Interval.Extended a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (PlutusLedgerApi.V1.Interval.Extended a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (PlutusLedgerApi.V1.Interval.Extended a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusLedgerApi.V1.Interval.Extended a)
instance GHC.Generics.Generic (PlutusLedgerApi.V1.Interval.Extended a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusLedgerApi.V1.Interval.Extended a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (PlutusLedgerApi.V1.Interval.Extended a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusLedgerApi.V1.Interval.Extended a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusLedgerApi.V1.Interval.UpperBound a)
instance GHC.Generics.Generic (PlutusLedgerApi.V1.Interval.UpperBound a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusLedgerApi.V1.Interval.UpperBound a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (PlutusLedgerApi.V1.Interval.UpperBound a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusLedgerApi.V1.Interval.UpperBound a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusLedgerApi.V1.Interval.LowerBound a)
instance GHC.Generics.Generic (PlutusLedgerApi.V1.Interval.LowerBound a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusLedgerApi.V1.Interval.LowerBound a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (PlutusLedgerApi.V1.Interval.LowerBound a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusLedgerApi.V1.Interval.LowerBound a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusLedgerApi.V1.Interval.Interval a)
instance GHC.Generics.Generic (PlutusLedgerApi.V1.Interval.Interval a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusLedgerApi.V1.Interval.Interval a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (PlutusLedgerApi.V1.Interval.Interval a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.Functor.Functor PlutusLedgerApi.V1.Interval.Interval
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.Functor.Functor PlutusLedgerApi.V1.Interval.LowerBound
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (PlutusLedgerApi.V1.Interval.LowerBound a)
instance PlutusTx.Functor.Functor PlutusLedgerApi.V1.Interval.UpperBound
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (PlutusLedgerApi.V1.Interval.UpperBound a)
instance PlutusTx.Functor.Functor PlutusLedgerApi.V1.Interval.Extended
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (PlutusLedgerApi.V1.Interval.Extended a)

module PlutusLedgerApi.V1.ParamName

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'intercept :: ParamName
DivideInteger'cpu'arguments'model'arguments'slope :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'intercept :: ParamName
ModInteger'cpu'arguments'model'arguments'slope :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'minimum :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'intercept :: ParamName
QuotientInteger'cpu'arguments'model'arguments'slope :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'intercept :: ParamName
RemainderInteger'cpu'arguments'model'arguments'slope :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName

-- | Given an ordered list of parameter values, tag them with their
--   parameter names. If the passed parameter values are more than
--   expected: the function will ignore the extraneous values at the tail
--   of the list, if the passed values are less than expected: the function
--   will throw an error; for more information, see Note [Cost model
--   parameters from the ledger's point of view]
tagWithParamNames :: forall k m. (Enum k, Bounded k, MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Integer] -> m [(k, Integer)]
instance PlutusLedgerApi.Common.ParamName.IsParamName PlutusLedgerApi.V1.ParamName.ParamName
instance GHC.Generics.Generic PlutusLedgerApi.V1.ParamName.ParamName
instance GHC.Enum.Bounded PlutusLedgerApi.V1.ParamName.ParamName
instance GHC.Ix.Ix PlutusLedgerApi.V1.ParamName.ParamName
instance GHC.Enum.Enum PlutusLedgerApi.V1.ParamName.ParamName
instance GHC.Classes.Ord PlutusLedgerApi.V1.ParamName.ParamName
instance GHC.Classes.Eq PlutusLedgerApi.V1.ParamName.ParamName

module PlutusLedgerApi.V1.EvaluationContext

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   There are two sets of parameters: one is with immediate unlifting and
--   the other one is with deferred unlifting. We have to keep both of
--   them, because depending on the language version either one has to be
--   used or the other. We also compile them separately due to all the
--   inlining and optimization that need to happen for things to be
--   efficient.
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of integer values passed from the ledger and are
--   expected to appear in correct order.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Integer] -> m EvaluationContext

-- | A raw representation of the ledger's cost model parameters.
--   
--   The associated keys/names to the parameter values are arbitrarily set
--   by the plutus team; the ledger does not hold any such names.
--   
--   See Note [Cost model parameters]
type CostModelParams = Map Text Integer
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | Get the raw machine parameters (as understood by the CEK evaluator)
--   stored inside an <a>EvaluationContext</a>.
toMachineParameters :: ProtocolVersion -> EvaluationContext -> DefaultMachineParameters

-- | A fatal error when trying to create a cost given some plain costmodel
--   parameters.
data CostModelApplyError

-- | a costmodel parameter with the give name does not exist in the
--   costmodel to be applied upon
CMUnknownParamError :: Text -> CostModelApplyError

-- | internal error when we are transforming the applyParams' input to json
--   (should not happen)
CMInternalReadError :: CostModelApplyError

-- | internal error when we are transforming the applied params from json
--   with given jsonstring error (should not happen)
CMInternalWriteError :: String -> CostModelApplyError

-- | See Note [Cost model parameters from the ledger's point of view]
CMTooFewParamsError :: Int -> Int -> CostModelApplyError
[cmTooFewExpected] :: CostModelApplyError -> Int
[cmTooFewActual] :: CostModelApplyError -> Int


-- | UTCTime and UTCTime ranges.
module PlutusLedgerApi.V1.Time

-- | POSIX time is measured as the number of <i>milliseconds</i> since
--   1970-01-01T00:00:00Z. This is not the same as Haskell's
--   <a>POSIXTime</a>
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | This is a length of time, as measured by a number of milliseconds.
newtype DiffMilliSeconds
DiffMilliSeconds :: Integer -> DiffMilliSeconds

-- | Simple conversion from <a>DiffMilliSeconds</a> to <a>POSIXTime</a>.
fromMilliSeconds :: DiffMilliSeconds -> POSIXTime
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Time.POSIXTime
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Real.Integral PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Real.Real PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Enum.Enum PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Num.Num PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Enum.Enum PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Numeric.AdditiveGroup PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Numeric.AdditiveMonoid PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Numeric.AdditiveSemigroup PlutusLedgerApi.V1.Time.POSIXTime
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Generics.Generic PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Show.Show PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Classes.Ord PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Classes.Eq PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Real.Integral PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Real.Real PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Enum.Enum PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.Numeric.AdditiveGroup PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.Numeric.AdditiveMonoid PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.Numeric.AdditiveSemigroup PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Num.Num PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Generics.Generic PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Show.Show PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Classes.Ord PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Classes.Eq PlutusLedgerApi.V1.Time.DiffMilliSeconds

module PlutusLedgerApi.V2.ParamName

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'intercept :: ParamName
DivideInteger'cpu'arguments'model'arguments'slope :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'intercept :: ParamName
ModInteger'cpu'arguments'model'arguments'slope :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'minimum :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'intercept :: ParamName
QuotientInteger'cpu'arguments'model'arguments'slope :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'intercept :: ParamName
RemainderInteger'cpu'arguments'model'arguments'slope :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
SerialiseData'cpu'arguments'intercept :: ParamName
SerialiseData'cpu'arguments'slope :: ParamName
SerialiseData'memory'arguments'intercept :: ParamName
SerialiseData'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'cpu'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'intercept :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'slope :: ParamName
VerifySchnorrSecp256k1Signature'memory'arguments :: ParamName

-- | Given an ordered list of parameter values, tag them with their
--   parameter names. If the passed parameter values are more than
--   expected: the function will ignore the extraneous values at the tail
--   of the list, if the passed values are less than expected: the function
--   will throw an error; for more information, see Note [Cost model
--   parameters from the ledger's point of view]
tagWithParamNames :: forall k m. (Enum k, Bounded k, MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Integer] -> m [(k, Integer)]
instance PlutusLedgerApi.Common.ParamName.IsParamName PlutusLedgerApi.V2.ParamName.ParamName
instance GHC.Generics.Generic PlutusLedgerApi.V2.ParamName.ParamName
instance GHC.Enum.Bounded PlutusLedgerApi.V2.ParamName.ParamName
instance GHC.Ix.Ix PlutusLedgerApi.V2.ParamName.ParamName
instance GHC.Enum.Enum PlutusLedgerApi.V2.ParamName.ParamName
instance GHC.Classes.Ord PlutusLedgerApi.V2.ParamName.ParamName
instance GHC.Classes.Eq PlutusLedgerApi.V2.ParamName.ParamName

module PlutusLedgerApi.V2.EvaluationContext

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   There are two sets of parameters: one is with immediate unlifting and
--   the other one is with deferred unlifting. We have to keep both of
--   them, because depending on the language version either one has to be
--   used or the other. We also compile them separately due to all the
--   inlining and optimization that need to happen for things to be
--   efficient.
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of integer values passed from the ledger and are
--   expected to appear in correct order.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Integer] -> m EvaluationContext

-- | A raw representation of the ledger's cost model parameters.
--   
--   The associated keys/names to the parameter values are arbitrarily set
--   by the plutus team; the ledger does not hold any such names.
--   
--   See Note [Cost model parameters]
type CostModelParams = Map Text Integer
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | Get the raw machine parameters (as understood by the CEK evaluator)
--   stored inside an <a>EvaluationContext</a>.
toMachineParameters :: ProtocolVersion -> EvaluationContext -> DefaultMachineParameters

-- | A fatal error when trying to create a cost given some plain costmodel
--   parameters.
data CostModelApplyError

-- | a costmodel parameter with the give name does not exist in the
--   costmodel to be applied upon
CMUnknownParamError :: Text -> CostModelApplyError

-- | internal error when we are transforming the applyParams' input to json
--   (should not happen)
CMInternalReadError :: CostModelApplyError

-- | internal error when we are transforming the applied params from json
--   with given jsonstring error (should not happen)
CMInternalWriteError :: String -> CostModelApplyError

-- | See Note [Cost model parameters from the ledger's point of view]
CMTooFewParamsError :: Int -> Int -> CostModelApplyError
[cmTooFewExpected] :: CostModelApplyError -> Int
[cmTooFewActual] :: CostModelApplyError -> Int

module PlutusLedgerApi.V3.ParamName

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'intercept :: ParamName
DivideInteger'cpu'arguments'model'arguments'slope :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'intercept :: ParamName
ModInteger'cpu'arguments'model'arguments'slope :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'minimum :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'intercept :: ParamName
QuotientInteger'cpu'arguments'model'arguments'slope :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'intercept :: ParamName
RemainderInteger'cpu'arguments'model'arguments'slope :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
SerialiseData'cpu'arguments'intercept :: ParamName
SerialiseData'cpu'arguments'slope :: ParamName
SerialiseData'memory'arguments'intercept :: ParamName
SerialiseData'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'cpu'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'intercept :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'slope :: ParamName
VerifySchnorrSecp256k1Signature'memory'arguments :: ParamName

-- | Given an ordered list of parameter values, tag them with their
--   parameter names. If the passed parameter values are more than
--   expected: the function will ignore the extraneous values at the tail
--   of the list, if the passed values are less than expected: the function
--   will throw an error; for more information, see Note [Cost model
--   parameters from the ledger's point of view]
tagWithParamNames :: forall k m. (Enum k, Bounded k, MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Integer] -> m [(k, Integer)]
instance PlutusLedgerApi.Common.ParamName.IsParamName PlutusLedgerApi.V3.ParamName.ParamName
instance GHC.Generics.Generic PlutusLedgerApi.V3.ParamName.ParamName
instance GHC.Enum.Bounded PlutusLedgerApi.V3.ParamName.ParamName
instance GHC.Ix.Ix PlutusLedgerApi.V3.ParamName.ParamName
instance GHC.Enum.Enum PlutusLedgerApi.V3.ParamName.ParamName
instance GHC.Classes.Ord PlutusLedgerApi.V3.ParamName.ParamName
instance GHC.Classes.Eq PlutusLedgerApi.V3.ParamName.ParamName

module PlutusLedgerApi.V3.EvaluationContext

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   There are two sets of parameters: one is with immediate unlifting and
--   the other one is with deferred unlifting. We have to keep both of
--   them, because depending on the language version either one has to be
--   used or the other. We also compile them separately due to all the
--   inlining and optimization that need to happen for things to be
--   efficient.
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of integer values passed from the ledger and are
--   expected to appear in correct order.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Integer] -> m EvaluationContext

-- | A raw representation of the ledger's cost model parameters.
--   
--   The associated keys/names to the parameter values are arbitrarily set
--   by the plutus team; the ledger does not hold any such names.
--   
--   See Note [Cost model parameters]
type CostModelParams = Map Text Integer
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | Get the raw machine parameters (as understood by the CEK evaluator)
--   stored inside an <a>EvaluationContext</a>.
toMachineParameters :: ProtocolVersion -> EvaluationContext -> DefaultMachineParameters

-- | A fatal error when trying to create a cost given some plain costmodel
--   parameters.
data CostModelApplyError

-- | a costmodel parameter with the give name does not exist in the
--   costmodel to be applied upon
CMUnknownParamError :: Text -> CostModelApplyError

-- | internal error when we are transforming the applyParams' input to json
--   (should not happen)
CMInternalReadError :: CostModelApplyError

-- | internal error when we are transforming the applied params from json
--   with given jsonstring error (should not happen)
CMInternalWriteError :: String -> CostModelApplyError

-- | See Note [Cost model parameters from the ledger's point of view]
CMTooFewParamsError :: Int -> Int -> CostModelApplyError
[cmTooFewExpected] :: CostModelApplyError -> Int
[cmTooFewActual] :: CostModelApplyError -> Int

module PlutusLedgerApi.V1.Bytes
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString

-- | An error that is encountered when converting a <tt>ByteString</tt> to
--   a <a>LedgerBytes</a>.
data LedgerBytesError

-- | Odd number of bytes in the original bytestring.
UnpairedDigit :: LedgerBytesError

-- | A non-hex digit character ([^A-Fa-f0-9]) encountered during decoding.
NotHexit :: Char -> LedgerBytesError

-- | Convert a hex-encoded (Base16) <tt>ByteString</tt> to a
--   <a>LedgerBytes</a>. May return an error (<a>LedgerBytesError</a>).
fromHex :: ByteString -> Either LedgerBytesError LedgerBytes

-- | Extract the Haskell bytestring from inside the Plutus opaque
--   <a>LedgerBytes</a>.
bytes :: LedgerBytes -> ByteString

-- | Lift a Haskell bytestring to the Plutus abstraction <a>LedgerBytes</a>
fromBytes :: ByteString -> LedgerBytes

-- | Encode a ByteString value to Base16 (i.e. hexadecimal), then decode
--   with UTF-8 to a <tt>Text</tt>.
encodeByteString :: ByteString -> Text
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Bytes.LedgerBytes
instance GHC.Exception.Type.Exception PlutusLedgerApi.V1.Bytes.LedgerBytesError
instance GHC.Show.Show PlutusLedgerApi.V1.Bytes.LedgerBytesError
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Bytes.LedgerBytes
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Bytes.LedgerBytes
instance GHC.Generics.Generic PlutusLedgerApi.V1.Bytes.LedgerBytes
instance GHC.Classes.Ord PlutusLedgerApi.V1.Bytes.LedgerBytes
instance GHC.Classes.Eq PlutusLedgerApi.V1.Bytes.LedgerBytes
instance Data.String.IsString PlutusLedgerApi.V1.Bytes.LedgerBytes
instance GHC.Show.Show PlutusLedgerApi.V1.Bytes.LedgerBytes


-- | Functions for working with <a>Value</a>.
module PlutusLedgerApi.V1.Value

-- | ByteString representing the currency, hashed with <i>BLAKE2b-224</i>.
--   It is empty for <tt>Ada</tt>, 28 bytes for <tt>MintingPolicyHash</tt>.
--   Forms an <a>AssetClass</a> along with <a>TokenName</a>. A <a>Value</a>
--   is a map from <a>CurrencySymbol</a>'s to a map from <a>TokenName</a>
--   to an <a>Integer</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | Creates <a>CurrencySymbol</a> from raw <tt>ByteString</tt>.
currencySymbol :: ByteString -> CurrencySymbol

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | ByteString of a name of a token. Shown as UTF-8 string when possible.
--   Should be no longer than 32 bytes, empty for Ada. Forms an
--   <a>AssetClass</a> along with a <a>CurrencySymbol</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Creates <a>TokenName</a> from raw <a>ByteString</a>.
tokenName :: ByteString -> TokenName

-- | Turn a TokenName to a hex-encoded <tt>String</tt>
--   
--   Compared to <tt>show</tt> , it will not surround the string with
--   double-quotes.
toString :: TokenName -> String

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName

-- | An asset class, identified by a <a>CurrencySymbol</a> and a
--   <a>TokenName</a>.
newtype AssetClass
AssetClass :: (CurrencySymbol, TokenName) -> AssetClass
[unAssetClass] :: AssetClass -> (CurrencySymbol, TokenName)

-- | The curried version of <a>AssetClass</a> constructor
assetClass :: CurrencySymbol -> TokenName -> AssetClass

-- | A <a>Value</a> containing the given amount of the asset class.
assetClassValue :: AssetClass -> Integer -> Value

-- | Get the quantity of the given <a>AssetClass</a> class in the
--   <a>Value</a>.
assetClassValueOf :: Value -> AssetClass -> Integer

-- | The <a>Value</a> type represents a collection of amounts of different
--   currencies. We can think of <a>Value</a> as a vector space whose
--   dimensions are currencies. To create a value of <a>Value</a>, we need
--   to specify a currency. This can be done using <a>adaValueOf</a>. To
--   get the ada dimension of <a>Value</a> we use <a>fromValue</a>. Plutus
--   contract authors will be able to define modules similar to <a>Ada</a>
--   for their own currencies.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   There is no 'Ord Value' instance since <a>Value</a> is only a partial
--   order, so <a>compare</a> can't do the right thing in some cases.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value

-- | Get the quantity of the given currency in the <a>Value</a>.
valueOf :: Value -> CurrencySymbol -> TokenName -> Integer
scale :: Module s v => s -> v -> v

-- | The list of <a>CurrencySymbol</a>s of a <a>Value</a>.
symbols :: Value -> [CurrencySymbol]

-- | Check whether one <a>Value</a> is greater than or equal to another.
--   See <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
geq :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is strictly greater than another. This
--   is *not* a pointwise operation. <tt>gt l r</tt> means <tt>geq l r
--   &amp;&amp; not (eq l r)</tt>.
gt :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is less than or equal to another. See
--   <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
leq :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is strictly less than another. This is
--   *not* a pointwise operation. <tt>lt l r</tt> means <tt>leq l r
--   &amp;&amp; not (eq l r)</tt>.
lt :: Value -> Value -> Bool

-- | Check whether a <a>Value</a> is zero.
isZero :: Value -> Bool

-- | Split a value into its positive and negative parts. The first element
--   of the tuple contains the negative parts of the value, the second
--   element contains the positive parts.
--   
--   <pre>
--   negate (fst (split a)) <tt>plus</tt> (snd (split a)) == a
--   </pre>
split :: Value -> (Value, Value)
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | Convert a value to a simple list, keeping only the non-zero amounts.
flattenValue :: Value -> [(CurrencySymbol, TokenName, Integer)]
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.CurrencySymbol
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.CurrencySymbol
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Value.CurrencySymbol
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Value.CurrencySymbol
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Value.CurrencySymbol
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Value.CurrencySymbol
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Value.CurrencySymbol
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Value.CurrencySymbol
instance GHC.Classes.Ord PlutusLedgerApi.V1.Value.CurrencySymbol
instance GHC.Classes.Eq PlutusLedgerApi.V1.Value.CurrencySymbol
instance Data.Data.Data PlutusLedgerApi.V1.Value.CurrencySymbol
instance GHC.Generics.Generic PlutusLedgerApi.V1.Value.CurrencySymbol
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Value.CurrencySymbol
instance GHC.Show.Show PlutusLedgerApi.V1.Value.CurrencySymbol
instance Data.String.IsString PlutusLedgerApi.V1.Value.CurrencySymbol
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Value.TokenName
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Value.TokenName
instance GHC.Classes.Ord PlutusLedgerApi.V1.Value.TokenName
instance GHC.Classes.Eq PlutusLedgerApi.V1.Value.TokenName
instance Data.Data.Data PlutusLedgerApi.V1.Value.TokenName
instance GHC.Generics.Generic PlutusLedgerApi.V1.Value.TokenName
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Value.AssetClass
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Value.AssetClass
instance GHC.Show.Show PlutusLedgerApi.V1.Value.AssetClass
instance GHC.Classes.Ord PlutusLedgerApi.V1.Value.AssetClass
instance GHC.Classes.Eq PlutusLedgerApi.V1.Value.AssetClass
instance Data.Data.Data PlutusLedgerApi.V1.Value.AssetClass
instance GHC.Generics.Generic PlutusLedgerApi.V1.Value.AssetClass
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Value.Value
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Value.Value
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Value.Value
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Value.Value
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Value.Value
instance GHC.Show.Show PlutusLedgerApi.V1.Value.Value
instance Data.Data.Data PlutusLedgerApi.V1.Value.Value
instance GHC.Generics.Generic PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Numeric.AdditiveSemigroup PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Numeric.AdditiveMonoid PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Numeric.AdditiveGroup PlutusLedgerApi.V1.Value.Value
instance GHC.Classes.Eq PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Value.Value
instance GHC.Base.Semigroup PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Semigroup.Semigroup PlutusLedgerApi.V1.Value.Value
instance GHC.Base.Monoid PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Monoid.Monoid PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Monoid.Group PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Numeric.Module GHC.Num.Integer.Integer PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Lattice.JoinSemiLattice PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Lattice.MeetSemiLattice PlutusLedgerApi.V1.Value.Value
instance Data.String.IsString PlutusLedgerApi.V1.Value.TokenName
instance GHC.Show.Show PlutusLedgerApi.V1.Value.TokenName


-- | Functions for working with scripts on the ledger.
module PlutusLedgerApi.V1.Scripts

-- | A higher-level evaluation error. FIXME: move to <i>plutus-apps</i>.
data ScriptError

-- | Expected behavior of the engine (e.g. user-provided error)
EvaluationError :: [Text] -> String -> ScriptError

-- | Unexpected behavior of the engine (a bug)
EvaluationException :: String -> String -> ScriptError

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | Information about the state of the blockchain and about the
--   transaction that is currently being validated, represented as a value
--   in <tt>Data</tt>.
newtype Context
Context :: BuiltinData -> Context

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash

-- | Type representing the <i>BLAKE2b-256</i> hash of a redeemer. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.Datum
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.Datum
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.ScriptHash
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Scripts.ScriptError
instance GHC.Generics.Generic PlutusLedgerApi.V1.Scripts.ScriptError
instance GHC.Classes.Eq PlutusLedgerApi.V1.Scripts.ScriptError
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.ScriptError
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Scripts.Datum
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Scripts.Datum
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Scripts.Datum
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Scripts.Datum
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Scripts.Datum
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Scripts.Datum
instance GHC.Classes.Ord PlutusLedgerApi.V1.Scripts.Datum
instance GHC.Classes.Eq PlutusLedgerApi.V1.Scripts.Datum
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.Datum
instance GHC.Generics.Generic PlutusLedgerApi.V1.Scripts.Datum
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Scripts.Redeemer
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Scripts.Redeemer
instance GHC.Classes.Ord PlutusLedgerApi.V1.Scripts.Redeemer
instance GHC.Classes.Eq PlutusLedgerApi.V1.Scripts.Redeemer
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.Redeemer
instance GHC.Generics.Generic PlutusLedgerApi.V1.Scripts.Redeemer
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Scripts.ScriptHash
instance GHC.Classes.Ord PlutusLedgerApi.V1.Scripts.ScriptHash
instance GHC.Classes.Eq PlutusLedgerApi.V1.Scripts.ScriptHash
instance GHC.Generics.Generic PlutusLedgerApi.V1.Scripts.ScriptHash
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Scripts.ScriptHash
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.ScriptHash
instance Data.String.IsString PlutusLedgerApi.V1.Scripts.ScriptHash
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Scripts.DatumHash
instance GHC.Classes.Ord PlutusLedgerApi.V1.Scripts.DatumHash
instance GHC.Classes.Eq PlutusLedgerApi.V1.Scripts.DatumHash
instance GHC.Generics.Generic PlutusLedgerApi.V1.Scripts.DatumHash
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Scripts.DatumHash
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.DatumHash
instance Data.String.IsString PlutusLedgerApi.V1.Scripts.DatumHash
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Scripts.RedeemerHash
instance GHC.Classes.Ord PlutusLedgerApi.V1.Scripts.RedeemerHash
instance GHC.Classes.Eq PlutusLedgerApi.V1.Scripts.RedeemerHash
instance GHC.Generics.Generic PlutusLedgerApi.V1.Scripts.RedeemerHash
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Scripts.RedeemerHash
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.RedeemerHash
instance Data.String.IsString PlutusLedgerApi.V1.Scripts.RedeemerHash
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.Context
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Scripts.Context
instance Codec.Serialise.Class.Serialise PlutusLedgerApi.V1.Scripts.Redeemer
instance Codec.Serialise.Class.Serialise PlutusLedgerApi.V1.Scripts.Datum

module PlutusLedgerApi.V1.Crypto

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself. Hashed with
--   <i>BLAKE2b-224</i>. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Crypto.PubKeyHash
instance GHC.Show.Show PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Data.String.IsString PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Crypto.PubKeyHash
instance GHC.Generics.Generic PlutusLedgerApi.V1.Crypto.PubKeyHash
instance GHC.Classes.Ord PlutusLedgerApi.V1.Crypto.PubKeyHash
instance GHC.Classes.Eq PlutusLedgerApi.V1.Crypto.PubKeyHash


-- | Address and staking address credentials for outputs.
module PlutusLedgerApi.V1.Credential

-- | Staking credential used to assign rewards.
data StakingCredential

-- | The staking hash is the <a>Credential</a> required to unlock a
--   transaction output. Either a public key credential (<a>PubKeyHash</a>)
--   or a script credential (<a>ScriptHash</a>). Both are hashed with
--   <i>BLAKE2b-244</i>. 28 byte.
StakingHash :: Credential -> StakingCredential

-- | The certificate pointer, constructed by the given slot number,
--   transaction and certificate indices. NB: The fields should really be
--   all <tt>Word64</tt>, as they are implemented in <tt>Word64</tt>, but
--   <a>Integer</a> is our only integral type so we need to use it instead.
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credentials required to unlock a transaction output.
data Credential

-- | The transaction that spends this output must be signed by the private
--   key. See <a>PubKeyHash</a>.
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator. See <a>ScriptHash</a>.
ScriptCredential :: ScriptHash -> Credential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Credential.StakingCredential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Credential.StakingCredential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Credential.Credential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Credential.Credential
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Credential.StakingCredential
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Credential.StakingCredential
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Credential.StakingCredential
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Credential.Credential
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Credential.Credential
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Credential.Credential
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Credential.Credential
instance GHC.Generics.Generic PlutusLedgerApi.V1.Credential.Credential
instance GHC.Show.Show PlutusLedgerApi.V1.Credential.Credential
instance GHC.Classes.Ord PlutusLedgerApi.V1.Credential.Credential
instance GHC.Classes.Eq PlutusLedgerApi.V1.Credential.Credential
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Credential.StakingCredential
instance GHC.Generics.Generic PlutusLedgerApi.V1.Credential.StakingCredential
instance GHC.Show.Show PlutusLedgerApi.V1.Credential.StakingCredential
instance GHC.Classes.Ord PlutusLedgerApi.V1.Credential.StakingCredential
instance GHC.Classes.Eq PlutusLedgerApi.V1.Credential.StakingCredential
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Credential.StakingCredential
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Credential.StakingCredential
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Credential.Credential
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Credential.Credential


-- | Digests of certificates that are included in transactions.
module PlutusLedgerApi.V1.DCert

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retirement certificate and the Epoch in which the retirement will
--   take place
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.DCert.DCert
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.DCert.DCert
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.DCert.DCert
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.DCert.DCert
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.DCert.DCert
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.DCert.DCert
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.DCert.DCert
instance GHC.Generics.Generic PlutusLedgerApi.V1.DCert.DCert
instance GHC.Show.Show PlutusLedgerApi.V1.DCert.DCert
instance GHC.Classes.Ord PlutusLedgerApi.V1.DCert.DCert
instance GHC.Classes.Eq PlutusLedgerApi.V1.DCert.DCert
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.DCert.DCert

module PlutusLedgerApi.V1.Address

-- | An address may contain two credentials, the payment credential and
--   optionally a <a>StakingCredential</a>.
data Address
Address :: Credential -> Maybe StakingCredential -> Address

-- | the payment credential
[addressCredential] :: Address -> Credential

-- | the staking credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The address that should be targeted by a transaction output locked by
--   the public key with the given hash.
pubKeyHashAddress :: PubKeyHash -> Address

-- | The address that should be used by a transaction output locked by the
--   given validator script hash.
scriptHashAddress :: ScriptHash -> Address

-- | The PubKeyHash of the address, if any
toPubKeyHash :: Address -> Maybe PubKeyHash

-- | The validator hash of the address, if any
toScriptHash :: Address -> Maybe ScriptHash

-- | The staking credential of an address (if any)
stakingCredential :: Address -> Maybe StakingCredential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Address.Address
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Address.Address
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Address.Address
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Address.Address
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Address.Address
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Address.Address
instance GHC.Generics.Generic PlutusLedgerApi.V1.Address.Address
instance GHC.Show.Show PlutusLedgerApi.V1.Address.Address
instance GHC.Classes.Ord PlutusLedgerApi.V1.Address.Address
instance GHC.Classes.Eq PlutusLedgerApi.V1.Address.Address
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Address.Address
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Address.Address

module PlutusLedgerApi.V1.Tx

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A tag indicating the type of script that we are pointing to.
--   
--   See also <a>ScriptPurpose</a>
data ScriptTag
Spend :: ScriptTag
Mint :: ScriptTag
Cert :: ScriptTag
Reward :: ScriptTag

-- | A redeemer pointer is a pair of a script type tag (<a>ScriptTag</a>)
--   <tt>t</tt> and an index <tt>i</tt>, picking out the i-th script of
--   type <tt>t</tt> in the transaction.
data RedeemerPtr
RedeemerPtr :: ScriptTag -> Integer -> RedeemerPtr

-- | Redeemers is a <a>Map</a> of redeemer pointer (<a>RedeemerPtr</a>) and
--   its <a>Redeemer</a>.
type Redeemers = Map RedeemerPtr Redeemer

-- | A transaction output, consisting of a target address (<a>Address</a>),
--   a value (<a>Value</a>), and optionally a datum hash
--   (<a>DatumHash</a>).
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | Whether the output is a pay-to-pubkey output.
isPubKeyOut :: TxOut -> Bool

-- | Whether the output is a pay-to-script output.
isPayToScriptOut :: TxOut -> Bool

-- | The address of a transaction output.
outAddress :: Lens' TxOut Address

-- | The value of a transaction output. | TODO: Compute address again
outValue :: Lens' TxOut Value

-- | The public key attached to a <a>TxOut</a>, if there is one.
txOutPubKey :: TxOut -> Maybe PubKeyHash

-- | The datum attached to a <a>TxOut</a>, if there is one.
txOutDatum :: TxOut -> Maybe DatumHash

-- | Create a transaction output locked by a public key.
pubKeyHashTxOut :: Value -> PubKeyHash -> TxOut
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Tx.TxOutRef
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Tx.TxOutRef
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Tx.TxOutRef
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Tx.TxOutRef
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Tx.TxOutRef
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Tx.TxOut
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Tx.TxOut
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Tx.TxOut
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Tx.TxOut
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Tx.TxOut
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Tx.TxId
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Tx.TxId
instance GHC.Show.Show PlutusLedgerApi.V1.Tx.TxId
instance Data.String.IsString PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Tx.TxId
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Tx.TxId
instance GHC.Generics.Generic PlutusLedgerApi.V1.Tx.TxId
instance GHC.Classes.Ord PlutusLedgerApi.V1.Tx.TxId
instance GHC.Classes.Eq PlutusLedgerApi.V1.Tx.TxId
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Tx.ScriptTag
instance GHC.Generics.Generic PlutusLedgerApi.V1.Tx.ScriptTag
instance GHC.Classes.Ord PlutusLedgerApi.V1.Tx.ScriptTag
instance GHC.Classes.Eq PlutusLedgerApi.V1.Tx.ScriptTag
instance GHC.Show.Show PlutusLedgerApi.V1.Tx.ScriptTag
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Tx.RedeemerPtr
instance GHC.Generics.Generic PlutusLedgerApi.V1.Tx.RedeemerPtr
instance GHC.Classes.Ord PlutusLedgerApi.V1.Tx.RedeemerPtr
instance GHC.Classes.Eq PlutusLedgerApi.V1.Tx.RedeemerPtr
instance GHC.Show.Show PlutusLedgerApi.V1.Tx.RedeemerPtr
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Tx.TxOutRef
instance GHC.Generics.Generic PlutusLedgerApi.V1.Tx.TxOutRef
instance GHC.Classes.Ord PlutusLedgerApi.V1.Tx.TxOutRef
instance GHC.Classes.Eq PlutusLedgerApi.V1.Tx.TxOutRef
instance GHC.Show.Show PlutusLedgerApi.V1.Tx.TxOutRef
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Tx.TxOut
instance GHC.Generics.Generic PlutusLedgerApi.V1.Tx.TxOut
instance GHC.Classes.Eq PlutusLedgerApi.V1.Tx.TxOut
instance GHC.Show.Show PlutusLedgerApi.V1.Tx.TxOut
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Tx.TxOut
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Tx.TxOut
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Tx.TxOutRef
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Tx.TxOutRef

module PlutusLedgerApi.V2.Tx

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A tag indicating the type of script that we are pointing to.
--   
--   See also <a>ScriptPurpose</a>
data ScriptTag
Spend :: ScriptTag
Mint :: ScriptTag
Cert :: ScriptTag
Reward :: ScriptTag

-- | A redeemer pointer is a pair of a script type tag (<a>ScriptTag</a>)
--   <tt>t</tt> and an index <tt>i</tt>, picking out the i-th script of
--   type <tt>t</tt> in the transaction.
data RedeemerPtr
RedeemerPtr :: ScriptTag -> Integer -> RedeemerPtr

-- | Redeemers is a <a>Map</a> of redeemer pointer (<a>RedeemerPtr</a>) and
--   its <a>Redeemer</a>.
type Redeemers = Map RedeemerPtr Redeemer

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | The datum attached to an output: either nothing; a datum hash; or the
--   datum itself (an "inline datum").
data OutputDatum
NoOutputDatum :: OutputDatum
OutputDatumHash :: DatumHash -> OutputDatum
OutputDatum :: Datum -> OutputDatum

-- | Whether the output is a pay-to-pubkey output.
isPubKeyOut :: TxOut -> Bool

-- | Whether the output is a pay-to-script output.
isPayToScriptOut :: TxOut -> Bool

-- | The address of a transaction output.
outAddress :: Lens' TxOut Address

-- | The value of a transaction output. | TODO: Compute address again
outValue :: Lens' TxOut Value

-- | The public key attached to a <a>TxOut</a>, if there is one.
txOutPubKey :: TxOut -> Maybe PubKeyHash

-- | The datum attached to a <a>TxOut</a>.
outDatum :: Lens' TxOut OutputDatum

-- | The reference script attached to a <a>TxOut</a>.
outReferenceScript :: Lens' TxOut (Maybe ScriptHash)

-- | Create a transaction output locked by a public key.
pubKeyHashTxOut :: Value -> PubKeyHash -> TxOut
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Tx.TxOut
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Tx.TxOut
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Tx.TxOut
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Tx.TxOut
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Tx.TxOut
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Tx.OutputDatum
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Tx.OutputDatum
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Tx.OutputDatum
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Tx.OutputDatum
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Tx.OutputDatum
instance Control.DeepSeq.NFData PlutusLedgerApi.V2.Tx.OutputDatum
instance GHC.Generics.Generic PlutusLedgerApi.V2.Tx.OutputDatum
instance GHC.Classes.Eq PlutusLedgerApi.V2.Tx.OutputDatum
instance GHC.Show.Show PlutusLedgerApi.V2.Tx.OutputDatum
instance Control.DeepSeq.NFData PlutusLedgerApi.V2.Tx.TxOut
instance GHC.Generics.Generic PlutusLedgerApi.V2.Tx.TxOut
instance GHC.Classes.Eq PlutusLedgerApi.V2.Tx.TxOut
instance GHC.Show.Show PlutusLedgerApi.V2.Tx.TxOut
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Tx.TxOut
instance PlutusTx.Eq.Eq PlutusLedgerApi.V2.Tx.TxOut
instance PlutusTx.Eq.Eq PlutusLedgerApi.V2.Tx.OutputDatum
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Tx.OutputDatum

module PlutusLedgerApi.V1.Contexts

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | The lookup table of datums attached to the transaction
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> TxId

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A transaction output, consisting of a target address (<a>Address</a>),
--   a value (<a>Value</a>), and optionally a datum hash
--   (<a>DatumHash</a>).
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash

-- | Given a UTXO reference and a transaction (<a>TxInfo</a>), resolve it
--   to one of the transaction's inputs (<a>TxInInfo</a>).
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Finds all the outputs that pay to the same script address that we are
--   currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]

-- | Get all the outputs that pay to the same script address we are
--   currently spending from, if any.
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> PubKeyHash -> Value

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Contexts.ScriptContext
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Contexts.ScriptContext
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.ScriptContext
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Contexts.TxInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Contexts.TxInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Contexts.TxInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.TxInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.TxInfo
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Contexts.TxInInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Contexts.TxInInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.TxInInfo
instance GHC.Classes.Eq PlutusLedgerApi.V1.Contexts.TxInInfo
instance GHC.Show.Show PlutusLedgerApi.V1.Contexts.TxInInfo
instance GHC.Generics.Generic PlutusLedgerApi.V1.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance GHC.Classes.Eq PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance GHC.Show.Show PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance GHC.Generics.Generic PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance GHC.Classes.Eq PlutusLedgerApi.V1.Contexts.TxInfo
instance GHC.Show.Show PlutusLedgerApi.V1.Contexts.TxInfo
instance GHC.Generics.Generic PlutusLedgerApi.V1.Contexts.TxInfo
instance GHC.Show.Show PlutusLedgerApi.V1.Contexts.ScriptContext
instance GHC.Classes.Eq PlutusLedgerApi.V1.Contexts.ScriptContext
instance GHC.Generics.Generic PlutusLedgerApi.V1.Contexts.ScriptContext
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Contexts.ScriptContext
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Contexts.ScriptContext
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Contexts.TxInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Contexts.TxInfo
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Contexts.TxInInfo

module PlutusLedgerApi.V2.Contexts

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> Map StakingCredential Integer -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | <i>Added in V2:</i> Transaction reference inputs
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals <i>V1-&gt;V2</i>: changed from assoc list to a
--   <a>AssocMap</a>
[txInfoWdrl] :: TxInfo -> Map StakingCredential Integer

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | <i>Added in V2:</i> a table of redeemers attached to the transaction
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer

-- | The lookup table of datums attached to the transaction
--   <i>V1-&gt;V2</i>: changed from assoc list to a <a>AssocMap</a>
[txInfoData] :: TxInfo -> Map DatumHash Datum

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> TxId

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash

-- | Given a UTXO reference and a transaction (<a>TxInfo</a>), resolve it
--   to one of the transaction's inputs (<a>TxInInfo</a>).
--   
--   Note: this only searches the true transaction inputs and not the
--   referenced transaction inputs.
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Find the indices of all the outputs that pay to the same script
--   address we are currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]

-- | Get all the outputs that pay to the same script address we are
--   currently spending from, if any.
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> PubKeyHash -> Value

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Contexts.ScriptContext
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Contexts.ScriptContext
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Contexts.ScriptContext
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Contexts.TxInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Contexts.TxInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Contexts.TxInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Contexts.TxInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Contexts.TxInfo
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Contexts.TxInInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Contexts.TxInInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Contexts.TxInInfo
instance GHC.Classes.Eq PlutusLedgerApi.V2.Contexts.TxInInfo
instance GHC.Show.Show PlutusLedgerApi.V2.Contexts.TxInInfo
instance GHC.Generics.Generic PlutusLedgerApi.V2.Contexts.TxInInfo
instance GHC.Classes.Eq PlutusLedgerApi.V2.Contexts.TxInfo
instance GHC.Show.Show PlutusLedgerApi.V2.Contexts.TxInfo
instance GHC.Generics.Generic PlutusLedgerApi.V2.Contexts.TxInfo
instance GHC.Show.Show PlutusLedgerApi.V2.Contexts.ScriptContext
instance GHC.Classes.Eq PlutusLedgerApi.V2.Contexts.ScriptContext
instance GHC.Generics.Generic PlutusLedgerApi.V2.Contexts.ScriptContext
instance PlutusTx.Eq.Eq PlutusLedgerApi.V2.Contexts.ScriptContext
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Contexts.ScriptContext
instance PlutusTx.Eq.Eq PlutusLedgerApi.V2.Contexts.TxInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Contexts.TxInfo
instance PlutusTx.Eq.Eq PlutusLedgerApi.V2.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Contexts.TxInInfo


-- | The interface to Plutus V1 for the ledger.
module PlutusLedgerApi.V1

-- | Scripts to the ledger are serialised bytestrings.
type SerialisedScript = ShortByteString

-- | Turns a program which was compiled using the 'PlutusTx' toolchain into
--   a binary format that is understood by the network and can be stored
--   on-chain.
serialiseCompiledCode :: forall a. CompiledCode a -> SerialisedScript

-- | Turns a program's AST (most likely manually constructed) into a binary
--   format that is understood by the network and can be stored on-chain.
serialiseUPLC :: Program DeBruijn DefaultUni DefaultFun () -> SerialisedScript

-- | Deserialises a <a>SerialisedScript</a> back into an AST.
deserialiseUPLC :: SerialisedScript -> Program DeBruijn DefaultUni DefaultFun ()

-- | Check if a <tt>Script</tt> is "valid" according to a protocol version.
--   At the moment this means "deserialises correctly", which in particular
--   implies that it is (almost certainly) an encoded script and the script
--   does not mention any builtins unavailable in the given protocol
--   version.
assertScriptWellFormed :: MonadError ScriptDecodeError m => ProtocolVersion -> SerialisedScript -> m ()

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
evaluateScriptRestricting :: ProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> SerialisedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. This will take as long as the script
--   takes, if you need to limit the execution time of the script also, you
--   can use <a>evaluateScriptRestricting</a>, which also returns the used
--   budget.
evaluateScriptCounting :: ProtocolVersion -> VerboseMode -> EvaluationContext -> SerialisedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | This represents the Cardano protocol version, with its major and minor
--   components. This relies on careful understanding between us and the
--   ledger as to what this means.
data ProtocolVersion
ProtocolVersion :: Int -> Int -> ProtocolVersion

-- | the major component
[pvMajor] :: ProtocolVersion -> Int

-- | the minor component
[pvMinor] :: ProtocolVersion -> Int

-- | A simple toggle indicating whether or not we should accumulate logs
--   during script execution.
data VerboseMode

-- | accumulate all traces
Verbose :: VerboseMode

-- | don't accumulate anything
Quiet :: VerboseMode

-- | The type of the executed script's accumulated log output: a list of
--   <a>Text</a>.
--   
--   It will be an empty list if the <a>VerboseMode</a> is set to
--   <a>Quiet</a>.
type LogOutput = [Text]
data ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory

-- | Counts CPU units in picoseconds: maximum value for SatInt is 2^63 ps,
--   or appproximately 106 days.
newtype ExCPU
ExCPU :: CostingInteger -> ExCPU

-- | Counts size in machine words.
newtype ExMemory
ExMemory :: CostingInteger -> ExMemory
data SatInt

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   There are two sets of parameters: one is with immediate unlifting and
--   the other one is with deferred unlifting. We have to keep both of
--   them, because depending on the language version either one has to be
--   used or the other. We also compile them separately due to all the
--   inlining and optimization that need to happen for things to be
--   efficient.
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of integer values passed from the ledger and are
--   expected to appear in correct order.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Integer] -> m EvaluationContext

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'intercept :: ParamName
DivideInteger'cpu'arguments'model'arguments'slope :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'intercept :: ParamName
ModInteger'cpu'arguments'model'arguments'slope :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'minimum :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'intercept :: ParamName
QuotientInteger'cpu'arguments'model'arguments'slope :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'intercept :: ParamName
RemainderInteger'cpu'arguments'model'arguments'slope :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName

-- | A fatal error when trying to create a cost given some plain costmodel
--   parameters.
data CostModelApplyError

-- | a costmodel parameter with the give name does not exist in the
--   costmodel to be applied upon
CMUnknownParamError :: Text -> CostModelApplyError

-- | internal error when we are transforming the applyParams' input to json
--   (should not happen)
CMInternalReadError :: CostModelApplyError

-- | internal error when we are transforming the applied params from json
--   with given jsonstring error (should not happen)
CMInternalWriteError :: String -> CostModelApplyError

-- | See Note [Cost model parameters from the ledger's point of view]
CMTooFewParamsError :: Int -> Int -> CostModelApplyError
[cmTooFewExpected] :: CostModelApplyError -> Int
[cmTooFewActual] :: CostModelApplyError -> Int

-- | A raw representation of the ledger's cost model parameters.
--   
--   The associated keys/names to the parameter values are arbitrarily set
--   by the plutus team; the ledger does not hold any such names.
--   
--   See Note [Cost model parameters]
type CostModelParams = Map Text Integer
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | An opaque type representing Plutus Core ByteStrings.
data BuiltinByteString
toBuiltin :: ToBuiltin a arep => a -> arep
fromBuiltin :: FromBuiltin arep a => arep -> a
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString

-- | Lift a Haskell bytestring to the Plutus abstraction <a>LedgerBytes</a>
fromBytes :: ByteString -> LedgerBytes

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retirement certificate and the Epoch in which the retirement will
--   take place
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert

-- | Staking credential used to assign rewards.
data StakingCredential

-- | The staking hash is the <a>Credential</a> required to unlock a
--   transaction output. Either a public key credential (<a>PubKeyHash</a>)
--   or a script credential (<a>ScriptHash</a>). Both are hashed with
--   <i>BLAKE2b-244</i>. 28 byte.
StakingHash :: Credential -> StakingCredential

-- | The certificate pointer, constructed by the given slot number,
--   transaction and certificate indices. NB: The fields should really be
--   all <tt>Word64</tt>, as they are implemented in <tt>Word64</tt>, but
--   <a>Integer</a> is our only integral type so we need to use it instead.
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credentials required to unlock a transaction output.
data Credential

-- | The transaction that spends this output must be signed by the private
--   key. See <a>PubKeyHash</a>.
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator. See <a>ScriptHash</a>.
ScriptCredential :: ScriptHash -> Credential

-- | The <a>Value</a> type represents a collection of amounts of different
--   currencies. We can think of <a>Value</a> as a vector space whose
--   dimensions are currencies. To create a value of <a>Value</a>, we need
--   to specify a currency. This can be done using <a>adaValueOf</a>. To
--   get the ada dimension of <a>Value</a> we use <a>fromValue</a>. Plutus
--   contract authors will be able to define modules similar to <a>Ada</a>
--   for their own currencies.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   There is no 'Ord Value' instance since <a>Value</a> is only a partial
--   order, so <a>compare</a> can't do the right thing in some cases.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | ByteString representing the currency, hashed with <i>BLAKE2b-224</i>.
--   It is empty for <tt>Ada</tt>, 28 bytes for <tt>MintingPolicyHash</tt>.
--   Forms an <a>AssetClass</a> along with <a>TokenName</a>. A <a>Value</a>
--   is a map from <a>CurrencySymbol</a>'s to a map from <a>TokenName</a>
--   to an <a>Integer</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | ByteString of a name of a token. Shown as UTF-8 string when possible.
--   Should be no longer than 32 bytes, empty for Ada. Forms an
--   <a>AssetClass</a> along with a <a>CurrencySymbol</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName

-- | POSIX time is measured as the number of <i>milliseconds</i> since
--   1970-01-01T00:00:00Z. This is not the same as Haskell's
--   <a>POSIXTime</a>
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | An address may contain two credentials, the payment credential and
--   optionally a <a>StakingCredential</a>.
data Address
Address :: Credential -> Maybe StakingCredential -> Address

-- | the payment credential
[addressCredential] :: Address -> Credential

-- | the staking credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself. Hashed with
--   <i>BLAKE2b-224</i>. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | The lookup table of datums attached to the transaction
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> TxId

-- | A transaction output, consisting of a target address (<a>Address</a>),
--   a value (<a>Value</a>), and optionally a datum hash
--   (<a>DatumHash</a>).
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
--   
--   The <a>Eq</a>uality of two intervals is specified as the canonical,
--   structural equality and not the equality of the elements of their two
--   underlying sets; the same holds for <a>Ord</a>.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | An <a>Interval</a> that covers every slot. In math. notation [-∞,+∞]
always :: Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>. In math. notation: [a,+∞]
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>. In math. notation: [-∞,a]
to :: a -> Interval a

-- | Construct a lower bound from a value.
--   
--   The resulting bound includes all values that are equal or greater than
--   the input value.
lowerBound :: a -> LowerBound a

-- | Construct an upper bound from a value.
--   
--   The resulting bound includes all values that are equal or smaller than
--   the input value.
upperBound :: a -> UpperBound a

-- | Construct a strict lower bound from a value.
--   
--   The resulting bound includes all values that are (strictly) greater
--   than the input value.
strictLowerBound :: a -> LowerBound a

-- | Construct a strict upper bound from a value.
--   
--   The resulting bound includes all values that are (strictly) smaller
--   than the input value.
strictUpperBound :: a -> UpperBound a

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a redeemer. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash

-- | A generic "data" type.
--   
--   The main constructor <a>Constr</a> represents a datatype value in
--   sum-of-products form: <tt>Constr i args</tt> represents a use of the
--   <tt>i</tt>th constructor along with its arguments.
--   
--   The other constructors are various primitives.
data Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data

-- | A type corresponding to the Plutus Core builtin equivalent of
--   <a>Data</a>.
--   
--   The point of this type is to be an opaque equivalent of <a>Data</a>,
--   so as to ensure that it is only used in ways that the compiler can
--   handle.
--   
--   As such, you should use this type in your on-chain code, and in any
--   data structures that you want to be representable on-chain.
--   
--   For off-chain usage, there are conversion functions
--   <a>builtinDataToData</a> and <a>dataToBuiltinData</a>, but note that
--   these will not work on-chain.
data BuiltinData
BuiltinData :: Data -> BuiltinData

-- | A typeclass for types that can be converted to and from
--   <a>BuiltinData</a>.
class ToData a

-- | Convert a value to <a>BuiltinData</a>.
toBuiltinData :: ToData a => a -> BuiltinData
class FromData a

-- | Convert a value from <a>BuiltinData</a>, returning <a>Nothing</a> if
--   this fails.
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class UnsafeFromData a

-- | Convert a value from <a>BuiltinData</a>, calling <a>error</a> if this
--   fails. This is typically much faster than <a>fromBuiltinData</a>.
--   
--   When implementing this function, make sure to call
--   <a>unsafeFromBuiltinData</a> rather than <a>fromBuiltinData</a> when
--   converting substructures!
--   
--   This is a simple type without any validation, <b>use with caution</b>.
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a

-- | Convert a value to <a>Data</a>.
toData :: ToData a => a -> Data

-- | Convert a value from <a>Data</a>, returning <a>Nothing</a> if this
--   fails.
fromData :: FromData a => Data -> Maybe a

-- | Convert a <a>Data</a> into a <a>BuiltinData</a>. Only works off-chain.
dataToBuiltinData :: Data -> BuiltinData

-- | Convert a <a>BuiltinData</a> into a <a>Data</a>. Only works off-chain.
builtinDataToData :: BuiltinData -> Data

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: FreeVariableError -> EvaluationError

-- | A deserialisation error
CodecError :: ScriptDecodeError -> EvaluationError

-- | An error indicating a version tag that we don't support TODO: make
--   this error more informative when we have more information about what
--   went wrong
IncompatibleVersionError :: Version () -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError

-- | An error that occurred during script deserialization.
data ScriptDecodeError

-- | an error from the underlying CBOR/serialise library
CBORDeserialiseError :: DeserialiseFailure -> ScriptDecodeError

-- | Script was successfully parsed, but more (runaway) bytes encountered
--   after script's position
RemainderError :: ByteString -> ScriptDecodeError

-- | the plutus version of the given script is not enabled yet
LanguageNotAvailableError :: LedgerPlutusVersion -> ProtocolVersion -> ProtocolVersion -> ScriptDecodeError

-- | the script's plutus version
[sdeAffectedLang] :: ScriptDecodeError -> LedgerPlutusVersion

-- | the protocol version that will first introduce/enable the plutus
--   version
[sdeIntroPv] :: ScriptDecodeError -> ProtocolVersion

-- | the protocol version in which the error occurred
[sdeThisPv] :: ScriptDecodeError -> ProtocolVersion


-- | The interface to Plutus V3 for the ledger.
module PlutusLedgerApi.V3

-- | Scripts to the ledger are serialised bytestrings.
type SerialisedScript = ShortByteString

-- | Turns a program which was compiled using the 'PlutusTx' toolchain into
--   a binary format that is understood by the network and can be stored
--   on-chain.
serialiseCompiledCode :: forall a. CompiledCode a -> SerialisedScript

-- | Turns a program's AST (most likely manually constructed) into a binary
--   format that is understood by the network and can be stored on-chain.
serialiseUPLC :: Program DeBruijn DefaultUni DefaultFun () -> SerialisedScript

-- | Deserialises a <a>SerialisedScript</a> back into an AST.
deserialiseUPLC :: SerialisedScript -> Program DeBruijn DefaultUni DefaultFun ()

-- | Check if a <tt>Script</tt> is "valid" according to a protocol version.
--   At the moment this means "deserialises correctly", which in particular
--   implies that it is (almost certainly) an encoded script and the script
--   does not mention any builtins unavailable in the given protocol
--   version.
assertScriptWellFormed :: MonadError ScriptDecodeError m => ProtocolVersion -> SerialisedScript -> m ()

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
evaluateScriptRestricting :: ProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> SerialisedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. This will take as long as the script
--   takes, if you need to limit the execution time of the script also, you
--   can use <a>evaluateScriptRestricting</a>, which also returns the used
--   budget.
evaluateScriptCounting :: ProtocolVersion -> VerboseMode -> EvaluationContext -> SerialisedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | This represents the Cardano protocol version, with its major and minor
--   components. This relies on careful understanding between us and the
--   ledger as to what this means.
data ProtocolVersion
ProtocolVersion :: Int -> Int -> ProtocolVersion

-- | the major component
[pvMajor] :: ProtocolVersion -> Int

-- | the minor component
[pvMinor] :: ProtocolVersion -> Int

-- | A simple toggle indicating whether or not we should accumulate logs
--   during script execution.
data VerboseMode

-- | accumulate all traces
Verbose :: VerboseMode

-- | don't accumulate anything
Quiet :: VerboseMode

-- | The type of the executed script's accumulated log output: a list of
--   <a>Text</a>.
--   
--   It will be an empty list if the <a>VerboseMode</a> is set to
--   <a>Quiet</a>.
type LogOutput = [Text]
data ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory

-- | Counts CPU units in picoseconds: maximum value for SatInt is 2^63 ps,
--   or appproximately 106 days.
newtype ExCPU
ExCPU :: CostingInteger -> ExCPU

-- | Counts size in machine words.
newtype ExMemory
ExMemory :: CostingInteger -> ExMemory
data SatInt

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   There are two sets of parameters: one is with immediate unlifting and
--   the other one is with deferred unlifting. We have to keep both of
--   them, because depending on the language version either one has to be
--   used or the other. We also compile them separately due to all the
--   inlining and optimization that need to happen for things to be
--   efficient.
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of integer values passed from the ledger and are
--   expected to appear in correct order.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Integer] -> m EvaluationContext

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'intercept :: ParamName
DivideInteger'cpu'arguments'model'arguments'slope :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'intercept :: ParamName
ModInteger'cpu'arguments'model'arguments'slope :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'minimum :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'intercept :: ParamName
QuotientInteger'cpu'arguments'model'arguments'slope :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'intercept :: ParamName
RemainderInteger'cpu'arguments'model'arguments'slope :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
SerialiseData'cpu'arguments'intercept :: ParamName
SerialiseData'cpu'arguments'slope :: ParamName
SerialiseData'memory'arguments'intercept :: ParamName
SerialiseData'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'cpu'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'intercept :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'slope :: ParamName
VerifySchnorrSecp256k1Signature'memory'arguments :: ParamName

-- | A fatal error when trying to create a cost given some plain costmodel
--   parameters.
data CostModelApplyError

-- | a costmodel parameter with the give name does not exist in the
--   costmodel to be applied upon
CMUnknownParamError :: Text -> CostModelApplyError

-- | internal error when we are transforming the applyParams' input to json
--   (should not happen)
CMInternalReadError :: CostModelApplyError

-- | internal error when we are transforming the applied params from json
--   with given jsonstring error (should not happen)
CMInternalWriteError :: String -> CostModelApplyError

-- | See Note [Cost model parameters from the ledger's point of view]
CMTooFewParamsError :: Int -> Int -> CostModelApplyError
[cmTooFewExpected] :: CostModelApplyError -> Int
[cmTooFewActual] :: CostModelApplyError -> Int

-- | A raw representation of the ledger's cost model parameters.
--   
--   The associated keys/names to the parameter values are arbitrarily set
--   by the plutus team; the ledger does not hold any such names.
--   
--   See Note [Cost model parameters]
type CostModelParams = Map Text Integer
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | An opaque type representing Plutus Core ByteStrings.
data BuiltinByteString
toBuiltin :: ToBuiltin a arep => a -> arep
fromBuiltin :: FromBuiltin arep a => arep -> a
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString

-- | Lift a Haskell bytestring to the Plutus abstraction <a>LedgerBytes</a>
fromBytes :: ByteString -> LedgerBytes

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retirement certificate and the Epoch in which the retirement will
--   take place
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert

-- | Staking credential used to assign rewards.
data StakingCredential

-- | The staking hash is the <a>Credential</a> required to unlock a
--   transaction output. Either a public key credential (<a>PubKeyHash</a>)
--   or a script credential (<a>ScriptHash</a>). Both are hashed with
--   <i>BLAKE2b-244</i>. 28 byte.
StakingHash :: Credential -> StakingCredential

-- | The certificate pointer, constructed by the given slot number,
--   transaction and certificate indices. NB: The fields should really be
--   all <tt>Word64</tt>, as they are implemented in <tt>Word64</tt>, but
--   <a>Integer</a> is our only integral type so we need to use it instead.
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credentials required to unlock a transaction output.
data Credential

-- | The transaction that spends this output must be signed by the private
--   key. See <a>PubKeyHash</a>.
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator. See <a>ScriptHash</a>.
ScriptCredential :: ScriptHash -> Credential

-- | The <a>Value</a> type represents a collection of amounts of different
--   currencies. We can think of <a>Value</a> as a vector space whose
--   dimensions are currencies. To create a value of <a>Value</a>, we need
--   to specify a currency. This can be done using <a>adaValueOf</a>. To
--   get the ada dimension of <a>Value</a> we use <a>fromValue</a>. Plutus
--   contract authors will be able to define modules similar to <a>Ada</a>
--   for their own currencies.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   There is no 'Ord Value' instance since <a>Value</a> is only a partial
--   order, so <a>compare</a> can't do the right thing in some cases.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | ByteString representing the currency, hashed with <i>BLAKE2b-224</i>.
--   It is empty for <tt>Ada</tt>, 28 bytes for <tt>MintingPolicyHash</tt>.
--   Forms an <a>AssetClass</a> along with <a>TokenName</a>. A <a>Value</a>
--   is a map from <a>CurrencySymbol</a>'s to a map from <a>TokenName</a>
--   to an <a>Integer</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | ByteString of a name of a token. Shown as UTF-8 string when possible.
--   Should be no longer than 32 bytes, empty for Ada. Forms an
--   <a>AssetClass</a> along with a <a>CurrencySymbol</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName

-- | POSIX time is measured as the number of <i>milliseconds</i> since
--   1970-01-01T00:00:00Z. This is not the same as Haskell's
--   <a>POSIXTime</a>
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | An address may contain two credentials, the payment credential and
--   optionally a <a>StakingCredential</a>.
data Address
Address :: Credential -> Maybe StakingCredential -> Address

-- | the payment credential
[addressCredential] :: Address -> Credential

-- | the staking credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself. Hashed with
--   <i>BLAKE2b-224</i>. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> Map StakingCredential Integer -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | <i>Added in V2:</i> Transaction reference inputs
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals <i>V1-&gt;V2</i>: changed from assoc list to a
--   <a>AssocMap</a>
[txInfoWdrl] :: TxInfo -> Map StakingCredential Integer

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | <i>Added in V2:</i> a table of redeemers attached to the transaction
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer

-- | The lookup table of datums attached to the transaction
--   <i>V1-&gt;V2</i>: changed from assoc list to a <a>AssocMap</a>
[txInfoData] :: TxInfo -> Map DatumHash Datum

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> TxId

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | The datum attached to an output: either nothing; a datum hash; or the
--   datum itself (an "inline datum").
data OutputDatum
NoOutputDatum :: OutputDatum
OutputDatumHash :: DatumHash -> OutputDatum
OutputDatum :: Datum -> OutputDatum

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
--   
--   The <a>Eq</a>uality of two intervals is specified as the canonical,
--   structural equality and not the equality of the elements of their two
--   underlying sets; the same holds for <a>Ord</a>.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | An <a>Interval</a> that covers every slot. In math. notation [-∞,+∞]
always :: Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>. In math. notation: [a,+∞]
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>. In math. notation: [-∞,a]
to :: a -> Interval a

-- | Construct a lower bound from a value.
--   
--   The resulting bound includes all values that are equal or greater than
--   the input value.
lowerBound :: a -> LowerBound a

-- | Construct an upper bound from a value.
--   
--   The resulting bound includes all values that are equal or smaller than
--   the input value.
upperBound :: a -> UpperBound a

-- | Construct a strict lower bound from a value.
--   
--   The resulting bound includes all values that are (strictly) greater
--   than the input value.
strictLowerBound :: a -> LowerBound a

-- | Construct a strict upper bound from a value.
--   
--   The resulting bound includes all values that are (strictly) smaller
--   than the input value.
strictUpperBound :: a -> UpperBound a

-- | A <a>Map</a> of key-value pairs.
data Map k v
fromList :: [(k, v)] -> Map k v

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a redeemer. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash

-- | A generic "data" type.
--   
--   The main constructor <a>Constr</a> represents a datatype value in
--   sum-of-products form: <tt>Constr i args</tt> represents a use of the
--   <tt>i</tt>th constructor along with its arguments.
--   
--   The other constructors are various primitives.
data Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data

-- | A type corresponding to the Plutus Core builtin equivalent of
--   <a>Data</a>.
--   
--   The point of this type is to be an opaque equivalent of <a>Data</a>,
--   so as to ensure that it is only used in ways that the compiler can
--   handle.
--   
--   As such, you should use this type in your on-chain code, and in any
--   data structures that you want to be representable on-chain.
--   
--   For off-chain usage, there are conversion functions
--   <a>builtinDataToData</a> and <a>dataToBuiltinData</a>, but note that
--   these will not work on-chain.
data BuiltinData
BuiltinData :: Data -> BuiltinData

-- | A typeclass for types that can be converted to and from
--   <a>BuiltinData</a>.
class ToData a

-- | Convert a value to <a>BuiltinData</a>.
toBuiltinData :: ToData a => a -> BuiltinData
class FromData a

-- | Convert a value from <a>BuiltinData</a>, returning <a>Nothing</a> if
--   this fails.
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class UnsafeFromData a

-- | Convert a value from <a>BuiltinData</a>, calling <a>error</a> if this
--   fails. This is typically much faster than <a>fromBuiltinData</a>.
--   
--   When implementing this function, make sure to call
--   <a>unsafeFromBuiltinData</a> rather than <a>fromBuiltinData</a> when
--   converting substructures!
--   
--   This is a simple type without any validation, <b>use with caution</b>.
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a

-- | Convert a value to <a>Data</a>.
toData :: ToData a => a -> Data

-- | Convert a value from <a>Data</a>, returning <a>Nothing</a> if this
--   fails.
fromData :: FromData a => Data -> Maybe a

-- | Convert a <a>Data</a> into a <a>BuiltinData</a>. Only works off-chain.
dataToBuiltinData :: Data -> BuiltinData

-- | Convert a <a>BuiltinData</a> into a <a>Data</a>. Only works off-chain.
builtinDataToData :: BuiltinData -> Data

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: FreeVariableError -> EvaluationError

-- | A deserialisation error
CodecError :: ScriptDecodeError -> EvaluationError

-- | An error indicating a version tag that we don't support TODO: make
--   this error more informative when we have more information about what
--   went wrong
IncompatibleVersionError :: Version () -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError

-- | An error that occurred during script deserialization.
data ScriptDecodeError

-- | an error from the underlying CBOR/serialise library
CBORDeserialiseError :: DeserialiseFailure -> ScriptDecodeError

-- | Script was successfully parsed, but more (runaway) bytes encountered
--   after script's position
RemainderError :: ByteString -> ScriptDecodeError

-- | the plutus version of the given script is not enabled yet
LanguageNotAvailableError :: LedgerPlutusVersion -> ProtocolVersion -> ProtocolVersion -> ScriptDecodeError

-- | the script's plutus version
[sdeAffectedLang] :: ScriptDecodeError -> LedgerPlutusVersion

-- | the protocol version that will first introduce/enable the plutus
--   version
[sdeIntroPv] :: ScriptDecodeError -> ProtocolVersion

-- | the protocol version in which the error occurred
[sdeThisPv] :: ScriptDecodeError -> ProtocolVersion


-- | The interface to Plutus V2 for the ledger.
module PlutusLedgerApi.V2

-- | Scripts to the ledger are serialised bytestrings.
type SerialisedScript = ShortByteString

-- | Turns a program which was compiled using the 'PlutusTx' toolchain into
--   a binary format that is understood by the network and can be stored
--   on-chain.
serialiseCompiledCode :: forall a. CompiledCode a -> SerialisedScript

-- | Turns a program's AST (most likely manually constructed) into a binary
--   format that is understood by the network and can be stored on-chain.
serialiseUPLC :: Program DeBruijn DefaultUni DefaultFun () -> SerialisedScript

-- | Deserialises a <a>SerialisedScript</a> back into an AST.
deserialiseUPLC :: SerialisedScript -> Program DeBruijn DefaultUni DefaultFun ()

-- | Check if a <tt>Script</tt> is "valid" according to a protocol version.
--   At the moment this means "deserialises correctly", which in particular
--   implies that it is (almost certainly) an encoded script and the script
--   does not mention any builtins unavailable in the given protocol
--   version.
assertScriptWellFormed :: MonadError ScriptDecodeError m => ProtocolVersion -> SerialisedScript -> m ()

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
evaluateScriptRestricting :: ProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> SerialisedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. This will take as long as the script
--   takes, if you need to limit the execution time of the script also, you
--   can use <a>evaluateScriptRestricting</a>, which also returns the used
--   budget.
evaluateScriptCounting :: ProtocolVersion -> VerboseMode -> EvaluationContext -> SerialisedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | This represents the Cardano protocol version, with its major and minor
--   components. This relies on careful understanding between us and the
--   ledger as to what this means.
data ProtocolVersion
ProtocolVersion :: Int -> Int -> ProtocolVersion

-- | the major component
[pvMajor] :: ProtocolVersion -> Int

-- | the minor component
[pvMinor] :: ProtocolVersion -> Int

-- | A simple toggle indicating whether or not we should accumulate logs
--   during script execution.
data VerboseMode

-- | accumulate all traces
Verbose :: VerboseMode

-- | don't accumulate anything
Quiet :: VerboseMode

-- | The type of the executed script's accumulated log output: a list of
--   <a>Text</a>.
--   
--   It will be an empty list if the <a>VerboseMode</a> is set to
--   <a>Quiet</a>.
type LogOutput = [Text]
data ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory

-- | Counts CPU units in picoseconds: maximum value for SatInt is 2^63 ps,
--   or appproximately 106 days.
newtype ExCPU
ExCPU :: CostingInteger -> ExCPU

-- | Counts size in machine words.
newtype ExMemory
ExMemory :: CostingInteger -> ExMemory
data SatInt

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   There are two sets of parameters: one is with immediate unlifting and
--   the other one is with deferred unlifting. We have to keep both of
--   them, because depending on the language version either one has to be
--   used or the other. We also compile them separately due to all the
--   inlining and optimization that need to happen for things to be
--   efficient.
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of integer values passed from the ledger and are
--   expected to appear in correct order.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Integer] -> m EvaluationContext

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'intercept :: ParamName
DivideInteger'cpu'arguments'model'arguments'slope :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'intercept :: ParamName
ModInteger'cpu'arguments'model'arguments'slope :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'minimum :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'intercept :: ParamName
QuotientInteger'cpu'arguments'model'arguments'slope :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'intercept :: ParamName
RemainderInteger'cpu'arguments'model'arguments'slope :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
SerialiseData'cpu'arguments'intercept :: ParamName
SerialiseData'cpu'arguments'slope :: ParamName
SerialiseData'memory'arguments'intercept :: ParamName
SerialiseData'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'cpu'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'intercept :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'slope :: ParamName
VerifySchnorrSecp256k1Signature'memory'arguments :: ParamName

-- | A fatal error when trying to create a cost given some plain costmodel
--   parameters.
data CostModelApplyError

-- | a costmodel parameter with the give name does not exist in the
--   costmodel to be applied upon
CMUnknownParamError :: Text -> CostModelApplyError

-- | internal error when we are transforming the applyParams' input to json
--   (should not happen)
CMInternalReadError :: CostModelApplyError

-- | internal error when we are transforming the applied params from json
--   with given jsonstring error (should not happen)
CMInternalWriteError :: String -> CostModelApplyError

-- | See Note [Cost model parameters from the ledger's point of view]
CMTooFewParamsError :: Int -> Int -> CostModelApplyError
[cmTooFewExpected] :: CostModelApplyError -> Int
[cmTooFewActual] :: CostModelApplyError -> Int

-- | A raw representation of the ledger's cost model parameters.
--   
--   The associated keys/names to the parameter values are arbitrarily set
--   by the plutus team; the ledger does not hold any such names.
--   
--   See Note [Cost model parameters]
type CostModelParams = Map Text Integer
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | An opaque type representing Plutus Core ByteStrings.
data BuiltinByteString
toBuiltin :: ToBuiltin a arep => a -> arep
fromBuiltin :: FromBuiltin arep a => arep -> a
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString

-- | Lift a Haskell bytestring to the Plutus abstraction <a>LedgerBytes</a>
fromBytes :: ByteString -> LedgerBytes

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retirement certificate and the Epoch in which the retirement will
--   take place
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert

-- | Staking credential used to assign rewards.
data StakingCredential

-- | The staking hash is the <a>Credential</a> required to unlock a
--   transaction output. Either a public key credential (<a>PubKeyHash</a>)
--   or a script credential (<a>ScriptHash</a>). Both are hashed with
--   <i>BLAKE2b-244</i>. 28 byte.
StakingHash :: Credential -> StakingCredential

-- | The certificate pointer, constructed by the given slot number,
--   transaction and certificate indices. NB: The fields should really be
--   all <tt>Word64</tt>, as they are implemented in <tt>Word64</tt>, but
--   <a>Integer</a> is our only integral type so we need to use it instead.
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credentials required to unlock a transaction output.
data Credential

-- | The transaction that spends this output must be signed by the private
--   key. See <a>PubKeyHash</a>.
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator. See <a>ScriptHash</a>.
ScriptCredential :: ScriptHash -> Credential

-- | The <a>Value</a> type represents a collection of amounts of different
--   currencies. We can think of <a>Value</a> as a vector space whose
--   dimensions are currencies. To create a value of <a>Value</a>, we need
--   to specify a currency. This can be done using <a>adaValueOf</a>. To
--   get the ada dimension of <a>Value</a> we use <a>fromValue</a>. Plutus
--   contract authors will be able to define modules similar to <a>Ada</a>
--   for their own currencies.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   There is no 'Ord Value' instance since <a>Value</a> is only a partial
--   order, so <a>compare</a> can't do the right thing in some cases.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | ByteString representing the currency, hashed with <i>BLAKE2b-224</i>.
--   It is empty for <tt>Ada</tt>, 28 bytes for <tt>MintingPolicyHash</tt>.
--   Forms an <a>AssetClass</a> along with <a>TokenName</a>. A <a>Value</a>
--   is a map from <a>CurrencySymbol</a>'s to a map from <a>TokenName</a>
--   to an <a>Integer</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | ByteString of a name of a token. Shown as UTF-8 string when possible.
--   Should be no longer than 32 bytes, empty for Ada. Forms an
--   <a>AssetClass</a> along with a <a>CurrencySymbol</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName

-- | POSIX time is measured as the number of <i>milliseconds</i> since
--   1970-01-01T00:00:00Z. This is not the same as Haskell's
--   <a>POSIXTime</a>
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | An address may contain two credentials, the payment credential and
--   optionally a <a>StakingCredential</a>.
data Address
Address :: Credential -> Maybe StakingCredential -> Address

-- | the payment credential
[addressCredential] :: Address -> Credential

-- | the staking credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself. Hashed with
--   <i>BLAKE2b-224</i>. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> Map StakingCredential Integer -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | <i>Added in V2:</i> Transaction reference inputs
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals <i>V1-&gt;V2</i>: changed from assoc list to a
--   <a>AssocMap</a>
[txInfoWdrl] :: TxInfo -> Map StakingCredential Integer

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | <i>Added in V2:</i> a table of redeemers attached to the transaction
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer

-- | The lookup table of datums attached to the transaction
--   <i>V1-&gt;V2</i>: changed from assoc list to a <a>AssocMap</a>
[txInfoData] :: TxInfo -> Map DatumHash Datum

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> TxId

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | The datum attached to an output: either nothing; a datum hash; or the
--   datum itself (an "inline datum").
data OutputDatum
NoOutputDatum :: OutputDatum
OutputDatumHash :: DatumHash -> OutputDatum
OutputDatum :: Datum -> OutputDatum

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
--   
--   The <a>Eq</a>uality of two intervals is specified as the canonical,
--   structural equality and not the equality of the elements of their two
--   underlying sets; the same holds for <a>Ord</a>.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | An <a>Interval</a> that covers every slot. In math. notation [-∞,+∞]
always :: Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>. In math. notation: [a,+∞]
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>. In math. notation: [-∞,a]
to :: a -> Interval a

-- | Construct a lower bound from a value.
--   
--   The resulting bound includes all values that are equal or greater than
--   the input value.
lowerBound :: a -> LowerBound a

-- | Construct an upper bound from a value.
--   
--   The resulting bound includes all values that are equal or smaller than
--   the input value.
upperBound :: a -> UpperBound a

-- | Construct a strict lower bound from a value.
--   
--   The resulting bound includes all values that are (strictly) greater
--   than the input value.
strictLowerBound :: a -> LowerBound a

-- | Construct a strict upper bound from a value.
--   
--   The resulting bound includes all values that are (strictly) smaller
--   than the input value.
strictUpperBound :: a -> UpperBound a

-- | A <a>Map</a> of key-value pairs.
data Map k v
fromList :: [(k, v)] -> Map k v

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a redeemer. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash

-- | A generic "data" type.
--   
--   The main constructor <a>Constr</a> represents a datatype value in
--   sum-of-products form: <tt>Constr i args</tt> represents a use of the
--   <tt>i</tt>th constructor along with its arguments.
--   
--   The other constructors are various primitives.
data Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data

-- | A type corresponding to the Plutus Core builtin equivalent of
--   <a>Data</a>.
--   
--   The point of this type is to be an opaque equivalent of <a>Data</a>,
--   so as to ensure that it is only used in ways that the compiler can
--   handle.
--   
--   As such, you should use this type in your on-chain code, and in any
--   data structures that you want to be representable on-chain.
--   
--   For off-chain usage, there are conversion functions
--   <a>builtinDataToData</a> and <a>dataToBuiltinData</a>, but note that
--   these will not work on-chain.
data BuiltinData
BuiltinData :: Data -> BuiltinData

-- | A typeclass for types that can be converted to and from
--   <a>BuiltinData</a>.
class ToData a

-- | Convert a value to <a>BuiltinData</a>.
toBuiltinData :: ToData a => a -> BuiltinData
class FromData a

-- | Convert a value from <a>BuiltinData</a>, returning <a>Nothing</a> if
--   this fails.
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class UnsafeFromData a

-- | Convert a value from <a>BuiltinData</a>, calling <a>error</a> if this
--   fails. This is typically much faster than <a>fromBuiltinData</a>.
--   
--   When implementing this function, make sure to call
--   <a>unsafeFromBuiltinData</a> rather than <a>fromBuiltinData</a> when
--   converting substructures!
--   
--   This is a simple type without any validation, <b>use with caution</b>.
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a

-- | Convert a value to <a>Data</a>.
toData :: ToData a => a -> Data

-- | Convert a value from <a>Data</a>, returning <a>Nothing</a> if this
--   fails.
fromData :: FromData a => Data -> Maybe a

-- | Convert a <a>Data</a> into a <a>BuiltinData</a>. Only works off-chain.
dataToBuiltinData :: Data -> BuiltinData

-- | Convert a <a>BuiltinData</a> into a <a>Data</a>. Only works off-chain.
builtinDataToData :: BuiltinData -> Data

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: FreeVariableError -> EvaluationError

-- | A deserialisation error
CodecError :: ScriptDecodeError -> EvaluationError

-- | An error indicating a version tag that we don't support TODO: make
--   this error more informative when we have more information about what
--   went wrong
IncompatibleVersionError :: Version () -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError

-- | An error that occurred during script deserialization.
data ScriptDecodeError

-- | an error from the underlying CBOR/serialise library
CBORDeserialiseError :: DeserialiseFailure -> ScriptDecodeError

-- | Script was successfully parsed, but more (runaway) bytes encountered
--   after script's position
RemainderError :: ByteString -> ScriptDecodeError

-- | the plutus version of the given script is not enabled yet
LanguageNotAvailableError :: LedgerPlutusVersion -> ProtocolVersion -> ProtocolVersion -> ScriptDecodeError

-- | the script's plutus version
[sdeAffectedLang] :: ScriptDecodeError -> LedgerPlutusVersion

-- | the protocol version that will first introduce/enable the plutus
--   version
[sdeIntroPv] :: ScriptDecodeError -> ProtocolVersion

-- | the protocol version in which the error occurred
[sdeThisPv] :: ScriptDecodeError -> ProtocolVersion

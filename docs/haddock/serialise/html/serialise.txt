-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A binary serialisation library for Haskell values.
--   
--   This package (formerly <tt>binary-serialise-cbor</tt>) provides pure,
--   efficient serialization of Haskell values directly into
--   <tt>ByteString</tt>s for storage or transmission purposes. By
--   providing a set of type class instances, you can also serialise any
--   custom data type you have as well.
--   
--   The underlying binary format used is the 'Concise Binary Object
--   Representation', or CBOR, specified in RFC 7049. As a result,
--   serialised Haskell values have implicit structure outside of the
--   Haskell program itself, meaning they can be inspected or analyzed
--   without custom tools.
--   
--   An implementation of the standard bijection between CBOR and JSON is
--   provided by the <a>cborg-json</a> package. Also see
--   [cbor-tool](<i>package</i>cbor-tool) for a convenient command-line
--   utility for working with CBOR data.
@package serialise
@version 0.2.6.0


-- | High level API for decoding values that were encoded with the
--   <a>Codec.Serialise.Encoding</a> module, using a <tt><a>Monad</a></tt>
--   based interface.
module Codec.Serialise.Decoding

-- | A continuation-based decoder, used for decoding values that were
--   previously encoded using the <a>Codec.CBOR.Encoding</a> module. As
--   <a>Decoder</a> has a <a>Monad</a> instance, you can easily write
--   <a>Decoder</a>s monadically for building your deserialisation logic.
data Decoder s a

-- | An action, representing a step for a decoder to taken and a
--   continuation to invoke with the expected value.
data DecodeAction s a
ConsumeWord :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord8 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord16 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord32 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeNegWord :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt8 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt16 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt32 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeListLen :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLen :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeTag :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInteger :: (Integer -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloat :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeDouble :: (Double# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytes :: (ByteString -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeByteArray :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeString :: (Text -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeUtf8ByteArray :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBool :: (Bool -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeSimple :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytesIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeStringIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeListLenIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeMapLenIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeNull :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeListLenOrIndef :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLenOrIndef :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBreakOr :: (Bool -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekTokenType :: (TokenType -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekAvailable :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekByteOffset :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWordCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord8Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord16Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord32Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeNegWordCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeIntCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt8Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt16Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt32Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeListLenCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLenCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeTagCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeIntegerCanonical :: (Integer -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloat16Canonical :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloatCanonical :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeDoubleCanonical :: (Double# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytesCanonical :: (ByteString -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeByteArrayCanonical :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeStringCanonical :: (Text -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeUtf8ByteArrayCanonical :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeSimpleCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
Fail :: String -> DecodeAction s a
Done :: a -> DecodeAction s a

-- | Given a <a>Decoder</a>, give us the <a>DecodeAction</a>
getDecodeAction :: Decoder s a -> ST s (DecodeAction s a)

-- | Decode a <a>Word</a>.
decodeWord :: Decoder s Word

-- | Decode a <a>Word8</a>.
decodeWord8 :: Decoder s Word8

-- | Decode a <a>Word16</a>.
decodeWord16 :: Decoder s Word16

-- | Decode a <a>Word32</a>.
decodeWord32 :: Decoder s Word32

-- | Decode a <a>Word64</a>.
decodeWord64 :: Decoder s Word64

-- | Decode a negative <a>Word</a>.
decodeNegWord :: Decoder s Word

-- | Decode a negative <a>Word64</a>.
decodeNegWord64 :: Decoder s Word64

-- | Decode an <a>Int</a>.
decodeInt :: Decoder s Int

-- | Decode an <a>Int8</a>.
decodeInt8 :: Decoder s Int8

-- | Decode an <a>Int16</a>.
decodeInt16 :: Decoder s Int16

-- | Decode an <a>Int32</a>.
decodeInt32 :: Decoder s Int32

-- | Decode an <a>Int64</a>.
decodeInt64 :: Decoder s Int64

-- | Decode an <a>Integer</a>.
decodeInteger :: Decoder s Integer

-- | Decode a <a>Float</a>.
decodeFloat :: Decoder s Float

-- | Decode a <a>Double</a>.
decodeDouble :: Decoder s Double

-- | Decode a string of bytes as a <a>ByteString</a>.
decodeBytes :: Decoder s ByteString

-- | Decode a token marking the beginning of an indefinite length set of
--   bytes.
decodeBytesIndef :: Decoder s ()

-- | Decode a string of bytes as a <a>ByteArray</a>.
--   
--   Also note that this will eagerly copy the content out of the input to
--   ensure that the input does not leak in the event that the
--   <a>ByteArray</a> is live but not forced.
decodeByteArray :: Decoder s ByteArray

-- | Decode a textual string as a piece of <a>Text</a>.
decodeString :: Decoder s Text

-- | Decode a token marking the beginning of an indefinite length string.
decodeStringIndef :: Decoder s ()

-- | Decode a textual string as UTF-8 encoded <a>ByteArray</a>. Note that
--   the result is not validated to be well-formed UTF-8.
--   
--   Also note that this will eagerly copy the content out of the input to
--   ensure that the input does not leak in the event that the
--   <a>ByteArray</a> is live but not forced.
decodeUtf8ByteArray :: Decoder s ByteArray

-- | Decode the length of a list.
decodeListLen :: Decoder s Int

-- | Decode a token marking the beginning of a list of indefinite length.
decodeListLenIndef :: Decoder s ()

-- | Decode the length of a map.
decodeMapLen :: Decoder s Int

-- | Decode a token marking the beginning of a map of indefinite length.
decodeMapLenIndef :: Decoder s ()

-- | Decode an arbitrary tag and return it as a <a>Word</a>.
decodeTag :: Decoder s Word

-- | Decode an arbitrary 64-bit tag and return it as a <a>Word64</a>.
decodeTag64 :: Decoder s Word64

-- | Decode a bool.
decodeBool :: Decoder s Bool

-- | Decode a nullary value, and return a unit value.
decodeNull :: Decoder s ()

-- | Decode a <tt>simple</tt> CBOR value and give back a <a>Word8</a>. You
--   probably don't ever need to use this.
decodeSimple :: Decoder s Word8

-- | Attempt to decode a word with <a>decodeWord</a>, and ensure the word
--   is exactly as expected, or fail.
decodeWordOf :: Word -> Decoder s ()

-- | Attempt to decode a list length using <a>decodeListLen</a>, and ensure
--   it is exactly the specified length, or fail.
decodeListLenOf :: Int -> Decoder s ()

-- | Attempt to decode a token for the length of a finite, known list, or
--   an indefinite list. If <a>Nothing</a> is returned, then an indefinite
--   length list occurs afterwords. If <tt><a>Just</a> x</tt> is returned,
--   then a list of length <tt>x</tt> is encoded.
decodeListLenOrIndef :: Decoder s (Maybe Int)

-- | Attempt to decode a token for the length of a finite, known map, or an
--   indefinite map. If <a>Nothing</a> is returned, then an indefinite
--   length map occurs afterwords. If <tt><a>Just</a> x</tt> is returned,
--   then a map of length <tt>x</tt> is encoded.
decodeMapLenOrIndef :: Decoder s (Maybe Int)

-- | Attempt to decode a <tt>Break</tt> token, and if that was successful,
--   return <a>True</a>. If the token was of any other type, return
--   <a>False</a>.
decodeBreakOr :: Decoder s Bool

-- | Peek at the current token we're about to decode, and return a
--   <a>TokenType</a> specifying what it is.
peekTokenType :: Decoder s TokenType

-- | Peek and return the length of the current buffer that we're running
--   our decoder on.
peekAvailable :: Decoder s Int

-- | The type of a token, which a decoder can ask for at an arbitrary time.
data TokenType
TypeUInt :: TokenType
TypeUInt64 :: TokenType
TypeNInt :: TokenType
TypeNInt64 :: TokenType
TypeInteger :: TokenType
TypeFloat16 :: TokenType
TypeFloat32 :: TokenType
TypeFloat64 :: TokenType
TypeBytes :: TokenType
TypeBytesIndef :: TokenType
TypeString :: TokenType
TypeStringIndef :: TokenType
TypeListLen :: TokenType
TypeListLen64 :: TokenType
TypeListLenIndef :: TokenType
TypeMapLen :: TokenType
TypeMapLen64 :: TokenType
TypeMapLenIndef :: TokenType
TypeTag :: TokenType
TypeTag64 :: TokenType
TypeBool :: TokenType
TypeNull :: TokenType
TypeSimple :: TokenType
TypeBreak :: TokenType
TypeInvalid :: TokenType

-- | Decode an indefinite sequence length.
decodeSequenceLenIndef :: (r -> a -> r) -> r -> (r -> r') -> Decoder s a -> Decoder s r'

-- | Decode a sequence length.
decodeSequenceLenN :: (r -> a -> r) -> r -> (r -> r') -> Int -> Decoder s a -> Decoder s r'


-- | High level API for encoding values, for later serialization into CBOR
--   binary format, using a <tt><a>Monoid</a></tt> based interface.
module Codec.Serialise.Encoding

-- | An intermediate form used during serialisation, specified as a
--   <a>Monoid</a>. It supports efficient concatenation, and is equivalent
--   to a specialised <a>Endo</a> <a>Tokens</a> type.
--   
--   It is used for the stage in serialisation where we flatten out the
--   Haskell data structure but it is independent of any specific external
--   binary or text format.
--   
--   Traditionally, to build any arbitrary <a>Encoding</a> value, you
--   specify larger structures from smaller ones and append the small ones
--   together using <a>mconcat</a>.
newtype Encoding
Encoding :: (Tokens -> Tokens) -> Encoding

-- | A flattened representation of a term, which is independent of any
--   underlying binary representation, but which we later serialise into
--   CBOR format.
data Tokens
TkWord :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkWord64 :: {-# UNPACK #-} !Word64 -> Tokens -> Tokens
TkInt :: {-# UNPACK #-} !Int -> Tokens -> Tokens
TkInt64 :: {-# UNPACK #-} !Int64 -> Tokens -> Tokens
TkBytes :: {-# UNPACK #-} !ByteString -> Tokens -> Tokens
TkBytesBegin :: Tokens -> Tokens
TkByteArray :: {-# UNPACK #-} !SlicedByteArray -> Tokens -> Tokens
TkString :: {-# UNPACK #-} !Text -> Tokens -> Tokens
TkUtf8ByteArray :: {-# UNPACK #-} !SlicedByteArray -> Tokens -> Tokens
TkStringBegin :: Tokens -> Tokens
TkListLen :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkListBegin :: Tokens -> Tokens
TkMapLen :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkMapBegin :: Tokens -> Tokens
TkTag :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkTag64 :: {-# UNPACK #-} !Word64 -> Tokens -> Tokens
TkInteger :: !Integer -> Tokens -> Tokens
TkNull :: Tokens -> Tokens
TkUndef :: Tokens -> Tokens
TkBool :: !Bool -> Tokens -> Tokens
TkSimple :: {-# UNPACK #-} !Word8 -> Tokens -> Tokens
TkFloat16 :: {-# UNPACK #-} !Float -> Tokens -> Tokens
TkFloat32 :: {-# UNPACK #-} !Float -> Tokens -> Tokens
TkFloat64 :: {-# UNPACK #-} !Double -> Tokens -> Tokens
TkBreak :: Tokens -> Tokens
TkEncoded :: {-# UNPACK #-} !ByteString -> Tokens -> Tokens
TkEnd :: Tokens

-- | Encode a <a>Word</a> in a flattened format.
encodeWord :: Word -> Encoding

-- | Encode a <a>Word8</a> in a flattened format.
encodeWord8 :: Word8 -> Encoding

-- | Encode a <a>Word16</a> in a flattened format.
encodeWord16 :: Word16 -> Encoding

-- | Encode a <a>Word32</a> in a flattened format.
encodeWord32 :: Word32 -> Encoding

-- | Encode a <a>Word64</a> in a flattened format.
encodeWord64 :: Word64 -> Encoding

-- | Encode an <a>Int</a> in a flattened format.
encodeInt :: Int -> Encoding

-- | Encode an <a>Int8</a> in a flattened format.
encodeInt8 :: Int8 -> Encoding

-- | Encode an <a>Int16</a> in a flattened format.
encodeInt16 :: Int16 -> Encoding

-- | Encode an <a>Int32</a> in a flattened format.
encodeInt32 :: Int32 -> Encoding

-- | Encode an @<a>Int64</a> in a flattened format.
encodeInt64 :: Int64 -> Encoding

-- | Encode an arbitrarily large @<a>Integer</a> in a flattened format.
encodeInteger :: Integer -> Encoding

-- | Encode an arbitrary strict <a>ByteString</a> in a flattened format.
encodeBytes :: ByteString -> Encoding

-- | Encode a token specifying the beginning of a string of bytes of
--   indefinite length. In reality, this specifies a stream of many
--   occurrences of <a>encodeBytes</a>, each specifying a single chunk of
--   the overall string. After all the bytes desired have been encoded, you
--   should follow it with a break token (see <a>encodeBreak</a>).
encodeBytesIndef :: Encoding

-- | Encode a bytestring in a flattened format.
encodeByteArray :: SlicedByteArray -> Encoding

-- | Encode a <a>Text</a> in a flattened format.
encodeString :: Text -> Encoding

-- | Encode the beginning of an indefinite string.
encodeStringIndef :: Encoding

-- | Encode a UTF-8 string in a flattened format. Note that the contents is
--   not validated to be well-formed UTF-8.
encodeUtf8ByteArray :: SlicedByteArray -> Encoding

-- | Encode the length of a list, used to indicate that the following
--   tokens represent the list values.
encodeListLen :: Word -> Encoding

-- | Encode a token specifying that this is the beginning of an indefinite
--   list of unknown size. Tokens representing the list are expected
--   afterwords, followed by a break token (see <a>encodeBreak</a>) when
--   the list has ended.
encodeListLenIndef :: Encoding

-- | Encode the length of a Map, used to indicate that the following tokens
--   represent the map values.
encodeMapLen :: Word -> Encoding

-- | Encode a token specifying that this is the beginning of an indefinite
--   map of unknown size. Tokens representing the map are expected
--   afterwords, followed by a break token (see <a>encodeBreak</a>) when
--   the map has ended.
encodeMapLenIndef :: Encoding

-- | Encode a 'break', used to specify the end of indefinite length objects
--   like maps or lists.
encodeBreak :: Encoding

-- | Encode an arbitrary <a>Word</a> tag.
encodeTag :: Word -> Encoding

-- | Encode an arbitrary 64-bit <a>Word64</a> tag.
encodeTag64 :: Word64 -> Encoding

-- | Encode a <a>Bool</a>.
encodeBool :: Bool -> Encoding

-- | Encode an <tt>Undef</tt> value.
encodeUndef :: Encoding

-- | Encode a <tt>Null</tt> value.
encodeNull :: Encoding

-- | Encode a 'simple' CBOR token that can be represented with an 8-bit
--   word. You probably don't ever need this.
encodeSimple :: Word8 -> Encoding

-- | Encode a small 16-bit <a>Float</a> in a flattened format.
encodeFloat16 :: Float -> Encoding

-- | Encode a full precision <a>Float</a> in a flattened format.
encodeFloat :: Float -> Encoding

-- | Encode a <a>Double</a> in a flattened format.
encodeDouble :: Double -> Encoding

module Codec.Serialise.Internal.GeneralisedUTF8

-- | Encode a string as (generalized) UTF-8. In addition to the encoding,
--   we return a flag indicating whether the encoded string contained any
--   surrogate characters, in which case the output is generalized UTF-8.
encodeGenUTF8 :: String -> (SlicedByteArray, UTF8Encoding)
data UTF8Encoding
ConformantUTF8 :: UTF8Encoding
GeneralisedUTF8 :: UTF8Encoding
decodeGenUTF8 :: ByteArray -> String

-- | Is a <a>Char</a> a UTF-16 surrogate?
isSurrogate :: Char -> Bool

-- | Is the given byte sequence valid under the given encoding?
isValid :: UTF8Encoding -> [Word8] -> Bool
instance GHC.Classes.Eq Codec.Serialise.Internal.GeneralisedUTF8.UTF8Encoding
instance GHC.Show.Show Codec.Serialise.Internal.GeneralisedUTF8.UTF8Encoding


-- | The <tt><a>Serialise</a></tt> class allows you to encode a given type
--   into a CBOR object, or decode a CBOR object into the user-specified
--   type.
module Codec.Serialise.Class

-- | Types that are instances of the <tt><a>Serialise</a></tt> class allow
--   values to be quickly encoded or decoded directly to a CBOR
--   representation, for object transmission or storage.
class Serialise a

-- | Definition for encoding a given type into a binary representation,
--   using the <tt><a>Encoding</a></tt> <tt><a>Monoid</a></tt>.
encode :: Serialise a => a -> Encoding

-- | Definition for encoding a given type into a binary representation,
--   using the <tt><a>Encoding</a></tt> <tt><a>Monoid</a></tt>.
encode :: (Serialise a, Generic a, GSerialiseEncode (Rep a)) => a -> Encoding

-- | Definition of a given <tt><a>Decoder</a></tt> for a type.
decode :: Serialise a => Decoder s a

-- | Definition of a given <tt><a>Decoder</a></tt> for a type.
decode :: (Serialise a, Generic a, GSerialiseDecode (Rep a)) => Decoder s a

-- | Utility to support specialised encoding for some list type - used for
--   <tt><a>Char</a></tt>/<tt><a>String</a></tt> instances in this package.
encodeList :: Serialise a => [a] -> Encoding

-- | Utility to support specialised decoding for some list type - used for
--   <tt><a>Char</a></tt>/<tt><a>String</a></tt> instances in this package.
decodeList :: Serialise a => Decoder s [a]

class GSerialiseEncode f

gencode :: GSerialiseEncode f => f a -> Encoding

class GSerialiseDecode f

gdecode :: GSerialiseDecode f => Decoder s (f a)

-- | Serialization of product types
class GSerialiseProd f

-- | Number of fields in product type
nFields :: GSerialiseProd f => Proxy f -> Word

-- | Encode fields sequentially without writing header
encodeSeq :: GSerialiseProd f => f a -> Encoding

-- | Decode fields sequentially without reading header
gdecodeSeq :: GSerialiseProd f => Decoder s (f a)

-- | Serialization of sum types
class GSerialiseSum f

-- | Number of constructor of given value
conNumber :: GSerialiseSum f => f a -> Word

-- | Number of fields of given value
numOfFields :: GSerialiseSum f => f a -> Word

-- | Encode field
encodeSum :: GSerialiseSum f => f a -> Encoding

-- | Decode field
decodeSum :: GSerialiseSum f => Word -> Decoder s (f a)

-- | Number of constructors
nConstructors :: GSerialiseSum f => Proxy f -> Word

-- | Number of fields for given constructor number
fieldsForCon :: GSerialiseSum f => Proxy f -> Word -> Decoder s Word

-- | Generic encoder for vectors. Its intended use is to allow easy
--   definition of <a>Serialise</a> instances for custom vector
encodeVector :: (Serialise a, Vector v a) => v a -> Encoding

-- | Generic decoder for vectors. Its intended use is to allow easy
--   definition of <a>Serialise</a> instances for custom vector
decodeVector :: (Serialise a, Vector v a) => Decoder s (v a)

-- | Patch functions together to obtain an <a>Encoding</a> for a container.
encodeContainerSkel :: (Word -> Encoding) -> (container -> Int) -> (accumFunc -> Encoding -> container -> Encoding) -> accumFunc -> container -> Encoding

-- | A helper function for encoding maps.
encodeMapSkel :: (Serialise k, Serialise v) => (m -> Int) -> ((k -> v -> Encoding -> Encoding) -> Encoding -> m -> Encoding) -> m -> Encoding

-- | A utility function to construct a <a>Decoder</a> for maps.
decodeMapSkel :: (Serialise k, Serialise v) => ([(k, v)] -> m) -> Decoder s m
instance forall k (f :: k -> *) (g :: k -> *). (Codec.Serialise.Class.GSerialiseSum f, Codec.Serialise.Class.GSerialiseSum g) => Codec.Serialise.Class.GSerialiseEncode (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) (g :: k -> *). (Codec.Serialise.Class.GSerialiseSum f, Codec.Serialise.Class.GSerialiseSum g) => Codec.Serialise.Class.GSerialiseDecode (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) (g :: k -> *). (Codec.Serialise.Class.GSerialiseSum f, Codec.Serialise.Class.GSerialiseSum g) => Codec.Serialise.Class.GSerialiseSum (f GHC.Generics.:+: g)
instance forall k i (f :: k -> *) (c :: GHC.Generics.Meta). (i GHC.Types.~ GHC.Generics.C, Codec.Serialise.Class.GSerialiseProd f) => Codec.Serialise.Class.GSerialiseSum (GHC.Generics.M1 i c f)
instance forall k (f :: k -> *) (g :: k -> *). (Codec.Serialise.Class.GSerialiseProd f, Codec.Serialise.Class.GSerialiseProd g) => Codec.Serialise.Class.GSerialiseEncode (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *). (Codec.Serialise.Class.GSerialiseProd f, Codec.Serialise.Class.GSerialiseProd g) => Codec.Serialise.Class.GSerialiseDecode (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *). (Codec.Serialise.Class.GSerialiseProd f, Codec.Serialise.Class.GSerialiseProd g) => Codec.Serialise.Class.GSerialiseProd (f GHC.Generics.:*: g)
instance Codec.Serialise.Class.GSerialiseProd GHC.Generics.U1
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.GSerialiseProd (GHC.Generics.K1 i a)
instance forall k i (f :: k -> *) (c :: GHC.Generics.Meta). (i GHC.Types.~ GHC.Generics.S, Codec.Serialise.Class.GSerialiseProd f) => Codec.Serialise.Class.GSerialiseProd (GHC.Generics.M1 i c f)
instance Codec.Serialise.Class.Serialise Codec.CBOR.Term.Term
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise [a]
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (GHC.Base.NonEmpty a)
instance Codec.Serialise.Class.Serialise Data.Void.Void
instance Codec.Serialise.Class.Serialise ()
instance Codec.Serialise.Class.Serialise GHC.Types.Bool
instance Codec.Serialise.Class.Serialise GHC.Types.Int
instance Codec.Serialise.Class.Serialise GHC.Int.Int8
instance Codec.Serialise.Class.Serialise GHC.Int.Int16
instance Codec.Serialise.Class.Serialise GHC.Int.Int32
instance Codec.Serialise.Class.Serialise GHC.Int.Int64
instance Codec.Serialise.Class.Serialise GHC.Types.Word
instance Codec.Serialise.Class.Serialise GHC.Word.Word8
instance Codec.Serialise.Class.Serialise GHC.Word.Word16
instance Codec.Serialise.Class.Serialise GHC.Word.Word32
instance Codec.Serialise.Class.Serialise GHC.Word.Word64
instance Codec.Serialise.Class.Serialise GHC.Num.Integer.Integer
instance Codec.Serialise.Class.Serialise GHC.Num.Natural.Natural
instance Codec.Serialise.Class.Serialise GHC.Types.Float
instance Codec.Serialise.Class.Serialise GHC.Types.Double
instance Codec.Serialise.Class.Serialise Numeric.Half.Internal.Half
instance forall k (e :: k). Codec.Serialise.Class.Serialise (Data.Fixed.Fixed e)
instance forall k (a :: k). Codec.Serialise.Class.Serialise (Data.Proxy.Proxy a)
instance Codec.Serialise.Class.Serialise GHC.Types.Char
instance Codec.Serialise.Class.Serialise Data.Text.Internal.Text
instance Codec.Serialise.Class.Serialise Data.ByteString.Internal.ByteString
instance Codec.Serialise.Class.Serialise Data.ByteString.Short.Internal.ShortByteString
instance Codec.Serialise.Class.Serialise Data.Text.Internal.Lazy.Text
instance Codec.Serialise.Class.Serialise Data.ByteString.Lazy.Internal.ByteString
instance forall k a (b :: k). Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Functor.Const.Const a b)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Control.Applicative.ZipList a)
instance (Codec.Serialise.Class.Serialise a, GHC.Real.Integral a) => Codec.Serialise.Class.Serialise (GHC.Real.Ratio a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Complex.Complex a)
instance Codec.Serialise.Class.Serialise GHC.Types.Ordering
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Ord.Down a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.Internal.Dual a)
instance Codec.Serialise.Class.Serialise Data.Semigroup.Internal.All
instance Codec.Serialise.Class.Serialise Data.Semigroup.Internal.Any
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.Internal.Sum a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.Internal.Product a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Monoid.First a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Monoid.Last a)
instance forall k (f :: k -> *) (a :: k). Codec.Serialise.Class.Serialise (f a) => Codec.Serialise.Class.Serialise (Data.Semigroup.Internal.Alt f a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Functor.Identity.Identity a)
instance Codec.Serialise.Class.Serialise GHC.IO.Exception.ExitCode
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.Min a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.Max a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.First a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.Last a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.WrappedMonoid a)
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CChar
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CSChar
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CUChar
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CShort
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CUShort
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CInt
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CUInt
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CLong
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CULong
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CPtrdiff
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CSize
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CWchar
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CSigAtomic
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CLLong
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CULLong
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CIntPtr
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CUIntPtr
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CIntMax
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CUIntMax
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CClock
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CTime
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CUSeconds
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CSUSeconds
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CFloat
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CDouble
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b) => Codec.Serialise.Class.Serialise (a, b)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c) => Codec.Serialise.Class.Serialise (a, b, c)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c, Codec.Serialise.Class.Serialise d) => Codec.Serialise.Class.Serialise (a, b, c, d)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c, Codec.Serialise.Class.Serialise d, Codec.Serialise.Class.Serialise e) => Codec.Serialise.Class.Serialise (a, b, c, d, e)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c, Codec.Serialise.Class.Serialise d, Codec.Serialise.Class.Serialise e, Codec.Serialise.Class.Serialise f) => Codec.Serialise.Class.Serialise (a, b, c, d, e, f)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c, Codec.Serialise.Class.Serialise d, Codec.Serialise.Class.Serialise e, Codec.Serialise.Class.Serialise f, Codec.Serialise.Class.Serialise g) => Codec.Serialise.Class.Serialise (a, b, c, d, e, f, g)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c, Codec.Serialise.Class.Serialise d, Codec.Serialise.Class.Serialise e, Codec.Serialise.Class.Serialise f, Codec.Serialise.Class.Serialise g, Codec.Serialise.Class.Serialise h) => Codec.Serialise.Class.Serialise (a, b, c, d, e, f, g, h)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c, Codec.Serialise.Class.Serialise d, Codec.Serialise.Class.Serialise e, Codec.Serialise.Class.Serialise f, Codec.Serialise.Class.Serialise g, Codec.Serialise.Class.Serialise h, Codec.Serialise.Class.Serialise i) => Codec.Serialise.Class.Serialise (a, b, c, d, e, f, g, h, i)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (GHC.Maybe.Maybe a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b) => Codec.Serialise.Class.Serialise (Data.Either.Either a b)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b) => Codec.Serialise.Class.Serialise (Data.These.These a b)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b) => Codec.Serialise.Class.Serialise (Data.Strict.Tuple.Pair a b)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Strict.Maybe.Maybe a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b) => Codec.Serialise.Class.Serialise (Data.Strict.Either.Either a b)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b) => Codec.Serialise.Class.Serialise (Data.Strict.These.These a b)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Tree.Tree a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Sequence.Internal.Seq a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Vector.Vector a)
instance (Codec.Serialise.Class.Serialise a, Data.Vector.Unboxed.Base.Unbox a) => Codec.Serialise.Class.Serialise (Data.Vector.Unboxed.Base.Vector a)
instance (Codec.Serialise.Class.Serialise a, Foreign.Storable.Storable a) => Codec.Serialise.Class.Serialise (Data.Vector.Storable.Vector a)
instance (Codec.Serialise.Class.Serialise a, Data.Primitive.Types.Prim a) => Codec.Serialise.Class.Serialise (Data.Vector.Primitive.Vector a)
instance (GHC.Classes.Ord a, Codec.Serialise.Class.Serialise a) => Codec.Serialise.Class.Serialise (Data.Set.Internal.Set a)
instance Codec.Serialise.Class.Serialise Data.IntSet.Internal.IntSet
instance (Codec.Serialise.Class.Serialise a, Data.Hashable.Class.Hashable a, GHC.Classes.Eq a) => Codec.Serialise.Class.Serialise (Data.HashSet.Internal.HashSet a)
instance (GHC.Classes.Ord k, Codec.Serialise.Class.Serialise k, Codec.Serialise.Class.Serialise v) => Codec.Serialise.Class.Serialise (Data.Map.Internal.Map k v)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.IntMap.Internal.IntMap a)
instance (Codec.Serialise.Class.Serialise k, Data.Hashable.Class.Hashable k, GHC.Classes.Eq k, Codec.Serialise.Class.Serialise v) => Codec.Serialise.Class.Serialise (Data.HashMap.Internal.HashMap k v)
instance Codec.Serialise.Class.Serialise Data.Version.Version
instance Codec.Serialise.Class.Serialise GHC.Fingerprint.Type.Fingerprint
instance Codec.Serialise.Class.Serialise GHC.Types.TyCon
instance Codec.Serialise.Class.Serialise GHC.Types.VecCount
instance Codec.Serialise.Class.Serialise GHC.Types.VecElem
instance Codec.Serialise.Class.Serialise GHC.Types.Levity
instance Codec.Serialise.Class.Serialise GHC.Types.RuntimeRep
instance Codec.Serialise.Class.Serialise GHC.Types.KindRep
instance Codec.Serialise.Class.Serialise GHC.Types.TypeLitSort
instance forall k (a :: k). Data.Typeable.Internal.Typeable a => Codec.Serialise.Class.Serialise (Data.Typeable.Internal.TypeRep a)
instance Codec.Serialise.Class.Serialise Data.Typeable.Internal.SomeTypeRep
instance Codec.Serialise.Class.Serialise Data.Time.Clock.Internal.UTCTime.UTCTime
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.GSerialiseEncode (GHC.Generics.K1 i a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.GSerialiseDecode (GHC.Generics.K1 i a)
instance Codec.Serialise.Class.GSerialiseDecode GHC.Generics.V1
instance Codec.Serialise.Class.GSerialiseDecode GHC.Generics.U1
instance forall k (a :: k -> *) i (c :: GHC.Generics.Meta). Codec.Serialise.Class.GSerialiseDecode a => Codec.Serialise.Class.GSerialiseDecode (GHC.Generics.M1 i c a)
instance Codec.Serialise.Class.GSerialiseEncode GHC.Generics.V1
instance Codec.Serialise.Class.GSerialiseEncode GHC.Generics.U1
instance forall k (a :: k -> *) i (c :: GHC.Generics.Meta). Codec.Serialise.Class.GSerialiseEncode a => Codec.Serialise.Class.GSerialiseEncode (GHC.Generics.M1 i c a)


-- | This module provides functions to serialise and deserialise Haskell
--   values for storage or transmission, to and from lazy
--   <tt><a>ByteString</a></tt>s. It also provides a type class and
--   utilities to help you make your types serialisable.
--   
--   For a full tutorial on using this module, see
--   <a>Codec.Serialise.Tutorial</a>.
module Codec.Serialise

-- | Serialise a Haskell value to an external binary representation.
--   
--   The output is represented as a lazy <a>ByteString</a> and is
--   constructed incrementally.
serialise :: Serialise a => a -> ByteString

-- | Deserialise a Haskell value from the external binary representation
--   (which must have been made using <a>serialise</a> or related
--   function).
--   
--   <i>Throws</i>: <tt><a>DeserialiseFailure</a></tt> if the given
--   external representation is invalid or does not correspond to a value
--   of the expected type.
deserialise :: Serialise a => ByteString -> a

-- | Deserialise a Haskell value from the external binary representation,
--   or get back a <tt><tt>DeserialiseFailure</tt></tt>.
deserialiseOrFail :: Serialise a => ByteString -> Either DeserialiseFailure a

-- | An exception type that may be returned (by pure functions) or thrown
--   (by IO actions) that fail to deserialise a given input.
data DeserialiseFailure
DeserialiseFailure :: ByteOffset -> String -> DeserialiseFailure

-- | Serialise a Haskell value to an external binary representation.
--   
--   The output is represented as a <a>Builder</a> and is constructed
--   incrementally. The representation as a <a>Builder</a> allows efficient
--   concatenation with other data.
serialiseIncremental :: Serialise a => a -> Builder

-- | Deserialise a Haskell value from the external binary representation.
--   
--   This allows <i>input</i> data to be provided incrementally, rather
--   than all in one go. It also gives an explicit representation of
--   deserialisation errors.
--   
--   Note that the incremental behaviour is only for the input data, not
--   the output value: the final deserialised value is constructed and
--   returned as a whole, not incrementally.
deserialiseIncremental :: Serialise a => ST s (IDecode s a)

-- | An Incremental decoder, used to represent the result of attempting to
--   run a decoder over a given input, and return a value of type
--   <tt>a</tt>.
data IDecode s a

-- | The decoder has consumed the available input and needs more to
--   continue. Provide <a>Just</a> if more input is available and
--   <a>Nothing</a> otherwise, and you will get a new <a>IDecode</a>.
Partial :: (Maybe ByteString -> ST s (IDecode s a)) -> IDecode s a

-- | The decoder has successfully finished. Except for the output value you
--   also get any unused input as well as the number of bytes consumed.
Done :: !ByteString -> {-# UNPACK #-} !ByteOffset -> a -> IDecode s a

-- | The decoder ran into an error. The decoder either used <a>fail</a> or
--   was not provided enough input. Contains any unconsumed input, the
--   number of bytes consumed, and a <a>DeserialiseFailure</a> exception
--   describing the reason why the failure occurred.
Fail :: !ByteString -> {-# UNPACK #-} !ByteOffset -> DeserialiseFailure -> IDecode s a

-- | Types that are instances of the <tt><a>Serialise</a></tt> class allow
--   values to be quickly encoded or decoded directly to a CBOR
--   representation, for object transmission or storage.
class Serialise a

-- | Definition for encoding a given type into a binary representation,
--   using the <tt><a>Encoding</a></tt> <tt><a>Monoid</a></tt>.
encode :: Serialise a => a -> Encoding

-- | Definition for encoding a given type into a binary representation,
--   using the <tt><a>Encoding</a></tt> <tt><a>Monoid</a></tt>.
encode :: (Serialise a, Generic a, GSerialiseEncode (Rep a)) => a -> Encoding

-- | Definition of a given <tt><a>Decoder</a></tt> for a type.
decode :: Serialise a => Decoder s a

-- | Definition of a given <tt><a>Decoder</a></tt> for a type.
decode :: (Serialise a, Generic a, GSerialiseDecode (Rep a)) => Decoder s a

-- | Utility to support specialised encoding for some list type - used for
--   <tt><a>Char</a></tt>/<tt><a>String</a></tt> instances in this package.
encodeList :: Serialise a => [a] -> Encoding

-- | Utility to support specialised decoding for some list type - used for
--   <tt><a>Char</a></tt>/<tt><a>String</a></tt> instances in this package.
decodeList :: Serialise a => Decoder s [a]

-- | Serialise a <tt><a>ByteString</a></tt> and write it directly to the
--   specified file.
writeFileSerialise :: Serialise a => FilePath -> a -> IO ()

-- | Read the specified file (internally, by reading a
--   <tt><a>ByteString</a></tt>) and attempt to decode it into a Haskell
--   value using <tt><a>deserialise</a></tt> (the type of which is
--   determined by the choice of the result type).
--   
--   <i>Throws</i>: <tt><a>DeserialiseFailure</a></tt> if the file fails to
--   deserialise properly.
readFileDeserialise :: Serialise a => FilePath -> IO a

-- | Serialise a <tt><a>ByteString</a></tt> (via <tt><a>serialise</a></tt>)
--   and write it directly to the specified <tt><a>Handle</a></tt>.
hPutSerialise :: Serialise a => Handle -> a -> IO ()


-- | High-level file-based API for serialising and deserialising values.
module Codec.Serialise.IO

-- | Serialise a <tt><a>ByteString</a></tt> and write it directly to the
--   specified file.
writeFileSerialise :: Serialise a => FilePath -> a -> IO ()

-- | Read the specified file (internally, by reading a
--   <tt><a>ByteString</a></tt>) and attempt to decode it into a Haskell
--   value using <tt><a>deserialise</a></tt> (the type of which is
--   determined by the choice of the result type).
--   
--   <i>Throws</i>: <tt><a>DeserialiseFailure</a></tt> if the file fails to
--   deserialise properly.
readFileDeserialise :: Serialise a => FilePath -> IO a

-- | Serialise a <tt><a>ByteString</a></tt> (via <tt><a>serialise</a></tt>)
--   and write it directly to the specified <tt><a>Handle</a></tt>.
hPutSerialise :: Serialise a => Handle -> a -> IO ()


-- | This module contains a set of generally useful properties, which
--   instance authors are encouraged to use in order to test their
--   instances of the <tt><a>Serialise</a></tt> class. For example, if you
--   have a data type which you might derive or write instances for:
--   
--   <pre>
--   data Foo = Foo { fooInt :: Int, fooBool :: Bool }
--     deriving (Eq, Show, <a>Generic</a>)
--   -- or, alternatively
--   instance <a>Serialise</a> Foo where
--     <a>encode</a> = ...
--     <a>decode</a> = ...
--   </pre>
--   
--   Then you can use this module to easily derive some quick properties:
--   
--   <pre>
--   import qualified <a>Codec.Serialise.Properties</a> as Props
--   
--   fooSerialiseId :: Foo -&gt; Bool
--   fooSerialiseId = Props.<a>serialiseIdentity</a>
--   
--   fooFlatTermId :: Foo -&gt; Bool
--   fooFlatTermId = Props.<a>flatTermIdentity</a>
--   
--   fooHasValidFlatTerm :: Foo -&gt; Bool
--   fooHasValidFlatTerm = Props.<a>hasValidFlatTerm</a>
--   </pre>
--   
--   You can then conveniently use these three functions with QuickCheck,
--   for example.
module Codec.Serialise.Properties

-- | Ensure that serializing and deserializing some value results in the
--   original value being returned.
serialiseIdentity :: (Serialise a, Eq a) => a -> Bool

-- | Ensure that serializing and deserializing a value with the
--   <tt><a>FlatTerm</a></tt> form results in the original value being
--   returned.
flatTermIdentity :: (Serialise a, Eq a) => a -> Bool

-- | Ensure that serializing a value into a <tt><a>FlatTerm</a></tt> gives
--   us a valid <tt><a>FlatTerm</a></tt> back.
hasValidFlatTerm :: Serialise a => a -> Bool


-- | <tt>serialise</tt> library is built on <tt>cborg</tt>, they implement
--   CBOR (Concise Binary Object Representation, specified by <a>IETF RFC
--   7049</a>) and serialisers/deserializers for it.
module Codec.Serialise.Tutorial

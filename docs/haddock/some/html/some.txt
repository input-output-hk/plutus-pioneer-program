-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Existential type: Some
--   
--   This library defines an existential type <a>Some</a>.
--   
--   <pre>
--   data Some f where
--       Some :: f a -&gt; Some f
--   </pre>
--   
--   in few variants, and utilities to work with it.
--   
--   If you are unsure which variant to use, use the one in
--   <a>Data.Some</a> module.
@package some
@version 1.0.3

module Data.GADT.DeepSeq
class GNFData f
grnf :: GNFData f => f a -> ()
instance forall k (a :: k -> *) (b :: k -> *). (Data.GADT.DeepSeq.GNFData a, Data.GADT.DeepSeq.GNFData b) => Data.GADT.DeepSeq.GNFData (Data.Functor.Product.Product a b)
instance forall k (a :: k -> *) (b :: k -> *). (Data.GADT.DeepSeq.GNFData a, Data.GADT.DeepSeq.GNFData b) => Data.GADT.DeepSeq.GNFData (Data.Functor.Sum.Sum a b)
instance forall k (a :: k). Data.GADT.DeepSeq.GNFData ((Data.Type.Equality.:~:) a)
instance Data.GADT.DeepSeq.GNFData Data.Typeable.Internal.TypeRep

module Data.GADT.Compare

-- | A class for type-contexts which contain enough information to (at
--   least in some cases) decide the equality of types occurring within
--   them.
class GEq f

-- | Produce a witness of type-equality, if one exists.
--   
--   A handy idiom for using this would be to pattern-bind in the Maybe
--   monad, eg.:
--   
--   <pre>
--   extract :: GEq tag =&gt; tag a -&gt; DSum tag -&gt; Maybe a
--   extract t1 (t2 :=&gt; x) = do
--       Refl &lt;- geq t1 t2
--       return x
--   </pre>
--   
--   Or in a list comprehension:
--   
--   <pre>
--   extractMany :: GEq tag =&gt; tag a -&gt; [DSum tag] -&gt; [a]
--   extractMany t1 things = [ x | (t2 :=&gt; x) &lt;- things, Refl &lt;- maybeToList (geq t1 t2)]
--   </pre>
--   
--   (Making use of the <tt>DSum</tt> type from <a>Data.Dependent.Sum</a>
--   in both examples)
geq :: GEq f => f a -> f b -> Maybe (a :~: b)

-- | If <tt>f</tt> has a <a>GEq</a> instance, this function makes a
--   suitable default implementation of <a>(==)</a>.
defaultEq :: GEq f => f a -> f b -> Bool

-- | If <tt>f</tt> has a <a>GEq</a> instance, this function makes a
--   suitable default implementation of <a>(/=)</a>.
defaultNeq :: GEq f => f a -> f b -> Bool

-- | Type class for comparable GADT-like structures. When 2 things are
--   equal, must return a witness that their parameter types are equal as
--   well (<a>GEQ</a>).
class GEq f => GCompare f
gcompare :: GCompare f => f a -> f b -> GOrdering a b
defaultCompare :: GCompare f => f a -> f b -> Ordering

-- | A type for the result of comparing GADT constructors; the type
--   parameters of the GADT values being compared are included so that in
--   the case where they are equal their parameter types can be unified.
data GOrdering a b
[GLT] :: GOrdering a b
[GEQ] :: GOrdering t t
[GGT] :: GOrdering a b

module Data.GADT.Show

-- | <a>Show</a>-like class for 1-type-parameter GADTs. <tt>GShow t =&gt;
--   ...</tt> is equivalent to something like <tt>(forall a. Show (t a))
--   =&gt; ...</tt>. The easiest way to create instances would probably be
--   to write (or derive) an <tt>instance Show (T a)</tt>, and then simply
--   say:
--   
--   <pre>
--   instance GShow t where gshowsPrec = showsPrec
--   </pre>
class GShow t
gshowsPrec :: GShow t => Int -> t a -> ShowS
gshows :: GShow t => t a -> ShowS
gshow :: GShow t => t a -> String

-- | <a>Read</a>-like class for 1-type-parameter GADTs. Unlike
--   <a>GShow</a>, this one cannot be mechanically derived from a
--   <a>Read</a> instance because <a>greadsPrec</a> must choose the phantom
--   type based on the <a>String</a> being parsed.
class GRead t
greadsPrec :: GRead t => Int -> GReadS t

-- | <tt>GReadS t</tt> is equivalent to <tt>ReadS (forall b. (forall a. t a
--   -&gt; b) -&gt; b)</tt>, which is in turn equivalent to <tt>ReadS
--   (Exists t)</tt> (with <tt>data Exists t where Exists :: t a -&gt;
--   Exists t</tt>)
type GReadS t = String -> [(Some t, String)]
greads :: GRead t => GReadS t
gread :: GRead t => String -> (forall a. t a -> b) -> b

-- | <pre>
--   &gt;&gt;&gt; greadMaybe "InL Refl" mkSome :: Maybe (Some (Sum ((:~:) Int) ((:~:) Bool)))
--   Just (mkSome (InL Refl))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; greadMaybe "garbage" mkSome :: Maybe (Some ((:~:) Int))
--   Nothing
--   </pre>
greadMaybe :: GRead t => String -> (forall a. t a -> b) -> Maybe b
getGReadResult :: Some tag -> (forall a. tag a -> b) -> b
mkGReadResult :: tag a -> Some tag

module Data.Some.Church

-- | Existential. This is type is useful to hide GADTs' parameters.
--   
--   <pre>
--   &gt;&gt;&gt; data Tag :: * -&gt; * where TagInt :: Tag Int; TagBool :: Tag Bool
--   
--   &gt;&gt;&gt; instance GShow Tag where gshowsPrec _ TagInt = showString "TagInt"; gshowsPrec _ TagBool = showString "TagBool"
--   
--   &gt;&gt;&gt; classify s = case s of "TagInt" -&gt; [mkGReadResult TagInt]; "TagBool" -&gt; [mkGReadResult TagBool]; _ -&gt; []
--   
--   &gt;&gt;&gt; instance GRead Tag where greadsPrec _ s = [ (r, rest) | (con, rest) &lt;-  lex s, r &lt;- classify con ]
--   </pre>
--   
--   With Church-encoding youcan only use a functions:
--   
--   <pre>
--   &gt;&gt;&gt; let y = mkSome TagBool
--   
--   &gt;&gt;&gt; y
--   mkSome TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withSome y $ \y' -&gt; case y' of { TagInt -&gt; "I"; TagBool -&gt; "B" } :: String
--   "B"
--   </pre>
--   
--   or explicitly work with <a>S</a>
--   
--   <pre>
--   &gt;&gt;&gt; let x = S $ \f -&gt; f TagInt
--   
--   &gt;&gt;&gt; x
--   mkSome TagInt
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; case x of S f -&gt; f $ \x' -&gt; case x' of { TagInt -&gt; "I"; TagBool -&gt; "B" } :: String
--   "I"
--   </pre>
--   
--   The implementation of <a>mapSome</a> is <i>safe</i>.
--   
--   <pre>
--   &gt;&gt;&gt; let f :: Tag a -&gt; Tag a; f TagInt = TagInt; f TagBool = TagBool
--   
--   &gt;&gt;&gt; mapSome f y
--   mkSome TagBool
--   </pre>
--   
--   but you can also use:
--   
--   <pre>
--   &gt;&gt;&gt; withSome y (mkSome . f)
--   mkSome TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "Some TagBool" :: Some Tag
--   mkSome TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "mkSome TagInt" :: Some Tag
--   mkSome TagInt
--   </pre>
newtype Some tag
S :: (forall r. (forall a. tag a -> r) -> r) -> Some tag

-- | Eliminator.
[withSome] :: Some tag -> forall r. (forall a. tag a -> r) -> r

-- | Constructor.
mkSome :: tag a -> Some tag

-- | Map over argument.
mapSome :: (forall x. f x -> g x) -> Some f -> Some g

-- | Monadic <a>withSome</a>.
withSomeM :: Monad m => m (Some tag) -> (forall a. tag a -> m r) -> m r

-- | <pre>
--   <a>flip</a> <a>withSome</a>
--   </pre>
foldSome :: (forall a. tag a -> b) -> Some tag -> b

-- | Traverse over argument.
traverseSome :: Functor m => (forall a. f a -> m (g a)) -> Some f -> m (Some g)

module Data.Some.GADT

-- | Existential. This is type is useful to hide GADTs' parameters.
--   
--   <pre>
--   &gt;&gt;&gt; data Tag :: * -&gt; * where TagInt :: Tag Int; TagBool :: Tag Bool
--   
--   &gt;&gt;&gt; instance GShow Tag where gshowsPrec _ TagInt = showString "TagInt"; gshowsPrec _ TagBool = showString "TagBool"
--   
--   &gt;&gt;&gt; classify s = case s of "TagInt" -&gt; [mkGReadResult TagInt]; "TagBool" -&gt; [mkGReadResult TagBool]; _ -&gt; []
--   
--   &gt;&gt;&gt; instance GRead Tag where greadsPrec _ s = [ (r, rest) | (con, rest) &lt;-  lex s, r &lt;- classify con ]
--   </pre>
--   
--   You can either use constructor:
--   
--   <pre>
--   &gt;&gt;&gt; let x = Some TagInt
--   
--   &gt;&gt;&gt; x
--   Some TagInt
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; case x of { Some TagInt -&gt; "I"; Some TagBool -&gt; "B" } :: String
--   "I"
--   </pre>
--   
--   or you can use functions
--   
--   <pre>
--   &gt;&gt;&gt; let y = mkSome TagBool
--   
--   &gt;&gt;&gt; y
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withSome y $ \y' -&gt; case y' of { TagInt -&gt; "I"; TagBool -&gt; "B" } :: String
--   "B"
--   </pre>
--   
--   The implementation of <a>mapSome</a> is <i>safe</i>.
--   
--   <pre>
--   &gt;&gt;&gt; let f :: Tag a -&gt; Tag a; f TagInt = TagInt; f TagBool = TagBool
--   
--   &gt;&gt;&gt; mapSome f y
--   Some TagBool
--   </pre>
--   
--   but you can also use:
--   
--   <pre>
--   &gt;&gt;&gt; withSome y (mkSome . f)
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "Some TagBool" :: Some Tag
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "mkSome TagInt" :: Some Tag
--   Some TagInt
--   </pre>
data Some tag
[Some] :: tag a -> Some tag

-- | Constructor.
mkSome :: tag a -> Some tag

-- | Eliminator.
withSome :: Some tag -> (forall a. tag a -> b) -> b

-- | Monadic <a>withSome</a>.
withSomeM :: Monad m => m (Some tag) -> (forall a. tag a -> m r) -> m r

-- | Map over argument.
mapSome :: (forall x. f x -> g x) -> Some f -> Some g

-- | <pre>
--   <a>flip</a> <a>withSome</a>
--   </pre>
foldSome :: (forall a. tag a -> b) -> Some tag -> b

-- | Traverse over argument.
traverseSome :: Functor m => (forall a. f a -> m (g a)) -> Some f -> m (Some g)
instance forall k (tag :: k -> *). Data.GADT.Internal.GShow tag => GHC.Show.Show (Data.Some.GADT.Some tag)
instance forall k (f :: k -> *). Data.GADT.Internal.GRead f => GHC.Read.Read (Data.Some.GADT.Some f)
instance forall k (tag :: k -> *). Data.GADT.Internal.GEq tag => GHC.Classes.Eq (Data.Some.GADT.Some tag)
instance forall k (tag :: k -> *). Data.GADT.Internal.GCompare tag => GHC.Classes.Ord (Data.Some.GADT.Some tag)
instance forall k (tag :: k -> *). Data.GADT.DeepSeq.GNFData tag => Control.DeepSeq.NFData (Data.Some.GADT.Some tag)
instance GHC.Base.Applicative m => GHC.Base.Semigroup (Data.Some.GADT.Some m)
instance GHC.Base.Applicative m => GHC.Base.Monoid (Data.Some.GADT.Some m)

module Data.Some.Newtype

-- | Existential. This is type is useful to hide GADTs' parameters.
--   
--   <pre>
--   &gt;&gt;&gt; data Tag :: * -&gt; * where TagInt :: Tag Int; TagBool :: Tag Bool
--   
--   &gt;&gt;&gt; instance GShow Tag where gshowsPrec _ TagInt = showString "TagInt"; gshowsPrec _ TagBool = showString "TagBool"
--   
--   &gt;&gt;&gt; classify s = case s of "TagInt" -&gt; [mkGReadResult TagInt]; "TagBool" -&gt; [mkGReadResult TagBool]; _ -&gt; []
--   
--   &gt;&gt;&gt; instance GRead Tag where greadsPrec _ s = [ (r, rest) | (con, rest) &lt;-  lex s, r &lt;- classify con ]
--   </pre>
--   
--   You can either use <tt>PatternSynonyms</tt> (available with GHC &gt;=
--   8.0)
--   
--   <pre>
--   &gt;&gt;&gt; let x = Some TagInt
--   
--   &gt;&gt;&gt; x
--   Some TagInt
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; case x of { Some TagInt -&gt; "I"; Some TagBool -&gt; "B" } :: String
--   "I"
--   </pre>
--   
--   or you can use functions
--   
--   <pre>
--   &gt;&gt;&gt; let y = mkSome TagBool
--   
--   &gt;&gt;&gt; y
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withSome y $ \y' -&gt; case y' of { TagInt -&gt; "I"; TagBool -&gt; "B" } :: String
--   "B"
--   </pre>
--   
--   The implementation of <a>mapSome</a> is <i>safe</i>.
--   
--   <pre>
--   &gt;&gt;&gt; let f :: Tag a -&gt; Tag a; f TagInt = TagInt; f TagBool = TagBool
--   
--   &gt;&gt;&gt; mapSome f y
--   Some TagBool
--   </pre>
--   
--   but you can also use:
--   
--   <pre>
--   &gt;&gt;&gt; withSome y (mkSome . f)
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "Some TagBool" :: Some Tag
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "mkSome TagInt" :: Some Tag
--   Some TagInt
--   </pre>
data Some tag
pattern Some :: tag a -> Some tag

-- | Constructor.
mkSome :: tag a -> Some tag

-- | Eliminator.
withSome :: Some tag -> (forall a. tag a -> b) -> b

-- | Monadic <a>withSome</a>.
withSomeM :: Monad m => m (Some tag) -> (forall a. tag a -> m r) -> m r

-- | Map over argument.
mapSome :: (forall t. f t -> g t) -> Some f -> Some g

-- | <pre>
--   <a>flip</a> <a>withSome</a>
--   </pre>
foldSome :: (forall a. tag a -> b) -> Some tag -> b

-- | Traverse over argument.
traverseSome :: Functor m => (forall a. f a -> m (g a)) -> Some f -> m (Some g)
instance forall k (tag :: k -> *). Data.GADT.Internal.GShow tag => GHC.Show.Show (Data.Some.Newtype.Some tag)
instance forall k (f :: k -> *). Data.GADT.Internal.GRead f => GHC.Read.Read (Data.Some.Newtype.Some f)
instance forall k (tag :: k -> *). Data.GADT.Internal.GEq tag => GHC.Classes.Eq (Data.Some.Newtype.Some tag)
instance forall k (tag :: k -> *). Data.GADT.Internal.GCompare tag => GHC.Classes.Ord (Data.Some.Newtype.Some tag)
instance forall k (tag :: k -> *). Data.GADT.DeepSeq.GNFData tag => Control.DeepSeq.NFData (Data.Some.Newtype.Some tag)
instance GHC.Base.Applicative m => GHC.Base.Semigroup (Data.Some.Newtype.Some m)
instance GHC.Base.Applicative m => GHC.Base.Monoid (Data.Some.Newtype.Some m)


-- | An existential type.
--   
--   The constructor is exported only on GHC-8 and later.
module Data.Some

-- | Existential. This is type is useful to hide GADTs' parameters.
--   
--   <pre>
--   &gt;&gt;&gt; data Tag :: * -&gt; * where TagInt :: Tag Int; TagBool :: Tag Bool
--   
--   &gt;&gt;&gt; instance GShow Tag where gshowsPrec _ TagInt = showString "TagInt"; gshowsPrec _ TagBool = showString "TagBool"
--   
--   &gt;&gt;&gt; classify s = case s of "TagInt" -&gt; [mkGReadResult TagInt]; "TagBool" -&gt; [mkGReadResult TagBool]; _ -&gt; []
--   
--   &gt;&gt;&gt; instance GRead Tag where greadsPrec _ s = [ (r, rest) | (con, rest) &lt;-  lex s, r &lt;- classify con ]
--   </pre>
--   
--   You can either use <tt>PatternSynonyms</tt> (available with GHC &gt;=
--   8.0)
--   
--   <pre>
--   &gt;&gt;&gt; let x = Some TagInt
--   
--   &gt;&gt;&gt; x
--   Some TagInt
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; case x of { Some TagInt -&gt; "I"; Some TagBool -&gt; "B" } :: String
--   "I"
--   </pre>
--   
--   or you can use functions
--   
--   <pre>
--   &gt;&gt;&gt; let y = mkSome TagBool
--   
--   &gt;&gt;&gt; y
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withSome y $ \y' -&gt; case y' of { TagInt -&gt; "I"; TagBool -&gt; "B" } :: String
--   "B"
--   </pre>
--   
--   The implementation of <a>mapSome</a> is <i>safe</i>.
--   
--   <pre>
--   &gt;&gt;&gt; let f :: Tag a -&gt; Tag a; f TagInt = TagInt; f TagBool = TagBool
--   
--   &gt;&gt;&gt; mapSome f y
--   Some TagBool
--   </pre>
--   
--   but you can also use:
--   
--   <pre>
--   &gt;&gt;&gt; withSome y (mkSome . f)
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "Some TagBool" :: Some Tag
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "mkSome TagInt" :: Some Tag
--   Some TagInt
--   </pre>
data Some tag
pattern Some :: tag a -> Some tag

-- | Constructor.
mkSome :: tag a -> Some tag

-- | Eliminator.
withSome :: Some tag -> (forall a. tag a -> b) -> b

-- | Monadic <a>withSome</a>.
withSomeM :: Monad m => m (Some tag) -> (forall a. tag a -> m r) -> m r

-- | Map over argument.
mapSome :: (forall t. f t -> g t) -> Some f -> Some g

-- | <pre>
--   <a>flip</a> <a>withSome</a>
--   </pre>
foldSome :: (forall a. tag a -> b) -> Some tag -> b

-- | Traverse over argument.
traverseSome :: Functor m => (forall a. f a -> m (g a)) -> Some f -> m (Some g)

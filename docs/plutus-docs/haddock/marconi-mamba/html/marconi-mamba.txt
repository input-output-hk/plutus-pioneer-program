-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/plutus-apps#readme</a>
@package marconi-mamba
@version 1.1.0.0


-- | This module provides support for writing handlers for JSON-RPC
--   endpoints
module Marconi.Api.Types

-- | Typre represents non empty list of Bech32 Shelley compatable addresses
type TargetAddresses = NonEmpty Address ShelleyAddr

-- | Type represents http port for JSON-RPC
type RpcPortNumber = Int
data CliArgs
CliArgs :: FilePath -> FilePath -> Maybe Int -> NetworkId -> TargetAddresses -> CliArgs

-- | POSIX socket file to communicate with cardano node
[socket] :: CliArgs -> FilePath

-- | filepath to local sqlite for utxo index table
[dbPath] :: CliArgs -> FilePath

-- | optional tcp/ip port number for JSON-RPC http server
[httpPort] :: CliArgs -> Maybe Int

-- | cardano network id
[networkId] :: CliArgs -> NetworkId

-- | white-space sepparated list of Bech32 Cardano Shelley addresses
[targetAddresses] :: CliArgs -> TargetAddresses
data DBQueryEnv
DBQueryEnv :: UtxoQueryTMVar -> TargetAddresses -> DBQueryEnv
[_queryTMVar] :: DBQueryEnv -> UtxoQueryTMVar

-- | user provided addresses to filter
[_queryAddresses] :: DBQueryEnv -> TargetAddresses
class HasDBQueryEnv c_aUiD
dBQueryEnv :: HasDBQueryEnv c_aUiD => Lens' c_aUiD DBQueryEnv
queryAddresses :: HasDBQueryEnv c_aUiD => Lens' c_aUiD TargetAddresses
queryTMVar :: HasDBQueryEnv c_aUiD => Lens' c_aUiD UtxoQueryTMVar

-- | JSON-RPC configuration
data JsonRpcEnv
JsonRpcEnv :: Settings -> DBQueryEnv -> JsonRpcEnv

-- | HTTP server setting
[_httpSettings] :: JsonRpcEnv -> Settings

-- | used for query sqlite
[_queryEnv] :: JsonRpcEnv -> DBQueryEnv
class HasJsonRpcEnv c_aUmV
jsonRpcEnv :: HasJsonRpcEnv c_aUmV => Lens' c_aUmV JsonRpcEnv
httpSettings :: HasJsonRpcEnv c_aUmV => Lens' c_aUmV Settings
queryEnv :: HasJsonRpcEnv c_aUmV => Lens' c_aUmV DBQueryEnv
newtype UtxoRowWrapper
UtxoRowWrapper :: UtxoRow -> UtxoRowWrapper
data UtxoTxOutReport
UtxoTxOutReport :: Text -> [UtxoRow] -> UtxoTxOutReport
[bech32Address] :: UtxoTxOutReport -> Text
[utxoReport] :: UtxoTxOutReport -> [UtxoRow]
newtype UtxoQueryTMVar
UtxoQueryTMVar :: TMVar UtxoIndex -> UtxoQueryTMVar

-- | for query thread to access in-memory utxos
[unUtxoIndex] :: UtxoQueryTMVar -> TMVar UtxoIndex
data QueryExceptions
AddressNotInListError :: QueryExceptions -> QueryExceptions
AddressConversionError :: QueryExceptions -> QueryExceptions
TxRefConversionError :: QueryExceptions -> QueryExceptions
QueryError :: String -> QueryExceptions
instance GHC.Generics.Generic Marconi.Api.Types.UtxoTxOutReport
instance GHC.Classes.Ord Marconi.Api.Types.UtxoTxOutReport
instance GHC.Classes.Eq Marconi.Api.Types.UtxoTxOutReport
instance GHC.Generics.Generic Marconi.Api.Types.UtxoRowWrapper
instance GHC.Show.Show Marconi.Api.Types.UtxoRowWrapper
instance GHC.Classes.Ord Marconi.Api.Types.UtxoRowWrapper
instance GHC.Classes.Eq Marconi.Api.Types.UtxoRowWrapper
instance GHC.Exception.Type.Exception Marconi.Api.Types.QueryExceptions
instance GHC.Show.Show Marconi.Api.Types.QueryExceptions
instance Data.Aeson.Types.ToJSON.ToJSON Marconi.Api.Types.UtxoRowWrapper
instance Data.Aeson.Types.ToJSON.ToJSON Marconi.Api.Types.UtxoTxOutReport
instance Marconi.Api.Types.HasJsonRpcEnv Marconi.Api.Types.JsonRpcEnv
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.Address.AddressAny
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.ScriptData.ScriptData
instance Data.Aeson.Types.ToJSON.ToJSON Data.ByteString.Internal.ByteString
instance Data.Aeson.Types.ToJSON.ToJSON Marconi.Index.Utxo.Utxo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Slotting.Block.BlockNo
instance Data.Aeson.Types.ToJSON.ToJSON Marconi.Index.Utxo.UtxoRow
instance Marconi.Api.Types.HasDBQueryEnv Marconi.Api.Types.DBQueryEnv
instance GHC.Show.Show Marconi.Api.Types.CliArgs

module Marconi.Api.Routes
type Echo = JsonRpc "echo" String String String
type TxOutRefReport = JsonRpc "utxoTxOutReport" String String UtxoTxOutReport
type TxOutRefsReport = JsonRpc "utxoTxOutReports" Int String [UtxoTxOutReport]
type TargetAddressesReport = JsonRpc "addressesBech32Report" Int String [Text]
type Print = JsonRpcNotification "print" String
type RpcAPI = Echo :<|> TxOutRefReport :<|> TxOutRefsReport :<|> TargetAddressesReport :<|> Print
type JsonRpcAPI = "json-rpc" :> RawJsonRpc RpcAPI
type GetTime = "time" :> Get '[PlainText] String
type GetTargetAddresses = "addresses" :> Get '[JSON] [Text]
type PrintMessage = "print" :> ReqBody '[PlainText] String :> Post '[PlainText] NoContent
type RestAPI = "rest" :> (GetTime :<|> GetTargetAddresses :<|> PrintMessage)
type API = JsonRpcAPI :<|> RestAPI
type NonEndpoint = "json-rpc" :> RawJsonRpc (JsonRpc "launch-missles" Int String Bool)

module Marconi.Api.UtxoIndexersQuery

-- | Bootstraps the utxo query environment. The module is responsible for
--   accessing SQLite for quries. The main issue we try to avoid here is
--   mixing inserts and quries in SQLite to avoid locking the database
bootstrap :: TargetAddresses -> IO DBQueryEnv

-- | Query utxos by Cardano Address To Cardano error may occure
findByCardanoAddress :: DBQueryEnv -> AddressAny -> IO [UtxoRow]

-- | Retrieve a Set of TxOutRefs associated with the given Cardano Era
--   address We return an empty Set if no address is found
findByAddress :: DBQueryEnv -> Text -> IO (Either QueryExceptions UtxoTxOutReport)

-- | finds reports for all user-provided addresses. TODO consider sqlite
--   streaming,
--   <a>https://hackage.haskell.org/package/sqlite-simple-0.4.18.2/docs/Database-SQLite-Simple.html#g:14</a>
findAll :: DBQueryEnv -> IO [UtxoTxOutReport]

-- | report target addresses Used by JSON-RPC
reportQueryAddresses :: DBQueryEnv -> IO [Address ShelleyAddr]
data UtxoRow
UtxoRow :: Utxo -> !SlotNo -> !BlockNo -> UtxoRow
[_utxoRowUtxo] :: UtxoRow -> Utxo
[_utxoRowSlotNo] :: UtxoRow -> !SlotNo
[_utxoRowBlockNo] :: UtxoRow -> !BlockNo
type UtxoIndex = SqliteIndex UtxoEvent Notification AddressAny Result
reportQueryCardanoAddresses :: DBQueryEnv -> Text
reportBech32Addresses :: DBQueryEnv -> [Text]

-- | Execute the query function We must stop the utxo inserts before doing
--   the query
withQueryAction :: DBQueryEnv -> AddressAny -> IO [UtxoRow]

-- | Non-blocking write of a new value to a <a>TMVar</a> Puts if empty.
--   Replaces if populated.
writeTMVar :: TMVar a -> a -> STM ()

module Marconi.Api.HttpServer

-- | bootstraps the he http server
bootstrap :: JsonRpcEnv -> IO ()


-- | This module bootstraps the mamba JSON RPC server, it acts as a glue
--   conntecting the JSON-RPC, HttpServer, marconiIndexer, and marconi
--   cache
module Marconi.Bootstrap

-- | Bootstraps the JSON-RPC http server with appropriate settings and
--   marconi cache this is just a wrapper for the bootstrapHttp in json-rpc
--   package
bootstrapJsonRpc :: Maybe RpcPortNumber -> TargetAddresses -> IO JsonRpcEnv
bootstrapHttp :: JsonRpcEnv -> IO ()

-- | marconi cardano blockchain indexer
bootstrapUtxoIndexers :: CliArgs -> JsonRpcEnv -> IO ()

-- | parses a white space separated address list Note, duplicate addresses
--   are rmoved
targetAddressParser :: String -> TargetAddresses

-- | Exit program with error Note, if the targetAddress parser fails, or is
--   empty, there is nothing to do for the hotStore. In such case we should
--   fail fast
fromJustWithError :: Show e => Either e a -> a

module Marconi.MambaCli

-- | parse cli arguments
parserCliArgs :: Parser CliArgs
parserOpts :: String -> ParserInfo CliArgs
parseCli :: IO CliArgs

-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/plutus-apps#readme</a>
@package marconi
@version 1.1.0.0

module Marconi.Index.Datum
type DatumIndex = SqliteIndex Event Notification Query Result
type Event = [(SlotNo, (DatumHash, ScriptData))]
type Query = DatumHash
type Result = Maybe ScriptData
type Notification = ()
newtype Depth
Depth :: Int -> Depth
open :: FilePath -> Depth -> IO DatumIndex
instance Database.SQLite.Simple.FromField.FromField Marconi.Index.Datum.DatumHash
instance Database.SQLite.Simple.ToField.ToField Marconi.Index.Datum.DatumHash
instance Codec.Serialise.Class.Serialise Cardano.Api.ScriptData.ScriptData
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.ScriptData.ScriptData
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.ScriptData.ScriptData
instance Database.SQLite.Simple.FromField.FromField Cardano.Slotting.Slot.SlotNo
instance Database.SQLite.Simple.ToField.ToField Cardano.Slotting.Slot.SlotNo

module Marconi.Index.ScriptTx
data ScriptTxHandle
ScriptTxHandle :: Connection -> Int -> ScriptTxHandle
[hdlConnection] :: ScriptTxHandle -> Connection
[hdlDepth] :: ScriptTxHandle -> Int
newtype Depth
Depth :: Int -> Depth
newtype TxCbor
TxCbor :: ByteString -> TxCbor
type ScriptTxIndexer = State ScriptTxHandle
data ScriptTxRow
ScriptTxRow :: !StorableQuery ScriptTxHandle -> !TxCbor -> !SlotNo -> !Hash BlockHeader -> ScriptTxRow
[scriptAddress] :: ScriptTxRow -> !StorableQuery ScriptTxHandle
[txCbor] :: ScriptTxRow -> !TxCbor
[txSlot] :: ScriptTxRow -> !SlotNo
[blockHash] :: ScriptTxRow -> !Hash BlockHeader
type Query = StorableQuery ScriptTxHandle
type Result = StorableResult ScriptTxHandle
toUpdate :: forall era. IsCardanoEra era => [Tx era] -> ChainPoint -> StorableEvent ScriptTxHandle
getTxBodyScripts :: forall era. TxBody era -> [StorableQuery ScriptTxHandle]
getTxScripts :: forall era. Tx era -> [StorableQuery ScriptTxHandle]
asEvents :: [ScriptTxRow] -> [StorableEvent ScriptTxHandle]
open :: FilePath -> Depth -> IO ScriptTxIndexer

-- | TODO: Remove when the following function is exported from
--   Cardano.Api.Script PR:
--   <a>https://github.com/input-output-hk/cardano-node/pull/4386</a>
fromShelleyBasedScript :: ShelleyBasedEra era -> Script (ShelleyLedgerEra era) -> ScriptInEra era
instance GHC.Classes.Eq (RewindableIndex.Storable.StorableQuery Marconi.Index.ScriptTx.ScriptTxHandle)
instance GHC.Show.Show (RewindableIndex.Storable.StorableQuery Marconi.Index.ScriptTx.ScriptTxHandle)
instance Database.SQLite.Simple.FromField.FromField Marconi.Index.ScriptTx.TxCbor
instance Database.SQLite.Simple.ToField.ToField Marconi.Index.ScriptTx.TxCbor
instance GHC.Show.Show Marconi.Index.ScriptTx.TxCbor
instance GHC.Classes.Eq Marconi.Index.ScriptTx.TxCbor
instance GHC.Show.Show (RewindableIndex.Storable.StorableEvent Marconi.Index.ScriptTx.ScriptTxHandle)
instance GHC.Generics.Generic Marconi.Index.ScriptTx.ScriptTxRow
instance Database.SQLite.Simple.FromRow.FromRow Marconi.Index.ScriptTx.ScriptTxRow
instance Database.SQLite.Simple.ToRow.ToRow Marconi.Index.ScriptTx.ScriptTxRow
instance RewindableIndex.Storable.Buffered Marconi.Index.ScriptTx.ScriptTxHandle
instance RewindableIndex.Storable.Queryable Marconi.Index.ScriptTx.ScriptTxHandle
instance RewindableIndex.Storable.HasPoint (RewindableIndex.Storable.StorableEvent Marconi.Index.ScriptTx.ScriptTxHandle) Cardano.Api.Block.ChainPoint
instance Database.SQLite.Simple.ToField.ToField (RewindableIndex.Storable.StorableQuery Marconi.Index.ScriptTx.ScriptTxHandle)
instance Database.SQLite.Simple.FromField.FromField (RewindableIndex.Storable.StorableQuery Marconi.Index.ScriptTx.ScriptTxHandle)
instance RewindableIndex.Storable.Rewindable Marconi.Index.ScriptTx.ScriptTxHandle
instance RewindableIndex.Storable.Resumable Marconi.Index.ScriptTx.ScriptTxHandle
instance Database.SQLite.Simple.ToField.ToField Cardano.Slotting.Slot.SlotNo
instance Database.SQLite.Simple.FromField.FromField Cardano.Slotting.Slot.SlotNo
instance Database.SQLite.Simple.ToField.ToField (Cardano.Api.Hash.Hash Cardano.Api.Block.BlockHeader)
instance Database.SQLite.Simple.FromField.FromField (Cardano.Api.Hash.Hash Cardano.Api.Block.BlockHeader)
instance GHC.Classes.Ord Cardano.Api.Block.ChainPoint

module Marconi.Orphans
instance Prettyprinter.Internal.Pretty Cardano.Api.Block.ChainTip
instance Prettyprinter.Internal.Pretty Cardano.Api.Block.ChainPoint
instance Prettyprinter.Internal.Pretty (Cardano.Api.Hash.Hash Cardano.Api.Block.BlockHeader)
instance Prettyprinter.Internal.Pretty Cardano.Slotting.Slot.SlotNo
instance Prettyprinter.Internal.Pretty Cardano.Slotting.Block.BlockNo

module Marconi.Logging
logging :: Trace IO Text -> Stream (Of (ChainSyncEvent (BlockInMode CardanoMode))) IO r -> Stream (Of (ChainSyncEvent (BlockInMode CardanoMode))) IO r


-- | This module provides several type aliases and utility functions to
--   deal with them.
module Marconi.Types

-- | Typre represents non empty list of Bech32 Shelley compatable addresses
type TargetAddresses = NonEmpty (Address ShelleyAddr)

-- | An alias for the current era, to ease the transition from one era to
--   the next one
type CurrentEra = BabbageEra
pattern AsCurrentEra :: AsType CurrentEra
pattern CurrentEra :: CardanoEra CurrentEra

-- | A Cardano TxOut of the current Era
type TxOut = TxOut CtxTx CurrentEra

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
type TxOutRef = TxIn
txOutRef :: TxId -> TxIx -> TxIn

module Marconi.Index.Utxo

-- | only store rows in the address list.
addressFilteredRows :: AddressAny -> [UtxoEvent] -> [UtxoRow]
newtype Depth
Depth :: Int -> Depth
eventAtAddress :: AddressAny -> UtxoEvent -> [UtxoEvent]
getUtxos :: IsCardanoEra era => Maybe TargetAddresses -> Tx era -> [Utxo]
getUtxoEvents :: IsCardanoEra era => Maybe TargetAddresses -> SlotNo -> BlockNo -> [Tx era] -> Maybe UtxoEvent
open :: FilePath -> Depth -> IO UtxoIndex

-- | Query the data stored in the indexer Quries SQL + buffered data, where
--   buffered data is the data that will be batched to SQL
query :: UtxoIndex -> AddressAny -> [UtxoEvent] -> IO Result

-- | Query the data stored in the indexer as a whole from: + volatile :
--   in-memory, datat that may rollback + diskStore : on-disk + buffered :
--   in-memeoy, data that will flush to storage
queryPlusVolatile :: UtxoIndex -> AddressAny -> IO Result
type Result = Maybe [UtxoRow]

-- | convert utoEvents to utxoRows
toRows :: UtxoEvent -> [UtxoRow]
toAddr :: AddressInEra CurrentEra -> AddressAny
utxoAddress :: Lens' Utxo AddressAny
utxoEventSlotNo :: Lens' UtxoEvent SlotNo
utxoEventUtxos :: Lens' UtxoEvent [Utxo]
utxoRowUtxo :: Lens' UtxoRow Utxo
data Utxo
Utxo :: !AddressAny -> !TxId -> !TxIx -> Maybe ScriptData -> Maybe (Hash ScriptData) -> Value -> Maybe ByteString -> Maybe ScriptHash -> Utxo
[_utxoAddress] :: Utxo -> !AddressAny
[_utxoTxId] :: Utxo -> !TxId
[_utxoTxIx] :: Utxo -> !TxIx
[_utxoDatum] :: Utxo -> Maybe ScriptData
[_utxoDatumHash] :: Utxo -> Maybe (Hash ScriptData)
[_utxoValue] :: Utxo -> Value
[_utxoInlineScript] :: Utxo -> Maybe ByteString
[_utxoInlineScriptHash] :: Utxo -> Maybe ScriptHash
data UtxoEvent
UtxoEvent :: [Utxo] -> !Set TxIn -> !SlotNo -> !BlockNo -> UtxoEvent
[_utxoEventUtxos] :: UtxoEvent -> [Utxo]
[_utxoEventInputs] :: UtxoEvent -> !Set TxIn
[_utxoEventSlotNo] :: UtxoEvent -> !SlotNo
[_utxoEventBlockNo] :: UtxoEvent -> !BlockNo
data UtxoRow
UtxoRow :: Utxo -> !SlotNo -> !BlockNo -> UtxoRow
[_utxoRowUtxo] :: UtxoRow -> Utxo
[_utxoRowSlotNo] :: UtxoRow -> !SlotNo
[_utxoRowBlockNo] :: UtxoRow -> !BlockNo
type UtxoIndex = SqliteIndex UtxoEvent Notification AddressAny Result

-- | The 0-based index of the block in the blockchain. BlockNo is &lt;=
--   SlotNo and is only equal at slot N if there is a block for every slot
--   where N &lt;= SlotNo.
newtype BlockNo
BlockNo :: Word64 -> BlockNo
[unBlockNo] :: BlockNo -> Word64

-- | The 0-based index for the Ourboros time slot.
newtype SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64
instance Database.SQLite.Simple.FromRow.FromRow Cardano.Api.TxIn.TxIn
instance Database.SQLite.Simple.ToRow.ToRow Cardano.Api.TxIn.TxIn
instance Database.SQLite.Simple.ToRow.ToRow Marconi.Index.Utxo.UtxoRow
instance Database.SQLite.Simple.FromRow.FromRow Marconi.Index.Utxo.UtxoRow
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.Address.AddressAny
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.Address.AddressAny
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.TxIn.TxId
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.TxIn.TxId
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.TxIn.TxIx
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.TxIn.TxIx
instance Database.SQLite.Simple.FromField.FromField (Cardano.Api.Hash.Hash Cardano.Api.ScriptData.ScriptData)
instance Database.SQLite.Simple.ToField.ToField (Cardano.Api.Hash.Hash Cardano.Api.ScriptData.ScriptData)
instance Codec.Serialise.Class.Serialise Cardano.Api.ScriptData.ScriptData
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.ScriptData.ScriptData
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.ScriptData.ScriptData
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.Value.Value
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.Value.Value
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.Script.ScriptHash
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.Script.ScriptHash
instance Database.SQLite.Simple.FromField.FromField Cardano.Slotting.Slot.SlotNo
instance Database.SQLite.Simple.ToField.ToField Cardano.Slotting.Slot.SlotNo
instance Database.SQLite.Simple.FromField.FromField Cardano.Slotting.Block.BlockNo
instance Database.SQLite.Simple.ToField.ToField Cardano.Slotting.Block.BlockNo
instance GHC.Generics.Generic Marconi.Index.Utxo.UtxoRow
instance GHC.Classes.Ord Marconi.Index.Utxo.UtxoRow
instance GHC.Classes.Eq Marconi.Index.Utxo.UtxoRow
instance GHC.Show.Show Marconi.Index.Utxo.UtxoRow
instance GHC.Classes.Eq Marconi.Index.Utxo.UtxoEvent
instance GHC.Show.Show Marconi.Index.Utxo.UtxoEvent
instance GHC.Classes.Eq Marconi.Index.Utxo.Utxo
instance GHC.Classes.Ord Marconi.Index.Utxo.Utxo
instance GHC.Generics.Generic Marconi.Index.Utxo.Utxo
instance GHC.Show.Show Marconi.Index.Utxo.Utxo

module Marconi.Indexers
getDatums :: BlockInMode CardanoMode -> [(SlotNo, (Hash ScriptData, ScriptData))]
scriptDataFromCardanoTxBody :: TxBody era -> Map (Hash ScriptData) ScriptData

-- | The way we synchronise channel consumption is by waiting on a QSemN
--   for each of the spawn indexers to finish processing the current event.
--   
--   The channel is used to transmit the next event to the listening
--   indexers. Note that even if the channel is unbound it will actually
--   only ever hold one event because it will be blocked until the
--   processing of the event finishes on all indexers.
--   
--   The indexer count is where we save the number of running indexers so
--   we know for how many we are waiting.
data Coordinator
Coordinator :: TChan (ChainSyncEvent (BlockInMode CardanoMode)) -> QSemN -> Int -> Coordinator
[_channel] :: Coordinator -> TChan (ChainSyncEvent (BlockInMode CardanoMode))
[_barrier] :: Coordinator -> QSemN
[_indexerCount] :: Coordinator -> Int
initialCoordinator :: Int -> IO Coordinator
type Worker = Coordinator -> FilePath -> IO [StorablePoint ScriptTxHandle]
datumWorker :: Worker

-- | does the transaction contain a targetAddress
isInTargetTxOut :: TargetAddresses -> TxOut CtxTx era -> Bool
utxoWorker :: (UtxoIndex -> IO UtxoIndex) -> Maybe TargetAddresses -> Worker
scriptTxWorker_ :: (StorableEvent ScriptTxHandle -> IO [()]) -> Depth -> Coordinator -> TChan (ChainSyncEvent (BlockInMode CardanoMode)) -> FilePath -> IO (IO (), MVar ScriptTxIndexer)
scriptTxWorker :: (StorableEvent ScriptTxHandle -> IO [()]) -> Worker
newtype UtxoQueryTMVar
UtxoQueryTMVar :: TMVar UtxoIndex -> UtxoQueryTMVar

-- | for query thread to access in-memory utxos
[unUtxoIndex] :: UtxoQueryTMVar -> TMVar UtxoIndex
filterIndexers :: Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe TargetAddresses -> [(Worker, FilePath)]
startIndexers :: [(Worker, FilePath)] -> IO ([ChainPoint], Coordinator)
mkIndexerStream :: Coordinator -> Stream (Of (ChainSyncEvent (BlockInMode CardanoMode))) IO r -> IO ()

module Marconi.CLI
chainPointParser :: Parser ChainPoint

-- | parses CLI params to valid NonEmpty list of Shelley addresses We error
--   out if there are any invalid addresses
multiString :: Mod OptionFields [Address ShelleyAddr] -> Parser TargetAddresses
parseCardanoAddresses :: String -> [Address ShelleyAddr]
pNetworkId :: Parser NetworkId

-- | This executable is meant to exercise a set of indexers (for now
--   datumhash -&gt; datum) against the mainnet (meant to be used for
--   testing).
--   
--   In case you want to access the results of the datumhash indexer you
--   need to query the resulting database: $ sqlite3 datums.sqlite &gt;
--   select slotNo, datumHash, datum from kv_datumhsh_datum where slotNo =
--   39920450;
--   39920450|679a55b523ff8d61942b2583b76e5d49498468164802ef1ebe513c685d6fb5c2|X(002f9787436835852ea78d3c45fc3d436b324184
data Options
Options :: String -> NetworkId -> ChainPoint -> FilePath -> Bool -> Bool -> Bool -> Maybe TargetAddresses -> Options
[optionsSocketPath] :: Options -> String
[optionsNetworkId] :: Options -> NetworkId
[optionsChainPoint] :: Options -> ChainPoint

-- | SQLite database directory path
[optionsDbPath] :: Options -> FilePath
[optionsDisableUtxo] :: Options -> Bool
[optionsDisableDatum] :: Options -> Bool
[optionsDisableScript] :: Options -> Bool
[optionsTargetAddresses] :: Options -> Maybe TargetAddresses
optionsParser :: Parser Options
parseOptions :: IO Options
utxoDbPath :: Options -> Maybe FilePath
datumDbPath :: Options -> Maybe FilePath
scriptTxDbPath :: Options -> Maybe FilePath
instance GHC.Show.Show Marconi.CLI.Options

-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package playground-common
@version 1.1.0.0

module Auth.Types
addUserAgent :: Request -> Request
newtype OAuthCode
OAuthCode :: Text -> OAuthCode
data OAuthToken a
OAuthToken :: !Token a -> !Text -> !Text -> OAuthToken a
[oAuthTokenAccessToken] :: OAuthToken a -> !Token a
[oAuthTokenScope] :: OAuthToken a -> !Text
[oAuthTokenTokenType] :: OAuthToken a -> !Text
data TokenProvider
Github :: TokenProvider
newtype Token (a :: TokenProvider)
Token :: Text -> Token (a :: TokenProvider)
newtype OAuthClientId
OAuthClientId :: Text -> OAuthClientId
newtype OAuthClientSecret
OAuthClientSecret :: Text -> OAuthClientSecret
instance Control.Newtype.Generics.Newtype Auth.Types.OAuthCode
instance GHC.Generics.Generic Auth.Types.OAuthCode
instance GHC.Classes.Eq Auth.Types.OAuthCode
instance GHC.Show.Show Auth.Types.OAuthCode
instance Control.Newtype.Generics.Newtype (Auth.Types.Token a)
instance Data.Aeson.Types.ToJSON.ToJSON (Auth.Types.Token a)
instance Data.Aeson.Types.FromJSON.FromJSON (Auth.Types.Token a)
instance GHC.Generics.Generic (Auth.Types.Token a)
instance GHC.Classes.Eq (Auth.Types.Token a)
instance GHC.Show.Show (Auth.Types.Token a)
instance GHC.Generics.Generic (Auth.Types.OAuthToken a)
instance GHC.Classes.Eq (Auth.Types.OAuthToken a)
instance GHC.Show.Show (Auth.Types.OAuthToken a)
instance Control.Newtype.Generics.Newtype Auth.Types.OAuthClientId
instance Data.Aeson.Types.ToJSON.ToJSON Auth.Types.OAuthClientId
instance Data.Aeson.Types.FromJSON.FromJSON Auth.Types.OAuthClientId
instance GHC.Generics.Generic Auth.Types.OAuthClientId
instance GHC.Classes.Eq Auth.Types.OAuthClientId
instance GHC.Show.Show Auth.Types.OAuthClientId
instance Control.Newtype.Generics.Newtype Auth.Types.OAuthClientSecret
instance Data.Aeson.Types.ToJSON.ToJSON Auth.Types.OAuthClientSecret
instance Data.Aeson.Types.FromJSON.FromJSON Auth.Types.OAuthClientSecret
instance GHC.Generics.Generic Auth.Types.OAuthClientSecret
instance GHC.Classes.Eq Auth.Types.OAuthClientSecret
instance GHC.Show.Show Auth.Types.OAuthClientSecret
instance Data.Aeson.Types.ToJSON.ToJSON (Auth.Types.OAuthToken a)
instance Data.Aeson.Types.FromJSON.FromJSON (Auth.Types.OAuthToken a)
instance Web.Internal.HttpApiData.ToHttpApiData (Auth.Types.Token a)
instance Web.Internal.HttpApiData.FromHttpApiData Auth.Types.OAuthCode

module Control.Monad.Now
class Monad m => MonadNow m
getCurrentTime :: MonadNow m => m UTCTime
getPOSIXTime :: MonadNow m => m POSIXTime
instance Control.Monad.Now.MonadNow GHC.Types.IO
instance Control.Monad.Now.MonadNow m => Control.Monad.Now.MonadNow (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Now.MonadNow m => Control.Monad.Now.MonadNow (Control.Monad.Logger.LoggingT m)
instance Control.Monad.Now.MonadNow m => Control.Monad.Now.MonadNow (Control.Monad.Trans.Reader.ReaderT r m)

module Control.Monad.Trace

-- | <tt>Trace</tt> is a neat way to run a <a>Maybe</a> monad, but leave a
--   trail behind so that if it fails, we know what step it failed at.
type TraceMaybe a = MaybeT (Writer (Last a))
withTrace :: Monad m => Maybe a -> MaybeT m a
attempt :: a -> TraceMaybe a ()
runTrace :: e -> TraceMaybe e a -> Either e a

module Control.Monad.Web
class Monad m => MonadWeb m
doRequest :: MonadWeb m => Manager -> Request -> m (Either Text (Response ByteString))
makeManager :: MonadWeb m => m Manager
instance Control.Monad.Web.MonadWeb GHC.Types.IO
instance Control.Monad.Web.MonadWeb m => Control.Monad.Web.MonadWeb (Control.Monad.Logger.LoggingT m)
instance Control.Monad.Web.MonadWeb m => Control.Monad.Web.MonadWeb (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Web.MonadWeb m => Control.Monad.Web.MonadWeb (Control.Monad.Trans.Reader.ReaderT a m)

module Language.Haskell.Interpreter

-- | spawn an external process to runghc a file
--   
--   If you set the environmental varaiable GHC_BIN_DIR then the executable
--   runghc in that path will be used. This is useful if you want to your
--   file to be run with some packages available, you can create a wrapper
--   runghc that includes these
--   
--   Any errors are converted to InterpreterError
runghc :: (Show t, TimeUnit t, MonadIO m, MonadError InterpreterError m, MonadMask m) => t -> [String] -> FilePath -> m (InterpreterResult String)
data CompilationError
RawError :: Text -> CompilationError
CompilationError :: !Text -> !Int -> !Int -> ![Text] -> CompilationError
[filename] :: CompilationError -> !Text
[row] :: CompilationError -> !Int
[column] :: CompilationError -> !Int
[text] :: CompilationError -> ![Text]
data InterpreterError
CompilationErrors :: [CompilationError] -> InterpreterError
TimeoutError :: Text -> InterpreterError
newtype SourceCode
SourceCode :: Text -> SourceCode
avoidUnsafe :: MonadError InterpreterError m => SourceCode -> m ()
newtype Warning
Warning :: Text -> Warning
data InterpreterResult a
InterpreterResult :: [Warning] -> a -> InterpreterResult a
[warnings] :: InterpreterResult a -> [Warning]
[result] :: InterpreterResult a -> a
parseErrorText :: Text -> CompilationError
instance Data.Aeson.Types.FromJSON.FromJSON Language.Haskell.Interpreter.CompilationError
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Interpreter.CompilationError
instance GHC.Generics.Generic Language.Haskell.Interpreter.CompilationError
instance GHC.Classes.Eq Language.Haskell.Interpreter.CompilationError
instance GHC.Show.Show Language.Haskell.Interpreter.CompilationError
instance Data.Aeson.Types.FromJSON.FromJSON Language.Haskell.Interpreter.InterpreterError
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Interpreter.InterpreterError
instance GHC.Generics.Generic Language.Haskell.Interpreter.InterpreterError
instance GHC.Classes.Eq Language.Haskell.Interpreter.InterpreterError
instance GHC.Show.Show Language.Haskell.Interpreter.InterpreterError
instance Control.Newtype.Generics.Newtype Language.Haskell.Interpreter.SourceCode
instance Data.Aeson.Types.FromJSON.FromJSON Language.Haskell.Interpreter.SourceCode
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Interpreter.SourceCode
instance GHC.Generics.Generic Language.Haskell.Interpreter.SourceCode
instance GHC.Classes.Eq Language.Haskell.Interpreter.SourceCode
instance GHC.Show.Show Language.Haskell.Interpreter.SourceCode
instance Data.Aeson.Types.FromJSON.FromJSON Language.Haskell.Interpreter.Warning
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.Interpreter.Warning
instance GHC.Generics.Generic Language.Haskell.Interpreter.Warning
instance GHC.Show.Show Language.Haskell.Interpreter.Warning
instance GHC.Classes.Eq Language.Haskell.Interpreter.Warning
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Language.Haskell.Interpreter.InterpreterResult a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Language.Haskell.Interpreter.InterpreterResult a)
instance GHC.Base.Functor Language.Haskell.Interpreter.InterpreterResult
instance GHC.Generics.Generic (Language.Haskell.Interpreter.InterpreterResult a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Haskell.Interpreter.InterpreterResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Haskell.Interpreter.InterpreterResult a)


-- | This module exists to take concrete types and convert them into
--   something we can easily create generic UI forms for, based on their
--   structure. As a secondary requirement, it also aims to be easy to
--   serialize to a sensible JSON representation.
--   
--   <a>ToSchema</a> turns a function signature into a <a>FormSchema</a> -
--   a description that can serialised as JSON and analysed in PureScript
--   land. In essence it's a simplified, specialised version of a
--   <a>Generic</a> representation.
--   
--   The frontend then takes a <a>FormSchema</a>, generates a UI form, and
--   allows the user create a concrete value that follows that schema. This
--   is the <a>FormArgument</a>.
--   
--   It's useful for the backend to make this instantiation too (because we
--   want to give the user example filled-in forms), so we provide
--   ToArgument.
module Schema

-- | A description of a type, suitable for consumption by the Playground's
--   website.
--   
--   By calling <a>toSchema</a> on a type you get a description of its
--   structure. Semantically:
--   
--   <pre>
--   &gt;&gt;&gt; toSchema @Int
--   
--   &gt;&gt;&gt; -- returns, "this is an Int."
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; toSchema @SomeRecord
--   
--   &gt;&gt;&gt; -- returns, "this is a record, and it has
--   
--   &gt;&gt;&gt; -- these named fields with these types".
--   </pre>
--   
--   The description you get back is the <a>FormSchema</a> type, which
--   describes all the obvious primitives, plus some Plutus types deemed
--   worthy of special treatment (eg. <a>Value</a>).
--   
--   Internally it relies on <a>Generics</a> to extract the type
--   information, but the implementation jumps through some hoops because
--   generics is geared towards getting the type-description of a specific
--   value (eg. <tt>Left <a>Foo</a></tt> or <tt>Right 5</tt>) rather than
--   on the type itself (eg. <tt>Either String Int</tt>).
class ToSchema a
toSchema :: ToSchema a => FormSchema

-- | The value-level equivalent of <a>ToSchema</a>. Where <a>ToSchema</a>
--   takes your type and returns a generic description of its structure,
--   <a>ToArgument</a> takes your value and returns an equivalent value
--   with a more generic structure. So semantially:
--   
--   The description you get back is the <a>FormArgument</a> type, which
--   describes all the obvious primitives, plus some Plutus types deemed
--   worthy of special treatment (eg. <a>Value</a>).
--   
--   <pre>
--   &gt;&gt;&gt; toSchema @User
--   
--   &gt;&gt;&gt; -- returns, "this is a record with a 'name' field, which is a String."
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; toArgument (User "Dave")
--   
--   &gt;&gt;&gt; -- returns, "this is a record with a 'name' field, which is a the String 'Dave'."
--   </pre>
class ToSchema a => ToArgument a
toArgument :: ToArgument a => a -> Fix FormArgumentF
data FormSchema
FormSchemaUnit :: FormSchema
FormSchemaBool :: FormSchema
FormSchemaInt :: FormSchema
FormSchemaInteger :: FormSchema
FormSchemaString :: FormSchema

-- | A string that may only contain <tt>0-9a-fA-F</tt>
FormSchemaHex :: FormSchema
FormSchemaArray :: FormSchema -> FormSchema
FormSchemaMaybe :: FormSchema -> FormSchema

-- | A radio button with a list of labels.
FormSchemaRadio :: [String] -> FormSchema
FormSchemaTuple :: FormSchema -> FormSchema -> FormSchema
FormSchemaObject :: [(String, FormSchema)] -> FormSchema
FormSchemaValue :: FormSchema
FormSchemaPOSIXTimeRange :: FormSchema
FormSchemaUnsupported :: String -> FormSchema
type FormArgument = Fix FormArgumentF
data FormArgumentF a
FormUnitF :: FormArgumentF a
FormBoolF :: Bool -> FormArgumentF a
FormIntF :: Maybe Int -> FormArgumentF a
FormIntegerF :: Maybe Integer -> FormArgumentF a
FormStringF :: Maybe String -> FormArgumentF a
FormHexF :: Maybe String -> FormArgumentF a
FormRadioF :: [String] -> Maybe String -> FormArgumentF a
FormArrayF :: FormSchema -> [a] -> FormArgumentF a
FormMaybeF :: FormSchema -> Maybe a -> FormArgumentF a
FormTupleF :: a -> a -> FormArgumentF a
FormObjectF :: [(String, a)] -> FormArgumentF a
FormValueF :: Value -> FormArgumentF a
FormPOSIXTimeRangeF :: Interval POSIXTime -> FormArgumentF a
FormUnsupportedF :: String -> FormArgumentF a
formArgumentToJson :: Fix FormArgumentF -> Maybe Value
instance Schema.ToSchema Ledger.Ada.Ada
instance Schema.ToSchema Wallet.Types.ContractInstanceId
instance Schema.ToSchema Plutus.V1.Ledger.Value.CurrencySymbol
instance Schema.ToSchema Plutus.V1.Ledger.Scripts.DatumHash
instance Schema.ToSchema Ledger.Crypto.PubKey
instance Schema.ToSchema Plutus.V1.Ledger.Crypto.PubKeyHash
instance Schema.ToSchema Ledger.Address.PaymentPubKey
instance Schema.ToSchema Ledger.Address.PaymentPubKeyHash
instance Schema.ToSchema Cardano.Ledger.Alonzo.Language.Language
instance Schema.ToSchema Ledger.Address.StakePubKey
instance Schema.ToSchema Ledger.Address.StakePubKeyHash
instance Schema.ToSchema Plutus.V1.Ledger.Scripts.RedeemerHash
instance Schema.ToSchema Ledger.Slot.Slot
instance Schema.ToSchema Ledger.Crypto.Signature
instance Schema.ToSchema Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance Schema.ToSchema Plutus.V1.Ledger.Value.TokenName
instance Schema.ToSchema Plutus.V1.Ledger.Tx.TxId
instance Schema.ToSchema Plutus.V1.Ledger.Tx.TxOutRef
instance Schema.ToSchema Plutus.V1.Ledger.Scripts.ValidatorHash
instance Schema.ToSchema Ledger.CardanoWallet.WalletNumber
instance Schema.ToArgument Ledger.Ada.Ada
instance Schema.ToArgument Ledger.CardanoWallet.WalletNumber
instance Schema.ToArgument Ledger.Slot.Slot
instance Data.Functor.Classes.Show1 Schema.FormArgumentF
instance Schema.ToSchema (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Schema.ToSchema PlutusTx.Builtins.Internal.BuiltinByteString
instance (Schema.ToSchema k, Schema.ToSchema v) => Schema.ToSchema (PlutusTx.AssocMap.Map k v)
instance Schema.ToSchema Plutus.V1.Ledger.Value.Value
instance Schema.ToArgument Plutus.V1.Ledger.Value.Value
instance Schema.ToSchema Plutus.V1.Ledger.Bytes.LedgerBytes
instance Schema.ToSchema Data.UUID.Types.Internal.UUID
instance Schema.ToSchema Wallet.Emulator.Wallet.WalletId
instance Schema.ToSchema Plutus.V1.Ledger.Time.POSIXTime
instance Schema.ToSchema Plutus.V1.Ledger.Time.POSIXTimeRange
instance Schema.ToSchema Plutus.V1.Ledger.Address.Address
instance Schema.ToSchema Wallet.Emulator.Wallet.Wallet
instance Schema.ToArgument Wallet.Emulator.Wallet.Wallet
instance Schema.ToArgument Wallet.Emulator.Wallet.WalletId
instance Schema.ToSchema a => Schema.ToSchema (Plutus.Contract.Secrets.SecretArgument a)
instance Schema.ToArgument a => Schema.ToArgument (Plutus.Contract.Secrets.SecretArgument a)
instance Data.Functor.Classes.Eq1 Schema.FormArgumentF
instance Data.OpenApi.Internal.Schema.ToSchema Schema.FormSchema
instance Data.Aeson.Types.ToJSON.ToJSON Schema.FormSchema
instance Data.Aeson.Types.FromJSON.FromJSON Schema.FormSchema
instance GHC.Generics.Generic Schema.FormSchema
instance GHC.Classes.Eq Schema.FormSchema
instance GHC.Show.Show Schema.FormSchema
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Schema.FormArgumentF a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Schema.FormArgumentF a)
instance GHC.Base.Functor Schema.FormArgumentF
instance GHC.Classes.Eq a => GHC.Classes.Eq (Schema.FormArgumentF a)
instance GHC.Generics.Generic (Schema.FormArgumentF a)
instance GHC.Show.Show a => GHC.Show.Show (Schema.FormArgumentF a)
instance Data.Aeson.Types.ToJSON.ToJSON (Data.Functor.Foldable.Fix Schema.FormArgumentF)
instance Data.Aeson.Types.FromJSON.FromJSON (Data.Functor.Foldable.Fix Schema.FormArgumentF)
instance (GHC.Generics.Constructor c, Schema.GenericToFields f) => Schema.GenericToSchema (GHC.Generics.C1 c f)
instance (Schema.GenericToFields f, Schema.GenericToFields g) => Schema.GenericToFields (f GHC.Generics.:*: g)
instance (Schema.ToSchema f, GHC.Generics.Selector s) => Schema.GenericToFields (GHC.Generics.S1 s (GHC.Generics.Rec0 f))
instance (Schema.GenericToConstructorName c1, Schema.GenericToConstructorName c2) => Schema.GenericToSchema (c1 GHC.Generics.:+: c2)
instance (Schema.GenericToConstructorName c1, Schema.GenericToConstructorName c2) => Schema.GenericToArgument (c1 GHC.Generics.:+: c2)
instance GHC.Generics.Constructor c => Schema.GenericToConstructorName (GHC.Generics.C1 c GHC.Generics.U1)
instance (Schema.GenericToConstructorName c1, Schema.GenericToConstructorName c2) => Schema.GenericToConstructorName (c1 GHC.Generics.:+: c2)
instance (Schema.GenericToPairs f, GHC.Generics.Constructor c) => Schema.GenericToArgument (GHC.Generics.C1 c f)
instance (Schema.GenericToPairs f, Schema.GenericToPairs g) => Schema.GenericToPairs (f GHC.Generics.:*: g)
instance (GHC.Generics.Selector s, Schema.ToArgument f) => Schema.GenericToPairs (GHC.Generics.S1 s (GHC.Generics.Rec0 f))
instance Schema.ToArgument ()
instance Schema.ToArgument GHC.Types.Bool
instance Schema.ToArgument GHC.Types.Int
instance Schema.ToArgument GHC.Integer.Type.Integer
instance Schema.ToArgument PlutusTx.Ratio.Rational
instance Schema.ToArgument Data.Text.Internal.Text
instance (Schema.ToArgument a, Schema.ToArgument b) => Schema.ToArgument (a, b)
instance Schema.ToArgument GHC.Base.String
instance (Schema.ToSchema a, Schema.ToArgument a) => Schema.ToArgument [a]
instance Schema.GenericToArgument f => Schema.GenericToArgument (GHC.Generics.D1 d f)
instance Schema.ToSchema ()
instance Schema.ToSchema GHC.Types.Bool
instance Schema.ToSchema GHC.Types.Int
instance Schema.ToSchema GHC.Integer.Type.Integer
instance Schema.ToSchema PlutusTx.Ratio.Rational
instance Schema.ToSchema Data.Text.Internal.Text
instance Schema.ToSchema a => Schema.ToSchema (Data.Proxy.Proxy a)
instance (Schema.ToSchema k, Schema.ToSchema v) => Schema.ToSchema (Data.Map.Internal.Map k v)
instance (Schema.ToSchema a, Schema.ToSchema b) => Schema.ToSchema (a, b)
instance Schema.ToSchema GHC.Base.String
instance Schema.ToSchema a => Schema.ToSchema [a]
instance Schema.ToSchema Plutus.V1.Ledger.Value.AssetClass
instance Schema.ToSchema a => Schema.ToSchema (GHC.Maybe.Maybe a)
instance Schema.GenericToSchema f => Schema.GenericToSchema (GHC.Generics.D1 d f)

module Playground.Types
data KnownCurrency
KnownCurrency :: ValidatorHash -> String -> NonEmpty TokenName -> KnownCurrency
[hash] :: KnownCurrency -> ValidatorHash
[friendlyName] :: KnownCurrency -> String
[knownTokens] :: KnownCurrency -> NonEmpty TokenName
adaCurrency :: KnownCurrency
data PayToWalletParams
PayToWalletParams :: WalletNumber -> Value -> PayToWalletParams
[payTo] :: PayToWalletParams -> WalletNumber
[value] :: PayToWalletParams -> Value
data SimulatorWallet
SimulatorWallet :: WalletNumber -> Value -> SimulatorWallet
[simulatorWalletWallet] :: SimulatorWallet -> WalletNumber
[simulatorWalletBalance] :: SimulatorWallet -> Value

-- | Describes the mockchain requests the frontend can make of the backend.
--   These will be mostly calls to their contract's various endpoints, but
--   we supply a few extra special calls for the sake of easier testing and
--   simulation.
data ContractCall a

-- | Call one of the defined endpoints of your contract.
CallEndpoint :: WalletNumber -> FunctionSchema a -> ContractCall a
[caller] :: ContractCall a -> WalletNumber
[argumentValues] :: ContractCall a -> FunctionSchema a

-- | Add the specified number of blocks to the mockchain before continuing.
AddBlocks :: Integer -> ContractCall a
[blocks] :: ContractCall a -> Integer

-- | Keep adding blocks until the mockchain reaches the specified slot,
--   then continue. (Note that calling <tt>AddBlocksUntil 20</tt> doesn't
--   mean you'll continue at slot 20, just that the slot number will now be
--   <i>at least</i> that high.
AddBlocksUntil :: Slot -> ContractCall a
[slot] :: ContractCall a -> Slot

-- | Make a wallet-to-wallet transfer of the specified value.
PayToWallet :: WalletNumber -> WalletNumber -> Value -> ContractCall a
[sender] :: ContractCall a -> WalletNumber
[recipient] :: ContractCall a -> WalletNumber
[amount] :: ContractCall a -> Value
type SimulatorAction = ContractCall (Fix FormArgumentF)
type Expression = ContractCall Value

-- | The example simulations have meaningful (hard-coded) names, but, for
--   any simulation the user creates in the playground, simulationName =
--   "Simulation " &lt;&gt; show simulationId; the simulationId is simply
--   present to ensure every simulation is created with a unique name.
data Simulation
Simulation :: String -> Int -> [SimulatorAction] -> [SimulatorWallet] -> Simulation
[simulationName] :: Simulation -> String
[simulationId] :: Simulation -> Int
[simulationActions] :: Simulation -> [SimulatorAction]
[simulationWallets] :: Simulation -> [SimulatorWallet]
data Evaluation
Evaluation :: [SimulatorWallet] -> SourceCode -> Value -> Evaluation
[wallets] :: Evaluation -> [SimulatorWallet]
[sourceCode] :: Evaluation -> SourceCode

-- | This will be a '[Expression s]' where <tt>s</tt> is the schema from
--   the compiled <a>SourceCode</a>. It has to be JSON, because we can't
--   know the type of <tt>s</tt> until the <a>SourceCode</a> has been
--   compiled.
[program] :: Evaluation -> Value
pubKeys :: Evaluation -> [PaymentPubKeyHash]
data EvaluationResult
EvaluationResult :: [[AnnotatedTx]] -> [EmulatorEvent] -> Text -> [SimulatorWallet] -> [SimulatorWallet] -> [(PaymentPubKeyHash, WalletNumber)] -> EvaluationResult

-- | Annotated blockchain, newest blocks first
[resultRollup] :: EvaluationResult -> [[AnnotatedTx]]

-- | The emulator log, newest events first
[emulatorLog] :: EvaluationResult -> [EmulatorEvent]
[emulatorTrace] :: EvaluationResult -> Text
[fundsDistribution] :: EvaluationResult -> [SimulatorWallet]
[feesDistribution] :: EvaluationResult -> [SimulatorWallet]
[walletKeys] :: EvaluationResult -> [(PaymentPubKeyHash, WalletNumber)]
data CompilationResult
CompilationResult :: [FunctionSchema FormSchema] -> [KnownCurrency] -> CompilationResult
[functionSchema] :: CompilationResult -> [FunctionSchema FormSchema]
[knownCurrencies] :: CompilationResult -> [KnownCurrency]
data ContractDemo
ContractDemo :: Text -> SourceCode -> [Simulation] -> InterpreterResult CompilationResult -> ContractDemo
[contractDemoName] :: ContractDemo -> Text
[contractDemoEditorContents] :: ContractDemo -> SourceCode
[contractDemoSimulations] :: ContractDemo -> [Simulation]
[contractDemoContext] :: ContractDemo -> InterpreterResult CompilationResult
data FunctionSchema a
FunctionSchema :: EndpointDescription -> a -> FunctionSchema a
[endpointDescription] :: FunctionSchema a -> EndpointDescription

-- | All contract endpoints take a single argument. (Multiple arguments
--   must be wrapped up into a container.)
[argument] :: FunctionSchema a -> a
data PlaygroundError
CompilationErrors :: [CompilationError] -> PlaygroundError
InterpreterError :: InterpreterError -> PlaygroundError
RollupError :: Text -> PlaygroundError
OtherError :: String -> PlaygroundError
JsonDecodingError :: String -> String -> String -> PlaygroundError
[expected] :: PlaygroundError -> String
[decodingError] :: PlaygroundError -> String
[input] :: PlaygroundError -> String
instance Data.Aeson.Types.FromJSON.FromJSON Playground.Types.KnownCurrency
instance Data.Aeson.Types.ToJSON.ToJSON Playground.Types.KnownCurrency
instance GHC.Generics.Generic Playground.Types.KnownCurrency
instance GHC.Show.Show Playground.Types.KnownCurrency
instance GHC.Classes.Eq Playground.Types.KnownCurrency
instance Schema.ToArgument Playground.Types.PayToWalletParams
instance Schema.ToSchema Playground.Types.PayToWalletParams
instance Data.Aeson.Types.ToJSON.ToJSON Playground.Types.PayToWalletParams
instance Data.Aeson.Types.FromJSON.FromJSON Playground.Types.PayToWalletParams
instance GHC.Generics.Generic Playground.Types.PayToWalletParams
instance GHC.Show.Show Playground.Types.PayToWalletParams
instance GHC.Classes.Eq Playground.Types.PayToWalletParams
instance Data.Aeson.Types.FromJSON.FromJSON Playground.Types.SimulatorWallet
instance Data.Aeson.Types.ToJSON.ToJSON Playground.Types.SimulatorWallet
instance GHC.Classes.Eq Playground.Types.SimulatorWallet
instance GHC.Generics.Generic Playground.Types.SimulatorWallet
instance GHC.Show.Show Playground.Types.SimulatorWallet
instance Data.Aeson.Types.FromJSON.FromJSON Playground.Types.Evaluation
instance Data.Aeson.Types.ToJSON.ToJSON Playground.Types.Evaluation
instance GHC.Generics.Generic Playground.Types.Evaluation
instance Data.Aeson.Types.FromJSON.FromJSON Playground.Types.EvaluationResult
instance Data.Aeson.Types.ToJSON.ToJSON Playground.Types.EvaluationResult
instance GHC.Generics.Generic Playground.Types.EvaluationResult
instance GHC.Show.Show Playground.Types.EvaluationResult
instance Data.Traversable.Traversable Playground.Types.FunctionSchema
instance Data.Foldable.Foldable Playground.Types.FunctionSchema
instance GHC.Base.Functor Playground.Types.FunctionSchema
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Playground.Types.FunctionSchema a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Playground.Types.FunctionSchema a)
instance GHC.Generics.Generic (Playground.Types.FunctionSchema a)
instance GHC.Show.Show a => GHC.Show.Show (Playground.Types.FunctionSchema a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Playground.Types.FunctionSchema a)
instance Data.Aeson.Types.ToJSON.ToJSON Playground.Types.CompilationResult
instance GHC.Generics.Generic Playground.Types.CompilationResult
instance GHC.Classes.Eq Playground.Types.CompilationResult
instance GHC.Show.Show Playground.Types.CompilationResult
instance Data.Traversable.Traversable Playground.Types.ContractCall
instance Data.Foldable.Foldable Playground.Types.ContractCall
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Playground.Types.ContractCall a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Playground.Types.ContractCall a)
instance GHC.Base.Functor Playground.Types.ContractCall
instance GHC.Generics.Generic (Playground.Types.ContractCall a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Playground.Types.ContractCall a)
instance GHC.Show.Show a => GHC.Show.Show (Playground.Types.ContractCall a)
instance Data.Aeson.Types.FromJSON.FromJSON Playground.Types.Simulation
instance Data.Aeson.Types.ToJSON.ToJSON Playground.Types.Simulation
instance GHC.Classes.Eq Playground.Types.Simulation
instance GHC.Generics.Generic Playground.Types.Simulation
instance GHC.Show.Show Playground.Types.Simulation
instance Data.Aeson.Types.ToJSON.ToJSON Playground.Types.ContractDemo
instance GHC.Generics.Generic Playground.Types.ContractDemo
instance GHC.Classes.Eq Playground.Types.ContractDemo
instance GHC.Show.Show Playground.Types.ContractDemo
instance Data.Aeson.Types.FromJSON.FromJSON Playground.Types.PlaygroundError
instance Data.Aeson.Types.ToJSON.ToJSON Playground.Types.PlaygroundError
instance GHC.Generics.Generic Playground.Types.PlaygroundError
instance GHC.Show.Show Playground.Types.PlaygroundError
instance GHC.Classes.Eq Playground.Types.PlaygroundError
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Playground.Types.FunctionSchema a)

module Playground.Interpreter.Util

-- | Evaluate a JSON payload from the Playground frontend against a given
--   contract schema.
stage :: forall w s a. (ContractConstraints s, ToJSON w, Monoid w) => Contract w s Text a -> ByteString -> ByteString -> Either PlaygroundError EvaluationResult
renderInstanceTrace :: [ContractInstanceTag] -> EmulatorEventFoldM effs Text


-- | This module handles exposing a Contract API to the Plutus Playground
--   frontend.
--   
--   In practice this means having a way of turning the Contract's effect
--   rows into a Schema declaration, by using an <a>EndpointToSchema</a>
--   instance.
--   
--   |
module Playground.Schema
endpointsToSchemas :: EndpointToSchema s => [FunctionSchema FormSchema]
class EndpointToSchema (s :: Row Type)
instance Playground.Schema.EndpointToSchema Data.Row.Internal.Empty
instance (Schema.ToSchema params, GHC.TypeLits.KnownSymbol label, Playground.Schema.EndpointToSchema ('Data.Row.Internal.R bs)) => Playground.Schema.EndpointToSchema ('Data.Row.Internal.R ((label 'Data.Row.Internal.:-> (Wallet.Types.EndpointValue params, Plutus.Contract.Effects.ActiveEndpoint)) : bs))

module Playground.TH
mkFunction :: Name -> Q [Dec]
mkFunctions :: [Name] -> Q [Dec]
ensureKnownCurrencies :: Q [Dec]
mkSchemaDefinitions :: Name -> Q [Dec]
mkSingleFunction :: Name -> Q [Dec]
mkKnownCurrencies :: [Name] -> Q [Dec]


-- | Re-export functions that are needed when creating a Contract for use
--   in the playground
module Playground.Contract
mkFunctions :: [Name] -> Q [Dec]
mkFunction :: Name -> Q [Dec]
endpointsToSchemas :: EndpointToSchema s => [FunctionSchema FormSchema]
ensureKnownCurrencies :: Q [Dec]
mkSchemaDefinitions :: Name -> Q [Dec]
mkKnownCurrencies :: [Name] -> Q [Dec]

-- | A description of a type, suitable for consumption by the Playground's
--   website.
--   
--   By calling <a>toSchema</a> on a type you get a description of its
--   structure. Semantically:
--   
--   <pre>
--   &gt;&gt;&gt; toSchema @Int
--   
--   &gt;&gt;&gt; -- returns, "this is an Int."
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; toSchema @SomeRecord
--   
--   &gt;&gt;&gt; -- returns, "this is a record, and it has
--   
--   &gt;&gt;&gt; -- these named fields with these types".
--   </pre>
--   
--   The description you get back is the <a>FormSchema</a> type, which
--   describes all the obvious primitives, plus some Plutus types deemed
--   worthy of special treatment (eg. <a>Value</a>).
--   
--   Internally it relies on <a>Generics</a> to extract the type
--   information, but the implementation jumps through some hoops because
--   generics is geared towards getting the type-description of a specific
--   value (eg. <tt>Left <a>Foo</a></tt> or <tt>Right 5</tt>) rather than
--   on the type itself (eg. <tt>Either String Int</tt>).
class ToSchema a

-- | The value-level equivalent of <a>ToSchema</a>. Where <a>ToSchema</a>
--   takes your type and returns a generic description of its structure,
--   <a>ToArgument</a> takes your value and returns an equivalent value
--   with a more generic structure. So semantially:
--   
--   The description you get back is the <a>FormArgument</a> type, which
--   describes all the obvious primitives, plus some Plutus types deemed
--   worthy of special treatment (eg. <a>Value</a>).
--   
--   <pre>
--   &gt;&gt;&gt; toSchema @User
--   
--   &gt;&gt;&gt; -- returns, "this is a record with a 'name' field, which is a String."
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; toArgument (User "Dave")
--   
--   &gt;&gt;&gt; -- returns, "this is a record with a 'name' field, which is a the String 'Dave'."
--   </pre>
class ToSchema a => ToArgument a

-- | A type that can be converted to JSON.
--   
--   Instances in general <i>must</i> specify <a>toJSON</a> and
--   <i>should</i> (but don't need to) specify <a>toEncoding</a>.
--   
--   An example type and instance:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>ToJSON</a> Coord where
--     <a>toJSON</a> (Coord x y) = <a>object</a> ["x" <a>.=</a> x, "y" <a>.=</a> y]
--   
--     <a>toEncoding</a> (Coord x y) = <tt>pairs</tt> ("x" <a>.=</a> x <a>&lt;&gt;</a> "y" <a>.=</a> y)
--   </pre>
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are two
--   options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>toJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>ToJSON</a> instance. If you
--   require nothing other than <a>defaultOptions</a>, it is sufficient to
--   write (and this is the only alternative where the default
--   <a>toJSON</a> implementation is sufficient):
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toEncoding</a> = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
--   
--   If on the other hand you wish to customize the generic decoding, you
--   have to implement both methods:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toJSON</a>     = <a>genericToJSON</a> customOptions
--       <a>toEncoding</a> = <a>genericToEncoding</a> customOptions
--   </pre>
--   
--   Previous versions of this library only had the <a>toJSON</a> method.
--   Adding <a>toEncoding</a> had two reasons:
--   
--   <ol>
--   <li>toEncoding is more efficient for the common case that the output
--   of <a>toJSON</a> is directly serialized to a <tt>ByteString</tt>.
--   Further, expressing either method in terms of the other would be
--   non-optimal.</li>
--   <li>The choice of defaults allows a smooth transition for existing
--   users: Existing instances that do not define <a>toEncoding</a> still
--   compile and have the correct semantics. This is ensured by making the
--   default implementation of <a>toEncoding</a> use <a>toJSON</a>. This
--   produces correct results, but since it performs an intermediate
--   conversion to a <a>Value</a>, it will be less efficient than directly
--   emitting an <a>Encoding</a>. (this also means that specifying nothing
--   more than <tt>instance ToJSON Coord</tt> would be sufficient as a
--   generically decoding instance, but there probably exists no good
--   reason to not specify <a>toEncoding</a> in new instances.)</li>
--   </ol>
class ToJSON a

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   In many cases, you can get the compiler to generate parsing code for
--   you (see below). To begin, let's cover writing an instance by hand.
--   
--   There are various reasons a conversion could fail. For example, an
--   <a>Object</a> could be missing a required key, an <a>Array</a> could
--   be of the wrong size, or a value could be of an incompatible type.
--   
--   The basic ways to signal a failed conversion are as follows:
--   
--   <ul>
--   <li><a>fail</a> yields a custom error message: it is the recommended
--   way of reporting a failure;</li>
--   <li><a>empty</a> (or <a>mzero</a>) is uninformative: use it when the
--   error is meant to be caught by some <tt>(<a>&lt;|&gt;</a>)</tt>;</li>
--   <li><a>typeMismatch</a> can be used to report a failure when the
--   encountered value is not of the expected JSON type; <a>unexpected</a>
--   is an appropriate alternative when more than one type may be expected,
--   or to keep the expected type implicit.</li>
--   </ul>
--   
--   <a>prependFailure</a> (or <a>modifyFailure</a>) add more information
--   to a parser's error messages.
--   
--   An example type and instance using <a>typeMismatch</a> and
--   <a>prependFailure</a>:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> (<a>Object</a> v) = Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   
--       -- We do not expect a non-<a>Object</a> value here.
--       -- We could use <a>empty</a> to fail, but <a>typeMismatch</a>
--       -- gives a much more informative error message.
--       <a>parseJSON</a> invalid    =
--           <a>prependFailure</a> "parsing Coord failed, "
--               (<a>typeMismatch</a> "Object" invalid)
--   </pre>
--   
--   For this common case of only being concerned with a single type of
--   JSON value, the functions <a>withObject</a>, <a>withScientific</a>,
--   etc. are provided. Their use is to be preferred when possible, since
--   they are more terse. Using <a>withObject</a>, we can rewrite the above
--   instance (assuming the same language extension and data type) as:
--   
--   <pre>
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>withObject</a> "Coord" $ \v -&gt; Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   </pre>
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   two options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>parseJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>FromJSON</a> instance for
--   your datatype without giving a definition for <a>parseJSON</a>.
--   
--   For example, the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>FromJSON</a> Coord
--   </pre>
--   
--   The default implementation will be equivalent to <tt>parseJSON =
--   <a>genericParseJSON</a> <a>defaultOptions</a></tt>; if you need
--   different options, you can customize the generic decoding by defining:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>genericParseJSON</a> customOptions
--   </pre>
class FromJSON a
data FunctionSchema a
data FormSchema

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a
printSchemas :: ([FunctionSchema FormSchema], [KnownCurrency]) -> IO ()
printJson :: ToJSON a => a -> IO ()

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data IO a

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | A wallet identifier
data Wallet
Wallet :: Maybe String -> WalletId -> Wallet
[prettyWalletName] :: Wallet -> Maybe String
[getWalletId] :: Wallet -> WalletId
data KnownCurrency
KnownCurrency :: ValidatorHash -> String -> NonEmpty TokenName -> KnownCurrency

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ValidatorHash
ValidatorHash :: BuiltinByteString -> ValidatorHash

-- | ByteString of a name of a token, shown as UTF-8 string when possible
newtype TokenName
TokenName :: BuiltinByteString -> TokenName

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|
adaCurrency :: KnownCurrency

-- | Expose an endpoint, return the data that was entered
endpoint :: forall (l :: Symbol) a w (s :: Row Type) e b. (HasEndpoint l a s, AsContractError e, FromJSON a) => (a -> Contract w s e b) -> Promise w s e b

-- | <tt>Contract w s e a</tt> is a contract with schema <tt>s</tt>,
--   producing a value of type <tt>a</tt> or an error <tt>e</tt>. See note
--   [Contract Schema].
data Contract w (s :: Row Type) e a
type Endpoint (l :: Symbol) a = l .== (EndpointValue a, ActiveEndpoint)
class AsContractError r

-- | Error produced while running a trace. Either a contract-specific error
--   (of type <tt>e</tt>), or an <a>AssertionError</a> from the emulator.
data TraceError e
TraceAssertionError :: AssertionError -> TraceError e
TContractError :: e -> TraceError e
HookError :: EndpointError -> TraceError e

-- | The minimum join of the two rows.
type family (l :: Row k) .\/ (r :: Row k) :: Row k
infixl 6 .\/

-- | <tt>interval a b</tt> includes all values that are greater than or
--   equal to <tt>a</tt> and smaller than or equal to <tt>b</tt>. Therefore
--   it includes <tt>a</tt> and <tt>b</tt>.
interval :: a -> a -> Interval a

-- | Get the hash of a public key belonging to the wallet that runs this
--   contract. * Any funds paid to this public key hash will be treated as
--   the wallet's own funds * The wallet is able to sign transactions with
--   the private key of this public key, for example, if the public key is
--   added to the <tt>requiredSignatures</tt> field of <tt>Tx</tt>. * There
--   is a 1-n relationship between wallets and public keys (although in the
--   mockchain n=1)
ownPaymentPubKeyHash :: forall w (s :: Row Type) e. AsContractError e => Contract w s e PaymentPubKeyHash
ownFirstPaymentPubKeyHash :: forall w (s :: Row Type) e. AsContractError e => Contract w s e PaymentPubKeyHash
ownPaymentPubKeyHashes :: forall w (s :: Row Type) e. AsContractError e => Contract w s e [PaymentPubKeyHash]

-- | Get the addresses belonging to the wallet that runs this contract. *
--   Any funds paid to one of these addresses will be treated as the
--   wallet's own funds * The wallet is able to sign transactions with the
--   private key of one of its public key, for example, if the public key
--   is added to the <tt>requiredSignatures</tt> field of <tt>Tx</tt>. *
--   There is a 1-n relationship between wallets and addresses (although in
--   the mockchain n=1)
ownAddresses :: forall w (s :: Row Type) e. AsContractError e => Contract w s e (NonEmpty CardanoAddress)

-- | Get the first address of the wallet that runs this contract.
ownAddress :: forall w (s :: Row Type) e. AsContractError e => Contract w s e CardanoAddress

-- | Wait until the slot
awaitSlot :: forall w (s :: Row Type) e. AsContractError e => Slot -> Contract w s e Slot

-- | Check whether every transaction that satisfies the constraints has to
--   modify the UTXO set.
modifiesUtxoSet :: TxConstraints i o -> Bool

-- | Get the unspent transaction outputs at an address.
utxosAt :: forall w (s :: Row Type) e. AsContractError e => CardanoAddress -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Wait until the target slot and get the unspent transaction outputs at
--   an address.
watchAddressUntilSlot :: forall w (s :: Row Type) e. AsContractError e => CardanoAddress -> Slot -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. The constraints do not refer to any typed script inputs
--   or outputs.
submitTx :: forall w (s :: Row Type) e. AsContractError e => TxConstraints Void Void -> Contract w s e CardanoTx

-- | A Babbage-era transaction, including witnesses for its inputs.
data Tx

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
type Expression = ContractCall Value

module Servant.Extra
left :: (a :<|> b) -> a
right :: (a :<|> b) -> b

module Gist
type API = Header "Authorization" (Token 'Github) :> "gists" :> GistAPI
type GistAPI = Get '[JSON] [Gist] :<|> ReqBody '[JSON] NewGist :> Post '[JSON] Gist :<|> Capture "GistId" GistId :> Get '[JSON] Gist :<|> Capture "GistId" GistId :> ReqBody '[JSON] NewGist :> Post '[JSON] Gist
getGists :: Maybe (Token 'Github) -> ClientM [Gist]
createNewGist :: Maybe (Token 'Github) -> NewGist -> ClientM Gist
getGist :: Maybe (Token 'Github) -> GistId -> ClientM Gist
updateGist :: Maybe (Token 'Github) -> GistId -> NewGist -> ClientM Gist
data Owner
Owner :: !Text -> !Text -> Owner
[_ownerLogin] :: Owner -> !Text
[_ownerHtmlUrl] :: Owner -> !Text
newtype GistId
GistId :: Text -> GistId
data Gist
Gist :: !GistId -> !Text -> !Text -> !Owner -> !Map String GistFile -> !Bool -> !String -> !String -> !String -> Gist
[_gistId] :: Gist -> !GistId
[_gistGitPushUrl] :: Gist -> !Text
[_gistHtmlUrl] :: Gist -> !Text
[_gistOwner] :: Gist -> !Owner
[_gistFiles] :: Gist -> !Map String GistFile
[_gistTruncated] :: Gist -> !Bool
[_gistCreatedAt] :: Gist -> !String
[_gistUpdatedAt] :: Gist -> !String
[_gistDescription] :: Gist -> !String
data GistFile
GistFile :: !Text -> !Maybe Text -> !Text -> !Maybe Bool -> !Maybe Text -> GistFile
[_gistFileFilename] :: GistFile -> !Text
[_gistFileLanguage] :: GistFile -> !Maybe Text
[_gistFileType] :: GistFile -> !Text
[_gistFileTruncated] :: GistFile -> !Maybe Bool
[_gistFileContent] :: GistFile -> !Maybe Text
data NewGist
NewGist :: !Text -> !Bool -> ![NewGistFile] -> NewGist
[_newGistDescription] :: NewGist -> !Text
[_newGistPublic] :: NewGist -> !Bool
[_newGistFiles] :: NewGist -> ![NewGistFile]
data NewGistFile
NewGistFile :: !Text -> !Text -> NewGistFile
[_newGistFilename] :: NewGistFile -> !Text
[_newGistFileContent] :: NewGistFile -> !Text
instance Data.Aeson.Types.ToJSON.ToJSON Gist.Owner
instance GHC.Generics.Generic Gist.Owner
instance GHC.Classes.Eq Gist.Owner
instance GHC.Show.Show Gist.Owner
instance Data.Aeson.Types.FromJSON.FromJSON Gist.NewGistFile
instance GHC.Generics.Generic Gist.NewGistFile
instance GHC.Classes.Eq Gist.NewGistFile
instance GHC.Show.Show Gist.NewGistFile
instance Data.Aeson.Types.FromJSON.FromJSON Gist.NewGist
instance GHC.Generics.Generic Gist.NewGist
instance GHC.Classes.Eq Gist.NewGist
instance GHC.Show.Show Gist.NewGist
instance Data.Aeson.Types.ToJSON.ToJSON Gist.GistId
instance Data.Aeson.Types.FromJSON.FromJSON Gist.GistId
instance GHC.Generics.Generic Gist.GistId
instance GHC.Classes.Ord Gist.GistId
instance GHC.Classes.Eq Gist.GistId
instance GHC.Show.Show Gist.GistId
instance Data.Aeson.Types.ToJSON.ToJSON Gist.GistFile
instance GHC.Generics.Generic Gist.GistFile
instance GHC.Classes.Eq Gist.GistFile
instance GHC.Show.Show Gist.GistFile
instance Data.Aeson.Types.ToJSON.ToJSON Gist.Gist
instance GHC.Generics.Generic Gist.Gist
instance GHC.Classes.Eq Gist.Gist
instance GHC.Show.Show Gist.Gist
instance Data.Aeson.Types.FromJSON.FromJSON Gist.Gist
instance Data.Aeson.Types.FromJSON.FromJSON Gist.GistFile
instance Web.Internal.HttpApiData.ToHttpApiData Gist.GistId
instance Web.Internal.HttpApiData.FromHttpApiData Gist.GistId
instance Data.Aeson.Types.ToJSON.ToJSON Gist.NewGist
instance Data.Aeson.Types.FromJSON.FromJSON Gist.Owner

module Auth

-- | We split out the API here because we don't want the Github Callback to
--   be exported for the frontend to call directly.
type API = FrontendAPI :<|> CallbackAPI
type FrontendAPI = ("oauth" :> (BrowserHeader "Cookie" Text :> "status" :> Get '[JSON] AuthStatus :<|> "github" :> GetRedirect (Headers '[Header "Location" Text]))) :<|> (BrowserHeader "Cookie" Text :> "gists" :> GistAPI)
server :: (MonadNow m, MonadWeb m, MonadLogger m, MonadError ServerError m, MonadIO m, MonadReader Env m) => ServerT API m
data AuthStatus
data AuthRole

-- | Config supplied at runtime.
data Config
Config :: !EncodeSigner -> !Text -> !Text -> !OAuthClientId -> !OAuthClientSecret -> Config
[_configJWTSignature] :: Config -> !EncodeSigner
[_configFrontendUrl] :: Config -> !Text
[_configGithubCbPath] :: Config -> !Text
[_configGithubClientId] :: Config -> !OAuthClientId
[_configGithubClientSecret] :: Config -> !OAuthClientSecret
configJWTSignature :: Lens' Config EncodeSigner
configFrontendUrl :: Lens' Config Text
configGithubCbPath :: Lens' Config Text
configGithubClientId :: Lens' Config OAuthClientId
configGithubClientSecret :: Lens' Config OAuthClientSecret
data GithubEndpoints

-- | Config determined by Github.
mkGithubEndpoints :: IO GithubEndpoints
githubEndpointsAuthLocation :: Lens' GithubEndpoints Request
githubEndpointsAccessTokenLocation :: Lens' GithubEndpoints Request
githubEndpointsApiBaseUrl :: Lens' GithubEndpoints BaseUrl
githubEndpointsCallbackUri :: Lens' GithubEndpoints Text
instance Data.Aeson.Types.FromJSON.FromJSON Auth.Config
instance Data.Aeson.Types.ToJSON.ToJSON Auth.AuthRole
instance Data.Aeson.Types.FromJSON.FromJSON Auth.AuthRole
instance GHC.Generics.Generic Auth.AuthRole
instance GHC.Classes.Eq Auth.AuthRole
instance GHC.Show.Show Auth.AuthRole
instance Data.Aeson.Types.ToJSON.ToJSON Auth.AuthStatus
instance Data.Aeson.Types.FromJSON.FromJSON Auth.AuthStatus
instance GHC.Generics.Generic Auth.AuthStatus
instance GHC.Classes.Eq Auth.AuthStatus
instance GHC.Show.Show Auth.AuthStatus

module PSGenerator.Common
psJson :: PSType
psNonEmpty :: MonadReader BridgeData m => m PSType
psSet :: MonadReader BridgeData m => m PSType
psUUID :: PSType
uuidBridge :: BridgePart
aesonValueBridge :: BridgePart
aesonBridge :: BridgePart
nonEmptyBridge :: BridgePart
setBridge :: BridgePart
containersBridge :: BridgePart
psBigInteger :: PSType
integerBridge :: BridgePart
word32Bridge :: BridgePart
word64Bridge :: BridgePart
digestBridge :: BridgePart
byteStringBridge :: BridgePart
bultinByteStringBridge :: BridgePart
scientificBridge :: BridgePart
naturalBridge :: BridgePart
satIntBridge :: BridgePart
exBudgetBridge :: BridgePart
identityBridge :: BridgePart
someCardanoApiTxBridge :: BridgePart
cardanoBuildTxBridge :: BridgePart
alonzoEraBridge :: BridgePart
babbageEraBridge :: BridgePart
babbagePParamsEraBridge :: BridgePart
standardCryptoBridge :: BridgePart
applyTxErrorBridge :: BridgePart
basicFailureBridge :: BridgePart
scriptFailureBridge :: BridgePart
utxosPredicateFailureBridge :: BridgePart
exportTxBridge :: BridgePart
protocolParametersBridge :: BridgePart
miscBridge :: BridgePart
psAssocMap :: MonadReader BridgeData m => m PSType
dataBridge :: BridgePart
assocMapBridge :: BridgePart
languageBridge :: BridgePart
scriptHashBridge :: BridgePart
scriptBridge :: BridgePart
datumBridge :: BridgePart
redeemerHashBridge :: BridgePart
redeemerBridge :: BridgePart
validatorHashBridge :: BridgePart
mpsHashBridge :: BridgePart
stakeValidatorHashBridge :: BridgePart
ledgerBytesBridge :: BridgePart
walletIdBridge :: BridgePart
ledgerBridge :: BridgePart
headersBridge :: BridgePart
headerBridge :: BridgePart
servantBridge :: BridgePart
scriptAnyLangType :: SumType 'Haskell
plutusTxOut :: SumType 'Haskell
cardanoTxOut :: SumType 'Haskell
txOut :: SumType 'Haskell
ledgerTypes :: [SumType 'Haskell]
walletTypes :: [SumType 'Haskell]
playgroundTypes :: [SumType 'Haskell]

-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/plutus-apps#readme</a>
@package plutus-chain-index
@version 1.1.0.0

module Plutus.ChainIndex.Config
data ChainIndexConfig
ChainIndexConfig :: String -> String -> Int -> NetworkId -> Int -> SlotConfig -> BlockNo -> Natural -> ChainIndexConfig
[cicSocketPath] :: ChainIndexConfig -> String
[cicDbPath] :: ChainIndexConfig -> String
[cicPort] :: ChainIndexConfig -> Int
[cicNetworkId] :: ChainIndexConfig -> NetworkId

-- | The number of blocks after which a transaction cannot be rolled back
--   anymore
[cicSecurityParam] :: ChainIndexConfig -> Int
[cicSlotConfig] :: ChainIndexConfig -> SlotConfig

-- | Only store transactions from this block number onward
[cicStoreFrom] :: ChainIndexConfig -> BlockNo

-- | The size of the queue and a number of transactions to collect before
--   writing to the database
[cicAppendTransactionQueueSize] :: ChainIndexConfig -> Natural
newtype DecodeConfigException
DecodeConfigException :: String -> DecodeConfigException

-- | These settings work with the main testnet
defaultConfig :: ChainIndexConfig
socketPath :: Lens' ChainIndexConfig String
dbPath :: Lens' ChainIndexConfig String
port :: Lens' ChainIndexConfig Int
networkId :: Lens' ChainIndexConfig NetworkId
securityParam :: Lens' ChainIndexConfig Int
slotConfig :: Lens' ChainIndexConfig SlotConfig
storeFrom :: Lens' ChainIndexConfig BlockNo
appendTransactionQueueSize :: Lens' ChainIndexConfig Natural
instance GHC.Exception.Type.Exception Plutus.ChainIndex.Config.DecodeConfigException
instance GHC.Show.Show Plutus.ChainIndex.Config.DecodeConfigException
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.ChainIndex.Config.ChainIndexConfig
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.ChainIndex.Config.ChainIndexConfig
instance GHC.Generics.Generic Plutus.ChainIndex.Config.ChainIndexConfig
instance GHC.Classes.Eq Plutus.ChainIndex.Config.ChainIndexConfig
instance GHC.Show.Show Plutus.ChainIndex.Config.ChainIndexConfig
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Api.NetworkId.NetworkId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.NetworkId.NetworkId
instance Data.Aeson.Types.FromJSON.FromJSON Ouroboros.Network.Magic.NetworkMagic
instance Data.Aeson.Types.ToJSON.ToJSON Ouroboros.Network.Magic.NetworkMagic
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Slotting.Block.BlockNo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Slotting.Block.BlockNo
instance Prettyprinter.Internal.Pretty Plutus.ChainIndex.Config.ChainIndexConfig

module Plutus.ChainIndex.CommandLine
data AppConfig
AppConfig :: Maybe FilePath -> Maybe Severity -> Maybe FilePath -> CLIConfigOverrides -> Command -> AppConfig
[acLogConfigPath] :: AppConfig -> Maybe FilePath
[acMinLogLevel] :: AppConfig -> Maybe Severity
[acConfigPath] :: AppConfig -> Maybe FilePath
[acCLIConfigOverrides] :: AppConfig -> CLIConfigOverrides
[acCommand] :: AppConfig -> Command

-- | Configuration
data Command

-- | Write default chain index configuration
DumpDefaultConfig :: !FilePath -> Command
[dumpConfigPath] :: Command -> !FilePath

-- | Write default logging configuration
DumpDefaultLoggingConfig :: !FilePath -> Command
[dumpLoggingConfigPath] :: Command -> !FilePath

-- | Start the chain index and connect it to a cardano node
StartChainIndex :: Command
data CLIConfigOverrides
CLIConfigOverrides :: Maybe String -> Maybe String -> Maybe Int -> Maybe Word32 -> Maybe Natural -> CLIConfigOverrides
[ccSocketPath] :: CLIConfigOverrides -> Maybe String
[ccDbPath] :: CLIConfigOverrides -> Maybe String
[ccPort] :: CLIConfigOverrides -> Maybe Int
[ccNetworkId] :: CLIConfigOverrides -> Maybe Word32
[ccAppendTransactionQueueSize] :: CLIConfigOverrides -> Maybe Natural

-- | Apply the CLI soverrides to the <a>ChainIndexConfig</a>
applyOverrides :: CLIConfigOverrides -> ChainIndexConfig -> ChainIndexConfig
cmdWithHelpParser :: ParserInfo AppConfig
instance GHC.Show.Show Plutus.ChainIndex.CommandLine.CLIConfigOverrides
instance GHC.Classes.Ord Plutus.ChainIndex.CommandLine.CLIConfigOverrides
instance GHC.Classes.Eq Plutus.ChainIndex.CommandLine.CLIConfigOverrides
instance GHC.Show.Show Plutus.ChainIndex.CommandLine.Command
instance GHC.Show.Show Plutus.ChainIndex.CommandLine.AppConfig

module Plutus.ChainIndex.Logging

-- | Logging (definitions from Plutus.PAB.Monitoring.Config)
--   
--   A default <a>Configuration</a> that logs on <a>Info</a> and above to
--   stdout
defaultConfig :: IO Configuration

-- | Load a <a>Configuration</a> from a YAML file.
loadConfig :: FilePath -> IO Configuration


-- | Using the chain index as a library.
--   
--   A minimal example that just syncs the chain index:
--   
--   <pre>
--   <a>withDefaultRunRequirements</a> $ runReq -&gt; do
--   
--       syncHandler &lt;- <tt>defaultChainSyncHandler</tt> runReq
--   
--       <a>syncChainIndex</a> <tt>defaultConfig</tt> runReq syncHandler
--   
--       void getLine
--   </pre>
module Plutus.ChainIndex.Lib

-- | The required arguments to run the chain index effects.
data RunRequirements
RunRequirements :: Trace IO (PrettyObject ChainIndexLog) -> TVar ChainIndexState -> Pool Connection -> Int -> RunRequirements
[trace] :: RunRequirements -> Trace IO (PrettyObject ChainIndexLog)
[stateTVar] :: RunRequirements -> TVar ChainIndexState
[pool] :: RunRequirements -> Pool Connection
[securityParam] :: RunRequirements -> Int

-- | Generate the requirements to run the chain index effects given logging
--   configuration and chain index configuration.
withRunRequirements :: Configuration -> ChainIndexConfig -> (RunRequirements -> IO ()) -> IO ()

-- | Generate the requirements to run the chain index effects given default
--   configurations.
withDefaultRunRequirements :: (RunRequirements -> IO ()) -> IO ()

-- | The default logging configuration.
defaultLoggingConfig :: IO Configuration

-- | These settings work with the main testnet
defaultConfig :: ChainIndexConfig

-- | Handle the chain index effects from the set of all effects.
handleChainIndexEffects :: forall (effs :: [Type -> Type]) a. (LastMember IO effs, Member (LogMsg ChainIndexLog) effs) => RunRequirements -> Eff (ChainIndexQueryEffect : (ChainIndexControlEffect : (BeamEffect Sqlite : effs))) a -> Eff effs (Either ChainIndexError a)

-- | Run the chain index effects.
runChainIndexEffects :: RunRequirements -> Eff '[ChainIndexQueryEffect, ChainIndexControlEffect, BeamEffect Sqlite] a -> IO (Either ChainIndexError a)

-- | Synchronise the chain index with the node using the given handler.
syncChainIndex :: ChainIndexConfig -> RunRequirements -> ChainSyncHandler -> IO ()

-- | A handler for chain synchronisation events.
type ChainSyncHandler = ChainSyncEvent -> IO ()

-- | Chain synchronisation events.
data ChainSyncEvent

-- | Resume from the given point
Resume :: Point -> ChainSyncEvent

-- | Append the given block. The tip is the current tip of the node, which
--   is newer than the tip of the block during syncing.
RollForward :: ChainSyncBlock -> Tip -> ChainSyncEvent

-- | Roll back to the given point. The tip is current tip of the node.
RollBackward :: Point -> Tip -> ChainSyncEvent
type EventsQueue = TBMQueue ChainSyncEvent
storeChainSyncHandler :: EventsQueue -> ChainSyncHandler

-- | Changes the given <tt>ChainSyncHandler</tt> to only store transactions
--   with a block number no smaller than the given one.
storeFromBlockNo :: BlockNumber -> ChainSyncHandler -> ChainSyncHandler

-- | Changes the given <tt>ChainSyncHandler</tt> to only process and store
--   certain transactions.
filterTxs :: (ChainIndexTx -> Bool) -> (ChainIndexTx -> Bool) -> ChainSyncHandler -> ChainSyncHandler
runChainIndexDuringSync :: RunRequirements -> Eff '[ChainIndexQueryEffect, ChainIndexControlEffect, BeamEffect Sqlite] a -> IO (Maybe a)

-- | Get the slot number of the current tip of the node.
getTipSlot :: ChainIndexConfig -> IO (Maybe SlotNo)
instance GHC.Show.Show Plutus.ChainIndex.Lib.ChainSyncEvent

module Plutus.ChainIndex.SyncStats
data SyncStats
SyncStats :: Integer -> Integer -> Point -> Point -> SyncStats

-- | Number of applied blocks
[syncStatsAppliedBlocks] :: SyncStats -> Integer

-- | Number of rollbacks
[syncStatsAppliedRollbacks] :: SyncStats -> Integer

-- | Chain index syncing tip
[syncStatsChainSyncPoint] :: SyncStats -> Point

-- | Current tip of the node
[syncStatsNodePoint] :: SyncStats -> Point
data SyncLog
SyncLog :: SyncState -> SyncStats -> Second -> SyncLog

-- | State of the syncing
[syncStateSyncLog] :: SyncLog -> SyncState

-- | Stats of the syncing
[syncStatsSyncLog] :: SyncLog -> SyncStats

-- | Period in seconds used to accumulate log events
[syncPeriodSyncLog] :: SyncLog -> Second
data SyncState
Synced :: SyncState
Syncing :: Double -> SyncState
NotSyncing :: SyncState
isSyncStateSynced :: SyncState -> Bool
isSyncStateNotSyncing :: SyncState -> Bool
isSyncStateSyncing :: SyncState -> Bool

-- | Log syncing summary.
logProgress :: forall effs. Member (LogMsg SyncLog) effs => [ChainSyncEvent] -> TimeSpec -> Eff effs ()

-- | Get the <a>SyncState</a> for a <a>SyncState</a>.
--   
--   TODO: The syncing percentage is valid when the node is already fully
--   synced. But when the node and chain-index are started at the same
--   time, the syncing percentage is not a valid number considering the
--   actual tip of the node. Find a better way to calculate this
--   percentage.
getSyncStateFromStats :: SyncStats -> SyncState
getSyncState :: Point -> Point -> SyncState
convertEventToSyncStats :: ChainSyncEvent -> SyncStats
instance Cardano.BM.Data.Tracer.ToObject Plutus.ChainIndex.SyncStats.SyncStats
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.ChainIndex.SyncStats.SyncStats
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.ChainIndex.SyncStats.SyncStats
instance GHC.Generics.Generic Plutus.ChainIndex.SyncStats.SyncStats
instance GHC.Show.Show Plutus.ChainIndex.SyncStats.SyncStats
instance GHC.Classes.Eq Plutus.ChainIndex.SyncStats.SyncStats
instance Cardano.BM.Data.Tracer.ToObject Plutus.ChainIndex.SyncStats.SyncState
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.ChainIndex.SyncStats.SyncState
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.ChainIndex.SyncStats.SyncState
instance GHC.Generics.Generic Plutus.ChainIndex.SyncStats.SyncState
instance GHC.Show.Show Plutus.ChainIndex.SyncStats.SyncState
instance GHC.Classes.Eq Plutus.ChainIndex.SyncStats.SyncState
instance Cardano.BM.Data.Tracer.ToObject Plutus.ChainIndex.SyncStats.SyncLog
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.ChainIndex.SyncStats.SyncLog
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.ChainIndex.SyncStats.SyncLog
instance GHC.Generics.Generic Plutus.ChainIndex.SyncStats.SyncLog
instance GHC.Show.Show Plutus.ChainIndex.SyncStats.SyncLog
instance GHC.Classes.Eq Plutus.ChainIndex.SyncStats.SyncLog
instance Prettyprinter.Internal.Pretty Plutus.ChainIndex.SyncStats.SyncLog
instance Prettyprinter.Internal.Pretty Plutus.ChainIndex.SyncStats.SyncState
instance GHC.Base.Semigroup Plutus.ChainIndex.SyncStats.SyncStats
instance GHC.Base.Monoid Plutus.ChainIndex.SyncStats.SyncStats

module Plutus.ChainIndex.Events

-- | How often do we check the queue
period :: Int

-- | We estimate the size of the event with the number of the transactions
--   in the block. By doing this we accumulate some number of blocks but
--   with less than <tt>queueSize</tt> number of transactions. This
--   approach helps to process blocks with a constant memory usage.
--   
--   However, once we are in sync with the node, we want to process every
--   block instead of batches of blocks so that we can update the database
--   as frequently as possible.
--   
--   Just accumulating <tt>queueSize</tt> blocks doesn't work as a block
--   can have any number of transactions. It works fine at the beginning of
--   the chain but later blocks grow in their size and the memory usage
--   grows tremendously.
measureEventQueueSizeByTxs :: Natural -> ChainSyncEvent -> Natural

-- | <a>processEventsQueue</a> reads events from <tt>TBQueue</tt>, collects
--   enough <a>RollForward</a>s to append blocks at once.
processEventsQueue :: Trace IO (PrettyObject SyncLog) -> RunRequirements -> EventsQueue -> IO ()


-- | Main entry points to the chain index.
module Plutus.ChainIndex.App
main :: IO ()
runMain :: Configuration -> ChainIndexConfig -> IO ()
runMainWithLog :: (String -> IO ()) -> Configuration -> ChainIndexConfig -> IO ()

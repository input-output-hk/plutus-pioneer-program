-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/plutus-apps#readme</a>
@package plutus-contract
@version 1.1.0.0


-- | Instances for <a>Rec</a> and <a>Var</a> types
module Data.Row.Extras
newtype JsonRec s
JsonRec :: Rec s -> JsonRec s
[unJsonRec] :: JsonRec s -> Rec s
newtype JsonVar s
JsonVar :: Var s -> JsonVar s
[unJsonVar] :: JsonVar s -> Var s

-- | Parse a 'Var s' from JSON if the label of the branch is known.
namedBranchFromJSON :: forall s. (AllUniqueLabels s, Forall s FromJSON) => String -> Value -> Parser (Var s)

-- | Fast diff. The implementation in row-types is exponential in time and
--   memory in the number of overlapping rows, due to limitations in ghc's
--   handling of type families. This version is much faster.
--   
--   Type level Row difference. That is, <tt>l <a>.\\</a> r</tt> is the row
--   remaining after removing any matching elements of <tt>r</tt> from
--   <tt>l</tt>.
type family (l :: Row k) .\\ (r :: Row k) :: Row k
infixl 6 .\\
instance Data.Row.Internal.Forall s Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Data.Row.Extras.JsonRec s)
instance (Data.Row.Internal.AllUniqueLabels s, Data.Row.Internal.Forall s Data.Aeson.Types.FromJSON.FromJSON) => Data.Aeson.Types.FromJSON.FromJSON (Data.Row.Extras.JsonRec s)
instance (Data.Row.Internal.AllUniqueLabels s, Data.Row.Internal.Forall s Data.Aeson.Types.FromJSON.FromJSON) => Data.Aeson.Types.FromJSON.FromJSON (Data.Row.Extras.JsonVar s)
instance Data.Row.Internal.Forall s Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Data.Row.Extras.JsonVar s)

module Data.Text.Extras
abbreviate :: Int -> Text -> Text
tshow :: Show a => a -> Text

module Data.UUID.Extras
isValidVersion :: Int -> UUID -> Bool

-- | A pure list of UUIDs that can be used in testing. This is _almost_ a
--   sequence counting up from zero, but we ensure that the version and
--   variant numbers are correctly set so the resulting UUIDs validate.
mockUUIDs :: [UUID]

-- | Given a UUID from <a>mockUUIDs</a>, returns a simple sequence number.
--   Returns <a>Nothing</a> if your UUID doesn't seem to come from that
--   sequence. As the name suggests, you should really only be using this
--   for mocking/testing.
mockUUIDToSequenceId :: UUID -> Maybe Word32

-- | Create a UUID that can be used in testing, from a simple
--   <a>Word32</a>. Reminder: Use 'fromIntegral i' to call it with an
--   <a>Int</a>.
sequenceIdToMockUUID :: Word32 -> UUID

module Plutus.Contract.Checkpoint
data Checkpoint r
[DoCheckpoint] :: Checkpoint ()
[AllocateKey] :: Checkpoint CheckpointKey
[Store] :: ToJSON a => CheckpointKey -> CheckpointKey -> a -> Checkpoint ()
[Retrieve] :: FromJSON a => CheckpointKey -> Checkpoint (Either CheckpointError (Maybe a))
data CheckpointError
JSONDecodeError :: Text -> CheckpointError
class AsCheckpointError r_aQsK
_CheckpointError :: AsCheckpointError r_aQsK => Prism' r_aQsK CheckpointError
_JSONDecodeError :: AsCheckpointError r_aQsK => Prism' r_aQsK Text
newtype CheckpointStore
CheckpointStore :: Map CheckpointKey (CheckpointStoreItem Value) -> CheckpointStore
[unCheckpointStore] :: CheckpointStore -> Map CheckpointKey (CheckpointStoreItem Value)
data CheckpointStoreItem a
CheckpointStoreItem :: a -> CheckpointKey -> CheckpointStoreItem a
[csValue] :: CheckpointStoreItem a -> a
[csNewKey] :: CheckpointStoreItem a -> CheckpointKey
data CheckpointKey
data CheckpointLogMsg
LogFoundValueRestoringKey :: CheckpointKey -> CheckpointLogMsg
LogDecodingErrorAtKey :: CheckpointKey -> CheckpointLogMsg
LogNoValueForKey :: CheckpointKey -> CheckpointLogMsg
LogDoCheckpoint :: CheckpointLogMsg
LogAllocateKey :: CheckpointLogMsg
LogRetrieve :: CheckpointKey -> CheckpointLogMsg
LogStore :: CheckpointKey -> CheckpointKey -> CheckpointLogMsg
LogKeyUpdate :: CheckpointKey -> CheckpointKey -> CheckpointLogMsg

-- | Create a checkpoint for an action. <tt>handleCheckpoint
--   (jsonCheckpoint action)</tt> will
--   
--   <ul>
--   <li>Obtain a <a>CheckpointKey</a> that identifies the position of the
--   current checkpoint in the program</li>
--   <li>Run <tt>action</tt>, convert its result to JSON and store it in
--   the checkpoint store if there is no value at the key</li>
--   <li>Retrieve the result as a JSON value from the store, parse it, and
--   return it *instead* of running <tt>action</tt> if there is a value at
--   the key.</li>
--   </ul>
jsonCheckpoint :: forall err a effs. (Member Checkpoint effs, Member (Error err) effs, ToJSON a, FromJSON a, AsCheckpointError err) => Eff effs a -> Eff effs a
jsonCheckpointLoop :: forall err a b effs. (Member Checkpoint effs, Member (Error err) effs, ToJSON a, FromJSON a, ToJSON b, FromJSON b, AsCheckpointError err) => (a -> Eff effs (Either b a)) -> a -> Eff effs b

-- | Handle the <a>Checkpoint</a> effect in terms of <a>CheckpointStore</a>
--   and <a>CheckpointKey</a> states.
handleCheckpoint :: forall effs. (Member (State CheckpointStore) effs, Member (State CheckpointKey) effs, Member (LogMsg CheckpointLogMsg) effs) => Eff (Checkpoint : effs) ~> Eff effs

-- | Intervals of checkpoint keys that are completely covered by the
--   checkpoint store.
completedIntervals :: CheckpointStore -> IntervalSet (Interval CheckpointKey)

-- | The maximum key that is present in the store
maxKey :: CheckpointStore -> Maybe CheckpointKey
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance Data.Traversable.Traversable Plutus.Contract.Checkpoint.CheckpointStoreItem
instance Data.Foldable.Foldable Plutus.Contract.Checkpoint.CheckpointStoreItem
instance GHC.Base.Functor Plutus.Contract.Checkpoint.CheckpointStoreItem
instance GHC.Generics.Generic (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance GHC.Base.Monoid Plutus.Contract.Checkpoint.CheckpointStore
instance GHC.Base.Semigroup Plutus.Contract.Checkpoint.CheckpointStore
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Checkpoint.CheckpointStore
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Checkpoint.CheckpointStore
instance GHC.Generics.Generic Plutus.Contract.Checkpoint.CheckpointStore
instance GHC.Show.Show Plutus.Contract.Checkpoint.CheckpointStore
instance GHC.Classes.Eq Plutus.Contract.Checkpoint.CheckpointStore
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Checkpoint.CheckpointLogMsg
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Checkpoint.CheckpointLogMsg
instance GHC.Generics.Generic Plutus.Contract.Checkpoint.CheckpointLogMsg
instance GHC.Show.Show Plutus.Contract.Checkpoint.CheckpointLogMsg
instance GHC.Classes.Ord Plutus.Contract.Checkpoint.CheckpointLogMsg
instance GHC.Classes.Eq Plutus.Contract.Checkpoint.CheckpointLogMsg
instance Prettyprinter.Internal.Pretty Plutus.Contract.Checkpoint.CheckpointLogMsg
instance Prettyprinter.Internal.Pretty Plutus.Contract.Checkpoint.CheckpointStore
instance Plutus.Contract.Checkpoint.AsCheckpointError Plutus.Contract.Checkpoint.CheckpointError
instance Prettyprinter.Internal.Pretty Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Enum.Enum Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Num.Num Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Generics.Generic Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Show.Show Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Classes.Ord Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Classes.Eq Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Checkpoint.CheckpointError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Checkpoint.CheckpointError
instance GHC.Generics.Generic Plutus.Contract.Checkpoint.CheckpointError
instance GHC.Show.Show Plutus.Contract.Checkpoint.CheckpointError
instance GHC.Classes.Ord Plutus.Contract.Checkpoint.CheckpointError
instance GHC.Classes.Eq Plutus.Contract.Checkpoint.CheckpointError
instance Prettyprinter.Internal.Pretty Plutus.Contract.Checkpoint.CheckpointError

module Plutus.Contract.Constraints

module Plutus.Contract.Oracle

-- | A value that was observed at a specific point in time
data Observation a
Observation :: a -> POSIXTime -> Observation a

-- | The value
[obsValue] :: Observation a -> a

-- | The time at which the value was observed
[obsTime] :: Observation a -> POSIXTime

-- | <tt>SignedMessage a</tt> contains the signature of a hash of a
--   <a>Datum</a>. The <a>Datum</a> can be decoded to a value of type
--   <tt>a</tt>.
data SignedMessage a
SignedMessage :: Signature -> DatumHash -> Datum -> SignedMessage a

-- | Signature of the message
[osmSignature] :: SignedMessage a -> Signature

-- | Hash of the message
[osmMessageHash] :: SignedMessage a -> DatumHash
[osmDatum] :: SignedMessage a -> Datum
data SignedMessageCheckError

-- | The signature did not match the public key
SignatureMismatch :: Signature -> PaymentPubKey -> DatumHash -> SignedMessageCheckError

-- | The datum was missing from the pending transaction
DatumMissing :: DatumHash -> SignedMessageCheckError

-- | The datum had the wrong shape
DecodingError :: SignedMessageCheckError

-- | The datum that corresponds to the hash is wrong
DatumNotEqualToExpected :: SignedMessageCheckError

-- | Verify the signature on a signed datum hash
checkSignature :: DatumHash -> PaymentPubKey -> Signature -> Either SignedMessageCheckError ()

-- | Extract the contents of the message and produce a constraint that
--   checks that the hash is correct. In off-chain code, where we check the
--   hash straightforwardly, <a>checkHashOffChain</a> can be used instead
--   of this.
checkHashConstraints :: FromData a => SignedMessage a -> Either SignedMessageCheckError (a, TxConstraints i o)

-- | The off-chain version of <a>checkHashConstraints</a>, using the hash
--   function directly instead of obtaining the hash from a
--   <a>ScriptContext</a> value
checkHashOffChain :: FromData a => SignedMessage a -> Either SignedMessageCheckError a

-- | Check the signature on a <a>SignedMessage</a> and extract the contents
--   of the message.
verifySignedMessageOffChain :: FromData a => PaymentPubKey -> SignedMessage a -> Either SignedMessageCheckError a

-- | Check the signature on a <a>SignedMessage</a> and extract the contents
--   of the message, using the pending transaction in lieu of a hash
--   function. See <a>verifySignedMessageConstraints</a> for a version that
--   does not require a <a>ScriptContext</a> value.
verifySignedMessageOnChain :: FromData a => ScriptContext -> PaymentPubKey -> SignedMessage a -> Either SignedMessageCheckError a

-- | Check the signature on a <a>SignedMessage</a> and extract the contents
--   of the message, producing a <tt>TxConstraint</tt> value that ensures
--   the hashes match up.
verifySignedMessageConstraints :: FromData a => PaymentPubKey -> SignedMessage a -> Either SignedMessageCheckError (a, TxConstraints i o)

-- | Encode a message of type <tt>a</tt> as a <tt>Data</tt> value and sign
--   the hash of the datum.
signMessage :: ToData a => a -> PaymentPrivateKey -> Passphrase -> SignedMessage a

-- | Encode an observation of a value of type <tt>a</tt> that was made at
--   the given time
signObservation :: ToData a => POSIXTime -> a -> PaymentPrivateKey -> Passphrase -> SignedMessage (Observation a)

-- | Encode a message of type <tt>a</tt> as a <tt>Data</tt> value and sign
--   the hash of the datum.
signMessage' :: ToData a => a -> XPrv -> SignedMessage a

-- | Encode an observation of a value of type <tt>a</tt> that was made at
--   the given time
signObservation' :: ToData a => POSIXTime -> a -> XPrv -> SignedMessage (Observation a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.Contract.Oracle.Observation a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.Contract.Oracle.Observation a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.Contract.Oracle.Observation a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contract.Oracle.Observation
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni a) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contract.Oracle.Observation a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.Contract.Oracle.SignedMessage a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.Contract.Oracle.SignedMessage a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.Contract.Oracle.SignedMessage a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contract.Oracle.SignedMessage
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contract.Oracle.SignedMessage a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.Contract.Oracle.Observation a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contract.Oracle.Observation a)
instance GHC.Generics.Generic (Plutus.Contract.Oracle.Observation a)
instance Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Oracle.SignedMessage a)
instance Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Oracle.SignedMessage a)
instance GHC.Classes.Eq (Plutus.Contract.Oracle.SignedMessage a)
instance GHC.Show.Show (Plutus.Contract.Oracle.SignedMessage a)
instance GHC.Generics.Generic (Plutus.Contract.Oracle.SignedMessage a)
instance GHC.Show.Show Plutus.Contract.Oracle.SignedMessageCheckError
instance GHC.Generics.Generic Plutus.Contract.Oracle.SignedMessageCheckError
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.Contract.Oracle.SignedMessage a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.Contract.Oracle.Observation a)

module Plutus.Contract.Resumable

-- | A data type for representing non-deterministic prompts.
data Resumable i o r
[RRequest] :: o -> Resumable i o i
[RSelect] :: Resumable i o Bool
[RZero] :: Resumable i o a
prompt :: Member (Resumable i o) effs => o -> Eff effs i
select :: forall i o effs a. Member (Resumable i o) effs => Eff effs a -> Eff effs a -> Eff effs a
never :: forall i o effs a. Member (Resumable i o) effs => Eff effs a
data Request o
Request :: RequestID -> IterationID -> o -> Request o
[rqID] :: Request o -> RequestID
[itID] :: Request o -> IterationID
[rqRequest] :: Request o -> o
data Response i
Response :: RequestID -> IterationID -> i -> Response i
[rspRqID] :: Response i -> RequestID
[rspItID] :: Response i -> IterationID
[rspResponse] :: Response i -> i

-- | A value that uniquely identifies requests made during the execution of
--   <a>Resumable</a> programs.
newtype RequestID
RequestID :: Natural -> RequestID

-- | A value that uniquely identifies groups of requests.
newtype IterationID
IterationID :: Natural -> IterationID
newtype Requests o
Requests :: [Request o] -> Requests o
[unRequests] :: Requests o -> [Request o]
type ResumableEffs i o effs a = NonDet : State IterationID : State RequestID : State (ReqMap i o effs a) : State (Requests o) : effs
newtype Responses i
Responses :: Map (IterationID, RequestID) i -> Responses i
[unResponses] :: Responses i -> Map (IterationID, RequestID) i
insertResponse :: Response i -> Responses i -> Responses i

-- | A list of all responses ordered by iteration and request ID
responses :: Responses i -> [Response i]
_Responses :: forall i. Iso' (Responses i) (Map (IterationID, RequestID) i)

-- | Interpret the <a>Resumable</a> effect in terms of the <a>Yield</a> and
--   <a>NonDet</a> effects.
handleResumable :: forall i o effs. (Member (Yield o i) effs, Member NonDet effs) => Eff (Resumable i o : effs) ~> Eff effs

-- | Interpret <a>Yield</a> as a prompt-type effect using <a>NonDet</a> to
--   branch out and choose a branch, and the <a>State</a> effects to keep
--   track of request IDs.
suspendNonDet :: forall i o a effs. Eff (Yield o i : ResumableEffs i o effs a) a -> Eff effs (Maybe (MultiRequestContStatus i o effs a))

-- | Status of a suspended <a>MultiRequestContinuation</a>.
data MultiRequestContStatus i o effs a

-- | Done
AResult :: a -> MultiRequestContStatus i o effs a

-- | Waiting for inputs
AContinuation :: MultiRequestContinuation i o effs a -> MultiRequestContStatus i o effs a

-- | A continuation that accepts a response to one of several requests.
data MultiRequestContinuation i o effs a
MultiRequestContinuation :: (Response i -> Eff effs (Maybe (MultiRequestContStatus i o effs a))) -> Requests o -> MultiRequestContinuation i o effs a

-- | Continuation for the response
[ndcCont] :: MultiRequestContinuation i o effs a -> Response i -> Eff effs (Maybe (MultiRequestContStatus i o effs a))

-- | The list of all open requests.
[ndcRequests] :: MultiRequestContinuation i o effs a -> Requests o

-- | A map of requests to continuations. For each request, identified by a
--   pair of <a>RequestID</a> and <a>IterationID</a>, <a>ReqMap</a>
--   contains the continuation that takes the response to the request.
newtype ReqMap i o effs a
ReqMap :: Map (RequestID, IterationID) (i -> Eff (ResumableEffs i o effs a) a) -> ReqMap i o effs a
[unReqMap] :: ReqMap i o effs a -> Map (RequestID, IterationID) (i -> Eff (ResumableEffs i o effs a) a)
instance GHC.Num.Num Plutus.Contract.Resumable.RequestID
instance GHC.Enum.Enum Plutus.Contract.Resumable.RequestID
instance Prettyprinter.Internal.Pretty Plutus.Contract.Resumable.RequestID
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.Contract.Resumable.RequestID
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.Contract.Resumable.RequestID
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.Contract.Resumable.RequestID
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Resumable.RequestID
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Resumable.RequestID
instance GHC.Generics.Generic Plutus.Contract.Resumable.RequestID
instance GHC.Show.Show Plutus.Contract.Resumable.RequestID
instance GHC.Classes.Ord Plutus.Contract.Resumable.RequestID
instance GHC.Classes.Eq Plutus.Contract.Resumable.RequestID
instance GHC.Base.Semigroup Plutus.Contract.Resumable.IterationID
instance GHC.Num.Num Plutus.Contract.Resumable.IterationID
instance GHC.Enum.Enum Plutus.Contract.Resumable.IterationID
instance Prettyprinter.Internal.Pretty Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.Contract.Resumable.IterationID
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Resumable.IterationID
instance GHC.Generics.Generic Plutus.Contract.Resumable.IterationID
instance GHC.Show.Show Plutus.Contract.Resumable.IterationID
instance GHC.Classes.Ord Plutus.Contract.Resumable.IterationID
instance GHC.Classes.Eq Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.FromJSON.FromJSON o => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Resumable.Request o)
instance Data.Aeson.Types.ToJSON.ToJSON o => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Resumable.Request o)
instance Data.Traversable.Traversable Plutus.Contract.Resumable.Request
instance Data.Foldable.Foldable Plutus.Contract.Resumable.Request
instance GHC.Base.Functor Plutus.Contract.Resumable.Request
instance GHC.Generics.Generic (Plutus.Contract.Resumable.Request o)
instance GHC.Show.Show o => GHC.Show.Show (Plutus.Contract.Resumable.Request o)
instance GHC.Classes.Ord o => GHC.Classes.Ord (Plutus.Contract.Resumable.Request o)
instance GHC.Classes.Eq o => GHC.Classes.Eq (Plutus.Contract.Resumable.Request o)
instance Data.Aeson.Types.FromJSON.FromJSON i => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Resumable.Response i)
instance Data.Aeson.Types.ToJSON.ToJSON i => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Resumable.Response i)
instance Data.Traversable.Traversable Plutus.Contract.Resumable.Response
instance Data.Foldable.Foldable Plutus.Contract.Resumable.Response
instance GHC.Base.Functor Plutus.Contract.Resumable.Response
instance GHC.Generics.Generic (Plutus.Contract.Resumable.Response i)
instance GHC.Show.Show i => GHC.Show.Show (Plutus.Contract.Resumable.Response i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Plutus.Contract.Resumable.Response i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Plutus.Contract.Resumable.Response i)
instance Data.Traversable.Traversable Plutus.Contract.Resumable.Requests
instance Data.Foldable.Foldable Plutus.Contract.Resumable.Requests
instance GHC.Base.Functor Plutus.Contract.Resumable.Requests
instance GHC.Generics.Generic (Plutus.Contract.Resumable.Requests o)
instance Data.Aeson.Types.FromJSON.FromJSON o => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Resumable.Requests o)
instance Data.Aeson.Types.ToJSON.ToJSON o => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Resumable.Requests o)
instance GHC.Base.Monoid (Plutus.Contract.Resumable.Requests o)
instance GHC.Base.Semigroup (Plutus.Contract.Resumable.Requests o)
instance GHC.Show.Show o => GHC.Show.Show (Plutus.Contract.Resumable.Requests o)
instance GHC.Classes.Ord o => GHC.Classes.Ord (Plutus.Contract.Resumable.Requests o)
instance GHC.Classes.Eq o => GHC.Classes.Eq (Plutus.Contract.Resumable.Requests o)
instance Data.Traversable.Traversable Plutus.Contract.Resumable.Responses
instance Data.Foldable.Foldable Plutus.Contract.Resumable.Responses
instance GHC.Base.Functor Plutus.Contract.Resumable.Responses
instance GHC.Generics.Generic (Plutus.Contract.Resumable.Responses i)
instance Data.Aeson.Types.FromJSON.FromJSON i => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Resumable.Responses i)
instance Data.Aeson.Types.ToJSON.ToJSON i => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Resumable.Responses i)
instance GHC.Base.Monoid (Plutus.Contract.Resumable.Responses i)
instance GHC.Base.Semigroup (Plutus.Contract.Resumable.Responses i)
instance GHC.Show.Show i => GHC.Show.Show (Plutus.Contract.Resumable.Responses i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Plutus.Contract.Resumable.Responses i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Plutus.Contract.Resumable.Responses i)
instance Data.OpenApi.Internal.Schema.ToSchema o => Data.OpenApi.Internal.Schema.ToSchema (Plutus.Contract.Resumable.Request o)
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Plutus.Contract.Resumable.Responses i)
instance Prettyprinter.Internal.Pretty o => Prettyprinter.Internal.Pretty (Plutus.Contract.Resumable.Requests o)
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Plutus.Contract.Resumable.Response i)
instance Prettyprinter.Internal.Pretty o => Prettyprinter.Internal.Pretty (Plutus.Contract.Resumable.Request o)
instance GHC.Base.Monoid Plutus.Contract.Resumable.IterationID

module Plutus.Contract.Schema
newtype Handlers s
Handlers :: Var (Output s) -> Handlers s
[unHandlers] :: Handlers s -> Var (Output s)
handlerName :: Forall (Output s) Unconstrained1 => Handlers s -> String
handlerArgument :: Forall (Output s) ToJSON => Handlers s -> Value
newtype Event s
Event :: Var (Input s) -> Event s
[unEvent] :: Event s -> Var (Input s)
eventName :: Forall (Input s) Unconstrained1 => Event s -> String
initialise :: forall (s :: Row *) l a. (KnownSymbol l, AllUniqueLabels (Output s), HasType l a (Output s)) => a -> Handlers s
type family Input (r :: Row *)
type family Output (r :: Row *)
type EmptySchema = Empty
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) GHC.Show.Show => GHC.Show.Show (Plutus.Contract.Schema.Event s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) GHC.Classes.Eq => GHC.Classes.Eq (Plutus.Contract.Schema.Event s)
instance (Data.Row.Internal.AllUniqueLabels (Plutus.Contract.Schema.Input s), Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) Data.Aeson.Types.FromJSON.FromJSON) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Schema.Event s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Schema.Event s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Schema.Handlers s)
instance (Data.Row.Internal.AllUniqueLabels (Plutus.Contract.Schema.Output s), Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) Data.Aeson.Types.FromJSON.FromJSON) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Schema.Handlers s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) GHC.Show.Show => GHC.Show.Show (Plutus.Contract.Schema.Handlers s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) GHC.Classes.Eq => GHC.Classes.Eq (Plutus.Contract.Schema.Handlers s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) Prettyprinter.Internal.Pretty => Prettyprinter.Internal.Pretty (Plutus.Contract.Schema.Handlers s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) Prettyprinter.Internal.Pretty => Prettyprinter.Internal.Pretty (Plutus.Contract.Schema.Event s)

module Plutus.Contract.Secrets

-- | A secret value. A value of type `Secret a` can't leak onto the
--   blockchain in plain-text unless you use an unsafe function. However, a
--   value of type `Secret a` can end up on the blockchain via one of the
--   escape hatches like <a>escape_sha2_256</a>.
data Secret a

-- | Secret argments are provided in the endpoint argument types.
--   
--   This type guarantees that a `SecretArgument a` that is seen by the
--   endpoint code is a `Secret a` in a way that can not be bypassed by
--   safe code.
data SecretArgument a
UserSide :: a -> SecretArgument a
EndpointSide :: Secret a -> SecretArgument a

-- | Turn a public value into a secret value
mkSecret :: a -> Secret a

-- | Construct a secret argument
secretArg :: a -> SecretArgument a

-- | Extract a secret value from a secret argument
extractSecret :: SecretArgument a -> Secret a

-- | Take the sha2_256 hash of a secret value. The result of this function
--   can be used on the blockchain.
escape_sha2_256 :: Secret BuiltinByteString -> BuiltinByteString

-- | <i>Warning: [Requires Review] An escape hatch is being created. This
--   should only be used in trusted code.</i>
unsafe_escape_secret :: Secret a -> a
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contract.Secrets.SecretArgument a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Secrets.SecretArgument a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Secrets.SecretArgument a)
instance Data.String.IsString s => Data.String.IsString (Plutus.Contract.Secrets.SecretArgument s)
instance GHC.Show.Show (Plutus.Contract.Secrets.Secret a)
instance GHC.Base.Functor Plutus.Contract.Secrets.Secret
instance PlutusTx.Functor.Functor Plutus.Contract.Secrets.Secret
instance GHC.Base.Applicative Plutus.Contract.Secrets.Secret
instance PlutusTx.Applicative.Applicative Plutus.Contract.Secrets.Secret
instance GHC.Base.Monad Plutus.Contract.Secrets.Secret
instance Data.String.IsString s => Data.String.IsString (Plutus.Contract.Secrets.Secret s)


-- | Data type used for minting and burning the thread token value.
module Plutus.Contract.StateMachine.MintingPolarity
data MintingPolarity
Mint :: MintingPolarity
Burn :: MintingPolarity
instance PlutusTx.IsData.Class.ToData Plutus.Contract.StateMachine.MintingPolarity.MintingPolarity
instance PlutusTx.IsData.Class.FromData Plutus.Contract.StateMachine.MintingPolarity.MintingPolarity
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contract.StateMachine.MintingPolarity.MintingPolarity
instance PlutusTx.Eq.Eq Plutus.Contract.StateMachine.MintingPolarity.MintingPolarity
instance GHC.Show.Show Plutus.Contract.StateMachine.MintingPolarity.MintingPolarity
instance GHC.Classes.Eq Plutus.Contract.StateMachine.MintingPolarity.MintingPolarity


-- | Thread token data type definition and minting policy. Thread tokens
--   are used to identify the contract instance on the blockchain, and
--   ensuring that the state was produced by running the state machine from
--   its initial state.
module Plutus.Contract.StateMachine.ThreadToken
data ThreadToken
ThreadToken :: TxOutRef -> CurrencySymbol -> ThreadToken
[ttOutRef] :: ThreadToken -> TxOutRef
[ttCurrencySymbol] :: ThreadToken -> CurrencySymbol
checkPolicy :: TxOutRef -> (ValidatorHash, MintingPolarity) -> ScriptContext -> Bool
curPolicy :: TxOutRef -> MintingPolicy

-- | The <a>Value</a> containing exactly the thread token.
threadTokenValue :: CurrencySymbol -> ValidatorHash -> Value

-- | Check exactly <tt>n</tt> thread tokens and no other tokens with the
--   given <tt>CurrencySymbol</tt> are in the given <tt>Value</tt>.
checkThreadTokenInner :: CurrencySymbol -> ValidatorHash -> Value -> Integer -> Bool
checkThreadToken :: Maybe ThreadToken -> ValidatorHash -> Value -> Integer -> Bool
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance PlutusTx.IsData.Class.ToData Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance PlutusTx.IsData.Class.FromData Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance GHC.Generics.Generic Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance GHC.Classes.Ord Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance GHC.Show.Show Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance GHC.Classes.Eq Plutus.Contract.StateMachine.ThreadToken.ThreadToken


-- | On-chain code fragments for creating a state machine. First define a
--   <tt>StateMachine s i</tt> with input type <tt>i</tt> and state type
--   <tt>s</tt>. Then use <a>mkValidator</a> in on-chain code to check the
--   required hashes and validate the transition, and <tt>mkRedeemer</tt>
--   to make redeemer scripts.
module Plutus.Contract.StateMachine.OnChain

-- | Specification of a state machine, consisting of a transition function
--   that determines the next state from the current state and an input,
--   and a checking function that checks the validity of the transition in
--   the context of the current transaction.
data StateMachine s i
StateMachine :: (State s -> i -> Maybe (TxConstraints Void Void, State s)) -> (s -> Bool) -> (s -> i -> ScriptContext -> Bool) -> Maybe ThreadToken -> StateMachine s i

-- | The transition function of the state machine. <a>Nothing</a> indicates
--   an invalid transition from the current state.
[smTransition] :: StateMachine s i -> State s -> i -> Maybe (TxConstraints Void Void, State s)

-- | Check whether a state is the final state
[smFinal] :: StateMachine s i -> s -> Bool

-- | The condition checking function. Can be used to perform checks on the
--   pending transaction that aren't covered by the constraints.
--   <a>smCheck</a> is always run in addition to checking the constraints,
--   so the default implementation always returns true.
[smCheck] :: StateMachine s i -> s -> i -> ScriptContext -> Bool

-- | The <tt>ThreadToken</tt> that identifies the contract instance. Make
--   one with <tt>getThreadToken</tt> and pass it on to
--   <a>mkStateMachine</a>. Initialising the machine will then mint a
--   thread token value.
[smThreadToken] :: StateMachine s i -> Maybe ThreadToken
data StateMachineInstance s i
StateMachineInstance :: StateMachine s i -> TypedValidator (StateMachine s i) -> StateMachineInstance s i

-- | The state machine specification.
[stateMachine] :: StateMachineInstance s i -> StateMachine s i

-- | The validator code for this state machine.
[typedValidator] :: StateMachineInstance s i -> TypedValidator (StateMachine s i)
data State s
State :: s -> Value -> State s
[stateData] :: State s -> s
[stateValue] :: State s -> Value

-- | A state machine that does not perform any additional checks on the
--   <a>ScriptContext</a> (beyond enforcing the constraints)
mkStateMachine :: Maybe ThreadToken -> (State s -> i -> Maybe (TxConstraints Void Void, State s)) -> (s -> Bool) -> StateMachine s i

-- | TODO StateMachine can be use only on a testnet at the moment, to
--   enable it on another network, we need to parametrise the networkId
machineAddress :: StateMachineInstance s i -> CardanoAddress

-- | Turn a state machine into a validator script.
mkValidator :: forall s i. ToData s => StateMachine s i -> ValidatorType (StateMachine s i)

-- | The <a>Value</a> containing exactly the thread token, if one has been
--   specified.
threadTokenValueOrZero :: StateMachineInstance s i -> Value
instance Data.Aeson.Types.FromJSON.FromJSON s => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.StateMachine.OnChain.State s)
instance Data.Aeson.Types.ToJSON.ToJSON s => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.StateMachine.OnChain.State s)
instance GHC.Generics.Generic (Plutus.Contract.StateMachine.OnChain.State s)
instance GHC.Show.Show s => GHC.Show.Show (Plutus.Contract.StateMachine.OnChain.State s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Plutus.Contract.StateMachine.OnChain.State s)
instance Plutus.Script.Utils.Typed.ValidatorTypes (Plutus.Contract.StateMachine.OnChain.StateMachine s i)

module Plutus.Contract.Test.ContractModel.Symbolics
newtype AssetKey
AssetKey :: Int -> AssetKey

-- | A symbolic token is a token that exists only during ContractModel
--   generation time
data SymToken
SymToken :: Var AssetKey -> String -> SymToken
[symVar] :: SymToken -> Var AssetKey
[symVarIdx] :: SymToken -> String

-- | A symbolic value is a combination of a real value and a value
--   associating symbolic tokens with an amount
data SymValue
SymValue :: Map SymToken Integer -> Value -> SymValue
[symValMap] :: SymValue -> Map SymToken Integer
[actualValPart] :: SymValue -> Value

-- | Check if a symbolic value is zero
symIsZero :: SymValue -> Bool

-- | Check if one symbolic value is less than or equal to another
symLeq :: SymValue -> SymValue -> Bool

-- | Using a semantics function for symbolic tokens, convert a SymValue to
--   a Value
toValue :: (SymToken -> AssetClass) -> SymValue -> Value

-- | Invert a sym token mapping to turn a Value into a SymValue, useful for
--   error reporting
toSymVal :: (AssetClass -> Maybe SymToken) -> Value -> SymValue
inv :: SymValue -> SymValue
class SymValueLike v
toSymValue :: SymValueLike v => v -> SymValue
class TokenLike t

-- | Get the value of a specific token in a <a>SymValue</a>
symAssetIdValueOf :: TokenLike t => SymValue -> t -> Integer

-- | Convert a token and an amount to a <a>SymValue</a>
symAssetIdValue :: TokenLike t => t -> Integer -> SymValue
instance Data.Data.Data Plutus.Contract.Test.ContractModel.Symbolics.AssetKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.Contract.Test.ContractModel.Symbolics.AssetKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.Contract.Test.ContractModel.Symbolics.AssetKey
instance GHC.Num.Num Plutus.Contract.Test.ContractModel.Symbolics.AssetKey
instance GHC.Show.Show Plutus.Contract.Test.ContractModel.Symbolics.AssetKey
instance GHC.Classes.Eq Plutus.Contract.Test.ContractModel.Symbolics.AssetKey
instance GHC.Classes.Ord Plutus.Contract.Test.ContractModel.Symbolics.AssetKey
instance Data.Data.Data Plutus.Contract.Test.ContractModel.Symbolics.SymToken
instance GHC.Classes.Eq Plutus.Contract.Test.ContractModel.Symbolics.SymToken
instance GHC.Classes.Ord Plutus.Contract.Test.ContractModel.Symbolics.SymToken
instance Data.Data.Data Plutus.Contract.Test.ContractModel.Symbolics.SymValue
instance GHC.Show.Show Plutus.Contract.Test.ContractModel.Symbolics.SymValue
instance Plutus.Contract.Test.ContractModel.Symbolics.TokenLike Plutus.Contract.Test.ContractModel.Symbolics.SymToken
instance Plutus.Contract.Test.ContractModel.Symbolics.TokenLike Plutus.V1.Ledger.Value.AssetClass
instance Plutus.Contract.Test.ContractModel.Symbolics.SymValueLike Plutus.V1.Ledger.Value.Value
instance Plutus.Contract.Test.ContractModel.Symbolics.SymValueLike Plutus.Contract.Test.ContractModel.Symbolics.SymValue
instance Plutus.Contract.Test.ContractModel.Symbolics.SymValueLike Ledger.Ada.Ada
instance GHC.Base.Semigroup Plutus.Contract.Test.ContractModel.Symbolics.SymValue
instance GHC.Base.Monoid Plutus.Contract.Test.ContractModel.Symbolics.SymValue
instance GHC.Classes.Eq Plutus.Contract.Test.ContractModel.Symbolics.SymValue
instance GHC.Show.Show Plutus.Contract.Test.ContractModel.Symbolics.SymToken

module Plutus.Contract.Test.Coverage.Analysis.Common
type Trm = Term NamedTyDeBruijn NamedDeBruijn DefaultUni DefaultFun ()
type Typ = Type NamedTyDeBruijn DefaultUni ()
type Kin = Kind ()
type Dat = Datatype NamedTyDeBruijn NamedDeBruijn DefaultUni DefaultFun ()
type Bind = Binding NamedTyDeBruijn NamedDeBruijn DefaultUni DefaultFun ()
type Trm' = Term TyName Name DefaultUni DefaultFun ()
type Typ' = Type TyName DefaultUni ()
type Dat' = Datatype TyName Name DefaultUni DefaultFun ()
type Bind' = Binding TyName Name DefaultUni DefaultFun ()
type Err' = Error DefaultUni DefaultFun ()
pattern BIF_Trace :: Term tyname name uni DefaultFun ()
pattern BIF_If :: Term tyname name uni DefaultFun ()
pattern LIT_Loc :: CoverageAnnotation -> Term tyname name DefaultUni fun ()
pattern Const :: DefaultUni (Esc a) -> a -> Term tyname name DefaultUni fun ()
builtinKind :: SomeTypeIn DefaultUni -> Kin
data Verbosity
Low :: Verbosity
Med :: Verbosity
High :: Verbosity
Unions :: Verbosity
debug :: Bool
verbosity :: [Verbosity]
traceDoc :: Verbosity -> Doc -> a -> a
traceDocIf :: Bool -> Verbosity -> Doc -> a -> a
errorDoc :: HasCallStack => Doc -> a
pattern Star :: Kin
pattern (:->) :: Kin -> Kin -> Kin
infixr 3 :->
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Common.Verbosity
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.Analysis.Common.Verbosity
instance GHC.Classes.Ord Plutus.Contract.Test.Coverage.Analysis.Common.Verbosity
instance Control.DeepSeq.NFData Plutus.Contract.Test.Coverage.Analysis.Common.Trm'
instance Control.DeepSeq.NFData Plutus.Contract.Test.Coverage.Analysis.Common.Bind'
instance Control.DeepSeq.NFData (PlutusCore.Core.Type.VarDecl PlutusCore.Name.TyName PlutusCore.Name.Name PlutusCore.Default.Universe.DefaultUni PlutusCore.Default.Builtins.DefaultFun ())
instance Control.DeepSeq.NFData (PlutusCore.Core.Type.TyVarDecl PlutusCore.Name.TyName ())
instance Control.DeepSeq.NFData Plutus.Contract.Test.Coverage.Analysis.Common.Dat'
instance Control.DeepSeq.NFData PlutusIR.Core.Type.Strictness
instance Control.DeepSeq.NFData PlutusIR.Core.Type.Recursivity
instance Control.DeepSeq.NFData (PlutusCore.Core.Type.TyVarDecl PlutusCore.DeBruijn.Internal.NamedTyDeBruijn ())
instance Control.DeepSeq.NFData Plutus.Contract.Test.Coverage.Analysis.Common.Dat
instance Control.DeepSeq.NFData (PlutusCore.Core.Type.VarDecl PlutusCore.DeBruijn.Internal.NamedTyDeBruijn PlutusCore.DeBruijn.Internal.NamedDeBruijn PlutusCore.Default.Universe.DefaultUni PlutusCore.Default.Builtins.DefaultFun ())
instance Control.DeepSeq.NFData Plutus.Contract.Test.Coverage.Analysis.Common.Bind
instance Control.DeepSeq.NFData Plutus.Contract.Test.Coverage.Analysis.Common.Trm

module Plutus.Contract.Test.Coverage.Analysis.DeBruijn
type DBCtx nm = [nm]
class Eq n => IsName n where {
    type family DeBruijn n;
}
mkDeBruijn :: IsName n => n -> Index -> DeBruijn n
class IsDbName n
setDbIndex :: IsDbName n => n -> Index -> n
getDbIndex :: IsDbName n => n -> Index
deBruijn :: HasCallStack => IsName n => DBCtx n -> n -> DeBruijn n
extendDBCtx :: HasCallStack => DBCtx n -> n -> DBCtx n
toDeBruijn_Trm :: HasCallStack => DBCtx TyName -> DBCtx Name -> Trm' -> Trm
toDeBruijn_Typ :: HasCallStack => DBCtx TyName -> Typ' -> Typ
bindCtx_Dat :: HasCallStack => (DBCtx TyName, DBCtx Name) -> Dat' -> (DBCtx TyName, DBCtx Name)
toDeBruijn_Dat :: HasCallStack => Bool -> DBCtx TyName -> Dat' -> Dat
bindCtx_Bind :: HasCallStack => (DBCtx TyName, DBCtx Name) -> Bind' -> (DBCtx TyName, DBCtx Name)
toDeBruijn_Bind :: HasCallStack => Bool -> DBCtx TyName -> DBCtx Name -> Bind' -> Bind
getTrm :: HasCallStack => CompiledCode a -> Trm
instance Plutus.Contract.Test.Coverage.Analysis.DeBruijn.IsDbName PlutusCore.DeBruijn.Internal.NamedDeBruijn
instance Plutus.Contract.Test.Coverage.Analysis.DeBruijn.IsDbName PlutusCore.DeBruijn.Internal.NamedTyDeBruijn
instance Plutus.Contract.Test.Coverage.Analysis.DeBruijn.IsName PlutusCore.Name.Name
instance Plutus.Contract.Test.Coverage.Analysis.DeBruijn.IsName PlutusCore.Name.TyName

module Plutus.Contract.Test.Coverage.Analysis.Types
data SnocList a
Nil :: SnocList a
(:>) :: SnocList a -> a -> SnocList a
infixl 5 :>
zipWithSnoc :: (a -> b -> c) -> SnocList a -> SnocList b -> SnocList c
data DCon
DCon :: [DTyp] -> DCon
data DDat
DDat :: Bool -> NamedTyDeBruijn -> Kin -> [NamedTyDeBruijn] -> [DCon] -> DDat
data TyCtxEntry
(:::) :: NamedTyDeBruijn -> Kin -> TyCtxEntry
TyCtxRecDat :: SnocList DDat -> TyCtxEntry
TyCtxDat :: DDat -> TyCtxEntry
type TyCtx = SnocList TyCtxEntry
type Subst a = SnocList a
data Dom
DTop :: DTyp -> Int -> Set CoverageAnnotation -> Dom
[ty] :: Dom -> DTyp
[depth] :: Dom -> Int
[_locations] :: Dom -> Set CoverageAnnotation
DError :: Dom
DSusp :: Set CoverageAnnotation -> Dom -> Dom
[_locations] :: Dom -> Set CoverageAnnotation
[inner] :: Dom -> Dom
DTySusp :: NamedTyDeBruijn -> Kin -> Set CoverageAnnotation -> Dom -> Dom
[suspName] :: Dom -> NamedTyDeBruijn
[kind] :: Dom -> Kin
[_locations] :: Dom -> Set CoverageAnnotation
[inner] :: Dom -> Dom
DIf :: DTyp -> Set CoverageAnnotation -> Dom
[argTy] :: Dom -> DTyp
[_locations] :: Dom -> Set CoverageAnnotation
DTrace :: DTyp -> Set CoverageAnnotation -> Dom
[argTy] :: Dom -> DTyp
[_locations] :: Dom -> Set CoverageAnnotation
DLoc :: CoverageAnnotation -> Dom
[location] :: Dom -> CoverageAnnotation
DLam :: NamedDeBruijn -> DTyp -> Subst Dom -> Subst DTyp -> Trm -> Set CoverageAnnotation -> Dom
[lamName] :: Dom -> NamedDeBruijn
[argTy] :: Dom -> DTyp
[substD] :: Dom -> Subst Dom
[substT] :: Dom -> Subst DTyp
[body] :: Dom -> Trm
[_locations] :: Dom -> Set CoverageAnnotation
DConstr :: DTyp -> Int -> SnocList Dom -> Set CoverageAnnotation -> Dom
[dat] :: Dom -> DTyp
[constr] :: Dom -> Int
[argsD] :: Dom -> SnocList Dom
[_locations] :: Dom -> Set CoverageAnnotation
DMatch :: DTyp -> Set CoverageAnnotation -> Dom
[dat] :: Dom -> DTyp
[_locations] :: Dom -> Set CoverageAnnotation
DUnion :: [Dom] -> Dom
DWeaken :: Weakening -> Dom -> Dom
[wk] :: Dom -> Weakening
[inner] :: Dom -> Dom
data DTyp
DTVar :: NamedTyDeBruijn -> [DTyp] -> DTyp
DTFun :: DTyp -> DTyp -> DTyp
DTLam :: NamedTyDeBruijn -> Kin -> DTyp -> DTyp
[dtName] :: DTyp -> NamedTyDeBruijn
[dtKind] :: DTyp -> Kin
[dtBody] :: DTyp -> DTyp
DTForall :: NamedTyDeBruijn -> Kin -> DTyp -> DTyp
[dtName] :: DTyp -> NamedTyDeBruijn
[dtKind] :: DTyp -> Kin
[dtBody] :: DTyp -> DTyp
DTWk :: Weakening -> DTyp -> DTyp
[dtWk] :: DTyp -> Weakening
[dtBody] :: DTyp -> DTyp
DTyBuiltin :: Kin -> DTyp
data DArg
TyArg :: DTyp -> DArg
DArg :: Dom -> DArg
newtype Weakening
Wk :: [(Index, Index)] -> Weakening
wkIndex :: HasCallStack => Weakening -> Index -> Index
wkBy :: HasCallStack => Index -> Weakening
shiftWeakening :: HasCallStack => Weakening -> Weakening
topLevelLocations :: HasCallStack => Dom -> Set CoverageAnnotation
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)
instance GHC.Generics.Generic (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)
instance Data.Traversable.Traversable Plutus.Contract.Test.Coverage.Analysis.Types.SnocList
instance Data.Foldable.Foldable Plutus.Contract.Test.Coverage.Analysis.Types.SnocList
instance GHC.Base.Functor Plutus.Contract.Test.Coverage.Analysis.Types.SnocList
instance Control.DeepSeq.NFData Plutus.Contract.Test.Coverage.Analysis.Types.Weakening
instance GHC.Generics.Generic Plutus.Contract.Test.Coverage.Analysis.Types.Weakening
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.Analysis.Types.Weakening
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.Weakening
instance Control.DeepSeq.NFData Plutus.Contract.Test.Coverage.Analysis.Types.DTyp
instance GHC.Generics.Generic Plutus.Contract.Test.Coverage.Analysis.Types.DTyp
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.Analysis.Types.DTyp
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.DTyp
instance Control.DeepSeq.NFData Plutus.Contract.Test.Coverage.Analysis.Types.DCon
instance GHC.Generics.Generic Plutus.Contract.Test.Coverage.Analysis.Types.DCon
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.Analysis.Types.DCon
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.DCon
instance Control.DeepSeq.NFData Plutus.Contract.Test.Coverage.Analysis.Types.DDat
instance GHC.Generics.Generic Plutus.Contract.Test.Coverage.Analysis.Types.DDat
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.Analysis.Types.DDat
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.DDat
instance Control.DeepSeq.NFData Plutus.Contract.Test.Coverage.Analysis.Types.TyCtxEntry
instance GHC.Generics.Generic Plutus.Contract.Test.Coverage.Analysis.Types.TyCtxEntry
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.Analysis.Types.TyCtxEntry
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.TyCtxEntry
instance Control.DeepSeq.NFData Plutus.Contract.Test.Coverage.Analysis.Types.Dom
instance GHC.Generics.Generic Plutus.Contract.Test.Coverage.Analysis.Types.Dom
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.Dom
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.DArg
instance GHC.Base.Semigroup Plutus.Contract.Test.Coverage.Analysis.Types.Weakening
instance GHC.Base.Monoid Plutus.Contract.Test.Coverage.Analysis.Types.Weakening
instance GHC.Base.Semigroup (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)
instance GHC.Base.Monoid (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)

module Plutus.Contract.Test.Coverage.Analysis.Pretty
class Pretty a
pretty :: Pretty a => a -> Doc
prettyPrec :: Pretty a => Int -> a -> Doc
(<?>) :: Doc -> Doc -> Doc
pParen :: Bool -> Doc -> Doc
type PrettyTm tyname name uni fun = (Eq tyname, Pretty tyname, Pretty name, Pretty (SomeTypeIn uni), Pretty (Some (ValueOf uni)), Pretty fun)
type PrettyTy tyname uni = (Eq tyname, Pretty tyname, Pretty (SomeTypeIn uni))
ppTyBind :: Pretty tyname => (tyname, Kind ann) -> Doc
ppAbstr :: Pretty b => Int -> (arg -> Doc) -> Doc -> ([arg], b) -> Doc
ppApp :: PrettyTm tyname name uni fun => Int -> Term tyname name uni fun ann -> Doc
ppApp' :: PrettyTm tyname name uni fun => Int -> Doc -> [Either (Type tyname uni ann) (Term tyname name uni fun ann)] -> Doc
viewApp :: Term tyname name uni fun ann -> (Term tyname name uni fun ann, [Either (Type tyname uni ann) (Term tyname name uni fun ann)])
ppSubst :: Pretty a => Subst a -> Doc
angles :: Doc -> Doc
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Test.QuickCheck.Modifiers.NonNegative a)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTy tyname uni => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusCore.Core.Type.Type tyname uni ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTy tyname uni => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusCore.Core.Type.TyDecl tyname uni ann)
instance (Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTy tyname uni, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty name) => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusCore.Core.Type.VarDecl tyname name uni fun ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTm tyname name uni fun => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusIR.Core.Type.Program tyname name uni fun ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTm tyname name uni fun => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusIR.Core.Type.Binding tyname name uni fun ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTm tyname name uni fun => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusIR.Core.Type.Datatype tyname name uni fun ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTm tyname name uni fun => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusIR.Core.Type.Term tyname name uni fun ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Data.Text.Internal.Text
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusTx.Code.CompiledCode a)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Universe.Core.SomeTypeIn PlutusCore.Default.Universe.DefaultUni)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Data.Some.Newtype.Some (Universe.Core.ValueOf PlutusCore.Default.Universe.DefaultUni))
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusCore.Default.Builtins.DefaultFun
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusCore.Name.Name
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusCore.DeBruijn.Internal.NamedDeBruijn
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusCore.Name.TyName
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusCore.DeBruijn.Internal.NamedTyDeBruijn
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusTx.Coverage.CoverageAnnotation
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusTx.Coverage.CovLoc
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusCore.Core.Type.Kind ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty tyname => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusCore.Core.Type.TyVarDecl tyname ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Data.Set.Internal.Set a)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty [a]
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.TyCtxEntry
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.DDat
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.DCon
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.DTyp
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.DArg
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty GHC.Types.Int
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusCore.DeBruijn.Internal.Index
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.Weakening
instance (Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty b) => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (a, b)
instance (Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty b, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty c) => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (a, b, c)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.Dom
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusTx.Coverage.CoverageIndex
instance (Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty k, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty v) => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Data.Map.Internal.Map k v)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Text.PrettyPrint.HughesPJ.Doc
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty GHC.Base.String
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty GHC.Types.Bool
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (GHC.Maybe.Maybe a)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty ()
instance (Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty name, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Data.Some.Newtype.Some (Universe.Core.ValueOf uni)), Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty fun) => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (UntypedPlutusCore.Core.Type.Program name uni fun ann)
instance (Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty name, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Data.Some.Newtype.Some (Universe.Core.ValueOf uni)), Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty fun) => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (UntypedPlutusCore.Core.Type.Term name uni fun ann)

module Plutus.Contract.Test.Coverage.Analysis.Interpreter
allNonFailLocations :: HasCallStack => CompiledCodeIn DefaultUni DefaultFun a -> Set CoverageAnnotation

module Plutus.Contract.Test.Coverage.Analysis
computeRefinedCoverageIndex :: CompiledCodeIn DefaultUni DefaultFun a -> CoverageIndex
refinedCoverageIndex :: Q Exp

module Plutus.Contract.Test.Coverage.ReportCoverage
writeCoverageReport :: String -> CoverageReport -> IO ()
instance GHC.Show.Show Plutus.Contract.Test.Coverage.ReportCoverage.CoverStatus
instance GHC.Classes.Ord Plutus.Contract.Test.Coverage.ReportCoverage.CoverStatus
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.ReportCoverage.CoverStatus
instance GHC.Show.Show Plutus.Contract.Test.Coverage.ReportCoverage.IgnoreStatus
instance GHC.Classes.Ord Plutus.Contract.Test.Coverage.ReportCoverage.IgnoreStatus
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.ReportCoverage.IgnoreStatus
instance GHC.Show.Show Plutus.Contract.Test.Coverage.ReportCoverage.Status
instance GHC.Classes.Ord Plutus.Contract.Test.Coverage.ReportCoverage.Status
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.ReportCoverage.Status
instance GHC.Show.Show Plutus.Contract.Test.Coverage.ReportCoverage.Swipe
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.ReportCoverage.Swipe
instance GHC.Classes.Ord Plutus.Contract.Test.Coverage.ReportCoverage.Swipe
instance GHC.Base.Semigroup Plutus.Contract.Test.Coverage.ReportCoverage.Status
instance GHC.Base.Monoid Plutus.Contract.Test.Coverage.ReportCoverage.Status
instance GHC.Base.Semigroup Plutus.Contract.Test.Coverage.ReportCoverage.IgnoreStatus
instance GHC.Base.Monoid Plutus.Contract.Test.Coverage.ReportCoverage.IgnoreStatus
instance GHC.Base.Semigroup Plutus.Contract.Test.Coverage.ReportCoverage.CoverStatus
instance GHC.Base.Monoid Plutus.Contract.Test.Coverage.ReportCoverage.CoverStatus

module Plutus.Contract.Test.MissingLovelace

-- | Returns the calculated delta between initial and final values. Might
--   be false positive.
--   
--   The tests check if a wallet's funds are equal to some expected value
--   at the end. Unfortunately, because of the adjustion of transactions,
--   the outputs' costs change and it's hard to track these changes in the
--   tests layer.
--   
--   This function tries to check if the difference between final and
--   initial values (<tt>realDelta</tt>) is a result of combination of
--   operations between output's costs and the expected delta.
--   
--   There is a risk when expected delta has only ada part and expected
--   delta /= realDelta and realDelta is divisible by some delta from
--   deltas, then we will return realDelta's ada. Which means that the test
--   will pass but without strong confidence in wallets' funds consistency.
--   For example, we expected -n, but there is n among deltas and realDelta
--   is n, it is divisible by n, then the test will pass. So please be
--   careful.
calculateDelta :: Value -> Ada -> Ada -> [Ada] -> Value

module Plutus.Contract.Util

-- | A monadic version of <tt>loop</tt>, where the predicate returns
--   <a>Left</a> as a seed for the next loop or <a>Right</a> to abort the
--   loop.
--   
--   
--   <a>https://hackage.haskell.org/package/extra-1.6.15/docs/src/Control.Monad.Extra.html#loopM</a>
loopM :: Monad m => (a -> m (Either a b)) -> a -> m b

-- | Repeatedly evaluate the action until it yields <a>Nothing</a>, then
--   return the aggregated result.
foldMaybe :: Monad m => (a -> b -> b) -> b -> m (Maybe a) -> m b

-- | Monadic version of <a>&lt;*</a>
finally :: Monad m => m a -> m b -> m a
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d

module Plutus.Trace.Tag

-- | A human-readable piece of data, used to identify threads and contract
--   instances. See note [Thread Tag]
newtype Tag
Tag :: Text -> Tag
[unTag] :: Tag -> Text
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Tag.Tag
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Tag.Tag
instance Data.String.IsString Plutus.Trace.Tag.Tag
instance GHC.Generics.Generic Plutus.Trace.Tag.Tag
instance GHC.Show.Show Plutus.Trace.Tag.Tag
instance GHC.Classes.Ord Plutus.Trace.Tag.Tag
instance GHC.Classes.Eq Plutus.Trace.Tag.Tag
instance Prettyprinter.Internal.Pretty Plutus.Trace.Tag.Tag

module Plutus.Trace.Scheduler

-- | Unique identifier of a thread.
data ThreadId
type SysCall effs systemEvent a = Either (MessageCall systemEvent) (ThreadCall effs systemEvent a)

-- | Sending messages to other threads and waiting for new messages to
--   arrive.
data MessageCall systemEvent

-- | Suspend ourselves (the caller) until we receive a message
WaitForMessage :: MessageCall systemEvent

-- | Send a message to all threads
Broadcast :: systemEvent -> MessageCall systemEvent

-- | Send a message to a specific thread
Message :: ThreadId -> systemEvent -> MessageCall systemEvent

-- | The system calls we can make to the scheduler, affecting the the
--   threads that are currently running.
data ThreadCall effs systemEvent a

-- | Start a new thread with a new thread ID.
Fork :: (ThreadId -> SuspendedThread effs systemEvent a) -> ThreadCall effs systemEvent a

-- | Unfreeze a thread.
Thaw :: ThreadId -> ThreadCall effs systemEvent a

-- | Terminate the scheduler.
Exit :: a -> ThreadCall effs systemEvent a

-- | A thread with a <a>Priority</a>.
data WithPriority t
WithPriority :: Priority -> t -> WithPriority t
[_priority] :: WithPriority t -> Priority
[_thread] :: WithPriority t -> t

-- | Priority of a thread.
data Priority

-- | Thread is ready to run
Normal :: Priority

-- | Thread is sleeping, to be resumed only after an external event happens
Sleeping :: Priority

-- | Thread is frozen, it will only be resumed after it is manually
--   unfrozen via the <a>Thaw</a> sys call.
Frozen :: Priority

-- | A human-readable piece of data, used to identify threads and contract
--   instances. See note [Thread Tag]
data Tag
type EmSystemCall effs systemEvent a = WithPriority (SysCall effs systemEvent a)
type AgentSystemCall systemEvent = WithPriority (MessageCall systemEvent)
type SuspendedThread effs systemEvent a = WithPriority (EmThread effs systemEvent a)

-- | Thread that can be run by the scheduler
data EmThread effs systemEvent a
EmThread :: (Maybe systemEvent -> Eff effs (Status effs (EmSystemCall effs systemEvent a) (Maybe systemEvent) ())) -> ThreadId -> Tag -> EmThread effs systemEvent a

-- | The continuation to be run when the thread is resumed.
[_continuation] :: EmThread effs systemEvent a -> Maybe systemEvent -> Eff effs (Status effs (EmSystemCall effs systemEvent a) (Maybe systemEvent) ())

-- | Thread ID
[_threadId] :: EmThread effs systemEvent a -> ThreadId

-- | Tag of the thread. See note [Thread Tag]
[_tag] :: EmThread effs systemEvent a -> Tag

-- | Scheduler state
data SchedulerState effs systemEvent a
SchedulerState :: Seq (EmThread effs systemEvent a) -> Seq (EmThread effs systemEvent a) -> Seq (EmThread effs systemEvent a) -> ThreadId -> HashMap ThreadId (Seq systemEvent) -> Map Tag (HashSet ThreadId) -> SchedulerState effs systemEvent a

-- | Threads running at normal priority
[_normalPrio] :: SchedulerState effs systemEvent a -> Seq (EmThread effs systemEvent a)

-- | Sleeping threads (waiting for an external event)
[_sleeping] :: SchedulerState effs systemEvent a -> Seq (EmThread effs systemEvent a)

-- | Frozen threads (will not be resumed until they are explicitly
--   unfrozen)
[_frozen] :: SchedulerState effs systemEvent a -> Seq (EmThread effs systemEvent a)

-- | Last thread id assigned to a thread
[_lastThreadId] :: SchedulerState effs systemEvent a -> ThreadId

-- | The mailboxes of all active threads.
[_mailboxes] :: SchedulerState effs systemEvent a -> HashMap ThreadId (Seq systemEvent)

-- | Map of tags to thread IDs. See note [Thread Tag]
[_activeThreads] :: SchedulerState effs systemEvent a -> Map Tag (HashSet ThreadId)

-- | Handle the 'Yield (EmSystemCall effs systemEvent) (Maybe systemEvent)'
--   effect using the scheduler, see note [Scheduler]. <a>runThreads</a>
--   only returns when all threads are finished, returning <a>Nothing</a>,
--   or when <a>exit</a> is called, in which case the value passed to
--   <a>exit</a> is returned.
runThreads :: forall a effs systemEvent. (Eq systemEvent, Member (LogMsg SchedulerLog) effs) => Eff (Reader ThreadId : (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent) : effs)) () -> Eff effs (Maybe a)

-- | Start a new thread
fork :: forall effs systemEvent effs2 a. Member (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent)) effs2 => Tag -> Priority -> Eff (Reader ThreadId : (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent) : effs)) () -> Eff effs2 (Maybe systemEvent)

-- | Suspend the current thread
sleep :: forall effs systemEvent effs2 a. Member (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent)) effs2 => Priority -> Eff effs2 (Maybe systemEvent)

-- | Stop the scheduler and let it return with the given value.
exit :: forall effs systemEvent effs2 a. Member (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent)) effs2 => a -> Eff effs2 (Maybe systemEvent)

-- | Make a thread with the given priority from an action. This is a
--   convenience for defining <tt>SimulatorInterpreter</tt> values.
mkThread :: Tag -> Priority -> Eff (Reader ThreadId : (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent) : effs)) () -> ThreadId -> SuspendedThread effs systemEvent a

-- | Make a system call
mkSysCall :: forall effs systemEvent effs2 a. Member (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent)) effs2 => Priority -> SysCall effs systemEvent a -> Eff effs2 (Maybe systemEvent)

-- | Make a <a>MessageCall</a> system call for some agent
mkAgentSysCall :: forall effs systemEvent. Member (Yield (AgentSystemCall systemEvent) (Maybe systemEvent)) effs => Priority -> MessageCall systemEvent -> Eff effs (Maybe systemEvent)
data SchedulerLog
SchedulerLog :: ThreadEvent -> ThreadId -> Tag -> Priority -> SchedulerLog
[slEvent] :: SchedulerLog -> ThreadEvent
[slThread] :: SchedulerLog -> ThreadId
[slTag] :: SchedulerLog -> Tag
[slPrio] :: SchedulerLog -> Priority
data ThreadEvent
Stopped :: ThreadEvent
Resumed :: ThreadEvent
Suspended :: ThreadEvent
Started :: ThreadEvent
Thawed :: ThreadEvent
instance Prettyprinter.Internal.Pretty Plutus.Trace.Scheduler.ThreadEvent
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Scheduler.ThreadEvent
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Scheduler.ThreadEvent
instance GHC.Generics.Generic Plutus.Trace.Scheduler.ThreadEvent
instance GHC.Show.Show Plutus.Trace.Scheduler.ThreadEvent
instance GHC.Classes.Ord Plutus.Trace.Scheduler.ThreadEvent
instance GHC.Classes.Eq Plutus.Trace.Scheduler.ThreadEvent
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Scheduler.SchedulerLog
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Scheduler.SchedulerLog
instance GHC.Generics.Generic Plutus.Trace.Scheduler.SchedulerLog
instance GHC.Show.Show Plutus.Trace.Scheduler.SchedulerLog
instance GHC.Classes.Eq Plutus.Trace.Scheduler.SchedulerLog
instance Prettyprinter.Internal.Pretty Plutus.Trace.Scheduler.SchedulerLog
instance Prettyprinter.Internal.Pretty Plutus.Trace.Scheduler.ThreadId
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Scheduler.ThreadId
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Scheduler.ThreadId
instance Data.Hashable.Class.Hashable Plutus.Trace.Scheduler.ThreadId
instance GHC.Generics.Generic Plutus.Trace.Scheduler.ThreadId
instance GHC.Show.Show Plutus.Trace.Scheduler.ThreadId
instance GHC.Classes.Ord Plutus.Trace.Scheduler.ThreadId
instance GHC.Classes.Eq Plutus.Trace.Scheduler.ThreadId
instance Prettyprinter.Internal.Pretty Plutus.Trace.Scheduler.Priority
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Scheduler.Priority
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Scheduler.Priority
instance GHC.Generics.Generic Plutus.Trace.Scheduler.Priority
instance GHC.Show.Show Plutus.Trace.Scheduler.Priority
instance GHC.Classes.Eq Plutus.Trace.Scheduler.Priority
instance GHC.Base.Functor Plutus.Trace.Scheduler.WithPriority

module Wallet.Emulator.Error

-- | An error thrown by wallet interactions.
data WalletAPIError

-- | There were insufficient funds to perform the desired operation.
InsufficientFunds :: Text -> WalletAPIError

-- | The change when selecting coins contains less than the minimum amount
--   of Ada.
ChangeHasLessThanNAda :: Value -> Ada -> WalletAPIError

-- | The wallet doesn't have any payment key hash, which should not be
--   possible.
NoPaymentPubKeyHashError :: WalletAPIError

-- | The private key of this public key hash is not known to the wallet.
PaymentPrivateKeyNotFound :: PaymentPubKeyHash -> WalletAPIError

-- | There was an error during off-chain validation.
ValidationError :: ValidationError -> WalletAPIError

-- | There was an error while converting to Cardano.API format.
ToCardanoError :: ToCardanoError -> WalletAPIError

-- | There was an error while creating a payment transaction
PaymentMkTxError :: MkTxError -> WalletAPIError

-- | The called wallet effect is not yet supported in a remote wallet
--   client scenario.
RemoteClientFunctionNotYetSupported :: Text -> WalletAPIError

-- | Some other error occurred.
OtherError :: Text -> WalletAPIError
throwInsufficientFundsError :: Member (Error WalletAPIError) effs => Text -> Eff effs a
throwOtherError :: Member (Error WalletAPIError) effs => Text -> Eff effs a
instance GHC.Generics.Generic Wallet.Emulator.Error.WalletAPIError
instance GHC.Classes.Eq Wallet.Emulator.Error.WalletAPIError
instance GHC.Show.Show Wallet.Emulator.Error.WalletAPIError
instance Prettyprinter.Internal.Pretty Wallet.Emulator.Error.WalletAPIError
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Error.WalletAPIError
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Error.WalletAPIError


-- | The log messages produced by the emulator.
module Wallet.Emulator.LogMessages
data RequestHandlerLogMsg
SlotNoticationTargetVsCurrent :: Slot -> Slot -> RequestHandlerLogMsg
StartWatchingContractAddresses :: RequestHandlerLogMsg
HandleTxFailed :: WalletAPIError -> RequestHandlerLogMsg
UtxoAtFailed :: Address -> RequestHandlerLogMsg
AdjustingUnbalancedTx :: [Ada] -> RequestHandlerLogMsg
data TxBalanceMsg
BalancingUnbalancedTx :: UnbalancedTx -> TxBalanceMsg
FinishedBalancing :: CardanoTx -> TxBalanceMsg
SigningTx :: CardanoTx -> TxBalanceMsg
SubmittingTx :: CardanoTx -> TxBalanceMsg
ValidationFailed :: ValidationPhase -> TxId -> CardanoTx -> ValidationError -> Value -> [Text] -> TxBalanceMsg
_AdjustingUnbalancedTx :: Prism' RequestHandlerLogMsg [Ada]
_BalancingUnbalancedTx :: Prism' TxBalanceMsg UnbalancedTx
_ValidationFailed :: Prism' TxBalanceMsg (ValidationPhase, TxId, CardanoTx, ValidationError, Value, [Text])
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.LogMessages.TxBalanceMsg
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.LogMessages.TxBalanceMsg
instance GHC.Generics.Generic Wallet.Emulator.LogMessages.TxBalanceMsg
instance GHC.Show.Show Wallet.Emulator.LogMessages.TxBalanceMsg
instance GHC.Classes.Eq Wallet.Emulator.LogMessages.TxBalanceMsg
instance Prettyprinter.Internal.Pretty Wallet.Emulator.LogMessages.TxBalanceMsg
instance Prettyprinter.Internal.Pretty Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance GHC.Generics.Generic Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance GHC.Show.Show Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance GHC.Classes.Eq Wallet.Emulator.LogMessages.RequestHandlerLogMsg

module Wallet.Error

module Wallet.Effects
data WalletEffect r
[SubmitTxn] :: CardanoTx -> WalletEffect ()
[OwnAddresses] :: WalletEffect (NonEmpty CardanoAddress)
[BalanceTx] :: UnbalancedTx -> WalletEffect (Either WalletAPIError CardanoTx)

-- | <i>Deprecated: We won't use the wallet for querying blockchain
--   information. See
--   <a>https://plutus-apps.readthedocs.io/en/latest/adr/0005-pab-indexing-solution-integration.html</a></i>
[TotalFunds] :: WalletEffect Value
[WalletAddSignature] :: CardanoTx -> WalletEffect CardanoTx

-- | Sends an unbalanced tx to be balanced, signed and submitted.
[YieldUnbalancedTx] :: UnbalancedTx -> WalletEffect ()
submitTxn :: forall effs_a3mrG. Member WalletEffect effs_a3mrG => CardanoTx -> Eff effs_a3mrG ()
ownAddresses :: forall effs_a3mrH. Member WalletEffect effs_a3mrH => Eff effs_a3mrH (NonEmpty CardanoAddress)
balanceTx :: forall effs_a3mrI. Member WalletEffect effs_a3mrI => UnbalancedTx -> Eff effs_a3mrI (Either WalletAPIError CardanoTx)
totalFunds :: forall effs_a3mrJ. Member WalletEffect effs_a3mrJ => Eff effs_a3mrJ Value
walletAddSignature :: forall effs_a3mrK. Member WalletEffect effs_a3mrK => CardanoTx -> Eff effs_a3mrK CardanoTx
yieldUnbalancedTx :: forall effs_a3mrL. Member WalletEffect effs_a3mrL => UnbalancedTx -> Eff effs_a3mrL ()
data NodeClientEffect r
[PublishTx] :: CardanoTx -> NodeClientEffect ()
[GetClientSlot] :: NodeClientEffect Slot
[GetClientParams] :: NodeClientEffect Params
publishTx :: forall effs_a3mva. Member NodeClientEffect effs_a3mva => CardanoTx -> Eff effs_a3mva ()
getClientSlot :: forall effs_a3mvb. Member NodeClientEffect effs_a3mvb => Eff effs_a3mvb Slot
getClientParams :: forall effs_a3mvc. Member NodeClientEffect effs_a3mvc => Eff effs_a3mvc Params

module Wallet.Emulator.NodeClient
data NodeClientEvent

-- | A transaction has been added to the pool of pending transactions. The
--   value is the fee of the transaction.
TxSubmit :: TxId -> Value -> NodeClientEvent
_TxSubmit :: Iso' NodeClientEvent (TxId, Value)
data NodeClientState
NodeClientState :: Slot -> AddressMap -> NodeClientState
[_clientSlot] :: NodeClientState -> Slot

-- | Full index
[_clientIndex] :: NodeClientState -> AddressMap
emptyNodeClientState :: NodeClientState
clientSlot :: Lens' NodeClientState Slot
clientIndex :: Lens' NodeClientState AddressMap
data ChainClientNotification
BlockValidated :: Block -> ChainClientNotification
SlotChanged :: Slot -> ChainClientNotification
data NodeClientControlEffect r
[ClientNotify] :: ChainClientNotification -> NodeClientControlEffect ()
clientNotify :: forall effs_a3n4B. Member NodeClientControlEffect effs_a3n4B => ChainClientNotification -> Eff effs_a3n4B ()
type NodeClientEffs = '[ChainEffect, State NodeClientState, LogMsg NodeClientEvent]
handleNodeControl :: Members NodeClientEffs effs => Eff (NodeClientControlEffect : effs) ~> Eff effs
handleNodeClient :: Members NodeClientEffs effs => Eff (NodeClientEffect : effs) ~> Eff effs
instance GHC.Classes.Eq Wallet.Emulator.NodeClient.ChainClientNotification
instance GHC.Show.Show Wallet.Emulator.NodeClient.ChainClientNotification
instance GHC.Classes.Eq Wallet.Emulator.NodeClient.NodeClientState
instance GHC.Show.Show Wallet.Emulator.NodeClient.NodeClientState
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.NodeClient.NodeClientEvent
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.NodeClient.NodeClientEvent
instance GHC.Generics.Generic Wallet.Emulator.NodeClient.NodeClientEvent
instance GHC.Show.Show Wallet.Emulator.NodeClient.NodeClientEvent
instance GHC.Classes.Eq Wallet.Emulator.NodeClient.NodeClientEvent
instance Prettyprinter.Internal.Pretty Wallet.Emulator.NodeClient.NodeClientEvent

module Wallet.Emulator.Wallet
newtype SigningProcess
SigningProcess :: (forall effs. Member (Error WalletAPIError) effs => [PaymentPubKeyHash] -> CardanoTx -> Eff effs CardanoTx) -> SigningProcess
[unSigningProcess] :: SigningProcess -> forall effs. Member (Error WalletAPIError) effs => [PaymentPubKeyHash] -> CardanoTx -> Eff effs CardanoTx

-- | A wallet identifier
data Wallet
Wallet :: Maybe String -> WalletId -> Wallet
[prettyWalletName] :: Wallet -> Maybe String
[getWalletId] :: Wallet -> WalletId
toMockWallet :: MockWallet -> Wallet
knownWallets :: [Wallet]
knownWallet :: Integer -> Wallet
fromWalletNumber :: WalletNumber -> Wallet
newtype WalletId
WalletId :: WalletId -> WalletId
[unWalletId] :: WalletId -> WalletId
toBase16 :: WalletId -> Text
fromBase16 :: Text -> Either String WalletId

-- | The <a>MockWallet</a> whose ID is the given wallet ID (if it exists)
walletToMockWallet :: Wallet -> Maybe MockWallet

-- | The same as <tt>walletToMockWallet</tt> but fails with an error
--   instead of returning <tt>Nothing</tt>.
walletToMockWallet' :: Wallet -> MockWallet

-- | The public key of a mock wallet. (Fails if the wallet is not a mock
--   wallet).
mockWalletPaymentPubKey :: Wallet -> PaymentPubKey

-- | The payment public key hash of a mock wallet. (Fails if the wallet is
--   not a mock wallet).
mockWalletPaymentPubKeyHash :: Wallet -> PaymentPubKeyHash

-- | Get the cardano address of a mock wallet. (Fails if the wallet is not
--   a mock wallet).
mockWalletAddress :: Wallet -> CardanoAddress
data WalletEvent
GenericLog :: Text -> WalletEvent
CheckpointLog :: CheckpointLogMsg -> WalletEvent
RequestHandlerLog :: RequestHandlerLogMsg -> WalletEvent
TxBalanceLog :: TxBalanceMsg -> WalletEvent
_TxBalanceLog :: Prism' WalletEvent TxBalanceMsg
_RequestHandlerLog :: Prism' WalletEvent RequestHandlerLogMsg
_CheckpointLog :: Prism' WalletEvent CheckpointLogMsg
_GenericLog :: Prism' WalletEvent Text

-- | The state used by the mock wallet environment.
data WalletState
WalletState :: MockWallet -> NodeClientState -> ChainIndexEmulatorState -> Maybe SigningProcess -> WalletState

-- | Mock wallet with the user's private key.
[_mockWallet] :: WalletState -> MockWallet

-- | The representation of the node, as known by the wallet
[_nodeClient] :: WalletState -> NodeClientState

-- | the chain index info known by the wallet
[_chainIndexEmulatorState] :: WalletState -> ChainIndexEmulatorState

-- | Override the signing process. Used for testing multi-agent use cases.
[_signingProcess] :: WalletState -> Maybe SigningProcess
signingProcess :: Lens' WalletState (Maybe SigningProcess)
nodeClient :: Lens' WalletState NodeClientState
mockWallet :: Lens' WalletState MockWallet
chainIndexEmulatorState :: Lens' WalletState ChainIndexEmulatorState
ownPaymentPrivateKey :: WalletState -> PaymentPrivateKey
ownPaymentPublicKey :: WalletState -> PaymentPubKey

-- | Get the user's own payment public-key address.
ownAddress :: WalletState -> CardanoAddress

-- | An empty wallet using the given private key. for that wallet as the
--   sole watched address.
fromMockWallet :: MockWallet -> WalletState

-- | Empty wallet state for an emulator <a>Wallet</a>. Returns
--   <a>Nothing</a> if the wallet is not known in the emulator.
emptyWalletState :: Wallet -> Maybe WalletState
handleWallet :: (Member (Error WalletAPIError) effs, Member NodeClientEffect effs, Member ChainIndexQueryEffect effs, Member (State WalletState) effs, Member (LogMsg TxBalanceMsg) effs) => WalletEffect ~> Eff effs
handleBalance :: (Member NodeClientEffect effs, Member ChainIndexQueryEffect effs, Member (State WalletState) effs, Member (LogMsg TxBalanceMsg) effs, Member (Error WalletAPIError) effs) => UnbalancedTx -> Eff effs CardanoTx
handleAddSignature :: (Member (State WalletState) effs, Member (Error WalletAPIError) effs) => CardanoTx -> Eff effs CardanoTx
ownOutputs :: forall effs. Member ChainIndexQueryEffect effs => WalletState -> Eff effs (Map TxOutRef DecoratedTxOut)

-- | The default signing process is <a>signWallet</a>
defaultSigningProcess :: MockWallet -> SigningProcess
signWithPrivateKey :: PaymentPrivateKey -> SigningProcess

-- | Sign the transaction by calling <a>signTxnWithKey</a> (throwing a
--   <tt>PrivateKeyNotFound</tt> error if called with a key other than the
--   wallet's private key)
signWallet :: MockWallet -> SigningProcess

-- | Sign the transaction with the private key of the mock wallet.
signTxnWithKey :: Member (Error WalletAPIError) r => MockWallet -> CardanoTx -> PaymentPubKeyHash -> Eff r CardanoTx

-- | Sign the transaction with the private key, if the hash is that of the
--   private key.
signTxWithPrivateKey :: Member (Error WalletAPIError) r => PaymentPrivateKey -> CardanoTx -> PaymentPubKeyHash -> Eff r CardanoTx

-- | Sign the transaction with the given private keys, ignoring the list of
--   public keys that the <a>SigningProcess</a> is passed.
signPrivateKeys :: [PaymentPrivateKey] -> SigningProcess
data SigningProcessControlEffect r
[SetSigningProcess] :: Maybe SigningProcess -> SigningProcessControlEffect ()
setSigningProcess :: forall effs_a3z0c. Member SigningProcessControlEffect effs_a3z0c => Maybe SigningProcess -> Eff effs_a3z0c ()
type SigningProcessEffs = '[State (Maybe SigningProcess), Error WalletAPIError]
handleSigningProcessControl :: Members SigningProcessEffs effs => Eff (SigningProcessControlEffect : effs) ~> Eff effs

-- | An Entity is a thing that can hold <a>Value</a>. Used in the
--   <a>balances</a> function to compute who holds for a given chain state
--   and set of wallets.
data Entity
WalletEntity :: Wallet -> Entity
PubKeyHashEntity :: PubKeyHash -> Entity
ScriptEntity :: ValidatorHash -> Entity
type WalletSet = Map Wallet WalletState

-- | Pick out all the public keys from the set of wallets and map them back
--   to their corresponding wallets.
walletPaymentPubKeyHashes :: WalletSet -> Map PaymentPubKeyHash Wallet

-- | For a set of wallets, convert them into a map of value: entity, where
--   entity is one of <a>Entity</a>.
balances :: ChainState -> WalletSet -> Map Entity Value
instance GHC.Classes.Ord Wallet.Emulator.Wallet.Entity
instance GHC.Classes.Eq Wallet.Emulator.Wallet.Entity
instance GHC.Show.Show Wallet.Emulator.Wallet.Entity
instance GHC.Show.Show Wallet.Emulator.Wallet.WalletState
instance Data.Aeson.Types.ToJSON.ToJSONKey Wallet.Emulator.Wallet.WalletId
instance Data.Data.Data Wallet.Emulator.Wallet.WalletId
instance GHC.Generics.Generic Wallet.Emulator.Wallet.WalletId
instance GHC.Classes.Ord Wallet.Emulator.Wallet.WalletId
instance GHC.Classes.Eq Wallet.Emulator.Wallet.WalletId
instance Data.Aeson.Types.ToJSON.ToJSONKey Wallet.Emulator.Wallet.Wallet
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Wallet.Wallet
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Wallet.Wallet
instance Data.Data.Data Wallet.Emulator.Wallet.Wallet
instance GHC.Generics.Generic Wallet.Emulator.Wallet.Wallet
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Wallet.WalletEvent
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Wallet.WalletEvent
instance GHC.Generics.Generic Wallet.Emulator.Wallet.WalletEvent
instance GHC.Classes.Eq Wallet.Emulator.Wallet.WalletEvent
instance GHC.Show.Show Wallet.Emulator.Wallet.WalletEvent
instance Data.OpenApi.Internal.Schema.ToSchema Wallet.Emulator.Wallet.Wallet
instance Data.OpenApi.Internal.Schema.ToSchema Cardano.Wallet.Primitive.Types.WalletId
instance Data.Data.Data Cardano.Wallet.Primitive.Types.WalletId
instance Data.OpenApi.Internal.Schema.ToSchema Wallet.Emulator.Wallet.WalletId
instance Prettyprinter.Internal.Pretty Wallet.Emulator.Wallet.WalletEvent
instance GHC.Classes.Eq Wallet.Emulator.Wallet.Wallet
instance GHC.Classes.Ord Wallet.Emulator.Wallet.Wallet
instance Web.Internal.HttpApiData.ToHttpApiData Wallet.Emulator.Wallet.Wallet
instance Web.Internal.HttpApiData.FromHttpApiData Wallet.Emulator.Wallet.Wallet
instance GHC.Show.Show Wallet.Emulator.Wallet.Wallet
instance Prettyprinter.Internal.Pretty Wallet.Emulator.Wallet.Wallet
instance GHC.Show.Show Wallet.Emulator.Wallet.WalletId
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Wallet.WalletId
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Wallet.WalletId
instance Web.Internal.HttpApiData.ToHttpApiData Wallet.Emulator.Wallet.WalletId
instance Web.Internal.HttpApiData.FromHttpApiData Wallet.Emulator.Wallet.WalletId
instance GHC.Show.Show Wallet.Emulator.Wallet.SigningProcess


-- | Mock wallet implementation
module Wallet.API
data WalletEffect r
submitTxn :: forall effs_a3mrG. Member WalletEffect effs_a3mrG => CardanoTx -> Eff effs_a3mrG ()

-- | <i>Deprecated: Use ownFirstPaymentPubKeyHash, ownPaymentPubKeyHashes
--   or ownAddresses instead</i>
ownPaymentPubKeyHash :: (Member WalletEffect effs, Member (Error WalletAPIError) effs) => Eff effs PaymentPubKeyHash
ownPaymentPubKeyHashes :: Member WalletEffect effs => Eff effs [PaymentPubKeyHash]
ownFirstPaymentPubKeyHash :: (Member WalletEffect effs, Member (Error WalletAPIError) effs) => Eff effs PaymentPubKeyHash
ownAddresses :: forall effs_a3mrH. Member WalletEffect effs_a3mrH => Eff effs_a3mrH (NonEmpty CardanoAddress)
balanceTx :: forall effs_a3mrI. Member WalletEffect effs_a3mrI => UnbalancedTx -> Eff effs_a3mrI (Either WalletAPIError CardanoTx)
yieldUnbalancedTx :: forall effs_a3mrL. Member WalletEffect effs_a3mrL => UnbalancedTx -> Eff effs_a3mrL ()
data NodeClientEffect r
publishTx :: forall effs_a3mva. Member NodeClientEffect effs_a3mva => CardanoTx -> Eff effs_a3mva ()
getClientSlot :: forall effs_a3mvb. Member NodeClientEffect effs_a3mvb => Eff effs_a3mvb Slot
getClientParams :: forall effs_a3mvc. Member NodeClientEffect effs_a3mvc => Eff effs_a3mvc Params
newtype PubKey
PubKey :: LedgerBytes -> PubKey
[getPubKey] :: PubKey -> LedgerBytes

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | Add the wallet's signature to the transaction and submit it. Returns
--   the transaction with the wallet's signature.
signTxAndSubmit :: Member WalletEffect effs => CardanoTx -> Eff effs CardanoTx

-- | A version of <a>signTxAndSubmit</a> that discards the result.
signTxAndSubmit_ :: Member WalletEffect effs => CardanoTx -> Eff effs ()

-- | Transfer some funds to an address, returning the transaction that was
--   submitted.
--   
--   Note: Due to a constraint in the Cardano ledger, each tx output must
--   have a minimum amount of Ada. Therefore, the funds to transfer will be
--   adjusted to satisfy that constraint. See <a>adjustUnbalancedTx</a>.
payToAddress :: (Member WalletEffect effs, Member (Error WalletAPIError) effs, Member (LogMsg Text) effs, Member (LogMsg RequestHandlerLogMsg) effs) => Params -> SlotRange -> Value -> Address -> Eff effs CardanoTx

-- | Transfer some funds to an address.
payToAddress_ :: (Member WalletEffect effs, Member (Error WalletAPIError) effs, Member (LogMsg Text) effs, Member (LogMsg RequestHandlerLogMsg) effs) => Params -> SlotRange -> Value -> Address -> Eff effs ()

-- | Transfer some funds to an address locked by a public key, returning
--   the transaction that was submitted.
--   
--   Note: Due to a constraint in the Cardano ledger, each tx output must
--   have a minimum amount of Ada. Therefore, the funds to transfer will be
--   adjusted to satisfy that constraint. See <a>adjustUnbalancedTx</a>.
payToPaymentPublicKeyHash :: (Member WalletEffect effs, Member (Error WalletAPIError) effs, Member (LogMsg Text) effs, Member (LogMsg RequestHandlerLogMsg) effs) => Params -> SlotRange -> Value -> PaymentPubKeyHash -> Eff effs CardanoTx

-- | Transfer some funds to an address locked by a public key.
payToPaymentPublicKeyHash_ :: (Member WalletEffect effs, Member (Error WalletAPIError) effs, Member (LogMsg Text) effs, Member (LogMsg RequestHandlerLogMsg) effs) => Params -> SlotRange -> Value -> PaymentPubKeyHash -> Eff effs ()
data Params
Params :: SlotConfig -> PParams -> NetworkId -> Params
[pSlotConfig] :: Params -> SlotConfig

-- | Convert <a>Params</a> to cardano-ledger <a>PParams</a>
[emulatorPParams] :: Params -> PParams
[pNetworkId] :: Params -> NetworkId

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | The slot number. This is a good proxy for time, since on the Cardano
--   blockchain slots pass at a constant rate.
data Slot

-- | An <a>Interval</a> of <a>Slot</a>s.
type SlotRange = Interval Slot

-- | Number of <a>Slot</a>s covered by the interval, if finite. <tt>width
--   (from x) == Nothing</tt>.
width :: SlotRange -> Maybe Integer

-- | The default slot validity range for transactions.
defaultSlotRange :: SlotRange

-- | <tt>interval a b</tt> includes all values that are greater than or
--   equal to <tt>a</tt> and smaller than or equal to <tt>b</tt>. Therefore
--   it includes <tt>a</tt> and <tt>b</tt>.
interval :: a -> a -> Interval a
singleton :: a -> Interval a

-- | Check if an <a>Interval</a> is empty.
isEmpty :: (Enum a, Ord a) => Interval a -> Bool

-- | An <a>Interval</a> that covers every slot.
always :: Interval a

-- | Check whether a value is in an interval.
member :: Ord a => a -> Interval a -> Bool

-- | Check if a value is earlier than the beginning of an <a>Interval</a>.
before :: Ord a => a -> Interval a -> Bool

-- | Check if a value is later than the end of a <a>Interval</a>.
after :: Ord a => a -> Interval a -> Bool

-- | <tt>a <a>contains</a> b</tt> is true if the <a>Interval</a> <tt>b</tt>
--   is entirely contained in <tt>a</tt>. That is, <tt>a <a>contains</a>
--   b</tt> if for every entry <tt>s</tt>, if <tt>member s b</tt> then
--   <tt>member s a</tt>.
contains :: Ord a => Interval a -> Interval a -> Bool

-- | An error thrown by wallet interactions.
data WalletAPIError

-- | There were insufficient funds to perform the desired operation.
InsufficientFunds :: Text -> WalletAPIError

-- | The change when selecting coins contains less than the minimum amount
--   of Ada.
ChangeHasLessThanNAda :: Value -> Ada -> WalletAPIError

-- | The wallet doesn't have any payment key hash, which should not be
--   possible.
NoPaymentPubKeyHashError :: WalletAPIError

-- | The private key of this public key hash is not known to the wallet.
PaymentPrivateKeyNotFound :: PaymentPubKeyHash -> WalletAPIError

-- | There was an error during off-chain validation.
ValidationError :: ValidationError -> WalletAPIError

-- | There was an error while converting to Cardano.API format.
ToCardanoError :: ToCardanoError -> WalletAPIError

-- | There was an error while creating a payment transaction
PaymentMkTxError :: MkTxError -> WalletAPIError

-- | The called wallet effect is not yet supported in a remote wallet
--   client scenario.
RemoteClientFunctionNotYetSupported :: Text -> WalletAPIError

-- | Some other error occurred.
OtherError :: Text -> WalletAPIError
throwInsufficientFundsError :: Member (Error WalletAPIError) effs => Text -> Eff effs a
throwOtherError :: Member (Error WalletAPIError) effs => Text -> Eff effs a

module Wallet


-- | Support for visualisation of a blockchain as a graph.
module Wallet.Graph

-- | Compute the <a>FlowLink</a>s for a <a>Blockchain</a> given a set of
--   known <a>PubKey</a>s.
txnFlows :: [PubKey] -> Blockchain -> [FlowLink]

-- | Construct a graph from a list of <a>FlowLink</a>s.
graph :: [FlowLink] -> FlowGraph

-- | The flow graph, consisting of a set of nodes (<a>TxRef</a>s) and edges
--   (<a>FlowLink</a>s).
data FlowGraph

-- | A link in the flow graph.
data FlowLink

-- | A wrapper around the first 8 digits of a <a>TxId</a>.
data TxRef

-- | The owner of an unspent transaction output.
data UtxOwner

-- | The location of a transaction in a blockchain specified by two
--   indices: the index of the containing block in the chain, and the index
--   of the transaction within the block.
data UtxoLocation
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.UtxOwner
instance GHC.Generics.Generic Wallet.Graph.UtxOwner
instance GHC.Show.Show Wallet.Graph.UtxOwner
instance GHC.Classes.Ord Wallet.Graph.UtxOwner
instance GHC.Classes.Eq Wallet.Graph.UtxOwner
instance GHC.Generics.Generic Wallet.Graph.TxRef
instance GHC.Show.Show Wallet.Graph.TxRef
instance GHC.Classes.Ord Wallet.Graph.TxRef
instance GHC.Classes.Eq Wallet.Graph.TxRef
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.UtxoLocation
instance GHC.Generics.Generic Wallet.Graph.UtxoLocation
instance GHC.Show.Show Wallet.Graph.UtxoLocation
instance GHC.Classes.Ord Wallet.Graph.UtxoLocation
instance GHC.Classes.Eq Wallet.Graph.UtxoLocation
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.FlowLink
instance GHC.Generics.Generic Wallet.Graph.FlowLink
instance GHC.Show.Show Wallet.Graph.FlowLink
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.FlowGraph
instance GHC.Generics.Generic Wallet.Graph.FlowGraph
instance GHC.Show.Show Wallet.Graph.FlowGraph
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.TxRef

module Wallet.Rollup.Types
data TxKey
TxKey :: TxId -> Integer -> TxKey
[_txKeyTxId] :: TxKey -> TxId
[_txKeyTxOutRefIdx] :: TxKey -> Integer
data SequenceId
SequenceId :: Int -> Int -> SequenceId
[slotIndex] :: SequenceId -> Int
[txIndex] :: SequenceId -> Int
txIndexL :: Lens' SequenceId Int
slotIndexL :: Lens' SequenceId Int
data DereferencedInput
DereferencedInput :: TxIn -> TxOut -> DereferencedInput
[originalInput] :: DereferencedInput -> TxIn
[refersTo] :: DereferencedInput -> TxOut
InputNotFound :: TxKey -> DereferencedInput
isFound :: DereferencedInput -> Bool
data BeneficialOwner
OwnedByPaymentPubKey :: PaymentPubKeyHash -> BeneficialOwner
OwnedByScript :: ValidatorHash -> BeneficialOwner
toBeneficialOwner :: TxOut -> BeneficialOwner
data AnnotatedTx
AnnotatedTx :: SequenceId -> TxId -> CardanoTx -> [DereferencedInput] -> Map BeneficialOwner Value -> Bool -> AnnotatedTx
[sequenceId] :: AnnotatedTx -> SequenceId
[txId] :: AnnotatedTx -> TxId
[tx] :: AnnotatedTx -> CardanoTx
[dereferencedInputs] :: AnnotatedTx -> [DereferencedInput]
[balances] :: AnnotatedTx -> Map BeneficialOwner Value
[valid] :: AnnotatedTx -> Bool
data Rollup
Rollup :: Map TxKey TxOut -> Map BeneficialOwner Value -> Rollup
[_previousOutputs] :: Rollup -> Map TxKey TxOut
[_rollingBalances] :: Rollup -> Map BeneficialOwner Value
rollingBalances :: Lens' Rollup (Map BeneficialOwner Value)
previousOutputs :: Lens' Rollup (Map TxKey TxOut)
data RollupState
RollupState :: SequenceId -> Rollup -> [AnnotatedTx] -> RollupState
[_currentSequenceId] :: RollupState -> SequenceId
[_rollup] :: RollupState -> Rollup
[_annotatedTransactions] :: RollupState -> [AnnotatedTx]
rollup :: Lens' RollupState Rollup
currentSequenceId :: Lens' RollupState SequenceId
annotatedTransactions :: Lens' RollupState [AnnotatedTx]
instance GHC.Generics.Generic Wallet.Rollup.Types.Rollup
instance GHC.Classes.Eq Wallet.Rollup.Types.Rollup
instance GHC.Show.Show Wallet.Rollup.Types.Rollup
instance Data.OpenApi.Internal.Schema.ToSchema Wallet.Rollup.Types.DereferencedInput
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.DereferencedInput
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.DereferencedInput
instance GHC.Generics.Generic Wallet.Rollup.Types.DereferencedInput
instance GHC.Show.Show Wallet.Rollup.Types.DereferencedInput
instance GHC.Classes.Eq Wallet.Rollup.Types.DereferencedInput
instance Data.Aeson.Types.ToJSON.ToJSONKey Wallet.Rollup.Types.BeneficialOwner
instance Data.Aeson.Types.FromJSON.FromJSONKey Wallet.Rollup.Types.BeneficialOwner
instance Data.OpenApi.Internal.Schema.ToSchema Wallet.Rollup.Types.BeneficialOwner
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.BeneficialOwner
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.BeneficialOwner
instance GHC.Generics.Generic Wallet.Rollup.Types.BeneficialOwner
instance GHC.Classes.Ord Wallet.Rollup.Types.BeneficialOwner
instance GHC.Show.Show Wallet.Rollup.Types.BeneficialOwner
instance GHC.Classes.Eq Wallet.Rollup.Types.BeneficialOwner
instance Data.OpenApi.Internal.Schema.ToSchema Wallet.Rollup.Types.AnnotatedTx
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.AnnotatedTx
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.AnnotatedTx
instance GHC.Generics.Generic Wallet.Rollup.Types.AnnotatedTx
instance GHC.Show.Show Wallet.Rollup.Types.AnnotatedTx
instance GHC.Classes.Eq Wallet.Rollup.Types.AnnotatedTx
instance Data.OpenApi.Internal.Schema.ToSchema Wallet.Rollup.Types.TxKey
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.TxKey
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.TxKey
instance GHC.Generics.Generic Wallet.Rollup.Types.TxKey
instance GHC.Classes.Ord Wallet.Rollup.Types.TxKey
instance GHC.Classes.Eq Wallet.Rollup.Types.TxKey
instance GHC.Show.Show Wallet.Rollup.Types.TxKey
instance Data.OpenApi.Internal.Schema.ToSchema Wallet.Rollup.Types.SequenceId
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.SequenceId
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.SequenceId
instance GHC.Generics.Generic Wallet.Rollup.Types.SequenceId
instance GHC.Show.Show Wallet.Rollup.Types.SequenceId
instance GHC.Classes.Ord Wallet.Rollup.Types.SequenceId
instance GHC.Classes.Eq Wallet.Rollup.Types.SequenceId
instance Prettyprinter.Internal.Pretty Wallet.Rollup.Types.TxKey

module Wallet.Rollup
doAnnotateBlockchain :: Monad m => Blockchain -> m [[AnnotatedTx]]
initialRollup :: Rollup
annotateBlockchain :: Monad m => Blockchain -> StateT Rollup m [[AnnotatedTx]]
data Rollup
initialState :: RollupState
handleChainEvent :: RollupState -> ChainEvent -> RollupState
getAnnotatedTransactions :: RollupState -> [[AnnotatedTx]]


-- | Defines a number of types that are used in Wallet.XXX modules
module Wallet.Types

-- | Unique ID for contract instance
newtype ContractInstanceId
ContractInstanceId :: UUID -> ContractInstanceId
[unContractInstanceId] :: ContractInstanceId -> UUID

-- | A pure list of all <a>ContractInstanceId</a> values. To be used in
--   testing.
contractInstanceIDs :: [ContractInstanceId]
randomID :: IO ContractInstanceId
data ContractActivityStatus
Active :: ContractActivityStatus
Stopped :: ContractActivityStatus
Done :: ContractActivityStatus
parseContractActivityStatus :: Text -> Maybe ContractActivityStatus
data Notification
Notification :: ContractInstanceId -> EndpointDescription -> Value -> Notification
[notificationContractID] :: Notification -> ContractInstanceId
[notificationContractEndpoint] :: Notification -> EndpointDescription
[notificationContractArg] :: Notification -> Value
data NotificationError
EndpointNotAvailable :: ContractInstanceId -> EndpointDescription -> NotificationError
MoreThanOneEndpointAvailable :: ContractInstanceId -> EndpointDescription -> NotificationError
InstanceDoesNotExist :: ContractInstanceId -> NotificationError

-- | Indicates that the target contract does not have the expected schema
--   
--   TODO: SCP-2137 Not currently used. As endpoint parameter decoding
--   happends inside the Contract and a throwError is used is decoding
--   failed. However, still valuable to be used by the PAB to throw an
--   error is an endpoint could not be decoded.
NotificationJSONDecodeError :: EndpointDescription -> Value -> String -> NotificationError
newtype EndpointDescription
EndpointDescription :: String -> EndpointDescription
[getEndpointDescription] :: EndpointDescription -> String
newtype EndpointValue a
EndpointValue :: a -> EndpointValue a
[unEndpointValue] :: EndpointValue a -> a
instance Wallet.Types.AsNotificationError Wallet.Types.NotificationError
instance Prettyprinter.Internal.Pretty Wallet.Types.ContractInstanceId
instance Data.OpenApi.Internal.Schema.ToSchema Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.ToJSON.ToJSONKey Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.FromJSON.FromJSONKey Wallet.Types.ContractInstanceId
instance GHC.Generics.Generic Wallet.Types.ContractInstanceId
instance GHC.Show.Show Wallet.Types.ContractInstanceId
instance GHC.Classes.Ord Wallet.Types.ContractInstanceId
instance GHC.Classes.Eq Wallet.Types.ContractInstanceId
instance Data.OpenApi.Internal.Schema.ToSchema Wallet.Types.ContractActivityStatus
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.ContractActivityStatus
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.ContractActivityStatus
instance GHC.Generics.Generic Wallet.Types.ContractActivityStatus
instance GHC.Show.Show Wallet.Types.ContractActivityStatus
instance GHC.Classes.Eq Wallet.Types.ContractActivityStatus
instance Data.OpenApi.Internal.Schema.ToSchema Wallet.Types.EndpointDescription
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.EndpointDescription
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.EndpointDescription
instance Prettyprinter.Internal.Pretty Wallet.Types.EndpointDescription
instance Data.String.IsString Wallet.Types.EndpointDescription
instance Language.Haskell.TH.Syntax.Lift Wallet.Types.EndpointDescription
instance GHC.Show.Show Wallet.Types.EndpointDescription
instance GHC.Generics.Generic Wallet.Types.EndpointDescription
instance GHC.Classes.Ord Wallet.Types.EndpointDescription
instance GHC.Classes.Eq Wallet.Types.EndpointDescription
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Wallet.Types.EndpointValue a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Wallet.Types.EndpointValue a)
instance GHC.Show.Show a => GHC.Show.Show (Wallet.Types.EndpointValue a)
instance GHC.Generics.Generic (Wallet.Types.EndpointValue a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Wallet.Types.EndpointValue a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Wallet.Types.EndpointValue a)
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.Notification
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.Notification
instance GHC.Generics.Generic Wallet.Types.Notification
instance GHC.Show.Show Wallet.Types.Notification
instance GHC.Classes.Eq Wallet.Types.Notification
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.NotificationError
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.NotificationError
instance GHC.Generics.Generic Wallet.Types.NotificationError
instance GHC.Show.Show Wallet.Types.NotificationError
instance GHC.Classes.Eq Wallet.Types.NotificationError
instance GHC.Show.Show a => Prettyprinter.Internal.Pretty (Wallet.Types.EndpointValue a)
instance Prettyprinter.Internal.Pretty Wallet.Types.NotificationError
instance Prettyprinter.Internal.Pretty Wallet.Types.Notification

module Plutus.Trace.Effects.ContractInstanceId
data ContractInstanceIdEff r
nextId :: forall effs_a48Lo. Member ContractInstanceIdEff effs_a48Lo => Eff effs_a48Lo ContractInstanceId

-- | Handle <a>ContractInstanceIdEff</a> using the list of IDs
--   <a>contractInstanceIDs</a>.
handleDeterministicIds :: Eff (ContractInstanceIdEff : effs) ~> Eff effs

-- | Handle <a>ContractInstanceIdEff</a> using a random number generator
handleRandomIds :: (LastMember m effs, MonadIO m) => Eff (ContractInstanceIdEff : effs) ~> Eff effs

module Plutus.Contract.Effects

-- | Requests that <tt>Contract</tt>s can make
data PABReq
AdjustUnbalancedTxReq :: UnbalancedTx -> PABReq
AwaitSlotReq :: Slot -> PABReq
AwaitTimeReq :: POSIXTime -> PABReq
AwaitUtxoSpentReq :: TxOutRef -> PABReq
AwaitUtxoProducedReq :: CardanoAddress -> PABReq
AwaitTxStatusChangeReq :: TxId -> PABReq
AwaitTxOutStatusChangeReq :: TxOutRef -> PABReq
CurrentNodeClientSlotReq :: PABReq
CurrentChainIndexSlotReq :: PABReq
CurrentTimeReq :: PABReq
CurrentNodeClientTimeRangeReq :: PABReq
GetParamsReq :: PABReq
OwnContractInstanceIdReq :: PABReq
OwnAddressesReq :: PABReq
ChainIndexQueryReq :: ChainIndexQuery -> PABReq
BalanceTxReq :: UnbalancedTx -> PABReq
WriteBalancedTxReq :: CardanoTx -> PABReq
ExposeEndpointReq :: ActiveEndpoint -> PABReq
PosixTimeRangeToContainedSlotRangeReq :: POSIXTimeRange -> PABReq
YieldUnbalancedTxReq :: UnbalancedTx -> PABReq
_AdjustUnbalancedTxReq :: Prism' PABReq UnbalancedTx
_AwaitSlotReq :: Prism' PABReq Slot
_AwaitTimeReq :: Prism' PABReq POSIXTime
_AwaitUtxoSpentReq :: Prism' PABReq TxOutRef
_AwaitUtxoProducedReq :: Prism' PABReq CardanoAddress
_CurrentNodeClientSlotReq :: Prism' PABReq ()
_CurrentChainIndexSlotReq :: Prism' PABReq ()
_CurrentTimeReq :: Prism' PABReq ()
_CurrentNodeClientTimeRangeReq :: Prism' PABReq ()
_AwaitTxStatusChangeReq :: Prism' PABReq TxId
_AwaitTxOutStatusChangeReq :: Prism' PABReq TxOutRef
_GetParamsReq :: Prism' PABReq ()
_OwnContractInstanceIdReq :: Prism' PABReq ()
_OwnAddressesReq :: Prism' PABReq ()
_ChainIndexQueryReq :: Prism' PABReq ChainIndexQuery
_BalanceTxReq :: Prism' PABReq UnbalancedTx
_WriteBalancedTxReq :: Prism' PABReq CardanoTx
_ExposeEndpointReq :: Prism' PABReq ActiveEndpoint
_PosixTimeRangeToContainedSlotRangeReq :: Prism' PABReq POSIXTimeRange
_YieldUnbalancedTxReq :: Prism' PABReq UnbalancedTx
_DatumFromHash :: Prism' ChainIndexQuery DatumHash
_ValidatorFromHash :: Prism' ChainIndexQuery ValidatorHash
_MintingPolicyFromHash :: Prism' ChainIndexQuery MintingPolicyHash
_RedeemerFromHash :: Prism' ChainIndexQuery RedeemerHash
_TxOutFromRef :: Prism' ChainIndexQuery TxOutRef
_TxFromTxId :: Prism' ChainIndexQuery TxId
_UnspentTxOutFromRef :: Prism' ChainIndexQuery TxOutRef
_UtxoSetMembership :: Prism' ChainIndexQuery TxOutRef
_UtxoSetAtAddress :: Prism' ChainIndexQuery (PageQuery TxOutRef, Credential)
_UtxoSetWithCurrency :: Prism' ChainIndexQuery (PageQuery TxOutRef, AssetClass)
_TxsFromTxIds :: Prism' ChainIndexQuery [TxId]
_TxoSetAtAddress :: Prism' ChainIndexQuery (PageQuery TxOutRef, Credential)
_GetTip :: Prism' ChainIndexQuery ()

-- | Responses that <tt>Contract</tt>s receive
data PABResp
AdjustUnbalancedTxResp :: Either ToCardanoError UnbalancedTx -> PABResp
AwaitSlotResp :: Slot -> PABResp
AwaitTimeResp :: POSIXTime -> PABResp
AwaitUtxoSpentResp :: ChainIndexTx -> PABResp
AwaitUtxoProducedResp :: NonEmpty ChainIndexTx -> PABResp
AwaitTxStatusChangeResp :: TxId -> TxStatus -> PABResp
AwaitTxOutStatusChangeResp :: TxOutRef -> TxOutStatus -> PABResp
CurrentNodeClientSlotResp :: Slot -> PABResp
CurrentChainIndexSlotResp :: Slot -> PABResp
CurrentTimeResp :: POSIXTime -> PABResp
CurrentNodeClientTimeRangeResp :: (POSIXTime, POSIXTime) -> PABResp
GetParamsResp :: Params -> PABResp
OwnContractInstanceIdResp :: ContractInstanceId -> PABResp
OwnAddressesResp :: NonEmpty CardanoAddress -> PABResp
ChainIndexQueryResp :: ChainIndexResponse -> PABResp
BalanceTxResp :: BalanceTxResponse -> PABResp
WriteBalancedTxResp :: WriteBalancedTxResponse -> PABResp
ExposeEndpointResp :: EndpointDescription -> EndpointValue Value -> PABResp
PosixTimeRangeToContainedSlotRangeResp :: Either SlotConversionError SlotRange -> PABResp
YieldUnbalancedTxResp :: () -> PABResp
_AdjustUnbalancedTxResp :: Prism' PABResp (Either ToCardanoError UnbalancedTx)
_AwaitSlotResp :: Prism' PABResp Slot
_AwaitTimeResp :: Prism' PABResp POSIXTime
_AwaitUtxoSpentResp :: Prism' PABResp ChainIndexTx
_AwaitUtxoProducedResp :: Prism' PABResp (NonEmpty ChainIndexTx)
_CurrentNodeClientSlotResp :: Prism' PABResp Slot
_CurrentChainIndexSlotResp :: Prism' PABResp Slot
_CurrentTimeResp :: Prism' PABResp POSIXTime
_CurrentNodeClientTimeRangeResp :: Prism' PABResp (POSIXTime, POSIXTime)
_AwaitTxStatusChangeResp :: Prism' PABResp (TxId, TxStatus)
_AwaitTxStatusChangeResp' :: TxId -> Prism' PABResp TxStatus
_AwaitTxOutStatusChangeResp :: Prism' PABResp (TxOutRef, TxOutStatus)
_GetParamsResp :: Prism' PABResp Params
_OwnContractInstanceIdResp :: Prism' PABResp ContractInstanceId
_OwnAddressesResp :: Prism' PABResp (NonEmpty CardanoAddress)
_ChainIndexQueryResp :: Prism' PABResp ChainIndexResponse
_BalanceTxResp :: Prism' PABResp BalanceTxResponse
_WriteBalancedTxResp :: Prism' PABResp WriteBalancedTxResponse
_ExposeEndpointResp :: Prism' PABResp (EndpointDescription, EndpointValue Value)
_PosixTimeRangeToContainedSlotRangeResp :: Prism' PABResp (Either SlotConversionError SlotRange)
_YieldUnbalancedTxResp :: Prism' PABResp ()
_DatumHashResponse :: Prism' ChainIndexResponse (Maybe Datum)
_ValidatorHashResponse :: Prism' ChainIndexResponse (Maybe (Versioned Validator))
_MintingPolicyHashResponse :: Prism' ChainIndexResponse (Maybe (Versioned MintingPolicy))
_RedeemerHashResponse :: Prism' ChainIndexResponse (Maybe Redeemer)
_TxOutRefResponse :: Prism' ChainIndexResponse (Maybe DecoratedTxOut)
_UnspentTxOutResponse :: Prism' ChainIndexResponse (Maybe DecoratedTxOut)
_TxIdResponse :: Prism' ChainIndexResponse (Maybe ChainIndexTx)
_UtxoSetMembershipResponse :: Prism' ChainIndexResponse IsUtxoResponse
_UtxoSetAtResponse :: Prism' ChainIndexResponse UtxosResponse
_UtxoSetWithCurrencyResponse :: Prism' ChainIndexResponse UtxosResponse
_TxIdsResponse :: Prism' ChainIndexResponse [ChainIndexTx]
_TxoSetAtResponse :: Prism' ChainIndexResponse TxosResponse
_GetTipResponse :: Prism' ChainIndexResponse Tip
matches :: PABReq -> PABResp -> Bool

-- | Represents all possible chain index queries. Each constructor contains
--   the input(s) needed for the query. These possible queries correspond
--   to the constructors of the data type <a>ChainIndexQueryEffect</a>.
data ChainIndexQuery
DatumFromHash :: DatumHash -> ChainIndexQuery
ValidatorFromHash :: ValidatorHash -> ChainIndexQuery
MintingPolicyFromHash :: MintingPolicyHash -> ChainIndexQuery
StakeValidatorFromHash :: StakeValidatorHash -> ChainIndexQuery
RedeemerFromHash :: RedeemerHash -> ChainIndexQuery
TxOutFromRef :: TxOutRef -> ChainIndexQuery
UnspentTxOutFromRef :: TxOutRef -> ChainIndexQuery
TxFromTxId :: TxId -> ChainIndexQuery
UtxoSetMembership :: TxOutRef -> ChainIndexQuery
UtxoSetAtAddress :: PageQuery TxOutRef -> Credential -> ChainIndexQuery
UnspentTxOutSetAtAddress :: PageQuery TxOutRef -> Credential -> ChainIndexQuery
DatumsAtAddress :: PageQuery TxOutRef -> Credential -> ChainIndexQuery
UtxoSetWithCurrency :: PageQuery TxOutRef -> AssetClass -> ChainIndexQuery
TxsFromTxIds :: [TxId] -> ChainIndexQuery
TxoSetAtAddress :: PageQuery TxOutRef -> Credential -> ChainIndexQuery
GetTip :: ChainIndexQuery

-- | Represents all possible responses to chain index queries. Each
--   constructor contain the output resulting for the chain index query.
--   These possible responses come from the data type
--   <a>ChainIndexQueryEffect</a>.
data ChainIndexResponse
DatumHashResponse :: Maybe Datum -> ChainIndexResponse
ValidatorHashResponse :: Maybe (Versioned Validator) -> ChainIndexResponse
MintingPolicyHashResponse :: Maybe (Versioned MintingPolicy) -> ChainIndexResponse
StakeValidatorHashResponse :: Maybe (Versioned StakeValidator) -> ChainIndexResponse
TxOutRefResponse :: Maybe DecoratedTxOut -> ChainIndexResponse
UnspentTxOutResponse :: Maybe DecoratedTxOut -> ChainIndexResponse
RedeemerHashResponse :: Maybe Redeemer -> ChainIndexResponse
TxIdResponse :: Maybe ChainIndexTx -> ChainIndexResponse
UtxoSetMembershipResponse :: IsUtxoResponse -> ChainIndexResponse
UtxoSetAtResponse :: UtxosResponse -> ChainIndexResponse
UnspentTxOutsAtResponse :: QueryResponse [(TxOutRef, DecoratedTxOut)] -> ChainIndexResponse
DatumsAtResponse :: QueryResponse [Datum] -> ChainIndexResponse
UtxoSetWithCurrencyResponse :: UtxosResponse -> ChainIndexResponse
TxIdsResponse :: [ChainIndexTx] -> ChainIndexResponse
TxoSetAtResponse :: TxosResponse -> ChainIndexResponse
GetTipResponse :: Tip -> ChainIndexResponse
data BalanceTxResponse
BalanceTxFailed :: WalletAPIError -> BalanceTxResponse
BalanceTxSuccess :: CardanoTx -> BalanceTxResponse
balanceTxResponse :: Iso' BalanceTxResponse (Either WalletAPIError CardanoTx)
data WriteBalancedTxResponse
WriteBalancedTxFailed :: WalletAPIError -> WriteBalancedTxResponse
WriteBalancedTxSuccess :: CardanoTx -> WriteBalancedTxResponse
writeBalancedTxResponse :: Iso' WriteBalancedTxResponse (Either WalletAPIError CardanoTx)
data ActiveEndpoint
ActiveEndpoint :: EndpointDescription -> Maybe Value -> ActiveEndpoint

-- | The name of the endpoint
[aeDescription] :: ActiveEndpoint -> EndpointDescription

-- | Data that should be shown to the user
[aeMetadata] :: ActiveEndpoint -> Maybe Value
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.Contract.Effects.ChainIndexQuery
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.ChainIndexQuery
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.ChainIndexQuery
instance GHC.Generics.Generic Plutus.Contract.Effects.ChainIndexQuery
instance GHC.Show.Show Plutus.Contract.Effects.ChainIndexQuery
instance GHC.Classes.Eq Plutus.Contract.Effects.ChainIndexQuery
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.ChainIndexResponse
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.ChainIndexResponse
instance GHC.Generics.Generic Plutus.Contract.Effects.ChainIndexResponse
instance GHC.Show.Show Plutus.Contract.Effects.ChainIndexResponse
instance GHC.Classes.Eq Plutus.Contract.Effects.ChainIndexResponse
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.BalanceTxResponse
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.BalanceTxResponse
instance GHC.Generics.Generic Plutus.Contract.Effects.BalanceTxResponse
instance GHC.Show.Show Plutus.Contract.Effects.BalanceTxResponse
instance GHC.Classes.Eq Plutus.Contract.Effects.BalanceTxResponse
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.WriteBalancedTxResponse
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.WriteBalancedTxResponse
instance GHC.Generics.Generic Plutus.Contract.Effects.WriteBalancedTxResponse
instance GHC.Show.Show Plutus.Contract.Effects.WriteBalancedTxResponse
instance GHC.Classes.Eq Plutus.Contract.Effects.WriteBalancedTxResponse
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.PABResp
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.PABResp
instance GHC.Generics.Generic Plutus.Contract.Effects.PABResp
instance GHC.Show.Show Plutus.Contract.Effects.PABResp
instance GHC.Classes.Eq Plutus.Contract.Effects.PABResp
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.Contract.Effects.ActiveEndpoint
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.ActiveEndpoint
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.ActiveEndpoint
instance GHC.Generics.Generic Plutus.Contract.Effects.ActiveEndpoint
instance GHC.Show.Show Plutus.Contract.Effects.ActiveEndpoint
instance GHC.Classes.Eq Plutus.Contract.Effects.ActiveEndpoint
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.Contract.Effects.PABReq
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.PABReq
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.PABReq
instance GHC.Generics.Generic Plutus.Contract.Effects.PABReq
instance GHC.Show.Show Plutus.Contract.Effects.PABReq
instance GHC.Classes.Eq Plutus.Contract.Effects.PABReq
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.PABReq
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.ActiveEndpoint
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.PABResp
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.WriteBalancedTxResponse
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.BalanceTxResponse
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.ChainIndexResponse
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.ChainIndexQuery

module Plutus.Contract.Error
data ContractError
WalletContractError :: WalletAPIError -> ContractError
ChainIndexContractError :: Text -> ChainIndexResponse -> ContractError
EmulatorAssertionContractError :: AssertionError -> ContractError
ConstraintResolutionContractError :: MkTxError -> ContractError
TxConstraintResolutionContractError :: MkTxError -> ContractError
TxToCardanoConvertContractError :: ToCardanoError -> ContractError
ResumableContractError :: MatchingError -> ContractError
CCheckpointContractError :: CheckpointError -> ContractError
EndpointDecodeContractError :: EndpointDescription -> EndpointValue Value -> Text -> ContractError

-- | The endpoint description which the decoding error occurred from
[eeEndpointDescription] :: ContractError -> EndpointDescription

-- | The endpoint value that was used as an endpoint parameter
[eeEndpointValue] :: ContractError -> EndpointValue Value

-- | JSON decoding error message
[eeErrorMessage] :: ContractError -> Text
OtherContractError :: Text -> ContractError
class AsContractError r_a4TlE
_ContractError :: AsContractError r_a4TlE => Prism' r_a4TlE ContractError
_WalletContractError :: AsContractError r_a4TlE => Prism' r_a4TlE WalletAPIError
_ChainIndexContractError :: AsContractError r_a4TlE => Prism' r_a4TlE (Text, ChainIndexResponse)
_EmulatorAssertionContractError :: AsContractError r_a4TlE => Prism' r_a4TlE AssertionError
_ConstraintResolutionContractError :: AsContractError r_a4TlE => Prism' r_a4TlE MkTxError
_TxConstraintResolutionContractError :: AsContractError r_a4TlE => Prism' r_a4TlE MkTxError
_TxToCardanoConvertContractError :: AsContractError r_a4TlE => Prism' r_a4TlE ToCardanoError
_ResumableContractError :: AsContractError r_a4TlE => Prism' r_a4TlE MatchingError
_CCheckpointContractError :: AsContractError r_a4TlE => Prism' r_a4TlE CheckpointError
_EndpointDecodeContractError :: AsContractError r_a4TlE => Prism' r_a4TlE (EndpointDescription, EndpointValue Value, Text)
_OtherContractError :: AsContractError r_a4TlE => Prism' r_a4TlE Text

-- | An error
newtype MatchingError
WrongVariantError :: Text -> MatchingError
[unWrongVariantError] :: MatchingError -> Text
class AsMatchingError r_a4SHi
_MatchingError :: AsMatchingError r_a4SHi => Prism' r_a4SHi MatchingError
_WrongVariantError :: AsMatchingError r_a4SHi => Prism' r_a4SHi Text

-- | An error emitted when an <tt>Assertion</tt> fails.
newtype AssertionError
GenericAssertion :: Text -> AssertionError
[unAssertionError] :: AssertionError -> Text
class AsAssertionError r_a4SOO
_AssertionError :: AsAssertionError r_a4SOO => Prism' r_a4SOO AssertionError
_GenericAssertion :: AsAssertionError r_a4SOO => Prism' r_a4SOO Text
instance Plutus.Contract.Error.AsContractError Plutus.Contract.Error.ContractError
instance Plutus.Contract.Error.AsContractError Data.Text.Internal.Text
instance Plutus.Contract.Error.AsAssertionError Plutus.Contract.Error.ContractError
instance Plutus.Contract.Checkpoint.AsCheckpointError Plutus.Contract.Error.ContractError
instance Prettyprinter.Internal.Pretty Plutus.Contract.Error.ContractError
instance Data.String.IsString Plutus.Contract.Error.ContractError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Error.ContractError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Error.ContractError
instance GHC.Generics.Generic Plutus.Contract.Error.ContractError
instance GHC.Classes.Eq Plutus.Contract.Error.ContractError
instance GHC.Show.Show Plutus.Contract.Error.ContractError
instance Plutus.Contract.Error.AsAssertionError Plutus.Contract.Error.AssertionError
instance Plutus.Contract.Error.AsAssertionError Data.Text.Internal.Text
instance Prettyprinter.Internal.Pretty Plutus.Contract.Error.AssertionError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Error.AssertionError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Error.AssertionError
instance GHC.Generics.Generic Plutus.Contract.Error.AssertionError
instance GHC.Classes.Eq Plutus.Contract.Error.AssertionError
instance GHC.Show.Show Plutus.Contract.Error.AssertionError
instance Plutus.Contract.Error.AsMatchingError Plutus.Contract.Error.MatchingError
instance Prettyprinter.Internal.Pretty Plutus.Contract.Error.MatchingError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Error.MatchingError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Error.MatchingError
instance GHC.Generics.Generic Plutus.Contract.Error.MatchingError
instance GHC.Show.Show Plutus.Contract.Error.MatchingError
instance GHC.Classes.Ord Plutus.Contract.Error.MatchingError
instance GHC.Classes.Eq Plutus.Contract.Error.MatchingError

module Plutus.Contract.Types

-- | Effects that are available to contracts.
type ContractEffs w e = '[Error e, LogMsg Value, Writer w, Checkpoint, Resumable PABResp PABReq]
handleContractEffs :: forall w e effs a. (Member (Error e) effs, Member (State CheckpointStore) effs, Member (State CheckpointKey) effs, Member (State (AccumState w)) effs, Member (LogMsg CheckpointLogMsg) effs, Member (LogMsg Value) effs, Monoid w) => Eff (ContractEffs w e) a -> Eff effs (Maybe (MultiRequestContStatus PABResp PABReq effs a))

-- | <tt>Contract w s e a</tt> is a contract with schema <tt>s</tt>,
--   producing a value of type <tt>a</tt> or an error <tt>e</tt>. See note
--   [Contract Schema].
newtype Contract w (s :: Row *) e a
Contract :: Eff (ContractEffs w e) a -> Contract w (s :: Row *) e a
[unContract] :: Contract w (s :: Row *) e a -> Eff (ContractEffs w e) a

-- | Class of types that can be trivially converted to a <a>Contract</a>.
--   For use with functions where it is convenient to accept both
--   <a>Contract</a> and <a>Promise</a> types.
class IsContract c
toContract :: IsContract c => c w s e a -> Contract w s e a

-- | A wrapper indicating that this contract starts with a waiting action.
--   For use with <tt>select</tt>.
newtype Promise w (s :: Row *) e a
Promise :: Contract w s e a -> Promise w (s :: Row *) e a
[awaitPromise] :: Promise w (s :: Row *) e a -> Contract w s e a

-- | Run more <a>Contract</a> code after the <a>Promise</a>.
promiseBind :: Promise w s e a -> (a -> Contract w s e b) -> Promise w s e b

-- | Lift a mapping function for <a>Contract</a> to a mapping function for
--   <a>Promise</a>.
promiseMap :: (Contract w1 s1 e1 a1 -> Contract w2 s2 e2 a2) -> Promise w1 s1 e1 a1 -> Promise w2 s2 e2 a2

-- | <tt>select</tt> returns the contract that makes progress first,
--   discarding the other one.
--   
--   However, note that if multiples promises are chained together like
--   <tt>P1 <a>select</a> P2 <a>select</a> P3</tt> and all three can make
--   progress at the same moment, then <tt>select</tt> will prioritize the
--   promises starting from the right (first <tt>P3</tt> then <tt>P2</tt>
--   then <tt>P1</tt>).
select :: forall w s e a. Promise w s e a -> Promise w s e a -> Promise w s e a

-- | A variant of <tt>select</tt> for contracts with different return
--   types.
selectEither :: forall w s e a b. Promise w s e a -> Promise w s e b -> Promise w s e (Either a b)

-- | <a>selectList</a> returns the contract that makes progress first,
--   discarding the other ones.
--   
--   However, if multiple contracts can make progress, <a>selectList</a>
--   prioritizes the ones appearing first in the input list. Therefore, the
--   order of the list of promises is important.
selectList :: [Promise w s e a] -> Contract w s e a

-- | A <a>Promise</a> that is never fulfilled. This is the identity of
--   <a>select</a>.
never :: Promise w s e a
data ContractError
WalletContractError :: WalletAPIError -> ContractError
ChainIndexContractError :: Text -> ChainIndexResponse -> ContractError
EmulatorAssertionContractError :: AssertionError -> ContractError
ConstraintResolutionContractError :: MkTxError -> ContractError
TxConstraintResolutionContractError :: MkTxError -> ContractError
TxToCardanoConvertContractError :: ToCardanoError -> ContractError
ResumableContractError :: MatchingError -> ContractError
CCheckpointContractError :: CheckpointError -> ContractError
EndpointDecodeContractError :: EndpointDescription -> EndpointValue Value -> Text -> ContractError

-- | The endpoint description which the decoding error occurred from
[eeEndpointDescription] :: ContractError -> EndpointDescription

-- | The endpoint value that was used as an endpoint parameter
[eeEndpointValue] :: ContractError -> EndpointValue Value

-- | JSON decoding error message
[eeErrorMessage] :: ContractError -> Text
OtherContractError :: Text -> ContractError
class AsContractError r_a4TlE
_ContractError :: AsContractError r_a4TlE => Prism' r_a4TlE ContractError
_WalletContractError :: AsContractError r_a4TlE => Prism' r_a4TlE WalletAPIError
_ChainIndexContractError :: AsContractError r_a4TlE => Prism' r_a4TlE (Text, ChainIndexResponse)
_EmulatorAssertionContractError :: AsContractError r_a4TlE => Prism' r_a4TlE AssertionError
_ConstraintResolutionContractError :: AsContractError r_a4TlE => Prism' r_a4TlE MkTxError
_TxConstraintResolutionContractError :: AsContractError r_a4TlE => Prism' r_a4TlE MkTxError
_TxToCardanoConvertContractError :: AsContractError r_a4TlE => Prism' r_a4TlE ToCardanoError
_ResumableContractError :: AsContractError r_a4TlE => Prism' r_a4TlE MatchingError
_CCheckpointContractError :: AsContractError r_a4TlE => Prism' r_a4TlE CheckpointError
_EndpointDecodeContractError :: AsContractError r_a4TlE => Prism' r_a4TlE (EndpointDescription, EndpointValue Value, Text)
_OtherContractError :: AsContractError r_a4TlE => Prism' r_a4TlE Text

-- | An error
newtype MatchingError
WrongVariantError :: Text -> MatchingError
[unWrongVariantError] :: MatchingError -> Text

-- | Transform any exceptions thrown by the <a>Contract</a> using the given
--   function.
mapError :: forall w s e e' a. (e -> e') -> Contract w s e a -> Contract w s e' a

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | Turn a contract with error type <tt>e</tt> and return type <tt>a</tt>
--   into one with any error type (ie. throwing no errors) that returns
--   'Either e a'
runError :: forall w s e e0 a. Contract w s e a -> Contract w s e0 (Either e a)

-- | Handle errors, potentially throwing new errors.
handleError :: forall w s e e' a. (e -> Contract w s e' a) -> Contract w s e a -> Contract w s e' a
class AsCheckpointError r_aQsK
_CheckpointError :: AsCheckpointError r_aQsK => Prism' r_aQsK CheckpointError
data CheckpointError
JSONDecodeError :: Text -> CheckpointError

-- | Write the current state of the contract to a checkpoint.
checkpoint :: forall w s e a. (AsCheckpointError e, FromJSON a, ToJSON a) => Contract w s e a -> Contract w s e a
checkpointLoop :: forall w s e a b. (AsCheckpointError e, FromJSON a, ToJSON a, ToJSON b, FromJSON b) => (a -> Contract w s e (Either b a)) -> a -> Contract w s e b
runResumable :: Monoid w => [Response PABResp] -> CheckpointStore -> Eff (ContractEffs w e) a -> ResumableResult w e PABResp PABReq a
insertAndUpdate :: forall w e a. Monoid w => Eff (ContractEffs w e) a -> CheckpointStore -> Responses (CheckpointKey, PABResp) -> Response PABResp -> ResumableResult w e PABResp PABReq a
runWithRecord :: forall w e a. Monoid w => Eff (ContractEffs w e) a -> CheckpointStore -> Responses PABResp -> ResumableResult w e PABResp PABReq a

-- | The result of running a <a>Resumable</a>
data ResumableResult w e i o a
ResumableResult :: Responses (CheckpointKey, i) -> Requests o -> Either e (Maybe a) -> Seq (LogMessage Value) -> Seq (LogMessage Value) -> CheckpointStore -> w -> w -> ResumableResult w e i o a
[_responses] :: ResumableResult w e i o a -> Responses (CheckpointKey, i)
[_requests] :: ResumableResult w e i o a -> Requests o
[_finalState] :: ResumableResult w e i o a -> Either e (Maybe a)
[_logs] :: ResumableResult w e i o a -> Seq (LogMessage Value)
[_lastLogs] :: ResumableResult w e i o a -> Seq (LogMessage Value)
[_checkpointStore] :: ResumableResult w e i o a -> CheckpointStore

-- | Accumulated, observable state of the contract
[_observableState] :: ResumableResult w e i o a -> w

-- | Last accumulated state
[_lastState] :: ResumableResult w e i o a -> w
responses :: forall w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg i_a53Cp. Lens (ResumableResult w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg) (ResumableResult w_a52gc e_a52gd i_a53Cp o_a52gf a_a52gg) (Responses (CheckpointKey, i_a52ge)) (Responses (CheckpointKey, i_a53Cp))
requests :: forall w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg o_a53Co. Lens (ResumableResult w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg) (ResumableResult w_a52gc e_a52gd i_a52ge o_a53Co a_a52gg) (Requests o_a52gf) (Requests o_a53Co)
finalState :: forall w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg e_a53Cm a_a53Cn. Lens (ResumableResult w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg) (ResumableResult w_a52gc e_a53Cm i_a52ge o_a52gf a_a53Cn) (Either e_a52gd (Maybe a_a52gg)) (Either e_a53Cm (Maybe a_a53Cn))
logs :: forall w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg. Lens' (ResumableResult w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg) (Seq (LogMessage Value))
lastState :: forall w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg. Lens' (ResumableResult w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg) w_a52gc
checkpointStore :: forall w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg. Lens' (ResumableResult w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg) CheckpointStore
observableState :: forall w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg. Lens' (ResumableResult w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg) w_a52gc

-- | Shrink the <a>ResumableResult</a> by deleting everything that's not
--   needed to restore the state of the contract instance.
shrinkResumableResult :: ResumableResult w e i o a -> ResumableResult w e i o a
data SuspendedContract w e i o a
SuspendedContract :: ResumableResult w e i o a -> Maybe (MultiRequestContStatus i o (SuspendedContractEffects w e) a) -> CheckpointKey -> SuspendedContract w e i o a
[_resumableResult] :: SuspendedContract w e i o a -> ResumableResult w e i o a
[_continuations] :: SuspendedContract w e i o a -> Maybe (MultiRequestContStatus i o (SuspendedContractEffects w e) a)
[_checkpointKey] :: SuspendedContract w e i o a -> CheckpointKey
resumableResult :: forall w_a53DW e_a53DX i_a53DY o_a53DZ a_a53E0. Lens' (SuspendedContract w_a53DW e_a53DX i_a53DY o_a53DZ a_a53E0) (ResumableResult w_a53DW e_a53DX i_a53DY o_a53DZ a_a53E0)
continuations :: forall w_a53DW e_a53DX i_a53DY o_a53DZ a_a53E0. Lens' (SuspendedContract w_a53DW e_a53DX i_a53DY o_a53DZ a_a53E0) (Maybe (MultiRequestContStatus i_a53DY o_a53DZ (SuspendedContractEffects w_a53DW e_a53DX) a_a53E0))
checkpointKey :: forall w_a53DW e_a53DX i_a53DY o_a53DZ a_a53E0. Lens' (SuspendedContract w_a53DW e_a53DX i_a53DY o_a53DZ a_a53E0) CheckpointKey

-- | Run an action of <tt>ContractEffs</tt> until it requests input for the
--   first time, returning the <a>SuspendedContract</a>
suspend :: forall w e a. Monoid w => CheckpointStore -> Eff (ContractEffs w e) a -> SuspendedContract w e PABResp PABReq a

-- | Feed a <a>Response</a> to a <a>SuspendedContract</a>.
runStep :: forall w e a. Monoid w => SuspendedContract w e PABResp PABReq a -> Response PABResp -> Maybe (SuspendedContract w e PABResp PABReq a)
lastLogs :: forall w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg. Lens' (ResumableResult w_a52gc e_a52gd i_a52ge o_a52gf a_a52gg) (Seq (LogMessage Value))
instance Data.Aeson.Types.FromJSON.FromJSON w => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Types.AccumState w)
instance Data.Aeson.Types.ToJSON.ToJSON w => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Types.AccumState w)
instance GHC.Base.Monoid w => GHC.Base.Monoid (Plutus.Contract.Types.AccumState w)
instance GHC.Base.Semigroup w => GHC.Base.Semigroup (Plutus.Contract.Types.AccumState w)
instance GHC.Show.Show w => GHC.Show.Show (Plutus.Contract.Types.AccumState w)
instance GHC.Classes.Ord w => GHC.Classes.Ord (Plutus.Contract.Types.AccumState w)
instance GHC.Classes.Eq w => GHC.Classes.Eq (Plutus.Contract.Types.AccumState w)
instance GHC.Base.Monad (Plutus.Contract.Types.Contract w s e)
instance GHC.Base.Applicative (Plutus.Contract.Types.Contract w s e)
instance GHC.Base.Functor (Plutus.Contract.Types.Contract w s e)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Plutus.Contract.Types.Promise w s e a)
instance Data.Bifunctor.Bifunctor (Plutus.Contract.Types.Promise w s)
instance GHC.Base.Functor (Plutus.Contract.Types.Promise w s e)
instance (Data.Aeson.Types.FromJSON.FromJSON i, Data.Aeson.Types.FromJSON.FromJSON o, Data.Aeson.Types.FromJSON.FromJSON e, Data.Aeson.Types.FromJSON.FromJSON a, Data.Aeson.Types.FromJSON.FromJSON w) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Types.ResumableResult w e i o a)
instance (Data.Aeson.Types.ToJSON.ToJSON w, Data.Aeson.Types.ToJSON.ToJSON a, Data.Aeson.Types.ToJSON.ToJSON e, Data.Aeson.Types.ToJSON.ToJSON o, Data.Aeson.Types.ToJSON.ToJSON i) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Types.ResumableResult w e i o a)
instance (GHC.Show.Show i, GHC.Show.Show o, GHC.Show.Show e, GHC.Show.Show a, GHC.Show.Show w) => GHC.Show.Show (Plutus.Contract.Types.ResumableResult w e i o a)
instance GHC.Generics.Generic (Plutus.Contract.Types.ResumableResult w e i o a)
instance Plutus.Contract.Types.IsContract Plutus.Contract.Types.Contract
instance Plutus.Contract.Types.IsContract Plutus.Contract.Types.Promise
instance Data.Functor.Bind.Class.Apply (Plutus.Contract.Types.Promise w s e)
instance Control.Monad.Error.Class.MonadError e (Plutus.Contract.Types.Contract w s e)
instance PlutusTx.Functor.Functor (Plutus.Contract.Types.Contract w s e)
instance PlutusTx.Applicative.Applicative (Plutus.Contract.Types.Contract w s e)
instance Data.Bifunctor.Bifunctor (Plutus.Contract.Types.Contract w s)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Plutus.Contract.Types.Contract w s e a)

module Plutus.Contract.State

-- | <tt>Contract w s e a</tt> is a contract with schema <tt>s</tt>,
--   producing a value of type <tt>a</tt> or an error <tt>e</tt>. See note
--   [Contract Schema].
data Contract w (s :: Row *) e a

-- | The state of a <a>Contract</a>, containing all responses that have
--   been fed to it, and checkpoints that it produced.
data State w e
State :: Responses e -> CheckpointStore -> w -> State w e
[record] :: State w e -> Responses e
[checkpoints] :: State w e -> CheckpointStore
[observableState] :: State w e -> w

-- | A request sent to a contract instance. It contains the previous
--   <a>State</a> of the instance, and a <a>Response</a> to one of the
--   requests of the instance.
data ContractRequest w s
ContractRequest :: State w (CheckpointKey, s) -> Response s -> ContractRequest w s
[oldState] :: ContractRequest w s -> State w (CheckpointKey, s)
[event] :: ContractRequest w s -> Response s

-- | A response produced by a contract instance. It contains the new
--   <a>State</a>, the list of endpoints that can be called, logs produced
--   by the contract, possibly an error message, and the accumulated
--   observable state.
data ContractResponse w e s h
ContractResponse :: State w (CheckpointKey, s) -> [Request h] -> [LogMessage Value] -> [LogMessage Value] -> Maybe e -> w -> ContractResponse w e s h

-- | Serialised state of the contract (internal)
[newState] :: ContractResponse w e s h -> State w (CheckpointKey, s)

-- | Open requests that can be handled
[hooks] :: ContractResponse w e s h -> [Request h]

-- | Logs produced by the contract
[logs] :: ContractResponse w e s h -> [LogMessage Value]

-- | Logs produced in the last step
[lastLogs] :: ContractResponse w e s h -> [LogMessage Value]

-- | Error that happened during contract execution
[err] :: ContractResponse w e s h -> Maybe e

-- | Observable state produced in the last step
[lastState] :: ContractResponse w e s h -> w
mapE :: forall e f w s h. (e -> f) -> ContractResponse w e s h -> ContractResponse w f s h
mapW :: forall w q e s h. (w -> q) -> ContractResponse w e s h -> ContractResponse q e s h

-- | Run one step of the contract by restoring it to its previous state and
--   feeding it a single new <a>Response</a> event.
insertAndUpdateContract :: forall w s e a. Monoid w => Contract w s e a -> ContractRequest w PABResp -> ContractResponse w e PABResp PABReq

-- | The <a>ContractResponse</a> with the initial state of the contract.
initialiseContract :: forall w s e a. Monoid w => Contract w s e a -> ContractResponse w e PABResp PABReq
mkResponse :: forall w e s h a. Monoid w => w -> ResumableResult w e s h a -> ContractResponse w e s h
instance (Data.Aeson.Types.FromJSON.FromJSON e, Data.Aeson.Types.FromJSON.FromJSON w) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.State.State w e)
instance (Data.Aeson.Types.ToJSON.ToJSON w, Data.Aeson.Types.ToJSON.ToJSON e) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.State.State w e)
instance Data.Traversable.Traversable (Plutus.Contract.State.State w)
instance Data.Foldable.Foldable (Plutus.Contract.State.State w)
instance GHC.Base.Functor (Plutus.Contract.State.State w)
instance (GHC.Show.Show e, GHC.Show.Show w) => GHC.Show.Show (Plutus.Contract.State.State w e)
instance (GHC.Classes.Eq e, GHC.Classes.Eq w) => GHC.Classes.Eq (Plutus.Contract.State.State w e)
instance GHC.Generics.Generic (Plutus.Contract.State.State w e)
instance (GHC.Show.Show s, GHC.Show.Show w) => Prettyprinter.Internal.Pretty (Plutus.Contract.State.ContractRequest w s)
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON w) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.State.ContractRequest w s)
instance (Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON w) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.State.ContractRequest w s)
instance Data.Traversable.Traversable (Plutus.Contract.State.ContractRequest w)
instance Data.Foldable.Foldable (Plutus.Contract.State.ContractRequest w)
instance GHC.Base.Functor (Plutus.Contract.State.ContractRequest w)
instance (GHC.Show.Show s, GHC.Show.Show w) => GHC.Show.Show (Plutus.Contract.State.ContractRequest w s)
instance (GHC.Classes.Eq s, GHC.Classes.Eq w) => GHC.Classes.Eq (Plutus.Contract.State.ContractRequest w s)
instance GHC.Generics.Generic (Plutus.Contract.State.ContractRequest w s)
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON w, Data.Aeson.Types.FromJSON.FromJSON h, Data.Aeson.Types.FromJSON.FromJSON e) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.State.ContractResponse w e s h)
instance (Data.Aeson.Types.ToJSON.ToJSON e, Data.Aeson.Types.ToJSON.ToJSON h, Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON w) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.State.ContractResponse w e s h)
instance GHC.Base.Functor (Plutus.Contract.State.ContractResponse w e s)
instance (GHC.Show.Show s, GHC.Show.Show w, GHC.Show.Show h, GHC.Show.Show e) => GHC.Show.Show (Plutus.Contract.State.ContractResponse w e s h)
instance (GHC.Classes.Eq s, GHC.Classes.Eq w, GHC.Classes.Eq h, GHC.Classes.Eq e) => GHC.Classes.Eq (Plutus.Contract.State.ContractResponse w e s h)
instance GHC.Generics.Generic (Plutus.Contract.State.ContractResponse w e s h)
instance Data.Bifunctor.Bifunctor (Plutus.Contract.State.ContractResponse w e)
instance Data.Bifunctor.Bifunctor Plutus.Contract.State.State

module Plutus.Contract.Logging

-- | Log a message at the <tt>Debug</tt> level
logDebug :: ToJSON a => a -> Contract w s e ()

-- | Log a message at the <tt>Info</tt> level
logInfo :: ToJSON a => a -> Contract w s e ()

-- | Log a message at the <tt>Warning</tt> level
logWarn :: ToJSON a => a -> Contract w s e ()

-- | Log a message at the <tt>Error</tt> level
logError :: ToJSON a => a -> Contract w s e ()

module Plutus.Contract.Request

-- | Wait until the slot
awaitSlot :: forall w s e. AsContractError e => Slot -> Contract w s e Slot

-- | Wait until the slot
isSlot :: forall w s e. AsContractError e => Slot -> Promise w s e Slot

-- | Get the current slot number

-- | <i>Deprecated: Use currentNodeClientSlot instead</i>
currentSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Get the current slot number of PAB

-- | <i>Deprecated: Use currentNodeClientSlot instead</i>
currentPABSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Get the current slot number of the node client (the local or remote
--   node) that the application is connected to.
currentNodeClientSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Get the current node slot number querying slot number from plutus
--   chain index to be aligned with slot at local running node
currentChainIndexSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Wait for a number of slots to pass
waitNSlots :: forall w s e. AsContractError e => Natural -> Contract w s e Slot

-- | Wait until the slot where the given time falls into and return latest
--   time we know has passed.
--   
--   Example: if starting time is 0 and slot length is 3s, then `awaitTime
--   4` waits until slot 2 and returns the value `POSIXTime 5`.
awaitTime :: forall w s e. AsContractError e => POSIXTime -> Contract w s e POSIXTime

-- | Wait until the slot where the given time falls into and return latest
--   time we know has passed.
isTime :: forall w s e. AsContractError e => POSIXTime -> Promise w s e POSIXTime

-- | Get the latest time of the current slot.
--   
--   Example: if slot length is 3s and current slot is 2, then
--   <a>currentTime</a> returns the value `POSIXTime 5`

-- | <i>Deprecated: Use currentNodeClientTimeRange instead</i>
currentTime :: forall w s e. AsContractError e => Contract w s e POSIXTime

-- | Get the <a>POSIXTime</a> range of the current slot.
--   
--   Example: if slot length is 3s and current slot is 2, then
--   <tt>currentTimeRange</tt> returns the time interval <tt>[3, 5[</tt>.
currentNodeClientTimeRange :: forall w s e. AsContractError e => Contract w s e (POSIXTime, POSIXTime)

-- | Wait for a number of milliseconds starting at the ending time of the
--   current slot, and return the latest time we know has passed.
--   
--   Example: if starting time is 0, slot length is 3000ms and current slot
--   is 0, then `waitNMilliSeconds 0` returns the value `POSIXTime 2000`
--   and `waitNMilliSeconds 1000` returns the value `POSIXTime 5`.
waitNMilliSeconds :: forall w s e. AsContractError e => DiffMilliSeconds -> Contract w s e POSIXTime
datumFromHash :: forall w s e. AsContractError e => DatumHash -> Contract w s e (Maybe Datum)

-- | Get the all datums at an address whether or not the corresponding utxo
--   have been consumed or not.
datumsAt :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e [Datum]
validatorFromHash :: forall w s e. AsContractError e => ValidatorHash -> Contract w s e (Maybe (Versioned Validator))
mintingPolicyFromHash :: forall w s e. AsContractError e => MintingPolicyHash -> Contract w s e (Maybe (Versioned MintingPolicy))
stakeValidatorFromHash :: forall w s e. AsContractError e => StakeValidatorHash -> Contract w s e (Maybe (Versioned StakeValidator))
redeemerFromHash :: forall w s e. AsContractError e => RedeemerHash -> Contract w s e (Maybe Redeemer)
txOutFromRef :: forall w s e. AsContractError e => TxOutRef -> Contract w s e (Maybe DecoratedTxOut)
txFromTxId :: forall w s e. AsContractError e => TxId -> Contract w s e (Maybe ChainIndexTx)
unspentTxOutFromRef :: forall w s e. AsContractError e => TxOutRef -> Contract w s e (Maybe DecoratedTxOut)
utxoRefMembership :: forall w s e. AsContractError e => TxOutRef -> Contract w s e IsUtxoResponse

-- | Get the unspent transaction output references at an address.
utxoRefsAt :: forall w s e. AsContractError e => PageQuery TxOutRef -> CardanoAddress -> Contract w s e UtxosResponse

-- | Get the unspent transaction output references with a specific
--   currrency (<a>AssetClass</a>).
utxoRefsWithCurrency :: forall w s e. AsContractError e => PageQuery TxOutRef -> AssetClass -> Contract w s e UtxosResponse

-- | Get the unspent transaction outputs at an address.
utxosAt :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Get the unspent transaction outputs from a <a>ChainIndexTx</a>.
utxosTxOutTxFromTx :: AsContractError e => ChainIndexTx -> Contract w s e [(TxOutRef, (DecoratedTxOut, ChainIndexTx))]

-- | Get unspent transaction outputs with transaction from address.
utxosTxOutTxAt :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e (Map TxOutRef (DecoratedTxOut, ChainIndexTx))

-- | Get the transactions for a list of transaction ids.
txsFromTxIds :: forall w s e. AsContractError e => [TxId] -> Contract w s e [ChainIndexTx]

-- | Get the transaction outputs at an address.
txoRefsAt :: forall w s e. AsContractError e => PageQuery TxOutRef -> CardanoAddress -> Contract w s e TxosResponse

-- | Get the transactions at an address.
txsAt :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e [ChainIndexTx]
getTip :: forall w s e. AsContractError e => Contract w s e Tip

-- | Go through each <a>Page</a>s of <a>QueryResponse</a>, and collect the
--   results.
collectQueryResponse :: Monad m => (PageQuery TxOutRef -> m (QueryResponse a)) -> m [a]

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has surpassed the given value.
fundsAtAddressGt :: forall w s e. AsContractError e => CardanoAddress -> Value -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has reached or surpassed the given
--   value.
fundsAtAddressGeq :: forall w s e. AsContractError e => CardanoAddress -> Value -> Contract w s e (Map TxOutRef DecoratedTxOut)
fundsAtAddressCondition :: forall w s e. AsContractError e => (Value -> Bool) -> CardanoAddress -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Wait until the target slot and get the unspent transaction outputs at
--   an address.
watchAddressUntilSlot :: forall w s e. AsContractError e => CardanoAddress -> Slot -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Wait until the target time and get the unspent transaction outputs at
--   an address.
watchAddressUntilTime :: forall w s e. AsContractError e => CardanoAddress -> POSIXTime -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Wait until the UTXO has been spent, returning the transaction that
--   spends it.
awaitUtxoSpent :: forall w s e. AsContractError e => TxOutRef -> Contract w s e ChainIndexTx

-- | Wait until the UTXO has been spent, returning the transaction that
--   spends it.
utxoIsSpent :: forall w s e. AsContractError e => TxOutRef -> Promise w s e ChainIndexTx

-- | Wait until one or more unspent outputs are produced at an address.
awaitUtxoProduced :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e (NonEmpty ChainIndexTx)

-- | Wait until one or more unspent outputs are produced at an address.
utxoIsProduced :: forall w s e. AsContractError e => CardanoAddress -> Promise w s e (NonEmpty ChainIndexTx)

-- | The rollback state of a Cardano transaction
data RollbackState a

-- | The transaction is not on the chain. That's all we can say.
Unknown :: RollbackState a

-- | The status of a Cardano transaction
type TxStatus = RollbackState ()

-- | Wait for the status of a transaction to change
awaitTxStatusChange :: forall w s e. AsContractError e => TxId -> Contract w s e TxStatus

-- | Wait until a transaction is confirmed (added to the ledger). If the
--   transaction is never added to the ledger then <a>awaitTxConfirmed</a>
--   never returns
awaitTxConfirmed :: forall w s e. AsContractError e => TxId -> Contract w s e ()

-- | Wait until a transaction is confirmed (added to the ledger).
isTxConfirmed :: forall w s e. AsContractError e => TxId -> Promise w s e ()
type TxOutStatus = RollbackState TxOutState

-- | Wait for the status of a transaction output to change.
awaitTxOutStatusChange :: forall w s e. AsContractError e => TxOutRef -> Contract w s e TxOutStatus

-- | Get the <a>ContractInstanceId</a> of this instance.
ownInstanceId :: forall w s e. AsContractError e => Contract w s e ContractInstanceId
type HasEndpoint l a s = (HasType l (EndpointValue a) (Input s), HasType l ActiveEndpoint (Output s), KnownSymbol l, ContractRow s)
newtype EndpointDescription
EndpointDescription :: String -> EndpointDescription
type Endpoint l a = l .== (EndpointValue a, ActiveEndpoint)

-- | Expose an endpoint, return the data that was entered
endpoint :: forall l a w s e b. (HasEndpoint l a s, AsContractError e, FromJSON a) => (a -> Contract w s e b) -> Promise w s e b
handleEndpoint :: forall l a w s e1 e2 b. (HasEndpoint l a s, AsContractError e1, FromJSON a) => (Either e1 a -> Contract w s e2 b) -> Promise w s e2 b

-- | Expose an endpoint with some metadata. Return the data that was
--   entered.
endpointWithMeta :: forall l a w s e meta b. (HasEndpoint l a s, AsContractError e, ToJSON meta, FromJSON a) => meta -> (a -> Contract w s e b) -> Promise w s e b
endpointDescription :: forall l. KnownSymbol l => Proxy l -> EndpointDescription
endpointReq :: forall l a s. HasEndpoint l a s => ActiveEndpoint
endpointResp :: forall l a s. (HasEndpoint l a s, ToJSON a) => a -> PABResp

-- | Get the hash of a public key belonging to the wallet that runs this
--   contract. * Any funds paid to this public key hash will be treated as
--   the wallet's own funds * The wallet is able to sign transactions with
--   the private key of this public key, for example, if the public key is
--   added to the <tt>requiredSignatures</tt> field of <tt>Tx</tt>. * There
--   is a 1-n relationship between wallets and public keys (although in the
--   mockchain n=1)

-- | <i>Deprecated: Use ownFirstPaymentPubKeyHash, ownPaymentPubKeyHashes
--   or ownAddresses instead</i>
ownPaymentPubKeyHash :: forall w s e. AsContractError e => Contract w s e PaymentPubKeyHash
ownPaymentPubKeyHashes :: forall w s e. AsContractError e => Contract w s e [PaymentPubKeyHash]
ownFirstPaymentPubKeyHash :: forall w s e. AsContractError e => Contract w s e PaymentPubKeyHash

-- | Get the addresses belonging to the wallet that runs this contract. *
--   Any funds paid to one of these addresses will be treated as the
--   wallet's own funds * The wallet is able to sign transactions with the
--   private key of one of its public key, for example, if the public key
--   is added to the <tt>requiredSignatures</tt> field of <tt>Tx</tt>. *
--   There is a 1-n relationship between wallets and addresses (although in
--   the mockchain n=1)
ownAddresses :: forall w s e. AsContractError e => Contract w s e (NonEmpty CardanoAddress)

-- | Get the first address of the wallet that runs this contract.
ownAddress :: forall w s e. AsContractError e => Contract w s e CardanoAddress

-- | Get all utxos belonging to the wallet that runs this contract.
ownUtxos :: forall w s e. AsContractError e => Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Adjust the unbalanced tx
adjustUnbalancedTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e UnbalancedTx

-- | Send an unbalanced transaction to be balanced and signed. Returns the
--   ID of the final transaction when the transaction was submitted. Throws
--   an error if balancing or signing failed.
submitUnbalancedTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e CardanoTx

-- | Send an balanced transaction to be signed. Returns the ID of the final
--   transaction when the transaction was submitted. Throws an error if
--   signing failed.
submitBalancedTx :: forall w s e. AsContractError e => CardanoTx -> Contract w s e CardanoTx

-- | Send an unbalanced transaction to be balanced. Returns the balanced
--   transaction. Throws an error if balancing failed.
balanceTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. The constraints do not refer to any typed script inputs
--   or outputs.
submitTx :: forall w s e. AsContractError e => TxConstraints Void Void -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. Using the current outputs at the contract address and the
--   contract's own public key to solve the constraints.
submitTxConstraints :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => TypedValidator a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints using the UTXO map
--   to resolve any input constraints (see <a>InputConstraint</a>)
submitTxConstraintsSpending :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => TypedValidator a -> Map TxOutRef DecoratedTxOut -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. Using the given constraints.
submitTxConstraintsWith :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => ScriptLookups a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e CardanoTx

-- | A version of <a>submitTx</a> that waits until the transaction has been
--   confirmed on the ledger before returning.
submitTxConfirmed :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e ()

-- | Build a transaction that satisfies the constraints
mkTxConstraints :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => ScriptLookups a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e UnbalancedTx

-- | Take an <a>UnbalancedTx</a> then balance, sign and submit it to the
--   blockchain without returning any results.
yieldUnbalancedTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e ()

-- | Get the configured parameter set.
getParams :: forall w s e. AsContractError e => Contract w s e Params

-- | Constraints on the contract schema, ensuring that the labels of the
--   schema are unique.
type ContractRow s = (AllUniqueLabels (Input s), AllUniqueLabels (Output s))
pabReq :: forall w s e a. AsContractError e => PABReq -> Prism' PABResp a -> Contract w s e a

-- | Arguments and result of a call to <tt>mkTx</tt>
data MkTxLog
MkTxLog :: ScriptLookups Any -> TxConstraints BuiltinData BuiltinData -> Either MkTxError UnbalancedTx -> MkTxLog
[mkTxLogLookups] :: MkTxLog -> ScriptLookups Any
[mkTxLogTxConstraints] :: MkTxLog -> TxConstraints BuiltinData BuiltinData
[mkTxLogResult] :: MkTxLog -> Either MkTxError UnbalancedTx
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Request.MkTxLog
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Request.MkTxLog
instance GHC.Generics.Generic Plutus.Contract.Request.MkTxLog
instance GHC.Show.Show Plutus.Contract.Request.MkTxLog


-- | Turn <a>UnbalancedTx</a> values into transactions using the wallet
--   API.
module Plutus.Contract.Wallet
balanceTx :: forall effs_a3mrI. Member WalletEffect effs_a3mrI => UnbalancedTx -> Eff effs_a3mrI (Either WalletAPIError CardanoTx)

-- | Balance an unabalanced transaction, sign it, and submit it to the
--   chain in the context of a wallet.
handleTx :: (Member WalletEffect effs, Member (Error WalletAPIError) effs) => UnbalancedTx -> Eff effs CardanoTx
yieldUnbalancedTx :: forall effs_a3mrL. Member WalletEffect effs_a3mrL => UnbalancedTx -> Eff effs_a3mrL ()

-- | Get an unspent output belonging to the wallet.
getUnspentOutput :: AsContractError e => Contract w s e TxOutRef

-- | Add the wallet's signature to the transaction and submit it. Returns
--   the transaction with the wallet's signature.
signTxAndSubmit :: Member WalletEffect effs => CardanoTx -> Eff effs CardanoTx

-- | Partial transaction that can be balanced by the wallet backend.
data ExportTx
ExportTx :: Tx BabbageEra -> [ExportTxInput] -> [ExportTxRedeemer] -> ExportTx

-- | The transaction itself
[partialTx] :: ExportTx -> Tx BabbageEra

-- | The tx outputs for all inputs spent by the partial tx
[lookups] :: ExportTx -> [ExportTxInput]
[redeemers] :: ExportTx -> [ExportTxRedeemer]
data ExportTxInput
ExportTxInput :: TxId -> TxIx -> AddressInEra BabbageEra -> Lovelace -> Maybe (Hash ScriptData) -> [(PolicyId, AssetName, Quantity)] -> ExportTxInput
[etxiId] :: ExportTxInput -> TxId
[etxiTxIx] :: ExportTxInput -> TxIx
[etxiAddress] :: ExportTxInput -> AddressInEra BabbageEra
[etxiLovelaceQuantity] :: ExportTxInput -> Lovelace
[etxiDatumHash] :: ExportTxInput -> Maybe (Hash ScriptData)
[etxiAssets] :: ExportTxInput -> [(PolicyId, AssetName, Quantity)]
data ExportTxRedeemer
SpendingRedeemer :: Redeemer -> TxOutRef -> ExportTxRedeemer
[redeemer] :: ExportTxRedeemer -> Redeemer
[redeemerOutRef] :: ExportTxRedeemer -> TxOutRef
MintingRedeemer :: Redeemer -> MintingPolicyHash -> ExportTxRedeemer
[redeemer] :: ExportTxRedeemer -> Redeemer
[redeemerPolicyId] :: ExportTxRedeemer -> MintingPolicyHash
RewardingRedeemer :: Redeemer -> StakingCredential -> ExportTxRedeemer
[redeemer] :: ExportTxRedeemer -> Redeemer
[redeemerStakingCredential] :: ExportTxRedeemer -> StakingCredential
CertifyingRedeemer :: Redeemer -> DCert -> ExportTxRedeemer
[redeemer] :: ExportTxRedeemer -> Redeemer
[redeemerDCert] :: ExportTxRedeemer -> DCert
export :: Params -> UnbalancedTx -> Either CardanoLedgerError ExportTx
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.Contract.Wallet.ExportTxRedeemer
instance GHC.Generics.Generic Plutus.Contract.Wallet.ExportTxRedeemer
instance GHC.Show.Show Plutus.Contract.Wallet.ExportTxRedeemer
instance GHC.Classes.Eq Plutus.Contract.Wallet.ExportTxRedeemer
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.Contract.Wallet.ExportTxInput
instance GHC.Generics.Generic Plutus.Contract.Wallet.ExportTxInput
instance GHC.Show.Show Plutus.Contract.Wallet.ExportTxInput
instance GHC.Classes.Eq Plutus.Contract.Wallet.ExportTxInput
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.Contract.Wallet.ExportTx
instance GHC.Generics.Generic Plutus.Contract.Wallet.ExportTx
instance GHC.Show.Show Plutus.Contract.Wallet.ExportTx
instance GHC.Classes.Eq Plutus.Contract.Wallet.ExportTx
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Wallet.ExportTx
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Wallet.ExportTx
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Wallet.ExportTxInput
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Wallet.ExportTxInput
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Wallet.ExportTxRedeemer
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Wallet.ExportTxRedeemer
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Wallet.ExportTxRedeemerPurpose

module Plutus.Contract.Trace.RequestHandler

-- | Request handlers that can choose whether to handle an effect (using
--   <a>Alternative</a>). This is useful if <tt>req</tt> is a sum type.
newtype RequestHandler effs req resp
RequestHandler :: (req -> Eff (NonDet : effs) resp) -> RequestHandler effs req resp
[unRequestHandler] :: RequestHandler effs req resp -> req -> Eff (NonDet : effs) resp
data RequestHandlerLogMsg
SlotNoticationTargetVsCurrent :: Slot -> Slot -> RequestHandlerLogMsg
HandleTxFailed :: WalletAPIError -> RequestHandlerLogMsg
AdjustingUnbalancedTx :: [Ada] -> RequestHandlerLogMsg
tryHandler :: forall effs req resp. RequestHandler effs req resp -> [req] -> Eff effs (Maybe resp)
tryHandler' :: forall f effs req resp. (Alternative f, Monad f) => RequestHandler effs req (f resp) -> [req] -> Eff effs (f resp)
wrapHandler :: RequestHandler effs req resp -> RequestHandler effs (Request req) (Response resp)
extract :: Alternative f => Prism' a b -> a -> f b
maybeToHandler :: (req -> Maybe resp) -> RequestHandler effs req resp

-- | Generalise a request handler
generalise :: forall effs req req' resp resp'. (req' -> Maybe req) -> (resp -> resp') -> RequestHandler effs req resp -> RequestHandler effs req' resp'
handleAdjustUnbalancedTx :: forall effs. (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member NodeClientEffect effs) => RequestHandler effs UnbalancedTx (Either ToCardanoError UnbalancedTx)
handleOwnAddresses :: forall a effs. (Member WalletEffect effs, Member (LogObserve (LogMessage Text)) effs) => RequestHandler effs a (NonEmpty CardanoAddress)
handleSlotNotifications :: forall effs. (Member NodeClientEffect effs, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs) => RequestHandler effs Slot Slot
handleCurrentNodeClientSlot :: forall effs a. (Member NodeClientEffect effs, Member (LogObserve (LogMessage Text)) effs) => RequestHandler effs a Slot
handleCurrentChainIndexSlot :: forall effs a. (Member (LogObserve (LogMessage Text)) effs, Member ChainIndexQueryEffect effs) => RequestHandler effs a Slot
handleTimeNotifications :: forall effs. (Member NodeClientEffect effs, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs) => RequestHandler effs POSIXTime POSIXTime
handleCurrentTime :: forall effs a. (Member NodeClientEffect effs, Member (LogObserve (LogMessage Text)) effs) => RequestHandler effs a POSIXTime
handleCurrentNodeClientTimeRange :: forall effs a. (Member NodeClientEffect effs, Member (LogObserve (LogMessage Text)) effs) => RequestHandler effs a (POSIXTime, POSIXTime)
handleTimeToSlotConversions :: forall effs. (Member NodeClientEffect effs, Member (LogObserve (LogMessage Text)) effs) => RequestHandler effs POSIXTimeRange SlotRange
handleUnbalancedTransactions :: forall effs. (Member WalletEffect effs, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs) => RequestHandler effs UnbalancedTx (Either WalletAPIError CardanoTx)
handlePendingTransactions :: forall effs. (Member WalletEffect effs, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs) => RequestHandler effs CardanoTx (Either WalletAPIError CardanoTx)
handleChainIndexQueries :: forall effs. (Member (LogObserve (LogMessage Text)) effs, Member ChainIndexQueryEffect effs) => RequestHandler effs ChainIndexQuery ChainIndexResponse
handleOwnInstanceIdQueries :: forall effs a. (Member (LogObserve (LogMessage Text)) effs, Member (Reader ContractInstanceId) effs) => RequestHandler effs a ContractInstanceId
handleYieldedUnbalancedTx :: forall effs. (Member WalletEffect effs, Member (LogObserve (LogMessage Text)) effs) => RequestHandler effs UnbalancedTx ()
handleGetParams :: forall effs. (Member (LogObserve (LogMessage Text)) effs, Member NodeClientEffect effs) => RequestHandler effs () Params
instance GHC.Base.Monoid (Plutus.Contract.Trace.RequestHandler.RequestHandler effs req resp)
instance GHC.Base.Semigroup (Plutus.Contract.Trace.RequestHandler.RequestHandler effs req resp)
instance Control.Arrow.Arrow (Plutus.Contract.Trace.RequestHandler.RequestHandler effs)
instance Control.Category.Category (Plutus.Contract.Trace.RequestHandler.RequestHandler effs)
instance Data.Profunctor.Unsafe.Profunctor (Plutus.Contract.Trace.RequestHandler.RequestHandler effs)
instance GHC.Base.Functor (Plutus.Contract.Trace.RequestHandler.RequestHandler effs req)

module Plutus.Contract

-- | <tt>Contract w s e a</tt> is a contract with schema <tt>s</tt>,
--   producing a value of type <tt>a</tt> or an error <tt>e</tt>. See note
--   [Contract Schema].
newtype Contract w (s :: Row *) e a
Contract :: Eff (ContractEffs w e) a -> Contract w (s :: Row *) e a
[unContract] :: Contract w (s :: Row *) e a -> Eff (ContractEffs w e) a
data ContractError
WalletContractError :: WalletAPIError -> ContractError
ChainIndexContractError :: Text -> ChainIndexResponse -> ContractError
EmulatorAssertionContractError :: AssertionError -> ContractError
ConstraintResolutionContractError :: MkTxError -> ContractError
TxConstraintResolutionContractError :: MkTxError -> ContractError
TxToCardanoConvertContractError :: ToCardanoError -> ContractError
ResumableContractError :: MatchingError -> ContractError
CCheckpointContractError :: CheckpointError -> ContractError
EndpointDecodeContractError :: EndpointDescription -> EndpointValue Value -> Text -> ContractError

-- | The endpoint description which the decoding error occurred from
[eeEndpointDescription] :: ContractError -> EndpointDescription

-- | The endpoint value that was used as an endpoint parameter
[eeEndpointValue] :: ContractError -> EndpointValue Value

-- | JSON decoding error message
[eeErrorMessage] :: ContractError -> Text
OtherContractError :: Text -> ContractError
class AsContractError r_a4TlE
_ContractError :: AsContractError r_a4TlE => Prism' r_a4TlE ContractError
_WalletContractError :: AsContractError r_a4TlE => Prism' r_a4TlE WalletAPIError
_ChainIndexContractError :: AsContractError r_a4TlE => Prism' r_a4TlE (Text, ChainIndexResponse)
_EmulatorAssertionContractError :: AsContractError r_a4TlE => Prism' r_a4TlE AssertionError
_ConstraintResolutionContractError :: AsContractError r_a4TlE => Prism' r_a4TlE MkTxError
_TxConstraintResolutionContractError :: AsContractError r_a4TlE => Prism' r_a4TlE MkTxError
_TxToCardanoConvertContractError :: AsContractError r_a4TlE => Prism' r_a4TlE ToCardanoError
_ResumableContractError :: AsContractError r_a4TlE => Prism' r_a4TlE MatchingError
_CCheckpointContractError :: AsContractError r_a4TlE => Prism' r_a4TlE CheckpointError
_EndpointDecodeContractError :: AsContractError r_a4TlE => Prism' r_a4TlE (EndpointDescription, EndpointValue Value, Text)
_OtherContractError :: AsContractError r_a4TlE => Prism' r_a4TlE Text

-- | Class of types that can be trivially converted to a <a>Contract</a>.
--   For use with functions where it is convenient to accept both
--   <a>Contract</a> and <a>Promise</a> types.
class IsContract c
toContract :: IsContract c => c w s e a -> Contract w s e a

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b
infixl 1 >>

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | Handle errors, potentially throwing new errors.
handleError :: forall w s e e' a. (e -> Contract w s e' a) -> Contract w s e a -> Contract w s e' a

-- | Transform any exceptions thrown by the <a>Contract</a> using the given
--   function.
mapError :: forall w s e e' a. (e -> e') -> Contract w s e a -> Contract w s e' a

-- | Turn a contract with error type <tt>e</tt> and return type <tt>a</tt>
--   into one with any error type (ie. throwing no errors) that returns
--   'Either e a'
runError :: forall w s e e0 a. Contract w s e a -> Contract w s e0 (Either e a)

-- | A wrapper indicating that this contract starts with a waiting action.
--   For use with <tt>select</tt>.
data Promise w (s :: Row *) e a
awaitPromise :: Promise w s e a -> Contract w s e a

-- | Lift a mapping function for <a>Contract</a> to a mapping function for
--   <a>Promise</a>.
promiseMap :: (Contract w1 s1 e1 a1 -> Contract w2 s2 e2 a2) -> Promise w1 s1 e1 a1 -> Promise w2 s2 e2 a2

-- | Run more <a>Contract</a> code after the <a>Promise</a>.
promiseBind :: Promise w s e a -> (a -> Contract w s e b) -> Promise w s e b

-- | Execute both contracts in any order
both :: Promise w s e a -> Promise w s e b -> Promise w s e (a, b)

-- | A variant of <tt>select</tt> for contracts with different return
--   types.
selectEither :: forall w s e a b. Promise w s e a -> Promise w s e b -> Promise w s e (Either a b)

-- | <tt>select</tt> returns the contract that makes progress first,
--   discarding the other one.
--   
--   However, note that if multiples promises are chained together like
--   <tt>P1 <a>select</a> P2 <a>select</a> P3</tt> and all three can make
--   progress at the same moment, then <tt>select</tt> will prioritize the
--   promises starting from the right (first <tt>P3</tt> then <tt>P2</tt>
--   then <tt>P1</tt>).
select :: forall w s e a. Promise w s e a -> Promise w s e a -> Promise w s e a

-- | <a>selectList</a> returns the contract that makes progress first,
--   discarding the other ones.
--   
--   However, if multiple contracts can make progress, <a>selectList</a>
--   prioritizes the ones appearing first in the input list. Therefore, the
--   order of the list of promises is important.
selectList :: [Promise w s e a] -> Contract w s e a

-- | A <a>Promise</a> that is never fulfilled. This is the identity of
--   <a>select</a>.
never :: Promise w s e a

-- | Wait until the slot
awaitSlot :: forall w s e. AsContractError e => Slot -> Contract w s e Slot

-- | Wait until the slot
isSlot :: forall w s e. AsContractError e => Slot -> Promise w s e Slot

-- | Get the current slot number

-- | <i>Deprecated: Use currentNodeClientSlot instead</i>
currentSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Get the current slot number of PAB

-- | <i>Deprecated: Use currentNodeClientSlot instead</i>
currentPABSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Get the current slot number of the node client (the local or remote
--   node) that the application is connected to.
currentNodeClientSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Get the current node slot number querying slot number from plutus
--   chain index to be aligned with slot at local running node
currentChainIndexSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Wait for a number of slots to pass
waitNSlots :: forall w s e. AsContractError e => Natural -> Contract w s e Slot

-- | Wait until the slot where the given time falls into and return latest
--   time we know has passed.
--   
--   Example: if starting time is 0 and slot length is 3s, then `awaitTime
--   4` waits until slot 2 and returns the value `POSIXTime 5`.
awaitTime :: forall w s e. AsContractError e => POSIXTime -> Contract w s e POSIXTime

-- | Wait until the slot where the given time falls into and return latest
--   time we know has passed.
isTime :: forall w s e. AsContractError e => POSIXTime -> Promise w s e POSIXTime

-- | Get the latest time of the current slot.
--   
--   Example: if slot length is 3s and current slot is 2, then
--   <a>currentTime</a> returns the value `POSIXTime 5`

-- | <i>Deprecated: Use currentNodeClientTimeRange instead</i>
currentTime :: forall w s e. AsContractError e => Contract w s e POSIXTime

-- | Get the <a>POSIXTime</a> range of the current slot.
--   
--   Example: if slot length is 3s and current slot is 2, then
--   <tt>currentTimeRange</tt> returns the time interval <tt>[3, 5[</tt>.
currentNodeClientTimeRange :: forall w s e. AsContractError e => Contract w s e (POSIXTime, POSIXTime)

-- | Wait for a number of milliseconds starting at the ending time of the
--   current slot, and return the latest time we know has passed.
--   
--   Example: if starting time is 0, slot length is 3000ms and current slot
--   is 0, then `waitNMilliSeconds 0` returns the value `POSIXTime 2000`
--   and `waitNMilliSeconds 1000` returns the value `POSIXTime 5`.
waitNMilliSeconds :: forall w s e. AsContractError e => DiffMilliSeconds -> Contract w s e POSIXTime
type HasEndpoint l a s = (HasType l (EndpointValue a) (Input s), HasType l ActiveEndpoint (Output s), KnownSymbol l, ContractRow s)
newtype EndpointDescription
EndpointDescription :: String -> EndpointDescription
[getEndpointDescription] :: EndpointDescription -> String
type Endpoint l a = l .== (EndpointValue a, ActiveEndpoint)

-- | Expose an endpoint, return the data that was entered
endpoint :: forall l a w s e b. (HasEndpoint l a s, AsContractError e, FromJSON a) => (a -> Contract w s e b) -> Promise w s e b
handleEndpoint :: forall l a w s e1 e2 b. (HasEndpoint l a s, AsContractError e1, FromJSON a) => (Either e1 a -> Contract w s e2 b) -> Promise w s e2 b

-- | Expose an endpoint with some metadata. Return the data that was
--   entered.
endpointWithMeta :: forall l a w s e meta b. (HasEndpoint l a s, AsContractError e, ToJSON meta, FromJSON a) => meta -> (a -> Contract w s e b) -> Promise w s e b
type EmptySchema = Empty

-- | Wait until the target slot and get the unspent transaction outputs at
--   an address.
watchAddressUntilSlot :: forall w s e. AsContractError e => CardanoAddress -> Slot -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Wait until the target time and get the unspent transaction outputs at
--   an address.
watchAddressUntilTime :: forall w s e. AsContractError e => CardanoAddress -> POSIXTime -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has surpassed the given value.
fundsAtAddressGt :: forall w s e. AsContractError e => CardanoAddress -> Value -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has reached or surpassed the given
--   value.
fundsAtAddressGeq :: forall w s e. AsContractError e => CardanoAddress -> Value -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Wait until the UTXO has been spent, returning the transaction that
--   spends it.
awaitUtxoSpent :: forall w s e. AsContractError e => TxOutRef -> Contract w s e ChainIndexTx

-- | Wait until the UTXO has been spent, returning the transaction that
--   spends it.
utxoIsSpent :: forall w s e. AsContractError e => TxOutRef -> Promise w s e ChainIndexTx

-- | Wait until one or more unspent outputs are produced at an address.
awaitUtxoProduced :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e (NonEmpty ChainIndexTx)

-- | Wait until one or more unspent outputs are produced at an address.
utxoIsProduced :: forall w s e. AsContractError e => CardanoAddress -> Promise w s e (NonEmpty ChainIndexTx)
datumFromHash :: forall w s e. AsContractError e => DatumHash -> Contract w s e (Maybe Datum)

-- | Get the all datums at an address whether or not the corresponding utxo
--   have been consumed or not.
datumsAt :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e [Datum]
validatorFromHash :: forall w s e. AsContractError e => ValidatorHash -> Contract w s e (Maybe (Versioned Validator))
mintingPolicyFromHash :: forall w s e. AsContractError e => MintingPolicyHash -> Contract w s e (Maybe (Versioned MintingPolicy))
stakeValidatorFromHash :: forall w s e. AsContractError e => StakeValidatorHash -> Contract w s e (Maybe (Versioned StakeValidator))
txOutFromRef :: forall w s e. AsContractError e => TxOutRef -> Contract w s e (Maybe DecoratedTxOut)
unspentTxOutFromRef :: forall w s e. AsContractError e => TxOutRef -> Contract w s e (Maybe DecoratedTxOut)
txFromTxId :: forall w s e. AsContractError e => TxId -> Contract w s e (Maybe ChainIndexTx)
utxoRefMembership :: forall w s e. AsContractError e => TxOutRef -> Contract w s e IsUtxoResponse

-- | Get the unspent transaction output references at an address.
utxoRefsAt :: forall w s e. AsContractError e => PageQuery TxOutRef -> CardanoAddress -> Contract w s e UtxosResponse

-- | Get the unspent transaction output references with a specific
--   currrency (<a>AssetClass</a>).
utxoRefsWithCurrency :: forall w s e. AsContractError e => PageQuery TxOutRef -> AssetClass -> Contract w s e UtxosResponse

-- | Get the unspent transaction outputs at an address.
utxosAt :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Get the unspent transaction outputs from a <a>ChainIndexTx</a>.
utxosTxOutTxFromTx :: AsContractError e => ChainIndexTx -> Contract w s e [(TxOutRef, (DecoratedTxOut, ChainIndexTx))]
getTip :: forall w s e. AsContractError e => Contract w s e Tip

-- | Get the hash of a public key belonging to the wallet that runs this
--   contract. * Any funds paid to this public key hash will be treated as
--   the wallet's own funds * The wallet is able to sign transactions with
--   the private key of this public key, for example, if the public key is
--   added to the <tt>requiredSignatures</tt> field of <tt>Tx</tt>. * There
--   is a 1-n relationship between wallets and public keys (although in the
--   mockchain n=1)

-- | <i>Deprecated: Use ownFirstPaymentPubKeyHash, ownPaymentPubKeyHashes
--   or ownAddresses instead</i>
ownPaymentPubKeyHash :: forall w s e. AsContractError e => Contract w s e PaymentPubKeyHash
ownPaymentPubKeyHashes :: forall w s e. AsContractError e => Contract w s e [PaymentPubKeyHash]
ownFirstPaymentPubKeyHash :: forall w s e. AsContractError e => Contract w s e PaymentPubKeyHash

-- | Get the addresses belonging to the wallet that runs this contract. *
--   Any funds paid to one of these addresses will be treated as the
--   wallet's own funds * The wallet is able to sign transactions with the
--   private key of one of its public key, for example, if the public key
--   is added to the <tt>requiredSignatures</tt> field of <tt>Tx</tt>. *
--   There is a 1-n relationship between wallets and addresses (although in
--   the mockchain n=1)
ownAddresses :: forall w s e. AsContractError e => Contract w s e (NonEmpty CardanoAddress)

-- | Get the first address of the wallet that runs this contract.
ownAddress :: forall w s e. AsContractError e => Contract w s e CardanoAddress

-- | Get all utxos belonging to the wallet that runs this contract.
ownUtxos :: forall w s e. AsContractError e => Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Unique ID for contract instance
data ContractInstanceId

-- | Get the <a>ContractInstanceId</a> of this instance.
ownInstanceId :: forall w s e. AsContractError e => Contract w s e ContractInstanceId

-- | Update the contract's accumulating state <tt>w</tt>
tell :: w -> Contract w s e ()

-- | An error thrown by wallet interactions.
data WalletAPIError

-- | Adjust the unbalanced tx
adjustUnbalancedTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e UnbalancedTx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. The constraints do not refer to any typed script inputs
--   or outputs.
submitTx :: forall w s e. AsContractError e => TxConstraints Void Void -> Contract w s e CardanoTx

-- | A version of <a>submitTx</a> that waits until the transaction has been
--   confirmed on the ledger before returning.
submitTxConfirmed :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e ()

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. Using the current outputs at the contract address and the
--   contract's own public key to solve the constraints.
submitTxConstraints :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => TypedValidator a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints using the UTXO map
--   to resolve any input constraints (see <a>InputConstraint</a>)
submitTxConstraintsSpending :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => TypedValidator a -> Map TxOutRef DecoratedTxOut -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. Using the given constraints.
submitTxConstraintsWith :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => ScriptLookups a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e CardanoTx

-- | Send an unbalanced transaction to be balanced and signed. Returns the
--   ID of the final transaction when the transaction was submitted. Throws
--   an error if balancing or signing failed.
submitUnbalancedTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e CardanoTx

-- | Send an balanced transaction to be signed. Returns the ID of the final
--   transaction when the transaction was submitted. Throws an error if
--   signing failed.
submitBalancedTx :: forall w s e. AsContractError e => CardanoTx -> Contract w s e CardanoTx

-- | Send an unbalanced transaction to be balanced. Returns the balanced
--   transaction. Throws an error if balancing failed.
balanceTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints
mkTxConstraints :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => ScriptLookups a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e UnbalancedTx

-- | Take an <a>UnbalancedTx</a> then balance, sign and submit it to the
--   blockchain without returning any results.
yieldUnbalancedTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e ()

-- | Wait until a transaction is confirmed (added to the ledger). If the
--   transaction is never added to the ledger then <a>awaitTxConfirmed</a>
--   never returns
awaitTxConfirmed :: forall w s e. AsContractError e => TxId -> Contract w s e ()

-- | Wait for the status of a transaction to change
awaitTxStatusChange :: forall w s e. AsContractError e => TxId -> Contract w s e TxStatus

-- | Wait until a transaction is confirmed (added to the ledger).
isTxConfirmed :: forall w s e. AsContractError e => TxId -> Promise w s e ()

-- | Wait for the status of a transaction output to change.
awaitTxOutStatusChange :: forall w s e. AsContractError e => TxOutRef -> Contract w s e TxOutStatus

-- | Get the configured parameter set.
getParams :: forall w s e. AsContractError e => Contract w s e Params

-- | Write the current state of the contract to a checkpoint.
checkpoint :: forall w s e a. (AsCheckpointError e, FromJSON a, ToJSON a) => Contract w s e a -> Contract w s e a
checkpointLoop :: forall w s e a b. (AsCheckpointError e, FromJSON a, ToJSON a, ToJSON b, FromJSON b) => (a -> Contract w s e (Either b a)) -> a -> Contract w s e b
class AsCheckpointError r_aQsK
_CheckpointError :: AsCheckpointError r_aQsK => Prism' r_aQsK CheckpointError
data CheckpointError
JSONDecodeError :: Text -> CheckpointError

-- | Alias for <tt>(r .! l)  a</tt>. It is a class rather than an alias,
--   so that it can be partially applied.
class r .! l  a => HasType (l :: Symbol) (a :: k) (r :: Row k)

-- | Constraints on the contract schema, ensuring that the labels of the
--   schema are unique.
type ContractRow s = (AllUniqueLabels (Input s), AllUniqueLabels (Output s))

-- | The minimum join of the two rows.
type family (l :: Row k) .\/ (r :: Row k) :: Row k
infixl 6 .\/

-- | Type level version of <tt>empty</tt>
type Empty = 'R '[] :: [LT a]

module Plutus.Trace.Emulator.Types

-- | Messages sent to, and received by, threads in the emulator.
data EmulatorMessage

-- | A new slot has begun and some blocks were added.
NewSlot :: [Block] -> Slot -> EmulatorMessage

-- | Call to an endpoint
EndpointCall :: ThreadId -> EndpointDescription -> Value -> EmulatorMessage

-- | Tell the contract instance to freeze itself (see note [Freeze and
--   Thaw])
Freeze :: EmulatorMessage

-- | Request for the current state of a contract instance
ContractInstanceStateRequest :: ThreadId -> EmulatorMessage

-- | Response to a contract instance state request
ContractInstanceStateResponse :: Value -> EmulatorMessage

-- | A map of contract instance ID to thread ID
newtype EmulatorThreads
EmulatorThreads :: Map ContractInstanceId ThreadId -> EmulatorThreads
[_instanceIdThreads] :: EmulatorThreads -> Map ContractInstanceId ThreadId
instanceIdThreads :: Iso' EmulatorThreads (Map ContractInstanceId ThreadId)

-- | Effects available to emulator agent threads. Includes emulated wallet
--   effects and effects related to threading / waiting for messages.
type EmulatorAgentThreadEffs effs = LogMsg ContractInstanceLog : EmulatedWalletEffects' (Yield (AgentSystemCall EmulatorMessage) (Maybe EmulatorMessage) : Reader ThreadId : effs)
type EmulatedWalletEffects = EmulatedWalletEffects' '[]

-- | Effects that are used to handle requests by contract instances. In the
--   emulator these effects are handled by <a>MultiAgent</a>. In the PAB
--   they are handled by the actual wallet<i>node</i>chain index, mediated
--   by the PAB runtime.
type EmulatedWalletEffects' effs = WalletEffect : Error WalletAPIError : NodeClientEffect : ChainIndexQueryEffect : LogObserve (LogMessage Text) : LogMsg RequestHandlerLogMsg : LogMsg TxBalanceMsg : LogMsg Text : effs

-- | A user-defined tag for a contract instance. Used to find the
--   instance's log messages in the emulator log.
data ContractInstanceTag
ContractInstanceTag :: Text -> Text -> ContractInstanceTag
[unContractInstanceTag] :: ContractInstanceTag -> Text
[shortContractInstanceTag] :: ContractInstanceTag -> Text

-- | The <a>ContractInstanceTag</a> for the contract instance of a wallet.
--   See note [Wallet contract instances]
walletInstanceTag :: Wallet -> ContractInstanceTag

-- | A reference to a running contract in the emulator.
data ContractHandle w s e
ContractHandle :: Contract w s e () -> ContractInstanceId -> ContractInstanceTag -> NetworkId -> ContractHandle w s e
[chContract] :: ContractHandle w s e -> Contract w s e ()
[chInstanceId] :: ContractHandle w s e -> ContractInstanceId
[chInstanceTag] :: ContractHandle w s e -> ContractInstanceTag
[chNetworkId] :: ContractHandle w s e -> NetworkId
data Emulator
type ContractConstraints s = (Forall (Output s) Unconstrained1, Forall (Input s) Unconstrained1, AllUniqueLabels (Input s), AllUniqueLabels (Output s), Forall (Input s) FromJSON, Forall (Input s) ToJSON, Forall (Output s) FromJSON, Forall (Output s) ToJSON)

-- | The state of a running contract instance with schema <tt>s</tt> and
--   error type <tt>e</tt> Serialisable to JSON.
data ContractInstanceState w (s :: Row *) e a
ContractInstanceState :: ResumableResult w e PABResp PABReq a -> Seq (Response PABResp) -> Seq [Request PABReq] -> ContractInstanceState w (s :: Row *) e a
[instContractState] :: ContractInstanceState w (s :: Row *) e a -> ResumableResult w e PABResp PABReq a

-- | Events received by the contract instance. (Used for debugging
--   purposes)
[instEvents] :: ContractInstanceState w (s :: Row *) e a -> Seq (Response PABResp)

-- | Requests issued by the contract instance (Used for debugging purposes)
[instHandlersHistory] :: ContractInstanceState w (s :: Row *) e a -> Seq [Request PABReq]

-- | State of the contract instance, internal to the contract instance
--   thread. It contains both the serialisable state of the contract
--   instance and the non-serialisable continuations in
--   <a>SuspendedContract</a>.
data ContractInstanceStateInternal w (s :: Row *) e a
ContractInstanceStateInternal :: SuspendedContract w e PABResp PABReq a -> Seq (Response PABResp) -> Seq [Request PABReq] -> ContractInstanceStateInternal w (s :: Row *) e a
[cisiSuspState] :: ContractInstanceStateInternal w (s :: Row *) e a -> SuspendedContract w e PABResp PABReq a
[cisiEvents] :: ContractInstanceStateInternal w (s :: Row *) e a -> Seq (Response PABResp)
[cisiHandlersHistory] :: ContractInstanceStateInternal w (s :: Row *) e a -> Seq [Request PABReq]
emptyInstanceState :: forall w (s :: Row *) e a. Monoid w => Contract w s e a -> ContractInstanceStateInternal w s e a
addEventInstanceState :: forall w s e a. Monoid w => Response PABResp -> ContractInstanceStateInternal w s e a -> Maybe (ContractInstanceStateInternal w s e a)

-- | Extract the serialisable <a>ContractInstanceState</a> from the
--   <a>ContractInstanceStateInternal</a>. We need to do this when we want
--   to send the instance state to another thread.
toInstanceState :: ContractInstanceStateInternal w (s :: Row *) e a -> ContractInstanceState w s e a
data ContractInstanceLog
ContractInstanceLog :: ContractInstanceMsg -> ContractInstanceId -> ContractInstanceTag -> ContractInstanceLog
[_cilMessage] :: ContractInstanceLog -> ContractInstanceMsg
[_cilId] :: ContractInstanceLog -> ContractInstanceId
[_cilTag] :: ContractInstanceLog -> ContractInstanceTag
cilId :: Lens' ContractInstanceLog ContractInstanceId
cilMessage :: Lens' ContractInstanceLog ContractInstanceMsg
cilTag :: Lens' ContractInstanceLog ContractInstanceTag
data EmulatorRuntimeError
ThreadIdNotFound :: ContractInstanceId -> EmulatorRuntimeError
InstanceIdNotFound :: Wallet -> EmulatorRuntimeError
EmulatorJSONDecodingError :: String -> Value -> EmulatorRuntimeError
GenericError :: String -> EmulatorRuntimeError
EmulatedWalletError :: WalletAPIError -> EmulatorRuntimeError
AssertionError :: String -> EmulatorRuntimeError

-- | Log messages produced by contract instances
data ContractInstanceMsg
Started :: ContractInstanceMsg
StoppedNoError :: ContractInstanceMsg
StoppedWithError :: String -> ContractInstanceMsg
ReceiveEndpointCall :: EndpointDescription -> Value -> ContractInstanceMsg
ReceiveEndpointCallSuccess :: ContractInstanceMsg
ReceiveEndpointCallFailure :: NotificationError -> ContractInstanceMsg
NoRequestsHandled :: ContractInstanceMsg
HandledRequest :: Response Value -> ContractInstanceMsg
CurrentRequests :: [Request Value] -> ContractInstanceMsg
InstErr :: EmulatorRuntimeError -> ContractInstanceMsg
ContractLog :: Value -> ContractInstanceMsg
SendingNotification :: Notification -> ContractInstanceMsg
NotificationSuccess :: Notification -> ContractInstanceMsg
NotificationFailure :: NotificationError -> ContractInstanceMsg
SendingContractState :: ThreadId -> ContractInstanceMsg
Freezing :: ContractInstanceMsg
_Started :: Prism' ContractInstanceMsg ()
_StoppedNoError :: Prism' ContractInstanceMsg ()
_StoppedWithError :: Prism' ContractInstanceMsg String
_ReceiveEndpointCall :: Prism' ContractInstanceMsg (EndpointDescription, Value)
_NoRequestsHandled :: Prism' ContractInstanceMsg ()
_HandledRequest :: Prism' ContractInstanceMsg (Response Value)
_CurrentRequests :: Prism' ContractInstanceMsg [Request Value]
_InstErr :: Prism' ContractInstanceMsg EmulatorRuntimeError
_ContractLog :: Prism' ContractInstanceMsg Value

-- | Log message produced by the user (main) thread
data UserThreadMsg
UserThreadErr :: EmulatorRuntimeError -> UserThreadMsg
UserLog :: String -> UserThreadMsg
instance GHC.Show.Show Plutus.Trace.Emulator.Types.OnInitialThreadStopped
instance GHC.Classes.Ord Plutus.Trace.Emulator.Types.OnInitialThreadStopped
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.OnInitialThreadStopped
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Show.Show Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.ContractInstanceTag
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.ContractInstanceTag
instance GHC.Show.Show Plutus.Trace.Emulator.Types.ContractInstanceTag
instance GHC.Classes.Ord Plutus.Trace.Emulator.Types.ContractInstanceTag
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.UserThreadMsg
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.UserThreadMsg
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.UserThreadMsg
instance GHC.Show.Show Plutus.Trace.Emulator.Types.UserThreadMsg
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.UserThreadMsg
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance GHC.Show.Show Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.ContractInstanceLog
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.ContractInstanceLog
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.ContractInstanceLog
instance GHC.Show.Show Plutus.Trace.Emulator.Types.ContractInstanceLog
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.ContractInstanceLog
instance GHC.Generics.Generic (Plutus.Trace.Emulator.Types.ContractInstanceState w s e a)
instance (Data.Aeson.Types.ToJSON.ToJSON e, Data.Aeson.Types.ToJSON.ToJSON a, Data.Aeson.Types.ToJSON.ToJSON w) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Trace.Emulator.Types.ContractInstanceState w s e a)
instance (Data.Aeson.Types.FromJSON.FromJSON e, Data.Aeson.Types.FromJSON.FromJSON a, Data.Aeson.Types.FromJSON.FromJSON w) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Trace.Emulator.Types.ContractInstanceState w s e a)
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.ContractInstanceLog
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.UserThreadMsg
instance Control.DeepSeq.NFData Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Data.String.IsString Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Show.Show Plutus.Trace.Emulator.Types.EmulatorMessage
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.EmulatorMessage
instance GHC.Base.Monoid Plutus.Trace.Emulator.Types.EmulatorThreads
instance GHC.Base.Semigroup Plutus.Trace.Emulator.Types.EmulatorThreads

module Wallet.Emulator.MultiAgent

-- | Assertions which will be checked during execution of the emulator.
data Assertion

-- | Assert that the given transaction is validated.
IsValidated :: CardanoTx -> Assertion

-- | Assert that the funds belonging to a wallet's public-key address are
--   equal to a value.
OwnFundsEqual :: Wallet -> Value -> Assertion

-- | An event with a timestamp measured in emulator time (currently:
--   <a>Slot</a>)
data EmulatorTimeEvent e
EmulatorTimeEvent :: Slot -> e -> EmulatorTimeEvent e
[_eteEmulatorTime] :: EmulatorTimeEvent e -> Slot
[_eteEvent] :: EmulatorTimeEvent e -> e
eteEvent :: forall e_a5TmF e_a5TBR. Lens (EmulatorTimeEvent e_a5TmF) (EmulatorTimeEvent e_a5TBR) e_a5TmF e_a5TBR
eteEmulatorTime :: forall e_a5TmF. Lens' (EmulatorTimeEvent e_a5TmF) Slot
emulatorTimeEvent :: Slot -> Prism' (EmulatorTimeEvent e) e

-- | Events produced by the blockchain emulator.
data EmulatorEvent'
ChainEvent :: ChainEvent -> EmulatorEvent'
ClientEvent :: Wallet -> NodeClientEvent -> EmulatorEvent'
WalletEvent :: Wallet -> WalletEvent -> EmulatorEvent'
ChainIndexEvent :: Wallet -> ChainIndexLog -> EmulatorEvent'
SchedulerEvent :: SchedulerLog -> EmulatorEvent'
InstanceEvent :: ContractInstanceLog -> EmulatorEvent'
UserThreadEvent :: UserThreadMsg -> EmulatorEvent'
type EmulatorEvent = EmulatorTimeEvent EmulatorEvent'
chainEvent :: Prism' EmulatorEvent' ChainEvent
walletClientEvent :: Wallet -> Prism' EmulatorEvent' NodeClientEvent
walletEvent :: Wallet -> Prism' EmulatorEvent' WalletEvent
walletEvent' :: Prism' EmulatorEvent' (Wallet, WalletEvent)
chainIndexEvent :: Wallet -> Prism' EmulatorEvent' ChainIndexLog
schedulerEvent :: Prism' EmulatorEvent' SchedulerLog
instanceEvent :: Prism' EmulatorEvent' ContractInstanceLog
userThreadEvent :: Prism' EmulatorEvent' UserThreadMsg
type EmulatedWalletControlEffects = '[NodeClientControlEffect, ChainIndexControlEffect, SigningProcessControlEffect, LogObserve (LogMessage Text), LogMsg Text]

-- | The type of actions in the emulator.
data MultiAgentEffect r

-- | A direct action performed by a wallet. Usually represents a "user
--   action", as it is triggered externally.
[WalletAction] :: Wallet -> Eff EmulatedWalletEffects r -> MultiAgentEffect r
data MultiAgentControlEffect r

-- | An action affecting the emulated parts of a wallet (only available in
--   emulator - see note [Control effects].)
[WalletControlAction] :: Wallet -> Eff EmulatedWalletControlEffects r -> MultiAgentControlEffect r

-- | An assertion in the event stream, which can inspect the current state.
[Assertion] :: Assertion -> MultiAgentControlEffect ()

-- | Run an action in the context of a wallet (ie. agent)
walletAction :: Member MultiAgentEffect effs => Wallet -> Eff EmulatedWalletEffects r -> Eff effs r
handleMultiAgentEffects :: forall effs. Member MultiAgentEffect effs => Wallet -> Eff (EmulatedWalletEffects' effs) ~> Eff effs
raiseWallet :: forall f effs. (Member f EmulatedWalletEffects, Member MultiAgentEffect effs) => Wallet -> f ~> Eff effs

-- | Run a control action in the context of a wallet
walletControlAction :: Member MultiAgentControlEffect effs => Wallet -> Eff EmulatedWalletControlEffects r -> Eff effs r
assertion :: Member MultiAgentControlEffect effs => Assertion -> Eff effs ()

-- | Issue an assertion that the funds for a given wallet have the given
--   value.
assertOwnFundsEq :: Member MultiAgentControlEffect effs => Wallet -> Value -> Eff effs ()

-- | Issue an assertion that the given transaction has been validated.
assertIsValidated :: Member MultiAgentControlEffect effs => CardanoTx -> Eff effs ()

-- | The state of the emulator itself.
data EmulatorState
EmulatorState :: ChainState -> Map Wallet WalletState -> [LogMessage EmulatorEvent] -> EmulatorState

-- | Mockchain
[_chainState] :: EmulatorState -> ChainState

-- | The state of each agent.
[_walletStates] :: EmulatorState -> Map Wallet WalletState

-- | The emulator log messages, with the newest last.
[_emulatorLog] :: EmulatorState -> [LogMessage EmulatorEvent]
walletStates :: Lens' EmulatorState (Map Wallet WalletState)
emulatorLog :: Lens' EmulatorState [LogMessage EmulatorEvent]
chainState :: Lens' EmulatorState ChainState
walletState :: Wallet -> Lens' EmulatorState WalletState

-- | Get the blockchain as a list of blocks, starting with the oldest
--   (genesis) block.
chainOldestFirst :: Lens' EmulatorState Blockchain
chainUtxo :: Getter EmulatorState AddressMap

-- | Get a map with the total value of each wallet's "own funds".
fundsDistribution :: EmulatorState -> Map Wallet Value

-- | Get the emulator log.
emLog :: EmulatorState -> [LogMessage EmulatorEvent]
emptyEmulatorState :: EmulatorState

-- | Initialise the emulator state with a blockchain.
emulatorState :: Blockchain -> EmulatorState

-- | Initialise the emulator state with a pool of pending transactions.
emulatorStatePool :: TxPool -> EmulatorState

-- | Initialise the emulator state with a single pending transaction that
--   creates the initial distribution of funds to public key addresses.
emulatorStateInitialDist :: Params -> Map PaymentPubKeyHash Value -> Either ToCardanoError EmulatorState
type MultiAgentEffs = '[State EmulatorState, LogMsg EmulatorEvent', Error WalletAPIError, Error ChainIndexError, Error AssertionError, ChainEffect, ChainControlEffect]
handleMultiAgentControl :: forall effs. Members MultiAgentEffs effs => Eff (MultiAgentControlEffect : effs) ~> Eff effs
handleMultiAgent :: forall effs. Members MultiAgentEffs effs => Eff (MultiAgentEffect : effs) ~> Eff effs

-- | Issue an <a>Assertion</a>.
assert :: Members MultiAgentEffs effs => Assertion -> Eff effs ()

-- | Issue an assertion that the funds for a given wallet have the given
--   value.
ownFundsEqual :: Members MultiAgentEffs effs => Wallet -> Value -> Eff effs ()

-- | Issue an assertion that the given transaction has been validated.
isValidated :: Members MultiAgentEffs effs => CardanoTx -> Eff effs ()
_singleton :: AReview [a] a
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.MultiAgent.EmulatorEvent'
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.MultiAgent.EmulatorEvent'
instance GHC.Generics.Generic Wallet.Emulator.MultiAgent.EmulatorEvent'
instance GHC.Show.Show Wallet.Emulator.MultiAgent.EmulatorEvent'
instance GHC.Classes.Eq Wallet.Emulator.MultiAgent.EmulatorEvent'
instance GHC.Show.Show Wallet.Emulator.MultiAgent.EmulatorState
instance Prettyprinter.Internal.Pretty Wallet.Emulator.MultiAgent.EmulatorEvent'
instance Prettyprinter.Internal.Pretty e => Prettyprinter.Internal.Pretty (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance Data.Aeson.Types.FromJSON.FromJSON e => Data.Aeson.Types.FromJSON.FromJSON (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance Data.Aeson.Types.ToJSON.ToJSON e => Data.Aeson.Types.ToJSON.ToJSON (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance Data.Traversable.Traversable Wallet.Emulator.MultiAgent.EmulatorTimeEvent
instance Data.Foldable.Foldable Wallet.Emulator.MultiAgent.EmulatorTimeEvent
instance GHC.Base.Functor Wallet.Emulator.MultiAgent.EmulatorTimeEvent
instance GHC.Generics.Generic (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance GHC.Show.Show e => GHC.Show.Show (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)

module Wallet.Emulator.Types

-- | A wallet identifier
data Wallet
Wallet :: Maybe String -> WalletId -> Wallet
[prettyWalletName] :: Wallet -> Maybe String
[getWalletId] :: Wallet -> WalletId
newtype WalletId
WalletId :: WalletId -> WalletId
[unWalletId] :: WalletId -> WalletId
data XPrv
data XPub

-- | Get the cardano address of a mock wallet. (Fails if the wallet is not
--   a mock wallet).
mockWalletAddress :: Wallet -> CardanoAddress

-- | The public key of a mock wallet. (Fails if the wallet is not a mock
--   wallet).
mockWalletPaymentPubKey :: Wallet -> PaymentPubKey

-- | The payment public key hash of a mock wallet. (Fails if the wallet is
--   not a mock wallet).
mockWalletPaymentPubKeyHash :: Wallet -> PaymentPubKeyHash

-- | Sign the transaction with a <a>PrivateKey</a> and passphrase
--   (ByteString) and add the signature to the transaction's list of
--   signatures.
addSignature :: PrivateKey -> Passphrase -> Tx -> Tx
knownWallets :: [Wallet]
knownWallet :: Integer -> Wallet

-- | Wrapper for config files and APIs
newtype WalletNumber
WalletNumber :: Integer -> WalletNumber
[getWallet] :: WalletNumber -> Integer
toWalletNumber :: MockWallet -> WalletNumber
fromWalletNumber :: WalletNumber -> Wallet

-- | Emulated wallet with a key and a passphrase
data MockWallet
MockWallet :: Digest Blake2b_160 -> MockPrivateKey -> Maybe MockPrivateKey -> Maybe String -> MockWallet
[mwWalletId] :: MockWallet -> Digest Blake2b_160
[mwPaymentKey] :: MockWallet -> MockPrivateKey
[mwStakeKey] :: MockWallet -> Maybe MockPrivateKey
[mwPrintAs] :: MockWallet -> Maybe String

-- | A pool of transactions which have yet to be validated.
type TxPool = [CardanoTx]
type EmulatorEffs = '[MultiAgentEffect, ChainEffect, ChainControlEffect]

-- | Assertions which will be checked during execution of the emulator.
data Assertion

-- | Assert that the given transaction is validated.
IsValidated :: CardanoTx -> Assertion

-- | Assert that the funds belonging to a wallet's public-key address are
--   equal to a value.
OwnFundsEqual :: Wallet -> Value -> Assertion

-- | Issue an <a>Assertion</a>.
assert :: Members MultiAgentEffs effs => Assertion -> Eff effs ()

-- | Issue an assertion that the given transaction has been validated.
assertIsValidated :: Member MultiAgentControlEffect effs => CardanoTx -> Eff effs ()

-- | An error emitted when an <tt>Assertion</tt> fails.
newtype AssertionError
GenericAssertion :: Text -> AssertionError
[unAssertionError] :: AssertionError -> Text
class AsAssertionError r_a4SOO
_AssertionError :: AsAssertionError r_a4SOO => Prism' r_a4SOO AssertionError
_GenericAssertion :: AsAssertionError r_a4SOO => Prism' r_a4SOO Text
data ChainClientNotification
BlockValidated :: Block -> ChainClientNotification
SlotChanged :: Slot -> ChainClientNotification
type EmulatorEvent = EmulatorTimeEvent EmulatorEvent'

-- | Events produced by the blockchain emulator.
data EmulatorEvent'

-- | An event with a timestamp measured in emulator time (currently:
--   <a>Slot</a>)
data EmulatorTimeEvent e
EmulatorTimeEvent :: Slot -> e -> EmulatorTimeEvent e
[_eteEmulatorTime] :: EmulatorTimeEvent e -> Slot
[_eteEvent] :: EmulatorTimeEvent e -> e

-- | The state used by the mock wallet environment.
data WalletState
WalletState :: MockWallet -> NodeClientState -> ChainIndexEmulatorState -> Maybe SigningProcess -> WalletState

-- | Mock wallet with the user's private key.
[_mockWallet] :: WalletState -> MockWallet

-- | The representation of the node, as known by the wallet
[_nodeClient] :: WalletState -> NodeClientState

-- | the chain index info known by the wallet
[_chainIndexEmulatorState] :: WalletState -> ChainIndexEmulatorState

-- | Override the signing process. Used for testing multi-agent use cases.
[_signingProcess] :: WalletState -> Maybe SigningProcess

-- | Empty wallet state for an emulator <a>Wallet</a>. Returns
--   <a>Nothing</a> if the wallet is not known in the emulator.
emptyWalletState :: Wallet -> Maybe WalletState
ownPaymentPrivateKey :: WalletState -> PaymentPrivateKey

-- | Get the user's own payment public-key address.
ownAddress :: WalletState -> CardanoAddress

-- | Run an action in the context of a wallet (ie. agent)
walletAction :: Member MultiAgentEffect effs => Wallet -> Eff EmulatedWalletEffects r -> Eff effs r
assertion :: Member MultiAgentControlEffect effs => Assertion -> Eff effs ()

-- | Issue an assertion that the funds for a given wallet have the given
--   value.
assertOwnFundsEq :: Member MultiAgentControlEffect effs => Wallet -> Value -> Eff effs ()

-- | Issue an assertion that the funds for a given wallet have the given
--   value.
ownFundsEqual :: Members MultiAgentEffs effs => Wallet -> Value -> Eff effs ()

-- | The state of the emulator itself.
data EmulatorState
EmulatorState :: ChainState -> Map Wallet WalletState -> [LogMessage EmulatorEvent] -> EmulatorState

-- | Mockchain
[_chainState] :: EmulatorState -> ChainState

-- | The state of each agent.
[_walletStates] :: EmulatorState -> Map Wallet WalletState

-- | The emulator log messages, with the newest last.
[_emulatorLog] :: EmulatorState -> [LogMessage EmulatorEvent]
emptyEmulatorState :: EmulatorState

-- | Initialise the emulator state with a blockchain.
emulatorState :: Blockchain -> EmulatorState

-- | Initialise the emulator state with a pool of pending transactions.
emulatorStatePool :: TxPool -> EmulatorState

-- | Initialise the emulator state with a single pending transaction that
--   creates the initial distribution of funds to public key addresses.
emulatorStateInitialDist :: Params -> Map PaymentPubKeyHash Value -> Either ToCardanoError EmulatorState
txPool :: Lens' ChainState TxPool
walletStates :: Lens' EmulatorState (Map Wallet WalletState)
index :: Lens' ChainState UtxoIndex
chainState :: Lens' EmulatorState ChainState
chainCurrentSlot :: Lens' ChainState Slot
processEmulated :: forall effs. (Member (Error WalletAPIError) effs, Member (Error ChainIndexError) effs, Member (Error AssertionError) effs, Member (State EmulatorState) effs, Member (LogMsg EmulatorEvent') effs) => Params -> Eff (MultiAgentEffect : (MultiAgentControlEffect : (ChainEffect : (ChainControlEffect : effs)))) ~> Eff effs

-- | Get a map with the total value of each wallet's "own funds".
fundsDistribution :: EmulatorState -> Map Wallet Value

-- | Get the emulator log.
emLog :: EmulatorState -> [LogMessage EmulatorEvent]

module Wallet.Emulator


-- | A trace is a sequence of actions by simulated wallets that can be run
--   on the mockchain. This module contains the functions needed to build
--   traces.
module Plutus.Contract.Trace

-- | Error produced while running a trace. Either a contract-specific error
--   (of type <tt>e</tt>), or an <a>AssertionError</a> from the emulator.
data TraceError e
TraceAssertionError :: AssertionError -> TraceError e
TContractError :: e -> TraceError e
HookError :: EndpointError -> TraceError e
data EndpointError
EndpointNotActive :: Maybe Wallet -> EndpointDescription -> EndpointError
class AsTraceError r_a6a1b e_a69FU | r_a6a1b -> e_a69FU
_TraceError :: AsTraceError r_a6a1b e_a69FU => Prism' r_a6a1b (TraceError e_a69FU)
_TraceAssertionError :: AsTraceError r_a6a1b e_a69FU => Prism' r_a6a1b AssertionError
_TContractError :: AsTraceError r_a6a1b e_a69FU => Prism' r_a6a1b e_a69FU
_HookError :: AsTraceError r_a6a1b e_a69FU => Prism' r_a6a1b EndpointError
toNotifyError :: ContractInstanceId -> EndpointError -> NotificationError
handleAdjustUnbalancedTx :: (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleSlotNotifications :: (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleTimeNotifications :: (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleOwnAddressesQueries :: (Member (LogObserve (LogMessage Text)) effs, Member WalletEffect effs) => RequestHandler effs PABReq PABResp
handleCurrentNodeClientSlotQueries :: (Member (LogObserve (LogMessage Text)) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleCurrentChainIndexSlotQueries :: (Member (LogObserve (LogMessage Text)) effs, Member ChainIndexQueryEffect effs) => RequestHandler effs PABReq PABResp
handleCurrentTimeQueries :: (Member (LogObserve (LogMessage Text)) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleCurrentNodeClientTimeRangeQueries :: (Member (LogObserve (LogMessage Text)) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleTimeToSlotConversions :: (Member (LogObserve (LogMessage Text)) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleUnbalancedTransactions :: (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member WalletEffect effs) => RequestHandler effs PABReq PABResp

-- | Submit the wallet's pending transactions to the blockchain.
handlePendingTransactions :: (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member WalletEffect effs) => RequestHandler effs PABReq PABResp
handleChainIndexQueries :: (Member (LogObserve (LogMessage Text)) effs, Member ChainIndexQueryEffect effs) => RequestHandler effs PABReq PABResp
handleOwnInstanceIdQueries :: (Member (LogObserve (LogMessage Text)) effs, Member (Reader ContractInstanceId) effs) => RequestHandler effs PABReq PABResp
handleYieldedUnbalancedTx :: (Member (LogObserve (LogMessage Text)) effs, Member WalletEffect effs) => RequestHandler effs PABReq PABResp
handleGetParams :: (Member (LogObserve (LogMessage Text)) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
type InitialDistribution = Map Wallet Value
defaultDist :: InitialDistribution
defaultDistFor :: [Wallet] -> InitialDistribution

-- | A wallet identifier
data Wallet
Wallet :: Maybe String -> WalletId -> Wallet
[prettyWalletName] :: Wallet -> Maybe String
[getWalletId] :: Wallet -> WalletId

-- | Get the cardano address of a mock wallet. (Fails if the wallet is not
--   a mock wallet).
mockWalletAddress :: Wallet -> CardanoAddress

-- | The public key of a mock wallet. (Fails if the wallet is not a mock
--   wallet).
mockWalletPaymentPubKey :: Wallet -> PaymentPubKey

-- | The payment public key hash of a mock wallet. (Fails if the wallet is
--   not a mock wallet).
mockWalletPaymentPubKeyHash :: Wallet -> PaymentPubKeyHash
knownWallets :: [Wallet]
knownWallet :: Integer -> Wallet
instance Plutus.Contract.Trace.AsTraceError (Plutus.Contract.Trace.TraceError e) e
instance Plutus.Contract.Error.AsAssertionError (Plutus.Contract.Trace.TraceError e)
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Trace.EndpointError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Trace.EndpointError
instance GHC.Generics.Generic Plutus.Contract.Trace.EndpointError
instance GHC.Show.Show Plutus.Contract.Trace.EndpointError
instance GHC.Classes.Eq Plutus.Contract.Trace.EndpointError
instance GHC.Show.Show e => GHC.Show.Show (Plutus.Contract.Trace.TraceError e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Plutus.Contract.Trace.TraceError e)
instance Prettyprinter.Internal.Pretty Plutus.Contract.Trace.EndpointError


-- | Interfacing with the wallet (for making payments)
module Plutus.Trace.Effects.EmulatedWalletAPI
data EmulatedWalletAPI r
[LiftWallet] :: Wallet -> Eff '[WalletEffect, Error WalletAPIError, LogMsg Text, LogMsg RequestHandlerLogMsg] a -> EmulatedWalletAPI a
liftWallet :: forall a_a6caP. forall effs_a6cbo. Member EmulatedWalletAPI effs_a6cbo => Wallet -> Eff ('(:) WalletEffect ('(:) (Error WalletAPIError) ('(:) (LogMsg Text) ('(:) (LogMsg RequestHandlerLogMsg) ('[] :: [Type -> Type]))))) a_a6caP -> Eff effs_a6cbo a_a6caP

-- | Make a payment from one wallet to another
payToWallet :: forall effs. Member EmulatedWalletAPI effs => Wallet -> Wallet -> Value -> Eff effs TxId

-- | Handle the <a>EmulatedWalletAPI</a> effect using the emulator's
--   <tt>MultiAgent</tt> effect.
handleEmulatedWalletAPI :: Member MultiAgentEffect effs => EmulatedWalletAPI ~> Eff effs

module Plutus.Trace.Emulator.System

-- | Start the system threads.
launchSystemThreads :: forall effs a. (Member ChainControlEffect effs, Member MultiAgentEffect effs, Member MultiAgentControlEffect effs) => [Wallet] -> Eff (Yield (EmSystemCall effs EmulatorMessage a) (Maybe EmulatorMessage) : effs) ()

-- | Append a block to the chain index for a specific slot.
appendNewTipBlock :: Member ChainIndexControlEffect effs => Tip -> Block -> Slot -> Eff effs ()


-- | Waiting for things to happen
module Plutus.Trace.Effects.Waiting
data Waiting r
[WaitUntilSlot] :: Slot -> Waiting Slot
[GetSlotConfig] :: Waiting SlotConfig
waitUntilSlot :: forall effs_a6dOC. Member Waiting effs_a6dOC => Slot -> Eff effs_a6dOC Slot

-- | Wait until the slot where the given time falls into and return latest
--   time we know has passed.
waitUntilTime :: Member Waiting effs => POSIXTime -> Eff effs POSIXTime

-- | Wait until the beginning of the next slot, returning the new slot
--   number.
nextSlot :: Member Waiting effs => Eff effs Slot

-- | Wait for a number of slots
waitNSlots :: forall effs. Member Waiting effs => Natural -> Eff effs Slot

-- | Convert the given <tt>n</tt> milliseconds to a number of slots to
--   wait.
--   
--   Note: Currently, if n &lt; length of a slot, then
--   <a>waitNMilliSeconds</a> has no effect.
waitNMilliSeconds :: forall effs. Member Waiting effs => DiffMilliSeconds -> Eff effs Slot
handleWaiting :: forall effs effs2 a. Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs => SlotConfig -> Waiting ~> Eff effs

module Plutus.Trace.Effects.Assert
data Assert r
[Assert] :: String -> (EmulatorState -> Bool) -> Assert ()
assert :: forall effs_a6eep. Member Assert effs_a6eep => String -> (EmulatorState -> Bool) -> Eff effs_a6eep ()

-- | Pass <a>EmulatorState</a> to the provided predicate and throw error
--   unless it's true.
handleAssert :: forall effs effs2 a. (Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs, Member (Error EmulatorRuntimeError) effs, Member (State EmulatorState) effs) => Assert ~> Eff effs

module Plutus.Contract.Test.Coverage

-- | Get every endpoint name that has been invoked in the emulator events
--   in <tt>es</tt> indexed by <a>ContractInstanceTag</a>
getInvokedEndpoints :: [EmulatorEvent] -> Map ContractInstanceTag (Set String)

-- | Collect every executed coverage annotation in the validators executed
--   in <tt>es</tt>
getCoverageData :: [EmulatorEvent] -> CoverageData
newtype CoverageRef
CoverageRef :: IORef CoverageData -> CoverageRef
newCoverageRef :: IO CoverageRef
readCoverageRef :: CoverageRef -> IO CoverageData

-- | Write a coverage report to name.html for the given index.
writeCoverageReport :: String -> CoverageReport -> IO ()

module Plutus.Trace.Emulator.ContractInstance

-- | Start a new thread for a contract. Most of the work happens in
--   <a>runInstance</a>.
contractThread :: forall w s e effs. (Member (State EmulatorThreads) effs, Member (Error EmulatorRuntimeError) effs, ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w) => ContractHandle w s e -> Eff (EmulatorAgentThreadEffs effs) ()
getThread :: forall effs. (Member (State EmulatorThreads) effs, Member (Error EmulatorRuntimeError) effs) => ContractInstanceId -> Eff effs ThreadId
data EmulatorRuntimeError

-- | Run an instance of a contract
runInstance :: forall w s e effs. (ContractConstraints s, Member (Error EmulatorRuntimeError) effs, Show e, ToJSON e, ToJSON w, Monoid w) => NetworkId -> Contract w s e () -> Maybe EmulatorMessage -> Eff (ContractInstanceThreadEffs w s e effs) ()

-- | The state of a running contract instance with schema <tt>s</tt> and
--   error type <tt>e</tt> Serialisable to JSON.
data ContractInstanceState w (s :: Row *) e a
ContractInstanceState :: ResumableResult w e PABResp PABReq a -> Seq (Response PABResp) -> Seq [Request PABReq] -> ContractInstanceState w (s :: Row *) e a
[instContractState] :: ContractInstanceState w (s :: Row *) e a -> ResumableResult w e PABResp PABReq a

-- | Events received by the contract instance. (Used for debugging
--   purposes)
[instEvents] :: ContractInstanceState w (s :: Row *) e a -> Seq (Response PABResp)

-- | Requests issued by the contract instance (Used for debugging purposes)
[instHandlersHistory] :: ContractInstanceState w (s :: Row *) e a -> Seq [Request PABReq]
emptyInstanceState :: forall w (s :: Row *) e a. Monoid w => Contract w s e a -> ContractInstanceStateInternal w s e a
addEventInstanceState :: forall w s e a. Monoid w => Response PABResp -> ContractInstanceStateInternal w s e a -> Maybe (ContractInstanceStateInternal w s e a)

-- | A block of transactions, indexed by tx outputs spent and by addresses
--   on which new outputs are produced
data IndexedBlock
IndexedBlock :: Map TxOutRef ChainIndexTx -> Map CardanoAddress (NonEmpty ChainIndexTx) -> IndexedBlock
[ibUtxoSpent] :: IndexedBlock -> Map TxOutRef ChainIndexTx
[ibUtxoProduced] :: IndexedBlock -> Map CardanoAddress (NonEmpty ChainIndexTx)
indexBlock :: [ChainIndexTx] -> IndexedBlock
getHooks :: forall w s e effs. Member (State (ContractInstanceStateInternal w s e ())) effs => Eff effs [Request PABReq]

-- | Add a <a>Response</a> to the contract instance state
addResponse :: forall w s e effs. (Member (State (ContractInstanceStateInternal w s e ())) effs, Member (LogMsg ContractInstanceMsg) effs, Monoid w) => Response PABResp -> Eff effs ()
instance GHC.Base.Semigroup Plutus.Trace.Emulator.ContractInstance.IndexedBlock
instance GHC.Base.Monoid Plutus.Trace.Emulator.ContractInstance.IndexedBlock


-- | Running emulator actions that produce streams of events
module Wallet.Emulator.Stream
data EmulatorConfig
EmulatorConfig :: InitialChainState -> Params -> EmulatorConfig

-- | State of the blockchain at the beginning of the simulation. Can be
--   given as a map of funds to wallets, or as a block of transactions.
[_initialChainState] :: EmulatorConfig -> InitialChainState

-- | Set the protocol parameters, network ID and slot configuration for the
--   emulator.
[_params] :: EmulatorConfig -> Params
data EmulatorErr
WalletErr :: WalletAPIError -> EmulatorErr
ChainIndexErr :: ChainIndexError -> EmulatorErr
AssertionErr :: AssertionError -> EmulatorErr
InstanceErr :: EmulatorRuntimeError -> EmulatorErr
ExitWasNeverCalled :: EmulatorErr
type InitialChainState = Either InitialDistribution [CardanoTx]
initialChainState :: Lens' EmulatorConfig InitialChainState

-- | The wallets' initial funds
initialDist :: EmulatorConfig -> InitialDistribution
initialState :: EmulatorConfig -> EmulatorState
params :: Lens' EmulatorConfig Params

-- | Turn an emulator action into a <a>Stream</a> of emulator log messages,
--   returning the final state of the emulator.
runTraceStream :: forall effs a. EmulatorConfig -> Eff '[State EmulatorState, LogMsg EmulatorEvent', MultiAgentEffect, MultiAgentControlEffect, ChainEffect, ChainControlEffect, Error EmulatorRuntimeError] (Maybe a) -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) (Either EmulatorErr a, EmulatorState)

-- | Finish the stream at the end of the given slot.
takeUntilSlot :: forall effs a. Slot -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) a -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) ()

-- | Remove from the stream all log messages whose log level is lower than
--   the the given level.
filterLogLevel :: forall effs a. LogLevel -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) a -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) a

-- | Apply a fold to an effectful stream of events.
foldStreamM :: forall m a b c. Monad m => FoldM m a b -> Stream (Of a) m c -> m (Of b c)

-- | Consume an emulator event stream.
foldEmulatorStreamM :: forall effs a b. FoldM (Eff effs) EmulatorEvent b -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) a -> Eff effs (Of b a)
instance GHC.Show.Show Wallet.Emulator.Stream.EmulatorConfig
instance GHC.Classes.Eq Wallet.Emulator.Stream.EmulatorConfig
instance GHC.Show.Show Wallet.Emulator.Stream.EmulatorErr
instance Data.Default.Class.Default Wallet.Emulator.Stream.EmulatorConfig

module Wallet.Emulator.Folds
type EmulatorEventFold a = Fold EmulatorEvent a

-- | A fold over emulator events that can fail with <a>EmulatorFoldErr</a>
type EmulatorEventFoldM effs a = FoldM (Eff effs) EmulatorEvent a
data EmulatorFoldErr
InstanceStateJSONDecodingError :: String -> Response Value -> EmulatorFoldErr

-- | A human-readable explanation of the error, to be included in the logs.
describeError :: EmulatorFoldErr -> String

-- | The state of a contract instance, recovered from the emulator log.
instanceState :: forall w s e a effs. (Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs (Maybe (ContractInstanceState w s e a))

-- | The list of open requests of the contract instance at its latest
--   iteration
instanceRequests :: forall w s e a effs. (Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs [Request PABReq]

-- | The reponses received by the contract instance
instanceResponses :: forall w s e a effs. (Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs [Response PABResp]

-- | The final state of the instance
instanceOutcome :: forall w s e a effs. (Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs (Outcome e a)

-- | The unbalanced transactions generated by the contract instance.
instanceTransactions :: forall w s e a effs. (Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs [UnbalancedTx]
data Outcome e a

-- | The contract finished without errors and produced a result
Done :: a -> Outcome e a

-- | The contract is waiting for more input.
NotDone :: Outcome e a

-- | The contract failed with an error.
Failed :: e -> Outcome e a

-- | The log messages produced by the contract instance.
instanceLog :: ContractInstanceTag -> EmulatorEventFold [EmulatorTimeEvent ContractInstanceLog]

-- | Accumulated state of the contract instance
instanceAccumState :: forall w s e a effs. (Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs w

-- | All chain events emitted by the node
chainEvents :: EmulatorEventFold [ChainEvent]

-- | Transactions that failed to validate, in the given validation phase
--   (if specified).
failedTransactions :: Maybe ValidationPhase -> EmulatorEventFold [(TxId, CardanoTx, ValidationError, Value, [Text])]

-- | Transactions that were validated
validatedTransactions :: EmulatorEventFold [(TxId, CardanoTx, [Text])]

-- | Unspent outputs at an address
utxoAtAddress :: CardanoAddress -> EmulatorEventFold UtxoMap

-- | The total value of unspent outputs at an address
valueAtAddress :: CardanoAddress -> EmulatorEventFold Value

-- | The funds belonging to a wallet
walletFunds :: Wallet -> EmulatorEventFold Value

-- | The fees paid by a wallet
walletFees :: Wallet -> EmulatorEventFold Value

-- | Unbalanced transactions that are sent to the wallet for balancing
walletTxBalanceEvents :: EmulatorEventFold [UnbalancedTx]

-- | Min lovelace of <tt>txOut</tt>s from adjusted unbalanced transactions
--   for all wallets
walletsAdjustedTxEvents :: EmulatorEventFold [Ada]

-- | Annotate the transactions that were validated by the node
annotatedBlockchain :: EmulatorEventFold [[AnnotatedTx]]

-- | All transactions that happened during the simulation
blockchain :: EmulatorEventFold [Block]

-- | The list of all emulator events
emulatorLog :: EmulatorEventFold [EmulatorEvent]

-- | Log and error messages produced by the main (user) thread in the
--   emulator
userLog :: EmulatorEventFold [EmulatorTimeEvent UserThreadMsg]

-- | Pretty-print each element into a new line.
renderLines :: forall a. Pretty a => Fold a Text

-- | An effectful <a>mapMaybe</a> for <a>FoldM</a>.
preMapMaybeM :: Monad m => (a -> m (Maybe b)) -> FoldM m b r -> FoldM m a r

-- | <a>mapMaybe</a> for <a>Fold</a>.
preMapMaybe :: (a -> Maybe b) -> Fold b r -> Fold a r

-- | Effectfully map the result of a <a>FoldM</a>
postMapM :: Monad m => (b -> m c) -> FoldM m a b -> FoldM m a c
mkTxLogs :: EmulatorEventFold [MkTxLog]
instance (GHC.Show.Show a, GHC.Show.Show e) => GHC.Show.Show (Wallet.Emulator.Folds.Outcome e a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq e) => GHC.Classes.Eq (Wallet.Emulator.Folds.Outcome e a)
instance GHC.Show.Show Wallet.Emulator.Folds.EmulatorFoldErr
instance GHC.Classes.Ord Wallet.Emulator.Folds.EmulatorFoldErr
instance GHC.Classes.Eq Wallet.Emulator.Folds.EmulatorFoldErr

module Wallet.Rollup.Render
showBlockchain :: [(PaymentPubKeyHash, Wallet)] -> Blockchain -> Either Text Text
showBlockchainFold :: [(PaymentPubKeyHash, Wallet)] -> EmulatorEventFold (Either Text Text)
instance Wallet.Rollup.Render.Render PlutusCore.Data.Data
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Value.Value
instance Wallet.Rollup.Render.Render Data.Text.Internal.Text
instance Wallet.Rollup.Render.Render GHC.Base.String
instance Wallet.Rollup.Render.Render GHC.Integer.Type.Integer
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Address.Address
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Tx.TxId
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Scripts.ValidatorHash
instance Prettyprinter.Internal.Pretty a => Wallet.Rollup.Render.Render (Wallet.Rollup.Render.RenderPretty a)
instance (Wallet.Rollup.Render.Render a, Wallet.Rollup.Render.Render b) => Wallet.Rollup.Render.Render (Data.Either.Either a b)
instance Wallet.Rollup.Render.Render [[Wallet.Rollup.Types.AnnotatedTx]]
instance Wallet.Rollup.Render.Render Wallet.Rollup.Types.AnnotatedTx
instance Wallet.Rollup.Render.Render Wallet.Rollup.Types.SequenceId
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Value.CurrencySymbol
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Value.TokenName
instance Wallet.Rollup.Render.Render PlutusTx.Builtins.Internal.BuiltinByteString
instance Wallet.Rollup.Render.Render PlutusTx.Builtins.Internal.BuiltinData
instance (Wallet.Rollup.Render.Render k, Wallet.Rollup.Render.Render v) => Wallet.Rollup.Render.Render (PlutusTx.AssocMap.Map k v)
instance Wallet.Rollup.Render.Render (Data.Map.Internal.Map Wallet.Rollup.Types.BeneficialOwner Plutus.V1.Ledger.Value.Value)
instance Wallet.Rollup.Render.Render (Data.Map.Internal.Map Ledger.Crypto.PubKey Ledger.Crypto.Signature)
instance Wallet.Rollup.Render.Render Wallet.Emulator.Wallet.Wallet
instance Wallet.Rollup.Render.Render Wallet.Rollup.Types.BeneficialOwner
instance Wallet.Rollup.Render.Render Ledger.Ada.Ada
instance Wallet.Rollup.Render.Render (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Wallet.Rollup.Render.Render Ledger.Crypto.PubKey
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Crypto.PubKeyHash
instance Wallet.Rollup.Render.Render Ledger.Address.PaymentPubKey
instance Wallet.Rollup.Render.Render Ledger.Address.PaymentPubKeyHash
instance Wallet.Rollup.Render.Render Ledger.Crypto.Signature
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Scripts.Script
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Scripts.Validator
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Scripts.Datum
instance Wallet.Rollup.Render.Render a => Wallet.Rollup.Render.Render (Data.Set.Internal.Set a)
instance Wallet.Rollup.Render.Render Wallet.Rollup.Types.DereferencedInput
instance Wallet.Rollup.Render.Render Ledger.Tx.Internal.TxIn
instance Wallet.Rollup.Render.Render Ledger.Tx.Internal.TxInType
instance Wallet.Rollup.Render.Render a => Wallet.Rollup.Render.Render (Plutus.Script.Utils.Scripts.Versioned a)
instance Wallet.Rollup.Render.Render Cardano.Ledger.Alonzo.Language.Language
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Tx.TxOutRef
instance Wallet.Rollup.Render.Render Ledger.Tx.Internal.TxOut
instance Codec.Serialise.Class.Serialise (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Data.Aeson.Types.ToJSON.ToJSON (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Data.Aeson.Types.FromJSON.FromJSON (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)

module Plutus.Trace.Effects.EmulatorControl
data EmulatorControl r
[SetSigningProcess] :: Wallet -> Maybe SigningProcess -> EmulatorControl ()
[AgentState] :: Wallet -> EmulatorControl WalletState
[FreezeContractInstance] :: ContractInstanceId -> EmulatorControl ()
[ThawContractInstance] :: ContractInstanceId -> EmulatorControl ()
[ChainState] :: EmulatorControl ChainState
[GetParams] :: EmulatorControl Params
[GetSlotConfig] :: EmulatorControl SlotConfig
[DiscardWallets] :: (Wallet -> Bool) -> EmulatorControl ()
setSigningProcess :: forall effs_a6yr3. Member EmulatorControl effs_a6yr3 => Wallet -> Maybe SigningProcess -> Eff effs_a6yr3 ()
agentState :: forall effs_a6yr4. Member EmulatorControl effs_a6yr4 => Wallet -> Eff effs_a6yr4 WalletState
freezeContractInstance :: forall effs_a6yr5. Member EmulatorControl effs_a6yr5 => ContractInstanceId -> Eff effs_a6yr5 ()
thawContractInstance :: forall effs_a6yr6. Member EmulatorControl effs_a6yr6 => ContractInstanceId -> Eff effs_a6yr6 ()
chainState :: forall effs_a6yr7. Member EmulatorControl effs_a6yr7 => Eff effs_a6yr7 ChainState
getParams :: forall effs_a6yr8. Member EmulatorControl effs_a6yr8 => Eff effs_a6yr8 Params
discardWallets :: forall effs_a6yra. Member EmulatorControl effs_a6yra => (Wallet -> Bool) -> Eff effs_a6yra ()

-- | Interpret the <a>EmulatorControl</a> effect in the
--   <tt>MultiAgentEffect</tt> and scheduler system calls.
handleEmulatorControl :: forall effs effs2 a. (Member (State EmulatorThreads) effs, Member (State EmulatorState) effs, Member (Error EmulatorRuntimeError) effs, Member MultiAgentControlEffect effs, Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs) => Params -> EmulatorControl ~> Eff effs
getSlotConfig :: forall effs_a6yr9. Member EmulatorControl effs_a6yr9 => Eff effs_a6yr9 SlotConfig

module Plutus.Trace.Effects.RunContract

-- | Run a Plutus contract (client side)
data RunContract r
[CallEndpointP] :: forall l ep w s e. (ContractConstraints s, HasEndpoint l ep s, ToJSON ep) => Proxy l -> ContractHandle w s e -> ep -> RunContract ()
[GetContractState] :: forall w s e. (ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> RunContract (ContractInstanceState w s e ())

-- | Start a Plutus contract (client side)
data StartContract r
[ActivateContract] :: (IsContract contract, ContractConstraints s, Show e, FromJSON e, ToJSON e, ToJSON w, Monoid w, FromJSON w) => Wallet -> contract w s e a -> ContractInstanceTag -> StartContract (ContractHandle w s e)
type ContractConstraints s = (Forall (Output s) Unconstrained1, Forall (Input s) Unconstrained1, AllUniqueLabels (Input s), AllUniqueLabels (Output s), Forall (Input s) FromJSON, Forall (Input s) ToJSON, Forall (Output s) FromJSON, Forall (Output s) ToJSON)

-- | A user-defined tag for a contract instance. Used to find the
--   instance's log messages in the emulator log.
data ContractInstanceTag
activateContract :: forall (contract_X6z1o :: Type -> Row Type -> Type -> Type -> Type) (s_X6z1q :: Row Type) e_X6z1s w_X6z1u a_X6z1w. (IsContract contract_X6z1o, ContractConstraints s_X6z1q, Show e_X6z1s, FromJSON e_X6z1s, ToJSON e_X6z1s, ToJSON w_X6z1u, Monoid w_X6z1u, FromJSON w_X6z1u) => forall effs_a6z3A. Member StartContract effs_a6z3A => Wallet -> contract_X6z1o w_X6z1u s_X6z1q e_X6z1s a_X6z1w -> ContractInstanceTag -> Eff effs_a6z3A (ContractHandle w_X6z1u s_X6z1q e_X6z1s)

-- | Like <a>activateContract</a>, but using <a>walletInstanceTag</a> for
--   the tag.
activateContractWallet :: forall contract w s e effs. (IsContract contract, ContractConstraints s, Show e, ToJSON e, FromJSON e, ToJSON w, FromJSON w, Member StartContract effs, Monoid w) => Wallet -> contract w s e () -> Eff effs (ContractHandle w s e)

-- | Call an endpoint on a contract instance.
callEndpoint :: forall l ep w s e effs. (ToJSON ep, ContractConstraints s, HasEndpoint l ep s, Member RunContract effs) => ContractHandle w s e -> ep -> Eff effs ()
getContractState :: forall w_X6z3P (s_X6z3R :: Row Type) e_X6z3T. (ContractConstraints s_X6z3R, FromJSON e_X6z3T, FromJSON w_X6z3P, ToJSON w_X6z3P) => forall effs_a6z8H. Member RunContract effs_a6z8H => ContractHandle w_X6z3P s_X6z3R e_X6z3T -> Eff effs_a6z8H (ContractInstanceState w_X6z3P s_X6z3R e_X6z3T ())

-- | Get the active endpoints of a contract instance.
activeEndpoints :: forall w s e effs. (Member RunContract effs, ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> Eff effs [ActiveEndpoint]

-- | Get the observable state <tt>w</tt> of a contract instance.
observableState :: forall w s e effs. (Member RunContract effs, ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> Eff effs w

-- | The <a>ContractInstanceTag</a> for the contract instance of a wallet.
--   See note [Wallet contract instances]
walletInstanceTag :: Wallet -> ContractInstanceTag

-- | Handle the <a>RunContract</a> effect by running each contract instance
--   in an emulator thread.
handleRunContract :: forall effs effs2 a. (Member (State EmulatorThreads) effs2, Member (Error EmulatorRuntimeError) effs2, Member (Error EmulatorRuntimeError) effs, Member (LogMsg EmulatorEvent') effs, Member (State EmulatorThreads) effs, Member (Reader ThreadId) effs, Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs) => RunContract ~> Eff effs

-- | Handle the <a>StartContract</a> effect by starting each contract
--   instance in an emulator thread.
handleStartContract :: forall effs effs2 a. (Member (State EmulatorThreads) effs2, Member (Error EmulatorRuntimeError) effs2, Member MultiAgentEffect effs2, Member (LogMsg EmulatorEvent') effs2, Member ContractInstanceIdEff effs, Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs) => NetworkId -> StartContract ~> Eff effs

-- | Start a new thread for a contract instance (given by the handle). The
--   thread runs in the context of the wallet.
startContractThread :: forall w s e effs effs2 a. (Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs, Member (State EmulatorThreads) effs2, Member MultiAgentEffect effs2, Member (Error EmulatorRuntimeError) effs2, Member (LogMsg EmulatorEvent') effs2, ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w) => Wallet -> ContractHandle w s e -> Eff effs (Maybe EmulatorMessage)

module Plutus.Trace.Emulator
data Emulator
type EmulatorTrace = Eff EmulatorEffects
type EmulatorEffects = StartContract : BaseEmulatorEffects
type BaseEmulatorEffects = [RunContract, Assert, Waiting, EmulatorControl, EmulatedWalletAPI, LogMsg String, Error EmulatorRuntimeError]
data EmulatorErr
WalletErr :: WalletAPIError -> EmulatorErr
ChainIndexErr :: ChainIndexError -> EmulatorErr
AssertionErr :: AssertionError -> EmulatorErr
InstanceErr :: EmulatorRuntimeError -> EmulatorErr
ExitWasNeverCalled :: EmulatorErr

-- | A reference to a running contract in the emulator.
data ContractHandle w s e
ContractHandle :: Contract w s e () -> ContractInstanceId -> ContractInstanceTag -> NetworkId -> ContractHandle w s e
[chContract] :: ContractHandle w s e -> Contract w s e ()
[chInstanceId] :: ContractHandle w s e -> ContractInstanceId
[chInstanceTag] :: ContractHandle w s e -> ContractInstanceTag
[chNetworkId] :: ContractHandle w s e -> NetworkId

-- | A user-defined tag for a contract instance. Used to find the
--   instance's log messages in the emulator log.
data ContractInstanceTag
type ContractConstraints s = (Forall (Output s) Unconstrained1, Forall (Input s) Unconstrained1, AllUniqueLabels (Input s), AllUniqueLabels (Output s), Forall (Input s) FromJSON, Forall (Input s) ToJSON, Forall (Output s) FromJSON, Forall (Output s) ToJSON)
assert :: forall effs_a6eep. Member Assert effs_a6eep => String -> (EmulatorState -> Bool) -> Eff effs_a6eep ()
activateContract :: forall (contract_X6z1o :: Type -> Row Type -> Type -> Type -> Type) (s_X6z1q :: Row Type) e_X6z1s w_X6z1u a_X6z1w. (IsContract contract_X6z1o, ContractConstraints s_X6z1q, Show e_X6z1s, FromJSON e_X6z1s, ToJSON e_X6z1s, ToJSON w_X6z1u, Monoid w_X6z1u, FromJSON w_X6z1u) => forall effs_a6z3A. Member StartContract effs_a6z3A => Wallet -> contract_X6z1o w_X6z1u s_X6z1q e_X6z1s a_X6z1w -> ContractInstanceTag -> Eff effs_a6z3A (ContractHandle w_X6z1u s_X6z1q e_X6z1s)

-- | Like <a>activateContract</a>, but using <a>walletInstanceTag</a> for
--   the tag.
activateContractWallet :: forall contract w s e effs. (IsContract contract, ContractConstraints s, Show e, ToJSON e, FromJSON e, ToJSON w, FromJSON w, Member StartContract effs, Monoid w) => Wallet -> contract w s e () -> Eff effs (ContractHandle w s e)

-- | The <a>ContractInstanceTag</a> for the contract instance of a wallet.
--   See note [Wallet contract instances]
walletInstanceTag :: Wallet -> ContractInstanceTag

-- | Call an endpoint on a contract instance.
callEndpoint :: forall l ep w s e effs. (ToJSON ep, ContractConstraints s, HasEndpoint l ep s, Member RunContract effs) => ContractHandle w s e -> ep -> Eff effs ()
getContractState :: forall w_X6z3P (s_X6z3R :: Row Type) e_X6z3T. (ContractConstraints s_X6z3R, FromJSON e_X6z3T, FromJSON w_X6z3P, ToJSON w_X6z3P) => forall effs_a6z8H. Member RunContract effs_a6z8H => ContractHandle w_X6z3P s_X6z3R e_X6z3T -> Eff effs_a6z8H (ContractInstanceState w_X6z3P s_X6z3R e_X6z3T ())

-- | Get the observable state <tt>w</tt> of a contract instance.
observableState :: forall w s e effs. (Member RunContract effs, ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> Eff effs w

-- | Get the active endpoints of a contract instance.
activeEndpoints :: forall w s e effs. (Member RunContract effs, ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> Eff effs [ActiveEndpoint]
liftWallet :: forall a_a6caP. forall effs_a6cbo. Member EmulatedWalletAPI effs_a6cbo => Wallet -> Eff ('(:) WalletEffect ('(:) (Error WalletAPIError) ('(:) (LogMsg Text) ('(:) (LogMsg RequestHandlerLogMsg) ('[] :: [Type -> Type]))))) a_a6caP -> Eff effs_a6cbo a_a6caP

-- | Make a payment from one wallet to another
payToWallet :: forall effs. Member EmulatedWalletAPI effs => Wallet -> Wallet -> Value -> Eff effs TxId

-- | Wait until the beginning of the next slot, returning the new slot
--   number.
nextSlot :: Member Waiting effs => Eff effs Slot
waitUntilSlot :: forall effs_a6dOC. Member Waiting effs_a6dOC => Slot -> Eff effs_a6dOC Slot

-- | Wait until the slot where the given time falls into and return latest
--   time we know has passed.
waitUntilTime :: Member Waiting effs => POSIXTime -> Eff effs POSIXTime

-- | Wait for a number of slots
waitNSlots :: forall effs. Member Waiting effs => Natural -> Eff effs Slot

-- | Convert the given <tt>n</tt> milliseconds to a number of slots to
--   wait.
--   
--   Note: Currently, if n &lt; length of a slot, then
--   <a>waitNMilliSeconds</a> has no effect.
waitNMilliSeconds :: forall effs. Member Waiting effs => DiffMilliSeconds -> Eff effs Slot
freezeContractInstance :: forall effs_a6yr5. Member EmulatorControl effs_a6yr5 => ContractInstanceId -> Eff effs_a6yr5 ()
thawContractInstance :: forall effs_a6yr6. Member EmulatorControl effs_a6yr6 => ContractInstanceId -> Eff effs_a6yr6 ()
setSigningProcess :: forall effs_a6yr3. Member EmulatorControl effs_a6yr3 => Wallet -> Maybe SigningProcess -> Eff effs_a6yr3 ()
chainState :: forall effs_a6yr7. Member EmulatorControl effs_a6yr7 => Eff effs_a6yr7 ChainState
getSlotConfig :: forall effs_a6yr9. Member EmulatorControl effs_a6yr9 => Eff effs_a6yr9 SlotConfig
chainNewestFirst :: Lens' ChainState Blockchain
txPool :: Lens' ChainState TxPool
index :: Lens' ChainState UtxoIndex
chainCurrentSlot :: Lens' ChainState Slot
agentState :: forall effs_a6yr4. Member EmulatorControl effs_a6yr4 => Wallet -> Eff effs_a6yr4 WalletState
ownPaymentPrivateKey :: WalletState -> PaymentPrivateKey
nodeClient :: Lens' WalletState NodeClientState
signingProcess :: Lens' WalletState (Maybe SigningProcess)

-- | Throws an error carrying information of type <tt>e :: *</tt>.
throwError :: forall e (effs :: [Type -> Type]) a. Member (Error e) effs => e -> Eff effs a
data EmulatorRuntimeError
ThreadIdNotFound :: ContractInstanceId -> EmulatorRuntimeError
InstanceIdNotFound :: Wallet -> EmulatorRuntimeError
EmulatorJSONDecodingError :: String -> Value -> EmulatorRuntimeError
GenericError :: String -> EmulatorRuntimeError
EmulatedWalletError :: WalletAPIError -> EmulatorRuntimeError
AssertionError :: String -> EmulatorRuntimeError
data EmulatorConfig
EmulatorConfig :: InitialChainState -> Params -> EmulatorConfig

-- | State of the blockchain at the beginning of the simulation. Can be
--   given as a map of funds to wallets, or as a block of transactions.
[_initialChainState] :: EmulatorConfig -> InitialChainState

-- | Set the protocol parameters, network ID and slot configuration for the
--   emulator.
[_params] :: EmulatorConfig -> Params
initialChainState :: Lens' EmulatorConfig InitialChainState
params :: Lens' EmulatorConfig Params

-- | Run a 'Trace Emulator', streaming the log messages as they arrive
runEmulatorStream :: forall effs a. EmulatorConfig -> EmulatorTrace a -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) (Either EmulatorErr a, EmulatorState)

-- | Options for how to set up and print the trace.
data TraceConfig
TraceConfig :: (LogMessage EmulatorEvent -> Maybe String) -> Handle -> LogLevel -> TraceConfig

-- | Function to decide how to print the particular events.
[traceConfigShowEvent] :: TraceConfig -> LogMessage EmulatorEvent -> Maybe String

-- | Where to print the outputs to. Default: <a>stdout</a>
[traceConfigOutputHandle] :: TraceConfig -> Handle
[traceConfigMinLogLevel] :: TraceConfig -> LogLevel

-- | Some example of how to configure the <a>traceConfigShowEvent</a>.
traceConfigShowEventExample :: LogMessage EmulatorEvent -> Maybe String

-- | Run an emulator trace to completion, returning a tuple of the final
--   state of the emulator, the events, and any error, if any.
runEmulatorTrace :: TraceConfig -> EmulatorConfig -> EmulatorTrace a -> ([LogMessage EmulatorEvent], Either EmulatorErr a, EmulatorState)
evalEmulatorTrace :: TraceConfig -> EmulatorConfig -> EmulatorTrace a -> Either EmulatorErr a

-- | A very simple effect for interpreting the output printing done by the
--   trace printing functions:
--   
--   <ul>
--   <li><a>runEmulatorTraceEff</a></li>
--   <li><a>runEmulatorTraceIO</a></li>
--   <li><a>runEmulatorTraceIOWithConfig</a></li>
--   </ul>
data PrintEffect r
[PrintLn] :: String -> PrintEffect ()

-- | Run the emulator trace returning an effect that can be evaluated by
--   interpreting the <a>PrintEffect</a>s.
runEmulatorTraceEff :: forall effs. Member PrintEffect effs => TraceConfig -> EmulatorConfig -> EmulatorTrace () -> Eff effs ()

-- | Runs the trace with <a>runEmulatorTrace</a>, with default
--   configuration that prints a selection of events to stdout.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; runEmulatorTraceIO (void $ Trace.waitNSlots 1)
--   </pre>
runEmulatorTraceIO :: EmulatorTrace () -> IO ()

-- | <i>Deprecated: Renamed to runEmulatorTraceIOWithConfig</i>
runEmulatorTraceIO' :: TraceConfig -> EmulatorConfig -> EmulatorTrace () -> IO ()

-- | Interpret a 'Trace Emulator' action in the multi agent and emulated
--   blockchain effects.
interpretEmulatorTrace :: forall effs a. (Member MultiAgentEffect effs, Member MultiAgentControlEffect effs, Member (Error EmulatorRuntimeError) effs, Member ChainControlEffect effs, Member (LogMsg EmulatorEvent') effs, Member (State EmulatorState) effs) => EmulatorConfig -> EmulatorTrace a -> Eff effs (Maybe a)
instance Data.Default.Class.Default Plutus.Trace.Emulator.TraceConfig

module Plutus.Trace.Emulator.Extract
data ValidatorMode
FullyAppliedValidators :: ValidatorMode
UnappliedValidators :: ValidatorMode

-- | Run an emulator trace and write the applied scripts to a file in Flat
--   format using the name as a prefix.
writeScriptsTo :: ScriptsConfig -> String -> EmulatorTrace a -> EmulatorConfig -> IO (Sum Int64, ExBudget)
showStats :: Int64 -> ExBudget -> String

-- | Configuration for <a>writeScriptsTo</a>
data ScriptsConfig
ScriptsConfig :: FilePath -> Command -> ScriptsConfig

-- | Folder the extracted scripts should be written to
[scPath] :: ScriptsConfig -> FilePath

-- | Whether to write out complete transactions or just the validator
--   scripts
[scCommand] :: ScriptsConfig -> Command

-- | Command for <a>writeScriptsTo</a>
data Command

-- | Write out validator scripts only (flat encoding)
Scripts :: ValidatorMode -> Command

-- | Whether to write fully applied or unapplied validators
[unappliedValidators] :: Command -> ValidatorMode

-- | Write out partial transactions
Transactions :: NetworkId -> FilePath -> Command

-- | Network ID to use when creating addresses
[networkId] :: Command -> NetworkId

-- | Location of a JSON file with protocol parameters
[protocolParamsJSON] :: Command -> FilePath

-- | Write out the arguments and results of <tt>mkTx</tt> calls
MkTxLogs :: Command
instance GHC.Show.Show Plutus.Trace.Emulator.Extract.ValidatorMode
instance GHC.Classes.Ord Plutus.Trace.Emulator.Extract.ValidatorMode
instance GHC.Classes.Eq Plutus.Trace.Emulator.Extract.ValidatorMode
instance GHC.Classes.Eq Plutus.Trace.Emulator.Extract.Command
instance GHC.Show.Show Plutus.Trace.Emulator.Extract.Command

module Plutus.Trace
data SchedulerLog
data ThreadEvent


-- | Testing contracts with HUnit and Tasty
module Plutus.Contract.Test
newtype TracePredicateF a
TracePredicate :: (forall effs. Members TestEffects effs => FoldM (Eff effs) EmulatorEvent a) -> TracePredicateF a
type TracePredicate = TracePredicateF Bool
type ContractConstraints s = (Forall (Output s) Unconstrained1, Forall (Input s) Unconstrained1, AllUniqueLabels (Input s), AllUniqueLabels (Output s), Forall (Input s) FromJSON, Forall (Input s) ToJSON, Forall (Output s) FromJSON, Forall (Output s) ToJSON)
not :: TracePredicate -> TracePredicate
(.&&.) :: TracePredicate -> TracePredicate -> TracePredicate
infixl 3 .&&.
(.||.) :: TracePredicate -> TracePredicate -> TracePredicate
infixl 2 .||.
w1 :: Wallet
w2 :: Wallet
w3 :: Wallet
w4 :: Wallet
w5 :: Wallet
w6 :: Wallet
w7 :: Wallet
w8 :: Wallet
w9 :: Wallet
w10 :: Wallet
endpointAvailable :: forall (l :: Symbol) w s e a. (KnownSymbol l, Monoid w) => Contract w s e a -> ContractInstanceTag -> TracePredicate

-- | A <a>TracePredicate</a> checking that the wallet's contract instance
--   finished without errors.
assertDone :: forall contract w s e a. (Monoid w, IsContract contract) => contract w s e a -> ContractInstanceTag -> (a -> Bool) -> String -> TracePredicate

-- | A <a>TracePredicate</a> checking that the wallet's contract instance
--   is waiting for input.
assertNotDone :: forall contract w s e a. (Monoid w, IsContract contract) => contract w s e a -> ContractInstanceTag -> String -> TracePredicate

-- | A <a>TracePredicate</a> checking that the wallet's contract instance
--   failed with an error.
assertContractError :: forall contract w s e a. (Monoid w, IsContract contract) => contract w s e a -> ContractInstanceTag -> (e -> Bool) -> String -> TracePredicate
data Outcome e a

-- | The contract finished without errors and produced a result
Done :: a -> Outcome e a

-- | The contract is waiting for more input.
NotDone :: Outcome e a

-- | The contract failed with an error.
Failed :: e -> Outcome e a
assertOutcome :: forall contract w s e a. (Monoid w, IsContract contract) => contract w s e a -> ContractInstanceTag -> (Outcome e a -> Bool) -> String -> TracePredicate
assertInstanceLog :: ContractInstanceTag -> ([EmulatorTimeEvent ContractInstanceLog] -> Bool) -> TracePredicate

-- | Assert that no transaction failed to validate.
assertNoFailedTransactions :: TracePredicate

-- | Assert that n transactions validated, and no transaction failed to
--   validate.
assertValidatedTransactionCount :: Int -> TracePredicate

-- | Assert that n transactions validated, and the rest failed.
assertValidatedTransactionCountOfTotal :: Int -> Int -> TracePredicate

-- | Assert that at least one transaction failed to validate, and that all
--   transactions that failed meet the predicate.
assertFailedTransaction :: (Tx -> ValidationError -> Bool) -> TracePredicate

-- | Assert that at least one transaction failed to validate with an
--   EvaluationError containing the given text.
assertEvaluationError :: Text -> TracePredicate
assertHooks :: forall w s e a. Monoid w => Contract w s e a -> ContractInstanceTag -> ([PABReq] -> Bool) -> String -> TracePredicate

-- | Make an assertion about the responses provided to the contract
--   instance.
assertResponses :: forall w s e a. Monoid w => Contract w s e a -> ContractInstanceTag -> ([Response PABResp] -> Bool) -> String -> TracePredicate
assertUserLog :: ([EmulatorTimeEvent UserThreadMsg] -> Bool) -> TracePredicate

-- | An assertion about the blockchain
assertBlockchain :: ([Block] -> Bool) -> TracePredicate

-- | An assertion about the chain events
assertChainEvents :: ([ChainEvent] -> Bool) -> TracePredicate

-- | An assertion about the chain events with a custom error message
assertChainEvents' :: ([ChainEvent] -> String) -> ([ChainEvent] -> Bool) -> TracePredicate

-- | Make an assertion about the accumulated state <tt>w</tt> of a contract
--   instance.
assertAccumState :: forall contract w s e a. (Monoid w, Show w, IsContract contract) => contract w s e a -> ContractInstanceTag -> (w -> Bool) -> String -> TracePredicate
data Shrinking
DoShrink :: Shrinking
DontShrink :: Shrinking

-- | make an assertion about the <a>ContractInstanceState</a> of a contract
--   instance
assertResumableResult :: forall w s e a. (Monoid w, Show e, Show a, Show w) => Contract w s e a -> ContractInstanceTag -> Shrinking -> (ResumableResult w e PABResp PABReq a -> Bool) -> String -> TracePredicate
assertUnbalancedTx :: forall w s e a. Monoid w => Contract w s e a -> ContractInstanceTag -> (UnbalancedTx -> Bool) -> String -> TracePredicate
anyUnbalancedTx :: forall w s e a. Monoid w => Contract w s e a -> ContractInstanceTag -> TracePredicate
assertEvents :: forall w s e a. Monoid w => Contract w s e a -> ContractInstanceTag -> ([PABResp] -> Bool) -> String -> TracePredicate

-- | Check that the funds in the wallet have changed by the given amount,
--   exluding fees.
walletFundsChange :: Wallet -> Value -> TracePredicate

-- | Check that the funds in the wallet have changed by the given amount,
--   including fees.
walletFundsExactChange :: Wallet -> Value -> TracePredicate
walletFundsAssetClassChange :: Wallet -> AssetClass -> Integer -> TracePredicate
walletPaidFees :: Wallet -> Value -> TracePredicate
waitingForSlot :: forall w s e a. Monoid w => Contract w s e a -> ContractInstanceTag -> Slot -> TracePredicate

-- | Check that the funds at an address meet some condition.
valueAtAddress :: CardanoAddress -> (Value -> Bool) -> TracePredicate
dataAtAddress :: forall d. FromData d => CardanoAddress -> ([d] -> Bool) -> TracePredicate

-- | Assert that the size of a <tt>Validator</tt> is below the maximum.
reasonable :: Validator -> Integer -> Assertion
reasonable' :: (String -> IO ()) -> Validator -> Integer -> Assertion

-- | Check if the emulator trace meets the condition
checkPredicate :: String -> TracePredicate -> EmulatorTrace () -> TestTree
checkPredicateCoverage :: String -> CoverageRef -> TracePredicate -> EmulatorTrace () -> TestTree
checkPredicateCoverageOptions :: CheckOptions -> String -> CoverageRef -> TracePredicate -> EmulatorTrace () -> TestTree

-- | A version of <a>checkPredicate</a> with configurable
--   <a>CheckOptions</a>
checkPredicateOptions :: CheckOptions -> String -> TracePredicate -> EmulatorTrace () -> TestTree

-- | Check if the emulator trace meets the condition, using the
--   <a>GeneratorModel</a> to generate initial transactions for the
--   blockchain
checkPredicateGen :: GeneratorModel -> TracePredicate -> EmulatorTrace () -> Property

-- | A version of <a>checkPredicateGen</a> with configurable
--   <a>CheckOptions</a>.
--   
--   Note that the <tt>InitialChainState</tt> in the <a>EmulatorConfig</a>
--   of the <a>CheckOptions</a> will be replaced with the
--   <a>mockchainInitialTxPool</a> generated by the model.
checkPredicateGenOptions :: CheckOptions -> GeneratorModel -> TracePredicate -> EmulatorTrace () -> Property

-- | Evaluate a trace predicate on an emulator trace, printing out debug
--   information and making assertions as we go.
checkPredicateInner :: forall m a. Monad m => CheckOptions -> TracePredicate -> EmulatorTrace a -> (String -> m ()) -> (Bool -> m ()) -> (CoverageData -> m ()) -> m (Either EmulatorErr a)
checkPredicateInnerStream :: forall m a. Monad m => CheckOptions -> TracePredicate -> (forall effs. Stream (Of (LogMessage EmulatorEvent)) (Eff effs) (Either EmulatorErr a)) -> (String -> m ()) -> (Bool -> m ()) -> (CoverageData -> m ()) -> m (Either EmulatorErr a)

-- | Check if the emulator trace fails with the condition
checkEmulatorFails :: String -> CheckOptions -> TracePredicate -> EmulatorTrace () -> TestTree

-- | Options for running the
data CheckOptions
CheckOptions :: LogLevel -> EmulatorConfig -> CheckOptions

-- | Minimum log level for emulator log messages to be included in the test
--   output (printed if the test fails)
[_minLogLevel] :: CheckOptions -> LogLevel
[_emulatorConfig] :: CheckOptions -> EmulatorConfig
defaultCheckOptions :: CheckOptions
minLogLevel :: Lens' CheckOptions LogLevel
emulatorConfig :: Lens' CheckOptions EmulatorConfig

-- | Modify the value assigned to the given wallet in the initial
--   distribution.
changeInitialWalletValue :: Wallet -> (Value -> Value) -> CheckOptions -> CheckOptions

-- | Set higher limits on transaction size and execution units. This can be
--   used to work around <tt>MaxTxSizeUTxO</tt> and
--   <tt>ExUnitsTooBigUTxO</tt> errors. Note that if you need this your
--   Plutus script will probably not validate on Mainnet.
increaseTransactionLimits :: CheckOptions -> CheckOptions

-- | Compare a golden PIR file to the provided <a>CompiledCode</a>.
goldenPir :: FilePath -> CompiledCode a -> TestTree
instance GHC.Show.Show Plutus.Contract.Test.Shrinking
instance GHC.Classes.Ord Plutus.Contract.Test.Shrinking
instance GHC.Classes.Eq Plutus.Contract.Test.Shrinking
instance GHC.Base.Functor Plutus.Contract.Test.TracePredicateF
instance GHC.Base.Applicative Plutus.Contract.Test.TracePredicateF


-- | A version of <a>RunContract</a> for use in the playground.
module Plutus.Trace.Effects.RunContractPlayground
data RunContractPlayground r
callEndpoint :: forall effs_a6Rqt. Member RunContractPlayground effs_a6Rqt => Wallet -> String -> Value -> Eff effs_a6Rqt ()
launchContract :: forall effs_a6Rqs. Member RunContractPlayground effs_a6Rqs => Wallet -> Eff effs_a6Rqs ()

-- | Handle the <a>RunContractPlayground</a> effect.
handleRunContractPlayground :: forall w s e effs effs2 a. (ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w, Member ContractInstanceIdEff effs, Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs, Member (LogMsg EmulatorEvent') effs2, Member (Error EmulatorRuntimeError) effs2, Member (State EmulatorThreads) effs2, Member MultiAgentEffect effs2, Member (State (Map Wallet ContractInstanceId)) effs2, Member (State (Map Wallet ContractInstanceId)) effs) => NetworkId -> Contract w s e () -> RunContractPlayground ~> Eff effs

module Plutus.Trace.Playground
type PlaygroundTrace a = Eff '[RunContractPlayground, Error EmulatorRuntimeError, Waiting, EmulatedWalletAPI] a
waitUntilSlot :: forall effs_a6dOC. Member Waiting effs_a6dOC => Slot -> Eff effs_a6dOC Slot

-- | Wait for a number of slots
waitNSlots :: forall effs. Member Waiting effs => Natural -> Eff effs Slot

-- | Wait until the beginning of the next slot, returning the new slot
--   number.
nextSlot :: Member Waiting effs => Eff effs Slot

-- | Make a payment from one wallet to another
payToWallet :: forall effs. Member EmulatedWalletAPI effs => Wallet -> Wallet -> Value -> Eff effs TxId
callEndpoint :: forall effs_a6Rqt. Member RunContractPlayground effs_a6Rqt => Wallet -> String -> Value -> Eff effs_a6Rqt ()
data EmulatorConfig
EmulatorConfig :: InitialChainState -> Params -> EmulatorConfig

-- | State of the blockchain at the beginning of the simulation. Can be
--   given as a map of funds to wallets, or as a block of transactions.
[_initialChainState] :: EmulatorConfig -> InitialChainState

-- | Set the protocol parameters, network ID and slot configuration for the
--   emulator.
[_params] :: EmulatorConfig -> Params
initialChainState :: Lens' EmulatorConfig InitialChainState

-- | Run a 'Trace Playground', streaming the log messages as they arrive
runPlaygroundStream :: forall w s e effs a. (ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w) => EmulatorConfig -> Contract w s e () -> PlaygroundTrace a -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) (Either EmulatorErr a, EmulatorState)
interpretPlaygroundTrace :: forall w s e effs a. (Member MultiAgentEffect effs, Member MultiAgentControlEffect effs, Member (Error EmulatorRuntimeError) effs, Member ChainControlEffect effs, Member (LogMsg EmulatorEvent') effs, ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w) => EmulatorConfig -> Contract w s e () -> [Wallet] -> PlaygroundTrace a -> Eff effs (Maybe a)

-- | The <a>ContractInstanceTag</a> for the contract instance of a wallet.
--   See note [Wallet contract instances]
walletInstanceTag :: Wallet -> ContractInstanceTag

module Plutus.Contract.Test.ContractModel.Internal.ContractInstance

-- | Key-value map where keys and values have three indices that can vary
--   between different elements of the map. Used to store
--   <a>ContractHandle</a>s, which are indexed over observable state,
--   schema, and error type.
data IMap (key :: i -> j -> k -> l -> *) (val :: i -> j -> k -> *)
[IMNil] :: IMap key val
[IMCons] :: (Typeable i, Typeable j, Typeable k, Typeable l) => key i j k l -> val i j k -> IMap key val -> IMap key val
imAppend :: IMap key val -> IMap key val -> IMap key val

-- | Look up a value in an indexed map. First checks that the indices
--   agree, using <a>cast</a>. Once the type checker is convinced that the
--   indices match we can check the key for equality.
imLookup :: (Typeable i, Typeable j, Typeable k, Typeable l, Typeable key, Typeable val, Eq (key i j k l)) => key i j k l -> IMap key val -> Maybe (val i j k)
imMap :: (forall i j k l. key i j k l -> key' i j k l) -> (forall i j k. val i j k -> val' i j k) -> IMap key val -> IMap key' val'

-- | The constraints required on contract schemas and error types to enable
--   calling contract endpoints (<a>callEndpoint</a>).
type SchemaConstraints w schema err = (Typeable w, Monoid w, ToJSON w, Typeable schema, ContractConstraints schema, Show err, Typeable err, ToJSON err, FromJSON err, ToJSON w, FromJSON w)
data WalletContractHandle w s e
WalletContractHandle :: Wallet -> ContractHandle w s e -> WalletContractHandle w s e
type Handles state = IMap (ContractInstanceKey state) WalletContractHandle
handlesAppend :: Handles state -> Handles state -> Handles state
data StartContract state
[StartContract] :: (SchemaConstraints w s e, Typeable p) => ContractInstanceKey state w s e p -> p -> StartContract state
class (ContractModel state, (forall w s e p. Eq (ContractInstanceKey state w s e p)), (forall w s e p. Show (ContractInstanceKey state w s e p))) => ContractInstanceModel state where {
    
    -- | To be able to call a contract endpoint from a wallet a
    --   <a>ContractHandle</a> is required. These are managed by the test
    --   framework and all the user needs to do is provide this contract
    --   instance key type representing the different contract instances that a
    --   test needs to work with, and when creating a property (see
    --   <tt>propRunActions_</tt>) provide a list of contract instance keys
    --   together with their wallets and contracts. Contract instance keys are
    --   indexed by the observable state, schema, and error type of the
    --   contract and should be defined as a GADT. For example, a handle type
    --   for a contract with one seller and multiple buyers could look like
    --   this.
    --   
    --   <pre>
    --   data ContractInstanceKey MyModel w s e where
    --       Buyer  :: Wallet -&gt; ContractInstanceKey MyModel MyObsState MySchema MyError MyParams
    --       Seller :: ContractInstanceKey MyModel MyObsState MySchema MyError MyParams
    --   </pre>
    data family ContractInstanceKey state :: * -> Row * -> * -> * -> *;
}

-- | Get the wallet that the contract running at a specific
--   <a>ContractInstanceKey</a> should run in
instanceWallet :: ContractInstanceModel state => ContractInstanceKey state w s e p -> Wallet

-- | The <a>ContractInstanceTag</a> of an instance key for a wallet.
--   Defaults to <a>walletInstanceTag</a>. You must override this if you
--   have multiple instances per wallet.
instanceTag :: forall w s e p. (ContractInstanceModel state, SchemaConstraints w s e) => ContractInstanceKey state w s e p -> ContractInstanceTag

-- | The initial handles
initialInstances :: ContractInstanceModel state => [StartContract state]

-- | Start new contract instances
startInstances :: ContractInstanceModel state => ModelState state -> Action state -> [StartContract state]

-- | Map a <a>ContractInstanceKey</a> <tt>k</tt> to the <a>Contract</a>
--   that is started when we start <tt>k</tt> in a given <a>ModelState</a>
--   with a given semantics of <a>SymToken</a>s
instanceContract :: ContractInstanceModel state => (SymToken -> AssetId) -> ContractInstanceKey state w s e p -> p -> Contract w s e ()


-- | This module provides a framework for testing Plutus contracts built on
--   <a>Test.QuickCheck</a>. The testing is model based, so to test a
--   contract you define a type modelling the state of the contract (or set
--   of contracts) and provide an instance of the <a>ContractModel</a>
--   class. This instance specifies what operations (<a>Action</a>s) the
--   contract supports, how they interact with the model state, and how to
--   execute them in the blockchain emulator
--   (<a>Plutus.Trace.Emulator</a>). Tests are evaluated by running
--   sequences of actions (random or user-specified) in the emulator and
--   comparing the state of the blockchain to the model state at the end.
--   
--   Test cases are written in the <a>DL</a> monad, which supports mixing
--   fixed sequences of actions with random actions, making it easy to
--   write properties like <i>it is always possible to get all funds out of
--   the contract</i>.
module Plutus.Contract.Test.ContractModel.Internal
pattern UnderlyingAction :: () => Action s -> Action (WithInstances s)
pattern Unilateral :: () => Wallet -> Action (WithInstances s)

-- | Options for controlling coverage checking requirements
--   
--   <ul>
--   <li><a>checkCoverage</a> tells you whether or not to run the coverage
--   checks at all.</li>
--   <li>`endpointCoverageEq instance endpointName` tells us what
--   percentage of tests are required to include a call to the endpoint
--   <tt>endpointName</tt> in the contract at `instance`.</li>
--   <li><tt>coverIndex</tt> is the coverage index obtained from the
--   <tt>CompiledCodeIn</tt> of the validator.</li>
--   </ul>
data CoverageOptions
CoverageOptions :: Bool -> (ContractInstanceTag -> String -> Double) -> CoverageIndex -> Maybe (IORef CoverageData) -> CoverageOptions
[_checkCoverage] :: CoverageOptions -> Bool
[_endpointCoverageReq] :: CoverageOptions -> ContractInstanceTag -> String -> Double
[_coverageIndex] :: CoverageOptions -> CoverageIndex
[_coverageIORef] :: CoverageOptions -> Maybe (IORef CoverageData)
newtype WithInstances s
WithInstances :: s -> WithInstances s
[withoutInstances] :: WithInstances s -> s
type CheckableContractModel state = (RunModel state (SpecificationEmulatorTrace state), ContractInstanceModel state)
type EmulatorTraceWithInstances s = Eff (State (Handles s) : EmulatorEffects)
type SpecificationEmulatorTrace s = Eff (Reader (Handles s) : BaseEmulatorEffects)
contractHandle :: (ContractInstanceModel state, Typeable w, Typeable schema, Typeable err, Typeable params) => ContractInstanceKey state w schema err params -> RunMonad (SpecificationEmulatorTrace state) (ContractHandle w schema err)
activateWallets :: ContractInstanceModel state => (SymToken -> AssetId) -> [StartContract state] -> EmulatorTraceWithInstances state ()

-- | Used to freeze other wallets when checking a
--   <a>NoLockedFundsProof</a>.
instancesForOtherWallets :: Wallet -> Handles state -> [ContractInstanceId]
liftSpecificationTrace :: SpecificationEmulatorTrace s a -> EmulatorTraceWithInstances s a
makeTheHash :: HashAlgorithm crypto => BuiltinByteString -> Hash crypto stuff

-- | `delay n` delays emulator execution by <tt>n</tt> slots
delay :: Integer -> RunMonad (SpecificationEmulatorTrace state) ()

-- | A whitelist entry tells you what final log entry prefixes are
--   acceptable for a given error
data Whitelist
Whitelist :: Set Text -> Whitelist
[errorPrefixes] :: Whitelist -> Set Text
data NoLockedFundsProofLight model
NoLockedFundsProofLight :: DL (WithInstances model) () -> NoLockedFundsProofLight model
[nlfplMainStrategy] :: NoLockedFundsProofLight model -> DL (WithInstances model) ()

-- | A "proof" that you can always recover the funds locked by a contract.
--   The first component is a strategy that from any state of the contract
--   can get all the funds out. The second component is a strategy for each
--   wallet that from the same state, shows how that wallet can recover the
--   same (or bigger) amount as using the first strategy, without relying
--   on any actions being taken by the other wallets.
--   
--   For instance, in a two player game where each player bets some amount
--   of funds and the winner gets the pot, there needs to be a mechanism
--   for the players to recover their bid if the other player simply walks
--   away (perhaps after realising the game is lost). If not, it won't be
--   possible to construct a <a>NoLockedFundsProof</a> that works in a
--   state where both players need to move before any funds can be
--   collected.
data NoLockedFundsProof model
NoLockedFundsProof :: DL (WithInstances model) () -> (Wallet -> DL (WithInstances model) ()) -> (ModelState (WithInstances model) -> SymValue) -> (ModelState (WithInstances model) -> SymValue) -> NoLockedFundsProof model

-- | Strategy to recover all funds from the contract in any reachable
--   state.
[nlfpMainStrategy] :: NoLockedFundsProof model -> DL (WithInstances model) ()

-- | A strategy for each wallet to recover as much (or more) funds as the
--   main strategy would give them in a given state, without the assistance
--   of any other wallet.
[nlfpWalletStrategy] :: NoLockedFundsProof model -> Wallet -> DL (WithInstances model) ()

-- | An initial amount of overhead value that may be lost - e.g. setup fees
--   for scripts that can't be recovered.
[nlfpOverhead] :: NoLockedFundsProof model -> ModelState (WithInstances model) -> SymValue

-- | The total amount of margin for error in the value collected by the
--   WalletStrategy compared to the MainStrategy. This is useful if your
--   contract contains rounding code that makes the order of operations
--   have a small but predictable effect on the value collected by
--   different wallets.
[nlfpErrorMargin] :: NoLockedFundsProof model -> ModelState (WithInstances model) -> SymValue
checkCoverage :: Lens' CoverageOptions Bool
coverageIORef :: Lens' CoverageOptions (Maybe (IORef CoverageData))
coverageIndex :: Lens' CoverageOptions CoverageIndex
endpointCoverageReq :: Lens' CoverageOptions (ContractInstanceTag -> String -> Double)

-- | Default coverage checking options are: * not to check coverage * set
--   the requriements for every endpoint to 20% and * not to cover any
--   source locations in the validator scripts.
defaultCoverageOptions :: CoverageOptions

-- | Default check options that include a large amount of Ada in the
--   initial distributions to avoid having to write <a>ContractModel</a>s
--   that keep track of balances.
defaultCheckOptionsContractModel :: CheckOptions

-- | Run QuickCheck on a property that tracks coverage and print its
--   coverage report.
quickCheckWithCoverage :: Testable prop => Args -> CoverageOptions -> (CoverageOptions -> prop) -> IO CoverageReport
quickCheckWithCoverageAndResult :: Testable prop => Args -> CoverageOptions -> (CoverageOptions -> prop) -> IO (CoverageReport, Result)

-- | Run a <a>Actions</a> in the emulator and check that the model and the
--   emulator agree on the final wallet balance changes. Equivalent to
--   
--   <pre>
--   propRunActions_ hs actions = <a>propRunActions</a> hs (<a>const</a> <a>$</a> <a>pure</a> <a>True</a>) actions
--   </pre>
propRunActions_ :: CheckableContractModel state => Actions (WithInstances state) -> Property

-- | Run a <a>Actions</a> in the emulator and check that the model and the
--   emulator agree on the final wallet balance changes, and that the given
--   <a>TracePredicate</a> holds at the end. Equivalent to:
--   
--   <pre>
--   propRunActions = <a>propRunActionsWithOptions</a> <a>defaultCheckOptionsContractModel</a> <a>defaultCoverageOptions</a>
--   </pre>
propRunActions :: CheckableContractModel state => (ModelState (WithInstances state) -> TracePredicate) -> Actions (WithInstances state) -> Property
propRunActionsWithOptions :: forall state. CheckableContractModel state => CheckOptions -> CoverageOptions -> (ModelState (WithInstances state) -> TracePredicate) -> Actions (WithInstances state) -> Property

-- | The default skeleton of a NoLockedFundsProof - doesn't permit any
--   overhead or error margin.
defaultNLFP :: NoLockedFundsProof model

-- | Check a <a>NoLockedFundsProof</a>. Each test will generate an
--   arbitrary sequence of actions (<a>anyActions_</a>) and ask the
--   <a>nlfpMainStrategy</a> to recover all funds locked by the contract
--   after performing those actions. This results in some distribution of
--   the contract funds to the wallets, and the test then asks each
--   <a>nlfpWalletStrategy</a> to show how to recover their allotment of
--   funds without any assistance from the other wallets (assuming the main
--   strategy did not execute). When executing wallet strategies, the
--   off-chain instances for other wallets are killed and their private
--   keys are deleted from the emulator state.
checkNoLockedFundsProof :: CheckableContractModel model => NoLockedFundsProof model -> Property
checkNoLockedFundsProofFast :: CheckableContractModel model => NoLockedFundsProof model -> Property
checkNoLockedFundsProofWithOptions :: CheckableContractModel model => CheckOptions -> NoLockedFundsProof model -> Property
checkNoLockedFundsProofFastWithOptions :: CheckableContractModel model => CheckOptions -> NoLockedFundsProof model -> Property
checkNoLockedFundsProof' :: CheckableContractModel model => (Actions (WithInstances model) -> Property) -> NoLockedFundsProof model -> Property
actionsFromList :: [Action s] -> Actions s
varNumOf :: Act s -> Int
walletAddress :: Wallet -> AddressInEra Era
addressToWallet :: AddressInEra Era -> Maybe Wallet
checkNoLockedFundsProofLight :: CheckableContractModel model => NoLockedFundsProofLight model -> Property

-- | Check that the last entry in a log is accepted by a whitelist entry
isAcceptedBy :: Maybe Text -> Whitelist -> Bool

-- | Check that a whitelist does not accept any partial functions
whitelistOk :: Whitelist -> Bool
mkWhitelist :: [Text] -> Whitelist
defaultWhitelist :: Whitelist

-- | Check that running a contract model does not result in validation
--   failures that are not accepted by the whitelist.
checkErrorWhitelist :: CheckableContractModel m => Whitelist -> Actions (WithInstances m) -> Property

-- | Check that running a contract model does not result in validation
--   failures that are not accepted by the whitelist.
checkErrorWhitelistWithOptions :: forall m. CheckableContractModel m => CheckOptions -> CoverageOptions -> Whitelist -> Actions (WithInstances m) -> Property
instance GHC.Base.Semigroup Plutus.Contract.Test.ContractModel.Internal.Whitelist
instance GHC.Base.Monoid Plutus.Contract.Test.ContractModel.Internal.Whitelist
instance GHC.Show.Show s => GHC.Show.Show (Plutus.Contract.Test.ContractModel.Internal.WithInstances s)
instance GHC.Generics.Generic (Plutus.Contract.Test.ContractModel.Internal.WithInstances s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Internal.WithInstances s)
instance GHC.Classes.Eq (Test.QuickCheck.ContractModel.Internal.Model.Action s) => GHC.Classes.Eq (Test.QuickCheck.ContractModel.Internal.Model.Action (Plutus.Contract.Test.ContractModel.Internal.WithInstances s))
instance Plutus.Contract.Test.ContractModel.Internal.CheckableContractModel state => Test.QuickCheck.ContractModel.Internal.RunModel (Plutus.Contract.Test.ContractModel.Internal.WithInstances state) (Plutus.Contract.Test.ContractModel.Internal.EmulatorTraceWithInstances state)
instance GHC.Show.Show (Test.QuickCheck.ContractModel.Internal.Model.Action s) => GHC.Show.Show (Test.QuickCheck.ContractModel.Internal.Model.Action (Plutus.Contract.Test.ContractModel.Internal.WithInstances s))
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymTokens (Test.QuickCheck.ContractModel.Internal.Model.Action s) => Test.QuickCheck.ContractModel.Internal.Model.HasSymTokens (Test.QuickCheck.ContractModel.Internal.Model.Action (Plutus.Contract.Test.ContractModel.Internal.WithInstances s))
instance Test.QuickCheck.ContractModel.Internal.Model.ContractModel s => Test.QuickCheck.ContractModel.Internal.Model.ContractModel (Plutus.Contract.Test.ContractModel.Internal.WithInstances s)
instance Test.QuickCheck.ContractModel.Internal.ChainIndex.HasChainIndex (Plutus.Contract.Test.ContractModel.Internal.EmulatorTraceWithInstances state)
instance Data.OpenUnion.Internal.Member Plutus.Trace.Effects.Waiting.Waiting effs => Test.QuickCheck.ContractModel.Internal.IsRunnable (Control.Monad.Freer.Internal.Eff effs)

module Plutus.Contract.Test.ContractModel.Interface

-- | A <a>ContractModel</a> instance captures everything that is needed to
--   generate and run tests of a contract or set of contracts. It specifies
--   among other things
--   
--   <ul>
--   <li>what operations are supported by the contract
--   (<a>Action</a>),</li>
--   <li>when they are valid (<a>precondition</a>),</li>
--   <li>how to generate random actions (<a>arbitraryAction</a>),</li>
--   <li>how the operations affect the state (<a>nextState</a>), and</li>
--   <li>how to run the operations in the emulator (<a>perform</a>)</li>
--   </ul>
class (Typeable state, Show state, Show (Action state), Eq (Action state), HasSymTokens (Action state), (forall w s e p. Eq (ContractInstanceKey state w s e p)), (forall w s e p. Show (ContractInstanceKey state w s e p))) => ContractModel state where {
    
    -- | The type of actions that are supported by the contract. An action
    --   usually represents a single <a>callEndpoint</a> or a transfer of
    --   tokens, but it can be anything that can be interpreted in the
    --   <tt>EmulatorTrace</tt> monad.
    data family Action state;
    
    -- | To be able to call a contract endpoint from a wallet a
    --   <a>ContractHandle</a> is required. These are managed by the test
    --   framework and all the user needs to do is provide this contract
    --   instance key type representing the different contract instances that a
    --   test needs to work with, and when creating a property (see
    --   <a>propRunActions_</a>) provide a list of contract instance keys
    --   together with their wallets and contracts (a
    --   <tt>ContractInstanceSpec</tt>). Contract instance keys are indexed by
    --   the observable state, schema, and error type of the contract and
    --   should be defined as a GADT. For example, a handle type for a contract
    --   with one seller and multiple buyers could look like this.
    --   
    --   <pre>
    --   data ContractInstanceKey MyModel w s e where
    --       Buyer  :: Wallet -&gt; ContractInstanceKey MyModel MyObsState MySchema MyError MyParams
    --       Seller :: ContractInstanceKey MyModel MyObsState MySchema MyError MyParams
    --   </pre>
    data family ContractInstanceKey state :: * -> Row * -> * -> * -> *;
}

-- | Get the wallet that the contract running at a specific
--   <a>ContractInstanceKey</a> should run in
instanceWallet :: ContractModel state => ContractInstanceKey state w s e p -> Wallet

-- | The <a>ContractInstanceTag</a> of an instance key for a wallet.
--   Defaults to <a>walletInstanceTag</a>. You must override this if you
--   have multiple instances per wallet.
instanceTag :: forall w s e p. (ContractModel state, SchemaConstraints w s e) => ContractInstanceKey state w s e p -> ContractInstanceTag

-- | Given the current model state, provide a QuickCheck generator for a
--   random next action. This is used in the <a>Arbitrary</a> instance for
--   <a>Actions</a>s as well as by <tt>anyAction</tt> and
--   <tt>anyActions</tt>.
arbitraryAction :: ContractModel state => ModelState state -> Gen (Action state)

-- | The name of an Action, used to report statistics.
actionName :: ContractModel state => Action state -> String

-- | The probability that we will generate a <tt>WaitUntil</tt> in a given
--   state
waitProbability :: ContractModel state => ModelState state -> Double

-- | Control the distribution of how long <tt>WaitUntil</tt> waits
arbitraryWaitInterval :: ContractModel state => ModelState state -> Gen Slot

-- | The initial state, before any actions have been performed.
initialState :: ContractModel state => state

-- | The initial handles
initialInstances :: ContractModel state => [StartContract state]

-- | The <a>precondition</a> function decides if a given action is valid in
--   a given state. Typically actions generated by <a>arbitraryAction</a>
--   will satisfy the precondition, but if they don't they will be
--   discarded and another action will be generated. More importantly, the
--   preconditions are used when shrinking (see <a>shrinkAction</a>) to
--   ensure that shrunk test cases still make sense.
--   
--   If an explicit <a>action</a> in a <a>DL</a> scenario violates the
--   precondition an error is raised.
precondition :: ContractModel state => ModelState state -> Action state -> Bool

-- | <a>nextReactiveState</a> is run every time the model <a>wait</a>s for
--   a slot to be reached. This can be used to model reactive components of
--   off-chain code.
nextReactiveState :: ContractModel state => Slot -> Spec state ()

-- | This is where the model logic is defined. Given an action,
--   <a>nextState</a> specifies the effects running that action has on the
--   model state. It runs in the <a>Spec</a> monad, which is a state monad
--   over the <a>ModelState</a>.
nextState :: ContractModel state => Action state -> Spec state ()

-- | Start new contract instances
startInstances :: ContractModel state => ModelState state -> Action state -> [StartContract state]

-- | Map a <a>ContractInstanceKey</a> <tt>k</tt> to the <a>Contract</a>
--   that is started when we start <tt>k</tt> in a given <a>ModelState</a>
--   with a given semantics of <tt>SymToken</tt>s
instanceContract :: ContractModel state => (SymToken -> AssetClass) -> ContractInstanceKey state w s e p -> p -> Contract w s e ()

-- | While <a>nextState</a> models the behaviour of the actions,
--   <a>perform</a> contains the code for running the actions in the
--   emulator (see <a>Plutus.Trace.Emulator</a>). It gets access to the
--   wallet contract handles, the current model state, and the action to be
--   performed.
perform :: ContractModel state => HandleFun state -> (SymToken -> AssetClass) -> ModelState state -> Action state -> SpecificationEmulatorTrace ()

-- | When a test involving random sequences of actions fails, the framework
--   tries to find a minimal failing test case by shrinking the original
--   failure. Action sequences are shrunk by removing individual actions,
--   or by replacing an action by one of the (simpler) actions returned by
--   <a>shrinkAction</a>.
--   
--   See <a>shrink</a> for more information on shrinking.
shrinkAction :: ContractModel state => ModelState state -> Action state -> [Action state]

-- | The <a>monitoring</a> function allows you to collect statistics of
--   your testing using QuickCheck functions like <a>label</a>,
--   <a>collect</a>, <a>classify</a>, and <a>tabulate</a>. This function is
--   called by <a>propRunActions</a> (and friends) for any actions in the
--   given <a>Actions</a>.
--   
--   Statistics on which actions are executed are always collected.
monitoring :: ContractModel state => (ModelState state, ModelState state) -> Action state -> Property -> Property

-- | In some scenarios it's useful to have actions that are never generated
--   randomly, but only used explicitly in <a>DL</a> scenario
--   <a>action</a>s. To avoid these actions matching an <tt>anyAction</tt>
--   when shrinking, they can be marked <a>restricted</a>.
restricted :: ContractModel state => Action state -> Bool
type Actions state = Actions (WithInstances (WrappedState state))
data SomeContractInstanceKey state
[Key] :: (SchemaConstraints w s e, Typeable p) => ContractInstanceKey state w s e p -> SomeContractInstanceKey state
class HasSymTokens a
getAllSymTokens :: HasSymTokens a => a -> Set SymToken

-- | The <a>ModelState</a> models the state of the blockchain. It contains,
--   
--   <ul>
--   <li>the contract-specific state (<a>contractState</a>)</li>
--   <li>the current slot (<a>currentSlot</a>)</li>
--   <li>the wallet balances (<tt>balances</tt>)</li>
--   <li>the amount that has been minted (<a>minted</a>)</li>
--   </ul>
data ModelState state

-- | Lens for the contract-specific part of the model state.
contractState :: Lens (ModelState state1) (ModelState state2) state1 state2
currentSlot :: Getter (ModelState state) Slot

-- | Get the current wallet balance changes. These are delta balances, so
--   they start out at zero and can be negative. The absolute balances used
--   by the emulator can be set in the <tt>CheckOptions</tt> argument to
--   <tt>propRunActionsWithOptions</tt>.
--   
--   <a>Spec</a> monad update functions: <a>withdraw</a>, <a>deposit</a>,
--   <a>transfer</a>.
balanceChanges :: Getter (ModelState state) (Map (AddressInEra Era) SymValue)
balanceChange :: Wallet -> Getter (ModelState state) SymValue

-- | Get the amount of tokens minted so far. This is used to compute
--   <a>lockedValue</a>.
--   
--   <a>Spec</a> monad update functions: <a>mint</a> and <a>burn</a>.
minted :: Getter (ModelState state) SymValue

-- | How much value is currently locked by contracts. This computed by
--   subtracting the wallet <tt>balances</tt> from the <a>minted</a> value.
lockedValue :: ModelState s -> SymValue

-- | Check if a symbolic value is zero
symIsZero :: SymValue -> Bool

-- | Monads with read access to the model state: the <a>Spec</a> monad used
--   in <a>nextState</a>, and the <tt>DL</tt> monad used to construct test
--   scenarios.
class Monad m => GetModelState (m :: Type -> Type)

-- | Get a component of the model state using a lens.
viewModelState :: GetModelState m => Getting a (ModelState (StateType m)) a -> m a

-- | Get a component of the contract state using a lens.
viewContractState :: (Coercible (StateType m) state, GetModelState m) => Getting a state a -> m a

-- | A symbolic token is a token that exists only during ContractModel
--   generation time
data SymToken
class SymValueLike v
toSymValue :: SymValueLike v => v -> SymValue
class TokenLike t

-- | Get the value of a specific token in a <a>SymValue</a>
symAssetIdValueOf :: TokenLike t => SymValue -> t -> Quantity

-- | Convert a token and an amount to a <a>SymValue</a>
symAssetIdValue :: TokenLike t => t -> Quantity -> SymValue
invSymValue :: SymValue -> SymValue

-- | Using a semantics function for symbolic tokens, convert a SymValue to
--   a Value
toValue :: (SymToken -> AssetId) -> SymValue -> Value

-- | The <a>Spec</a> monad is a state monad over the <a>ModelState</a> with
--   reader and writer components to keep track of newly created symbolic
--   tokens. It is used exclusively by the <a>nextState</a> function to
--   model the effects of an action on the blockchain.
newtype Spec state a
Spec :: WriterT [SymToken] (ReaderT (Var (Map String AssetId)) (State (ModelState state))) a -> Spec state a
[unSpec] :: Spec state a -> WriterT [SymToken] (ReaderT (Var (Map String AssetId)) (State (ModelState state))) a
wait :: forall state. ContractModel state => Integer -> Spec state ()
waitUntil :: forall state. ContractModel state => Slot -> Spec state ()

-- | Mint tokens. Minted tokens start out as <a>lockedValue</a> (i.e. owned
--   by the contract) and can be transferred to wallets using
--   <a>deposit</a>.
mint :: SymValueLike v => v -> Spec state ()

-- | Burn tokens. Equivalent to <tt><a>mint</a> . <a>inv</a></tt>.
burn :: SymValueLike v => v -> Spec state ()

-- | Add tokens to the <a>balanceChange</a> of a wallet. The added tokens
--   are subtracted from the <tt>lockedValue</tt> of tokens held by
--   contracts.
deposit :: SymValueLike v => Wallet -> v -> Spec state ()

-- | Withdraw tokens from a wallet. The withdrawn tokens are added to the
--   <tt>lockedValue</tt> of tokens held by contracts.
withdraw :: SymValueLike v => Wallet -> v -> Spec state ()

-- | Transfer tokens between wallets, updating their <tt>balances</tt>.
transfer :: SymValueLike v => Wallet -> Wallet -> v -> Spec state ()

-- | Create a new symbolic token in <a>nextState</a> - must have a
--   corresponding <tt>registerToken</tt> call in <a>perform</a>
createToken :: String -> Spec state SymToken

-- | Assert that a particular predicate holds at a point in the
--   specification
assertSpec :: String -> Bool -> Spec state ()
type SpecificationEmulatorTrace = Eff (Writer [(String, AssetClass)] : BaseEmulatorEffects)

-- | Register the real token corresponding to a symbolic token created in
--   <tt>createToken</tt>.
registerToken :: String -> AssetClass -> SpecificationEmulatorTrace ()

-- | `delay n` delays emulator execution by <tt>n</tt> slots
delay :: Integer -> SpecificationEmulatorTrace ()
type DL state = DL (WithInstances (WrappedState state))
action :: ContractModel state => Action state -> DL state ()
waitUntilDL :: ContractModel state => Slot -> DL state ()

-- | Generate a random action using <a>arbitraryAction</a>. The generated
--   action is guaranteed to satisfy its <a>precondition</a>. Fails with
--   <a>Stuck</a> if no action satisfying the precondition can be found
--   after 100 attempts.
anyAction :: DL state ()

-- | Generate a sequence of random actions using <a>arbitraryAction</a>.
--   All actions satisfy their <a>precondition</a>s. The argument is the
--   expected number of actions in the sequence chosen from a geometric
--   distribution, unless in the <a>stopping</a> stage, in which case as
--   few actions as possible are generated.
anyActions :: Int -> DL state ()

-- | Generate a sequence of random actions using <a>arbitraryAction</a>.
--   All actions satisfy their <a>precondition</a>s. Actions may be
--   generated until the <a>stopping</a> stage is reached; the expected
--   length is size/2.
anyActions_ :: DL state ()

-- | Generate a random value using the given <a>Quantification</a> (or
--   list/tuple of quantifications). Generated values will only shrink to
--   smaller values that could also have been generated.
forAllQ :: Quantifiable q => q -> DL s (Quantifies q)

-- | Pick a random value from a list. Treated as an empty choice if the
--   list is empty:
--   
--   <pre>
--   <a>forAllQ</a> (<a>elementsQ</a> []) == <a>empty</a>
--   </pre>
elementsQ :: Eq a => [a] -> Quantification a

-- | Generate a random value in a given range (inclusive).
chooseQ :: (Arbitrary a, Random a, Ord a) => (a, a) -> Quantification a

-- | Fail if the boolean is <tt>False</tt>.
--   
--   Equivalent to
--   
--   <pre>
--   assert msg b = unless b (fail msg)
--   </pre>
assert :: String -> Bool -> DL s ()
assertModel :: String -> (ModelState state -> Bool) -> DL state ()

-- | Test case generation from <a>DL</a> scenarios have a target length of
--   the action sequence to be generated that is based on the QuickCheck
--   size parameter (see <a>sized</a>). However, given that scenarios can
--   contain explicit <a>action</a>s it might not be possible to stop the
--   scenario once the target length has been reached.
--   
--   Instead, once the target number of actions have been reached,
--   generation goes into the <i>stopping</i> phase. In this phase branches
--   starting with <a>stopping</a> are preferred, if possible. Conversely,
--   before the stopping phase, branches starting with <a>stopping</a> are
--   avoided unless there are no other possible choices.
--   
--   For example, here is the definition of <a>anyActions</a>:
--   
--   <pre>
--   <a>anyActions</a> n = <a>stopping</a> <a>&lt;|&gt;</a> pure ()
--                          <a>&lt;|&gt;</a> (<a>weight</a> (fromIntegral n) &gt;&gt; <a>anyAction</a> &gt;&gt; <a>anyActions</a> n)
--   </pre>
--   
--   The effect of this definition is that the second or third branch will
--   be taken until the desired number of actions have been generated, at
--   which point the <a>stopping</a> branch will be taken and generation
--   stops (or continues with whatever comes after the <a>anyActions</a>
--   call).
--   
--   Now, it might not be possible, or too hard, to find a way to terminate
--   a scenario. For instance, this scenario has no finite test cases:
--   
--   <pre>
--   looping = <a>anyAction</a> &gt;&gt; looping
--   </pre>
--   
--   To prevent test case generation from looping, if a scenario has not
--   terminated after generating <tt>2 * n + 20</tt> actions, where
--   <tt>n</tt> is when the stopping phase kicks in, generation fails with
--   a <a>Looping</a> error.
stopping :: DL state ()

-- | By default, <a>Alternative</a> choice (<a>&lt;|&gt;</a>) picks among
--   the next actions with equal probability. So, for instance, this code
--   chooses between the actions <tt>a</tt>, <tt>b</tt> and <tt>c</tt>,
--   with a probability <tt>1/3</tt> of choosing each:
--   
--   <pre>
--   unbiasedChoice a b c = <a>action</a> a <a>&lt;|&gt;</a> <a>action</a> b <a>&lt;|&gt;</a> <a>action</a> c
--   </pre>
--   
--   To change this you can use <a>weight</a>, which multiplies the
--   relative probability of picking a branch by the given number.
--   
--   For instance, the following scenario picks the action <tt>a</tt> with
--   probability <tt>2/3</tt> and the action <tt>b</tt> with probability
--   <tt>1/3</tt>:
--   
--   <pre>
--   biasedChoice a b = <a>weight</a> 2 (<a>action</a> a) <a>&lt;|&gt;</a> <a>weight</a> (<a>action</a> b)
--   </pre>
--   
--   Calls to <a>weight</a> need to appear at the top-level after a choice,
--   preceding any actions (<a>action</a>/<a>anyAction</a>) or random
--   generation (<tt>forAllQ</tt>), or they will have no effect.
weight :: Double -> DL state ()

-- | Sometimes test case generation should depend on QuickCheck's size
--   parameter. This can be accessed using <tt>getSize</tt>. For example,
--   <tt>anyActions_</tt> is defined by
--   
--   <pre>
--   anyActions_ = do n &lt;- getSize
--                    anyActions (n <a>div</a> 2 + 1)
--   </pre>
--   
--   so that we generate a random number of actions, but on average half
--   the size (which is about the same as the average random positive
--   integer, or length of a list).
getSize :: DL state Int

-- | The <a>monitor</a> function allows you to collect statistics of your
--   testing using QuickCheck functions like <a>label</a>, <a>collect</a>,
--   <a>classify</a>, and <a>tabulate</a>. See also the <tt>monitoring</tt>
--   method of <a>ContractModel</a> which is called for all actions in a
--   test case (regardless of whether they are generated by an explicit
--   <a>action</a> or an <a>anyAction</a>).
monitor :: (Property -> Property) -> DL state ()

-- | The constraints required on contract schemas and error types to enable
--   calling contract endpoints (<a>callEndpoint</a>).
type SchemaConstraints w schema err = (Typeable w, Monoid w, ToJSON w, Typeable schema, ContractConstraints schema, Show err, Typeable err, ToJSON err, FromJSON err, ToJSON w, FromJSON w)
data StartContract state
[StartContract] :: (SchemaConstraints w s e, Typeable p) => ContractInstanceKey state w s e p -> p -> StartContract state

-- | A function returning the <a>ContractHandle</a> corresponding to a
--   <a>ContractInstanceKey</a>. A <a>HandleFun</a> is provided to the
--   <a>perform</a> function to enable calling contract endpoints with
--   <a>callEndpoint</a>.
type HandleFun state = forall w schema err params. (Typeable w, Typeable schema, Typeable err, Typeable params) => ContractInstanceKey state w schema err params -> ContractHandle w schema err

-- | Sanity check a <a>ContractModel</a>. Ensures that wallet balances are
--   not always unchanged.
propSanityCheckModel :: forall state. ContractModel state => Property

-- | Sanity check a <a>ContractModel</a>. Ensures that all assertions in
--   the property generation succeed.
propSanityCheckAssertions :: forall state. ContractModel state => Actions state -> Property

-- | Sanity check a <a>ContractModel</a>. Ensures that
--   <a>nextReactiveState</a> is idempotent.
propSanityCheckReactive :: forall state. (ContractModel state, Eq state) => Actions state -> Positive Integer -> Positive Integer -> Property

-- | Options for controlling coverage checking requirements
--   
--   <ul>
--   <li><a>checkCoverage</a> tells you whether or not to run the coverage
--   checks at all.</li>
--   <li>`endpointCoverageEq instance endpointName` tells us what
--   percentage of tests are required to include a call to the endpoint
--   <tt>endpointName</tt> in the contract at `instance`.</li>
--   <li><tt>coverIndex</tt> is the coverage index obtained from the
--   <tt>CompiledCodeIn</tt> of the validator.</li>
--   </ul>
data CoverageOptions

-- | Default coverage checking options are: * not to check coverage * set
--   the requriements for every endpoint to 20% and * not to cover any
--   source locations in the validator scripts.
defaultCoverageOptions :: CoverageOptions
endpointCoverageReq :: Lens' CoverageOptions (ContractInstanceTag -> String -> Double)
checkCoverage :: Lens' CoverageOptions Bool
coverageIndex :: Lens' CoverageOptions CoverageIndex

-- | Run QuickCheck on a property that tracks coverage and print its
--   coverage report.
quickCheckWithCoverage :: Testable prop => Args -> CoverageOptions -> (CoverageOptions -> prop) -> IO CoverageReport
quickCheckWithCoverageAndResult :: Testable prop => Args -> CoverageOptions -> (CoverageOptions -> prop) -> IO (CoverageReport, Result)

-- | Run a <a>Actions</a> in the emulator and check that the model and the
--   emulator agree on the final wallet balance changes. Equivalent to
--   
--   <pre>
--   propRunActions_ hs actions = <a>propRunActions</a> hs (<a>const</a> <a>$</a> <a>pure</a> <a>True</a>) actions
--   </pre>
propRunActions_ :: ContractModel state => Actions state -> Property

-- | Run a <a>Actions</a> in the emulator and check that the model and the
--   emulator agree on the final wallet balance changes, and that the given
--   <a>TracePredicate</a> holds at the end. Equivalent to:
--   
--   <pre>
--   propRunActions = <a>propRunActionsWithOptions</a> <tt>defaultCheckOptionsContractModel</tt> <tt>defaultCoverageOptions</tt>
--   </pre>
propRunActions :: ContractModel state => (ModelState state -> TracePredicate) -> Actions state -> Property

-- | Run a <a>Actions</a> in the emulator and check that the model and the
--   emulator agree on the final wallet balance changes, that no off-chain
--   contract instance crashed, and that the given <a>TracePredicate</a>
--   holds at the end. The predicate has access to the final model state.
--   
--   The <a>Actions</a> argument can be generated by a <tt>forAllDL</tt>
--   from a <a>DL</a> scenario, or using the <a>Arbitrary</a> instance for
--   actions which generates random actions using <a>arbitraryAction</a>:
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck $ propRunActions_ handles
--   +++ OK, passed 100 tests
--   
--   &gt;&gt;&gt; quickCheck $ forAllDL dl $ propRunActions_ handles
--   +++ OK, passed 100 tests
--   </pre>
--   
--   The options argument can be used to configure the emulator--setting
--   initial wallet balances, the maximum number of slots to run for, and
--   the log level for the emulator trace printed on failing tests:
--   
--   <pre>
--   options :: <tt>Map</tt> <a>Wallet</a> <a>Value</a> -&gt; <a>Slot</a> -&gt; <a>LogLevel</a> -&gt; <a>CheckOptions</a>
--   options dist slot logLevel =
--       <a>defaultCheckOptions</a> <a>&amp;</a> <a>emulatorConfig</a> . <a>initialChainState</a> <a>.~</a> <a>Left</a> dist
--                             <a>&amp;</a> <a>minLogLevel</a>                        <a>.~</a> logLevel
--   </pre>
propRunActionsWithOptions :: ContractModel state => CheckOptions -> CoverageOptions -> (ModelState state -> TracePredicate) -> Actions state -> Property

-- | Default check options that include a large amount of Ada in the
--   initial distributions to avoid having to write <a>ContractModel</a>s
--   that keep track of balances.
defaultCheckOptionsContractModel :: CheckOptions

-- | Turn a <a>DL</a> scenario into a QuickCheck property. Generates a
--   random <a>Actions</a> matching the scenario and feeds it to the given
--   property. The property can be a full property running the emulator and
--   checking the results, defined using <tt>propRunActions_</tt>,
--   <tt>propRunActions</tt>, or <tt>propRunActionsWithOptions</tt>.
--   Assuming a model for an auction contract and <a>DL</a> scenario that
--   checks that you can always complete the auction, you can write:
--   
--   <pre>
--   finishAuction :: <a>DL</a> AuctionState ()
--   prop_Auction  = <tt>propRunActions_</tt> handles
--     where handles = ...
--   prop_Finish = <a>forAllDL</a> finishAuction prop_Auction
--   </pre>
--   
--   However, there is also value in a property that does not run the
--   emulator at all:
--   
--   <pre>
--   prop_FinishModel = <a>forAllDL</a> finishAuction $ const True
--   </pre>
--   
--   This will check all the assertions and other failure conditions of the
--   <a>DL</a> scenario very quickly. Once this property passes a large
--   number of tests, you can run the full property checking that the model
--   agrees with reality.
forAllDL :: (ContractModel state, Testable p) => DL state () -> (Actions state -> p) -> Property
forAllDL_ :: (ContractModel state, Testable p) => DL state () -> (Actions state -> p) -> Property
type NoLockedFundsProof state = NoLockedFundsProof (WrappedState state)
pattern NoLockedFundsProof :: () => DL (WithInstances model) () -> (Wallet -> DL (WithInstances model) ()) -> (ModelState (WithInstances model) -> SymValue) -> (ModelState (WithInstances model) -> SymValue) -> NoLockedFundsProof model

-- | Strategy to recover all funds from the contract in any reachable
--   state.
nlfpMainStrategy :: NoLockedFundsProof model -> DL (WithInstances model) ()

-- | A strategy for each wallet to recover as much (or more) funds as the
--   main strategy would give them in a given state, without the assistance
--   of any other wallet.
nlfpWalletStrategy :: NoLockedFundsProof model -> Wallet -> DL (WithInstances model) ()

-- | An initial amount of overhead value that may be lost - e.g. setup fees
--   for scripts that can't be recovered.
nlfpOverhead :: NoLockedFundsProof model -> ModelState (WithInstances model) -> SymValue

-- | The total amount of margin for error in the value collected by the
--   WalletStrategy compared to the MainStrategy. This is useful if your
--   contract contains rounding code that makes the order of operations
--   have a small but predictable effect on the value collected by
--   different wallets.
nlfpErrorMargin :: NoLockedFundsProof model -> ModelState (WithInstances model) -> SymValue

-- | The default skeleton of a NoLockedFundsProof - doesn't permit any
--   overhead or error margin.
defaultNLFP :: NoLockedFundsProof model

-- | Check a <a>NoLockedFundsProof</a>. Each test will generate an
--   arbitrary sequence of actions (<a>anyActions_</a>) and ask the
--   <a>nlfpMainStrategy</a> to recover all funds locked by the contract
--   after performing those actions. This results in some distribution of
--   the contract funds to the wallets, and the test then asks each
--   <a>nlfpWalletStrategy</a> to show how to recover their allotment of
--   funds without any assistance from the other wallets (assuming the main
--   strategy did not execute). When executing wallet strategies, the
--   off-chain instances for other wallets are killed and their private
--   keys are deleted from the emulator state.
checkNoLockedFundsProof :: CheckableContractModel model => NoLockedFundsProof model -> Property
checkNoLockedFundsProofFast :: CheckableContractModel model => NoLockedFundsProof model -> Property
type NoLockedFundsProofLight state = NoLockedFundsProofLight (WrappedState state)
pattern NoLockedFundsProofLight :: () => DL (WithInstances model) () -> NoLockedFundsProofLight model
nlfplMainStrategy :: NoLockedFundsProofLight model -> DL (WithInstances model) ()
checkNoLockedFundsProofLight :: CheckableContractModel model => NoLockedFundsProofLight model -> Property
checkNoLockedFundsProofWithOptions :: CheckableContractModel model => CheckOptions -> NoLockedFundsProof model -> Property
checkNoLockedFundsProofFastWithOptions :: CheckableContractModel model => CheckOptions -> NoLockedFundsProof model -> Property

-- | A whitelist entry tells you what final log entry prefixes are
--   acceptable for a given error
data Whitelist

-- | Check that a whitelist does not accept any partial functions
whitelistOk :: Whitelist -> Bool
mkWhitelist :: [Text] -> Whitelist
errorPrefixes :: Whitelist -> Set Text
defaultWhitelist :: Whitelist

-- | Check that running a contract model does not result in validation
--   failures that are not accepted by the whitelist.
checkErrorWhitelist :: ContractModel m => Whitelist -> Actions m -> Property

-- | Check that running a contract model does not result in validation
--   failures that are not accepted by the whitelist.
checkErrorWhitelistWithOptions :: forall m. ContractModel m => CheckOptions -> CoverageOptions -> Whitelist -> Actions m -> Property
newtype WithInstances s
WithInstances :: s -> WithInstances s
[withoutInstances] :: WithInstances s -> s
newtype WrappedState state
WrapState :: state -> WrappedState state
[unwrapState] :: WrappedState state -> state

-- | Perform a light-weight check to find egregious double satisfaction
--   vulnerabilities in contracts.
--   
--   A counterexample to this property consists of three transactions. *
--   The first transaction is a valid transaction from the trace generated
--   by the contract model. * The second transaction, generated by
--   redirecting a non-datum pubkey output from a non-signer to a signer in
--   the first transaction, fails to validate. This demonstrates that funds
--   can't simply be stolen. * The third transaction goes through and
--   manages to steal funds by altering the first transaction. It is
--   generated by adding another script input (with the same value as the
--   non-signer non-stealable pubkey output) and adding a datum to the
--   non-signer non-stealable pubkey output, and giving the extra value
--   from the new script input to a signer.
checkDoubleSatisfaction :: forall m. ContractModel m => Actions m -> Property

-- | Perform a light-weight check to find egregious double satisfaction
--   vulnerabilities in contracts, with options.
checkDoubleSatisfactionWithOptions :: forall m. ContractModel m => CheckOptions -> CoverageOptions -> Actions m -> Property

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a>  <a>id</a>
--   <a>to</a> . <a>from</a>  <a>id</a>
--   </pre>
class Generic a
instance GHC.Show.Show state => GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.WrappedState state)
instance GHC.Classes.Eq state => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.WrappedState state)
instance GHC.Classes.Ord state => GHC.Classes.Ord (Plutus.Contract.Test.ContractModel.Interface.WrappedState state)
instance GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.ContractInstanceKey state w s e p) => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Internal.ContractInstance.ContractInstanceKey (Plutus.Contract.Test.ContractModel.Interface.WrappedState state) w s e p)
instance GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.ContractInstanceKey state w s e p) => GHC.Show.Show (Plutus.Contract.Test.ContractModel.Internal.ContractInstance.ContractInstanceKey (Plutus.Contract.Test.ContractModel.Interface.WrappedState state) w s e p)
instance GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.Action state) => GHC.Classes.Eq (Test.QuickCheck.ContractModel.Internal.Model.Action (Plutus.Contract.Test.ContractModel.Interface.WrappedState state))
instance GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.Action state) => GHC.Show.Show (Test.QuickCheck.ContractModel.Internal.Model.Action (Plutus.Contract.Test.ContractModel.Interface.WrappedState state))
instance GHC.Generics.Generic (Test.QuickCheck.ContractModel.Internal.Model.Action (Plutus.Contract.Test.ContractModel.Interface.WrappedState state))
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.SomeContractInstanceKey state)
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.SomeContractInstanceKey state)
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => Plutus.Contract.Test.ContractModel.Internal.ContractInstance.ContractInstanceModel (Plutus.Contract.Test.ContractModel.Interface.WrappedState state)
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => Test.QuickCheck.ContractModel.Internal.Model.ContractModel (Plutus.Contract.Test.ContractModel.Interface.WrappedState state)
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => Test.QuickCheck.ContractModel.Internal.RunModel (Plutus.Contract.Test.ContractModel.Interface.WrappedState state) (Plutus.Contract.Test.ContractModel.Internal.SpecificationEmulatorTrace (Plutus.Contract.Test.ContractModel.Interface.WrappedState state))
instance Test.QuickCheck.ContractModel.Internal.Symbolics.SymValueLike Plutus.V1.Ledger.Value.Value
instance Test.QuickCheck.ContractModel.Internal.Symbolics.TokenLike Plutus.V1.Ledger.Value.AssetClass
instance Test.QuickCheck.ContractModel.Internal.Symbolics.SymValueLike Ledger.Ada.Ada
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymTokens Wallet.Emulator.Wallet.Wallet
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymTokens Plutus.V1.Ledger.Value.Value


-- | This module provides a framework for testing Plutus contracts built on
--   <a>Test.QuickCheck</a>. The testing is model based, so to test a
--   contract you define a type modelling the state of the contract (or set
--   of contracts) and provide an instance of the <a>ContractModel</a>
--   class. This instance specifies what operations (<a>Action</a>s) the
--   contract supports, how they interact with the model state, and how to
--   execute them in the blockchain emulator
--   (<a>Plutus.Trace.Emulator</a>). Tests are evaluated by running
--   sequences of actions (random or user-specified) in the emulator and
--   comparing the state of the blockchain to the model state at the end.
--   
--   Test cases are written in the <a>DL</a> monad, which supports mixing
--   fixed sequences of actions with random actions, making it easy to
--   write properties like <i>it is always possible to get all funds out of
--   the contract</i>.
module Plutus.Contract.Test.ContractModel

module Plutus.Contract.Test.ContractModel.CrashTolerance

-- | This derived state is used to derive a new <a>ContractModel</a> on top
--   of the <a>state</a> contract model that also specifies how the
--   contract(s) behave when contract instances crash and restart.
data WithCrashTolerance state
class ContractModel state => CrashTolerance state

-- | Specifiy what happens when a contract instance crashes
crash :: CrashTolerance state => SomeContractInstanceKey state -> Spec state ()

-- | Specify what happens when a contract instance is restarted
restart :: CrashTolerance state => SomeContractInstanceKey state -> Spec state ()

-- | Specify the arguments to give to a restarted contract
restartArguments :: CrashTolerance state => ModelState state -> ContractInstanceKey state w s e p -> p

-- | Check if an action is available given a list of alive contract
--   instances.
available :: CrashTolerance state => Action state -> [SomeContractInstanceKey state] -> Bool
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => GHC.Show.Show (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state)
instance (GHC.Classes.Eq state, Plutus.Contract.Test.ContractModel.Interface.ContractModel state) => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state)
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.Action (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state))
instance GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.ContractInstanceKey state w s e p) => GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.ContractInstanceKey (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state) w s e p)
instance GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.ContractInstanceKey state w s e p) => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.ContractInstanceKey (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state) w s e p)
instance (Data.Typeable.Internal.Typeable state, Plutus.Contract.Test.ContractModel.CrashTolerance.CrashTolerance state) => Plutus.Contract.Test.ContractModel.Interface.ContractModel (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state)
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.Action (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state))
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => Test.QuickCheck.ContractModel.Internal.Model.HasSymTokens (Plutus.Contract.Test.ContractModel.Interface.Action (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state))

module Plutus.Contract.StateMachine

-- | Client-side definition of a state machine.
data StateMachineClient s i
StateMachineClient :: StateMachineInstance s i -> ([OnChainState s i] -> Either SMContractError (OnChainState s i)) -> StateMachineClient s i

-- | The instance of the state machine, defining the machine's transitions,
--   its final states and its check function.
[scInstance] :: StateMachineClient s i -> StateMachineInstance s i

-- | A function that chooses the relevant on-chain state, given a list of
--   all potential on-chain states found at the contract address.
[scChooser] :: StateMachineClient s i -> [OnChainState s i] -> Either SMContractError (OnChainState s i)

-- | Restrictions placed on the allocation of funds to outputs of
--   transactions.
data TxConstraints i o
data SMContractError
ChooserError :: Text -> SMContractError
UnableToExtractTransition :: SMContractError
SMCContractError :: ContractError -> SMContractError
class AsSMContractError r_a7d2z
_SMContractError :: AsSMContractError r_a7d2z => Prism' r_a7d2z SMContractError
_ChooserError :: AsSMContractError r_a7d2z => Prism' r_a7d2z Text
_UnableToExtractTransition :: AsSMContractError r_a7d2z => Prism' r_a7d2z ()
_SMCContractError :: AsSMContractError r_a7d2z => Prism' r_a7d2z ContractError

-- | Specification of a state machine, consisting of a transition function
--   that determines the next state from the current state and an input,
--   and a checking function that checks the validity of the transition in
--   the context of the current transaction.
data StateMachine s i
StateMachine :: (State s -> i -> Maybe (TxConstraints Void Void, State s)) -> (s -> Bool) -> (s -> i -> ScriptContext -> Bool) -> Maybe ThreadToken -> StateMachine s i

-- | The transition function of the state machine. <a>Nothing</a> indicates
--   an invalid transition from the current state.
[smTransition] :: StateMachine s i -> State s -> i -> Maybe (TxConstraints Void Void, State s)

-- | Check whether a state is the final state
[smFinal] :: StateMachine s i -> s -> Bool

-- | The condition checking function. Can be used to perform checks on the
--   pending transaction that aren't covered by the constraints.
--   <a>smCheck</a> is always run in addition to checking the constraints,
--   so the default implementation always returns true.
[smCheck] :: StateMachine s i -> s -> i -> ScriptContext -> Bool

-- | The <tt>ThreadToken</tt> that identifies the contract instance. Make
--   one with <tt>getThreadToken</tt> and pass it on to
--   <a>mkStateMachine</a>. Initialising the machine will then mint a
--   thread token value.
[smThreadToken] :: StateMachine s i -> Maybe ThreadToken
data StateMachineInstance s i
StateMachineInstance :: StateMachine s i -> TypedValidator (StateMachine s i) -> StateMachineInstance s i

-- | The state machine specification.
[stateMachine] :: StateMachineInstance s i -> StateMachine s i

-- | The validator code for this state machine.
[typedValidator] :: StateMachineInstance s i -> TypedValidator (StateMachine s i)
data State s
State :: s -> Value -> State s
[stateData] :: State s -> s
[stateValue] :: State s -> Value

-- | Typed representation of the on-chain state of a state machine instance
newtype OnChainState s i
OnChainState :: TypedScriptTxOutRef (StateMachine s i) -> OnChainState s i

-- | Typed UTXO
[ocsTxOutRef] :: OnChainState s i -> TypedScriptTxOutRef (StateMachine s i)

-- | The outcome of <a>waitForUpdateTimeout</a>
data WaitingResult t i s

-- | The timeout happened before any change of the on-chain state was
--   detected
Timeout :: t -> WaitingResult t i s

-- | The state machine instance ended
ContractEnded :: i -> WaitingResult t i s

-- | The state machine instance transitioned to a new state
Transition :: i -> s -> WaitingResult t i s

-- | The state machine instance was initialised
InitialState :: s -> WaitingResult t i s

-- | An invalid transition
data InvalidTransition s i
InvalidTransition :: Maybe (State s) -> i -> InvalidTransition s i

-- | Current state. <a>Nothing</a> indicates that there is no current
--   state.
[tfState] :: InvalidTransition s i -> Maybe (State s)

-- | Transition that was attempted but failed
[tfInput] :: InvalidTransition s i -> i

-- | Result of an attempted transition
data TransitionResult s i

-- | The transition is not allowed
TransitionFailure :: InvalidTransition s i -> TransitionResult s i

-- | The transition is allowed and results in a new state
TransitionSuccess :: s -> TransitionResult s i
data ThreadToken
ThreadToken :: TxOutRef -> CurrencySymbol -> ThreadToken

-- | Turn a state machine into a validator script.
mkValidator :: forall s i. ToData s => StateMachine s i -> ValidatorType (StateMachine s i)

-- | A state machine that does not perform any additional checks on the
--   <a>ScriptContext</a> (beyond enforcing the constraints)
mkStateMachine :: Maybe ThreadToken -> (State s -> i -> Maybe (TxConstraints Void Void, State s)) -> (s -> Bool) -> StateMachine s i

-- | A state machine client with the <a>defaultChooser</a> function
mkStateMachineClient :: forall state input. StateMachineInstance state input -> StateMachineClient state input

-- | A state chooser function that fails if confronted with anything other
--   than exactly one output
defaultChooser :: forall state input. [OnChainState state input] -> Either SMContractError (OnChainState state input)
getStates :: forall s i. (FromData s, ToData s) => StateMachineInstance s i -> Map TxOutRef DecoratedTxOut -> [OnChainState s i]

-- | Tries to run one step of a state machine: If the <i>guard</i> (the
--   last argument) returns <tt><a>Nothing</a></tt> when given the
--   unbalanced transaction to be submitted, the old state and the new
--   step, the step is run and <tt><a>Right</a></tt> the new state is
--   returned. If the guard returns <tt><a>Just</a> a</tt>, <tt><a>Left</a>
--   a</tt> is returned instead.
runGuardedStep :: forall w a e state schema input. (AsSMContractError e, FromData state, ToData state, ToData input) => StateMachineClient state input -> input -> (UnbalancedTx -> state -> state -> Maybe a) -> Contract w schema e (Either a (TransitionResult state input))

-- | Run one step of a state machine, returning the new state.
runStep :: forall w e state schema input. (AsSMContractError e, FromData state, ToData state, ToData input) => StateMachineClient state input -> input -> Contract w schema e (TransitionResult state input)

-- | Initialise a state machine
runInitialise :: forall w e state schema input. (FromData state, ToData state, ToData input, AsSMContractError e) => StateMachineClient state input -> state -> Value -> Contract w schema e state

-- | The same as <a>runGuardedStep</a> but we can supply additional
--   constraints and lookups for transaction.
runGuardedStepWith :: forall w a e state schema input. (AsSMContractError e, FromData state, ToData state, ToData input) => ScriptLookups (StateMachine state input) -> TxConstraints input state -> StateMachineClient state input -> input -> (UnbalancedTx -> state -> state -> Maybe a) -> Contract w schema e (Either a (TransitionResult state input))

-- | Run one step of a state machine, returning the new state. We can
--   supply additional constraints and lookups for transaction.
runStepWith :: forall w e state schema input. (AsSMContractError e, FromData state, ToData state, ToData input) => ScriptLookups (StateMachine state input) -> TxConstraints input state -> StateMachineClient state input -> input -> Contract w schema e (TransitionResult state input)

-- | Initialise a state machine and supply additional constraints and
--   lookups for transaction.
runInitialiseWith :: forall w e state schema input. (FromData state, ToData state, ToData input, AsSMContractError e) => ScriptLookups (StateMachine state input) -> TxConstraints input state -> StateMachineClient state input -> state -> Value -> Contract w schema e state

-- | Create a thread token. The thread token contains a reference to an
--   unspent output of the wallet, so it needs to used with
--   <tt>mkStateMachine</tt> immediately, and the machine must be
--   initialised, to prevent the output from getting spent in the mean
--   time.
getThreadToken :: AsSMContractError e => Contract w schema e ThreadToken

-- | Get the current on-chain state of the state machine instance. Return
--   Nothing if there is no state on chain. Throws an
--   <tt>SMContractError</tt> if the number of outputs at the machine
--   address is greater than one.
getOnChainState :: (AsSMContractError e, FromData state, ToData state) => StateMachineClient state i -> Contract w schema e (Maybe (OnChainState state i, Map TxOutRef DecoratedTxOut))
getStateData :: OnChainState s i -> s

-- | Wait until the on-chain state of the state machine instance has
--   changed, and return the new state, or return <a>Nothing</a> if the
--   instance has been terminated. If <a>waitForUpdate</a> is called before
--   the instance has even started then it returns the first state of the
--   instance as soon as it has started.
waitForUpdate :: forall state i w schema e. (AsSMContractError e, AsContractError e, FromData state, ToData state, FromData i) => StateMachineClient state i -> Contract w schema e (Maybe (OnChainState state i))

-- | Wait for the on-chain state of the state machine instance to change
--   until timeoutSlot, and return the new state, or return
--   <a>ContractEnded</a> if the instance has been terminated. If
--   <a>waitForUpdate</a> is called before the instance has even started
--   then it returns the first state of the instance as soon as it has
--   started.
waitForUpdateUntilSlot :: (AsSMContractError e, AsContractError e, FromData state, ToData state, FromData i) => StateMachineClient state i -> Slot -> Contract w schema e (WaitingResult Slot i state)

-- | Same as <a>waitForUpdateUntilSlot</a>, but works with <a>POSIXTime</a>
--   instead.
waitForUpdateUntilTime :: (AsSMContractError e, AsContractError e, FromData state, ToData state, FromData i) => StateMachineClient state i -> POSIXTime -> Contract w schema e (WaitingResult POSIXTime i state)

-- | Construct a <a>Promise</a> that waits for an update to the state
--   machine's on-chain state, or a user-defined timeout (whichever happens
--   first).
waitForUpdateTimeout :: forall state i t w schema e. (AsSMContractError e, AsContractError e, FromData state, ToData state, FromData i) => StateMachineClient state i -> Promise w schema e t -> Contract w schema e (Promise w schema e (WaitingResult t i (OnChainState state i)))

-- | Constraints &amp; lookups needed to transition a state machine
--   instance
data StateMachineTransition state input
StateMachineTransition :: TxConstraints input state -> State state -> State state -> ScriptLookups (StateMachine state input) -> StateMachineTransition state input
[smtConstraints] :: StateMachineTransition state input -> TxConstraints input state
[smtOldState] :: StateMachineTransition state input -> State state
[smtNewState] :: StateMachineTransition state input -> State state
[smtLookups] :: StateMachineTransition state input -> ScriptLookups (StateMachine state input)

-- | Given a state machine client and an input to apply to the client's
--   state machine instance, compute the <a>StateMachineTransition</a> that
--   can produce an actual transaction performing the transition
mkStep :: forall w e state schema input. (AsSMContractError e, FromData state, ToData state) => StateMachineClient state input -> input -> Contract w schema e (Either (InvalidTransition state input) (StateMachineTransition state input))

-- | Uninhabited data type
data Void
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON t, Data.Aeson.Types.FromJSON.FromJSON i) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.StateMachine.WaitingResult t i s)
instance (Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON i, Data.Aeson.Types.ToJSON.ToJSON t) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.StateMachine.WaitingResult t i s)
instance GHC.Base.Functor (Plutus.Contract.StateMachine.WaitingResult t i)
instance GHC.Generics.Generic (Plutus.Contract.StateMachine.WaitingResult t i s)
instance (GHC.Show.Show t, GHC.Show.Show i, GHC.Show.Show s) => GHC.Show.Show (Plutus.Contract.StateMachine.WaitingResult t i s)
instance Plutus.Contract.StateMachine.AsSMContractError Plutus.Contract.StateMachine.SMContractError
instance Plutus.Contract.Error.AsContractError Plutus.Contract.StateMachine.SMContractError
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON i) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.StateMachine.InvalidTransition s i)
instance (Data.Aeson.Types.ToJSON.ToJSON i, Data.Aeson.Types.ToJSON.ToJSON s) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.StateMachine.InvalidTransition s i)
instance GHC.Generics.Generic (Plutus.Contract.StateMachine.InvalidTransition s i)
instance (GHC.Show.Show s, GHC.Show.Show i) => GHC.Show.Show (Plutus.Contract.StateMachine.InvalidTransition s i)
instance (GHC.Classes.Eq s, GHC.Classes.Eq i) => GHC.Classes.Eq (Plutus.Contract.StateMachine.InvalidTransition s i)
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.StateMachine.SMContractError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.StateMachine.SMContractError
instance GHC.Generics.Generic Plutus.Contract.StateMachine.SMContractError
instance GHC.Classes.Eq Plutus.Contract.StateMachine.SMContractError
instance GHC.Show.Show Plutus.Contract.StateMachine.SMContractError

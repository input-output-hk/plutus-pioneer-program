-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Interface to the Plutus ledger for the Cardano ledger.
--   
--   Interface to the Plutus scripting support for the Cardano ledger.
@package plutus-ledger-api
@version 1.0.0.1


-- | Common types and functions used across all the ledger API modules.
module Plutus.ApiCommon

-- | Scripts to the ledger are serialised bytestrings.
type SerializedScript = ShortByteString

-- | The plutus language version as seen from the ledger's side. Note: the
--   ordering of constructors matters for deriving Ord
data LedgerPlutusVersion
PlutusV1 :: LedgerPlutusVersion
PlutusV2 :: LedgerPlutusVersion

-- | This represents the Cardano protocol version, with its major and minor
--   components. This relies on careful understanding between us and the
--   ledger as to what this means.
data ProtocolVersion
ProtocolVersion :: Int -> Int -> ProtocolVersion
[pvMajor] :: ProtocolVersion -> Int
[pvMinor] :: ProtocolVersion -> Int

-- | A map indicating which builtin functions were introduced in which
--   <a>ProtocolVersion</a>. Each builtin function should appear at most
--   once.
--   
--   This *must* be updated when new builtins are added. See Note [New
--   builtins and protocol versions]
builtinsIntroducedIn :: Map (LedgerPlutusVersion, ProtocolVersion) (Set DefaultFun)

-- | Which builtin functions are available in the given
--   <a>ProtocolVersion</a>?
--   
--   See Note [New builtins and protocol versions]
builtinsAvailableIn :: LedgerPlutusVersion -> ProtocolVersion -> Set DefaultFun

-- | A variant of <tt>Script</tt> with a specialized decoder.
newtype ScriptForExecution
ScriptForExecution :: Program NamedDeBruijn DefaultUni DefaultFun () -> ScriptForExecution

-- | This decoder decodes the names directly into <a>NamedDeBruijn</a>s
--   rather than <a>DeBruijn</a>s. This is needed because the CEK machine
--   expects <tt>NameDeBruijn</tt>s, but there are obviously no names in
--   the serialized form of a <tt>Script</tt>. Rather than traversing the
--   term and inserting fake names after deserializing, this lets us do at
--   the same time as deserializing.
scriptCBORDecoder :: LedgerPlutusVersion -> ProtocolVersion -> Decoder s ScriptForExecution

-- | Check if a <tt>Script</tt> is "valid" according to a protocol version.
--   At the moment this means "deserialises correctly", which in particular
--   implies that it is (almost certainly) an encoded script and the script
--   does not mention any builtins unavailable in the given protocol
--   version.
--   
--   Note: Parameterized over the ledger-plutus-version since the builtins
--   allowed (during decoding) differs.
isScriptWellFormed :: LedgerPlutusVersion -> ProtocolVersion -> SerializedScript -> Bool

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: FreeVariableError -> EvaluationError

-- | A serialisation error
CodecError :: DeserialiseFailure -> EvaluationError

-- | An error indicating a version tag that we don't support TODO: make
--   this error more informative when we have more information about what
--   went wrong
IncompatibleVersionError :: Version () -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError

-- | The type of log output: just a list of <a>Text</a>.
type LogOutput = [Text]

-- | A simple toggle indicating whether or not we should produce logs.
data VerboseMode
Verbose :: VerboseMode
Quiet :: VerboseMode

-- | Shared helper for the evaluation functions, deserializes the
--   <a>SerializedScript</a> , applies it to its arguments, puts
--   fakenamedebruijns, and scope-checks it.
mkTermToEvaluate :: MonadError EvaluationError m => LedgerPlutusVersion -> ProtocolVersion -> SerializedScript -> [Data] -> m (Term NamedDeBruijn DefaultUni DefaultFun ())

-- | Which unlifting mode should we use in the given <a>ProtocolVersion</a>
--   so as to correctly construct the machine's parameters
unliftingModeIn :: ProtocolVersion -> UnliftingMode
type DefaultMachineParameters = MachineParameters CekMachineCosts CekValue DefaultUni DefaultFun
toMachineParameters :: ProtocolVersion -> EvaluationContext -> DefaultMachineParameters
mkMachineParametersFor :: MonadError CostModelApplyError m => UnliftingMode -> CostModelParams -> m DefaultMachineParameters

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than recomputed on every evaluation.
--   
--   There are two sets of parameters: one is with immediate unlifting and
--   the other one is with deferred unlifting. We have to keep both of
--   them, because depending on the language version either one has to be
--   used or the other. We also compile them separately due to all the
--   inlining and optimization that need to happen for things to be
--   efficient.
data EvaluationContext
EvaluationContext :: DefaultMachineParameters -> DefaultMachineParameters -> EvaluationContext
[machineParametersImmediate] :: EvaluationContext -> DefaultMachineParameters
[machineParametersDeferred] :: EvaluationContext -> DefaultMachineParameters

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a <a>Map</a> of strings to cost integer values (aka
--   <a>CostModelParams</a>, <a>CostModel</a>) See Note [Inlining meanings
--   of builtins].
mkEvaluationContext :: MonadError CostModelApplyError m => CostModelParams -> m EvaluationContext

-- | Comparably expensive to <a>mkEvaluationContext</a>, so it should only
--   be used sparingly.
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
--   
--   Note: Parameterized over the ledger-plutus-version since the builtins
--   allowed (during decoding) differs.
evaluateScriptRestricting :: LedgerPlutusVersion -> ProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> SerializedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. This will take as long as the script
--   takes, if you need to limit the execution time of the script also, you
--   can use <a>evaluateScriptRestricting</a>, which also returns the used
--   budget.
--   
--   Note: Parameterized over the ledger-plutus-version since the builtins
--   allowed (during decoding) differs.
evaluateScriptCounting :: LedgerPlutusVersion -> ProtocolVersion -> VerboseMode -> EvaluationContext -> SerializedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)
instance GHC.Classes.Ord Plutus.ApiCommon.LedgerPlutusVersion
instance GHC.Classes.Eq Plutus.ApiCommon.LedgerPlutusVersion
instance GHC.Classes.Eq Plutus.ApiCommon.ProtocolVersion
instance GHC.Show.Show Plutus.ApiCommon.ProtocolVersion
instance GHC.Classes.Eq Plutus.ApiCommon.EvaluationError
instance GHC.Show.Show Plutus.ApiCommon.EvaluationError
instance GHC.Classes.Eq Plutus.ApiCommon.VerboseMode
instance NoThunks.Class.NoThunks Plutus.ApiCommon.EvaluationContext
instance Control.DeepSeq.NFData Plutus.ApiCommon.EvaluationContext
instance GHC.Generics.Generic Plutus.ApiCommon.EvaluationContext
instance Prettyprinter.Internal.Pretty Plutus.ApiCommon.EvaluationError
instance GHC.Classes.Ord Plutus.ApiCommon.ProtocolVersion
instance Prettyprinter.Internal.Pretty Plutus.ApiCommon.ProtocolVersion

module Plutus.V1.Ledger.EvaluationContext

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than recomputed on every evaluation.
--   
--   There are two sets of parameters: one is with immediate unlifting and
--   the other one is with deferred unlifting. We have to keep both of
--   them, because depending on the language version either one has to be
--   used or the other. We also compile them separately due to all the
--   inlining and optimization that need to happen for things to be
--   efficient.
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a <a>Map</a> of strings to cost integer values (aka
--   <a>CostModelParams</a>, <a>CostModel</a>) See Note [Inlining meanings
--   of builtins].
mkEvaluationContext :: MonadError CostModelApplyError m => CostModelParams -> m EvaluationContext
type CostModelParams = Map Text Integer

-- | Comparably expensive to <a>mkEvaluationContext</a>, so it should only
--   be used sparingly.
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()
machineParametersImmediate :: EvaluationContext -> DefaultMachineParameters
machineParametersDeferred :: EvaluationContext -> DefaultMachineParameters
toMachineParameters :: ProtocolVersion -> EvaluationContext -> DefaultMachineParameters

-- | The set of valid names that a cost model parameter can take for this
--   language version. It is used for the deserialization of
--   <a>CostModelParams</a>.
costModelParamNames :: Set Text

-- | The raw cost model params, only to be used for testing purposes.
costModelParamsForTesting :: CostModelParams

-- | only to be for testing purposes: make an evaluation context by
--   applying an empty set of protocol parameters
evalCtxForTesting :: EvaluationContext

-- | The type of errors that <a>applyParams</a> can throw.
data CostModelApplyError

-- | a costmodel parameter with the give name does not exist in the
--   costmodel to be applied upon
CMUnknownParamError :: Text -> CostModelApplyError

-- | internal error when we are transforming the applyParams' input to json
--   (should not happen)
CMInternalReadError :: CostModelApplyError

-- | internal error when we are transforming the applied params from json
--   with given jsonstring error (should not happen)
CMInternalWriteError :: String -> CostModelApplyError


-- | A type for intervals and associated functions.
module Plutus.V1.Ledger.Interval

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | Check whether a value is in an interval.
member :: Ord a => a -> Interval a -> Bool

-- | <tt>interval a b</tt> includes all values that are greater than or
--   equal to <tt>a</tt> and smaller than or equal to <tt>b</tt>. Therefore
--   it includes <tt>a</tt> and <tt>b</tt>.
interval :: a -> a -> Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>.
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>.
to :: a -> Interval a

-- | An <a>Interval</a> that covers every slot.
always :: Interval a

-- | An <a>Interval</a> that is empty.
never :: Interval a
singleton :: a -> Interval a

-- | 'hull a b' is the smallest interval containing <tt>a</tt> and
--   <tt>b</tt>.
hull :: Ord a => Interval a -> Interval a -> Interval a

-- | 'intersection a b' is the largest interval that is contained in
--   <tt>a</tt> and in <tt>b</tt>, if it exists.
intersection :: Ord a => Interval a -> Interval a -> Interval a

-- | Check whether two intervals overlap, that is, whether there is a value
--   that is a member of both intervals.
overlaps :: (Enum a, Ord a) => Interval a -> Interval a -> Bool

-- | <tt>a <a>contains</a> b</tt> is true if the <a>Interval</a> <tt>b</tt>
--   is entirely contained in <tt>a</tt>. That is, <tt>a <a>contains</a>
--   b</tt> if for every entry <tt>s</tt>, if <tt>member s b</tt> then
--   <tt>member s a</tt>.
contains :: Ord a => Interval a -> Interval a -> Bool

-- | Check if an <a>Interval</a> is empty.
isEmpty :: (Enum a, Ord a) => Interval a -> Bool

-- | Check if a value is earlier than the beginning of an <a>Interval</a>.
before :: Ord a => a -> Interval a -> Bool

-- | Check if a value is later than the end of a <a>Interval</a>.
after :: Ord a => a -> Interval a -> Bool
lowerBound :: a -> LowerBound a
upperBound :: a -> UpperBound a
strictLowerBound :: a -> LowerBound a
strictUpperBound :: a -> UpperBound a
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Interval.Interval
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.LowerBound a), PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.UpperBound a)) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.V1.Ledger.Interval.Extended a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (Plutus.V1.Ledger.Interval.Extended a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.V1.Ledger.Interval.UpperBound a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (Plutus.V1.Ledger.Interval.UpperBound a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.V1.Ledger.Interval.LowerBound a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (Plutus.V1.Ledger.Interval.LowerBound a)
instance PlutusTx.Ord.Ord a => PlutusTx.Lattice.JoinSemiLattice (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Ord.Ord a => PlutusTx.Lattice.BoundedJoinSemiLattice (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Ord.Ord a => PlutusTx.Lattice.MeetSemiLattice (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Ord.Ord a => PlutusTx.Lattice.BoundedMeetSemiLattice (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Interval.UpperBound
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.Extended a)) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.UpperBound a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Interval.LowerBound
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.Extended a)) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.LowerBound a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Interval.Extended
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni a) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.Extended a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.V1.Ledger.Interval.LowerBound a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.V1.Ledger.Interval.LowerBound a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.V1.Ledger.Interval.LowerBound a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.V1.Ledger.Interval.UpperBound a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.V1.Ledger.Interval.UpperBound a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.V1.Ledger.Interval.UpperBound a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.V1.Ledger.Interval.Extended a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.V1.Ledger.Interval.Extended a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.V1.Ledger.Interval.Extended a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Plutus.V1.Ledger.Interval.Extended a)
instance GHC.Generics.Generic (Plutus.V1.Ledger.Interval.Extended a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.V1.Ledger.Interval.Extended a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Plutus.V1.Ledger.Interval.Extended a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.V1.Ledger.Interval.Extended a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Plutus.V1.Ledger.Interval.UpperBound a)
instance GHC.Generics.Generic (Plutus.V1.Ledger.Interval.UpperBound a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.V1.Ledger.Interval.UpperBound a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Plutus.V1.Ledger.Interval.UpperBound a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.V1.Ledger.Interval.UpperBound a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Plutus.V1.Ledger.Interval.LowerBound a)
instance GHC.Generics.Generic (Plutus.V1.Ledger.Interval.LowerBound a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.V1.Ledger.Interval.LowerBound a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Plutus.V1.Ledger.Interval.LowerBound a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.V1.Ledger.Interval.LowerBound a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Plutus.V1.Ledger.Interval.Interval a)
instance GHC.Generics.Generic (Plutus.V1.Ledger.Interval.Interval a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.V1.Ledger.Interval.Interval a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Plutus.V1.Ledger.Interval.Interval a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Functor.Functor Plutus.V1.Ledger.Interval.Interval
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Functor.Functor Plutus.V1.Ledger.Interval.LowerBound
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Plutus.V1.Ledger.Interval.LowerBound a)
instance PlutusTx.Functor.Functor Plutus.V1.Ledger.Interval.UpperBound
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Plutus.V1.Ledger.Interval.UpperBound a)
instance PlutusTx.Functor.Functor Plutus.V1.Ledger.Interval.Extended
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Plutus.V1.Ledger.Interval.Extended a)

module Plutus.V1.Ledger.ProtocolVersions
shelleyPV :: ProtocolVersion
allegraPV :: ProtocolVersion
maryPV :: ProtocolVersion
alonzoPV :: ProtocolVersion
vasilPV :: ProtocolVersion


-- | UTCTime and UTCTime ranges.
module Plutus.V1.Ledger.Time

-- | POSIX time is measured as the number of milliseconds since
--   1970-01-01T00:00:00Z
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | This is a length of time, as measured by a number of milliseconds.
newtype DiffMilliSeconds
DiffMilliSeconds :: Integer -> DiffMilliSeconds

-- | Simple conversion from <a>DiffMilliSeconds</a> to <a>POSIXTime</a>.
fromMilliSeconds :: DiffMilliSeconds -> POSIXTime
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Time.POSIXTime
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Real.Integral Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Real.Real Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Enum.Enum Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Num.Num Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Enum.Enum Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Numeric.AdditiveGroup Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Numeric.AdditiveMonoid Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Numeric.AdditiveSemigroup Plutus.V1.Ledger.Time.POSIXTime
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Generics.Generic Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Show.Show Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Classes.Ord Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Classes.Eq Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Time.DiffMilliSeconds
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Time.DiffMilliSeconds
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Time.DiffMilliSeconds
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Time.DiffMilliSeconds
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Time.DiffMilliSeconds
instance GHC.Real.Integral Plutus.V1.Ledger.Time.DiffMilliSeconds
instance GHC.Real.Real Plutus.V1.Ledger.Time.DiffMilliSeconds
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Time.DiffMilliSeconds
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Time.DiffMilliSeconds
instance GHC.Enum.Enum Plutus.V1.Ledger.Time.DiffMilliSeconds
instance PlutusTx.Numeric.AdditiveGroup Plutus.V1.Ledger.Time.DiffMilliSeconds
instance PlutusTx.Numeric.AdditiveMonoid Plutus.V1.Ledger.Time.DiffMilliSeconds
instance PlutusTx.Numeric.AdditiveSemigroup Plutus.V1.Ledger.Time.DiffMilliSeconds
instance GHC.Num.Num Plutus.V1.Ledger.Time.DiffMilliSeconds
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Time.DiffMilliSeconds
instance GHC.Generics.Generic Plutus.V1.Ledger.Time.DiffMilliSeconds
instance GHC.Show.Show Plutus.V1.Ledger.Time.DiffMilliSeconds
instance GHC.Classes.Ord Plutus.V1.Ledger.Time.DiffMilliSeconds
instance GHC.Classes.Eq Plutus.V1.Ledger.Time.DiffMilliSeconds

module Plutus.V2.Ledger.EvaluationContext
type CostModelParams = Map Text Integer

-- | The type of errors that <a>applyParams</a> can throw.
data CostModelApplyError

-- | a costmodel parameter with the give name does not exist in the
--   costmodel to be applied upon
CMUnknownParamError :: Text -> CostModelApplyError

-- | internal error when we are transforming the applyParams' input to json
--   (should not happen)
CMInternalReadError :: CostModelApplyError

-- | internal error when we are transforming the applied params from json
--   with given jsonstring error (should not happen)
CMInternalWriteError :: String -> CostModelApplyError

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than recomputed on every evaluation.
--   
--   There are two sets of parameters: one is with immediate unlifting and
--   the other one is with deferred unlifting. We have to keep both of
--   them, because depending on the language version either one has to be
--   used or the other. We also compile them separately due to all the
--   inlining and optimization that need to happen for things to be
--   efficient.
data EvaluationContext
toMachineParameters :: ProtocolVersion -> EvaluationContext -> DefaultMachineParameters

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a <a>Map</a> of strings to cost integer values (aka
--   <a>CostModelParams</a>, <a>CostModel</a>) See Note [Inlining meanings
--   of builtins].
mkEvaluationContext :: MonadError CostModelApplyError m => CostModelParams -> m EvaluationContext

-- | Comparably expensive to <a>mkEvaluationContext</a>, so it should only
--   be used sparingly.
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | The raw cost model params, only to be used for testing purposes.
costModelParamsForTesting :: CostModelParams

-- | only to be for testing purposes: make an evaluation context by
--   applying an empty set of protocol parameters
evalCtxForTesting :: EvaluationContext

-- | The set of valid names that a cost model parameter can take for this
--   language version. It is used for the deserialization of
--   <a>CostModelParams</a>.
costModelParamNames :: Set Text

module Plutus.V1.Ledger.Bytes
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString
fromHex :: ByteString -> Either String LedgerBytes
bytes :: LedgerBytes -> ByteString
fromBytes :: ByteString -> LedgerBytes
encodeByteString :: ByteString -> Text
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Bytes.LedgerBytes
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Bytes.LedgerBytes
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Bytes.LedgerBytes
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Bytes.LedgerBytes
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Bytes.LedgerBytes
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Bytes.LedgerBytes
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Bytes.LedgerBytes
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Bytes.LedgerBytes
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Bytes.LedgerBytes
instance GHC.Generics.Generic Plutus.V1.Ledger.Bytes.LedgerBytes
instance GHC.Classes.Ord Plutus.V1.Ledger.Bytes.LedgerBytes
instance GHC.Classes.Eq Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.String.IsString Plutus.V1.Ledger.Bytes.LedgerBytes
instance GHC.Show.Show Plutus.V1.Ledger.Bytes.LedgerBytes


-- | Functions for working with scripts on the ledger.
module Plutus.V1.Ledger.Scripts

-- | A script on the chain. This is an opaque type as far as the chain is
--   concerned.
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
[unScript] :: Script -> Program DeBruijn DefaultUni DefaultFun ()

-- | The size of a <a>Script</a>. No particular interpretation is given to
--   this, other than that it is proportional to the serialized size of the
--   script.
scriptSize :: Script -> Integer

-- | Turn a <a>CompiledCode</a> (usually produced by <tt>compile</tt>) into
--   a <a>Script</a> for use with this package.
fromCompiledCode :: CompiledCode a -> Script
data ScriptError

-- | Expected behavior of the engine (e.g. user-provided error)
EvaluationError :: [Text] -> String -> ScriptError

-- | Unexpected behavior of the engine (a bug)
EvaluationException :: String -> String -> ScriptError

-- | Evaluate a script, returning the trace log.
evaluateScript :: forall m. MonadError ScriptError m => Script -> m (ExBudget, [Text])

-- | Evaluate a <a>Validator</a> with its <a>Context</a>, <a>Datum</a>, and
--   <a>Redeemer</a>, returning the log.
runScript :: MonadError ScriptError m => Context -> Validator -> Datum -> Redeemer -> m (ExBudget, [Text])

-- | Evaluate a <a>MintingPolicy</a> with its <a>Context</a> and
--   <a>Redeemer</a>, returning the log.
runMintingPolicyScript :: MonadError ScriptError m => Context -> MintingPolicy -> Redeemer -> m (ExBudget, [Text])

-- | Evaluate a <a>StakeValidator</a> with its <a>Context</a> and
--   <a>Redeemer</a>, returning the log.
runStakeValidatorScript :: MonadError ScriptError m => Context -> StakeValidator -> Redeemer -> m (ExBudget, [Text])

-- | Apply a <a>Validator</a> to its <a>Context</a>, <a>Datum</a>, and
--   <a>Redeemer</a>.
applyValidator :: Context -> Validator -> Datum -> Redeemer -> Script

-- | Apply <a>MintingPolicy</a> to its <a>Context</a> and <a>Redeemer</a>.
applyMintingPolicyScript :: Context -> MintingPolicy -> Redeemer -> Script

-- | Apply <a>StakeValidator</a> to its <a>Context</a> and <a>Redeemer</a>.
applyStakeValidatorScript :: Context -> StakeValidator -> Redeemer -> Script
applyArguments :: Script -> [Data] -> Script
mkValidatorScript :: CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ()) -> Validator

-- | <a>Validator</a> is a wrapper around <a>Script</a>s which are used as
--   validators in transaction outputs.
newtype Validator
Validator :: Script -> Validator
[getValidator] :: Validator -> Script
unValidatorScript :: Validator -> Script

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData
mkMintingPolicyScript :: CompiledCode (BuiltinData -> BuiltinData -> ()) -> MintingPolicy

-- | <a>MintingPolicy</a> is a wrapper around <a>Script</a>s which are used
--   as validators for minting constraints.
newtype MintingPolicy
MintingPolicy :: Script -> MintingPolicy
[getMintingPolicy] :: MintingPolicy -> Script
unMintingPolicyScript :: MintingPolicy -> Script
mkStakeValidatorScript :: CompiledCode (BuiltinData -> BuiltinData -> ()) -> StakeValidator

-- | <a>StakeValidator</a> is a wrapper around <a>Script</a>s which are
--   used as validators for withdrawals and stake address certificates.
newtype StakeValidator
StakeValidator :: Script -> StakeValidator
[getStakeValidator] :: StakeValidator -> Script
unStakeValidatorScript :: StakeValidator -> Script

-- | Information about the state of the blockchain and about the
--   transaction that is currently being validated, represented as a value
--   in <tt>Data</tt>.
newtype Context
Context :: BuiltinData -> Context

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ValidatorHash
ValidatorHash :: BuiltinByteString -> ValidatorHash

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype MintingPolicyHash
MintingPolicyHash :: BuiltinByteString -> MintingPolicyHash

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype StakeValidatorHash
StakeValidatorHash :: BuiltinByteString -> StakeValidatorHash

-- | <tt>()</tt> as a redeemer.
unitRedeemer :: Redeemer

-- | <tt>()</tt> as a datum.
unitDatum :: Datum
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.Redeemer
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.Redeemer
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.Datum
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.Datum
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.RedeemerHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.RedeemerHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.DatumHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.DatumHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.ValidatorHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.ValidatorHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.ScriptHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.ScriptHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.Script
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.Script
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.Script
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.ScriptError
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.ScriptError
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.ScriptError
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.ScriptError
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.Validator
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.Validator
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.Validator
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.Validator
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.Validator
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.Validator
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.Datum
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.Datum
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Scripts.Datum
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Scripts.Datum
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Scripts.Datum
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.Datum
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.Datum
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.Datum
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.Datum
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.Datum
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.Redeemer
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.Redeemer
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Scripts.Redeemer
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Scripts.Redeemer
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Scripts.Redeemer
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.Redeemer
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.Redeemer
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.Redeemer
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.Redeemer
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.Redeemer
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.MintingPolicy
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.MintingPolicy
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.MintingPolicy
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.MintingPolicy
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.MintingPolicy
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.MintingPolicy
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.StakeValidator
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.StakeValidator
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.StakeValidator
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.StakeValidator
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.StakeValidator
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.StakeValidator
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.ScriptHash
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Scripts.ScriptHash
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Scripts.ScriptHash
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Scripts.ScriptHash
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.ScriptHash
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.ScriptHash
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.ScriptHash
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.ScriptHash
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.ScriptHash
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.ScriptHash
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.ScriptHash
instance Data.String.IsString Plutus.V1.Ledger.Scripts.ScriptHash
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.ValidatorHash
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Scripts.ValidatorHash
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Scripts.ValidatorHash
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Scripts.ValidatorHash
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.ValidatorHash
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.ValidatorHash
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.ValidatorHash
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.ValidatorHash
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.ValidatorHash
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.ValidatorHash
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.String.IsString Plutus.V1.Ledger.Scripts.ValidatorHash
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.DatumHash
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Scripts.DatumHash
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Scripts.DatumHash
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Scripts.DatumHash
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.DatumHash
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.DatumHash
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.DatumHash
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.DatumHash
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.DatumHash
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.DatumHash
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.DatumHash
instance Data.String.IsString Plutus.V1.Ledger.Scripts.DatumHash
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.RedeemerHash
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Scripts.RedeemerHash
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Scripts.RedeemerHash
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Scripts.RedeemerHash
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.RedeemerHash
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.RedeemerHash
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.RedeemerHash
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.RedeemerHash
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.RedeemerHash
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.RedeemerHash
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.String.IsString Plutus.V1.Ledger.Scripts.RedeemerHash
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Data.String.IsString Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Data.String.IsString Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.Context
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.Context
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.StakeValidator
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.MintingPolicy
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.Validator
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.Script
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.Script
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.Script


-- | Functions for working with <a>Value</a>.
module Plutus.V1.Ledger.Value
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | Creates <a>CurrencySymbol</a> from raw <tt>ByteString</tt>.
currencySymbol :: ByteString -> CurrencySymbol

-- | The currency symbol of a monetay policy hash
mpsSymbol :: MintingPolicyHash -> CurrencySymbol

-- | The minting policy hash of a currency symbol
currencyMPSHash :: CurrencySymbol -> MintingPolicyHash

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | ByteString of a name of a token, shown as UTF-8 string when possible
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Creates <a>TokenName</a> from raw <tt>ByteString</tt>.
tokenName :: ByteString -> TokenName
toString :: TokenName -> String

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName

-- | An asset class, identified by currency symbol and token name.
newtype AssetClass
AssetClass :: (CurrencySymbol, TokenName) -> AssetClass
[unAssetClass] :: AssetClass -> (CurrencySymbol, TokenName)
assetClass :: CurrencySymbol -> TokenName -> AssetClass

-- | A <a>Value</a> containing the given amount of the asset class.
assetClassValue :: AssetClass -> Integer -> Value

-- | Get the quantity of the given <a>AssetClass</a> class in the
--   <a>Value</a>.
assetClassValueOf :: Value -> AssetClass -> Integer

-- | A cryptocurrency value. This is a map from <a>CurrencySymbol</a>s to a
--   quantity of that currency.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   See note [Currencies] for more details.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value

-- | Get the quantity of the given currency in the <a>Value</a>.
valueOf :: Value -> CurrencySymbol -> TokenName -> Integer
scale :: Module s v => s -> v -> v

-- | The list of <a>CurrencySymbol</a>s of a <a>Value</a>.
symbols :: Value -> [CurrencySymbol]

-- | Check whether one <a>Value</a> is greater than or equal to another.
--   See <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
geq :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is strictly greater than another. This
--   is *not* a pointwise operation. <tt>gt l r</tt> means <tt>geq l r
--   &amp;&amp; not (eq l r)</tt>.
gt :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is less than or equal to another. See
--   <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
leq :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is strictly less than another. This is
--   *not* a pointwise operation. <tt>lt l r</tt> means <tt>leq l r
--   &amp;&amp; not (eq l r)</tt>.
lt :: Value -> Value -> Bool

-- | Check whether a <a>Value</a> is zero.
isZero :: Value -> Bool

-- | Split a value into its positive and negative parts. The first element
--   of the tuple contains the negative parts of the value, the second
--   element contains the positive parts.
--   
--   <pre>
--   negate (fst (split a)) <tt>plus</tt> (snd (split a)) == a
--   </pre>
split :: Value -> (Value, Value)
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | Convert a value to a simple list, keeping only the non-zero amounts.
flattenValue :: Value -> [(CurrencySymbol, TokenName, Integer)]
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.Value
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.Value
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.AssetClass
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.AssetClass
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.TokenName
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.TokenName
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.CurrencySymbol
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.CurrencySymbol
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Value.CurrencySymbol
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Value.CurrencySymbol
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Value.CurrencySymbol
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Value.CurrencySymbol
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Value.CurrencySymbol
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Value.CurrencySymbol
instance GHC.Classes.Ord Plutus.V1.Ledger.Value.CurrencySymbol
instance GHC.Classes.Eq Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.Data.Data Plutus.V1.Ledger.Value.CurrencySymbol
instance GHC.Generics.Generic Plutus.V1.Ledger.Value.CurrencySymbol
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Value.CurrencySymbol
instance GHC.Show.Show Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.String.IsString Plutus.V1.Ledger.Value.CurrencySymbol
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Value.TokenName
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Value.TokenName
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Value.TokenName
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Value.TokenName
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Value.TokenName
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Value.TokenName
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Value.TokenName
instance GHC.Classes.Ord Plutus.V1.Ledger.Value.TokenName
instance GHC.Classes.Eq Plutus.V1.Ledger.Value.TokenName
instance Data.Data.Data Plutus.V1.Ledger.Value.TokenName
instance GHC.Generics.Generic Plutus.V1.Ledger.Value.TokenName
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Value.AssetClass
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Value.AssetClass
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Value.AssetClass
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Value.AssetClass
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Value.AssetClass
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Value.AssetClass
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Value.AssetClass
instance GHC.Show.Show Plutus.V1.Ledger.Value.AssetClass
instance GHC.Classes.Ord Plutus.V1.Ledger.Value.AssetClass
instance GHC.Classes.Eq Plutus.V1.Ledger.Value.AssetClass
instance Data.Data.Data Plutus.V1.Ledger.Value.AssetClass
instance GHC.Generics.Generic Plutus.V1.Ledger.Value.AssetClass
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Value.Value
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Value.Value
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Value.Value
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Value.Value
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Value.Value
instance Data.Data.Data Plutus.V1.Ledger.Value.Value
instance GHC.Generics.Generic Plutus.V1.Ledger.Value.Value
instance PlutusTx.Numeric.AdditiveSemigroup Plutus.V1.Ledger.Value.Value
instance PlutusTx.Numeric.AdditiveMonoid Plutus.V1.Ledger.Value.Value
instance PlutusTx.Numeric.AdditiveGroup Plutus.V1.Ledger.Value.Value
instance GHC.Show.Show Plutus.V1.Ledger.Value.Value
instance GHC.Classes.Eq Plutus.V1.Ledger.Value.Value
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Value.Value
instance GHC.Base.Semigroup Plutus.V1.Ledger.Value.Value
instance PlutusTx.Semigroup.Semigroup Plutus.V1.Ledger.Value.Value
instance GHC.Base.Monoid Plutus.V1.Ledger.Value.Value
instance PlutusTx.Monoid.Monoid Plutus.V1.Ledger.Value.Value
instance PlutusTx.Monoid.Group Plutus.V1.Ledger.Value.Value
instance PlutusTx.Numeric.Module GHC.Integer.Type.Integer Plutus.V1.Ledger.Value.Value
instance PlutusTx.Lattice.JoinSemiLattice Plutus.V1.Ledger.Value.Value
instance PlutusTx.Lattice.MeetSemiLattice Plutus.V1.Ledger.Value.Value
instance Data.String.IsString Plutus.V1.Ledger.Value.TokenName
instance GHC.Show.Show Plutus.V1.Ledger.Value.TokenName

module Plutus.V1.Ledger.Crypto

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Crypto.PubKeyHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Crypto.PubKeyHash
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Crypto.PubKeyHash
instance GHC.Show.Show Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.String.IsString Plutus.V1.Ledger.Crypto.PubKeyHash
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Crypto.PubKeyHash
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Crypto.PubKeyHash
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Crypto.PubKeyHash
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Crypto.PubKeyHash
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Crypto.PubKeyHash
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Crypto.PubKeyHash
instance GHC.Generics.Generic Plutus.V1.Ledger.Crypto.PubKeyHash
instance GHC.Classes.Ord Plutus.V1.Ledger.Crypto.PubKeyHash
instance GHC.Classes.Eq Plutus.V1.Ledger.Crypto.PubKeyHash

module Plutus.V1.Ledger.Credential

-- | Staking credential used to assign rewards
data StakingCredential
StakingHash :: Credential -> StakingCredential
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credential required to unlock a transaction output
data Credential

-- | The transaction that spends this output must be signed by the private
--   key
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator.
ScriptCredential :: ValidatorHash -> Credential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Credential.StakingCredential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Credential.StakingCredential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Credential.Credential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Credential.Credential
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Credential.StakingCredential
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Credential.StakingCredential
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Credential.StakingCredential
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Credential.Credential
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Credential.Credential
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Credential.Credential
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Credential.Credential
instance GHC.Generics.Generic Plutus.V1.Ledger.Credential.Credential
instance GHC.Show.Show Plutus.V1.Ledger.Credential.Credential
instance GHC.Classes.Ord Plutus.V1.Ledger.Credential.Credential
instance GHC.Classes.Eq Plutus.V1.Ledger.Credential.Credential
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Credential.StakingCredential
instance GHC.Generics.Generic Plutus.V1.Ledger.Credential.StakingCredential
instance GHC.Show.Show Plutus.V1.Ledger.Credential.StakingCredential
instance GHC.Classes.Ord Plutus.V1.Ledger.Credential.StakingCredential
instance GHC.Classes.Eq Plutus.V1.Ledger.Credential.StakingCredential
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Credential.StakingCredential
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Credential.StakingCredential
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Credential.Credential
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Credential.Credential

module Plutus.V1.Ledger.DCert

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retiremant certificate and the Epoch N
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.DCert.DCert
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.DCert.DCert
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.DCert.DCert
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.DCert.DCert
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.DCert.DCert
instance Control.DeepSeq.NFData Plutus.V1.Ledger.DCert.DCert
instance GHC.Generics.Generic Plutus.V1.Ledger.DCert.DCert
instance GHC.Show.Show Plutus.V1.Ledger.DCert.DCert
instance GHC.Classes.Ord Plutus.V1.Ledger.DCert.DCert
instance GHC.Classes.Eq Plutus.V1.Ledger.DCert.DCert
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.DCert.DCert
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.DCert.DCert

module Plutus.V1.Ledger.Address

-- | Address with two kinds of credentials, normal and staking.
data Address
Address :: Credential -> Maybe StakingCredential -> Address
[addressCredential] :: Address -> Credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The address that should be targeted by a transaction output locked by
--   the public key with the given hash.
pubKeyHashAddress :: PubKeyHash -> Address

-- | The address that should be used by a transaction output locked by the
--   given validator script hash.
scriptHashAddress :: ValidatorHash -> Address

-- | The PubKeyHash of the address, if any
toPubKeyHash :: Address -> Maybe PubKeyHash

-- | The validator hash of the address, if any
toValidatorHash :: Address -> Maybe ValidatorHash

-- | The staking credential of an address (if any)
stakingCredential :: Address -> Maybe StakingCredential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Address.Address
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Address.Address
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Address.Address
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Address.Address
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Address.Address
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Address.Address
instance GHC.Generics.Generic Plutus.V1.Ledger.Address.Address
instance GHC.Show.Show Plutus.V1.Ledger.Address.Address
instance GHC.Classes.Ord Plutus.V1.Ledger.Address.Address
instance GHC.Classes.Eq Plutus.V1.Ledger.Address.Address
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Address.Address
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Address.Address

module Plutus.V1.Ledger.Tx

-- | A transaction ID, using a SHA256 hash as the transaction id.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A tag indicating the type of script that we are pointing to.
data ScriptTag
Spend :: ScriptTag
Mint :: ScriptTag
Cert :: ScriptTag
Reward :: ScriptTag

-- | A redeemer pointer is a pair of a script type tag t and an index i,
--   picking out the ith script of type t in the transaction.
data RedeemerPtr
RedeemerPtr :: ScriptTag -> Integer -> RedeemerPtr
type Redeemers = Map RedeemerPtr Redeemer

-- | A transaction output, consisting of a target address, a value, and
--   optionally a datum hash.
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | Whether the output is a pay-to-pubkey output.
isPubKeyOut :: TxOut -> Bool

-- | Whether the output is a pay-to-script output.
isPayToScriptOut :: TxOut -> Bool

-- | The address of a transaction output.
outAddress :: Lens' TxOut Address

-- | The value of a transaction output. | TODO: Compute address again
outValue :: Lens' TxOut Value

-- | The public key attached to a <a>TxOut</a>, if there is one.
txOutPubKey :: TxOut -> Maybe PubKeyHash

-- | The datum attached to a <a>TxOut</a>, if there is one.
txOutDatum :: TxOut -> Maybe DatumHash

-- | Create a transaction output locked by a public key.
pubKeyHashTxOut :: Value -> PubKeyHash -> TxOut

-- | The type of a transaction input.
data TxInType

-- | A transaction input that consumes a script address with the given
--   validator, redeemer, and datum.
ConsumeScriptAddress :: !Validator -> !Redeemer -> !Datum -> TxInType

-- | A transaction input that consumes a public key address.
ConsumePublicKeyAddress :: TxInType

-- | Consume a simple script
ConsumeSimpleScriptAddress :: TxInType

-- | A transaction input, consisting of a transaction output reference and
--   an input type.
data TxIn
TxIn :: !TxOutRef -> Maybe TxInType -> TxIn
[txInRef] :: TxIn -> !TxOutRef
[txInType] :: TxIn -> Maybe TxInType

-- | The <a>TxOutRef</a> spent by a transaction input.
inRef :: Lens' TxIn TxOutRef

-- | The type of a transaction input.
inType :: Lens' TxIn (Maybe TxInType)

-- | Validator, redeemer, and data scripts of a transaction input that
--   spends a "pay to script" output.
inScripts :: TxIn -> Maybe (Validator, Redeemer, Datum)

-- | A transaction input that spends a "pay to public key" output, given
--   the witness.
pubKeyTxIn :: TxOutRef -> TxIn

-- | A transaction input that spends a "pay to script" output, given
--   witnesses.
scriptTxIn :: TxOutRef -> Validator -> Redeemer -> Datum -> TxIn

-- | Filter to get only the pubkey inputs.
pubKeyTxIns :: Fold (Set TxIn) TxIn

-- | Filter to get only the script inputs.
scriptTxIns :: Fold (Set TxIn) TxIn
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Tx.TxOutRef
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Tx.TxOutRef
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Tx.TxOutRef
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Tx.TxOutRef
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Tx.TxOutRef
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Tx.TxOut
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Tx.TxOut
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Tx.TxOut
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Tx.TxOut
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Tx.TxOut
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Tx.TxId
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Tx.TxId
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Tx.TxId
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Tx.TxId
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Tx.TxId
instance Data.String.IsString Plutus.V1.Ledger.Tx.TxId
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Tx.TxId
instance GHC.Show.Show Plutus.V1.Ledger.Tx.TxId
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Tx.TxId
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Tx.TxId
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Tx.TxId
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.TxId
instance GHC.Classes.Ord Plutus.V1.Ledger.Tx.TxId
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.TxId
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Tx.ScriptTag
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.ScriptTag
instance GHC.Classes.Ord Plutus.V1.Ledger.Tx.ScriptTag
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.ScriptTag
instance GHC.Show.Show Plutus.V1.Ledger.Tx.ScriptTag
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Tx.RedeemerPtr
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.RedeemerPtr
instance GHC.Classes.Ord Plutus.V1.Ledger.Tx.RedeemerPtr
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.RedeemerPtr
instance GHC.Show.Show Plutus.V1.Ledger.Tx.RedeemerPtr
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Tx.TxOutRef
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.TxOutRef
instance GHC.Classes.Ord Plutus.V1.Ledger.Tx.TxOutRef
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.TxOutRef
instance GHC.Show.Show Plutus.V1.Ledger.Tx.TxOutRef
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Tx.TxInType
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.TxInType
instance GHC.Classes.Ord Plutus.V1.Ledger.Tx.TxInType
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.TxInType
instance GHC.Show.Show Plutus.V1.Ledger.Tx.TxInType
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Tx.TxIn
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.TxIn
instance GHC.Classes.Ord Plutus.V1.Ledger.Tx.TxIn
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.TxIn
instance GHC.Show.Show Plutus.V1.Ledger.Tx.TxIn
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Tx.TxOut
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.TxOut
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.TxOut
instance GHC.Show.Show Plutus.V1.Ledger.Tx.TxOut
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Tx.TxOut
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Tx.TxOut
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Tx.TxIn
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Tx.TxOutRef
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Tx.TxOutRef

module Plutus.V2.Ledger.Tx

-- | A transaction ID, using a SHA256 hash as the transaction id.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A tag indicating the type of script that we are pointing to.
data ScriptTag
Spend :: ScriptTag
Mint :: ScriptTag
Cert :: ScriptTag
Reward :: ScriptTag

-- | A redeemer pointer is a pair of a script type tag t and an index i,
--   picking out the ith script of type t in the transaction.
data RedeemerPtr
RedeemerPtr :: ScriptTag -> Integer -> RedeemerPtr
type Redeemers = Map RedeemerPtr Redeemer

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | The datum attached to an output: either nothing; a datum hash; or the
--   datum itself (an "inline datum").
data OutputDatum
NoOutputDatum :: OutputDatum
OutputDatumHash :: DatumHash -> OutputDatum
OutputDatum :: Datum -> OutputDatum

-- | Whether the output is a pay-to-pubkey output.
isPubKeyOut :: TxOut -> Bool

-- | Whether the output is a pay-to-script output.
isPayToScriptOut :: TxOut -> Bool

-- | The address of a transaction output.
outAddress :: Lens' TxOut Address

-- | The value of a transaction output. | TODO: Compute address again
outValue :: Lens' TxOut Value

-- | The public key attached to a <a>TxOut</a>, if there is one.
txOutPubKey :: TxOut -> Maybe PubKeyHash

-- | The datum attached to a <a>TxOut</a>.
outDatum :: Lens' TxOut OutputDatum

-- | The reference script attached to a <a>TxOut</a>.
outReferenceScript :: Lens' TxOut (Maybe ScriptHash)

-- | Create a transaction output locked by a public key.
pubKeyHashTxOut :: Value -> PubKeyHash -> TxOut

-- | The type of a transaction input.
data TxInType

-- | A transaction input that consumes a script address with the given
--   validator, redeemer, and datum.
ConsumeScriptAddress :: !Validator -> !Redeemer -> !Datum -> TxInType

-- | A transaction input that consumes a public key address.
ConsumePublicKeyAddress :: TxInType

-- | Consume a simple script
ConsumeSimpleScriptAddress :: TxInType

-- | A transaction input, consisting of a transaction output reference and
--   an input type.
data TxIn
TxIn :: !TxOutRef -> Maybe TxInType -> TxIn
[txInRef] :: TxIn -> !TxOutRef
[txInType] :: TxIn -> Maybe TxInType

-- | The <a>TxOutRef</a> spent by a transaction input.
inRef :: Lens' TxIn TxOutRef

-- | The type of a transaction input.
inType :: Lens' TxIn (Maybe TxInType)

-- | Validator, redeemer, and data scripts of a transaction input that
--   spends a "pay to script" output.
inScripts :: TxIn -> Maybe (Validator, Redeemer, Datum)

-- | A transaction input that spends a "pay to public key" output, given
--   the witness.
pubKeyTxIn :: TxOutRef -> TxIn

-- | A transaction input that spends a "pay to script" output, given
--   witnesses.
scriptTxIn :: TxOutRef -> Validator -> Redeemer -> Datum -> TxIn

-- | Filter to get only the pubkey inputs.
pubKeyTxIns :: Fold (Set TxIn) TxIn

-- | Filter to get only the script inputs.
scriptTxIns :: Fold (Set TxIn) TxIn
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V2.Ledger.Tx.TxOut
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V2.Ledger.Tx.TxOut
instance PlutusTx.IsData.Class.ToData Plutus.V2.Ledger.Tx.TxOut
instance PlutusTx.IsData.Class.FromData Plutus.V2.Ledger.Tx.TxOut
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V2.Ledger.Tx.TxOut
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V2.Ledger.Tx.OutputDatum
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V2.Ledger.Tx.OutputDatum
instance PlutusTx.IsData.Class.ToData Plutus.V2.Ledger.Tx.OutputDatum
instance PlutusTx.IsData.Class.FromData Plutus.V2.Ledger.Tx.OutputDatum
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V2.Ledger.Tx.OutputDatum
instance Control.DeepSeq.NFData Plutus.V2.Ledger.Tx.OutputDatum
instance GHC.Generics.Generic Plutus.V2.Ledger.Tx.OutputDatum
instance GHC.Classes.Eq Plutus.V2.Ledger.Tx.OutputDatum
instance GHC.Show.Show Plutus.V2.Ledger.Tx.OutputDatum
instance Control.DeepSeq.NFData Plutus.V2.Ledger.Tx.TxOut
instance GHC.Generics.Generic Plutus.V2.Ledger.Tx.TxOut
instance GHC.Classes.Eq Plutus.V2.Ledger.Tx.TxOut
instance GHC.Show.Show Plutus.V2.Ledger.Tx.TxOut
instance Prettyprinter.Internal.Pretty Plutus.V2.Ledger.Tx.TxOut
instance PlutusTx.Eq.Eq Plutus.V2.Ledger.Tx.TxOut
instance PlutusTx.Eq.Eq Plutus.V2.Ledger.Tx.OutputDatum
instance Prettyprinter.Internal.Pretty Plutus.V2.Ledger.Tx.OutputDatum

module Plutus.V1.Ledger.Contexts

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo

-- | Transaction inputs
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]

-- | Hash of the pending transaction (excluding witnesses)
[txInfoId] :: TxInfo -> TxId
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext
[scriptContextTxInfo] :: ScriptContext -> TxInfo
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | A transaction ID, using a SHA256 hash as the transaction id.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A transaction output, consisting of a target address, a value, and
--   optionally a datum hash.
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Finds all the outputs that pay to the same script address that we are
--   currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | Get the public key hash that locks the transaction output, if any.
pubKeyOutput :: TxOut -> Maybe PubKeyHash

-- | Get the list of <a>TxOut</a> outputs of the pending transaction at a
--   given script address.
scriptOutputsAt :: ValidatorHash -> TxInfo -> [(DatumHash, Value)]

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value locked by the given validator in this transaction.
valueLockedBy :: TxInfo -> ValidatorHash -> Value

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> PubKeyHash -> Value

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol

-- | Get the validator and datum hashes of the output that is curently
--   being validated
ownHashes :: ScriptContext -> (ValidatorHash, DatumHash)

-- | Get the hash of the validator script that is currently being
--   validated.
ownHash :: ScriptContext -> ValidatorHash

-- | Convert a <a>CurrencySymbol</a> to a <a>ValidatorHash</a>
fromSymbol :: CurrencySymbol -> ValidatorHash
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Contexts.ScriptContext
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Contexts.ScriptContext
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.ScriptContext
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Contexts.TxInfo
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Contexts.TxInfo
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Contexts.TxInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.TxInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.TxInfo
instance PlutusTx.IsData.Class.ToData Plutus.V1.Ledger.Contexts.TxInInfo
instance PlutusTx.IsData.Class.FromData Plutus.V1.Ledger.Contexts.TxInInfo
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V1.Ledger.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.TxInInfo
instance GHC.Classes.Eq Plutus.V1.Ledger.Contexts.TxInInfo
instance GHC.Show.Show Plutus.V1.Ledger.Contexts.TxInInfo
instance GHC.Generics.Generic Plutus.V1.Ledger.Contexts.TxInInfo
instance GHC.Classes.Eq Plutus.V1.Ledger.Contexts.ScriptPurpose
instance GHC.Show.Show Plutus.V1.Ledger.Contexts.ScriptPurpose
instance GHC.Generics.Generic Plutus.V1.Ledger.Contexts.ScriptPurpose
instance GHC.Classes.Eq Plutus.V1.Ledger.Contexts.TxInfo
instance GHC.Show.Show Plutus.V1.Ledger.Contexts.TxInfo
instance GHC.Generics.Generic Plutus.V1.Ledger.Contexts.TxInfo
instance GHC.Show.Show Plutus.V1.Ledger.Contexts.ScriptContext
instance GHC.Classes.Eq Plutus.V1.Ledger.Contexts.ScriptContext
instance GHC.Generics.Generic Plutus.V1.Ledger.Contexts.ScriptContext
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Contexts.ScriptContext
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Contexts.ScriptContext
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Contexts.TxInfo
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Contexts.TxInfo
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Contexts.ScriptPurpose
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Contexts.ScriptPurpose
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Contexts.TxInInfo

module Plutus.V2.Ledger.Contexts

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> Map StakingCredential Integer -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> TxInfo

-- | Transaction inputs
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction reference inputs
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> Map StakingCredential Integer

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer
[txInfoData] :: TxInfo -> Map DatumHash Datum

-- | Hash of the pending transaction (excluding witnesses)
[txInfoId] :: TxInfo -> TxId
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext
[scriptContextTxInfo] :: ScriptContext -> TxInfo
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Find the indices of all the outputs that pay to the same script
--   address we are currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]

-- | Get all the outputs that pay to the same script address we are
--   currently spending from, if any.
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | Get the public key hash that locks the transaction output, if any.
pubKeyOutput :: TxOut -> Maybe PubKeyHash

-- | Get the list of <a>TxOut</a> outputs of the pending transaction at a
--   given script address.
scriptOutputsAt :: ValidatorHash -> TxInfo -> [(OutputDatum, Value)]

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value locked by the given validator in this transaction.
valueLockedBy :: TxInfo -> ValidatorHash -> Value

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> PubKeyHash -> Value

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol

-- | Get the validator and datum hashes of the output that is curently
--   being validated
ownHashes :: ScriptContext -> (ValidatorHash, OutputDatum)

-- | Get the hash of the validator script that is currently being
--   validated.
ownHash :: ScriptContext -> ValidatorHash

-- | Convert a <a>CurrencySymbol</a> to a <a>ValidatorHash</a>
fromSymbol :: CurrencySymbol -> ValidatorHash
instance PlutusTx.IsData.Class.ToData Plutus.V2.Ledger.Contexts.ScriptContext
instance PlutusTx.IsData.Class.FromData Plutus.V2.Ledger.Contexts.ScriptContext
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V2.Ledger.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V2.Ledger.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V2.Ledger.Contexts.ScriptContext
instance PlutusTx.IsData.Class.ToData Plutus.V2.Ledger.Contexts.TxInfo
instance PlutusTx.IsData.Class.FromData Plutus.V2.Ledger.Contexts.TxInfo
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V2.Ledger.Contexts.TxInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V2.Ledger.Contexts.TxInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V2.Ledger.Contexts.TxInfo
instance PlutusTx.IsData.Class.ToData Plutus.V2.Ledger.Contexts.TxInInfo
instance PlutusTx.IsData.Class.FromData Plutus.V2.Ledger.Contexts.TxInInfo
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.V2.Ledger.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V2.Ledger.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V2.Ledger.Contexts.TxInInfo
instance GHC.Classes.Eq Plutus.V2.Ledger.Contexts.TxInInfo
instance GHC.Show.Show Plutus.V2.Ledger.Contexts.TxInInfo
instance GHC.Generics.Generic Plutus.V2.Ledger.Contexts.TxInInfo
instance GHC.Classes.Eq Plutus.V2.Ledger.Contexts.TxInfo
instance GHC.Show.Show Plutus.V2.Ledger.Contexts.TxInfo
instance GHC.Generics.Generic Plutus.V2.Ledger.Contexts.TxInfo
instance GHC.Show.Show Plutus.V2.Ledger.Contexts.ScriptContext
instance GHC.Classes.Eq Plutus.V2.Ledger.Contexts.ScriptContext
instance GHC.Generics.Generic Plutus.V2.Ledger.Contexts.ScriptContext
instance PlutusTx.Eq.Eq Plutus.V2.Ledger.Contexts.ScriptContext
instance Prettyprinter.Internal.Pretty Plutus.V2.Ledger.Contexts.ScriptContext
instance PlutusTx.Eq.Eq Plutus.V2.Ledger.Contexts.TxInfo
instance Prettyprinter.Internal.Pretty Plutus.V2.Ledger.Contexts.TxInfo
instance PlutusTx.Eq.Eq Plutus.V2.Ledger.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty Plutus.V2.Ledger.Contexts.TxInInfo


-- | The interface to Plutus V1 for the ledger.
module Plutus.V1.Ledger.Api

-- | Scripts to the ledger are serialised bytestrings.
type SerializedScript = ShortByteString

-- | A script on the chain. This is an opaque type as far as the chain is
--   concerned.
data Script

-- | Turn a <a>CompiledCode</a> (usually produced by <tt>compile</tt>) into
--   a <a>Script</a> for use with this package.
fromCompiledCode :: CompiledCode a -> Script

-- | Check if a <a>Script</a> is "valid" according to a protocol version.
--   At the moment this means "deserialises correctly", which in particular
--   implies that it is (almost certainly) an encoded script and the script
--   does not mention any builtins unavailable in the given protocol
--   version.
isScriptWellFormed :: ProtocolVersion -> SerializedScript -> Bool

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
evaluateScriptRestricting :: ProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> SerializedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. This will take as long as the script
--   takes, if you need to limit the execution time of the script also, you
--   can use <a>evaluateScriptRestricting</a>, which also returns the used
--   budget.
evaluateScriptCounting :: ProtocolVersion -> VerboseMode -> EvaluationContext -> SerializedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | This represents the Cardano protocol version, with its major and minor
--   components. This relies on careful understanding between us and the
--   ledger as to what this means.
data ProtocolVersion
ProtocolVersion :: Int -> Int -> ProtocolVersion
[pvMajor] :: ProtocolVersion -> Int
[pvMinor] :: ProtocolVersion -> Int

-- | A simple toggle indicating whether or not we should produce logs.
data VerboseMode
Verbose :: VerboseMode
Quiet :: VerboseMode

-- | The type of log output: just a list of <a>Text</a>.
type LogOutput = [Text]
data ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory

-- | Counts CPU units in picoseconds: maximum value for SatInt is 2^63 ps,
--   or appproximately 106 days.
newtype ExCPU
ExCPU :: CostingInteger -> ExCPU

-- | Counts size in machine words.
newtype ExMemory
ExMemory :: CostingInteger -> ExMemory
data SatInt

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than recomputed on every evaluation.
--   
--   There are two sets of parameters: one is with immediate unlifting and
--   the other one is with deferred unlifting. We have to keep both of
--   them, because depending on the language version either one has to be
--   used or the other. We also compile them separately due to all the
--   inlining and optimization that need to happen for things to be
--   efficient.
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a <a>Map</a> of strings to cost integer values (aka
--   <a>CostModelParams</a>, <a>CostModel</a>) See Note [Inlining meanings
--   of builtins].
mkEvaluationContext :: MonadError CostModelApplyError m => CostModelParams -> m EvaluationContext

-- | The type of errors that <a>applyParams</a> can throw.
data CostModelApplyError

-- | a costmodel parameter with the give name does not exist in the
--   costmodel to be applied upon
CMUnknownParamError :: Text -> CostModelApplyError

-- | internal error when we are transforming the applyParams' input to json
--   (should not happen)
CMInternalReadError :: CostModelApplyError

-- | internal error when we are transforming the applied params from json
--   with given jsonstring error (should not happen)
CMInternalWriteError :: String -> CostModelApplyError
type CostModelParams = Map Text Integer

-- | Comparably expensive to <a>mkEvaluationContext</a>, so it should only
--   be used sparingly.
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | The set of valid names that a cost model parameter can take for this
--   language version. It is used for the deserialization of
--   <a>CostModelParams</a>.
costModelParamNames :: Set Text
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext
[scriptContextTxInfo] :: ScriptContext -> TxInfo
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | An opaque type representing Plutus Core ByteStrings.
data BuiltinByteString
toBuiltin :: ToBuiltin a arep => a -> arep
fromBuiltin :: FromBuiltin arep a => arep -> a
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString
fromBytes :: ByteString -> LedgerBytes

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retiremant certificate and the Epoch N
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert

-- | Staking credential used to assign rewards
data StakingCredential
StakingHash :: Credential -> StakingCredential
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credential required to unlock a transaction output
data Credential

-- | The transaction that spends this output must be signed by the private
--   key
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator.
ScriptCredential :: ValidatorHash -> Credential

-- | A cryptocurrency value. This is a map from <a>CurrencySymbol</a>s to a
--   quantity of that currency.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   See note [Currencies] for more details.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | ByteString of a name of a token, shown as UTF-8 string when possible
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName

-- | POSIX time is measured as the number of milliseconds since
--   1970-01-01T00:00:00Z
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | Address with two kinds of credentials, normal and staking.
data Address
Address :: Credential -> Maybe StakingCredential -> Address
[addressCredential] :: Address -> Credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | A transaction ID, using a SHA256 hash as the transaction id.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo

-- | Transaction inputs
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]

-- | Hash of the pending transaction (excluding witnesses)
[txInfoId] :: TxInfo -> TxId

-- | A transaction output, consisting of a target address, a value, and
--   optionally a datum hash.
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | An <a>Interval</a> that covers every slot.
always :: Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>.
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>.
to :: a -> Interval a
lowerBound :: a -> LowerBound a
upperBound :: a -> UpperBound a
strictLowerBound :: a -> LowerBound a
strictUpperBound :: a -> UpperBound a

-- | <a>Validator</a> is a wrapper around <a>Script</a>s which are used as
--   validators in transaction outputs.
newtype Validator
Validator :: Script -> Validator
[getValidator] :: Validator -> Script
mkValidatorScript :: CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ()) -> Validator
unValidatorScript :: Validator -> Script

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ValidatorHash
ValidatorHash :: BuiltinByteString -> ValidatorHash

-- | <a>MintingPolicy</a> is a wrapper around <a>Script</a>s which are used
--   as validators for minting constraints.
newtype MintingPolicy
MintingPolicy :: Script -> MintingPolicy
[getMintingPolicy] :: MintingPolicy -> Script
mkMintingPolicyScript :: CompiledCode (BuiltinData -> BuiltinData -> ()) -> MintingPolicy
unMintingPolicyScript :: MintingPolicy -> Script

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype MintingPolicyHash
MintingPolicyHash :: BuiltinByteString -> MintingPolicyHash

-- | <a>StakeValidator</a> is a wrapper around <a>Script</a>s which are
--   used as validators for withdrawals and stake address certificates.
newtype StakeValidator
StakeValidator :: Script -> StakeValidator
[getStakeValidator] :: StakeValidator -> Script
mkStakeValidatorScript :: CompiledCode (BuiltinData -> BuiltinData -> ()) -> StakeValidator
unStakeValidatorScript :: StakeValidator -> Script

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype StakeValidatorHash
StakeValidatorHash :: BuiltinByteString -> StakeValidatorHash

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash

-- | A generic "data" type.
--   
--   The main constructor <a>Constr</a> represents a datatype value in
--   sum-of-products form: <tt>Constr i args</tt> represents a use of the
--   <tt>i</tt>th constructor along with its arguments.
--   
--   The other constructors are various primitives.
data Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data

-- | A type corresponding to the Plutus Core builtin equivalent of
--   <a>Data</a>.
--   
--   The point of this type is to be an opaque equivalent of <a>Data</a>,
--   so as to ensure that it is only used in ways that the compiler can
--   handle.
--   
--   As such, you should use this type in your on-chain code, and in any
--   data structures that you want to be representable on-chain.
--   
--   For off-chain usage, there are conversion functions
--   <a>builtinDataToData</a> and <a>dataToBuiltinData</a>, but note that
--   these will not work on-chain.
data BuiltinData
BuiltinData :: Data -> BuiltinData

-- | A typeclass for types that can be converted to and from
--   <a>BuiltinData</a>.
class ToData a

-- | Convert a value to <a>BuiltinData</a>.
toBuiltinData :: ToData a => a -> BuiltinData
class FromData a

-- | Convert a value from <a>BuiltinData</a>, returning <a>Nothing</a> if
--   this fails.
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class UnsafeFromData a

-- | Convert a value from <a>BuiltinData</a>, calling <a>error</a> if this
--   fails. This is typically much faster than <a>fromBuiltinData</a>.
--   
--   When implementing this function, make sure to call
--   <a>unsafeFromBuiltinData</a> rather than <a>fromBuiltinData</a> when
--   converting substructures!
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a

-- | Convert a value to <a>Data</a>.
toData :: ToData a => a -> Data

-- | Convert a value from <a>Data</a>, returning <a>Nothing</a> if this
--   fails.
fromData :: FromData a => Data -> Maybe a

-- | Convert a <a>Data</a> into a <a>BuiltinData</a>. Only works off-chain.
dataToBuiltinData :: Data -> BuiltinData

-- | Convert a <a>BuiltinData</a> into a <a>Data</a>. Only works off-chain.
builtinDataToData :: BuiltinData -> Data

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: FreeVariableError -> EvaluationError

-- | A serialisation error
CodecError :: DeserialiseFailure -> EvaluationError

-- | An error indicating a version tag that we don't support TODO: make
--   this error more informative when we have more information about what
--   went wrong
IncompatibleVersionError :: Version () -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError


-- | The interface to Plutus V2 for the ledger.
module Plutus.V2.Ledger.Api

-- | Scripts to the ledger are serialised bytestrings.
type SerializedScript = ShortByteString

-- | A script on the chain. This is an opaque type as far as the chain is
--   concerned.
data Script

-- | Turn a <a>CompiledCode</a> (usually produced by <tt>compile</tt>) into
--   a <a>Script</a> for use with this package.
fromCompiledCode :: CompiledCode a -> Script

-- | Check if a <a>Script</a> is "valid" according to a protocol version.
--   At the moment this means "deserialises correctly", which in particular
--   implies that it is (almost certainly) an encoded script and the script
--   does not mention any builtins unavailable in the given protocol
--   version.
isScriptWellFormed :: ProtocolVersion -> SerializedScript -> Bool

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
evaluateScriptRestricting :: ProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> SerializedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. This will take as long as the script
--   takes, if you need to limit the execution time of the script also, you
--   can use <a>evaluateScriptRestricting</a>, which also returns the used
--   budget.
evaluateScriptCounting :: ProtocolVersion -> VerboseMode -> EvaluationContext -> SerializedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | This represents the Cardano protocol version, with its major and minor
--   components. This relies on careful understanding between us and the
--   ledger as to what this means.
data ProtocolVersion
ProtocolVersion :: Int -> Int -> ProtocolVersion
[pvMajor] :: ProtocolVersion -> Int
[pvMinor] :: ProtocolVersion -> Int

-- | A simple toggle indicating whether or not we should produce logs.
data VerboseMode
Verbose :: VerboseMode
Quiet :: VerboseMode

-- | The type of log output: just a list of <a>Text</a>.
type LogOutput = [Text]
data ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory

-- | Counts CPU units in picoseconds: maximum value for SatInt is 2^63 ps,
--   or appproximately 106 days.
newtype ExCPU
ExCPU :: CostingInteger -> ExCPU

-- | Counts size in machine words.
newtype ExMemory
ExMemory :: CostingInteger -> ExMemory
data SatInt

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than recomputed on every evaluation.
--   
--   There are two sets of parameters: one is with immediate unlifting and
--   the other one is with deferred unlifting. We have to keep both of
--   them, because depending on the language version either one has to be
--   used or the other. We also compile them separately due to all the
--   inlining and optimization that need to happen for things to be
--   efficient.
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a <a>Map</a> of strings to cost integer values (aka
--   <a>CostModelParams</a>, <a>CostModel</a>) See Note [Inlining meanings
--   of builtins].
mkEvaluationContext :: MonadError CostModelApplyError m => CostModelParams -> m EvaluationContext

-- | The type of errors that <a>applyParams</a> can throw.
data CostModelApplyError

-- | a costmodel parameter with the give name does not exist in the
--   costmodel to be applied upon
CMUnknownParamError :: Text -> CostModelApplyError

-- | internal error when we are transforming the applyParams' input to json
--   (should not happen)
CMInternalReadError :: CostModelApplyError

-- | internal error when we are transforming the applied params from json
--   with given jsonstring error (should not happen)
CMInternalWriteError :: String -> CostModelApplyError
type CostModelParams = Map Text Integer

-- | Comparably expensive to <a>mkEvaluationContext</a>, so it should only
--   be used sparingly.
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | The set of valid names that a cost model parameter can take for this
--   language version. It is used for the deserialization of
--   <a>CostModelParams</a>.
costModelParamNames :: Set Text
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext
[scriptContextTxInfo] :: ScriptContext -> TxInfo
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | An opaque type representing Plutus Core ByteStrings.
data BuiltinByteString
toBuiltin :: ToBuiltin a arep => a -> arep
fromBuiltin :: FromBuiltin arep a => arep -> a
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString
fromBytes :: ByteString -> LedgerBytes

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retiremant certificate and the Epoch N
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert

-- | Staking credential used to assign rewards
data StakingCredential
StakingHash :: Credential -> StakingCredential
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credential required to unlock a transaction output
data Credential

-- | The transaction that spends this output must be signed by the private
--   key
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator.
ScriptCredential :: ValidatorHash -> Credential

-- | A cryptocurrency value. This is a map from <a>CurrencySymbol</a>s to a
--   quantity of that currency.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   See note [Currencies] for more details.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | ByteString of a name of a token, shown as UTF-8 string when possible
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName

-- | POSIX time is measured as the number of milliseconds since
--   1970-01-01T00:00:00Z
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | Address with two kinds of credentials, normal and staking.
data Address
Address :: Credential -> Maybe StakingCredential -> Address
[addressCredential] :: Address -> Credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | A transaction ID, using a SHA256 hash as the transaction id.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> Map StakingCredential Integer -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> TxInfo

-- | Transaction inputs
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction reference inputs
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> Map StakingCredential Integer

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer
[txInfoData] :: TxInfo -> Map DatumHash Datum

-- | Hash of the pending transaction (excluding witnesses)
[txInfoId] :: TxInfo -> TxId

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | The datum attached to an output: either nothing; a datum hash; or the
--   datum itself (an "inline datum").
data OutputDatum
NoOutputDatum :: OutputDatum
OutputDatumHash :: DatumHash -> OutputDatum
OutputDatum :: Datum -> OutputDatum

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | An <a>Interval</a> that covers every slot.
always :: Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>.
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>.
to :: a -> Interval a
lowerBound :: a -> LowerBound a
upperBound :: a -> UpperBound a
strictLowerBound :: a -> LowerBound a
strictUpperBound :: a -> UpperBound a

-- | A <a>Map</a> of key-value pairs.
data Map k v
fromList :: [(k, v)] -> Map k v

-- | <a>Validator</a> is a wrapper around <a>Script</a>s which are used as
--   validators in transaction outputs.
newtype Validator
Validator :: Script -> Validator
[getValidator] :: Validator -> Script
mkValidatorScript :: CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ()) -> Validator
unValidatorScript :: Validator -> Script

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ValidatorHash
ValidatorHash :: BuiltinByteString -> ValidatorHash

-- | <a>MintingPolicy</a> is a wrapper around <a>Script</a>s which are used
--   as validators for minting constraints.
newtype MintingPolicy
MintingPolicy :: Script -> MintingPolicy
[getMintingPolicy] :: MintingPolicy -> Script
mkMintingPolicyScript :: CompiledCode (BuiltinData -> BuiltinData -> ()) -> MintingPolicy
unMintingPolicyScript :: MintingPolicy -> Script

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype MintingPolicyHash
MintingPolicyHash :: BuiltinByteString -> MintingPolicyHash

-- | <a>StakeValidator</a> is a wrapper around <a>Script</a>s which are
--   used as validators for withdrawals and stake address certificates.
newtype StakeValidator
StakeValidator :: Script -> StakeValidator
[getStakeValidator] :: StakeValidator -> Script
mkStakeValidatorScript :: CompiledCode (BuiltinData -> BuiltinData -> ()) -> StakeValidator
unStakeValidatorScript :: StakeValidator -> Script

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype StakeValidatorHash
StakeValidatorHash :: BuiltinByteString -> StakeValidatorHash

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString

-- | A generic "data" type.
--   
--   The main constructor <a>Constr</a> represents a datatype value in
--   sum-of-products form: <tt>Constr i args</tt> represents a use of the
--   <tt>i</tt>th constructor along with its arguments.
--   
--   The other constructors are various primitives.
data Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data

-- | A type corresponding to the Plutus Core builtin equivalent of
--   <a>Data</a>.
--   
--   The point of this type is to be an opaque equivalent of <a>Data</a>,
--   so as to ensure that it is only used in ways that the compiler can
--   handle.
--   
--   As such, you should use this type in your on-chain code, and in any
--   data structures that you want to be representable on-chain.
--   
--   For off-chain usage, there are conversion functions
--   <a>builtinDataToData</a> and <a>dataToBuiltinData</a>, but note that
--   these will not work on-chain.
data BuiltinData
BuiltinData :: Data -> BuiltinData

-- | A typeclass for types that can be converted to and from
--   <a>BuiltinData</a>.
class ToData a

-- | Convert a value to <a>BuiltinData</a>.
toBuiltinData :: ToData a => a -> BuiltinData
class FromData a

-- | Convert a value from <a>BuiltinData</a>, returning <a>Nothing</a> if
--   this fails.
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class UnsafeFromData a

-- | Convert a value from <a>BuiltinData</a>, calling <a>error</a> if this
--   fails. This is typically much faster than <a>fromBuiltinData</a>.
--   
--   When implementing this function, make sure to call
--   <a>unsafeFromBuiltinData</a> rather than <a>fromBuiltinData</a> when
--   converting substructures!
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a

-- | Convert a value to <a>Data</a>.
toData :: ToData a => a -> Data

-- | Convert a value from <a>Data</a>, returning <a>Nothing</a> if this
--   fails.
fromData :: FromData a => Data -> Maybe a

-- | Convert a <a>Data</a> into a <a>BuiltinData</a>. Only works off-chain.
dataToBuiltinData :: Data -> BuiltinData

-- | Convert a <a>BuiltinData</a> into a <a>Data</a>. Only works off-chain.
builtinDataToData :: BuiltinData -> Data

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: FreeVariableError -> EvaluationError

-- | A serialisation error
CodecError :: DeserialiseFailure -> EvaluationError

-- | An error indicating a version tag that we don't support TODO: make
--   this error more informative when we have more information about what
--   went wrong
IncompatibleVersionError :: Version () -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError


-- | This module contains example values to be used for testing. These
--   should NOT be used in non-test code!
module Plutus.V1.Ledger.Examples

-- | Creates a script which has N arguments, and always succeeds.
alwaysSucceedingNAryFunction :: Natural -> SerializedScript

-- | Creates a script which has N arguments, and always fails.
alwaysFailingNAryFunction :: Natural -> SerializedScript
summingFunction :: SerializedScript

-- | Wrap a script with lambda/app so that, for instance, it has a
--   different hash but the same behavior.
saltFunction :: Integer -> SerializedScript -> SerializedScript

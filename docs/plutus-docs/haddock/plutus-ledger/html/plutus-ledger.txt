-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Wallet API
--   
--   Plutus ledger library
@package plutus-ledger
@version 1.1.0.0


-- | Encoding and decoding of <tt>ByteString</tt> and serialisable values
--   as base16 encoded JSON strings
module Data.Aeson.Extras
encodeByteString :: ByteString -> Text
decodeByteString :: Value -> Parser ByteString
encodeSerialise :: Serialise a => a -> Text
decodeSerialise :: Serialise a => Value -> Parser a
tryDecode :: Text -> Either String ByteString

-- | Newtype for deriving <tt>ToJSON</tt> and <tt>FromJSON</tt> for types
--   that have a <a>Serialise</a> instance by just encoding the serialized
--   bytes as a JSON string.
newtype JSONViaSerialise a
JSONViaSerialise :: a -> JSONViaSerialise a
instance Codec.Serialise.Class.Serialise a => Data.Aeson.Types.ToJSON.ToJSON (Data.Aeson.Extras.JSONViaSerialise a)
instance Codec.Serialise.Class.Serialise a => Data.Aeson.Types.FromJSON.FromJSON (Data.Aeson.Extras.JSONViaSerialise a)

module Data.Time.Units.Extra
instance Data.Aeson.Types.FromJSON.FromJSON Data.Time.Units.Second
instance Data.Aeson.Types.ToJSON.ToJSON Data.Time.Units.Second
instance Data.Aeson.Types.FromJSON.FromJSON Data.Time.Units.Millisecond
instance Data.Aeson.Types.ToJSON.ToJSON Data.Time.Units.Millisecond


-- | Functions for working with <a>Ada</a> in Template Haskell.
module Ledger.Ada

-- | ADA, the special currency on the Cardano blockchain. The unit of Ada
--   is Lovelace, and 1M Lovelace is one Ada. See note [Currencies] in
--   <a>TH</a>.
newtype Ada
Lovelace :: Integer -> Ada
[getLovelace] :: Ada -> Integer

-- | Get the amount of Ada (the unit of the currency Ada) in this
--   <a>Ada</a> value.
getAda :: Ada -> Micro

-- | The <a>CurrencySymbol</a> of the <a>Ada</a> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <a>Ada</a> currency.
adaToken :: TokenName

-- | Get the <a>Ada</a> in the given <a>Value</a>.
fromValue :: Value -> Ada

-- | Create a <a>Value</a> containing only the given <a>Ada</a>.
toValue :: Ada -> Value

-- | Create <a>Ada</a> representing the given quantity of Lovelace (the
--   unit of the currency Ada).
lovelaceOf :: Integer -> Ada

-- | Create <a>Ada</a> representing the given quantity of Ada (1M
--   Lovelace).
adaOf :: Micro -> Ada

-- | A <a>Value</a> with the given amount of Lovelace (the currency unit).
--   
--   <pre>
--   lovelaceValueOf == toValue . lovelaceOf
--   </pre>
lovelaceValueOf :: Integer -> Value

-- | A <a>Value</a> with the given amount of Ada (the currency unit).
--   
--   <pre>
--   adaValueOf == toValue . adaOf
--   </pre>
adaValueOf :: Micro -> Value

-- | Divide one <a>Ada</a> value by another.
divide :: Ada -> Ada -> Ada

-- | Check whether an <a>Ada</a> value is zero.
isZero :: Ada -> Bool
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Ada.Ada
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Ada.Ada
instance Prettyprinter.Internal.Pretty Ledger.Ada.Ada
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Ada.Ada
instance PlutusTx.IsData.Class.FromData Ledger.Ada.Ada
instance PlutusTx.IsData.Class.ToData Ledger.Ada.Ada
instance Codec.Serialise.Class.Serialise Ledger.Ada.Ada
instance GHC.Real.Real Ledger.Ada.Ada
instance GHC.Real.Integral Ledger.Ada.Ada
instance PlutusTx.Numeric.MultiplicativeMonoid Ledger.Ada.Ada
instance PlutusTx.Numeric.MultiplicativeSemigroup Ledger.Ada.Ada
instance PlutusTx.Numeric.AdditiveGroup Ledger.Ada.Ada
instance PlutusTx.Numeric.AdditiveMonoid Ledger.Ada.Ada
instance PlutusTx.Numeric.AdditiveSemigroup Ledger.Ada.Ada
instance GHC.Num.Num Ledger.Ada.Ada
instance PlutusTx.Ord.Ord Ledger.Ada.Ada
instance PlutusTx.Eq.Eq Ledger.Ada.Ada
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Ada.Ada
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Ada.Ada
instance GHC.Generics.Generic Ledger.Ada.Ada
instance GHC.Show.Show Ledger.Ada.Ada
instance GHC.Classes.Ord Ledger.Ada.Ada
instance GHC.Classes.Eq Ledger.Ada.Ada
instance GHC.Enum.Enum Ledger.Ada.Ada
instance GHC.Base.Semigroup Ledger.Ada.Ada
instance PlutusTx.Semigroup.Semigroup Ledger.Ada.Ada
instance GHC.Base.Monoid Ledger.Ada.Ada
instance PlutusTx.Monoid.Monoid Ledger.Ada.Ada

module Ledger.Builtins.Orphans
instance GHC.Generics.Generic PlutusTx.Builtins.Internal.BuiltinData
instance Data.OpenApi.Internal.Schema.ToSchema PlutusTx.Builtins.Internal.BuiltinData
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Data.Data
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Data.Data
instance Data.OpenApi.Internal.Schema.ToSchema PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Builtins.Internal.BuiltinData
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Builtins.Internal.BuiltinData
instance Codec.Serialise.Class.Serialise PlutusTx.Builtins.Internal.BuiltinData
instance Data.OpenApi.Internal.Schema.ToSchema PlutusCore.Data.Data

module Ledger.Contexts.Orphans
instance GHC.Classes.Ord Plutus.V1.Ledger.Contexts.ScriptPurpose

module Ledger.Crypto.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Crypto.PubKeyHash
instance Control.Newtype.Generics.Newtype Plutus.V1.Ledger.Crypto.PubKeyHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Crypto.PubKeyHash

module Ledger.Scripts.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.DatumHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.DatumHash
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.RedeemerHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.ScriptHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.ScriptHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.ScriptHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.ScriptHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.ScriptHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.ScriptHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.ValidatorHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Context
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Context
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.StakeValidator
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.StakeValidator
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.MintingPolicy
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.MintingPolicy
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Validator
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Validator
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Redeemer
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Redeemer
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.Redeemer
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Datum
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Datum
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.Datum
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Scripts.Datum
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Script
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Script

module Ledger.Scripts

-- | An example Plutus script that always succeeds, irrespective of inputs.
--   
--   For example, if one were to use this for a payment address then it
--   would allow anyone to spend from it.
--   
--   The exact script depends on the context in which it is to be used.
examplePlutusScriptAlwaysSucceeds :: WitCtx witctx -> PlutusScript PlutusScriptV1

-- | An example Plutus script that always fails, irrespective of inputs.
--   
--   For example, if one were to use this for a payment address then it
--   would be impossible for anyone to ever spend from it.
--   
--   The exact script depends on the context in which it is to be used.
examplePlutusScriptAlwaysFails :: WitCtx witctx -> PlutusScript PlutusScriptV1
examplePlutusScriptAlwaysSucceedsHash :: WitCtx ctx -> BuiltinByteString
examplePlutusScriptAlwaysFailsHash :: WitCtx ctx -> BuiltinByteString

-- | This GADT provides a value-level representation of all the witness
--   contexts. This enables pattern matching on the context to allow them
--   to be treated in a non-uniform way.
data WitCtx witctx
[WitCtxTxIn] :: WitCtx WitCtxTxIn
[WitCtxMint] :: WitCtx WitCtxMint
[WitCtxStake] :: WitCtx WitCtxStake

module Ledger.Credential.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Credential.Credential
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Credential.Credential
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Credential.Credential
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Credential.Credential
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Credential.Credential
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Credential.StakingCredential
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Credential.StakingCredential
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Credential.StakingCredential
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Credential.StakingCredential
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Credential.StakingCredential

module Ledger.DCert.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.DCert.DCert
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.DCert.DCert
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.DCert.DCert

module Ledger.Address.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Address.Address
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Address.Address
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Address.Address
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Address.Address


-- | Slots and slot ranges.
module Ledger.Slot

-- | The slot number. This is a good proxy for time, since on the Cardano
--   blockchain slots pass at a constant rate.
newtype Slot
Slot :: Integer -> Slot
[getSlot] :: Slot -> Integer

-- | An <a>Interval</a> of <a>Slot</a>s.
type SlotRange = Interval Slot

-- | Number of <a>Slot</a>s covered by the interval, if finite. <tt>width
--   (from x) == Nothing</tt>.
width :: SlotRange -> Maybe Integer
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Plutus.V1.Ledger.Interval.Interval a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Plutus.V1.Ledger.Interval.Interval a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.V1.Ledger.Interval.Interval a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.V1.Ledger.Interval.Interval a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Plutus.V1.Ledger.Interval.LowerBound a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Plutus.V1.Ledger.Interval.LowerBound a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.V1.Ledger.Interval.LowerBound a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.V1.Ledger.Interval.LowerBound a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Plutus.V1.Ledger.Interval.UpperBound a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Plutus.V1.Ledger.Interval.UpperBound a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.V1.Ledger.Interval.UpperBound a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.V1.Ledger.Interval.UpperBound a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Plutus.V1.Ledger.Interval.Extended a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Plutus.V1.Ledger.Interval.Extended a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.V1.Ledger.Interval.Extended a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.V1.Ledger.Interval.Extended a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Slot.Slot
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Slot.Slot
instance Prettyprinter.Internal.Pretty Ledger.Slot.Slot
instance Data.Hashable.Class.Hashable Ledger.Slot.Slot
instance Codec.Serialise.Class.Serialise Ledger.Slot.Slot
instance GHC.Real.Integral Ledger.Slot.Slot
instance GHC.Real.Real Ledger.Slot.Slot
instance GHC.Enum.Enum Ledger.Slot.Slot
instance GHC.Num.Num Ledger.Slot.Slot
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Slot.Slot
instance PlutusTx.IsData.Class.FromData Ledger.Slot.Slot
instance PlutusTx.IsData.Class.ToData Ledger.Slot.Slot
instance PlutusTx.Enum.Enum Ledger.Slot.Slot
instance PlutusTx.Ord.Ord Ledger.Slot.Slot
instance PlutusTx.Eq.Eq Ledger.Slot.Slot
instance PlutusTx.Numeric.AdditiveGroup Ledger.Slot.Slot
instance PlutusTx.Numeric.AdditiveMonoid Ledger.Slot.Slot
instance PlutusTx.Numeric.AdditiveSemigroup Ledger.Slot.Slot
instance Control.DeepSeq.NFData Ledger.Slot.Slot
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Slot.Slot
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Slot.Slot
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Slot.Slot
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Slot.Slot
instance Data.Data.Data Ledger.Slot.Slot
instance GHC.Generics.Generic Ledger.Slot.Slot
instance GHC.Show.Show Ledger.Slot.Slot
instance GHC.Classes.Ord Ledger.Slot.Slot
instance GHC.Classes.Eq Ledger.Slot.Slot


-- | Dealing with tokens
module Ledger.Tokens

-- | A value that contains exactly the token.
token :: AssetClass -> Value

-- | The outputs of the <tt>ValidatorCtx</tt> that carry a non-zero amount
--   of the currency.
outputsWith :: TxInfo -> AssetClass -> [TxOut]

-- | The total <a>Value</a> paid by the pending transaction to outputs
--   whose value also includes a non-zero amount of the currency.
paidTo :: TxInfo -> AssetClass -> Value


-- | <i>Deprecated: Use Plutus.Script.Utils.V1.Typed.Scripts.Validators
--   instead</i>
module Ledger.Typed.Scripts.Validators


-- | Typed transaction inputs and outputs. This module defines typed
--   versions of various ledger types. The ultimate goal is to make sure
--   that the script types attached to inputs and outputs line up, to avoid
--   type errors at validation time.

-- | <i>Deprecated: Use Plutus.Script.Utils.V1.Typed.Scripts instead</i>
module Ledger.Typed.Tx


-- | <i>Deprecated: Use Plutus.Script.Utils.Typed instead</i>
module Ledger.Typed.TypeUtils

module Ledger.Value

-- | Value without any Ada.
noAdaValue :: Value -> Value

-- | Value without any non-Ada.
adaOnlyValue :: Value -> Value
isAdaOnlyValue :: Value -> Bool

-- | Get the quantities of just the given <a>CurrencySymbol</a> in the
--   <a>Value</a>. This is useful when implementing minting policies as
--   they are responsible for checking all minted/burnt tokens of their own
--   <a>CurrencySymbol</a>.
currencyValueOf :: Value -> CurrencySymbol -> Value

module Ledger.Value.Orphans
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Value.CurrencySymbol
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Value.TokenName
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Value.TokenName
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Value.AssetClass
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Value.AssetClass
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Value.AssetClass
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Value.AssetClass
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Value.Value
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Value.Value
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Value.Value
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Value.Value
instance (Data.Hashable.Class.Hashable k, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (PlutusTx.AssocMap.Map k v)
instance (Codec.Serialise.Class.Serialise k, Codec.Serialise.Class.Serialise v) => Codec.Serialise.Class.Serialise (PlutusTx.AssocMap.Map k v)
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Value.TokenName
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Value.TokenName
instance (Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSON k) => Data.Aeson.Types.ToJSON.ToJSON (PlutusTx.AssocMap.Map k v)
instance (Data.Aeson.Types.FromJSON.FromJSON v, Data.Aeson.Types.FromJSON.FromJSON k) => Data.Aeson.Types.FromJSON.FromJSON (PlutusTx.AssocMap.Map k v)

module Ledger.Tx.Orphans.V2
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V2.Ledger.Tx.OutputDatum
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V2.Ledger.Tx.OutputDatum
instance Codec.Serialise.Class.Serialise Plutus.V2.Ledger.Tx.OutputDatum
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V2.Ledger.Tx.OutputDatum
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V2.Ledger.Tx.TxOut
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V2.Ledger.Tx.TxOut
instance Codec.Serialise.Class.Serialise Plutus.V2.Ledger.Tx.TxOut

module Ledger.Tx.Orphans.V1
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.RedeemerPtr
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.RedeemerPtr
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Tx.RedeemerPtr
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Tx.RedeemerPtr
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.RedeemerPtr
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.ScriptTag
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.ScriptTag
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.ScriptTag
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.TxIn
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.TxIn
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxIn
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.TxOut
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.TxOut
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxOut
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.TxInType
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.TxInType
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxInType
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.TxOutRef
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.TxOutRef
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Tx.TxOutRef
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Tx.TxOutRef
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxOutRef
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.TxId
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.TxId
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Tx.TxId
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Tx.TxId
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxId
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Bytes.LedgerBytes

module Ledger.Tx.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Tx.Tx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Tx.Tx Cardano.Api.Eras.BabbageEra)

module Ledger.Typed.Scripts.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON (Plutus.Script.Utils.Typed.TypedValidator a)
instance Data.Aeson.Types.FromJSON.FromJSON (Plutus.Script.Utils.Typed.TypedValidator a)
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError

module Ledger.Typed.Scripts

-- | Non-Native Script language. This is an Enumerated type. This is
--   expected to be an open type. We will add new Constuctors to this type
--   as additional Non-Native scripting language as are added. We use an
--   enumerated type for two reasons. 1) We can write total functions by
--   case analysis over the constructors 2) We will use DataKinds to make
--   some datatypes indexed by Language For now, the only Non-Native
--   Scriting language is Plutus We might add new languages in the futures.
--   
--   Note that the the serialization of <a>Language</a> depends on the
--   ordering.
data Language
PlutusV1 :: Language
PlutusV2 :: Language

-- | Hash of the minting policy that forwards all checks to the instance's
--   validator
forwardingMintingPolicyHash :: TypedValidator a -> MintingPolicyHash

-- | The minting policy that forwards all checks to the instance's
--   validator
vForwardingMintingPolicy :: TypedValidator a -> Versioned MintingPolicy

-- | The unversioned minting policy that forwards all checks to the
--   instance's validator
forwardingMintingPolicy :: TypedValidator a -> MintingPolicy

-- | Generalise the typed validator to one that works with the
--   <tt>Data</tt> type.
generalise :: TypedValidator a -> TypedValidator Any

-- | The validator script itself.
vValidatorScript :: TypedValidator a -> Versioned Validator

-- | The unversioned validator script itself.
validatorScript :: TypedValidator a -> Validator

-- | The address of the validator.
validatorCardanoAddress :: NetworkId -> TypedValidator a -> AddressInEra BabbageEra

-- | The address of the validator.
validatorAddress :: TypedValidator a -> Address

-- | The hash of the validator.
validatorHash :: TypedValidator a -> ValidatorHash
type UntypedValidator = BuiltinData -> BuiltinData -> BuiltinData -> ()
type UntypedMintingPolicy = BuiltinData -> BuiltinData -> ()
type UntypedStakeValidator = BuiltinData -> BuiltinData -> ()
data Any

-- | The type of the data of this connection type.
type family DatumType a

-- | The type of the redeemers of this connection type.
type family RedeemerType a

-- | A class that associates a type standing for a connection type with two
--   types, the type of the redeemer and the data script for that
--   connection type.
class ValidatorTypes a where {
    
    -- | The type of the redeemers of this connection type.
    type family RedeemerType a;
    
    -- | The type of the data of this connection type.
    type family DatumType a;
    type RedeemerType a = ();
    type DatumType a = ();
}

-- | A typed validator script with its <tt>ValidatorScript</tt> and
--   <tt>Address</tt>.
data TypedValidator a
TypedValidator :: Versioned Validator -> ValidatorHash -> Versioned MintingPolicy -> MintingPolicyHash -> TypedValidator a
[tvValidator] :: TypedValidator a -> Versioned Validator
[tvValidatorHash] :: TypedValidator a -> ValidatorHash
[tvForwardingMPS] :: TypedValidator a -> Versioned MintingPolicy

-- | The hash of the minting policy that checks whether the validator is
--   run in this transaction
[tvForwardingMPSHash] :: TypedValidator a -> MintingPolicyHash
class UnsafeFromData sc => IsScriptContext sc

-- | Converts a custom datum and redeemer from a validator function to an
--   untyped validator function. See Note [Scripts returning Bool].
--   
--   Here's an example of how this function can be used:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V2.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V2.Scripts (mkUntypedValidator)
--   
--   newtype MyCustomDatum = MyCustomDatum Integer
--   PlutusTx.unstableMakeIsData ''MyCustomDatum
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkValidator :: MyCustomDatum -&gt; MyCustomRedeemer -&gt; Plutus.ScriptContext -&gt; Bool
--   mkValidator _ _ _ = True
--   
--   validator :: Plutus.Validator
--   validator = Plutus.mkValidatorScript
--       $$(PlutusTx.compile [|| wrap ||])
--    where
--       wrap = mkUntypedValidator mkValidator
--   </pre>
--   
--   Here's an example using a parameterized validator:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V2.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V2.Scripts (mkUntypedValidator)
--   
--   newtype MyCustomDatum = MyCustomDatum Integer
--   PlutusTx.unstableMakeIsData ''MyCustomDatum
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkValidator :: Int -&gt; MyCustomDatum -&gt; MyCustomRedeemer -&gt; Plutus.ScriptContext -&gt; Bool
--   mkValidator _ _ _ _ = True
--   
--   validator :: Int -&gt; Plutus.Validator
--   validator i = Plutus.mkValidatorScript
--       $$(PlutusTx.compile [|| wrap . mkValidator ||]) <a>applyCode</a> PlutusTx.liftCode i
--    where
--       wrap = mkUntypedValidator
--   </pre>
--   
--   For debugging purpose, it may be of interest to know that in the
--   default implementation, the parameters are decoded in the order they
--   appear (data, redeemer and then script context). A log trace is
--   generated after each successfully decoded parameter. Thus, if a
--   parameter can't be decoded, the culprit is the first parameter in the
--   list that doesn't appear as successfully decoded in the log trace.
mkUntypedValidator :: (IsScriptContext sc, UnsafeFromData d, UnsafeFromData r) => (d -> r -> sc -> Bool) -> UntypedValidator

-- | Converts a custom redeemer from a stake validator function to an
--   untyped stake validator function. See Note [Scripts returning Bool].
--   
--   Here's an example of how this function can be used:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V1.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V1.Scripts (mkUntypedStakeValidator)
--   
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkStakeValidator :: MyCustomRedeemer -&gt; ScriptContext -&gt; Bool
--   mkStakeValidator _ _ = True
--   
--   validator :: Plutus.Validator
--   validator = Plutus.mkStakeValidatorScript
--       $$(PlutusTx.compile [|| wrap ||])
--    where
--       wrap = mkUntypedStakeValidator mkStakeValidator
--   </pre>
--   
--   For debugging purpose, it may be of interest to know that in the
--   default implementation, the parameters are decoded in the order they
--   appear (redeemer and then script context). A log trace is generated
--   after each successfully decoded parameter. Thus, if a parameter can't
--   be decoded, the culprit is the first parameter in the list that
--   doesn't appear as successfully decoded in the log trace.
mkUntypedStakeValidator :: (IsScriptContext sc, UnsafeFromData r) => (r -> sc -> Bool) -> UntypedStakeValidator

-- | Converts a custom redeemer from a minting policy function to an
--   untyped minting policy function. See Note [Scripts returning Bool].
--   
--   Here's an example of how this function can be used:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V1.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V1.Scripts (mkUntypedMintingPolicy)
--   
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkMintingPolicy :: MyCustomRedeemer -&gt; ScriptContext -&gt; Bool
--   mkMintingPolicy _ _ = True
--   
--   validator :: Plutus.Validator
--   validator = Plutus.mkMintingPolicyScript
--       $$(PlutusTx.compile [|| wrap ||])
--    where
--       wrap = mkUntypedMintingPolicy mkMintingPolicy
--   </pre>
--   
--   For debugging purpose, it may be of interest to know that in the
--   default implementation, the parameters are decoded in the order they
--   appear (redeemer and then script context). A log trace is generated
--   after each successfully decoded parameter. Thus, if a parameter can't
--   be decoded, the culprit is the first parameter in the list that
--   doesn't appear as successfully decoded in the log trace.
mkUntypedMintingPolicy :: (IsScriptContext sc, UnsafeFromData r) => (r -> sc -> Bool) -> UntypedMintingPolicy
type ScriptContextV1 = ScriptContext
type ScriptContextV2 = ScriptContext

-- | A script of some kind with its Plutus language version
data Versioned script
Versioned :: script -> Language -> Versioned script
[unversioned] :: Versioned script -> script
[version] :: Versioned script -> Language

-- | <a>MintingPolicy</a> is a wrapper around <a>Script</a>s which are used
--   as validators for minting constraints.
data MintingPolicy

-- | <a>Validator</a> is a wrapper around <a>Script</a>s which are used as
--   validators in transaction outputs.
data Validator

-- | An error we can get while trying to type an existing transaction part.
data ConnectionError
WrongValidatorAddress :: Address -> Address -> ConnectionError
WrongOutType :: WrongOutTypeError -> ConnectionError
WrongValidatorType :: String -> ConnectionError
WrongRedeemerType :: BuiltinData -> ConnectionError
WrongDatumType :: BuiltinData -> ConnectionError
NoDatum :: TxOutRef -> DatumHash -> ConnectionError
UnknownRef :: TxOutRef -> ConnectionError
mkForwardingMintingPolicy :: Versioned Validator -> Versioned MintingPolicy

-- | Make a <a>TypedValidator</a> (with no type constraints) from an
--   untyped <a>Validator</a> script.
unsafeMkTypedValidator :: Versioned Validator -> TypedValidator Any

-- | The type of validators for the given connection type.
type ValidatorType a = DatumType a -> RedeemerType a -> ScriptContext -> Bool

-- | Make a <a>TypedValidator</a> from the <a>CompiledCode</a> of a
--   validator script and its wrapper.
mkTypedValidator :: CompiledCode (ValidatorType a) -> CompiledCode (ValidatorType a -> UntypedValidator) -> TypedValidator a

-- | Make a <a>TypedValidator</a> from the <a>CompiledCode</a> of a
--   parameterized validator script and its wrapper.
mkTypedValidatorParam :: forall a param. Lift DefaultUni param => CompiledCode (param -> ValidatorType a) -> CompiledCode (ValidatorType a -> UntypedValidator) -> param -> TypedValidator a

module Ledger.Crypto
newtype PubKey
PubKey :: LedgerBytes -> PubKey
[getPubKey] :: PubKey -> LedgerBytes

-- | A cryptographic private key.
newtype PrivateKey
PrivateKey :: LedgerBytes -> PrivateKey
[getPrivateKey] :: PrivateKey -> LedgerBytes

-- | A message with a cryptographic signature.
newtype Signature
Signature :: BuiltinByteString -> Signature
[getSignature] :: Signature -> BuiltinByteString

-- | Passphrase newtype to mark intent
newtype Passphrase
Passphrase :: ByteString -> Passphrase
[unPassphrase] :: Passphrase -> ByteString

-- | Compute the hash of a public key.
pubKeyHash :: PubKey -> PubKeyHash

-- | Check whether the given <a>Signature</a> was signed by the private key
--   corresponding to the given public key.
signedBy :: ByteArrayAccess a => Signature -> PubKey -> a -> Bool

-- | Sign a message using a private key and passphrase.
sign :: ByteArrayAccess a => a -> XPrv -> Passphrase -> Signature

-- | Sign the hash of a transaction using a private key and passphrase.
signTx :: TxId -> XPrv -> Passphrase -> Signature

-- | Generate a private key from a seed phrase and passphrase
generateFromSeed :: ByteString -> Passphrase -> XPrv
toPublicKey :: XPrv -> PubKey
xPubToPublicKey :: XPub -> PubKey

-- | Sign a message using a private key with no passphrase.
sign' :: ByteArrayAccess a => a -> XPrv -> Signature

-- | Sign the hash of a transaction using a private key that has no
--   passphrase.
signTx' :: TxId -> XPrv -> Signature

-- | Generate a private key from a seed phrase without a passphrase.
generateFromSeed' :: ByteString -> XPrv
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Crypto.PrivateKey
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Crypto.PrivateKey
instance Data.Hashable.Class.Hashable Ledger.Crypto.PrivateKey
instance Prettyprinter.Internal.Pretty Ledger.Crypto.PrivateKey
instance GHC.Show.Show Ledger.Crypto.PrivateKey
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Crypto.PrivateKey
instance PlutusTx.IsData.Class.FromData Ledger.Crypto.PrivateKey
instance PlutusTx.IsData.Class.ToData Ledger.Crypto.PrivateKey
instance Codec.Serialise.Class.Serialise Ledger.Crypto.PrivateKey
instance PlutusTx.Ord.Ord Ledger.Crypto.PrivateKey
instance PlutusTx.Eq.Eq Ledger.Crypto.PrivateKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Crypto.PrivateKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Crypto.PrivateKey
instance Control.Newtype.Generics.Newtype Ledger.Crypto.PrivateKey
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Crypto.PrivateKey
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Crypto.PrivateKey
instance GHC.Generics.Generic Ledger.Crypto.PrivateKey
instance GHC.Classes.Ord Ledger.Crypto.PrivateKey
instance GHC.Classes.Eq Ledger.Crypto.PrivateKey
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Crypto.PubKey
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Crypto.PubKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Crypto.PubKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Crypto.PubKey
instance Prettyprinter.Internal.Pretty Ledger.Crypto.PubKey
instance GHC.Show.Show Ledger.Crypto.PubKey
instance Data.String.IsString Ledger.Crypto.PubKey
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Crypto.PubKey
instance PlutusTx.IsData.Class.FromData Ledger.Crypto.PubKey
instance PlutusTx.IsData.Class.ToData Ledger.Crypto.PubKey
instance Codec.Serialise.Class.Serialise Ledger.Crypto.PubKey
instance PlutusTx.Ord.Ord Ledger.Crypto.PubKey
instance PlutusTx.Eq.Eq Ledger.Crypto.PubKey
instance Control.DeepSeq.NFData Ledger.Crypto.PubKey
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Crypto.PubKey
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Crypto.PubKey
instance Control.Newtype.Generics.Newtype Ledger.Crypto.PubKey
instance GHC.Generics.Generic Ledger.Crypto.PubKey
instance GHC.Classes.Ord Ledger.Crypto.PubKey
instance GHC.Classes.Eq Ledger.Crypto.PubKey
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Crypto.Signature
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Crypto.Signature
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Crypto.Signature
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Crypto.Signature
instance Data.String.IsString Ledger.Crypto.Passphrase
instance Prettyprinter.Internal.Pretty Ledger.Crypto.Signature
instance GHC.Show.Show Ledger.Crypto.Signature
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Crypto.Signature
instance PlutusTx.IsData.Class.FromData Ledger.Crypto.Signature
instance PlutusTx.IsData.Class.ToData Ledger.Crypto.Signature
instance Control.DeepSeq.NFData Ledger.Crypto.Signature
instance Codec.Serialise.Class.Serialise Ledger.Crypto.Signature
instance PlutusTx.Ord.Ord Ledger.Crypto.Signature
instance PlutusTx.Eq.Eq Ledger.Crypto.Signature
instance GHC.Generics.Generic Ledger.Crypto.Signature
instance GHC.Classes.Ord Ledger.Crypto.Signature
instance GHC.Classes.Eq Ledger.Crypto.Signature
instance GHC.Show.Show Ledger.Crypto.Passphrase

module Ledger.Orphans
instance Data.Data.Data Ouroboros.Network.Magic.NetworkMagic
instance Data.Data.Data Cardano.Api.NetworkId.NetworkId
instance GHC.Generics.Generic Cardano.Api.NetworkId.NetworkId
instance GHC.Generics.Generic Cardano.Api.ScriptData.ScriptData
instance GHC.Generics.Generic Cardano.Api.TxIn.TxId
instance Data.OpenApi.Internal.Schema.ToSchema Cardano.Api.TxIn.TxId
instance GHC.Generics.Generic Cardano.Api.TxIn.TxIx
instance Data.OpenApi.Internal.Schema.ToSchema Cardano.Api.TxIn.TxIx
instance GHC.Generics.Generic Cardano.Api.Value.Lovelace
instance Data.OpenApi.Internal.Schema.ToSchema Cardano.Api.Value.Lovelace
instance GHC.Generics.Generic Cardano.Api.Value.PolicyId
instance Data.OpenApi.Internal.Schema.ToSchema Cardano.Api.Value.PolicyId
instance GHC.Generics.Generic Cardano.Api.Value.Quantity
instance Data.OpenApi.Internal.Schema.ToSchema Cardano.Api.Value.Quantity
instance (Data.OpenApi.Internal.Schema.ToSchema k, Data.OpenApi.Internal.Schema.ToSchema v) => Data.OpenApi.Internal.Schema.ToSchema (PlutusTx.AssocMap.Map k v)
instance Data.OpenApi.Internal.Schema.ToSchema (Control.Monad.Freer.Extras.Log.LogMessage Data.Aeson.Types.Internal.Value)
instance Data.OpenApi.Internal.Schema.ToSchema Control.Monad.Freer.Extras.Log.LogLevel
instance Data.OpenApi.Internal.Schema.ToSchema ann => Data.OpenApi.Internal.Schema.ToSchema (PlutusCore.Core.Type.Kind ann)
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Ada.Ada
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.DCert.DCert
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Tx.ScriptTag
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Tx.RedeemerPtr
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Tx.TxOutRef
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Tx.TxOut
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V2.Ledger.Tx.TxOut
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Scripts.Validator
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Tx.TxId
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Slot.Slot
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Plutus.V1.Ledger.Interval.Interval a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Plutus.V1.Ledger.Interval.LowerBound a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Plutus.V1.Ledger.Interval.UpperBound a)
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Scripts.Redeemer
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Value.Value
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Scripts.MintingPolicy
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Crypto.PubKey
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Value.TokenName
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Scripts.StakeValidator
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Crypto.Signature
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Time.POSIXTime
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Time.DiffMilliSeconds
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Value.AssetClass
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Plutus.V1.Ledger.Interval.Extended a)
instance (Data.OpenApi.Internal.Schema.ToSchema tyname, Data.OpenApi.Internal.Schema.ToSchema name, Data.OpenApi.Internal.Schema.ToSchema (uni ann), Data.OpenApi.Internal.Schema.ToSchema fun, Data.OpenApi.Internal.Schema.ToSchema ann, Data.OpenApi.Internal.Schema.ToSchema (PlutusCore.Core.Type.Type tyname uni ann), Data.OpenApi.Internal.Schema.ToSchema (Data.Some.Newtype.Some (Universe.Core.ValueOf uni)), Data.Typeable.Internal.Typeable uni) => Data.OpenApi.Internal.Schema.ToSchema (PlutusCore.Core.Type.Term tyname name uni fun ann)
instance Data.OpenApi.Internal.Schema.ToSchema ann => Data.OpenApi.Internal.Schema.ToSchema (PlutusCore.Core.Type.Version ann)
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Scripts.ScriptHash
instance Data.OpenApi.Internal.Schema.ToSchema Cardano.Ledger.Alonzo.Language.Language
instance Data.OpenApi.Internal.Schema.ToSchema script => Data.OpenApi.Internal.Schema.ToSchema (Plutus.Script.Utils.Scripts.Versioned script)
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Time.POSIXTime
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Time.POSIXTime
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.ScriptError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.ScriptError
instance Web.Internal.HttpApiData.ToHttpApiData Ledger.Crypto.PrivateKey
instance Web.Internal.HttpApiData.FromHttpApiData Ledger.Crypto.PrivateKey
instance Web.Internal.HttpApiData.ToHttpApiData Plutus.V1.Ledger.Bytes.LedgerBytes
instance Web.Internal.HttpApiData.FromHttpApiData Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.ByteArray.Types.ByteArrayAccess Plutus.V1.Ledger.Tx.TxId
instance Codec.Serialise.Class.Serialise (Cardano.Api.Address.AddressInEra Cardano.Api.Eras.BabbageEra)
instance Data.OpenApi.Internal.Schema.ToSchema Cardano.Api.Script.ScriptHash
instance Data.OpenApi.Internal.Schema.ToSchema (Cardano.Api.Address.AddressInEra Cardano.Api.Eras.BabbageEra)
instance Data.OpenApi.Internal.Schema.ToSchema Cardano.Api.ScriptData.ScriptData
instance Data.OpenApi.Internal.Schema.ToSchema (Cardano.Api.Hash.Hash Cardano.Api.ScriptData.ScriptData)
instance Data.OpenApi.Internal.Schema.ToSchema Cardano.Api.Value.AssetName
instance Data.OpenApi.Internal.Schema.ToSchema Cardano.Crypto.Wallet.XPub
instance Data.OpenApi.Internal.Schema.ToSchema Cardano.Crypto.Wallet.XPrv
instance Data.OpenApi.Internal.Schema.ToSchema (Crypto.Hash.Types.Digest Crypto.Hash.Blake2b.Blake2b_160)
instance Data.OpenApi.Internal.Schema.ToSchema (Cardano.Crypto.Hash.Class.Hash Cardano.Crypto.Hash.Blake2b.Blake2b_256 Cardano.Ledger.Hashes.EraIndependentTxBody)
instance Data.OpenApi.Internal.Schema.ToSchema (Cardano.Ledger.SafeHash.SafeHash Cardano.Ledger.Crypto.StandardCrypto Cardano.Ledger.Hashes.EraIndependentData)
instance Data.OpenApi.Internal.Schema.ToSchema Data.Aeson.Types.Internal.Value
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.V1.Ledger.Scripts.Script
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Time.POSIXTime
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Time.POSIXTime

module Ledger.Address

-- | The staking credential of an address (if any)
stakingCredential :: Address -> Maybe StakingCredential

-- | The address that should be used by a transaction output locked by the
--   given validator script hash.
scriptHashAddress :: ValidatorHash -> Address

-- | The validator hash of the address, if any
toValidatorHash :: Address -> Maybe ValidatorHash

-- | The PubKeyHash of the address, if any
toPubKeyHash :: Address -> Maybe PubKeyHash

-- | Address with two kinds of credentials, normal and staking.
data Address
Address :: Credential -> Maybe StakingCredential -> Address
[addressCredential] :: Address -> Credential
[addressStakingCredential] :: Address -> Maybe StakingCredential
type CardanoAddress = AddressInEra BabbageEra
newtype PaymentPrivateKey
PaymentPrivateKey :: XPrv -> PaymentPrivateKey
[unPaymentPrivateKey] :: PaymentPrivateKey -> XPrv
newtype PaymentPubKey
PaymentPubKey :: PubKey -> PaymentPubKey
[unPaymentPubKey] :: PaymentPubKey -> PubKey
newtype PaymentPubKeyHash
PaymentPubKeyHash :: PubKeyHash -> PaymentPubKeyHash
[unPaymentPubKeyHash] :: PaymentPubKeyHash -> PubKeyHash
newtype StakePubKey
StakePubKey :: PubKey -> StakePubKey
[unStakePubKey] :: StakePubKey -> PubKey
newtype StakePubKeyHash
StakePubKeyHash :: PubKeyHash -> StakePubKeyHash
[unStakePubKeyHash] :: StakePubKeyHash -> PubKeyHash
toPlutusAddress :: AddressInEra era -> Address
toPlutusPubKeyHash :: Hash PaymentKey -> PubKeyHash
cardanoAddressCredential :: AddressInEra era -> Credential
cardanoPubKeyHash :: AddressInEra era -> Maybe PubKeyHash
cardanoStakingCredential :: AddressInEra era -> Maybe StakingCredential
paymentPubKeyHash :: PaymentPubKey -> PaymentPubKeyHash

-- | The address that should be targeted by a transaction output locked by
--   the given public payment key (with its staking credentials).
pubKeyHashAddress :: PaymentPubKeyHash -> Maybe StakingCredential -> Address

-- | The address that should be targeted by a transaction output locked by
--   the given public key. (with its staking credentials).
pubKeyAddress :: PaymentPubKey -> Maybe StakingCredential -> Address

-- | The address that should be used by a transaction output locked by the
--   given validator script (with its staking credentials).
scriptValidatorHashAddress :: ValidatorHash -> Maybe StakingCredential -> Address

-- | Construct a <a>StakingCredential</a> from a public key hash.
stakePubKeyHashCredential :: StakePubKeyHash -> StakingCredential

-- | Construct a <a>StakingCredential</a> from a validator script hash.
stakeValidatorHashCredential :: StakeValidatorHash -> StakingCredential
xprvToPaymentPubKey :: XPrv -> PaymentPubKey
xprvToPaymentPubKeyHash :: XPrv -> PaymentPubKeyHash
xprvToStakingCredential :: XPrv -> StakingCredential
xprvToStakePubKey :: XPrv -> StakePubKey
xprvToStakePubKeyHash :: XPrv -> StakePubKeyHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Address.StakePubKeyHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Address.StakePubKeyHash
instance Prettyprinter.Internal.Pretty Ledger.Address.StakePubKeyHash
instance GHC.Show.Show Ledger.Address.StakePubKeyHash
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Address.StakePubKeyHash
instance PlutusTx.IsData.Class.FromData Ledger.Address.StakePubKeyHash
instance PlutusTx.IsData.Class.ToData Ledger.Address.StakePubKeyHash
instance Data.Hashable.Class.Hashable Ledger.Address.StakePubKeyHash
instance Codec.Serialise.Class.Serialise Ledger.Address.StakePubKeyHash
instance PlutusTx.Ord.Ord Ledger.Address.StakePubKeyHash
instance PlutusTx.Eq.Eq Ledger.Address.StakePubKeyHash
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Address.StakePubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Address.StakePubKeyHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Address.StakePubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Address.StakePubKeyHash
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Address.StakePubKeyHash
instance GHC.Generics.Generic Ledger.Address.StakePubKeyHash
instance GHC.Classes.Ord Ledger.Address.StakePubKeyHash
instance GHC.Classes.Eq Ledger.Address.StakePubKeyHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Address.StakePubKey
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Address.StakePubKey
instance Prettyprinter.Internal.Pretty Ledger.Address.StakePubKey
instance GHC.Show.Show Ledger.Address.StakePubKey
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Address.StakePubKey
instance PlutusTx.IsData.Class.FromData Ledger.Address.StakePubKey
instance PlutusTx.IsData.Class.ToData Ledger.Address.StakePubKey
instance Codec.Serialise.Class.Serialise Ledger.Address.StakePubKey
instance PlutusTx.Ord.Ord Ledger.Address.StakePubKey
instance PlutusTx.Eq.Eq Ledger.Address.StakePubKey
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Address.StakePubKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Address.StakePubKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Address.StakePubKey
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Address.StakePubKey
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Address.StakePubKey
instance GHC.Generics.Generic Ledger.Address.StakePubKey
instance GHC.Classes.Ord Ledger.Address.StakePubKey
instance GHC.Classes.Eq Ledger.Address.StakePubKey
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Address.PaymentPubKeyHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Address.PaymentPubKeyHash
instance Prettyprinter.Internal.Pretty Ledger.Address.PaymentPubKeyHash
instance GHC.Show.Show Ledger.Address.PaymentPubKeyHash
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Address.PaymentPubKeyHash
instance PlutusTx.IsData.Class.FromData Ledger.Address.PaymentPubKeyHash
instance PlutusTx.IsData.Class.ToData Ledger.Address.PaymentPubKeyHash
instance Data.Hashable.Class.Hashable Ledger.Address.PaymentPubKeyHash
instance Codec.Serialise.Class.Serialise Ledger.Address.PaymentPubKeyHash
instance PlutusTx.Ord.Ord Ledger.Address.PaymentPubKeyHash
instance PlutusTx.Eq.Eq Ledger.Address.PaymentPubKeyHash
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Address.PaymentPubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Address.PaymentPubKeyHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Address.PaymentPubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Address.PaymentPubKeyHash
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Address.PaymentPubKeyHash
instance GHC.Generics.Generic Ledger.Address.PaymentPubKeyHash
instance GHC.Classes.Ord Ledger.Address.PaymentPubKeyHash
instance GHC.Classes.Eq Ledger.Address.PaymentPubKeyHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Address.PaymentPubKey
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Address.PaymentPubKey
instance Prettyprinter.Internal.Pretty Ledger.Address.PaymentPubKey
instance GHC.Show.Show Ledger.Address.PaymentPubKey
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Address.PaymentPubKey
instance PlutusTx.IsData.Class.FromData Ledger.Address.PaymentPubKey
instance PlutusTx.IsData.Class.ToData Ledger.Address.PaymentPubKey
instance Codec.Serialise.Class.Serialise Ledger.Address.PaymentPubKey
instance PlutusTx.Ord.Ord Ledger.Address.PaymentPubKey
instance PlutusTx.Eq.Eq Ledger.Address.PaymentPubKey
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Address.PaymentPubKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Address.PaymentPubKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Address.PaymentPubKey
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Address.PaymentPubKey
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Address.PaymentPubKey
instance GHC.Generics.Generic Ledger.Address.PaymentPubKey
instance GHC.Classes.Ord Ledger.Address.PaymentPubKey
instance GHC.Classes.Eq Ledger.Address.PaymentPubKey


-- | Interface to the transaction types from 'cardano-api'
module Ledger.Tx.CardanoAPI.Internal
newtype CardanoBuildTx
CardanoBuildTx :: TxBodyContent BuildTx BabbageEra -> CardanoBuildTx
[getCardanoBuildTx] :: CardanoBuildTx -> TxBodyContent BuildTx BabbageEra

-- | Cardano tx from any era.
data SomeCardanoApiTx
[SomeTx] :: IsCardanoEra era => Tx era -> EraInMode era CardanoMode -> SomeCardanoApiTx
txOutRefs :: SomeCardanoApiTx -> [(TxOut, TxOutRef)]
unspentOutputsTx :: SomeCardanoApiTx -> Map TxOutRef TxOut
fromCardanoTxId :: TxId -> TxId
fromCardanoTxIn :: TxIn -> TxOutRef
fromCardanoTxOutToPV1TxInfoTxOut :: TxOut CtxTx era -> TxOut
fromCardanoTxOutToPV2TxInfoTxOut :: TxOut CtxTx era -> TxOut
fromCardanoTxOutDatumHash :: TxOutDatum CtxTx era -> Maybe DatumHash
fromCardanoTxOutDatum :: TxOutDatum CtxTx era -> OutputDatum
fromCardanoTxOutValue :: TxOutValue era -> Value

-- | <i>Deprecated: we now use Cardano address internally, if you need a
--   plutus address use <a>toPlutusAddress</a> </i>
fromCardanoAddressInEra :: AddressInEra era -> Address

-- | <i>Deprecated: Shouldn't be used as we use Cardano address internally
--   now</i>
fromCardanoAddress :: Address addrtype -> Address
fromCardanoAssetId :: AssetId -> AssetClass
fromCardanoAssetName :: AssetName -> TokenName
fromCardanoMintValue :: TxMintValue build era -> Value
fromCardanoValue :: Value -> Value
fromCardanoPolicyId :: PolicyId -> MintingPolicyHash
fromCardanoFee :: TxFee era -> Value
fromCardanoValidityRange :: (TxValidityLowerBound era, TxValidityUpperBound era) -> SlotRange
fromCardanoScriptInEra :: ScriptInEra era -> Maybe (Versioned Script)

-- | <i>Deprecated: Shouldn't be used as we use Cardano address internally
--   now</i>
fromCardanoPaymentKeyHash :: Hash PaymentKey -> PubKeyHash
fromCardanoScriptData :: ScriptData -> BuiltinData
fromCardanoPlutusScript :: HasTypeProxy lang => PlutusScript lang -> Script
fromCardanoScriptInAnyLang :: ScriptInAnyLang -> Maybe (Versioned Script)
fromCardanoLovelace :: Lovelace -> Value

-- | Given a 'C.TxScriptValidity era', if the <tt>era</tt> supports
--   scripts, return a <tt>True</tt> or <tt>False</tt> depending on script
--   validity. If the <tt>era</tt> does not support scripts, always return
--   <tt>True</tt>.
fromTxScriptValidity :: TxScriptValidity era -> Bool
toTxScriptValidity :: ShelleyBasedEra era -> Bool -> TxScriptValidity era

-- | Given a 'C.TxBody from a 'C.Tx era', return the datums and redeemers
--   along with their hashes.
scriptDataFromCardanoTxBody :: TxBody era -> (Map DatumHash Datum, Redeemers)

-- | Extract plutus scripts from a Cardano API tx body.
--   
--   Note that Plutus scripts are only supported in Alonzo era and onwards.
plutusScriptsFromTxBody :: TxBody era -> Map ScriptHash (Versioned Script)
makeTransactionBody :: Maybe (PParams (BabbageEra StandardCrypto)) -> Map RdmrPtr ExUnits -> CardanoBuildTx -> Either ToCardanoError (TxBody BabbageEra)
toCardanoTxIn :: TxOutRef -> Either ToCardanoError TxIn
toCardanoTxOut :: NetworkId -> TxOut -> Either ToCardanoError (TxOut CtxTx BabbageEra)
toCardanoTxOutDatum :: OutputDatum -> Either ToCardanoError (TxOutDatum CtxTx BabbageEra)
toCardanoTxOutDatumHash :: DatumHash -> Either ToCardanoError (TxOutDatum ctx BabbageEra)
toCardanoTxOutDatumHashFromDatum :: Datum -> TxOutDatum ctx BabbageEra
toCardanoTxOutDatumInline :: Datum -> TxOutDatum CtxTx BabbageEra
toCardanoTxOutDatumInTx :: Datum -> TxOutDatum CtxTx BabbageEra
toCardanoTxOutNoDatum :: TxOutDatum CtxTx BabbageEra
toCardanoTxOutValue :: Value -> Either ToCardanoError (TxOutValue BabbageEra)
toCardanoAddressInEra :: NetworkId -> Address -> Either ToCardanoError (AddressInEra BabbageEra)
toCardanoAssetId :: AssetClass -> Either ToCardanoError AssetId
toCardanoAssetName :: TokenName -> Either ToCardanoError AssetName
toCardanoPolicyId :: MintingPolicyHash -> Either ToCardanoError PolicyId
toCardanoValue :: Value -> Either ToCardanoError Value
toCardanoLovelace :: Value -> Either ToCardanoError Lovelace
toCardanoFee :: Value -> Either ToCardanoError (TxFee BabbageEra)
adaToCardanoValue :: Ada -> Value
toCardanoValidityRange :: SlotRange -> Either ToCardanoError (TxValidityLowerBound BabbageEra, TxValidityUpperBound BabbageEra)
toCardanoScriptInEra :: Versioned Script -> Either ToCardanoError (ScriptInEra BabbageEra)
toCardanoPaymentKeyHash :: PaymentPubKeyHash -> Either ToCardanoError (Hash PaymentKey)
toCardanoScriptData :: BuiltinData -> ScriptData
toCardanoScriptDataHash :: DatumHash -> Either ToCardanoError (Hash ScriptData)
toCardanoScriptHash :: ValidatorHash -> Either ToCardanoError ScriptHash
toCardanoStakeKeyHash :: PubKeyHash -> Either ToCardanoError (Hash StakeKey)
toCardanoPlutusScript :: SerialiseAsRawBytes plutusScript => AsType plutusScript -> Script -> Either ToCardanoError plutusScript
toCardanoScriptInAnyLang :: Versioned Script -> Either ToCardanoError ScriptInAnyLang
toCardanoReferenceScript :: Maybe (Versioned Script) -> Either ToCardanoError (ReferenceScript BabbageEra)
toCardanoTxId :: TxId -> Either ToCardanoError TxId
data ToCardanoError

-- | A C.TxBodyError converted to String
TxBodyError :: String -> ToCardanoError
DeserialisationError :: ToCardanoError
InvalidValidityRange :: ToCardanoError
ValueNotPureAda :: ToCardanoError
OutputHasZeroAda :: ToCardanoError
StakingPointersNotSupported :: ToCardanoError
SimpleScriptsNotSupportedToCardano :: ToCardanoError
MissingInputValidator :: ToCardanoError
MissingDatum :: ToCardanoError
MissingMintingPolicy :: ToCardanoError
ScriptPurposeNotSupported :: ScriptTag -> ToCardanoError
MissingMintingPolicyRedeemer :: ToCardanoError
MissingStakeValidator :: ToCardanoError
UnsupportedPlutusVersion :: Language -> ToCardanoError
Tag :: String -> ToCardanoError -> ToCardanoError
data FromCardanoError
SimpleScriptsNotSupported :: FromCardanoError
deserialiseFromRawBytes :: SerialiseAsRawBytes t => AsType t -> ByteString -> Either ToCardanoError t
zeroExecutionUnits :: ExecutionUnits
tag :: String -> Either ToCardanoError t -> Either ToCardanoError t

-- | Run code that needs an <tt>IsCardanoEra</tt> constraint while you only
--   have an <tt>EraInMode</tt> value.
withIsCardanoEra :: EraInMode era CardanoMode -> (IsCardanoEra era => r) -> r
instance GHC.Show.Show Ledger.Tx.CardanoAPI.Internal.CardanoBuildTx
instance GHC.Classes.Eq Ledger.Tx.CardanoAPI.Internal.CardanoBuildTx
instance Cardano.BM.Data.Tracer.ToObject Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance GHC.Generics.Generic Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance GHC.Classes.Eq Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance GHC.Show.Show Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.CardanoAPI.Internal.ToCardanoError
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.CardanoAPI.Internal.ToCardanoError
instance GHC.Generics.Generic Ledger.Tx.CardanoAPI.Internal.ToCardanoError
instance GHC.Classes.Eq Ledger.Tx.CardanoAPI.Internal.ToCardanoError
instance GHC.Show.Show Ledger.Tx.CardanoAPI.Internal.ToCardanoError
instance GHC.Show.Show Ledger.Tx.CardanoAPI.Internal.SomeCardanoApiTx
instance Prettyprinter.Internal.Pretty Ledger.Tx.CardanoAPI.Internal.ToCardanoError
instance Prettyprinter.Internal.Pretty Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance GHC.Classes.Eq Ledger.Tx.CardanoAPI.Internal.SomeCardanoApiTx
instance Codec.Serialise.Class.Serialise Ledger.Tx.CardanoAPI.Internal.SomeCardanoApiTx
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.CardanoAPI.Internal.SomeCardanoApiTx
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.CardanoAPI.Internal.SomeCardanoApiTx
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Tx.CardanoAPI.Internal.SomeCardanoApiTx
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.CardanoAPI.Internal.CardanoBuildTx
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.CardanoAPI.Internal.CardanoBuildTx
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Tx.CardanoAPI.Internal.CardanoBuildTx
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable mode) => Data.OpenApi.Internal.Schema.ToSchema (Cardano.Api.Modes.EraInMode era mode)
instance Data.Typeable.Internal.Typeable era => Data.OpenApi.Internal.Schema.ToSchema (Cardano.Api.Tx.Tx era)

module Ledger.Tx.Internal
type ReferenceScript = ReferenceScript BabbageEra

-- | A <a>TxOut</a> along with the <a>Tx</a> it comes from, which may have
--   additional information e.g. the full data script that goes with the
--   <a>TxOut</a>.
data TxOutTx
TxOutTx :: Tx -> TxOut -> TxOutTx
[txOutTxTx] :: TxOutTx -> Tx
[txOutTxOut] :: TxOutTx -> TxOut

-- | A babbage era transaction without witnesses for its inputs.
data TxStripped
TxStripped :: [TxOutRef] -> [TxOutRef] -> [TxOut] -> !Value -> !Value -> TxStripped

-- | The inputs to this transaction, as transaction output references only.
[txStrippedInputs] :: TxStripped -> [TxOutRef]

-- | The reference inputs to this transaction, as transaction output
--   references only.
[txStrippedReferenceInputs] :: TxStripped -> [TxOutRef]

-- | The outputs of this transation.
[txStrippedOutputs] :: TxStripped -> [TxOut]

-- | The <a>Value</a> minted by this transaction.
[txStrippedMint] :: TxStripped -> !Value

-- | The fee for this transaction.
[txStrippedFee] :: TxStripped -> !Value

-- | A Babbage-era transaction, including witnesses for its inputs.
data Tx
Tx :: [TxInput] -> [TxInput] -> [TxInput] -> [TxOut] -> Maybe TxOut -> Maybe Value -> !Value -> !Value -> !SlotRange -> MintingWitnessesMap -> [Withdrawal] -> [Certificate] -> Map PubKey Signature -> ScriptsMap -> Map DatumHash Datum -> Maybe BuiltinByteString -> Tx

-- | The inputs to this transaction.
[txInputs] :: Tx -> [TxInput]

-- | The reference inputs to this transaction.
[txReferenceInputs] :: Tx -> [TxInput]

-- | The collateral inputs to cover the fees in case validation of the
--   transaction fails.
[txCollateralInputs] :: Tx -> [TxInput]

-- | The outputs of this transaction, ordered so they can be referenced by
--   index.
[txOutputs] :: Tx -> [TxOut]

-- | The output of the remaining collateral after covering fees in case
--   validation of the transaction fails.
[txReturnCollateral] :: Tx -> Maybe TxOut

-- | The total collateral to be paid in case validation of the transaction
--   fails.
[txTotalCollateral] :: Tx -> Maybe Value

-- | The <a>Value</a> minted by this transaction.
[txMint] :: Tx -> !Value

-- | The fee for this transaction.
[txFee] :: Tx -> !Value

-- | The <a>SlotRange</a> during which this transaction may be validated.
[txValidRange] :: Tx -> !SlotRange

-- | The witnesses that must be present to check minting conditions matched
--   with their redeemers.
[txMintingWitnesses] :: Tx -> MintingWitnessesMap

-- | Withdrawals, contains redeemers.
[txWithdrawals] :: Tx -> [Withdrawal]

-- | Certificates, contains redeemers.
[txCertificates] :: Tx -> [Certificate]

-- | Signatures of this transaction.
[txSignatures] :: Tx -> Map PubKey Signature

-- | Scripts for all script credentials mentioned in this tx.
[txScripts] :: Tx -> ScriptsMap

-- | Datum objects recorded on this transaction.
[txData] :: Tx -> Map DatumHash Datum

-- | Metadata
[txMetadata] :: Tx -> Maybe BuiltinByteString
type MintingWitnessesMap = Map MintingPolicyHash (Redeemer, Maybe (Versioned TxOutRef))
type ScriptsMap = Map ScriptHash (Versioned Script)

-- | Validator, redeemer, and data scripts of a transaction input that
--   spends a "pay to script" output. inScripts :: Tx -&gt; TxInput -&gt;
--   Maybe (LedgerPlutusVersion, Validator, Redeemer, Datum) inScripts tx
--   i@TxInput{txInputType=TxConsumeScriptAddress pv _ _ _} = case txInType
--   $ fillTxInputWitnesses tx i of Just (ConsumeScriptAddress v r d) -&gt;
--   Just (pv, v, r, d) _ -&gt; Nothing inScripts _ _ = Nothing
newtype TxOut
TxOut :: TxOut CtxTx BabbageEra -> TxOut
[getTxOut] :: TxOut -> TxOut CtxTx BabbageEra
data Certificate
Certificate :: DCert -> Maybe Redeemer -> Certificate
[certificateDcert] :: Certificate -> DCert

-- | redeemer for script credential
[certificateRedeemer] :: Certificate -> Maybe Redeemer

-- | Stake withdrawal, if applicable the script should be included in
--   txScripts.
data Withdrawal
Withdrawal :: Credential -> Integer -> Maybe Redeemer -> Withdrawal

-- | staking credential
[withdrawalCredential] :: Withdrawal -> Credential

-- | amount of withdrawal in Lovelace, must withdraw all eligible amount
[withdrawalAmount] :: Withdrawal -> Integer

-- | redeemer for script credential
[withdrawalRedeemer] :: Withdrawal -> Maybe Redeemer

-- | A transaction input, consisting of a transaction output reference and
--   an input type. Differs with TxIn by: TxIn *maybe* contains *full* data
--   witnesses, TxInput always contains redeemer witness, but
--   datum/validator hashes.
data TxInput
TxInput :: !TxOutRef -> !TxInputType -> TxInput
[txInputRef] :: TxInput -> !TxOutRef
[txInputType] :: TxInput -> !TxInputType

-- | The type of a transaction input with hashes.
data TxInputType

-- | A transaction input that consumes (with a validator hash) or
--   references (with a txOutRef) a script address with the given the
--   redeemer and datum hash.
TxScriptAddress :: !Redeemer -> !Either ValidatorHash (Versioned TxOutRef) -> !Maybe DatumHash -> TxInputType

-- | A transaction input that consumes a public key address.
TxConsumePublicKeyAddress :: TxInputType

-- | Consume a simple script
TxConsumeSimpleScriptAddress :: TxInputType

-- | A transaction input, consisting of a transaction output reference and
--   an input type.
data TxIn
TxIn :: !TxOutRef -> Maybe TxInType -> TxIn
[txInRef] :: TxIn -> !TxOutRef
[txInType] :: TxIn -> Maybe TxInType

-- | The type of a transaction input.
data TxInType

-- | A transaction input that consumes (with a validator) or references
--   (with a txOutRef) a script address with the given the redeemer and
--   datum. Datum is optional if the input refers to a script output which
--   contains an inline datum
ScriptAddress :: !Either (Versioned Validator) (Versioned TxOutRef) -> !Redeemer -> !Maybe Datum -> TxInType

-- | A transaction input that consumes a public key address.
ConsumePublicKeyAddress :: TxInType

-- | Consume a simple script
ConsumeSimpleScriptAddress :: TxInType

-- | A transaction input that spends a "pay to public key" output, given
--   the witness.
pubKeyTxIn :: TxOutRef -> TxIn

-- | A transaction input that spends a "pay to script" output, given
--   witnesses. Datum is optional if the input refers to a script output
--   which contains an inline datum
scriptTxIn :: TxOutRef -> Versioned Validator -> Redeemer -> Maybe Datum -> TxIn

-- | The <a>TxOutRef</a> spent by a transaction input.
inputRef :: Lens' TxInput TxOutRef

-- | The type of a transaction input.
inputType :: Lens' TxInput TxInputType

-- | Validator, redeemer, and data scripts of a transaction input that
--   spends a "pay to script" output.
inScripts :: TxIn -> Maybe (Versioned Validator, Redeemer, Maybe Datum)

-- | The <a>TxOutRef</a> spent by a transaction input.
inRef :: Lens' TxInput TxOutRef

-- | The type of a transaction input.
inType :: Lens' TxInput TxInputType

-- | Filter to get only the pubkey inputs.
pubKeyTxInputs :: Fold [TxInput] TxInput

-- | Filter to get only the scripts that consume or reference a script
--   address
scriptTxInputs :: Fold [TxInput] TxInput

-- | Filter to get only the scripts that reference a script address
referenceScriptTxInputs :: Fold [TxInput] TxInput
toSizedTxOut :: TxOut -> Sized (TxOut StandardBabbage)

-- | The inputs of a transaction.
inputs :: Lens' Tx [TxInput]

-- | The reference inputs of a transaction.
referenceInputs :: Lens' Tx [TxInput]

-- | The collateral inputs of a transaction for paying fees when validating
--   the transaction fails.
collateralInputs :: Lens' Tx [TxInput]

-- | The outputs of a transaction.
outputs :: Lens' Tx [TxOut]
returnCollateral :: Lens' Tx (Maybe TxOut)
totalCollateral :: Lens' Tx (Maybe Value)

-- | The validity range of a transaction.
validRange :: Lens' Tx SlotRange
signatures :: Lens' Tx (Map PubKey Signature)
fee :: Lens' Tx Value
mint :: Lens' Tx Value
mintScripts :: Lens' Tx MintingWitnessesMap
scriptWitnesses :: Lens' Tx ScriptsMap
datumWitnesses :: Lens' Tx (Map DatumHash Datum)

-- | The inputs of a transaction.
metadata :: Lens' Tx (Maybe BuiltinByteString)
lookupSignature :: PubKey -> Tx -> Maybe Signature
lookupDatum :: Tx -> DatumHash -> Maybe Datum

-- | Check that all values in a transaction are non-negative.
validValuesTx :: Tx -> Bool
txOutValue :: TxOut -> Value
outValue :: Lens TxOut TxOut Value (TxOutValue BabbageEra)
outValue' :: Lens' TxOut (TxOutValue BabbageEra)
strip :: Tx -> TxStripped
txOutTxDatum :: TxOutTx -> Maybe Datum

-- | Get a hash from the stored TxOutDatum (either dirctly or by hashing
--   the inlined datum)
txOutDatumHash :: TxOut -> Maybe DatumHash
txOutPubKey :: TxOut -> Maybe PubKeyHash
txOutAddress :: TxOut -> CardanoAddress
outAddress :: Lens' TxOut (AddressInEra BabbageEra)
outDatumHash :: Lens TxOut TxOut (Maybe DatumHash) (TxOutDatum CtxTx BabbageEra)
txOutReferenceScript :: TxOut -> ReferenceScript
outReferenceScript :: Lens' TxOut ReferenceScript
lookupScript :: ScriptsMap -> ScriptHash -> Maybe (Versioned Script)
lookupValidator :: ScriptsMap -> ValidatorHash -> Maybe (Versioned Validator)

-- | The transaction output references consumed by a transaction.
spentOutputs :: Tx -> [TxOutRef]

-- | The transaction output references referenced by a transaction.
referencedOutputs :: Tx -> [TxOutRef]
lookupMintingPolicy :: ScriptsMap -> MintingPolicyHash -> Maybe (Versioned MintingPolicy)
lookupStakeValidator :: ScriptsMap -> StakeValidatorHash -> Maybe (Versioned StakeValidator)

-- | Translate TxInput to old Plutus.V1.Ledger.Api TxIn taking script and
--   datum witnesses from Tx.
fillTxInputWitnesses :: Tx -> TxInput -> TxIn
pubKeyTxInput :: TxOutRef -> TxInput

-- | Add minting policy together with the redeemer into txMintingWitnesses
--   and txScripts accordingly. Doesn't alter txMint.
addMintingPolicy :: Versioned MintingPolicy -> (Redeemer, Maybe (Versioned TxOutRef)) -> Tx -> Tx

-- | Add validator together with the redeemer and datum into txInputs,
--   txData and txScripts accordingly. Datum is optional if the input
--   refers to a script output which contains an inline datum
addScriptTxInput :: TxOutRef -> Versioned Validator -> Redeemer -> Maybe Datum -> Tx -> Tx

-- | Add script reference together with the redeemer and datum into
--   txInputs and txData accordingly. Datum is optional if the input refers
--   to a script output which contains an inline datum
addReferenceTxInput :: TxOutRef -> Versioned TxOutRef -> Redeemer -> Maybe Datum -> Tx -> Tx
txRedeemers :: Tx -> Map ScriptPurpose Redeemer
txSpendingRedeemers :: Tx -> Map TxOutRef Redeemer
txMintingRedeemers :: Tx -> Map MintingPolicyHash Redeemer
txRewardingRedeemers :: Tx -> Map Credential Redeemer
txCertifyingRedeemers :: Tx -> Map DCert Redeemer

-- | Non-Native Script language. This is an Enumerated type. This is
--   expected to be an open type. We will add new Constuctors to this type
--   as additional Non-Native scripting language as are added. We use an
--   enumerated type for two reasons. 1) We can write total functions by
--   case analysis over the constructors 2) We will use DataKinds to make
--   some datatypes indexed by Language For now, the only Non-Native
--   Scriting language is Plutus We might add new languages in the futures.
--   
--   Note that the the serialization of <a>Language</a> depends on the
--   ordering.
data Language
PlutusV1 :: Language
PlutusV2 :: Language

-- | Validator, redeemer, and data scripts of a transaction input that
--   spends a "pay to script" output. inScripts :: Tx -&gt; TxInput -&gt;
--   Maybe (LedgerPlutusVersion, Validator, Redeemer, Datum) inScripts tx
--   i@TxInput{txInputType=TxConsumeScriptAddress pv _ _ _} = case txInType
--   $ fillTxInputWitnesses tx i of Just (ConsumeScriptAddress v r d) -&gt;
--   Just (pv, v, r, d) _ -&gt; Nothing inScripts _ _ = Nothing
newtype TxOut
TxOut :: TxOut CtxTx BabbageEra -> TxOut
[getTxOut] :: TxOut -> TxOut CtxTx BabbageEra

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | A script of some kind with its Plutus language version
data Versioned script
Versioned :: script -> Language -> Versioned script
[unversioned] :: Versioned script -> script
[version] :: Versioned script -> Language
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Tx.Internal.TxInType
instance Control.DeepSeq.NFData Ledger.Tx.Internal.TxInType
instance Codec.Serialise.Class.Serialise Ledger.Tx.Internal.TxInType
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.Internal.TxInType
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.Internal.TxInType
instance GHC.Generics.Generic Ledger.Tx.Internal.TxInType
instance GHC.Classes.Ord Ledger.Tx.Internal.TxInType
instance GHC.Classes.Eq Ledger.Tx.Internal.TxInType
instance GHC.Show.Show Ledger.Tx.Internal.TxInType
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Tx.Internal.TxIn
instance Control.DeepSeq.NFData Ledger.Tx.Internal.TxIn
instance Codec.Serialise.Class.Serialise Ledger.Tx.Internal.TxIn
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.Internal.TxIn
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.Internal.TxIn
instance GHC.Generics.Generic Ledger.Tx.Internal.TxIn
instance GHC.Classes.Ord Ledger.Tx.Internal.TxIn
instance GHC.Classes.Eq Ledger.Tx.Internal.TxIn
instance GHC.Show.Show Ledger.Tx.Internal.TxIn
instance Control.DeepSeq.NFData Ledger.Tx.Internal.TxInputType
instance Codec.Serialise.Class.Serialise Ledger.Tx.Internal.TxInputType
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.Internal.TxInputType
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.Internal.TxInputType
instance GHC.Generics.Generic Ledger.Tx.Internal.TxInputType
instance GHC.Classes.Ord Ledger.Tx.Internal.TxInputType
instance GHC.Classes.Eq Ledger.Tx.Internal.TxInputType
instance GHC.Show.Show Ledger.Tx.Internal.TxInputType
instance Control.DeepSeq.NFData Ledger.Tx.Internal.TxInput
instance Codec.Serialise.Class.Serialise Ledger.Tx.Internal.TxInput
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.Internal.TxInput
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.Internal.TxInput
instance GHC.Generics.Generic Ledger.Tx.Internal.TxInput
instance GHC.Classes.Ord Ledger.Tx.Internal.TxInput
instance GHC.Classes.Eq Ledger.Tx.Internal.TxInput
instance GHC.Show.Show Ledger.Tx.Internal.TxInput
instance Control.DeepSeq.NFData Ledger.Tx.Internal.Withdrawal
instance Codec.Serialise.Class.Serialise Ledger.Tx.Internal.Withdrawal
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.Internal.Withdrawal
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.Internal.Withdrawal
instance GHC.Generics.Generic Ledger.Tx.Internal.Withdrawal
instance GHC.Classes.Eq Ledger.Tx.Internal.Withdrawal
instance GHC.Show.Show Ledger.Tx.Internal.Withdrawal
instance Control.DeepSeq.NFData Ledger.Tx.Internal.Certificate
instance Codec.Serialise.Class.Serialise Ledger.Tx.Internal.Certificate
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.Internal.Certificate
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.Internal.Certificate
instance GHC.Generics.Generic Ledger.Tx.Internal.Certificate
instance GHC.Classes.Eq Ledger.Tx.Internal.Certificate
instance GHC.Show.Show Ledger.Tx.Internal.Certificate
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.Internal.TxOut
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.Internal.TxOut
instance GHC.Generics.Generic Ledger.Tx.Internal.TxOut
instance GHC.Classes.Eq Ledger.Tx.Internal.TxOut
instance GHC.Show.Show Ledger.Tx.Internal.TxOut
instance Control.DeepSeq.NFData Ledger.Tx.Internal.Tx
instance Codec.Serialise.Class.Serialise Ledger.Tx.Internal.Tx
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.Internal.Tx
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.Internal.Tx
instance GHC.Generics.Generic Ledger.Tx.Internal.Tx
instance GHC.Classes.Eq Ledger.Tx.Internal.Tx
instance GHC.Show.Show Ledger.Tx.Internal.Tx
instance Codec.Serialise.Class.Serialise Ledger.Tx.Internal.TxStripped
instance GHC.Generics.Generic Ledger.Tx.Internal.TxStripped
instance GHC.Classes.Eq Ledger.Tx.Internal.TxStripped
instance GHC.Show.Show Ledger.Tx.Internal.TxStripped
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.Internal.TxOutTx
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.Internal.TxOutTx
instance Codec.Serialise.Class.Serialise Ledger.Tx.Internal.TxOutTx
instance GHC.Generics.Generic Ledger.Tx.Internal.TxOutTx
instance GHC.Classes.Eq Ledger.Tx.Internal.TxOutTx
instance GHC.Show.Show Ledger.Tx.Internal.TxOutTx
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Tx.Internal.Tx
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Tx.Internal.TxInputType
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Tx.Internal.TxInput
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Tx.Internal.Withdrawal
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Tx.Internal.Certificate
instance GHC.Base.Semigroup Ledger.Tx.Internal.Tx
instance GHC.Base.Monoid Ledger.Tx.Internal.Tx
instance Data.ByteArray.Types.ByteArrayAccess Ledger.Tx.Internal.Tx
instance Cardano.Binary.ToCBOR.ToCBOR Ledger.Tx.Internal.TxOut
instance Cardano.Binary.FromCBOR.FromCBOR Ledger.Tx.Internal.TxOut
instance Codec.Serialise.Class.Serialise Ledger.Tx.Internal.TxOut
instance Control.DeepSeq.NFData Ledger.Tx.Internal.TxOut
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Tx.Internal.TxOut
instance Prettyprinter.Internal.Pretty Ledger.Tx.Internal.TxOut
instance Prettyprinter.Internal.Pretty Ledger.Tx.Internal.Certificate
instance Prettyprinter.Internal.Pretty Ledger.Tx.Internal.Withdrawal
instance Prettyprinter.Internal.Pretty Ledger.Tx.Internal.TxInput
instance Prettyprinter.Internal.Pretty Ledger.Tx.Internal.TxIn

module Ledger.CardanoWallet

-- | Emulated wallet with a key and a passphrase
data MockWallet
MockWallet :: Digest Blake2b_160 -> MockPrivateKey -> Maybe MockPrivateKey -> Maybe String -> MockWallet
[mwWalletId] :: MockWallet -> Digest Blake2b_160
[mwPaymentKey] :: MockWallet -> MockPrivateKey
[mwStakeKey] :: MockWallet -> Maybe MockPrivateKey
[mwPrintAs] :: MockWallet -> Maybe String

-- | Wrapper for config files and APIs
newtype WalletNumber
WalletNumber :: Integer -> WalletNumber
[getWallet] :: WalletNumber -> Integer
fromWalletNumber :: WalletNumber -> MockWallet
toWalletNumber :: MockWallet -> WalletNumber

-- | The wallets used in mockchain simulations by default. There are ten
--   wallets by default.
knownMockWallets :: [MockWallet]

-- | Get a known wallet from an <tt>Integer</tt> indexed from 1 to 10.
knownMockWallet :: Integer -> MockWallet
fromSeed :: ByteString -> Passphrase -> MockWallet
fromSeed' :: ByteString -> MockWallet

-- | A mock cardano address for the 'Testnet $ NetworkMagic 1' network.
mockWalletAddress :: MockWallet -> CardanoAddress

-- | Mock wallet's private key
paymentPrivateKey :: MockWallet -> PaymentPrivateKey

-- | The mock wallet's public key hash
paymentPubKeyHash :: MockWallet -> PaymentPubKeyHash

-- | The mock wallet's payment public key
paymentPubKey :: MockWallet -> PaymentPubKey

-- | The mock wallet's staking credentials
stakingCredential :: MockWallet -> Maybe StakingCredential

-- | The mock wallet's stake public key hash
stakePubKeyHash :: MockWallet -> Maybe StakePubKeyHash

-- | The mock wallet's stake public key
stakePubKey :: MockWallet -> Maybe StakePubKey
knownAddresses :: [CardanoAddress]
knownPaymentKeys :: Map PaymentPubKey PaymentPrivateKey
knownPaymentPublicKeys :: [PaymentPubKey]
knownPaymentPrivateKeys :: [PaymentPrivateKey]
instance GHC.Show.Show Ledger.CardanoWallet.MockWallet
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.CardanoWallet.WalletNumber
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.CardanoWallet.WalletNumber
instance Web.Internal.HttpApiData.FromHttpApiData Ledger.CardanoWallet.WalletNumber
instance Web.Internal.HttpApiData.ToHttpApiData Ledger.CardanoWallet.WalletNumber
instance GHC.Generics.Generic Ledger.CardanoWallet.WalletNumber
instance GHC.Classes.Ord Ledger.CardanoWallet.WalletNumber
instance GHC.Classes.Eq Ledger.CardanoWallet.WalletNumber
instance GHC.Show.Show Ledger.CardanoWallet.WalletNumber
instance GHC.Show.Show Ledger.CardanoWallet.MockPrivateKey
instance GHC.Classes.Eq Ledger.CardanoWallet.MockPrivateKey
instance GHC.Classes.Ord Ledger.CardanoWallet.MockPrivateKey
instance Data.Hashable.Class.Hashable Ledger.CardanoWallet.MockPrivateKey


-- | Copied from plutus-ledger-api because not exported
module Prettyprinter.Extras

-- | Newtype wrapper for deriving <a>Pretty</a> via a <a>Show</a> instance
newtype PrettyShow a
PrettyShow :: a -> PrettyShow a
[unPrettyShow] :: PrettyShow a -> a

-- | Overloaded conversion to <a>Doc</a>.
--   
--   Laws:
--   
--   <ol>
--   <li>output should be pretty. :-)</li>
--   </ol>
class Pretty a

-- | <pre>
--   &gt;&gt;&gt; pretty 1 &lt;+&gt; pretty "hello" &lt;+&gt; pretty 1.234
--   1 hello 1.234
--   </pre>
pretty :: Pretty a => a -> Doc ann

-- | <tt><a>prettyList</a></tt> is only used to define the <tt>instance
--   <a>Pretty</a> a =&gt; <a>Pretty</a> [a]</tt>. In normal circumstances
--   only the <tt><a>pretty</a></tt> function is used.
--   
--   <pre>
--   &gt;&gt;&gt; prettyList [1, 23, 456]
--   [1, 23, 456]
--   </pre>
prettyList :: Pretty a => [a] -> Doc ann

-- | Newtype wrapper for deriving <a>Pretty</a> for a <a>Foldable</a>
--   container by calling <a>toList</a>.
newtype PrettyFoldable f a
PrettyFoldable :: f a -> PrettyFoldable f a
[unPrettyFoldable] :: PrettyFoldable f a -> f a

-- | A <tt><a>Tagged</a> s b</tt> value is a value <tt>b</tt> with an
--   attached phantom type <tt>s</tt>. This can be used in place of the
--   more traditional but less safe idiom of passing in an undefined value
--   with the type, because unlike an <tt>(s -&gt; b)</tt>, a
--   <tt><a>Tagged</a> s b</tt> can't try to use the argument <tt>s</tt> as
--   a real value.
--   
--   Moreover, you don't have to rely on the compiler to inline away the
--   extra argument, because the newtype is "free"
--   
--   <a>Tagged</a> has kind <tt>k -&gt; * -&gt; *</tt> if the compiler
--   supports <tt>PolyKinds</tt>, therefore there is an extra <tt>k</tt>
--   showing in the instance haddocks that may cause confusion.
newtype Tagged (s :: k) b
Tagged :: b -> Tagged (s :: k) b
instance (Data.Foldable.Foldable f, Prettyprinter.Internal.Pretty a) => Prettyprinter.Internal.Pretty (Prettyprinter.Extras.PrettyFoldable f a)
instance GHC.Show.Show a => Prettyprinter.Internal.Pretty (Prettyprinter.Extras.PrettyShow a)
instance (GHC.TypeLits.KnownSymbol a, Prettyprinter.Internal.Pretty b) => Prettyprinter.Internal.Pretty (Data.Tagged.Tagged a b)

module Ledger.Index.Internal

-- | The UTxOs of a blockchain indexed by their references.
newtype UtxoIndex
UtxoIndex :: Map TxOutRef TxOut -> UtxoIndex
[getIndex] :: UtxoIndex -> Map TxOutRef TxOut

-- | A reason why a transaction is invalid.
data ValidationError

-- | The transaction output consumed by a transaction input could not be
--   found (either because it was already spent, or because there was no
--   transaction with the given hash on the blockchain).
TxOutRefNotFound :: TxOutRef -> ValidationError

-- | For pay-to-script outputs: evaluation of the validator script failed.
ScriptFailure :: ScriptError -> ValidationError

-- | An error from Cardano.Ledger validation
CardanoLedgerValidationError :: Text -> ValidationError
class AsValidationError r_a3en6
_ValidationError :: AsValidationError r_a3en6 => Prism' r_a3en6 ValidationError
_TxOutRefNotFound :: AsValidationError r_a3en6 => Prism' r_a3en6 TxOutRef
_ScriptFailure :: AsValidationError r_a3en6 => Prism' r_a3en6 ScriptError
_CardanoLedgerValidationError :: AsValidationError r_a3en6 => Prism' r_a3en6 Text
data ValidationPhase
Phase1 :: ValidationPhase
Phase2 :: ValidationPhase
type ValidationErrorInPhase = (ValidationPhase, ValidationError)
type ValidationSuccess = Map RdmrPtr ([Text], ExUnits)
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Index.Internal.ValidationPhase
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Index.Internal.ValidationPhase
instance GHC.Generics.Generic Ledger.Index.Internal.ValidationPhase
instance GHC.Show.Show Ledger.Index.Internal.ValidationPhase
instance GHC.Classes.Eq Ledger.Index.Internal.ValidationPhase
instance Prettyprinter.Internal.Pretty Ledger.Index.Internal.ValidationError
instance Prettyprinter.Internal.Pretty Ledger.Index.Internal.ValidationPhase
instance Ledger.Index.Internal.AsValidationError Ledger.Index.Internal.ValidationError
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Index.Internal.ValidationError
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Index.Internal.ValidationError
instance Control.DeepSeq.NFData Ledger.Index.Internal.UtxoIndex
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Index.Internal.UtxoIndex
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Index.Internal.UtxoIndex
instance Codec.Serialise.Class.Serialise Ledger.Index.Internal.UtxoIndex
instance GHC.Base.Monoid Ledger.Index.Internal.UtxoIndex
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Index.Internal.UtxoIndex
instance GHC.Base.Semigroup Ledger.Index.Internal.UtxoIndex
instance GHC.Classes.Eq Ledger.Index.Internal.UtxoIndex
instance GHC.Generics.Generic Ledger.Index.Internal.UtxoIndex
instance GHC.Show.Show Ledger.Index.Internal.UtxoIndex
instance GHC.Generics.Generic Ledger.Index.Internal.ValidationError
instance GHC.Show.Show Ledger.Index.Internal.ValidationError
instance GHC.Classes.Eq Ledger.Index.Internal.ValidationError


-- | Interface to the transaction types from 'cardano-api'
module Ledger.Tx.CardanoAPI
newtype CardanoBuildTx
CardanoBuildTx :: TxBodyContent BuildTx BabbageEra -> CardanoBuildTx
[getCardanoBuildTx] :: CardanoBuildTx -> TxBodyContent BuildTx BabbageEra

-- | Cardano tx from any era.
data SomeCardanoApiTx
[SomeTx] :: IsCardanoEra era => Tx era -> EraInMode era CardanoMode -> SomeCardanoApiTx
fromCardanoTxInsCollateral :: TxInsCollateral era -> [TxIn]
fromCardanoTotalCollateral :: TxTotalCollateral BabbageEra -> Maybe Value
fromCardanoReturnCollateral :: TxReturnCollateral CtxTx BabbageEra -> Maybe TxOut
toCardanoTxBody :: NetworkId -> PParams (BabbageEra StandardCrypto) -> [PaymentPubKeyHash] -> Tx -> Either ToCardanoError (TxBody BabbageEra)
toCardanoTxBodyContent :: NetworkId -> PParams (BabbageEra StandardCrypto) -> [PaymentPubKeyHash] -> Tx -> Either ToCardanoError CardanoBuildTx
toCardanoTxInsCollateral :: [TxInput] -> Either ToCardanoError (TxInsCollateral BabbageEra)
toCardanoTotalCollateral :: Maybe Value -> Either ToCardanoError (TxTotalCollateral BabbageEra)
toCardanoReturnCollateral :: Maybe TxOut -> TxReturnCollateral CtxTx BabbageEra
toCardanoTxInWitness :: Tx -> TxInputType -> Either ToCardanoError (Witness WitCtxTxIn BabbageEra)
toCardanoDatumWitness :: Maybe Datum -> ScriptDatum WitCtxTxIn
toCardanoTxInReferenceWitnessHeader :: Versioned TxOutRef -> Either ToCardanoError WitnessHeader
toCardanoTxInScriptWitnessHeader :: Versioned Script -> Either ToCardanoError WitnessHeader
toCardanoMintValue :: Tx -> Either ToCardanoError (TxMintValue BuildTx BabbageEra)
toCardanoMintWitness :: Redeemer -> Maybe (Versioned TxOutRef) -> Maybe (Versioned MintingPolicy) -> Either ToCardanoError (ScriptWitness WitCtxMint BabbageEra)
data ToCardanoError

-- | A C.TxBodyError converted to String
TxBodyError :: String -> ToCardanoError
DeserialisationError :: ToCardanoError
InvalidValidityRange :: ToCardanoError
ValueNotPureAda :: ToCardanoError
OutputHasZeroAda :: ToCardanoError
StakingPointersNotSupported :: ToCardanoError
SimpleScriptsNotSupportedToCardano :: ToCardanoError
MissingInputValidator :: ToCardanoError
MissingDatum :: ToCardanoError
MissingMintingPolicy :: ToCardanoError
ScriptPurposeNotSupported :: ScriptTag -> ToCardanoError
MissingMintingPolicyRedeemer :: ToCardanoError
MissingStakeValidator :: ToCardanoError
UnsupportedPlutusVersion :: Language -> ToCardanoError
Tag :: String -> ToCardanoError -> ToCardanoError
data FromCardanoError
SimpleScriptsNotSupported :: FromCardanoError
getRequiredSigners :: Tx BabbageEra -> [PaymentPubKeyHash]
fromPlutusIndex :: UtxoIndex -> Either (Either ValidationErrorInPhase ToCardanoError) (UTxO (BabbageEra StandardCrypto))
fromPlutusTxOut :: TxOut -> TxOut (BabbageEra StandardCrypto)
fromPlutusTxOutRef :: TxOutRef -> Either ToCardanoError (TxIn StandardCrypto)

module Ledger.Tx

-- | Non-Native Script language. This is an Enumerated type. This is
--   expected to be an open type. We will add new Constuctors to this type
--   as additional Non-Native scripting language as are added. We use an
--   enumerated type for two reasons. 1) We can write total functions by
--   case analysis over the constructors 2) We will use DataKinds to make
--   some datatypes indexed by Language For now, the only Non-Native
--   Scriting language is Plutus We might add new languages in the futures.
--   
--   Note that the the serialization of <a>Language</a> depends on the
--   ordering.
data Language
PlutusV1 :: Language
PlutusV2 :: Language

-- | Create a transaction output locked by a public key.
pubKeyHashTxOut :: Value -> PubKeyHash -> TxOut

-- | Whether the output is a pay-to-script output.
isPayToScriptOut :: TxOut -> Bool

-- | Whether the output is a pay-to-pubkey output.
isPubKeyOut :: TxOut -> Bool

-- | The datum attached to a <a>TxOut</a>, if there is one.
txOutDatum :: TxOut -> Maybe DatumHash

-- | A transaction ID, using a SHA256 hash as the transaction id.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A tag indicating the type of script that we are pointing to.
data ScriptTag
Spend :: ScriptTag
Mint :: ScriptTag
Cert :: ScriptTag
Reward :: ScriptTag

-- | A redeemer pointer is a pair of a script type tag t and an index i,
--   picking out the ith script of type t in the transaction.
data RedeemerPtr
RedeemerPtr :: ScriptTag -> Integer -> RedeemerPtr
type Redeemers = Map RedeemerPtr Redeemer

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | A script of some kind with its Plutus language version
data Versioned script
Versioned :: script -> Language -> Versioned script
[unversioned] :: Versioned script -> script
[version] :: Versioned script -> Language
type ReferenceScript = ReferenceScript BabbageEra

-- | A <a>TxOut</a> along with the <a>Tx</a> it comes from, which may have
--   additional information e.g. the full data script that goes with the
--   <a>TxOut</a>.
data TxOutTx
TxOutTx :: Tx -> TxOut -> TxOutTx
[txOutTxTx] :: TxOutTx -> Tx
[txOutTxOut] :: TxOutTx -> TxOut

-- | A babbage era transaction without witnesses for its inputs.
data TxStripped
TxStripped :: [TxOutRef] -> [TxOutRef] -> [TxOut] -> !Value -> !Value -> TxStripped

-- | The inputs to this transaction, as transaction output references only.
[txStrippedInputs] :: TxStripped -> [TxOutRef]

-- | The reference inputs to this transaction, as transaction output
--   references only.
[txStrippedReferenceInputs] :: TxStripped -> [TxOutRef]

-- | The outputs of this transation.
[txStrippedOutputs] :: TxStripped -> [TxOut]

-- | The <a>Value</a> minted by this transaction.
[txStrippedMint] :: TxStripped -> !Value

-- | The fee for this transaction.
[txStrippedFee] :: TxStripped -> !Value

-- | A Babbage-era transaction, including witnesses for its inputs.
data Tx
Tx :: [TxInput] -> [TxInput] -> [TxInput] -> [TxOut] -> Maybe TxOut -> Maybe Value -> !Value -> !Value -> !SlotRange -> MintingWitnessesMap -> [Withdrawal] -> [Certificate] -> Map PubKey Signature -> ScriptsMap -> Map DatumHash Datum -> Maybe BuiltinByteString -> Tx

-- | The inputs to this transaction.
[txInputs] :: Tx -> [TxInput]

-- | The reference inputs to this transaction.
[txReferenceInputs] :: Tx -> [TxInput]

-- | The collateral inputs to cover the fees in case validation of the
--   transaction fails.
[txCollateralInputs] :: Tx -> [TxInput]

-- | The outputs of this transaction, ordered so they can be referenced by
--   index.
[txOutputs] :: Tx -> [TxOut]

-- | The output of the remaining collateral after covering fees in case
--   validation of the transaction fails.
[txReturnCollateral] :: Tx -> Maybe TxOut

-- | The total collateral to be paid in case validation of the transaction
--   fails.
[txTotalCollateral] :: Tx -> Maybe Value

-- | The <a>Value</a> minted by this transaction.
[txMint] :: Tx -> !Value

-- | The fee for this transaction.
[txFee] :: Tx -> !Value

-- | The <a>SlotRange</a> during which this transaction may be validated.
[txValidRange] :: Tx -> !SlotRange

-- | The witnesses that must be present to check minting conditions matched
--   with their redeemers.
[txMintingWitnesses] :: Tx -> MintingWitnessesMap

-- | Withdrawals, contains redeemers.
[txWithdrawals] :: Tx -> [Withdrawal]

-- | Certificates, contains redeemers.
[txCertificates] :: Tx -> [Certificate]

-- | Signatures of this transaction.
[txSignatures] :: Tx -> Map PubKey Signature

-- | Scripts for all script credentials mentioned in this tx.
[txScripts] :: Tx -> ScriptsMap

-- | Datum objects recorded on this transaction.
[txData] :: Tx -> Map DatumHash Datum

-- | Metadata
[txMetadata] :: Tx -> Maybe BuiltinByteString
type MintingWitnessesMap = Map MintingPolicyHash (Redeemer, Maybe (Versioned TxOutRef))
type ScriptsMap = Map ScriptHash (Versioned Script)

-- | Validator, redeemer, and data scripts of a transaction input that
--   spends a "pay to script" output. inScripts :: Tx -&gt; TxInput -&gt;
--   Maybe (LedgerPlutusVersion, Validator, Redeemer, Datum) inScripts tx
--   i@TxInput{txInputType=TxConsumeScriptAddress pv _ _ _} = case txInType
--   $ fillTxInputWitnesses tx i of Just (ConsumeScriptAddress v r d) -&gt;
--   Just (pv, v, r, d) _ -&gt; Nothing inScripts _ _ = Nothing
newtype TxOut
TxOut :: TxOut CtxTx BabbageEra -> TxOut
[getTxOut] :: TxOut -> TxOut CtxTx BabbageEra
data Certificate
Certificate :: DCert -> Maybe Redeemer -> Certificate
[certificateDcert] :: Certificate -> DCert

-- | redeemer for script credential
[certificateRedeemer] :: Certificate -> Maybe Redeemer

-- | Stake withdrawal, if applicable the script should be included in
--   txScripts.
data Withdrawal
Withdrawal :: Credential -> Integer -> Maybe Redeemer -> Withdrawal

-- | staking credential
[withdrawalCredential] :: Withdrawal -> Credential

-- | amount of withdrawal in Lovelace, must withdraw all eligible amount
[withdrawalAmount] :: Withdrawal -> Integer

-- | redeemer for script credential
[withdrawalRedeemer] :: Withdrawal -> Maybe Redeemer

-- | A transaction input, consisting of a transaction output reference and
--   an input type. Differs with TxIn by: TxIn *maybe* contains *full* data
--   witnesses, TxInput always contains redeemer witness, but
--   datum/validator hashes.
data TxInput
TxInput :: !TxOutRef -> !TxInputType -> TxInput
[txInputRef] :: TxInput -> !TxOutRef
[txInputType] :: TxInput -> !TxInputType

-- | The type of a transaction input with hashes.
data TxInputType

-- | A transaction input that consumes (with a validator hash) or
--   references (with a txOutRef) a script address with the given the
--   redeemer and datum hash.
TxScriptAddress :: !Redeemer -> !Either ValidatorHash (Versioned TxOutRef) -> !Maybe DatumHash -> TxInputType

-- | A transaction input that consumes a public key address.
TxConsumePublicKeyAddress :: TxInputType

-- | Consume a simple script
TxConsumeSimpleScriptAddress :: TxInputType

-- | A transaction input, consisting of a transaction output reference and
--   an input type.
data TxIn
TxIn :: !TxOutRef -> Maybe TxInType -> TxIn
[txInRef] :: TxIn -> !TxOutRef
[txInType] :: TxIn -> Maybe TxInType

-- | The type of a transaction input.
data TxInType

-- | A transaction input that consumes (with a validator) or references
--   (with a txOutRef) a script address with the given the redeemer and
--   datum. Datum is optional if the input refers to a script output which
--   contains an inline datum
ScriptAddress :: !Either (Versioned Validator) (Versioned TxOutRef) -> !Redeemer -> !Maybe Datum -> TxInType

-- | A transaction input that consumes a public key address.
ConsumePublicKeyAddress :: TxInType

-- | Consume a simple script
ConsumeSimpleScriptAddress :: TxInType

-- | A transaction input that spends a "pay to public key" output, given
--   the witness.
pubKeyTxIn :: TxOutRef -> TxIn

-- | A transaction input that spends a "pay to script" output, given
--   witnesses. Datum is optional if the input refers to a script output
--   which contains an inline datum
scriptTxIn :: TxOutRef -> Versioned Validator -> Redeemer -> Maybe Datum -> TxIn

-- | The <a>TxOutRef</a> spent by a transaction input.
inputRef :: Lens' TxInput TxOutRef

-- | The type of a transaction input.
inputType :: Lens' TxInput TxInputType

-- | Validator, redeemer, and data scripts of a transaction input that
--   spends a "pay to script" output.
inScripts :: TxIn -> Maybe (Versioned Validator, Redeemer, Maybe Datum)

-- | The <a>TxOutRef</a> spent by a transaction input.
inRef :: Lens' TxInput TxOutRef

-- | The type of a transaction input.
inType :: Lens' TxInput TxInputType

-- | Filter to get only the pubkey inputs.
pubKeyTxInputs :: Fold [TxInput] TxInput

-- | Filter to get only the scripts that consume or reference a script
--   address
scriptTxInputs :: Fold [TxInput] TxInput

-- | Filter to get only the scripts that reference a script address
referenceScriptTxInputs :: Fold [TxInput] TxInput
toSizedTxOut :: TxOut -> Sized (TxOut StandardBabbage)

-- | The inputs of a transaction.
inputs :: Lens' Tx [TxInput]

-- | The reference inputs of a transaction.
referenceInputs :: Lens' Tx [TxInput]

-- | The collateral inputs of a transaction for paying fees when validating
--   the transaction fails.
collateralInputs :: Lens' Tx [TxInput]

-- | The outputs of a transaction.
outputs :: Lens' Tx [TxOut]
returnCollateral :: Lens' Tx (Maybe TxOut)
totalCollateral :: Lens' Tx (Maybe Value)

-- | The validity range of a transaction.
validRange :: Lens' Tx SlotRange
signatures :: Lens' Tx (Map PubKey Signature)
fee :: Lens' Tx Value
mint :: Lens' Tx Value
mintScripts :: Lens' Tx MintingWitnessesMap
scriptWitnesses :: Lens' Tx ScriptsMap
datumWitnesses :: Lens' Tx (Map DatumHash Datum)

-- | The inputs of a transaction.
metadata :: Lens' Tx (Maybe BuiltinByteString)
lookupSignature :: PubKey -> Tx -> Maybe Signature
lookupDatum :: Tx -> DatumHash -> Maybe Datum

-- | Check that all values in a transaction are non-negative.
validValuesTx :: Tx -> Bool
txOutValue :: TxOut -> Value
outValue :: Lens TxOut TxOut Value (TxOutValue BabbageEra)
outValue' :: Lens' TxOut (TxOutValue BabbageEra)
strip :: Tx -> TxStripped
txOutTxDatum :: TxOutTx -> Maybe Datum

-- | Get a hash from the stored TxOutDatum (either dirctly or by hashing
--   the inlined datum)
txOutDatumHash :: TxOut -> Maybe DatumHash
txOutPubKey :: TxOut -> Maybe PubKeyHash
txOutAddress :: TxOut -> CardanoAddress
outAddress :: Lens' TxOut (AddressInEra BabbageEra)
outDatumHash :: Lens TxOut TxOut (Maybe DatumHash) (TxOutDatum CtxTx BabbageEra)
txOutReferenceScript :: TxOut -> ReferenceScript
outReferenceScript :: Lens' TxOut ReferenceScript
lookupScript :: ScriptsMap -> ScriptHash -> Maybe (Versioned Script)
lookupValidator :: ScriptsMap -> ValidatorHash -> Maybe (Versioned Validator)

-- | The transaction output references consumed by a transaction.
spentOutputs :: Tx -> [TxOutRef]

-- | The transaction output references referenced by a transaction.
referencedOutputs :: Tx -> [TxOutRef]
lookupMintingPolicy :: ScriptsMap -> MintingPolicyHash -> Maybe (Versioned MintingPolicy)
lookupStakeValidator :: ScriptsMap -> StakeValidatorHash -> Maybe (Versioned StakeValidator)

-- | Translate TxInput to old Plutus.V1.Ledger.Api TxIn taking script and
--   datum witnesses from Tx.
fillTxInputWitnesses :: Tx -> TxInput -> TxIn
pubKeyTxInput :: TxOutRef -> TxInput

-- | Add minting policy together with the redeemer into txMintingWitnesses
--   and txScripts accordingly. Doesn't alter txMint.
addMintingPolicy :: Versioned MintingPolicy -> (Redeemer, Maybe (Versioned TxOutRef)) -> Tx -> Tx

-- | Add validator together with the redeemer and datum into txInputs,
--   txData and txScripts accordingly. Datum is optional if the input
--   refers to a script output which contains an inline datum
addScriptTxInput :: TxOutRef -> Versioned Validator -> Redeemer -> Maybe Datum -> Tx -> Tx

-- | Add script reference together with the redeemer and datum into
--   txInputs and txData accordingly. Datum is optional if the input refers
--   to a script output which contains an inline datum
addReferenceTxInput :: TxOutRef -> Versioned TxOutRef -> Redeemer -> Maybe Datum -> Tx -> Tx
txRedeemers :: Tx -> Map ScriptPurpose Redeemer
txSpendingRedeemers :: Tx -> Map TxOutRef Redeemer
txMintingRedeemers :: Tx -> Map MintingPolicyHash Redeemer
txRewardingRedeemers :: Tx -> Map Credential Redeemer
txCertifyingRedeemers :: Tx -> Map DCert Redeemer

-- | Offchain view of a transaction output.
data DecoratedTxOut
PublicKeyDecoratedTxOut :: PubKeyHash -> Maybe StakingCredential -> Value -> Maybe (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> DecoratedTxOut

-- | The pubKey hash that protects the transaction address
[_decoratedTxOutPubKeyHash] :: DecoratedTxOut -> PubKeyHash

-- | The staking credential of the transaction address, if any
[_decoratedTxOutStakingCredential] :: DecoratedTxOut -> Maybe StakingCredential

-- | Value of the transaction output.
[_decoratedTxOutValue] :: DecoratedTxOut -> Value

-- | Optional datum (inline datum or datum in transaction body) attached to
--   the transaction output.
[_decoratedTxOutPubKeyDatum] :: DecoratedTxOut -> Maybe (DatumHash, DatumFromQuery)

-- | Value of the transaction output.
[_decoratedTxOutReferenceScript] :: DecoratedTxOut -> Maybe (Versioned Script)
ScriptDecoratedTxOut :: ValidatorHash -> Maybe StakingCredential -> Value -> (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe (Versioned Validator) -> DecoratedTxOut

-- | The hash of the script that protects the transaction address
[_decoratedTxOutValidatorHash] :: DecoratedTxOut -> ValidatorHash

-- | The staking credential of the transaction address, if any
[_decoratedTxOutStakingCredential] :: DecoratedTxOut -> Maybe StakingCredential

-- | Value of the transaction output.
[_decoratedTxOutValue] :: DecoratedTxOut -> Value

-- | Datum attached to the transaction output, either in full (inline datum
--   or datum in transaction body) or as a hash reference. A transaction
--   output protected by a Plutus script is guardateed to have an
--   associated datum.
[_decoratedTxOutScriptDatum] :: DecoratedTxOut -> (DatumHash, DatumFromQuery)

-- | Value of the transaction output.
[_decoratedTxOutReferenceScript] :: DecoratedTxOut -> Maybe (Versioned Script)

-- | Full version of the validator protecting the transaction output
[_decoratedTxOutValidator] :: DecoratedTxOut -> Maybe (Versioned Validator)
toTxOut :: NetworkId -> DecoratedTxOut -> Either ToCardanoError TxOut

-- | Converts a transaction output from the chain index to the
--   plutus-ledger-api transaction output.
--   
--   Note that <a>DecoratedTxOut</a> supports features such inline datums
--   and reference scripts which are not supported by V1 TxOut. Converting
--   from <a>DecoratedTxOut</a> to <a>TxOut</a> and back is therefore
--   lossy.
toTxInfoTxOut :: DecoratedTxOut -> TxOut
decoratedTxOutPubKeyHash :: Traversal' DecoratedTxOut PubKeyHash
decoratedTxOutAddress :: Getter DecoratedTxOut Address
decoratedTxOutDatum :: Traversal' DecoratedTxOut (DatumHash, DatumFromQuery)
decoratedTxOutValue :: Lens' DecoratedTxOut Value
decoratedTxOutPubKeyDatum :: Traversal' DecoratedTxOut (Maybe (DatumHash, DatumFromQuery))
decoratedTxOutScriptDatum :: Traversal' DecoratedTxOut (DatumHash, DatumFromQuery)
decoratedTxOutStakingCredential :: Lens' DecoratedTxOut (Maybe StakingCredential)
decoratedTxOutReferenceScript :: Lens' DecoratedTxOut (Maybe (Versioned Script))
decoratedTxOutValidatorHash :: Traversal' DecoratedTxOut ValidatorHash
decoratedTxOutValidator :: Traversal' DecoratedTxOut (Maybe (Versioned Validator))
_PublicKeyDecoratedTxOut :: Prism' DecoratedTxOut (PubKeyHash, Maybe StakingCredential, Value, Maybe (DatumHash, DatumFromQuery), Maybe (Versioned Script))
_ScriptDecoratedTxOut :: Prism' DecoratedTxOut (ValidatorHash, Maybe StakingCredential, Value, (DatumHash, DatumFromQuery), Maybe (Versioned Script), Maybe (Versioned Validator))
_decoratedTxOutAddress :: DecoratedTxOut -> Address
mkDecoratedTxOut :: CardanoAddress -> Value -> (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> DecoratedTxOut
mkPubkeyDecoratedTxOut :: CardanoAddress -> Value -> Maybe (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe DecoratedTxOut
mkScriptDecoratedTxOut :: CardanoAddress -> Value -> (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe (Versioned Validator) -> Maybe DecoratedTxOut

-- | A datum in a transaction output that comes from a chain index query.
data DatumFromQuery
DatumUnknown :: DatumFromQuery
DatumInline :: Datum -> DatumFromQuery
DatumInBody :: Datum -> DatumFromQuery
datumInDatumFromQuery :: Traversal' DatumFromQuery Datum
data CardanoTx
EmulatorTx :: Tx -> CardanoTx
[_emulatorTx] :: CardanoTx -> Tx
CardanoApiTx :: SomeCardanoApiTx -> CardanoTx
[_cardanoApiTx] :: CardanoTx -> SomeCardanoApiTx
cardanoApiTx :: Traversal' CardanoTx SomeCardanoApiTx
emulatorTx :: Traversal' CardanoTx Tx
onCardanoTx :: (Tx -> r) -> (SomeCardanoApiTx -> r) -> CardanoTx -> r
cardanoTxMap :: (Tx -> Tx) -> (SomeCardanoApiTx -> SomeCardanoApiTx) -> CardanoTx -> CardanoTx
getCardanoTxId :: CardanoTx -> TxId
getCardanoTxInputs :: CardanoTx -> [TxIn]
getCardanoTxCollateralInputs :: CardanoTx -> [TxIn]
getCardanoTxOutRefs :: CardanoTx -> [(TxOut, TxOutRef)]
getCardanoTxOutputs :: CardanoTx -> [TxOut]
getCardanoTxRedeemers :: CardanoTx -> Map ScriptPurpose Redeemer
getCardanoTxSpentOutputs :: CardanoTx -> Set TxOutRef
getCardanoTxProducedOutputs :: CardanoTx -> Map TxOutRef TxOut
getCardanoTxReturnCollateral :: CardanoTx -> Maybe TxOut
getCardanoTxProducedReturnCollateral :: CardanoTx -> Map TxOutRef TxOut
getCardanoTxTotalCollateral :: CardanoTx -> Maybe Value
getCardanoTxFee :: CardanoTx -> Value
getCardanoTxMint :: CardanoTx -> Value
getCardanoTxValidityRange :: CardanoTx -> SlotRange
getCardanoTxData :: CardanoTx -> Map DatumHash Datum

-- | Cardano tx from any era.
data SomeCardanoApiTx
[SomeTx] :: IsCardanoEra era => Tx era -> EraInMode era CardanoMode -> SomeCardanoApiTx
pattern CardanoApiEmulatorEraTx :: Tx BabbageEra -> SomeCardanoApiTx
data ToCardanoError

-- | A C.TxBodyError converted to String
TxBodyError :: String -> ToCardanoError
DeserialisationError :: ToCardanoError
InvalidValidityRange :: ToCardanoError
ValueNotPureAda :: ToCardanoError
OutputHasZeroAda :: ToCardanoError
StakingPointersNotSupported :: ToCardanoError
SimpleScriptsNotSupportedToCardano :: ToCardanoError
MissingInputValidator :: ToCardanoError
MissingDatum :: ToCardanoError
MissingMintingPolicy :: ToCardanoError
ScriptPurposeNotSupported :: ScriptTag -> ToCardanoError
MissingMintingPolicyRedeemer :: ToCardanoError
MissingStakeValidator :: ToCardanoError
UnsupportedPlutusVersion :: Language -> ToCardanoError
Tag :: String -> ToCardanoError -> ToCardanoError

-- | Sign the transaction with a <a>PrivateKey</a> and passphrase
--   (ByteString) and add the signature to the transaction's list of
--   signatures.
addSignature :: PrivateKey -> Passphrase -> Tx -> Tx

-- | Sign the transaction with a <a>PrivateKey</a> that has no passphrase
--   and add the signature to the transaction's list of signatures
addSignature' :: PrivateKey -> Tx -> Tx
addCardanoTxSignature :: PrivateKey -> CardanoTx -> CardanoTx

-- | Create a transaction output locked by a public payment key and
--   optionnaly a public stake key.
pubKeyTxOut :: Value -> PaymentPubKey -> Maybe StakingCredential -> Either ToCardanoError TxOut

-- | Update a map of unspent transaction outputs and signatures based on
--   the inputs and outputs of a transaction.
updateUtxo :: CardanoTx -> Map TxOutRef TxOut -> Map TxOutRef TxOut

-- | Update a map of unspent transaction outputs and signatures based on
--   the collateral inputs of a transaction (for when it is invalid).
updateUtxoCollateral :: CardanoTx -> Map TxOutRef TxOut -> Map TxOutRef TxOut

-- | A list of a transaction's outputs paired with a <a>TxOutRef</a>s
--   referring to them.
txOutRefs :: Tx -> [(TxOut, TxOutRef)]

-- | The unspent outputs of a transaction.
unspentOutputsTx :: Tx -> Map TxOutRef TxOut
getTxBodyContentInputs :: TxBodyContent ctx era -> [TxIn]
getTxBodyContentCollateralInputs :: TxBodyContent ctx era -> [TxIn]
getTxBodyContentReturnCollateral :: TxBodyContent ctx BabbageEra -> Maybe TxOut
getTxBodyContentMint :: TxBodyContent ctx era -> Value
txBodyContentIns :: Lens' (TxBodyContent BuildTx BabbageEra) [(TxIn, BuildTxWith BuildTx (Witness WitCtxTxIn BabbageEra))]
txBodyContentCollateralIns :: Lens' (TxBodyContent BuildTx BabbageEra) [TxIn]
txBodyContentOuts :: Lens' (TxBodyContent ctx BabbageEra) [TxOut]

-- | Compute the id of a transaction.
txId :: Tx -> TxId
instance Prettyprinter.Internal.Pretty Ledger.Tx.CardanoTx
instance Prettyprinter.Internal.Pretty Ledger.Tx.CardanoAPI.Internal.SomeCardanoApiTx
instance Prettyprinter.Internal.Pretty Ledger.Tx.CardanoAPI.Internal.CardanoBuildTx
instance Prettyprinter.Internal.Pretty Ledger.Tx.Internal.Tx
instance Codec.Serialise.Class.Serialise Ledger.Tx.CardanoTx
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Tx.CardanoTx
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.CardanoTx
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.CardanoTx
instance GHC.Generics.Generic Ledger.Tx.CardanoTx
instance GHC.Show.Show Ledger.Tx.CardanoTx
instance GHC.Classes.Eq Ledger.Tx.CardanoTx
instance Prettyprinter.Internal.Pretty Ledger.Tx.DecoratedTxOut
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Tx.DecoratedTxOut
instance Control.DeepSeq.NFData Ledger.Tx.DecoratedTxOut
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.DecoratedTxOut
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.DecoratedTxOut
instance GHC.Generics.Generic Ledger.Tx.DecoratedTxOut
instance Codec.Serialise.Class.Serialise Ledger.Tx.DecoratedTxOut
instance GHC.Classes.Eq Ledger.Tx.DecoratedTxOut
instance GHC.Show.Show Ledger.Tx.DecoratedTxOut
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Tx.DatumFromQuery
instance Control.DeepSeq.NFData Ledger.Tx.DatumFromQuery
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.DatumFromQuery
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.DatumFromQuery
instance GHC.Generics.Generic Ledger.Tx.DatumFromQuery
instance Codec.Serialise.Class.Serialise Ledger.Tx.DatumFromQuery
instance GHC.Classes.Eq Ledger.Tx.DatumFromQuery
instance GHC.Show.Show Ledger.Tx.DatumFromQuery

module Ledger.Blockchain

-- | A transaction on the blockchain. Invalid transactions are still put on
--   the chain to be able to collect fees.
data OnChainTx
Invalid :: CardanoTx -> OnChainTx
Valid :: CardanoTx -> OnChainTx
_Valid :: Prism' OnChainTx CardanoTx
_Invalid :: Prism' OnChainTx CardanoTx

-- | A block on the blockchain. This is just a list of transactions
--   following on from the chain so far.
type Block = [OnChainTx]

-- | Block identifier (usually a hash)
newtype BlockId
BlockId :: ByteString -> BlockId
[getBlockId] :: BlockId -> ByteString

-- | A blockchain, which is just a list of blocks, starting with the
--   newest.
type Blockchain = [Block]

-- | Information about the state of the blockchain and about the
--   transaction that is currently being validated, represented as a value
--   in <tt>Data</tt>.
newtype Context
Context :: BuiltinData -> Context
eitherTx :: (CardanoTx -> r) -> (CardanoTx -> r) -> OnChainTx -> r
unOnChain :: OnChainTx -> CardanoTx
onChainTxIsValid :: OnChainTx -> Bool

-- | Outputs consumed from the UTXO set by the <a>OnChainTx</a>
consumableInputs :: OnChainTx -> [TxIn]

-- | Outputs added to the UTXO set by the <a>OnChainTx</a>
outputsProduced :: OnChainTx -> Map TxOutRef TxOut

-- | Lookup a transaction in a <a>Blockchain</a> by its id.
transaction :: Blockchain -> TxId -> Maybe OnChainTx

-- | Determine the unspent output that an input refers to
out :: Blockchain -> TxOutRef -> Maybe TxOut

-- | Determine the unspent value that a transaction output refers to.
value :: Blockchain -> TxOutRef -> Maybe Value

-- | The unspent outputs of a transaction.
unspentOutputsTx :: Tx -> Map TxOutRef TxOut

-- | The transaction output references consumed by a transaction.
spentOutputs :: Tx -> [TxOutRef]

-- | The unspent transaction outputs of the ledger as a whole.
unspentOutputs :: Blockchain -> Map TxOutRef TxOut

-- | Determine the data script that a transaction output refers to.
datumTxo :: Blockchain -> TxOutRef -> Maybe DatumHash

-- | Update a map of unspent transaction outputs and signatures based on
--   the inputs and outputs of a transaction.
updateUtxo :: CardanoTx -> Map TxOutRef TxOut -> Map TxOutRef TxOut
txOutPubKey :: TxOut -> Maybe PubKeyHash

-- | Determine the public key that locks a transaction output, if there is
--   one.
pubKeyTxo :: Blockchain -> TxOutRef -> Maybe PubKeyHash

-- | Check that all values in a transaction are non-negative.
validValuesTx :: Tx -> Bool
instance GHC.Generics.Generic Ledger.Blockchain.BlockId
instance GHC.Classes.Ord Ledger.Blockchain.BlockId
instance GHC.Classes.Eq Ledger.Blockchain.BlockId
instance Codec.Serialise.Class.Serialise Ledger.Blockchain.OnChainTx
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Blockchain.OnChainTx
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Blockchain.OnChainTx
instance GHC.Generics.Generic Ledger.Blockchain.OnChainTx
instance GHC.Show.Show Ledger.Blockchain.OnChainTx
instance GHC.Classes.Eq Ledger.Blockchain.OnChainTx
instance Prettyprinter.Internal.Pretty Ledger.Blockchain.OnChainTx
instance GHC.Show.Show Ledger.Blockchain.BlockId
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Blockchain.BlockId
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Blockchain.BlockId
instance Data.OpenApi.Internal.Schema.ToSchema Ledger.Blockchain.BlockId
instance Prettyprinter.Internal.Pretty Ledger.Blockchain.BlockId


-- | <a>AddressMap</a>s and functions for working on them.
--   
--   <a>AddressMap</a>s are used to represent the limited knowledge about
--   the state of the ledger that the wallet retains. Rather than keeping
--   the entire ledger (which can be very large) the wallet only tracks the
--   UTxOs at particular addresses.
module Ledger.AddressMap

-- | A map of <tt>Address</tt>es and their unspent outputs.
newtype AddressMap
AddressMap :: Map CardanoAddress UtxoMap -> AddressMap
[getAddressMap] :: AddressMap -> Map CardanoAddress UtxoMap
type UtxoMap = Map TxOutRef (CardanoTx, TxOut)

-- | Add an address with no unspent outputs to a map. If the address
--   already exists, do nothing.
addAddress :: CardanoAddress -> AddressMap -> AddressMap

-- | Add a list of <tt>Address</tt>es with no unspent outputs to the map.
addAddresses :: [CardanoAddress] -> AddressMap -> AddressMap

-- | Filter the transaction output references in the map
filterRefs :: (TxOutRef -> (CardanoTx, TxOut) -> Bool) -> AddressMap -> AddressMap

-- | Get the funds available at a particular address.
fundsAt :: CardanoAddress -> Lens' AddressMap UtxoMap

-- | The total value of unspent outputs (which the map knows about) at an
--   address.
values :: AddressMap -> Map CardanoAddress Value

-- | Walk through the address map, applying an effectful function to each
--   entry.
traverseWithKey :: Applicative f => (CardanoAddress -> Map TxOutRef (CardanoTx, TxOut) -> f (Map TxOutRef (CardanoTx, TxOut))) -> AddressMap -> f AddressMap

-- | An address map with a single unspent transaction output.
singleton :: (CardanoAddress, TxOutRef, CardanoTx, TxOut) -> AddressMap

-- | Create an <a>AddressMap</a> with the unspent outputs of a single
--   transaction.
fromTxOutputs :: OnChainTx -> AddressMap

-- | Create a map of unspent transaction outputs to their addresses (the
--   "inverse" of an <a>AddressMap</a>, without the values)
knownAddresses :: AddressMap -> Map TxOutRef CardanoAddress

-- | Update an <a>AddressMap</a> with the inputs and outputs of a new
--   transaction. <tt>updateAddresses</tt> does <i>not</i> add or remove
--   any keys from the map.
updateAddresses :: OnChainTx -> AddressMap -> AddressMap

-- | Update an <a>AddressMap</a> with the inputs and outputs of a new
--   transaction, including all addresses in the transaction.
updateAllAddresses :: OnChainTx -> AddressMap -> AddressMap

-- | Restrict an <a>AddressMap</a> to a set of addresses.
restrict :: AddressMap -> Set CardanoAddress -> AddressMap

-- | Get the set of all addresses that the transaction spends outputs from
--   or produces outputs to
addressesTouched :: AddressMap -> OnChainTx -> Set CardanoAddress
outRefMap :: AddressMap -> Map TxOutRef (CardanoTx, TxOut)
outputsMapFromTxForAddress :: CardanoAddress -> OnChainTx -> Map TxOutRef (CardanoTx, TxOut)

-- | The unspent transaction outputs of the ledger as a whole.
fromChain :: Blockchain -> AddressMap
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.AddressMap.AddressMap
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.AddressMap.AddressMap
instance Codec.Serialise.Class.Serialise Ledger.AddressMap.AddressMap
instance GHC.Generics.Generic Ledger.AddressMap.AddressMap
instance GHC.Classes.Eq Ledger.AddressMap.AddressMap
instance GHC.Show.Show Ledger.AddressMap.AddressMap
instance GHC.Base.Semigroup Ledger.AddressMap.AddressMap
instance GHC.Base.Monoid Ledger.AddressMap.AddressMap
instance Control.Lens.At.Ixed Ledger.AddressMap.AddressMap
instance Control.Lens.At.At Ledger.AddressMap.AddressMap


-- | An index of unspent transaction outputs, and some functions for
--   validating transactions using the index.
module Ledger.Index

-- | The UTxOs of a blockchain indexed by their references.
newtype UtxoIndex
UtxoIndex :: Map TxOutRef TxOut -> UtxoIndex
[getIndex] :: UtxoIndex -> Map TxOutRef TxOut

-- | Update the index for the addition of a transaction.
insert :: CardanoTx -> UtxoIndex -> UtxoIndex

-- | Update the index for the addition of only the collateral inputs of a
--   failed transaction.
insertCollateral :: CardanoTx -> UtxoIndex -> UtxoIndex

-- | Update the index for the addition of a block.
insertBlock :: Block -> UtxoIndex -> UtxoIndex

-- | Create an index of all UTxOs on the chain.
initialise :: Blockchain -> UtxoIndex

-- | Find an unspent transaction output by the <a>TxOutRef</a> that spends
--   it.
lookup :: MonadError ValidationError m => TxOutRef -> UtxoIndex -> m TxOut

-- | A reason why a transaction is invalid.
data ValidationError

-- | The transaction output consumed by a transaction input could not be
--   found (either because it was already spent, or because there was no
--   transaction with the given hash on the blockchain).
TxOutRefNotFound :: TxOutRef -> ValidationError

-- | For pay-to-script outputs: evaluation of the validator script failed.
ScriptFailure :: ScriptError -> ValidationError

-- | An error from Cardano.Ledger validation
CardanoLedgerValidationError :: Text -> ValidationError
_TxOutRefNotFound :: AsValidationError r_a3en6 => Prism' r_a3en6 TxOutRef
_ScriptFailure :: AsValidationError r_a3en6 => Prism' r_a3en6 ScriptError
_CardanoLedgerValidationError :: AsValidationError r_a3en6 => Prism' r_a3en6 Text
type ValidationSuccess = Map RdmrPtr ([Text], ExUnits)
type ValidationErrorInPhase = (ValidationPhase, ValidationError)
data ValidationPhase
Phase1 :: ValidationPhase
Phase2 :: ValidationPhase

-- | Minimum transaction fee.
minFee :: Tx -> Value

-- | TODO Should be calculated based on the maximum script size permitted
--   on the Cardano blockchain.
maxFee :: Ada

-- | Adjust a single transaction output so it contains at least the minimum
--   amount of Ada and return the adjustment (if any) and the updated
--   TxOut.
adjustTxOut :: PParams (BabbageEra StandardCrypto) -> TxOut -> Either ToCardanoError ([Ada], TxOut)

-- | Exact computation of the mimimum Ada required for a given TxOut. TODO:
--   Should be moved to cardano-api-extended once created
minAdaTxOut :: PParams (BabbageEra StandardCrypto) -> TxOut -> Ada

-- | Provide a reasonable estimate of the mimimum of Ada required for a
--   TxOut.
--   
--   An exact estimate of the the mimimum of Ada in a TxOut is determined
--   by two things: - the <tt>PParams</tt>, more precisely its
--   <tt>coinPerUTxOWord</tt> parameter. - the size of the <a>TxOut</a>. In
--   many situations though, we need to determine a plausible value for the
--   minimum of Ada needed for a TxOut without knowing much of the
--   <a>TxOut</a>. This function provides a value big enough to balance
--   UTxOs without a large inlined data (larger than a hash) nor a complex
--   val with a lot of minted values. It's superior to the lowest minimum
--   needed for an UTxO, as the lowest value require no datum. An estimate
--   of the minimum required Ada for each tx output.
minAdaTxOutEstimated :: Ada
maxMinAdaTxOut :: Ada

-- | Filter to get only the pubkey inputs.
pubKeyTxIns :: Fold [TxIn] TxIn

-- | Filter to get only the script inputs.
scriptTxIns :: Fold [TxIn] TxIn
data ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory

-- | Counts CPU units in picoseconds: maximum value for SatInt is 2^63 ps,
--   or appproximately 106 days.
newtype ExCPU
ExCPU :: CostingInteger -> ExCPU

-- | Counts size in machine words.
newtype ExMemory
ExMemory :: CostingInteger -> ExMemory
data SatInt

module Ledger

-- | An example Plutus script that always fails, irrespective of inputs.
--   
--   For example, if one were to use this for a payment address then it
--   would be impossible for anyone to ever spend from it.
--   
--   The exact script depends on the context in which it is to be used.
examplePlutusScriptAlwaysFails :: WitCtx witctx -> PlutusScript PlutusScriptV1

-- | An example Plutus script that always succeeds, irrespective of inputs.
--   
--   For example, if one were to use this for a payment address then it
--   would allow anyone to spend from it.
--   
--   The exact script depends on the context in which it is to be used.
examplePlutusScriptAlwaysSucceeds :: WitCtx witctx -> PlutusScript PlutusScriptV1

-- | This GADT provides a value-level representation of all the witness
--   contexts. This enables pattern matching on the context to allow them
--   to be treated in a non-uniform way.
data WitCtx witctx
[WitCtxTxIn] :: WitCtx WitCtxTxIn
[WitCtxMint] :: WitCtx WitCtxMint
[WitCtxStake] :: WitCtx WitCtxStake

-- | Non-Native Script language. This is an Enumerated type. This is
--   expected to be an open type. We will add new Constuctors to this type
--   as additional Non-Native scripting language as are added. We use an
--   enumerated type for two reasons. 1) We can write total functions by
--   case analysis over the constructors 2) We will use DataKinds to make
--   some datatypes indexed by Language For now, the only Non-Native
--   Scriting language is Plutus We might add new languages in the futures.
--   
--   Note that the the serialization of <a>Language</a> depends on the
--   ordering.
data Language
PlutusV1 :: Language
PlutusV2 :: Language
data ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory

-- | Counts size in machine words.
newtype ExMemory
ExMemory :: CostingInteger -> ExMemory

-- | Counts CPU units in picoseconds: maximum value for SatInt is 2^63 ps,
--   or appproximately 106 days.
newtype ExCPU
ExCPU :: CostingInteger -> ExCPU
data SatInt

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> PubKeyHash -> Value

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value locked by the given validator in this transaction.
valueLockedBy :: TxInfo -> ValidatorHash -> Value

-- | Get the list of <a>TxOut</a> outputs of the pending transaction at a
--   given script address.
scriptOutputsAt :: ValidatorHash -> TxInfo -> [(DatumHash, Value)]

-- | Convert a <a>CurrencySymbol</a> to a <a>ValidatorHash</a>
fromSymbol :: CurrencySymbol -> ValidatorHash

-- | Get the hash of the validator script that is currently being
--   validated.
ownHash :: ScriptContext -> ValidatorHash

-- | Get the validator and datum hashes of the output that is curently
--   being validated
ownHashes :: ScriptContext -> (ValidatorHash, DatumHash)

-- | Get the public key hash that locks the transaction output, if any.
pubKeyOutput :: TxOut -> Maybe PubKeyHash

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | Finds all the outputs that pay to the same script address that we are
--   currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo

-- | Transaction inputs
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]

-- | Hash of the pending transaction (excluding witnesses)
[txInfoId] :: TxInfo -> TxId
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext
[scriptContextTxInfo] :: ScriptContext -> TxInfo
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Create a transaction output locked by a public key.
pubKeyHashTxOut :: Value -> PubKeyHash -> TxOut

-- | Whether the output is a pay-to-script output.
isPayToScriptOut :: TxOut -> Bool

-- | Whether the output is a pay-to-pubkey output.
isPubKeyOut :: TxOut -> Bool

-- | The datum attached to a <a>TxOut</a>, if there is one.
txOutDatum :: TxOut -> Maybe DatumHash

-- | A transaction ID, using a SHA256 hash as the transaction id.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A tag indicating the type of script that we are pointing to.
data ScriptTag
Spend :: ScriptTag
Mint :: ScriptTag
Cert :: ScriptTag
Reward :: ScriptTag

-- | A redeemer pointer is a pair of a script type tag t and an index i,
--   picking out the ith script of type t in the transaction.
data RedeemerPtr
RedeemerPtr :: ScriptTag -> Integer -> RedeemerPtr
type Redeemers = Map RedeemerPtr Redeemer

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | The staking credential of an address (if any)
stakingCredential :: Address -> Maybe StakingCredential

-- | The address that should be used by a transaction output locked by the
--   given validator script hash.
scriptHashAddress :: ValidatorHash -> Address

-- | The validator hash of the address, if any
toValidatorHash :: Address -> Maybe ValidatorHash

-- | The PubKeyHash of the address, if any
toPubKeyHash :: Address -> Maybe PubKeyHash

-- | Address with two kinds of credentials, normal and staking.
data Address
Address :: Credential -> Maybe StakingCredential -> Address
[addressCredential] :: Address -> Credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | <tt>()</tt> as a redeemer.
unitRedeemer :: Redeemer

-- | <tt>()</tt> as a datum.
unitDatum :: Datum

-- | Evaluate a <a>StakeValidator</a> with its <a>Context</a> and
--   <a>Redeemer</a>, returning the log.
runStakeValidatorScript :: MonadError ScriptError m => Context -> StakeValidator -> Redeemer -> m (ExBudget, [Text])

-- | Apply <a>StakeValidator</a> to its <a>Context</a> and <a>Redeemer</a>.
applyStakeValidatorScript :: Context -> StakeValidator -> Redeemer -> Script

-- | Evaluate a <a>MintingPolicy</a> with its <a>Context</a> and
--   <a>Redeemer</a>, returning the log.
runMintingPolicyScript :: MonadError ScriptError m => Context -> MintingPolicy -> Redeemer -> m (ExBudget, [Text])

-- | Apply <a>MintingPolicy</a> to its <a>Context</a> and <a>Redeemer</a>.
applyMintingPolicyScript :: Context -> MintingPolicy -> Redeemer -> Script

-- | Evaluate a <a>Validator</a> with its <a>Context</a>, <a>Datum</a>, and
--   <a>Redeemer</a>, returning the log.
runScript :: MonadError ScriptError m => Context -> Validator -> Datum -> Redeemer -> m (ExBudget, [Text])

-- | Apply a <a>Validator</a> to its <a>Context</a>, <a>Datum</a>, and
--   <a>Redeemer</a>.
applyValidator :: Context -> Validator -> Datum -> Redeemer -> Script
unStakeValidatorScript :: StakeValidator -> Script
mkStakeValidatorScript :: CompiledCode (BuiltinData -> BuiltinData -> ()) -> StakeValidator
unMintingPolicyScript :: MintingPolicy -> Script
mkMintingPolicyScript :: CompiledCode (BuiltinData -> BuiltinData -> ()) -> MintingPolicy
unValidatorScript :: Validator -> Script
mkValidatorScript :: CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ()) -> Validator

-- | Evaluate a script, returning the trace log.
evaluateScript :: MonadError ScriptError m => Script -> m (ExBudget, [Text])
applyArguments :: Script -> [Data] -> Script

-- | Turn a <a>CompiledCode</a> (usually produced by <tt>compile</tt>) into
--   a <a>Script</a> for use with this package.
fromCompiledCode :: CompiledCode a -> Script

-- | The size of a <a>Script</a>. No particular interpretation is given to
--   this, other than that it is proportional to the serialized size of the
--   script.
scriptSize :: Script -> Integer

-- | A script on the chain. This is an opaque type as far as the chain is
--   concerned.
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
[unScript] :: Script -> Program DeBruijn DefaultUni DefaultFun ()
data ScriptError

-- | Expected behavior of the engine (e.g. user-provided error)
EvaluationError :: [Text] -> String -> ScriptError

-- | Unexpected behavior of the engine (a bug)
EvaluationException :: String -> String -> ScriptError

-- | <a>Validator</a> is a wrapper around <a>Script</a>s which are used as
--   validators in transaction outputs.
newtype Validator
Validator :: Script -> Validator
[getValidator] :: Validator -> Script

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | <a>MintingPolicy</a> is a wrapper around <a>Script</a>s which are used
--   as validators for minting constraints.
newtype MintingPolicy
MintingPolicy :: Script -> MintingPolicy
[getMintingPolicy] :: MintingPolicy -> Script

-- | <a>StakeValidator</a> is a wrapper around <a>Script</a>s which are
--   used as validators for withdrawals and stake address certificates.
newtype StakeValidator
StakeValidator :: Script -> StakeValidator
[getStakeValidator] :: StakeValidator -> Script

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ValidatorHash
ValidatorHash :: BuiltinByteString -> ValidatorHash

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype MintingPolicyHash
MintingPolicyHash :: BuiltinByteString -> MintingPolicyHash

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype StakeValidatorHash
StakeValidatorHash :: BuiltinByteString -> StakeValidatorHash

-- | Information about the state of the blockchain and about the
--   transaction that is currently being validated, represented as a value
--   in <tt>Data</tt>.
newtype Context
Context :: BuiltinData -> Context

-- | Simple conversion from <a>DiffMilliSeconds</a> to <a>POSIXTime</a>.
fromMilliSeconds :: DiffMilliSeconds -> POSIXTime

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | POSIX time is measured as the number of milliseconds since
--   1970-01-01T00:00:00Z
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | This is a length of time, as measured by a number of milliseconds.
newtype DiffMilliSeconds
DiffMilliSeconds :: Integer -> DiffMilliSeconds

-- | Check if a value is later than the end of a <a>Interval</a>.
after :: Ord a => a -> Interval a -> Bool

-- | Check if a value is earlier than the beginning of an <a>Interval</a>.
before :: Ord a => a -> Interval a -> Bool

-- | Check if an <a>Interval</a> is empty.
isEmpty :: (Enum a, Ord a) => Interval a -> Bool

-- | <tt>a <a>contains</a> b</tt> is true if the <a>Interval</a> <tt>b</tt>
--   is entirely contained in <tt>a</tt>. That is, <tt>a <a>contains</a>
--   b</tt> if for every entry <tt>s</tt>, if <tt>member s b</tt> then
--   <tt>member s a</tt>.
contains :: Ord a => Interval a -> Interval a -> Bool

-- | 'hull a b' is the smallest interval containing <tt>a</tt> and
--   <tt>b</tt>.
hull :: Ord a => Interval a -> Interval a -> Interval a

-- | 'intersection a b' is the largest interval that is contained in
--   <tt>a</tt> and in <tt>b</tt>, if it exists.
intersection :: Ord a => Interval a -> Interval a -> Interval a

-- | Check whether two intervals overlap, that is, whether there is a value
--   that is a member of both intervals.
overlaps :: (Enum a, Ord a) => Interval a -> Interval a -> Bool

-- | Check whether a value is in an interval.
member :: Ord a => a -> Interval a -> Bool

-- | An <a>Interval</a> that is empty.
never :: Interval a

-- | An <a>Interval</a> that covers every slot.
always :: Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>.
to :: a -> Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>.
from :: a -> Interval a
singleton :: a -> Interval a

-- | <tt>interval a b</tt> includes all values that are greater than or
--   equal to <tt>a</tt> and smaller than or equal to <tt>b</tt>. Therefore
--   it includes <tt>a</tt> and <tt>b</tt>.
interval :: a -> a -> Interval a
upperBound :: a -> UpperBound a
lowerBound :: a -> LowerBound a
strictLowerBound :: a -> LowerBound a
strictUpperBound :: a -> UpperBound a

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | Hash a <a>BuiltinData</a>
dataHash :: BuiltinData -> BuiltinByteString

-- | Hash a <a>Redeemer</a> builtin data.
redeemerHash :: Redeemer -> RedeemerHash

-- | Hash a 'PV1.Datum builtin data.
datumHash :: Datum -> DatumHash

-- | The <tt>CurrencySymbol</tt> of a <tt>MintingPolicy</tt>.
scriptCurrencySymbol :: Versioned MintingPolicy -> CurrencySymbol

-- | Hash a <a>Versioned</a> <a>StakeValidator</a> script.
stakeValidatorHash :: Versioned StakeValidator -> StakeValidatorHash

-- | Hash a <a>Versioned</a> <a>MintingPolicy</a> script.
mintingPolicyHash :: Versioned MintingPolicy -> MintingPolicyHash

-- | Hash a <a>Versioned</a> <a>Validator</a> script.
validatorHash :: Versioned Validator -> ValidatorHash

-- | Hash a <a>Versioned</a> <tt>Script</tt>
scriptHash :: Versioned Script -> ScriptHash

-- | A script of some kind with its Plutus language version
data Versioned script
Versioned :: script -> Language -> Versioned script
[unversioned] :: Versioned script -> script
[version] :: Versioned script -> Language
examplePlutusScriptAlwaysSucceedsHash :: WitCtx ctx -> BuiltinByteString
examplePlutusScriptAlwaysFailsHash :: WitCtx ctx -> BuiltinByteString

-- | The slot number. This is a good proxy for time, since on the Cardano
--   blockchain slots pass at a constant rate.
newtype Slot
Slot :: Integer -> Slot
[getSlot] :: Slot -> Integer

-- | An <a>Interval</a> of <a>Slot</a>s.
type SlotRange = Interval Slot

-- | Number of <a>Slot</a>s covered by the interval, if finite. <tt>width
--   (from x) == Nothing</tt>.
width :: SlotRange -> Maybe Integer

-- | Value without any Ada.
noAdaValue :: Value -> Value

-- | A message with a cryptographic signature.
newtype Signature
Signature :: BuiltinByteString -> Signature
[getSignature] :: Signature -> BuiltinByteString

-- | Passphrase newtype to mark intent
newtype Passphrase
Passphrase :: ByteString -> Passphrase
[unPassphrase] :: Passphrase -> ByteString
newtype PubKey
PubKey :: LedgerBytes -> PubKey
[getPubKey] :: PubKey -> LedgerBytes

-- | A cryptographic private key.
newtype PrivateKey
PrivateKey :: LedgerBytes -> PrivateKey
[getPrivateKey] :: PrivateKey -> LedgerBytes

-- | Compute the hash of a public key.
pubKeyHash :: PubKey -> PubKeyHash

-- | Check whether the given <a>Signature</a> was signed by the private key
--   corresponding to the given public key.
signedBy :: ByteArrayAccess a => Signature -> PubKey -> a -> Bool

-- | Sign the hash of a transaction using a private key and passphrase.
signTx :: TxId -> XPrv -> Passphrase -> Signature

-- | Sign the hash of a transaction using a private key that has no
--   passphrase.
signTx' :: TxId -> XPrv -> Signature

-- | Sign a message using a private key and passphrase.
sign :: ByteArrayAccess a => a -> XPrv -> Passphrase -> Signature

-- | Sign a message using a private key with no passphrase.
sign' :: ByteArrayAccess a => a -> XPrv -> Signature

-- | Generate a private key from a seed phrase and passphrase
generateFromSeed :: ByteString -> Passphrase -> XPrv

-- | Generate a private key from a seed phrase without a passphrase.
generateFromSeed' :: ByteString -> XPrv
xPubToPublicKey :: XPub -> PubKey
toPublicKey :: XPrv -> PubKey
newtype PaymentPubKey
PaymentPubKey :: PubKey -> PaymentPubKey
[unPaymentPubKey] :: PaymentPubKey -> PubKey
newtype PaymentPrivateKey
PaymentPrivateKey :: XPrv -> PaymentPrivateKey
[unPaymentPrivateKey] :: PaymentPrivateKey -> XPrv
type CardanoAddress = AddressInEra BabbageEra
cardanoAddressCredential :: AddressInEra era -> Credential
cardanoStakingCredential :: AddressInEra era -> Maybe StakingCredential
cardanoPubKeyHash :: AddressInEra era -> Maybe PubKeyHash
toPlutusAddress :: AddressInEra era -> Address
toPlutusPubKeyHash :: Hash PaymentKey -> PubKeyHash
newtype PaymentPubKeyHash
PaymentPubKeyHash :: PubKeyHash -> PaymentPubKeyHash
[unPaymentPubKeyHash] :: PaymentPubKeyHash -> PubKeyHash
xprvToPaymentPubKey :: XPrv -> PaymentPubKey
newtype StakePubKey
StakePubKey :: PubKey -> StakePubKey
[unStakePubKey] :: StakePubKey -> PubKey
xprvToPaymentPubKeyHash :: XPrv -> PaymentPubKeyHash
newtype StakePubKeyHash
StakePubKeyHash :: PubKeyHash -> StakePubKeyHash
[unStakePubKeyHash] :: StakePubKeyHash -> PubKeyHash
xprvToStakePubKey :: XPrv -> StakePubKey
xprvToStakePubKeyHash :: XPrv -> StakePubKeyHash
xprvToStakingCredential :: XPrv -> StakingCredential
paymentPubKeyHash :: PaymentPubKey -> PaymentPubKeyHash

-- | The address that should be targeted by a transaction output locked by
--   the given public payment key (with its staking credentials).
pubKeyHashAddress :: PaymentPubKeyHash -> Maybe StakingCredential -> Address

-- | The address that should be targeted by a transaction output locked by
--   the given public key. (with its staking credentials).
pubKeyAddress :: PaymentPubKey -> Maybe StakingCredential -> Address

-- | The address that should be used by a transaction output locked by the
--   given validator script (with its staking credentials).
scriptValidatorHashAddress :: ValidatorHash -> Maybe StakingCredential -> Address

-- | Construct a <a>StakingCredential</a> from a public key hash.
stakePubKeyHashCredential :: StakePubKeyHash -> StakingCredential

-- | Construct a <a>StakingCredential</a> from a validator script hash.
stakeValidatorHashCredential :: StakeValidatorHash -> StakingCredential
data ToCardanoError

-- | A C.TxBodyError converted to String
TxBodyError :: String -> ToCardanoError
DeserialisationError :: ToCardanoError
InvalidValidityRange :: ToCardanoError
ValueNotPureAda :: ToCardanoError
OutputHasZeroAda :: ToCardanoError
StakingPointersNotSupported :: ToCardanoError
SimpleScriptsNotSupportedToCardano :: ToCardanoError
MissingInputValidator :: ToCardanoError
MissingDatum :: ToCardanoError
MissingMintingPolicy :: ToCardanoError
ScriptPurposeNotSupported :: ScriptTag -> ToCardanoError
MissingMintingPolicyRedeemer :: ToCardanoError
MissingStakeValidator :: ToCardanoError
UnsupportedPlutusVersion :: Language -> ToCardanoError
Tag :: String -> ToCardanoError -> ToCardanoError

-- | Cardano tx from any era.
data SomeCardanoApiTx
[SomeTx] :: IsCardanoEra era => Tx era -> EraInMode era CardanoMode -> SomeCardanoApiTx
pattern CardanoApiEmulatorEraTx :: Tx BabbageEra -> SomeCardanoApiTx
type ReferenceScript = ReferenceScript BabbageEra

-- | A <a>TxOut</a> along with the <a>Tx</a> it comes from, which may have
--   additional information e.g. the full data script that goes with the
--   <a>TxOut</a>.
data TxOutTx
TxOutTx :: Tx -> TxOut -> TxOutTx
[txOutTxTx] :: TxOutTx -> Tx
[txOutTxOut] :: TxOutTx -> TxOut

-- | A babbage era transaction without witnesses for its inputs.
data TxStripped
TxStripped :: [TxOutRef] -> [TxOutRef] -> [TxOut] -> !Value -> !Value -> TxStripped

-- | The inputs to this transaction, as transaction output references only.
[txStrippedInputs] :: TxStripped -> [TxOutRef]

-- | The reference inputs to this transaction, as transaction output
--   references only.
[txStrippedReferenceInputs] :: TxStripped -> [TxOutRef]

-- | The outputs of this transation.
[txStrippedOutputs] :: TxStripped -> [TxOut]

-- | The <a>Value</a> minted by this transaction.
[txStrippedMint] :: TxStripped -> !Value

-- | The fee for this transaction.
[txStrippedFee] :: TxStripped -> !Value

-- | A Babbage-era transaction, including witnesses for its inputs.
data Tx
Tx :: [TxInput] -> [TxInput] -> [TxInput] -> [TxOut] -> Maybe TxOut -> Maybe Value -> !Value -> !Value -> !SlotRange -> MintingWitnessesMap -> [Withdrawal] -> [Certificate] -> Map PubKey Signature -> ScriptsMap -> Map DatumHash Datum -> Maybe BuiltinByteString -> Tx

-- | The inputs to this transaction.
[txInputs] :: Tx -> [TxInput]

-- | The reference inputs to this transaction.
[txReferenceInputs] :: Tx -> [TxInput]

-- | The collateral inputs to cover the fees in case validation of the
--   transaction fails.
[txCollateralInputs] :: Tx -> [TxInput]

-- | The outputs of this transaction, ordered so they can be referenced by
--   index.
[txOutputs] :: Tx -> [TxOut]

-- | The output of the remaining collateral after covering fees in case
--   validation of the transaction fails.
[txReturnCollateral] :: Tx -> Maybe TxOut

-- | The total collateral to be paid in case validation of the transaction
--   fails.
[txTotalCollateral] :: Tx -> Maybe Value

-- | The <a>Value</a> minted by this transaction.
[txMint] :: Tx -> !Value

-- | The fee for this transaction.
[txFee] :: Tx -> !Value

-- | The <a>SlotRange</a> during which this transaction may be validated.
[txValidRange] :: Tx -> !SlotRange

-- | The witnesses that must be present to check minting conditions matched
--   with their redeemers.
[txMintingWitnesses] :: Tx -> MintingWitnessesMap

-- | Withdrawals, contains redeemers.
[txWithdrawals] :: Tx -> [Withdrawal]

-- | Certificates, contains redeemers.
[txCertificates] :: Tx -> [Certificate]

-- | Signatures of this transaction.
[txSignatures] :: Tx -> Map PubKey Signature

-- | Scripts for all script credentials mentioned in this tx.
[txScripts] :: Tx -> ScriptsMap

-- | Datum objects recorded on this transaction.
[txData] :: Tx -> Map DatumHash Datum

-- | Metadata
[txMetadata] :: Tx -> Maybe BuiltinByteString
type MintingWitnessesMap = Map MintingPolicyHash (Redeemer, Maybe (Versioned TxOutRef))
type ScriptsMap = Map ScriptHash (Versioned Script)

-- | Validator, redeemer, and data scripts of a transaction input that
--   spends a "pay to script" output. inScripts :: Tx -&gt; TxInput -&gt;
--   Maybe (LedgerPlutusVersion, Validator, Redeemer, Datum) inScripts tx
--   i@TxInput{txInputType=TxConsumeScriptAddress pv _ _ _} = case txInType
--   $ fillTxInputWitnesses tx i of Just (ConsumeScriptAddress v r d) -&gt;
--   Just (pv, v, r, d) _ -&gt; Nothing inScripts _ _ = Nothing
newtype TxOut
TxOut :: TxOut CtxTx BabbageEra -> TxOut
[getTxOut] :: TxOut -> TxOut CtxTx BabbageEra
data Certificate
Certificate :: DCert -> Maybe Redeemer -> Certificate
[certificateDcert] :: Certificate -> DCert

-- | redeemer for script credential
[certificateRedeemer] :: Certificate -> Maybe Redeemer

-- | Stake withdrawal, if applicable the script should be included in
--   txScripts.
data Withdrawal
Withdrawal :: Credential -> Integer -> Maybe Redeemer -> Withdrawal

-- | staking credential
[withdrawalCredential] :: Withdrawal -> Credential

-- | amount of withdrawal in Lovelace, must withdraw all eligible amount
[withdrawalAmount] :: Withdrawal -> Integer

-- | redeemer for script credential
[withdrawalRedeemer] :: Withdrawal -> Maybe Redeemer

-- | A transaction input, consisting of a transaction output reference and
--   an input type. Differs with TxIn by: TxIn *maybe* contains *full* data
--   witnesses, TxInput always contains redeemer witness, but
--   datum/validator hashes.
data TxInput
TxInput :: !TxOutRef -> !TxInputType -> TxInput
[txInputRef] :: TxInput -> !TxOutRef
[txInputType] :: TxInput -> !TxInputType

-- | The type of a transaction input with hashes.
data TxInputType

-- | A transaction input that consumes (with a validator hash) or
--   references (with a txOutRef) a script address with the given the
--   redeemer and datum hash.
TxScriptAddress :: !Redeemer -> !Either ValidatorHash (Versioned TxOutRef) -> !Maybe DatumHash -> TxInputType

-- | A transaction input that consumes a public key address.
TxConsumePublicKeyAddress :: TxInputType

-- | Consume a simple script
TxConsumeSimpleScriptAddress :: TxInputType

-- | A transaction input, consisting of a transaction output reference and
--   an input type.
data TxIn
TxIn :: !TxOutRef -> Maybe TxInType -> TxIn
[txInRef] :: TxIn -> !TxOutRef
[txInType] :: TxIn -> Maybe TxInType

-- | The type of a transaction input.
data TxInType

-- | A transaction input that consumes (with a validator) or references
--   (with a txOutRef) a script address with the given the redeemer and
--   datum. Datum is optional if the input refers to a script output which
--   contains an inline datum
ScriptAddress :: !Either (Versioned Validator) (Versioned TxOutRef) -> !Redeemer -> !Maybe Datum -> TxInType

-- | A transaction input that consumes a public key address.
ConsumePublicKeyAddress :: TxInType

-- | Consume a simple script
ConsumeSimpleScriptAddress :: TxInType

-- | A transaction input that spends a "pay to public key" output, given
--   the witness.
pubKeyTxIn :: TxOutRef -> TxIn

-- | A transaction input that spends a "pay to script" output, given
--   witnesses. Datum is optional if the input refers to a script output
--   which contains an inline datum
scriptTxIn :: TxOutRef -> Versioned Validator -> Redeemer -> Maybe Datum -> TxIn

-- | The <a>TxOutRef</a> spent by a transaction input.
inputRef :: Lens' TxInput TxOutRef

-- | The type of a transaction input.
inputType :: Lens' TxInput TxInputType

-- | Validator, redeemer, and data scripts of a transaction input that
--   spends a "pay to script" output.
inScripts :: TxIn -> Maybe (Versioned Validator, Redeemer, Maybe Datum)

-- | The <a>TxOutRef</a> spent by a transaction input.
inRef :: Lens' TxInput TxOutRef

-- | The type of a transaction input.
inType :: Lens' TxInput TxInputType

-- | Filter to get only the pubkey inputs.
pubKeyTxInputs :: Fold [TxInput] TxInput

-- | Filter to get only the scripts that consume or reference a script
--   address
scriptTxInputs :: Fold [TxInput] TxInput

-- | Filter to get only the scripts that reference a script address
referenceScriptTxInputs :: Fold [TxInput] TxInput
toSizedTxOut :: TxOut -> Sized (TxOut StandardBabbage)

-- | The inputs of a transaction.
inputs :: Lens' Tx [TxInput]

-- | The reference inputs of a transaction.
referenceInputs :: Lens' Tx [TxInput]

-- | The collateral inputs of a transaction for paying fees when validating
--   the transaction fails.
collateralInputs :: Lens' Tx [TxInput]

-- | The outputs of a transaction.
outputs :: Lens' Tx [TxOut]
returnCollateral :: Lens' Tx (Maybe TxOut)
totalCollateral :: Lens' Tx (Maybe Value)

-- | The validity range of a transaction.
validRange :: Lens' Tx SlotRange
signatures :: Lens' Tx (Map PubKey Signature)
fee :: Lens' Tx Value
mint :: Lens' Tx Value
mintScripts :: Lens' Tx MintingWitnessesMap
scriptWitnesses :: Lens' Tx ScriptsMap
datumWitnesses :: Lens' Tx (Map DatumHash Datum)

-- | The inputs of a transaction.
metadata :: Lens' Tx (Maybe BuiltinByteString)
lookupSignature :: PubKey -> Tx -> Maybe Signature
lookupDatum :: Tx -> DatumHash -> Maybe Datum

-- | Check that all values in a transaction are non-negative.
validValuesTx :: Tx -> Bool
txOutValue :: TxOut -> Value
outValue :: Lens TxOut TxOut Value (TxOutValue BabbageEra)
outValue' :: Lens' TxOut (TxOutValue BabbageEra)
strip :: Tx -> TxStripped
txOutTxDatum :: TxOutTx -> Maybe Datum

-- | Get a hash from the stored TxOutDatum (either dirctly or by hashing
--   the inlined datum)
txOutDatumHash :: TxOut -> Maybe DatumHash
txOutPubKey :: TxOut -> Maybe PubKeyHash
txOutAddress :: TxOut -> CardanoAddress
outAddress :: Lens' TxOut (AddressInEra BabbageEra)
outDatumHash :: Lens TxOut TxOut (Maybe DatumHash) (TxOutDatum CtxTx BabbageEra)
txOutReferenceScript :: TxOut -> ReferenceScript
outReferenceScript :: Lens' TxOut ReferenceScript
lookupScript :: ScriptsMap -> ScriptHash -> Maybe (Versioned Script)
lookupValidator :: ScriptsMap -> ValidatorHash -> Maybe (Versioned Validator)

-- | The transaction output references consumed by a transaction.
spentOutputs :: Tx -> [TxOutRef]

-- | The transaction output references referenced by a transaction.
referencedOutputs :: Tx -> [TxOutRef]
lookupMintingPolicy :: ScriptsMap -> MintingPolicyHash -> Maybe (Versioned MintingPolicy)
lookupStakeValidator :: ScriptsMap -> StakeValidatorHash -> Maybe (Versioned StakeValidator)

-- | Translate TxInput to old Plutus.V1.Ledger.Api TxIn taking script and
--   datum witnesses from Tx.
fillTxInputWitnesses :: Tx -> TxInput -> TxIn
pubKeyTxInput :: TxOutRef -> TxInput

-- | Add minting policy together with the redeemer into txMintingWitnesses
--   and txScripts accordingly. Doesn't alter txMint.
addMintingPolicy :: Versioned MintingPolicy -> (Redeemer, Maybe (Versioned TxOutRef)) -> Tx -> Tx

-- | Add validator together with the redeemer and datum into txInputs,
--   txData and txScripts accordingly. Datum is optional if the input
--   refers to a script output which contains an inline datum
addScriptTxInput :: TxOutRef -> Versioned Validator -> Redeemer -> Maybe Datum -> Tx -> Tx

-- | Add script reference together with the redeemer and datum into
--   txInputs and txData accordingly. Datum is optional if the input refers
--   to a script output which contains an inline datum
addReferenceTxInput :: TxOutRef -> Versioned TxOutRef -> Redeemer -> Maybe Datum -> Tx -> Tx
txRedeemers :: Tx -> Map ScriptPurpose Redeemer
txSpendingRedeemers :: Tx -> Map TxOutRef Redeemer
txMintingRedeemers :: Tx -> Map MintingPolicyHash Redeemer
txRewardingRedeemers :: Tx -> Map Credential Redeemer
txCertifyingRedeemers :: Tx -> Map DCert Redeemer

-- | A reason why a transaction is invalid.
data ValidationError

-- | The transaction output consumed by a transaction input could not be
--   found (either because it was already spent, or because there was no
--   transaction with the given hash on the blockchain).
TxOutRefNotFound :: TxOutRef -> ValidationError

-- | For pay-to-script outputs: evaluation of the validator script failed.
ScriptFailure :: ScriptError -> ValidationError

-- | An error from Cardano.Ledger validation
CardanoLedgerValidationError :: Text -> ValidationError

-- | The UTxOs of a blockchain indexed by their references.
newtype UtxoIndex
UtxoIndex :: Map TxOutRef TxOut -> UtxoIndex
[getIndex] :: UtxoIndex -> Map TxOutRef TxOut
type ValidationSuccess = Map RdmrPtr ([Text], ExUnits)
type ValidationErrorInPhase = (ValidationPhase, ValidationError)
data ValidationPhase
Phase1 :: ValidationPhase
Phase2 :: ValidationPhase
_CardanoLedgerValidationError :: AsValidationError r_a3en6 => Prism' r_a3en6 Text
_TxOutRefNotFound :: AsValidationError r_a3en6 => Prism' r_a3en6 TxOutRef
_ScriptFailure :: AsValidationError r_a3en6 => Prism' r_a3en6 ScriptError

-- | A datum in a transaction output that comes from a chain index query.
data DatumFromQuery
DatumUnknown :: DatumFromQuery
DatumInline :: Datum -> DatumFromQuery
DatumInBody :: Datum -> DatumFromQuery

-- | Offchain view of a transaction output.
data DecoratedTxOut
PublicKeyDecoratedTxOut :: PubKeyHash -> Maybe StakingCredential -> Value -> Maybe (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> DecoratedTxOut

-- | The pubKey hash that protects the transaction address
[_decoratedTxOutPubKeyHash] :: DecoratedTxOut -> PubKeyHash

-- | The staking credential of the transaction address, if any
[_decoratedTxOutStakingCredential] :: DecoratedTxOut -> Maybe StakingCredential

-- | Value of the transaction output.
[_decoratedTxOutValue] :: DecoratedTxOut -> Value

-- | Optional datum (inline datum or datum in transaction body) attached to
--   the transaction output.
[_decoratedTxOutPubKeyDatum] :: DecoratedTxOut -> Maybe (DatumHash, DatumFromQuery)

-- | Value of the transaction output.
[_decoratedTxOutReferenceScript] :: DecoratedTxOut -> Maybe (Versioned Script)
ScriptDecoratedTxOut :: ValidatorHash -> Maybe StakingCredential -> Value -> (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe (Versioned Validator) -> DecoratedTxOut

-- | The hash of the script that protects the transaction address
[_decoratedTxOutValidatorHash] :: DecoratedTxOut -> ValidatorHash

-- | The staking credential of the transaction address, if any
[_decoratedTxOutStakingCredential] :: DecoratedTxOut -> Maybe StakingCredential

-- | Value of the transaction output.
[_decoratedTxOutValue] :: DecoratedTxOut -> Value

-- | Datum attached to the transaction output, either in full (inline datum
--   or datum in transaction body) or as a hash reference. A transaction
--   output protected by a Plutus script is guardateed to have an
--   associated datum.
[_decoratedTxOutScriptDatum] :: DecoratedTxOut -> (DatumHash, DatumFromQuery)

-- | Value of the transaction output.
[_decoratedTxOutReferenceScript] :: DecoratedTxOut -> Maybe (Versioned Script)

-- | Full version of the validator protecting the transaction output
[_decoratedTxOutValidator] :: DecoratedTxOut -> Maybe (Versioned Validator)
datumInDatumFromQuery :: Traversal' DatumFromQuery Datum
decoratedTxOutPubKeyDatum :: Traversal' DecoratedTxOut (Maybe (DatumHash, DatumFromQuery))
decoratedTxOutPubKeyHash :: Traversal' DecoratedTxOut PubKeyHash
decoratedTxOutReferenceScript :: Lens' DecoratedTxOut (Maybe (Versioned Script))
decoratedTxOutScriptDatum :: Traversal' DecoratedTxOut (DatumHash, DatumFromQuery)
decoratedTxOutStakingCredential :: Lens' DecoratedTxOut (Maybe StakingCredential)
decoratedTxOutValidator :: Traversal' DecoratedTxOut (Maybe (Versioned Validator))
decoratedTxOutValidatorHash :: Traversal' DecoratedTxOut ValidatorHash
decoratedTxOutValue :: Lens' DecoratedTxOut Value
data CardanoTx
EmulatorTx :: Tx -> CardanoTx
[_emulatorTx] :: CardanoTx -> Tx
CardanoApiTx :: SomeCardanoApiTx -> CardanoTx
[_cardanoApiTx] :: CardanoTx -> SomeCardanoApiTx
_PublicKeyDecoratedTxOut :: Prism' DecoratedTxOut (PubKeyHash, Maybe StakingCredential, Value, Maybe (DatumHash, DatumFromQuery), Maybe (Versioned Script))
_ScriptDecoratedTxOut :: Prism' DecoratedTxOut (ValidatorHash, Maybe StakingCredential, Value, (DatumHash, DatumFromQuery), Maybe (Versioned Script), Maybe (Versioned Validator))
mkDecoratedTxOut :: CardanoAddress -> Value -> (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> DecoratedTxOut
mkPubkeyDecoratedTxOut :: CardanoAddress -> Value -> Maybe (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe DecoratedTxOut
mkScriptDecoratedTxOut :: CardanoAddress -> Value -> (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe (Versioned Validator) -> Maybe DecoratedTxOut
_decoratedTxOutAddress :: DecoratedTxOut -> Address
decoratedTxOutAddress :: Getter DecoratedTxOut Address
decoratedTxOutDatum :: Traversal' DecoratedTxOut (DatumHash, DatumFromQuery)
toTxOut :: NetworkId -> DecoratedTxOut -> Either ToCardanoError TxOut

-- | Converts a transaction output from the chain index to the
--   plutus-ledger-api transaction output.
--   
--   Note that <a>DecoratedTxOut</a> supports features such inline datums
--   and reference scripts which are not supported by V1 TxOut. Converting
--   from <a>DecoratedTxOut</a> to <a>TxOut</a> and back is therefore
--   lossy.
toTxInfoTxOut :: DecoratedTxOut -> TxOut
cardanoApiTx :: Traversal' CardanoTx SomeCardanoApiTx
emulatorTx :: Traversal' CardanoTx Tx
onCardanoTx :: (Tx -> r) -> (SomeCardanoApiTx -> r) -> CardanoTx -> r
cardanoTxMap :: (Tx -> Tx) -> (SomeCardanoApiTx -> SomeCardanoApiTx) -> CardanoTx -> CardanoTx
getCardanoTxId :: CardanoTx -> TxId
getCardanoTxInputs :: CardanoTx -> [TxIn]
getTxBodyContentInputs :: TxBodyContent ctx era -> [TxIn]
getCardanoTxCollateralInputs :: CardanoTx -> [TxIn]
getTxBodyContentCollateralInputs :: TxBodyContent ctx era -> [TxIn]
getCardanoTxOutRefs :: CardanoTx -> [(TxOut, TxOutRef)]
getCardanoTxOutputs :: CardanoTx -> [TxOut]
getCardanoTxProducedOutputs :: CardanoTx -> Map TxOutRef TxOut
getCardanoTxSpentOutputs :: CardanoTx -> Set TxOutRef
getCardanoTxReturnCollateral :: CardanoTx -> Maybe TxOut
getTxBodyContentReturnCollateral :: TxBodyContent ctx BabbageEra -> Maybe TxOut
getCardanoTxProducedReturnCollateral :: CardanoTx -> Map TxOutRef TxOut
getCardanoTxTotalCollateral :: CardanoTx -> Maybe Value
getCardanoTxFee :: CardanoTx -> Value
getCardanoTxMint :: CardanoTx -> Value
getTxBodyContentMint :: TxBodyContent ctx era -> Value
getCardanoTxValidityRange :: CardanoTx -> SlotRange
getCardanoTxData :: CardanoTx -> Map DatumHash Datum
txBodyContentIns :: Lens' (TxBodyContent BuildTx BabbageEra) [(TxIn, BuildTxWith BuildTx (Witness WitCtxTxIn BabbageEra))]
txBodyContentCollateralIns :: Lens' (TxBodyContent BuildTx BabbageEra) [TxIn]
txBodyContentOuts :: Lens' (TxBodyContent ctx BabbageEra) [TxOut]
getCardanoTxRedeemers :: CardanoTx -> Map ScriptPurpose Redeemer

-- | Compute the id of a transaction.
txId :: Tx -> TxId

-- | Update a map of unspent transaction outputs and signatures based on
--   the inputs and outputs of a transaction.
updateUtxo :: CardanoTx -> Map TxOutRef TxOut -> Map TxOutRef TxOut

-- | Update a map of unspent transaction outputs and signatures based on
--   the collateral inputs of a transaction (for when it is invalid).
updateUtxoCollateral :: CardanoTx -> Map TxOutRef TxOut -> Map TxOutRef TxOut

-- | A list of a transaction's outputs paired with a <a>TxOutRef</a>s
--   referring to them.
txOutRefs :: Tx -> [(TxOut, TxOutRef)]

-- | The unspent outputs of a transaction.
unspentOutputsTx :: Tx -> Map TxOutRef TxOut

-- | Create a transaction output locked by a public payment key and
--   optionnaly a public stake key.
pubKeyTxOut :: Value -> PaymentPubKey -> Maybe StakingCredential -> Either ToCardanoError TxOut
addCardanoTxSignature :: PrivateKey -> CardanoTx -> CardanoTx

-- | Sign the transaction with a <a>PrivateKey</a> and passphrase
--   (ByteString) and add the signature to the transaction's list of
--   signatures.
addSignature :: PrivateKey -> Passphrase -> Tx -> Tx

-- | Sign the transaction with a <a>PrivateKey</a> that has no passphrase
--   and add the signature to the transaction's list of signatures
addSignature' :: PrivateKey -> Tx -> Tx

-- | A blockchain, which is just a list of blocks, starting with the
--   newest.
type Blockchain = [Block]

-- | A block on the blockchain. This is just a list of transactions
--   following on from the chain so far.
type Block = [OnChainTx]

-- | A transaction on the blockchain. Invalid transactions are still put on
--   the chain to be able to collect fees.
data OnChainTx
Invalid :: CardanoTx -> OnChainTx
Valid :: CardanoTx -> OnChainTx

-- | Block identifier (usually a hash)
newtype BlockId
BlockId :: ByteString -> BlockId
[getBlockId] :: BlockId -> ByteString
eitherTx :: (CardanoTx -> r) -> (CardanoTx -> r) -> OnChainTx -> r
unOnChain :: OnChainTx -> CardanoTx
onChainTxIsValid :: OnChainTx -> Bool

-- | Outputs consumed from the UTXO set by the <a>OnChainTx</a>
consumableInputs :: OnChainTx -> [TxIn]

-- | Outputs added to the UTXO set by the <a>OnChainTx</a>
outputsProduced :: OnChainTx -> Map TxOutRef TxOut

-- | Lookup a transaction in a <a>Blockchain</a> by its id.
transaction :: Blockchain -> TxId -> Maybe OnChainTx

-- | Determine the unspent output that an input refers to
out :: Blockchain -> TxOutRef -> Maybe TxOut

-- | Determine the unspent value that a transaction output refers to.
value :: Blockchain -> TxOutRef -> Maybe Value

-- | Determine the data script that a transaction output refers to.
datumTxo :: Blockchain -> TxOutRef -> Maybe DatumHash

-- | Determine the public key that locks a transaction output, if there is
--   one.
pubKeyTxo :: Blockchain -> TxOutRef -> Maybe PubKeyHash

-- | The unspent transaction outputs of the ledger as a whole.
unspentOutputs :: Blockchain -> Map TxOutRef TxOut
_Invalid :: Prism' OnChainTx CardanoTx
_Valid :: Prism' OnChainTx CardanoTx

-- | Create an index of all UTxOs on the chain.
initialise :: Blockchain -> UtxoIndex

-- | Update the index for the addition of a transaction.
insert :: CardanoTx -> UtxoIndex -> UtxoIndex

-- | Update the index for the addition of only the collateral inputs of a
--   failed transaction.
insertCollateral :: CardanoTx -> UtxoIndex -> UtxoIndex

-- | Update the index for the addition of a block.
insertBlock :: Block -> UtxoIndex -> UtxoIndex

-- | Find an unspent transaction output by the <a>TxOutRef</a> that spends
--   it.
lookup :: MonadError ValidationError m => TxOutRef -> UtxoIndex -> m TxOut

-- | Filter to get only the script inputs.
scriptTxIns :: Fold [TxIn] TxIn

-- | Filter to get only the pubkey inputs.
pubKeyTxIns :: Fold [TxIn] TxIn

-- | Adjust a single transaction output so it contains at least the minimum
--   amount of Ada and return the adjustment (if any) and the updated
--   TxOut.
adjustTxOut :: PParams (BabbageEra StandardCrypto) -> TxOut -> Either ToCardanoError ([Ada], TxOut)

-- | Exact computation of the mimimum Ada required for a given TxOut. TODO:
--   Should be moved to cardano-api-extended once created
minAdaTxOut :: PParams (BabbageEra StandardCrypto) -> TxOut -> Ada

-- | Provide a reasonable estimate of the mimimum of Ada required for a
--   TxOut.
--   
--   An exact estimate of the the mimimum of Ada in a TxOut is determined
--   by two things: - the <tt>PParams</tt>, more precisely its
--   <tt>coinPerUTxOWord</tt> parameter. - the size of the <a>TxOut</a>. In
--   many situations though, we need to determine a plausible value for the
--   minimum of Ada needed for a TxOut without knowing much of the
--   <a>TxOut</a>. This function provides a value big enough to balance
--   UTxOs without a large inlined data (larger than a hash) nor a complex
--   val with a lot of minted values. It's superior to the lowest minimum
--   needed for an UTxO, as the lowest value require no datum. An estimate
--   of the minimum required Ada for each tx output.
minAdaTxOutEstimated :: Ada
maxMinAdaTxOut :: Ada

-- | Minimum transaction fee.
minFee :: Tx -> Value

-- | TODO Should be calculated based on the maximum script size permitted
--   on the Cardano blockchain.
maxFee :: Ada

-- | An asset class, identified by currency symbol and token name.
data AssetClass
data CurrencySymbol

-- | ByteString of a name of a token, shown as UTF-8 string when possible
data TokenName

-- | A cryptocurrency value. This is a map from <a>CurrencySymbol</a>s to a
--   quantity of that currency.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   See note [Currencies] for more details.
data Value

-- | ADA, the special currency on the Cardano blockchain. The unit of Ada
--   is Lovelace, and 1M Lovelace is one Ada. See note [Currencies] in
--   <a>TH</a>.
data Ada

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
data NetworkId

-- | Credential required to unlock a transaction output
data Credential

-- | Staking credential used to assign rewards
data StakingCredential

module Ledger.Test
someCode :: CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ())
someValidator :: Validator
someTypedValidator :: TypedValidator Any
someValidatorHash :: ValidatorHash
someCardanoAddress :: NetworkId -> CardanoAddress
someAddress :: Address
someValidatorV2 :: Validator
someTypedValidatorV2 :: TypedValidator Any
someValidatorHashV2 :: ValidatorHash
someCardanoAddressV2 :: NetworkId -> CardanoAddress
someAddressV2 :: Address
mkPolicy :: () -> ScriptContext -> Bool
mkPolicyV2 :: () -> ScriptContext -> Bool
coinMintingPolicy :: Language -> Versioned MintingPolicy
coinMintingPolicyV1 :: MintingPolicy
coinMintingPolicyV2 :: MintingPolicy
coinMintingPolicyHash :: Language -> MintingPolicyHash
coinMintingPolicyHashV1 :: MintingPolicyHash
coinMintingPolicyHashV2 :: MintingPolicyHash
coinMintingPolicyCurrencySymbol :: Language -> CurrencySymbol
coinMintingPolicyCurrencySymbolV1 :: CurrencySymbol
coinMintingPolicyCurrencySymbolV2 :: CurrencySymbol
someToken :: Language -> Value
asRedeemer :: ToData a => a -> Redeemer
asDatum :: ToData a => a -> Datum

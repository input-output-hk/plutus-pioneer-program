-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/plutus-apps#readme</a>
@package plutus-pab
@version 1.1.0.0

module Cardano.Api.NetworkId.Extra

-- | Wrapper for <a>NetworkId</a> to prevent the creation of orphan
--   instances.
newtype NetworkIdWrapper
NetworkIdWrapper :: NetworkId -> NetworkIdWrapper
[unNetworkIdWrapper] :: NetworkIdWrapper -> NetworkId

-- | A network ID for use in testing.
testnetNetworkId :: NetworkIdWrapper
instance GHC.Classes.Eq Cardano.Api.NetworkId.Extra.NetworkIdWrapper
instance GHC.Show.Show Cardano.Api.NetworkId.Extra.NetworkIdWrapper
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Api.NetworkId.Extra.NetworkIdWrapper
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.NetworkId.Extra.NetworkIdWrapper

module Cardano.Chain
type TxPool = [CardanoTx]
data MockNodeServerChainState
MockNodeServerChainState :: TxPool -> UtxoIndex -> Slot -> TChan Block -> Maybe Block -> MockNodeServerChainState
[_txPool] :: MockNodeServerChainState -> TxPool
[_index] :: MockNodeServerChainState -> UtxoIndex
[_currentSlot] :: MockNodeServerChainState -> Slot
[_channel] :: MockNodeServerChainState -> TChan Block
[_tip] :: MockNodeServerChainState -> Maybe Block
txPool :: Lens' MockNodeServerChainState TxPool
tip :: Lens' MockNodeServerChainState (Maybe Block)
index :: Lens' MockNodeServerChainState UtxoIndex
currentSlot :: Lens' MockNodeServerChainState Slot
channel :: Lens' MockNodeServerChainState (TChan Block)
emptyChainState :: MonadIO m => m MockNodeServerChainState
getChannel :: MonadIO m => MVar MockNodeServerChainState -> m (TChan Block)

-- | Build a PAB ChainState from a emulator ChainState
fromEmulatorChainState :: MonadIO m => ChainState -> m MockNodeServerChainState
getTip :: forall m. MonadIO m => MVar MockNodeServerChainState -> m Block
handleControlChain :: (Member (State MockNodeServerChainState) effs, Member (LogMsg ChainEvent) effs, LastMember m effs, MonadIO m) => Params -> ChainControlEffect ~> Eff effs
handleChain :: Member (State MockNodeServerChainState) effs => Params -> ChainEffect ~> Eff effs
logEvent :: Member (LogMsg ChainEvent) effs => ChainEvent -> Eff effs ()
addTxToPool :: CardanoTx -> TxPool -> TxPool

-- | Fetch the currently stored chain by iterating over the channel until
--   there is nothing left to be returned.
chainNewestFirst :: forall m. MonadIO m => TChan Block -> m [Block]
instance GHC.Show.Show Cardano.Chain.MockNodeServerChainState
instance GHC.Generics.Generic Cardano.Chain.MockNodeServerChainState


-- | This mock client has been used to test the PAB while we had no real
--   node available. Since now we do, this will be phased out and
--   eventually removed in favor of the <a>Client</a> module which connects
--   to a real cardano node.
module Cardano.Protocol.Socket.Mock.Client
newtype TxSendHandle
TxSendHandle :: TQueue (Tx BabbageEra) -> TxSendHandle
[tshQueue] :: TxSendHandle -> TQueue (Tx BabbageEra)

-- | Queue a transaction to be sent to the server.
queueTx :: TxSendHandle -> Tx BabbageEra -> IO ()
getCurrentSlot :: ChainSyncHandle Block -> IO Slot

-- | Run the chain sync protocol to get access to the current slot number.
runChainSync' :: FilePath -> SlotConfig -> IO (ChainSyncHandle Block)
runChainSync :: FilePath -> SlotConfig -> (Block -> Slot -> IO ()) -> IO (ChainSyncHandle Block)

-- | The client updates the application state when the protocol state
--   changes.
chainSyncClient :: SlotConfig -> (Block -> Slot -> IO ()) -> ChainSyncClient Block (Point Block) Tip IO ()
runTxSender :: FilePath -> IO TxSendHandle

-- | The client updates the application state when the protocol state
--   changes.
txSubmissionClient :: TQueue (Tx BabbageEra) -> LocalTxSubmissionClient (Tx BabbageEra) String IO ()

module Cardano.Wallet.Types
data WalletConfig
LocalWalletConfig :: LocalWalletSettings -> WalletConfig
[walletSettings] :: WalletConfig -> LocalWalletSettings
RemoteWalletConfig :: WalletConfig
newtype LocalWalletSettings
LocalWalletSettings :: WalletUrl -> LocalWalletSettings
[baseUrl] :: LocalWalletSettings -> WalletUrl
newtype WalletUrl
WalletUrl :: BaseUrl -> WalletUrl
defaultWalletConfig :: WalletConfig
walletSettingsL :: Traversal' WalletConfig LocalWalletSettings
baseUrlL :: Lens' LocalWalletSettings WalletUrl
_LocalWalletConfig :: Prism' WalletConfig LocalWalletSettings
_RemoteWalletConfig :: Prism' WalletConfig ()
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Types.WalletUrl
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Types.WalletUrl
instance GHC.Show.Show Cardano.Wallet.Types.WalletUrl
instance GHC.Classes.Eq Cardano.Wallet.Types.WalletUrl
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Types.LocalWalletSettings
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Types.LocalWalletSettings
instance GHC.Generics.Generic Cardano.Wallet.Types.LocalWalletSettings
instance GHC.Classes.Eq Cardano.Wallet.Types.LocalWalletSettings
instance GHC.Show.Show Cardano.Wallet.Types.LocalWalletSettings
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Types.WalletConfig
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Types.WalletConfig
instance GHC.Generics.Generic Cardano.Wallet.Types.WalletConfig
instance GHC.Classes.Eq Cardano.Wallet.Types.WalletConfig
instance GHC.Show.Show Cardano.Wallet.Types.WalletConfig
instance Data.Default.Class.Default Cardano.Wallet.Types.WalletConfig

module Control.Concurrent.Availability

-- | A semaphore-like construct whereby a service can signal to another
--   thread that it's finished its startup phase, and is now available to
--   use.
data Availability
newToken :: MonadIO m => m Availability
starting :: MonadIO m => Availability -> m ()
available :: MonadIO m => Availability -> m ()

module Control.Concurrent.STM.Extras.Stream

-- | An STM stream of <tt>a</tt>s (poor man's pull-based FRP)
data STMStream a

-- | Read the first event from the stream.
readOne :: STMStream a -> IO (a, Maybe (STMStream a))

-- | Read a number of events from the stream. Blocks until all events have
--   been received.
readN :: Natural -> STMStream a -> IO [a]

-- | Consume a stream. Blocks until the stream has terminated.
foldM :: STMStream a -> (a -> IO ()) -> IO () -> IO ()

-- | Produce an infinite stream of values from an STM (i.e. watch it for
--   updates). Uses the Eq instance to not output the same value twice in a
--   row.
unfold :: forall a. Eq a => STM a -> STMStream a

-- | Produce an infinite stream of values from an STM (i.e. watch it for
--   updates). Uses the Eq instance of <tt>b</tt> to not output the same
--   value twice in a row.
unfoldOn :: forall a b. Eq b => (a -> b) -> STM a -> STMStream a

-- | Build a stream containing only one element.
singleton :: STM a -> STMStream a

-- | Remove consecutive duplicates from a stream.
dedupe :: forall a. Eq a => STMStream a -> STMStream a
instance GHC.Base.Functor Control.Concurrent.STM.Extras.Stream.STMStream
instance GHC.Base.Applicative Control.Concurrent.STM.Extras.Stream.STMStream
instance GHC.Base.Monad Control.Concurrent.STM.Extras.Stream.STMStream
instance GHC.Classes.Eq a => GHC.Base.Semigroup (Control.Concurrent.STM.Extras.Stream.STMStream a)
instance GHC.Classes.Eq a => GHC.Base.Monoid (Control.Concurrent.STM.Extras.Stream.STMStream a)

module Control.Concurrent.STM.Extras

module Control.Monad.Freer.Delay
data DelayEffect r
[DelayThread] :: TimeUnit a => a -> DelayEffect ()
delayThread :: forall a_X1wTi. TimeUnit a_X1wTi => forall effs_a1wUe. Member DelayEffect effs_a1wUe => a_X1wTi -> Eff effs_a1wUe ()
handleDelayEffect :: forall effs m. (LastMember m effs, MonadIO m) => Eff (DelayEffect : effs) ~> Eff effs


-- | Temporary code that'll make it easy for us to generate arbitrary
--   events. This should either be deleted when we can get real events, or
--   at least moved across to the test suite.
module Plutus.PAB.Arbitrary

-- | A validator that always succeeds.
acceptingValidator :: Validator

-- | A minting policy that always succeeds.
acceptingMintingPolicy :: MintingPolicy

-- | Generate responses for mock requests. This function returns a
--   <a>Maybe</a> because we can't (yet) create a generator for every
--   request type.
genResponse :: PABReq -> Maybe (Gen PABResp)
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusTx.Builtins.Internal.BuiltinByteString
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Bytes.LedgerBytes
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Scripts.MintingPolicy
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Scripts.Script
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Scripts.ScriptHash
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Index.Internal.ValidationError
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Scripts.ScriptError
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Constraints.OffChain.MkTxError
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.Script.Utils.V1.Typed.Scripts.Validators.WrongOutTypeError
instance Test.QuickCheck.Arbitrary.Arbitrary Wallet.Emulator.Error.WalletAPIError
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Tx.CardanoAPI.Internal.ToCardanoError
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Tx.Internal.Tx
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Tx.Internal.TxIn
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Tx.Internal.TxInputType
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Tx.Internal.TxInput
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V2.Ledger.Tx.OutputDatum
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Tx.Internal.TxOut
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Tx.TxOutRef
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Tx.Internal.TxInType
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Tx.Internal.Withdrawal
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Tx.Internal.Certificate
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Credential.Credential
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Credential.StakingCredential
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.DCert.DCert
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Tx.ScriptTag
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Tx.RedeemerPtr
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Aeson.Types.Internal.Value
instance (Test.QuickCheck.Arbitrary.Generic.Arg (Plutus.V1.Ledger.Interval.Extended a) a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Plutus.V1.Ledger.Interval.Extended a)
instance (Test.QuickCheck.Arbitrary.Generic.Arg (Plutus.V1.Ledger.Interval.Extended a) a, Test.QuickCheck.Arbitrary.Generic.Arg (Plutus.V1.Ledger.Interval.LowerBound a) a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Plutus.V1.Ledger.Interval.LowerBound a)
instance (Test.QuickCheck.Arbitrary.Generic.Arg (Plutus.V1.Ledger.Interval.Extended a) a, Test.QuickCheck.Arbitrary.Generic.Arg (Plutus.V1.Ledger.Interval.UpperBound a) a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Plutus.V1.Ledger.Interval.UpperBound a)
instance (Test.QuickCheck.Arbitrary.Generic.Arg (Plutus.V1.Ledger.Interval.Extended a) a, Test.QuickCheck.Arbitrary.Generic.Arg (Plutus.V1.Ledger.Interval.LowerBound a) a, Test.QuickCheck.Arbitrary.Generic.Arg (Plutus.V1.Ledger.Interval.UpperBound a) a, Test.QuickCheck.Arbitrary.Generic.Arg (Plutus.V1.Ledger.Interval.Interval a) a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Plutus.V1.Ledger.Interval.Interval a)
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Crypto.PubKey
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Crypto.PubKeyHash
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Address.PaymentPubKey
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Address.PaymentPubKeyHash
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Address.StakePubKey
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Address.StakePubKeyHash
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Slot.Slot
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Tx.TxId
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Crypto.Signature
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusCore.Data.Data
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusTx.Builtins.Internal.BuiltinData
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Alonzo.Language.Language
instance (Test.QuickCheck.Arbitrary.Generic.Arg (Plutus.Script.Utils.Scripts.Versioned script) script, Test.QuickCheck.Arbitrary.Arbitrary script) => Test.QuickCheck.Arbitrary.Arbitrary (Plutus.Script.Utils.Scripts.Versioned script)
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Scripts.Datum
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Scripts.DatumHash
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Scripts.Redeemer
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Scripts.Validator
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Value.TokenName
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Value.CurrencySymbol
instance Test.QuickCheck.Arbitrary.Arbitrary Ledger.Ada.Ada
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Value.Value
instance (Test.QuickCheck.Arbitrary.Arbitrary k, Test.QuickCheck.Arbitrary.Arbitrary v) => Test.QuickCheck.Arbitrary.Arbitrary (PlutusTx.AssocMap.Map k v)
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.Contract.Effects.PABReq
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Address.Address
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Address.AddressInEra Cardano.Api.Eras.BabbageEra)
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.V1.Ledger.Scripts.ValidatorHash
instance Test.QuickCheck.Arbitrary.Arbitrary Wallet.Types.EndpointDescription
instance Test.QuickCheck.Arbitrary.Arbitrary Plutus.Contract.Effects.ActiveEndpoint

module Plutus.PAB.Core.Indexer.TxConfirmationStatus
type TCSIndex = SqliteIndex Event () TxId Result
data TxInfo
TxInfo :: TxId -> BlockNumber -> SlotNo -> TxInfo
[txId] :: TxInfo -> TxId
[blockNumber] :: TxInfo -> BlockNumber
[slotNumber] :: TxInfo -> SlotNo
newtype Depth
Depth :: Int -> Depth
open :: FilePath -> Depth -> IO TCSIndex
insert :: forall m h (v :: Type -> Type) e n q r. (Monad m, PrimMonad m, MVector (Mutable v) e) => e -> SplitIndex m h v e n q r -> m (SplitIndex m h v e n q r)
rewind :: forall (v :: Type -> Type) e (m :: Type -> Type) h n q r. MVector (Mutable v) e => Int -> SplitIndex m h v e n q r -> Maybe (SplitIndex m h v e n q r)
instance GHC.Generics.Generic Plutus.PAB.Core.Indexer.TxConfirmationStatus.TxInfo
instance GHC.Show.Show Plutus.PAB.Core.Indexer.TxConfirmationStatus.TxInfo
instance GHC.Classes.Eq Plutus.PAB.Core.Indexer.TxConfirmationStatus.TxInfo
instance Database.SQLite.Simple.FromField.FromField Plutus.ChainIndex.Types.BlockNumber
instance Database.SQLite.Simple.ToField.ToField Plutus.ChainIndex.Types.BlockNumber
instance Database.SQLite.Simple.FromField.FromField Cardano.Slotting.Slot.SlotNo
instance Database.SQLite.Simple.ToField.ToField Cardano.Slotting.Slot.SlotNo
instance Database.SQLite.Simple.ToRow.ToRow Plutus.PAB.Core.Indexer.TxConfirmationStatus.TxInfo
instance Database.SQLite.Simple.FromRow.FromRow Plutus.PAB.Core.Indexer.TxConfirmationStatus.TxInfo
instance Database.SQLite.Simple.FromField.FromField Plutus.V1.Ledger.Tx.TxId
instance Database.SQLite.Simple.ToField.ToField Plutus.V1.Ledger.Tx.TxId

module Plutus.PAB.Core.ContractInstance.STM

-- | Data about the blockchain that contract instances may be interested
--   in.
data BlockchainEnv
BlockchainEnv :: Maybe Int -> TVar Slot -> TVar Slot -> TVar BlockNumber -> Either (TVar (UtxoIndex TxIdState)) (IORef TCSIndex) -> TVar (UtxoIndex TxOutBalance) -> Params -> BlockchainEnv

-- | How much history do we retain in the environment. Zero signifies no
--   trimming is done.
[beRollbackHistory] :: BlockchainEnv -> Maybe Int

-- | Actual current slot
[beCurrentSlot] :: BlockchainEnv -> TVar Slot

-- | Slot of the last synced block from <tt>startNodeClient</tt>
[beLastSyncedBlockSlot] :: BlockchainEnv -> TVar Slot

-- | Last synced block number from <tt>startNodeClient</tt>.
[beLastSyncedBlockNo] :: BlockchainEnv -> TVar BlockNumber

-- | Map holding metadata which determines the status of transactions.
[beTxChanges] :: BlockchainEnv -> Either (TVar (UtxoIndex TxIdState)) (IORef TCSIndex)

-- | Map holding metadata which determines the status of transaction
--   outputs.
[beTxOutChanges] :: BlockchainEnv -> TVar (UtxoIndex TxOutBalance)

-- | The set of parameters, like protocol parameters and slot
--   configuration.
[beParams] :: BlockchainEnv -> Params

-- | Initialise an empty <a>BlockchainEnv</a> value
emptyBlockchainEnv :: Maybe Int -> Params -> STM BlockchainEnv

-- | Wait until the current slot is greater than or equal to the target
--   slot, then return the current slot.
awaitSlot :: Slot -> BlockchainEnv -> STM Slot

-- | Wait until the current time is greater than or equal to the target
--   time, then return the current time.
awaitTime :: POSIXTime -> BlockchainEnv -> STM POSIXTime

-- | Wait for an endpoint response.
awaitEndpointResponse :: Request ActiveEndpoint -> InstanceState -> STM (EndpointValue Value)

-- | Wait for the status of a transaction to change.
waitForTxStatusChange :: TxStatus -> TxId -> BlockchainEnv -> STM TxStatus
updateTxChangesR :: Either (TVar (UtxoIndex TxIdState)) (IORef TCSIndex) -> (TCSIndex -> IO TCSIndex) -> IO ()

-- | Wait for the status of a transaction output to change.
waitForTxOutStatusChange :: TxOutStatus -> TxOutRef -> BlockchainEnv -> STM TxOutStatus

-- | The current slot number
currentSlot :: BlockchainEnv -> STM Slot
lastSyncedBlockSlot :: BlockchainEnv -> STM Slot

-- | The state of an active contract instance.
data InstanceState
InstanceState :: TVar (Map (RequestID, IterationID) OpenEndpoint) -> TVar Activity -> TVar (Maybe Value) -> TMVar () -> TVar (Map (RequestID, IterationID) OpenTxOutSpentRequest) -> TVar (Map (RequestID, IterationID) OpenTxOutProducedRequest) -> TVar [ExportTx] -> InstanceState

-- | Open endpoints that can be responded to.
[issEndpoints] :: InstanceState -> TVar (Map (RequestID, IterationID) OpenEndpoint)

-- | Whether the instance is still running.
[issStatus] :: InstanceState -> TVar Activity

-- | Serialised observable state of the contract instance (if available)
[issObservableState] :: InstanceState -> TVar (Maybe Value)

-- | Stop the instance if a value is written into the TMVar.
[issStop] :: InstanceState -> TMVar ()
[issTxOutRefs] :: InstanceState -> TVar (Map (RequestID, IterationID) OpenTxOutSpentRequest)
[issAddressRefs] :: InstanceState -> TVar (Map (RequestID, IterationID) OpenTxOutProducedRequest)

-- | Partial tx that needs to be balanced, signed and submitted by an
--   external agent.
[issYieldedExportTxs] :: InstanceState -> TVar [ExportTx]

-- | An <a>InstanceState</a> value with empty fields
emptyInstanceState :: STM InstanceState

-- | An open endpoint that can be responded to.
data OpenEndpoint
OpenEndpoint :: ActiveEndpoint -> TMVar (EndpointValue Value) -> OpenEndpoint

-- | Name of the endpoint
[oepName] :: OpenEndpoint -> ActiveEndpoint

-- | A place to write the response to.
[oepResponse] :: OpenEndpoint -> TMVar (EndpointValue Value)
data OpenTxOutProducedRequest
OpenTxOutProducedRequest :: CardanoAddress -> TMVar (NonEmpty ChainIndexTx) -> OpenTxOutProducedRequest

-- | <tt>Address</tt> that the contract instance is watching (TODO: Should
--   be ViewAddress -- SCP-2628)
[otxAddress] :: OpenTxOutProducedRequest -> CardanoAddress

-- | A place to write the producing transactions to
[otxProducingTxns] :: OpenTxOutProducedRequest -> TMVar (NonEmpty ChainIndexTx)

-- | A TxOutRef that a contract instance is watching
data OpenTxOutSpentRequest
OpenTxOutSpentRequest :: TxOutRef -> TMVar ChainIndexTx -> OpenTxOutSpentRequest

-- | The <a>TxOutRef</a> that the instance is watching
[osrOutRef] :: OpenTxOutSpentRequest -> TxOutRef

-- | A place to write the spending transaction to
[osrSpendingTx] :: OpenTxOutSpentRequest -> TMVar ChainIndexTx

-- | Empty the list of open enpoints that can be called on the instance
clearEndpoints :: InstanceState -> STM ()

-- | Add an active endpoint to the instance's list of active endpoints.
addEndpoint :: Request ActiveEndpoint -> InstanceState -> STM ()

-- | Add a new <a>OpenTxOutSpentRequest</a> to the instance's list of utxo
--   spent requests
addUtxoSpentReq :: Request TxOutRef -> InstanceState -> STM ()
waitForUtxoSpent :: Request TxOutRef -> InstanceState -> STM ChainIndexTx

-- | Add a new <a>OpenTxOutProducedRequest</a> to the instance's list of
--   utxo produced requests
addUtxoProducedReq :: Request CardanoAddress -> InstanceState -> STM ()
waitForUtxoProduced :: Request CardanoAddress -> InstanceState -> STM (NonEmpty ChainIndexTx)

-- | Set the <a>Activity</a> of the instance
setActivity :: Activity -> InstanceState -> STM ()

-- | Write a new value into the contract instance's observable state.
setObservableState :: Value -> InstanceState -> STM ()

-- | The list of all endpoints that can be called on the instance
openEndpoints :: InstanceState -> STM (Map (RequestID, IterationID) OpenEndpoint)

-- | Call an endpoint with a JSON value.
callEndpoint :: OpenEndpoint -> EndpointValue Value -> STM ()

-- | Return the final state of the contract when it is finished (possibly
--   an error)
finalResult :: InstanceState -> STM (Maybe Value)

-- | Whether the contract instance is still waiting for an event.
data Activity
Active :: Activity

-- | Instance was stopped before all requests were handled
Stopped :: Activity

-- | Instance finished, possibly with an error
Done :: Maybe Value -> Activity

-- | State of all contract instances that are currently running
data InstancesState

-- | Initialise the <a>InstancesState</a> with an empty value
emptyInstancesState :: IO InstancesState

-- | Insert an <a>InstanceState</a> value into the <a>InstancesState</a>
insertInstance :: ContractInstanceId -> InstanceState -> InstancesState -> IO ()

-- | Delete an instance from the <a>InstancesState</a>
removeInstance :: ContractInstanceId -> InstancesState -> IO ()

-- | Call an endpoint on a contract instance. Fail immediately if the
--   endpoint is not active.
callEndpointOnInstance :: InstancesState -> EndpointDescription -> Value -> ContractInstanceId -> IO (STM (Maybe NotificationError))

-- | Call an endpoint on a contract instance. If the endpoint is not
--   active, wait until the TMVar is filled, then fail. (if the endpoint
--   becomes active in the meantime it will be called)
callEndpointOnInstanceTimeout :: TMVar () -> InstancesState -> EndpointDescription -> Value -> ContractInstanceId -> IO (STM (Maybe NotificationError))

-- | Get the observable state of the contract instance. Blocks if the state
--   is not available yet.
observableContractState :: InstanceState -> STM Value

-- | The list of all partial txs that need to be balanced on the instance.
yieldedExportTxs :: InstanceState -> STM [ExportTx]

-- | The <a>InstanceState</a> of the contract instance. Retries if the
--   state can't be found in the map.
instanceState :: ContractInstanceId -> InstancesState -> IO (Maybe InstanceState)

-- | The IDs of all contract instances
instanceIDs :: InstancesState -> IO (Set ContractInstanceId)

-- | The IDs of contract instances with their statuses
instancesWithStatuses :: InstancesState -> IO (STM (Map ContractInstanceId ContractActivityStatus))
instancesClientEnv :: InstancesState -> IO (STM InstanceClientEnv)

-- | Events that the contract instances are waiting for, indexed by keys
--   that are readily available in the node client (ie. that can be
--   produced from just a block without any additional information)
data InstanceClientEnv
InstanceClientEnv :: Map TxOutRef [OpenTxOutSpentRequest] -> Map CardanoAddress [OpenTxOutProducedRequest] -> InstanceClientEnv
[ceUtxoSpentRequests] :: InstanceClientEnv -> Map TxOutRef [OpenTxOutSpentRequest]
[ceUtxoProducedRequests] :: InstanceClientEnv -> Map CardanoAddress [OpenTxOutProducedRequest]
instance GHC.Show.Show Plutus.PAB.Core.ContractInstance.STM.Activity
instance GHC.Classes.Eq Plutus.PAB.Core.ContractInstance.STM.Activity
instance GHC.Base.Semigroup Plutus.PAB.Core.ContractInstance.STM.InstanceClientEnv
instance GHC.Base.Monoid Plutus.PAB.Core.ContractInstance.STM.InstanceClientEnv

module Cardano.Wallet.RemoteClient

-- | Wallet effect handler to remote client scenario.
--   
--   Useful for browser-based wallets (Nami, Yoroi, etc.) where the PAB
--   doesn't have direct access.
--   
--   TODO: All wallet effects, except <a>YieldUnbalancedTx</a> need to be
--   implemented. See SCP-3094.
handleWalletClient :: forall m effs. (LastMember m effs, MonadIO m, Member NodeClientEffect effs, Member (Error WalletAPIError) effs, Member (Reader InstancesState) effs) => Maybe ContractInstanceId -> WalletEffect ~> Eff effs

module Plutus.PAB.Db.Schema
data ContractInstanceT f
ContractInstance :: Columnar f Text -> Columnar f Text -> Columnar f Text -> Columnar f (Maybe Text) -> Columnar f Bool -> ContractInstanceT f
[_contractInstanceId] :: ContractInstanceT f -> Columnar f Text
[_contractInstanceContractId] :: ContractInstanceT f -> Columnar f Text
[_contractInstanceWallet] :: ContractInstanceT f -> Columnar f Text
[_contractInstanceState] :: ContractInstanceT f -> Columnar f (Maybe Text)
[_contractInstanceActive] :: ContractInstanceT f -> Columnar f Bool
contractInstanceId :: forall (f1 :: Type -> Type) f2. Functor f2 => (Columnar f1 Text -> f2 (Columnar f1 Text)) -> ContractInstanceT f1 -> f2 (ContractInstanceT f1)
type ContractInstance = ContractInstanceT Identity
type ContractInstanceId = PrimaryKey ContractInstanceT Identity
data Db f
Db :: f (TableEntity ContractInstanceT) -> Db f
[_contractInstances] :: Db f -> f (TableEntity ContractInstanceT)
db :: DatabaseSettings be Db
checkedSqliteDb :: CheckedDatabaseSettings Sqlite Db
checkedPostgresDb :: CheckedDatabaseSettings Postgres Db
instance Database.Beam.Schema.Tables.Beamable Plutus.PAB.Db.Schema.ContractInstanceT
instance GHC.Generics.Generic (Plutus.PAB.Db.Schema.ContractInstanceT f)
instance Database.Beam.Schema.Tables.Beamable (Database.Beam.Schema.Tables.PrimaryKey Plutus.PAB.Db.Schema.ContractInstanceT)
instance GHC.Generics.Generic (Database.Beam.Schema.Tables.PrimaryKey Plutus.PAB.Db.Schema.ContractInstanceT f)
instance Database.Beam.Schema.Tables.Database be Plutus.PAB.Db.Schema.Db
instance GHC.Generics.Generic (Plutus.PAB.Db.Schema.Db f)
instance Database.Beam.Schema.Tables.Table Plutus.PAB.Db.Schema.ContractInstanceT

module Plutus.PAB.Effects.TimeEffect
data TimeEffect r
[SystemTime] :: TimeEffect Slot
systemTime :: forall effs_a2dGi. Member TimeEffect effs_a2dGi => Eff effs_a2dGi Slot

module Plutus.PAB.Effects.UUID
data UUIDEffect r
[UuidNextRandom] :: UUIDEffect UUID
uuidNextRandom :: forall effs_a2dJe. Member UUIDEffect effs_a2dJe => Eff effs_a2dJe UUID
handleUUIDEffect :: (LastMember m effs, MonadIO m) => Eff (UUIDEffect : effs) ~> Eff effs

module Plutus.PAB.Events.Contract

-- | Unique ID for contract instance
newtype ContractInstanceId
ContractInstanceId :: UUID -> ContractInstanceId
[unContractInstanceId] :: ContractInstanceId -> UUID

-- | A value that uniquely identifies groups of requests.
data IterationID

module Plutus.PAB.Events.ContractInstanceState
data PartiallyDecodedResponse v
PartiallyDecodedResponse :: [Request v] -> [LogMessage Value] -> [LogMessage Value] -> Maybe Value -> Value -> PartiallyDecodedResponse v
[hooks] :: PartiallyDecodedResponse v -> [Request v]
[logs] :: PartiallyDecodedResponse v -> [LogMessage Value]
[lastLogs] :: PartiallyDecodedResponse v -> [LogMessage Value]
[err] :: PartiallyDecodedResponse v -> Maybe Value
[observableState] :: PartiallyDecodedResponse v -> Value
fromResp :: ContractResponse Value Value s v -> PartiallyDecodedResponse v

-- | Whether the instance has any active requests
hasActiveRequests :: forall w s e a. ContractResponse w e s a -> Bool
instance Data.OpenApi.Internal.Schema.ToSchema v => Data.OpenApi.Internal.Schema.ToSchema (Plutus.PAB.Events.ContractInstanceState.PartiallyDecodedResponse v)
instance Data.Aeson.Types.FromJSON.FromJSON v => Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Events.ContractInstanceState.PartiallyDecodedResponse v)
instance Data.Aeson.Types.ToJSON.ToJSON v => Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Events.ContractInstanceState.PartiallyDecodedResponse v)
instance Data.Traversable.Traversable Plutus.PAB.Events.ContractInstanceState.PartiallyDecodedResponse
instance Data.Foldable.Foldable Plutus.PAB.Events.ContractInstanceState.PartiallyDecodedResponse
instance GHC.Base.Functor Plutus.PAB.Events.ContractInstanceState.PartiallyDecodedResponse
instance GHC.Generics.Generic (Plutus.PAB.Events.ContractInstanceState.PartiallyDecodedResponse v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Plutus.PAB.Events.ContractInstanceState.PartiallyDecodedResponse v)
instance GHC.Show.Show v => GHC.Show.Show (Plutus.PAB.Events.ContractInstanceState.PartiallyDecodedResponse v)
instance Prettyprinter.Internal.Pretty v => Prettyprinter.Internal.Pretty (Plutus.PAB.Events.ContractInstanceState.PartiallyDecodedResponse v)

module Cardano.BM.Data.Tracer.Extras

-- | A structured log object with a textual description and additional
--   fields.
mkObjectStr :: StructuredLog k => Text -> k -> KeyMap Value

-- | Deriving <a>ToObject</a> from <a>Pretty</a>
newtype PrettyToObject a
PrettyToObject :: a -> PrettyToObject a
[unPrettyToObject] :: PrettyToObject a -> a

-- | Types that can be turned into structured log messages
class StructuredLog a
toStructuredLog :: StructuredLog a => a -> KeyMap Value

-- | A <tt><a>Tagged</a> s b</tt> value is a value <tt>b</tt> with an
--   attached phantom type <tt>s</tt>. This can be used in place of the
--   more traditional but less safe idiom of passing in an undefined value
--   with the type, because unlike an <tt>(s -&gt; b)</tt>, a
--   <tt><a>Tagged</a> s b</tt> can't try to use the argument <tt>s</tt> as
--   a real value.
--   
--   Moreover, you don't have to rely on the compiler to inline away the
--   extra argument, because the newtype is "free"
--   
--   <a>Tagged</a> has kind <tt>k -&gt; * -&gt; *</tt> if the compiler
--   supports <tt>PolyKinds</tt>, therefore there is an extra <tt>k</tt>
--   showing in the instance haddocks that may cause confusion.
newtype Tagged (s :: k) b
Tagged :: b -> Tagged (s :: k) b
instance Cardano.BM.Data.Tracer.Extras.StructuredLog Wallet.Types.ContractInstanceId
instance Cardano.BM.Data.Tracer.Extras.StructuredLog Plutus.Contract.Resumable.IterationID
instance Cardano.BM.Data.Tracer.Extras.StructuredLog Plutus.Contract.Checkpoint.CheckpointLogMsg
instance Cardano.BM.Data.Tracer.Extras.StructuredLog Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance Cardano.BM.Data.Tracer.Extras.StructuredLog Wallet.Emulator.LogMessages.TxBalanceMsg
instance Cardano.BM.Data.Tracer.Extras.StructuredLog Ledger.Tx.Internal.Tx
instance Cardano.BM.Data.Tracer.Extras.StructuredLog Data.UUID.Types.Internal.UUID
instance (Data.Aeson.Types.ToJSON.ToJSON w, Data.Aeson.Types.ToJSON.ToJSON v) => Cardano.BM.Data.Tracer.Extras.StructuredLog (Plutus.Contract.State.ContractRequest w v)
instance Cardano.BM.Data.Tracer.Extras.StructuredLog Plutus.V1.Ledger.Value.Value
instance Cardano.BM.Data.Tracer.Extras.StructuredLog Wallet.Types.EndpointDescription
instance Cardano.BM.Data.Tracer.Extras.StructuredLog ()
instance (Cardano.BM.Data.Tracer.Extras.StructuredLog a, Cardano.BM.Data.Tracer.Extras.StructuredLog b) => Cardano.BM.Data.Tracer.Extras.StructuredLog (a, b)
instance (Cardano.BM.Data.Tracer.Extras.StructuredLog a, Cardano.BM.Data.Tracer.Extras.StructuredLog b, Cardano.BM.Data.Tracer.Extras.StructuredLog c) => Cardano.BM.Data.Tracer.Extras.StructuredLog (a, b, c)
instance (Cardano.BM.Data.Tracer.Extras.StructuredLog a, Cardano.BM.Data.Tracer.Extras.StructuredLog b, Cardano.BM.Data.Tracer.Extras.StructuredLog c, Cardano.BM.Data.Tracer.Extras.StructuredLog d) => Cardano.BM.Data.Tracer.Extras.StructuredLog (a, b, c, d)
instance (Cardano.BM.Data.Tracer.Extras.StructuredLog a, Cardano.BM.Data.Tracer.Extras.StructuredLog b) => Cardano.BM.Data.Tracer.Extras.StructuredLog (Data.Either.Either a b)
instance Cardano.BM.Data.Tracer.Extras.StructuredLog a => Cardano.BM.Data.Tracer.Extras.StructuredLog (GHC.Maybe.Maybe a)
instance Data.Aeson.Types.ToJSON.ToJSON v => Cardano.BM.Data.Tracer.Extras.StructuredLog (Plutus.PAB.Events.ContractInstanceState.PartiallyDecodedResponse v)
instance Data.Aeson.Types.ToJSON.ToJSON v => Cardano.BM.Data.Tracer.Extras.StructuredLog (Plutus.Contract.Resumable.Response v)
instance (GHC.TypeLits.KnownSymbol s, Data.Aeson.Types.ToJSON.ToJSON a) => Cardano.BM.Data.Tracer.Extras.StructuredLog (Data.Tagged.Tagged s a)
instance Prettyprinter.Internal.Pretty a => Cardano.BM.Data.Tracer.ToObject (Cardano.BM.Data.Tracer.Extras.PrettyToObject a)


-- | This module exports data types for logging, events and configuration
module Cardano.Node.Types

-- | Top-level logging data type for structural logging inside the PAB
--   server.
data PABServerLogMsg
StartingSlotCoordination :: UTCTime -> Millisecond -> PABServerLogMsg
NoRandomTxGeneration :: PABServerLogMsg
StartingRandomTx :: PABServerLogMsg
KeepingOldBlocks :: PABServerLogMsg
RemovingOldBlocks :: PABServerLogMsg
StartingPABServer :: Int -> PABServerLogMsg
ProcessingChainEvent :: ChainEvent -> PABServerLogMsg
BlockOperation :: BlockEvent -> PABServerLogMsg
CreatingRandomTransaction :: PABServerLogMsg
TxSendCalledWithoutMock :: PABServerLogMsg
data BlockEvent
NewSlot :: BlockEvent
NewTransaction :: Tx BabbageEra -> BlockEvent
type NodeServerEffects m = '[ChainControlEffect, ChainEffect, State MockNodeServerChainState, LogMsg PABServerLogMsg, Reader (Maybe TxSendHandle), State AppState, LogMsg PABServerLogMsg, m]

-- | The types of handles varies based on the type of clients (mocked or
--   real nodes) and we need a generic way of handling either type of
--   response.
type ChainSyncHandle = Either (ChainSyncHandle Block) (ChainSyncHandle ChainSyncEvent)

-- | Application State
data AppState
AppState :: MockNodeServerChainState -> [LogMessage PABServerLogMsg] -> AppState

-- | blockchain state
[_chainState] :: AppState -> MockNodeServerChainState

-- | history of all log messages
[_eventHistory] :: AppState -> [LogMessage PABServerLogMsg]

-- | <a>AppState</a> with an initial transaction that pays some Ada to the
--   wallets.
initialAppState :: MonadIO m => [Wallet] -> m AppState

-- | <tt>ChainState</tt> with initial values
initialChainState :: MonadIO m => InitialDistribution -> m MockNodeServerChainState
chainState :: Lens' AppState MockNodeServerChainState
eventHistory :: Lens' AppState [LogMessage PABServerLogMsg]

-- | Node server configuration
data PABServerConfig
PABServerConfig :: BaseUrl -> [WalletNumber] -> FilePath -> Integer -> SlotConfig -> NetworkIdWrapper -> Maybe FilePath -> Maybe Text -> NodeMode -> PABServerConfig

-- | base url of the service
[pscBaseUrl] :: PABServerConfig -> BaseUrl

-- | The wallets that receive money from the initial transaction.
[pscInitialTxWallets] :: PABServerConfig -> [WalletNumber]

-- | Path to the socket used to communicate with the server.
[pscSocketPath] :: PABServerConfig -> FilePath

-- | The number of blocks to keep for replaying to a newly connected
--   clients
[pscKeptBlocks] :: PABServerConfig -> Integer

-- | Beginning of slot 0.
[pscSlotConfig] :: PABServerConfig -> SlotConfig

-- | NetworkId that's used with the CardanoAPI.
[pscNetworkId] :: PABServerConfig -> NetworkIdWrapper

-- | Path to a JSON file containing the protocol parameters
[pscProtocolParametersJsonPath] :: PABServerConfig -> Maybe FilePath

-- | Wallet passphrase
[pscPassphrase] :: PABServerConfig -> Maybe Text

-- | Whether to connect to an Alonzo node or a mock node
[pscNodeMode] :: PABServerConfig -> NodeMode

-- | Which node we're connecting to
data NodeMode

-- | Connect to the PAB mock node.
MockNode :: NodeMode

-- | Connect to an Alonzo node
AlonzoNode :: NodeMode

-- | Do not connect to any node for chain sync events. Connect to Alonzo
--   node for slot notifications.
NoChainSyncEvents :: NodeMode
_MockNode :: Prism' NodeMode ()
_AlonzoNode :: Prism' NodeMode ()
newtype NodeUrl
NodeUrl :: BaseUrl -> NodeUrl
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Node.Types.PABServerConfig
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Node.Types.PABServerConfig
instance GHC.Generics.Generic Cardano.Node.Types.PABServerConfig
instance GHC.Classes.Eq Cardano.Node.Types.PABServerConfig
instance GHC.Show.Show Cardano.Node.Types.PABServerConfig
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Node.Types.BlockEvent
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Node.Types.BlockEvent
instance GHC.Show.Show Cardano.Node.Types.BlockEvent
instance GHC.Generics.Generic Cardano.Node.Types.BlockEvent
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Node.Types.PABServerLogMsg
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Node.Types.PABServerLogMsg
instance GHC.Show.Show Cardano.Node.Types.PABServerLogMsg
instance GHC.Generics.Generic Cardano.Node.Types.PABServerLogMsg
instance GHC.Show.Show Cardano.Node.Types.AppState
instance Prettyprinter.Internal.Pretty Cardano.Node.Types.PABServerLogMsg
instance Cardano.BM.Data.Tracer.ToObject Cardano.Node.Types.PABServerLogMsg
instance Prettyprinter.Internal.Pretty Cardano.Node.Types.BlockEvent
instance Data.Default.Class.Default Cardano.Node.Types.PABServerConfig
instance Prettyprinter.Internal.Pretty Cardano.Node.Types.PABServerConfig
instance GHC.Classes.Eq Cardano.Node.Types.NodeUrl
instance GHC.Show.Show Cardano.Node.Types.NodeUrl
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Node.Types.NodeMode
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Node.Types.NodeMode
instance GHC.Generics.Generic Cardano.Node.Types.NodeMode
instance GHC.Classes.Eq Cardano.Node.Types.NodeMode
instance GHC.Show.Show Cardano.Node.Types.NodeMode

module Cardano.Protocol.Socket.Mock.Server
data CommandChannel
CommandChannel :: TQueue ServerCommand -> TQueue ServerResponse -> CommandChannel
[ccCommand] :: CommandChannel -> TQueue ServerCommand
[ccResponse] :: CommandChannel -> TQueue ServerResponse
type Error a = Either Text a

-- | Clone the original channel for each connected client, then use this
--   wrapper to make sure that no data is consumed from the original
--   channel.
newtype LocalChannel
LocalChannel :: TChan Block -> LocalChannel

-- | A handler used to pass around the path to the server and channels used
--   for controlling the server.
data ServerHandler
ServerHandler :: FilePath -> CommandChannel -> ServerHandler
[shSocketPath] :: ServerHandler -> FilePath
[shCommandChannel] :: ServerHandler -> CommandChannel

-- | The commands that control the server. This API is not part of the
--   client interface, and in order to call them directly you will need
--   access to the returned ServerHandler
data ServerCommand
ProcessBlock :: ServerCommand
ModifySlot :: (Slot -> Slot) -> ServerCommand
AddTx :: Tx BabbageEra -> ServerCommand

-- | The response from the server. Can be used for the information passed
--   back, or for synchronisation.
data ServerResponse
BlockAdded :: Block -> ServerResponse
SlotChanged :: Slot -> ServerResponse
processBlock :: MonadIO m => ServerHandler -> m Block
modifySlot :: MonadIO m => (Slot -> Slot) -> ServerHandler -> m Slot
addTx :: MonadIO m => ServerHandler -> Tx BabbageEra -> m ()
pruneChain :: MonadIO m => Integer -> TChan Block -> m ThreadId
handleCommand :: MonadIO m => Trace IO PABServerLogMsg -> CommandChannel -> MVar MockNodeServerChainState -> Params -> m ()

-- | Start the server in a new thread, and return a server handler used to
--   control the server
runServerNode :: MonadIO m => Trace IO PABServerLogMsg -> FilePath -> Integer -> MockNodeServerChainState -> Params -> m ServerHandler
type ChainSyncMonad = ReaderT (MVar MockNodeServerChainState) IO
runChainSync :: MVar MockNodeServerChainState -> ChainSyncMonad a -> IO a
idleState :: (MonadReader (MVar MockNodeServerChainState) m, MonadIO m) => LocalChannel -> m (ServerStIdle Block (Point Block) Tip m ())
nextState :: (MonadReader (MVar MockNodeServerChainState) m, MonadIO m) => LocalChannel -> m (Either (ServerStNext Block (Point Block) Tip m ()) (m (ServerStNext Block (Point Block) Tip m ())))
findIntersect :: (MonadReader (MVar MockNodeServerChainState) m, MonadIO m) => [Point Block] -> m (ServerStIntersect Block (Point Block) Tip m ())
sendRollForward :: (MonadReader (MVar MockNodeServerChainState) m, MonadIO m) => LocalChannel -> Block -> Block -> m (ServerStNext Block (Point Block) Tip m ())
chainSyncServer :: (MonadReader (MVar MockNodeServerChainState) m, MonadIO m) => ChainSyncServer Block (Point Block) Tip m ()
cloneChainFrom :: forall m. (MonadReader (MVar MockNodeServerChainState) m, MonadIO m) => Integer -> m LocalChannel
hoistChainSync :: MonadReader (MVar MockNodeServerChainState) m => ChainSyncServer Block (Point Block) Tip ChainSyncMonad a -> m (ChainSyncServer Block (Point Block) Tip IO a)
hoistStIdle :: MonadReader (MVar MockNodeServerChainState) m => ServerStIdle Block (Point Block) Tip ChainSyncMonad a -> m (ServerStIdle Block (Point Block) Tip IO a)
hoistStIntersect :: MonadReader (MVar MockNodeServerChainState) m => ServerStIntersect Block (Point Block) Tip ChainSyncMonad a -> m (ServerStIntersect Block (Point Block) Tip IO a)
hoistStNext :: MonadReader (MVar MockNodeServerChainState) m => ServerStNext Block (Point Block) Tip ChainSyncMonad a -> m (ServerStNext Block (Point Block) Tip IO a)
protocolLoop :: MonadIO m => FilePath -> MVar MockNodeServerChainState -> m Void
nodeToClientProtocols :: MVar MockNodeServerChainState -> NodeToClientProtocols 'ResponderMode ByteString IO Void ()
chainSync :: MVar MockNodeServerChainState -> RunMiniProtocol 'ResponderMode ByteString IO Void ()
txSubmission :: MVar MockNodeServerChainState -> RunMiniProtocol 'ResponderMode ByteString IO Void ()
pointOffset :: Point Block -> Integer
getChainPoints :: MonadIO m => TChan Block -> MockNodeServerChainState -> m [Point Block]
txSubmissionServer :: MVar MockNodeServerChainState -> LocalTxSubmissionServer (Tx BabbageEra) String IO ()
instance GHC.Show.Show Cardano.Protocol.Socket.Mock.Server.ServerResponse
instance GHC.Show.Show Cardano.Protocol.Socket.Mock.Server.ServerCommand

module Cardano.Node.Params
fromPABServerConfig :: PABServerConfig -> IO Params
readProtocolParameters :: Maybe FilePath -> IO ProtocolParameters

module Cardano.Node.API
type API = "healthcheck" :> Get '[JSON] NoContent :<|> "mock" :> NodeAPI
type NodeAPI = "consume-event-history" :> Post '[JSON] [LogMessage PABServerLogMsg]

module Cardano.ChainIndex.Types
type ChainIndexEffects m = '[ChainIndexControlEffect, ChainIndexQueryEffect, State ChainIndexEmulatorState, LogMsg ChainIndexLog, Error ChainIndexError, m]
newtype ChainIndexUrl
ChainIndexUrl :: BaseUrl -> ChainIndexUrl
newtype ChainIndexConfig
ChainIndexConfig :: ChainIndexUrl -> ChainIndexConfig
[ciBaseUrl] :: ChainIndexConfig -> ChainIndexUrl
defaultChainIndexConfig :: ChainIndexConfig

-- | Messages from the ChainIndex Server
data ChainIndexServerMsg

-- | Starting a node client thread
StartingNodeClientThread :: ChainIndexServerMsg

-- | Port number | Received transaction
StartingChainIndex :: Int -> ChainIndexServerMsg
ReceivedBlocksTxns :: Int -> Int -> ChainIndexServerMsg
ChainEvent :: ChainIndexLog -> ChainIndexServerMsg
type ChainIndexTrace = Trace IO ChainIndexServerMsg
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.ChainIndex.Types.ChainIndexServerMsg
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.ChainIndex.Types.ChainIndexServerMsg
instance GHC.Generics.Generic Cardano.ChainIndex.Types.ChainIndexServerMsg
instance GHC.Show.Show Cardano.ChainIndex.Types.ChainIndexServerMsg
instance Prettyprinter.Internal.Pretty Cardano.ChainIndex.Types.ChainIndexServerMsg
instance Cardano.BM.Data.Tracer.ToObject Cardano.ChainIndex.Types.ChainIndexServerMsg
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.ChainIndex.Types.ChainIndexUrl
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.ChainIndex.Types.ChainIndexUrl
instance GHC.Show.Show Cardano.ChainIndex.Types.ChainIndexUrl
instance GHC.Classes.Eq Cardano.ChainIndex.Types.ChainIndexUrl
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.ChainIndex.Types.ChainIndexConfig
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.ChainIndex.Types.ChainIndexConfig
instance GHC.Generics.Generic Cardano.ChainIndex.Types.ChainIndexConfig
instance GHC.Classes.Eq Cardano.ChainIndex.Types.ChainIndexConfig
instance GHC.Show.Show Cardano.ChainIndex.Types.ChainIndexConfig
instance Data.Default.Class.Default Cardano.ChainIndex.Types.ChainIndexConfig

module Plutus.PAB.Instances
instance Cardano.BM.Data.Tracer.Extras.StructuredLog Language.Haskell.TH.Syntax.Loc
instance Cardano.BM.Data.Tracer.Extras.StructuredLog Control.Monad.Logger.LogSource
instance Data.Aeson.Types.ToJSON.ToJSON Language.Haskell.TH.Syntax.Loc
instance Data.Aeson.Types.FromJSON.FromJSON Language.Haskell.TH.Syntax.Loc
instance Web.Internal.HttpApiData.ToHttpApiData Wallet.Types.ContractInstanceId
instance Web.Internal.HttpApiData.FromHttpApiData Wallet.Types.ContractInstanceId
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Wallet.Types.ContractInstanceId
instance Cardano.BM.Data.Tracer.ToObject Wallet.Emulator.Wallet.WalletEvent
instance Data.Aeson.Types.FromJSON.FromJSON Servant.Client.Core.ClientError.ClientError
instance Data.Aeson.Types.ToJSON.ToJSON Servant.Client.Core.ClientError.ClientError

module Plutus.PAB.Monitoring.Config

-- | A default <a>Configuration</a> that logs on <a>Info</a> and above to
--   stdout
defaultConfig :: IO Configuration

-- | Load a <a>Configuration</a> from a YAML file.
loadConfig :: FilePath -> IO Configuration

module Plutus.PAB.Run.Command

-- | A command for which a config.yaml file is required
data ConfigCommand
Migrate :: ConfigCommand

-- | Run the mock node service
StartNode :: ConfigCommand

-- | Run the mock wallet service
MockWallet :: ConfigCommand

-- | Run the chain index service
ChainIndex :: ConfigCommand

-- | Fork a list of commands
ForkCommands :: [ConfigCommand] -> ConfigCommand

-- | Display the contract identified by <a>ContractInstanceId</a>
ContractState :: ContractInstanceId -> ConfigCommand

-- | Get the history of the contract identified by <tt>UUID</tt>
ReportContractHistory :: ContractInstanceId -> ConfigCommand

-- | Get all available contracts
ReportAvailableContracts :: ConfigCommand

-- | Get active contracts
ReportActiveContracts :: ConfigCommand

-- | Run the PAB webserver
PABWebserver :: ConfigCommand

-- | A single command to the PAB that spins up all the necessary services.
allServices :: ConfigCommand
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Run.Command.ConfigCommand
instance GHC.Generics.Generic Plutus.PAB.Run.Command.ConfigCommand
instance GHC.Classes.Eq Plutus.PAB.Run.Command.ConfigCommand
instance GHC.Show.Show Plutus.PAB.Run.Command.ConfigCommand

module Plutus.PAB.Timeout
newtype Timeout
Timeout :: Maybe Second -> Timeout
[unTimeout] :: Timeout -> Maybe Second

-- | Create a <a>TMVar</a> that is filled when the timeout expires. If the
--   timeout is <a>Nothing</a>, the <a>TMVar</a> is never filled.
startTimeout :: Timeout -> IO (TMVar ())
instance Data.Default.Class.Default Plutus.PAB.Timeout.Timeout

module Plutus.PAB.Types
data PABError
FileNotFound :: FilePath -> PABError
ContractNotFound :: FilePath -> PABError
ContractInstanceNotFound :: ContractInstanceId -> PABError
PABContractError :: ContractError -> PABError
WalletClientError :: ClientError -> PABError
NodeClientError :: ClientError -> PABError
BeamEffectError :: BeamError -> PABError
RandomTxClientError :: ClientError -> PABError
ChainIndexError :: ClientError -> PABError
WalletError :: WalletAPIError -> PABError
ContractCommandError :: Int -> Text -> PABError
InvalidUUIDError :: Text -> PABError
OtherError :: Text -> PABError
EndpointCallError :: NotificationError -> PABError

-- | Attempt to stop the instance failed because it was not running
InstanceAlreadyStopped :: ContractInstanceId -> PABError
WalletNotFound :: Wallet -> PABError
MissingConfigFileOption :: PABError
ContractStateNotFound :: ContractInstanceId -> PABError
AesonDecodingError :: Text -> Text -> PABError
MigrationNotDoneError :: Text -> PABError
RemoteWalletWithMockNodeError :: PABError
TxSenderNotAvailable :: PABError
data DBConnection
PostgresPool :: Pool Connection -> DBConnection
SqlitePool :: Pool Connection -> DBConnection
data DbConfig
SqliteDB :: DbConfig -> DbConfig
PostgresDB :: DbConfig -> DbConfig
takeSqliteDB :: DbConfig -> DbConfig
takePostgresDB :: DbConfig -> DbConfig

-- | Default database config uses an in-memory sqlite database that is
--   shared between all threads in the process.
defaultDbConfig :: DbConfig
data ChainQueryConfig
ChainIndexConfig :: ChainIndexConfig -> ChainQueryConfig
BlockfrostConfig :: BlockfrostConfig -> ChainQueryConfig
data ChainQueryEnv
ChainIndexEnv :: ClientEnv -> ChainQueryEnv
BlockfrostEnv :: BlockfrostEnv -> ChainQueryEnv
getChainIndexEnv :: ChainQueryEnv -> ClientEnv
getBlockfrostEnv :: ChainQueryEnv -> BlockfrostEnv
data Config
Config :: DbConfig -> WalletConfig -> PABServerConfig -> WebserverConfig -> ChainQueryConfig -> RequestProcessingConfig -> DevelopmentOptions -> Config
[dbConfig] :: Config -> DbConfig
[walletServerConfig] :: Config -> WalletConfig
[nodeServerConfig] :: Config -> PABServerConfig
[pabWebserverConfig] :: Config -> WebserverConfig
[chainQueryConfig] :: Config -> ChainQueryConfig
[requestProcessingConfig] :: Config -> RequestProcessingConfig
[developmentOptions] :: Config -> DevelopmentOptions
mergeObjects :: Value -> Value -> Value
defaultConfig :: Config
newtype RequestProcessingConfig
RequestProcessingConfig :: Second -> RequestProcessingConfig

-- | How many seconds to wait between calls to
--   <a>processAllContractOutboxes</a>
[requestProcessingInterval] :: RequestProcessingConfig -> Second
defaultRequestProcessingConfig :: RequestProcessingConfig
data WebserverConfig
WebserverConfig :: BaseUrl -> Maybe FilePath -> Bool -> Maybe Second -> Maybe Second -> Bool -> Maybe FilePath -> Maybe FilePath -> WebserverConfig
[baseUrl] :: WebserverConfig -> BaseUrl
[staticDir] :: WebserverConfig -> Maybe FilePath

-- | If true; use a very permissive CORS policy (any website can interact.)
[permissiveCorsPolicy] :: WebserverConfig -> Bool

-- | timeout to be used when endpoint is not available on invocation.
[endpointTimeout] :: WebserverConfig -> Maybe Second

-- | timeout to be used when querying endpoint result when expected
--   contract status must be set to Done.
[waitStatusTimeout] :: WebserverConfig -> Maybe Second
[enableMarconi] :: WebserverConfig -> Bool

-- | Certificate file for serving over HTTPS
[certificatePath] :: WebserverConfig -> Maybe FilePath

-- | Key file for serving over HTTPS
[keyPath] :: WebserverConfig -> Maybe FilePath

-- | Default config for debugging.
defaultWebServerConfig :: WebserverConfig
data DevelopmentOptions
DevelopmentOptions :: Maybe Int -> Point -> DevelopmentOptions
[pabRollbackHistory] :: DevelopmentOptions -> Maybe Int
[pabResumeFrom] :: DevelopmentOptions -> Point
defaultDevelopmentOptions :: DevelopmentOptions

-- | The source of a PAB event, used for sharding of the event stream
data Source
PABEventSource :: Source
InstanceEventSource :: ContractInstanceId -> Source
toUUID :: Source -> UUID
data ChainOverview
ChainOverview :: Blockchain -> Map TxId CardanoTx -> UtxoIndex -> ChainOverview
[chainOverviewBlockchain] :: ChainOverview -> Blockchain
[chainOverviewUnspentTxsById] :: ChainOverview -> Map TxId CardanoTx
[chainOverviewUtxoIndex] :: ChainOverview -> UtxoIndex
mkChainOverview :: Blockchain -> ChainOverview
_TxSenderNotAvailable :: Prism' PABError ()
_RemoteWalletWithMockNodeError :: Prism' PABError ()
_MigrationNotDoneError :: Prism' PABError Text
_AesonDecodingError :: Prism' PABError (Text, Text)
_ContractStateNotFound :: Prism' PABError ContractInstanceId
_MissingConfigFileOption :: Prism' PABError ()
_WalletNotFound :: Prism' PABError Wallet
_InstanceAlreadyStopped :: Prism' PABError ContractInstanceId
_EndpointCallError :: Prism' PABError NotificationError
_OtherError :: Prism' PABError Text
_InvalidUUIDError :: Prism' PABError Text
_ContractCommandError :: Prism' PABError (Int, Text)
_WalletError :: Prism' PABError WalletAPIError
_ChainIndexError :: Prism' PABError ClientError
_RandomTxClientError :: Prism' PABError ClientError
_BeamEffectError :: Prism' PABError BeamError
_NodeClientError :: Prism' PABError ClientError
_WalletClientError :: Prism' PABError ClientError
_PABContractError :: Prism' PABError ContractError
_ContractInstanceNotFound :: Prism' PABError ContractInstanceId
_ContractNotFound :: Prism' PABError FilePath
_FileNotFound :: Prism' PABError FilePath
_SqlitePool :: Prism' DBConnection (Pool Connection)
_PostgresPool :: Prism' DBConnection (Pool Connection)
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Types.PABError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Types.PABError
instance GHC.Generics.Generic Plutus.PAB.Types.PABError
instance GHC.Classes.Eq Plutus.PAB.Types.PABError
instance GHC.Show.Show Plutus.PAB.Types.PABError
instance GHC.Generics.Generic Plutus.PAB.Types.DbConfig
instance GHC.Classes.Eq Plutus.PAB.Types.DbConfig
instance GHC.Show.Show Plutus.PAB.Types.DbConfig
instance GHC.Generics.Generic Plutus.PAB.Types.ChainQueryConfig
instance GHC.Classes.Eq Plutus.PAB.Types.ChainQueryConfig
instance GHC.Show.Show Plutus.PAB.Types.ChainQueryConfig
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Types.RequestProcessingConfig
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Types.RequestProcessingConfig
instance GHC.Generics.Generic Plutus.PAB.Types.RequestProcessingConfig
instance GHC.Classes.Eq Plutus.PAB.Types.RequestProcessingConfig
instance GHC.Show.Show Plutus.PAB.Types.RequestProcessingConfig
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Types.WebserverConfig
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Types.WebserverConfig
instance GHC.Generics.Generic Plutus.PAB.Types.WebserverConfig
instance GHC.Classes.Eq Plutus.PAB.Types.WebserverConfig
instance GHC.Show.Show Plutus.PAB.Types.WebserverConfig
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Types.DevelopmentOptions
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Types.DevelopmentOptions
instance GHC.Generics.Generic Plutus.PAB.Types.DevelopmentOptions
instance GHC.Classes.Eq Plutus.PAB.Types.DevelopmentOptions
instance GHC.Show.Show Plutus.PAB.Types.DevelopmentOptions
instance GHC.Generics.Generic Plutus.PAB.Types.Config
instance GHC.Classes.Eq Plutus.PAB.Types.Config
instance GHC.Show.Show Plutus.PAB.Types.Config
instance GHC.Classes.Eq Plutus.PAB.Types.Source
instance GHC.Show.Show Plutus.PAB.Types.Source
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Types.ChainOverview
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Types.ChainOverview
instance GHC.Generics.Generic Plutus.PAB.Types.ChainOverview
instance GHC.Classes.Eq Plutus.PAB.Types.ChainOverview
instance GHC.Show.Show Plutus.PAB.Types.ChainOverview
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Types.Config
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Types.Config
instance Data.Default.Class.Default Plutus.PAB.Types.Config
instance Data.Default.Class.Default Plutus.PAB.Types.DevelopmentOptions
instance Data.Default.Class.Default Plutus.PAB.Types.WebserverConfig
instance Data.Default.Class.Default Plutus.PAB.Types.RequestProcessingConfig
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Types.ChainQueryConfig
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Types.ChainQueryConfig
instance Data.Default.Class.Default Plutus.PAB.Types.ChainQueryConfig
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Types.DbConfig
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Types.DbConfig
instance Data.Default.Class.Default Plutus.PAB.Types.DbConfig
instance Prettyprinter.Internal.Pretty Plutus.PAB.Types.PABError


module Plutus.PAB.Core.ContractInstance.BlockchainEnv

-- | Connect to the node and write node updates to the blockchain env.
startNodeClient :: Config -> InstancesState -> IO BlockchainEnv

-- | Go through the transactions in a block, updating the
--   <a>BlockchainEnv</a> when any interesting addresses or transactions
--   have changed.
processMockBlock :: InstancesState -> BlockchainEnv -> Block -> Slot -> IO (STM (Either SyncActionFailure (Slot, BlockNumber)))
instance GHC.Show.Show Plutus.PAB.Core.ContractInstance.BlockchainEnv.SyncActionFailure

module Cardano.Wallet.Mock.Types
type WalletEffects m = '[MultiWalletEffect, NodeClientEffect, ChainIndexQueryEffect, State Wallets, Error PABError, LogMsg Text, Error WalletAPIError, Error ClientError, Error ServerError, m]
type Wallets = Map WalletId WalletState
data MultiWalletEffect r
[CreateWallet] :: Maybe Ada -> MultiWalletEffect WalletInfo
[MultiWallet] :: Wallet -> Eff '[WalletEffect] a -> MultiWalletEffect a
[GetWalletInfo] :: WalletId -> MultiWalletEffect (Maybe WalletInfo)
createWallet :: forall effs_a3cgz. Member MultiWalletEffect effs_a3cgz => Maybe Ada -> Eff effs_a3cgz WalletInfo
multiWallet :: forall a_a3c86. forall effs_a3cgA. Member MultiWalletEffect effs_a3cgA => Wallet -> Eff ('(:) WalletEffect ('[] :: [Type -> Type])) a_a3c86 -> Eff effs_a3cgA a_a3c86
getWalletInfo :: forall effs_a3cgB. Member MultiWalletEffect effs_a3cgB => WalletId -> Eff effs_a3cgB (Maybe WalletInfo)
data WalletMsg
StartingWallet :: Port -> WalletMsg
ChainClientMsg :: Text -> WalletMsg
Balancing :: TxBalanceMsg -> WalletMsg
RequestHandling :: RequestHandlerLogMsg -> WalletMsg
newtype Port
Port :: Int -> Port
newtype NodeClient
NodeClient :: ClientEnv -> NodeClient
newtype ChainClient
ChainClient :: ClientEnv -> ChainClient
data ChainIndexUrl

-- | Information about an emulated wallet.
data WalletInfo
WalletInfo :: Wallet -> PaymentPubKeyHash -> NonEmpty CardanoAddress -> WalletInfo
[wiWallet] :: WalletInfo -> Wallet

-- | Hash of the wallet's public key, serving as wallet ID. TODO Remove
--   eventually as it is replaced by <a>wiAddresses</a>.
[wiPaymentPubKeyHash] :: WalletInfo -> PaymentPubKeyHash

-- | Wallet's addresses
[wiAddresses] :: WalletInfo -> NonEmpty CardanoAddress
fromWalletState :: WalletState -> WalletInfo
instance Prettyprinter.Internal.Pretty Cardano.Wallet.Mock.Types.Port
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Mock.Types.Port
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Mock.Types.Port
instance GHC.Num.Num Cardano.Wallet.Mock.Types.Port
instance GHC.Classes.Eq Cardano.Wallet.Mock.Types.Port
instance GHC.Show.Show Cardano.Wallet.Mock.Types.Port
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Mock.Types.WalletMsg
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Mock.Types.WalletMsg
instance GHC.Generics.Generic Cardano.Wallet.Mock.Types.WalletMsg
instance GHC.Show.Show Cardano.Wallet.Mock.Types.WalletMsg
instance Prettyprinter.Internal.Pretty Cardano.Wallet.Mock.Types.WalletMsg
instance Cardano.BM.Data.Tracer.ToObject Cardano.Wallet.Mock.Types.WalletMsg
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Mock.Types.WalletInfo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Mock.Types.WalletInfo
instance GHC.Generics.Generic Cardano.Wallet.Mock.Types.WalletInfo
instance GHC.Show.Show Cardano.Wallet.Mock.Types.WalletInfo

module Cardano.Wallet.Mock.API
type API walletId = "create" :> QueryParam "funds" Integer :> Post '[JSON] WalletInfo :<|> Capture "walletId" walletId :> "submit-txn" :> ReqBody '[JSON] CardanoTx :> Post '[JSON] NoContent :<|> Capture "walletId" walletId :> "own-payment-public-key-hash" :> Get '[JSON] PaymentPubKeyHash :<|> Capture "walletId" walletId :> "own-addresses" :> Get '[JSON] (NonEmpty CardanoAddress) :<|> Capture "walletId" walletId :> "balance-tx" :> ReqBody '[JSON] UnbalancedTx :> Post '[JSON] (Either WalletAPIError CardanoTx) :<|> Capture "walletId" walletId :> "total-funds" :> Get '[JSON] Value :<|> Capture "walletId" walletId :> "sign" :> ReqBody '[JSON] CardanoTx :> Post '[JSON] CardanoTx

module Cardano.Wallet.Mock.Client
createWallet :: Maybe Integer -> ClientM WalletInfo
submitTxn :: Wallet -> CardanoTx -> ClientM ()

-- | <i>Deprecated: Use ownAddresses instead</i>
ownPaymentPubKeyHash :: Wallet -> ClientM PaymentPubKeyHash
ownAddresses :: Wallet -> ClientM (NonEmpty CardanoAddress)
balanceTx :: Wallet -> UnbalancedTx -> ClientM (Either WalletAPIError CardanoTx)
totalFunds :: Wallet -> ClientM Value
sign :: Wallet -> CardanoTx -> ClientM CardanoTx
handleWalletClient :: forall m effs. (LastMember m effs, MonadIO m, Member (Error ClientError) effs, Member (Error WalletAPIError) effs, Member (Reader ClientEnv) effs) => Wallet -> WalletEffect ~> Eff effs

module Cardano.Node.Client
healthcheck :: ClientM NoContent
consumeEventHistory :: ClientM [LogMessage PABServerLogMsg]
handleNodeClientClient :: forall m effs. (LastMember m effs, MonadIO m, Member (Error PABError) effs, Member (Reader (Maybe TxSendHandle)) effs, Member (Reader ChainSyncHandle) effs) => Params -> NodeClientEffect ~> Eff effs

-- | This does not seem to support resuming so it means that the slot tick
--   will be behind everything else. This is due to having 2 connections to
--   the node one for chainSync<i>block transfer and one for
--   chainSync</i>currentSlot information. TODO: Think about merging the
--   two functionalities, or keep them in sync.
runChainSyncWithCfg :: PABServerConfig -> IO ChainSyncHandle

module Plutus.PAB.Webserver.Types
data ContractReport t
ContractReport :: [ContractSignatureResponse t] -> [(ContractInstanceId, PartiallyDecodedResponse PABReq)] -> ContractReport t
[crAvailableContracts] :: ContractReport t -> [ContractSignatureResponse t]
[crActiveContractStates] :: ContractReport t -> [(ContractInstanceId, PartiallyDecodedResponse PABReq)]
data ChainReport
ChainReport :: Map TxId Tx -> UtxoIndex -> [[AnnotatedTx]] -> ChainReport
[transactionMap] :: ChainReport -> Map TxId Tx
[utxoIndex] :: ChainReport -> UtxoIndex
[annotatedBlockchain] :: ChainReport -> [[AnnotatedTx]]
emptyChainReport :: ChainReport
data FullReport t
FullReport :: ContractReport t -> ChainReport -> FullReport t
[contractReport] :: FullReport t -> ContractReport t
[chainReport] :: FullReport t -> ChainReport
data ContractSignatureResponse t
ContractSignatureResponse :: t -> [FunctionSchema FormSchema] -> ContractSignatureResponse t
[csrDefinition] :: ContractSignatureResponse t -> t
[csrSchemas] :: ContractSignatureResponse t -> [FunctionSchema FormSchema]

-- | Data needed to start a new instance of a contract.
data ContractActivationArgs t
ContractActivationArgs :: t -> Maybe Wallet -> ContractActivationArgs t

-- | ID of the contract
[caID] :: ContractActivationArgs t -> t

-- | Wallet that should be used for this instance, `knownWallet 1` is used
--   in the Nothing case.
[caWallet] :: ContractActivationArgs t -> Maybe Wallet

-- | Current state of a contract instance (to be sent to external clients)
data ContractInstanceClientState t
ContractInstanceClientState :: ContractInstanceId -> PartiallyDecodedResponse ActiveEndpoint -> Wallet -> t -> ContractActivityStatus -> [ExportTx] -> ContractInstanceClientState t
[cicContract] :: ContractInstanceClientState t -> ContractInstanceId
[cicCurrentState] :: ContractInstanceClientState t -> PartiallyDecodedResponse ActiveEndpoint
[cicWallet] :: ContractInstanceClientState t -> Wallet
[cicDefinition] :: ContractInstanceClientState t -> t
[cicStatus] :: ContractInstanceClientState t -> ContractActivityStatus
[cicYieldedExportTxs] :: ContractInstanceClientState t -> [ExportTx]

-- | Status updates for contract instances streamed to client
data InstanceStatusToClient

-- | The observable state of the contract has changed.
NewObservableState :: Value -> InstanceStatusToClient

-- | The set of active endpoints has changed.
NewActiveEndpoints :: [ActiveEndpoint] -> InstanceStatusToClient

-- | Partial txs that need to be balanced, signed and submitted by an
--   external client.
NewYieldedExportTxs :: [ExportTx] -> InstanceStatusToClient

-- | Contract instance is done with an optional error message.
ContractFinished :: Maybe Value -> InstanceStatusToClient

-- | Data sent to the client through the combined websocket API
data CombinedWSStreamToClient
InstanceUpdate :: ContractInstanceId -> InstanceStatusToClient -> CombinedWSStreamToClient

-- | New slot number
SlotChange :: Slot -> CombinedWSStreamToClient

-- | Instructions sent to the server through the combined websocket API
data CombinedWSStreamToServer
Subscribe :: Either ContractInstanceId PubKeyHash -> CombinedWSStreamToServer
Unsubscribe :: Either ContractInstanceId PubKeyHash -> CombinedWSStreamToServer
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.PAB.Webserver.Types.ChainReport
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Webserver.Types.ChainReport
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Webserver.Types.ChainReport
instance GHC.Generics.Generic Plutus.PAB.Webserver.Types.ChainReport
instance GHC.Classes.Eq Plutus.PAB.Webserver.Types.ChainReport
instance GHC.Show.Show Plutus.PAB.Webserver.Types.ChainReport
instance Data.Aeson.Types.FromJSON.FromJSON t => Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Webserver.Types.ContractSignatureResponse t)
instance Data.Aeson.Types.ToJSON.ToJSON t => Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Webserver.Types.ContractSignatureResponse t)
instance GHC.Show.Show t => GHC.Show.Show (Plutus.PAB.Webserver.Types.ContractSignatureResponse t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Plutus.PAB.Webserver.Types.ContractSignatureResponse t)
instance GHC.Generics.Generic (Plutus.PAB.Webserver.Types.ContractSignatureResponse t)
instance Data.OpenApi.Internal.Schema.ToSchema t => Data.OpenApi.Internal.Schema.ToSchema (Plutus.PAB.Webserver.Types.ContractReport t)
instance Data.Aeson.Types.FromJSON.FromJSON t => Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Webserver.Types.ContractReport t)
instance Data.Aeson.Types.ToJSON.ToJSON t => Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Webserver.Types.ContractReport t)
instance GHC.Show.Show t => GHC.Show.Show (Plutus.PAB.Webserver.Types.ContractReport t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Plutus.PAB.Webserver.Types.ContractReport t)
instance GHC.Generics.Generic (Plutus.PAB.Webserver.Types.ContractReport t)
instance Data.OpenApi.Internal.Schema.ToSchema t => Data.OpenApi.Internal.Schema.ToSchema (Plutus.PAB.Webserver.Types.FullReport t)
instance Data.Aeson.Types.FromJSON.FromJSON t => Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Webserver.Types.FullReport t)
instance Data.Aeson.Types.ToJSON.ToJSON t => Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Webserver.Types.FullReport t)
instance GHC.Show.Show t => GHC.Show.Show (Plutus.PAB.Webserver.Types.FullReport t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Plutus.PAB.Webserver.Types.FullReport t)
instance GHC.Generics.Generic (Plutus.PAB.Webserver.Types.FullReport t)
instance Data.Aeson.Types.FromJSON.FromJSON t => Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Webserver.Types.ContractActivationArgs t)
instance Data.Aeson.Types.ToJSON.ToJSON t => Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Webserver.Types.ContractActivationArgs t)
instance GHC.Generics.Generic (Plutus.PAB.Webserver.Types.ContractActivationArgs t)
instance GHC.Show.Show t => GHC.Show.Show (Plutus.PAB.Webserver.Types.ContractActivationArgs t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Plutus.PAB.Webserver.Types.ContractActivationArgs t)
instance Data.Aeson.Types.FromJSON.FromJSON t => Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Webserver.Types.ContractInstanceClientState t)
instance Data.Aeson.Types.ToJSON.ToJSON t => Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Webserver.Types.ContractInstanceClientState t)
instance GHC.Generics.Generic (Plutus.PAB.Webserver.Types.ContractInstanceClientState t)
instance GHC.Show.Show t => GHC.Show.Show (Plutus.PAB.Webserver.Types.ContractInstanceClientState t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Plutus.PAB.Webserver.Types.ContractInstanceClientState t)
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Webserver.Types.InstanceStatusToClient
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Webserver.Types.InstanceStatusToClient
instance GHC.Show.Show Plutus.PAB.Webserver.Types.InstanceStatusToClient
instance GHC.Classes.Eq Plutus.PAB.Webserver.Types.InstanceStatusToClient
instance GHC.Generics.Generic Plutus.PAB.Webserver.Types.InstanceStatusToClient
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Webserver.Types.CombinedWSStreamToClient
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Webserver.Types.CombinedWSStreamToClient
instance GHC.Show.Show Plutus.PAB.Webserver.Types.CombinedWSStreamToClient
instance GHC.Classes.Eq Plutus.PAB.Webserver.Types.CombinedWSStreamToClient
instance GHC.Generics.Generic Plutus.PAB.Webserver.Types.CombinedWSStreamToClient
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Webserver.Types.CombinedWSStreamToServer
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Webserver.Types.CombinedWSStreamToServer
instance GHC.Show.Show Plutus.PAB.Webserver.Types.CombinedWSStreamToServer
instance GHC.Classes.Eq Plutus.PAB.Webserver.Types.CombinedWSStreamToServer
instance GHC.Generics.Generic Plutus.PAB.Webserver.Types.CombinedWSStreamToServer
instance Data.OpenApi.Internal.Schema.ToSchema t => Data.OpenApi.Internal.Schema.ToSchema (Plutus.PAB.Webserver.Types.ContractSignatureResponse t)
instance Data.OpenApi.Internal.Schema.ToSchema t => Data.OpenApi.Internal.Schema.ToSchema (Plutus.PAB.Webserver.Types.ContractActivationArgs t)
instance Data.OpenApi.Internal.Schema.ToSchema t => Data.OpenApi.Internal.Schema.ToSchema (Plutus.PAB.Webserver.Types.ContractInstanceClientState t)
instance Prettyprinter.Internal.Pretty t => Prettyprinter.Internal.Pretty (Plutus.PAB.Webserver.Types.ContractActivationArgs t)

module Plutus.PAB.Webserver.API

-- | PAB client API for contracts of type <tt>t</tt>. An example of
--   <tt>t</tt> are * <a>Builtin</a> contracts that run in the same process
--   as the PAB (ie. the PAB is compiled &amp; distributed with these
--   contracts)
type API t walletId = "api" :> ("healthcheck" :> Description "Is the server alive?" :> Get '[JSON] () :<|> ("fullreport" :> Description "Details of the contracts: the signatures and their states." :> Get '[JSON] (FullReport t)) :<|> "contract" :> ("activate" :> ReqBody '[JSON] (ContractActivationArgs t) :> Description "Start a new instance." :> Post '[JSON] ContractInstanceId :<|> "instance" :> (Capture "contract-instance-id" ContractInstanceId :> ("status" :> Description "Current status of contract instance." :> Get '[JSON] (ContractInstanceClientState t) :<|> "schema" :> Description "Endpoints' schema of contract instance." :> Get '[JSON] (ContractSignatureResponse t) :<|> "endpoint" :> Capture "endpoint-name" String :> ReqBody '[JSON] Value :> Description "Call an endpoint." :> Post '[JSON] () :<|> "stop" :> Description "Terminate the instance." :> Put '[JSON] ())) :<|> "instances" :> "wallet" :> Capture "wallet-id" walletId :> QueryParam "status" Text :> Description "List of contract instances for the wallet filtered by status (active, stopped, done). All by default." :> Get '[JSON] [ContractInstanceClientState t] :<|> "instances" :> QueryParam "status" Text :> Description "List of contract instances filtered by status (active, stopped, done). All by default." :> Get '[JSON] [ContractInstanceClientState t] :<|> "definitions" :> Description "list of available contracts." :> Get '[JSON] [ContractSignatureResponse t]))
type WSAPI = "ws" :> (Capture "contract-instance-id" ContractInstanceId :> WebSocketPending :<|> WebSocketPending)
type SwaggerAPI = "swagger" :> SwaggerSchemaUI "swagger-ui" "swagger.json"


-- | Servant client for PAB
module Plutus.PAB.Webserver.Client

-- | Client for PAB. The first type-argument is contract type that is used
--   for PAB-simulator.
data PabClient t walletId
PabClient :: ClientM () -> ClientM (FullReport t) -> (ContractActivationArgs t -> ClientM ContractInstanceId) -> (ContractInstanceId -> InstanceClient t) -> (walletId -> Maybe Text -> ClientM [ContractInstanceClientState t]) -> (Maybe Text -> ClientM [ContractInstanceClientState t]) -> ClientM [ContractSignatureResponse t] -> PabClient t walletId

-- | call healthcheck method
[healthcheck] :: PabClient t walletId -> ClientM ()

-- | call fullreport method
[fullreport] :: PabClient t walletId -> ClientM (FullReport t)

-- | call activate contract method
[activateContract] :: PabClient t walletId -> ContractActivationArgs t -> ClientM ContractInstanceId

-- | call methods for instance client. We should turn
--   <tt>ContractInstanceId</tt> to <tt>Text</tt> for the first argument.
[instanceClient] :: PabClient t walletId -> ContractInstanceId -> InstanceClient t

-- | get wallet instances
[getWallet] :: PabClient t walletId -> walletId -> Maybe Text -> ClientM [ContractInstanceClientState t]

-- | get instances
[getInstances] :: PabClient t walletId -> Maybe Text -> ClientM [ContractInstanceClientState t]

-- | get definitions
[getDefinitions] :: PabClient t walletId -> ClientM [ContractSignatureResponse t]

-- | Contract instance endpoints
data InstanceClient t
InstanceClient :: ClientM (ContractInstanceClientState t) -> ClientM (ContractSignatureResponse t) -> (String -> Value -> ClientM ()) -> ClientM () -> InstanceClient t

-- | get instance status
[getInstanceStatus] :: InstanceClient t -> ClientM (ContractInstanceClientState t)

-- | get instance schema
[getInstanceSchema] :: InstanceClient t -> ClientM (ContractSignatureResponse t)

-- | call instance endpoint
[callInstanceEndpoint] :: InstanceClient t -> String -> Value -> ClientM ()

-- | call stop instance method
[stopInstance] :: InstanceClient t -> ClientM ()

-- | Init generic pab client
pabClient :: forall t walletId. (ToJSON t, FromJSON t, ToHttpApiData walletId) => PabClient t walletId

module Plutus.PAB.Events

-- | A structure which ties together all possible event types into one
--   parent.
data PABEvent t

-- | Update the state of a contract instance
UpdateContractInstanceState :: !ContractActivationArgs t -> !ContractInstanceId -> !ContractResponse Value Value PABResp PABReq -> PABEvent t

-- | Send a transaction to the node
SubmitTx :: !Tx -> PABEvent t
ActivateContract :: !ContractActivationArgs t -> !ContractInstanceId -> PABEvent t
StopContract :: !ContractInstanceId -> PABEvent t
_UpdateContractInstanceState :: forall t_a3AP1. Prism' (PABEvent t_a3AP1) (ContractActivationArgs t_a3AP1, ContractInstanceId, ContractResponse Value Value PABResp PABReq)
_SubmitTx :: forall t_a3AP1. Prism' (PABEvent t_a3AP1) Tx
_ActivateContract :: forall t_a3AP1. Prism' (PABEvent t_a3AP1) (ContractActivationArgs t_a3AP1, ContractInstanceId)
_StopContract :: forall t_a3AP1. Prism' (PABEvent t_a3AP1) ContractInstanceId
instance Prettyprinter.Internal.Pretty t => Prettyprinter.Internal.Pretty (Plutus.PAB.Events.PABEvent t)
instance Data.Aeson.Types.FromJSON.FromJSON t => Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Events.PABEvent t)
instance Data.Aeson.Types.ToJSON.ToJSON t => Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Events.PABEvent t)
instance GHC.Generics.Generic (Plutus.PAB.Events.PABEvent t)
instance GHC.Show.Show t => GHC.Show.Show (Plutus.PAB.Events.PABEvent t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Plutus.PAB.Events.PABEvent t)

module Plutus.PAB.Effects.Contract

-- | A class of contracts running in the PAB. The purpose of the type
--   parameter <tt>contract</tt> is to allow for different ways of running
--   contracts, for example: A compiled executable running in a separate
--   process, or an "inline" contract that was compiled with the PAB and
--   runs in the same process.
--   
--   The associated type families correspond to the type arguments needed
--   for the <tt>ContractRequest</tt> and <a>ContractResponse</a> types
--   from <a>State</a>.
class PABContract contract where {
    
    -- | Any data needed to identify the contract. For example, the location of
    --   the executable.
    type family ContractDef contract;
    
    -- | Contract state type
    type family State contract;
}

-- | Extract the serialisable state from the contract instance state.
serialisableState :: PABContract contract => Proxy contract -> State contract -> ContractResponse Value Value PABResp PABReq

-- | The open requests of the contract instance.
requests :: forall contract. PABContract contract => State contract -> [Request PABReq]

-- | An effect for sending updates to contracts that implement
--   <tt>PABContract</tt>
data ContractEffect t r
[ExportSchema] :: PABContract t => ContractDef t -> ContractEffect t [FunctionSchema FormSchema]
[InitialState] :: PABContract t => ContractInstanceId -> ContractDef t -> ContractEffect t (State t)
[UpdateContract] :: PABContract t => ContractInstanceId -> ContractDef t -> State t -> Response PABResp -> ContractEffect t (State t)

-- | Get the schema of a contract given its definition.
exportSchema :: forall t effs. (Member (ContractEffect t) effs, PABContract t) => ContractDef t -> Eff effs [FunctionSchema FormSchema]

-- | Get the initial state of a contract
initialState :: forall t effs. (Member (ContractEffect t) effs, PABContract t) => ContractInstanceId -> ContractDef t -> Eff effs (State t)

-- | Send an update to the contract and return the new state.
updateContract :: forall t effs. (Member (ContractEffect t) effs, PABContract t) => ContractInstanceId -> ContractDef t -> State t -> Response PABResp -> Eff effs (State t)

-- | Storing and retrieving the state of a contract instance
data ContractStore t r
[PutStartInstance] :: ContractActivationArgs (ContractDef t) -> ContractInstanceId -> ContractStore t ()
[PutState] :: ContractActivationArgs (ContractDef t) -> ContractInstanceId -> State t -> ContractStore t ()
[GetState] :: ContractInstanceId -> ContractStore t (State t)
[PutStopInstance] :: ContractInstanceId -> ContractStore t ()
[GetContracts] :: Maybe ContractActivityStatus -> ContractStore t (Map ContractInstanceId (ContractActivationArgs (ContractDef t)))
[DeleteState] :: ContractInstanceId -> ContractStore t ()

-- | Store the state of the contract instance
putState :: forall t effs. Member (ContractStore t) effs => ContractActivationArgs (ContractDef t) -> ContractInstanceId -> State t -> Eff effs ()

-- | Load the state of the contract instance
getState :: forall t effs. Member (ContractStore t) effs => ContractInstanceId -> Eff effs (State t)

-- | Get the definition of a running contract
getDefinition :: forall t effs. Member (ContractStore t) effs => ContractInstanceId -> Eff effs (Maybe (ContractActivationArgs (ContractDef t)))

-- | All active contracts with their definitions WARNING : definition is
--   misleading as this function is retrieving all instances (i.e., not
--   only active ones), especially when the in memory database setting is
--   used Indeed, handler defined in ContractStore ignores the status
--   parameter given in GetContracts. Note also that a contract instance
--   added in the db has active status set to True. This status is set to
--   False only when the contract is explicitly stopped.
getActiveContracts :: forall t effs. Member (ContractStore t) effs => Eff effs (Map ContractInstanceId (ContractActivationArgs (ContractDef t)))

-- | All contracts with their definitions by given status (all by default)
getContracts :: forall t effs. Member (ContractStore t) effs => Maybe ContractActivityStatus -> Eff effs (Map ContractInstanceId (ContractActivationArgs (ContractDef t)))
putStartInstance :: forall t effs. Member (ContractStore t) effs => ContractActivationArgs (ContractDef t) -> ContractInstanceId -> Eff effs ()
putStopInstance :: forall t effs. Member (ContractStore t) effs => ContractInstanceId -> Eff effs ()
deleteState :: forall t effs. Member (ContractStore t) effs => ContractInstanceId -> Eff effs ()

-- | Storing and retrieving definitions of contracts. (Not all <tt>t</tt>s
--   support this)
data ContractDefinition t r
[AddDefinition] :: ContractDef t -> ContractDefinition t ()
[GetDefinitions] :: ContractDefinition t [ContractDef t]
addDefinition :: forall t effs. Member (ContractDefinition t) effs => ContractDef t -> Eff effs ()
getDefinitions :: forall t effs. Member (ContractDefinition t) effs => Eff effs [ContractDef t]


-- | Request handlers for contract instance runners.
module Plutus.PAB.Core.ContractInstance.RequestHandlers

-- | Log messages about the contract instance
data ContractInstanceMsg t
ProcessFirstInboxMessage :: ContractInstanceId -> Response PABResp -> ContractInstanceMsg t
SendingContractStateMessages :: ContractInstanceId -> IterationID -> [Request PABReq] -> ContractInstanceMsg t
LookingUpStateOfContractInstance :: ContractInstanceMsg t
CurrentIteration :: IterationID -> ContractInstanceMsg t
InboxMessageDoesntMatchIteration :: IterationID -> IterationID -> ContractInstanceMsg t
InboxMessageMatchesIteration :: ContractInstanceMsg t
InvokingContractUpdate :: ContractInstanceMsg t
ObtainedNewState :: ContractInstanceMsg t
ContractLog :: ContractInstanceId -> Value -> ContractInstanceMsg t
UpdatedContract :: ContractInstanceId -> IterationID -> ContractInstanceMsg t
LookingUpContract :: ContractDef t -> ContractInstanceMsg t
InitialisingContract :: ContractDef t -> ContractInstanceId -> ContractInstanceMsg t
InitialPABResp :: PartiallyDecodedResponse PABReq -> ContractInstanceMsg t
ActivatedContractInstance :: ContractDef t -> Wallet -> ContractInstanceId -> ContractInstanceMsg t
RunRequestHandler :: ContractInstanceId -> Int -> ContractInstanceMsg t
RunRequestHandlerDidNotHandleAnyEvents :: ContractInstanceMsg t
StoringSignedTx :: Tx -> ContractInstanceMsg t
CallingEndpoint :: String -> ContractInstanceId -> Value -> ContractInstanceMsg t
ProcessContractInbox :: ContractInstanceId -> ContractInstanceMsg t
HandlingRequest :: RequestHandlerLogMsg -> ContractInstanceMsg t
HandlingRequests :: ContractInstanceId -> [Request PABReq] -> ContractInstanceMsg t
BalancingTx :: TxBalanceMsg -> ContractInstanceMsg t
NotificationFailed :: NotificationError -> ContractInstanceMsg t
instance GHC.Generics.Generic (Plutus.PAB.Core.ContractInstance.RequestHandlers.ContractInstanceMsg t)
instance GHC.Classes.Eq (Plutus.PAB.Effects.Contract.ContractDef t) => GHC.Classes.Eq (Plutus.PAB.Core.ContractInstance.RequestHandlers.ContractInstanceMsg t)
instance GHC.Show.Show (Plutus.PAB.Effects.Contract.ContractDef t) => GHC.Show.Show (Plutus.PAB.Core.ContractInstance.RequestHandlers.ContractInstanceMsg t)
instance Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Effects.Contract.ContractDef t) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Core.ContractInstance.RequestHandlers.ContractInstanceMsg t)
instance Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Effects.Contract.ContractDef t) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Core.ContractInstance.RequestHandlers.ContractInstanceMsg t)
instance Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Effects.Contract.ContractDef t) => Cardano.BM.Data.Tracer.ToObject (Plutus.PAB.Core.ContractInstance.RequestHandlers.ContractInstanceMsg t)
instance Prettyprinter.Internal.Pretty (Plutus.PAB.Effects.Contract.ContractDef t) => Prettyprinter.Internal.Pretty (Plutus.PAB.Core.ContractInstance.RequestHandlers.ContractInstanceMsg t)

module Plutus.PAB.Db.Memory.ContractStore

-- | The current state of a contract instance Considering InstanceState
--   contractState as mutable to avoid bottleneck when updating
--   InMemInstances especially when an instance already exists. Note also
--   that PutState is adjusted so as to avoid full map update when instance
--   already exists.
data InMemContractInstanceState t
InMemContractInstanceState :: ContractActivationArgs (ContractDef t) -> TVar (State t) -> InMemContractInstanceState t
[_contractDef] :: InMemContractInstanceState t -> ContractActivationArgs (ContractDef t)
[_contractState] :: InMemContractInstanceState t -> TVar (State t)

-- | Handle the <a>ContractStore</a> effect by writing the state to the
--   TVar in <tt>SimulatorState</tt>
handleContractStore :: forall t effs. (LastMember IO effs, Member (Reader (InMemInstances t)) effs, Member (Error PABError) effs) => ContractStore t ~> Eff effs
data InMemInstances t
initialInMemInstances :: forall t. IO (InMemInstances t)

module Plutus.PAB.Core.ContractInstance

-- | Log messages about the contract instance
data ContractInstanceMsg t
ProcessFirstInboxMessage :: ContractInstanceId -> Response PABResp -> ContractInstanceMsg t
SendingContractStateMessages :: ContractInstanceId -> IterationID -> [Request PABReq] -> ContractInstanceMsg t
LookingUpStateOfContractInstance :: ContractInstanceMsg t
CurrentIteration :: IterationID -> ContractInstanceMsg t
InboxMessageDoesntMatchIteration :: IterationID -> IterationID -> ContractInstanceMsg t
InboxMessageMatchesIteration :: ContractInstanceMsg t
InvokingContractUpdate :: ContractInstanceMsg t
ObtainedNewState :: ContractInstanceMsg t
ContractLog :: ContractInstanceId -> Value -> ContractInstanceMsg t
UpdatedContract :: ContractInstanceId -> IterationID -> ContractInstanceMsg t
LookingUpContract :: ContractDef t -> ContractInstanceMsg t
InitialisingContract :: ContractDef t -> ContractInstanceId -> ContractInstanceMsg t
InitialPABResp :: PartiallyDecodedResponse PABReq -> ContractInstanceMsg t
ActivatedContractInstance :: ContractDef t -> Wallet -> ContractInstanceId -> ContractInstanceMsg t
RunRequestHandler :: ContractInstanceId -> Int -> ContractInstanceMsg t
RunRequestHandlerDidNotHandleAnyEvents :: ContractInstanceMsg t
StoringSignedTx :: Tx -> ContractInstanceMsg t
CallingEndpoint :: String -> ContractInstanceId -> Value -> ContractInstanceMsg t
ProcessContractInbox :: ContractInstanceId -> ContractInstanceMsg t
HandlingRequest :: RequestHandlerLogMsg -> ContractInstanceMsg t
HandlingRequests :: ContractInstanceId -> [Request PABReq] -> ContractInstanceMsg t
BalancingTx :: TxBalanceMsg -> ContractInstanceMsg t
NotificationFailed :: NotificationError -> ContractInstanceMsg t

-- | Create a new instance of the contract
activateContractSTM :: forall t m appBackend effs. (Member (LogMsg (ContractInstanceMsg t)) effs, Member UUIDEffect effs, Member (ContractEffect t) effs, Member (ContractStore t) effs, Member (Reader InstancesState) effs, PABContract t, AppBackendConstraints t m appBackend, LastMember m (Reader ContractInstanceId : appBackend), LastMember m effs) => (ContractInstanceId -> Eff appBackend ~> IO) -> ContractActivationArgs (ContractDef t) -> Eff effs ContractInstanceId

-- | Create a new instance of the contract, but where the
--   activeContractInstanceId and the initial state are provided.
activateContractSTM' :: forall t m appBackend effs. (Member (LogMsg (ContractInstanceMsg t)) effs, Member (ContractStore t) effs, Member (Reader InstancesState) effs, PABContract t, AppBackendConstraints t m appBackend, LastMember m (Reader ContractInstanceId : appBackend), LastMember m effs) => ContractInstanceState t -> ContractInstanceId -> (ContractInstanceId -> Eff appBackend ~> IO) -> ContractActivationArgs (ContractDef t) -> Eff effs ContractInstanceId

-- | Build a new ContractInstanceState and return it, along with the
--   corresponding new intsance id.
initContractInstanceState :: forall t effs. (Member UUIDEffect effs, Member (ContractEffect t) effs, PABContract t) => ContractActivationArgs (ContractDef t) -> Eff effs (ContractInstanceId, ContractInstanceState t)

-- | Container for holding a few bits of state related to the contract
--   instance that we may want to pass in.
data ContractInstanceState t
ContractInstanceState :: State t -> STM InstanceState -> ContractInstanceState t
[contractState] :: ContractInstanceState t -> State t
[stmState] :: ContractInstanceState t -> STM InstanceState

-- | Update the TVars in the <a>InstanceState</a> with data from the list
--   of requests.
updateState :: forall m effs. (LastMember m effs, MonadIO m, Member (Reader InstanceState) effs) => ContractResponse Value Value PABResp PABReq -> Eff effs ()

-- | Start the thread for the contract instance
startSTMInstanceThread :: forall t m appBackend effs. (LastMember m effs, PABContract t, AppBackendConstraints t m appBackend, LastMember m (Reader InstanceState : (Reader ContractInstanceId : appBackend))) => (ContractInstanceId -> Eff appBackend ~> IO) -> ContractActivationArgs (ContractDef t) -> ContractInstanceId -> Eff effs InstanceState

-- | Spin up the STM Instance thread for the provided contract and add it
--   to the STM instance state.
startContractInstanceThread' :: forall t m appBackend effs. (Member (Reader InstancesState) effs, PABContract t, AppBackendConstraints t m appBackend, LastMember m (Reader ContractInstanceId : appBackend), LastMember m effs) => ContractInstanceState t -> ContractInstanceId -> (ContractInstanceId -> Eff appBackend ~> IO) -> ContractActivationArgs (ContractDef t) -> Eff effs ContractInstanceId
type AppBackendConstraints t m effs = (LastMember m effs, MonadIO m, Member (Error PABError) effs, Member (LogMsg (ContractInstanceMsg t)) effs, Member ChainIndexQueryEffect effs, Member WalletEffect effs, Member NodeClientEffect effs, Member (LogMsg RequestHandlerLogMsg) effs, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg TxBalanceMsg) effs, Member (Reader BlockchainEnv) effs, Member (ContractEffect t) effs, Member (ContractStore t) effs)

-- | Call an endpoint on a contract instance. Fail immediately if the
--   endpoint is not active.
callEndpointOnInstance :: InstancesState -> EndpointDescription -> Value -> ContractInstanceId -> IO (STM (Maybe NotificationError))


-- | PAB Log messages and instances
module Plutus.PAB.Monitoring.PABLogMsg
data PABLogMsg t
SCoreMsg :: CoreMsg t -> PABLogMsg t
SChainIndexServerMsg :: ChainIndexServerMsg -> PABLogMsg t
SWalletMsg :: WalletMsg -> PABLogMsg t
SMockserverLogMsg :: PABServerLogMsg -> PABLogMsg t
SMultiAgent :: PABMultiAgentMsg t -> PABLogMsg t

-- | Messages from the ChainIndex Server
data ChainIndexServerMsg
data WalletMsg

-- | Top-level logging data type for structural logging inside the PAB
--   server.
data PABServerLogMsg
data AppMsg t
ActiveContractsMsg :: AppMsg t
ContractHistoryMsg :: AppMsg t
PABMsg :: PABLogMsg t -> AppMsg t
AvailableContract :: Text -> AppMsg t
ContractInstances :: ContractDef t -> [ContractInstanceId] -> AppMsg t
ContractHistoryItem :: ContractInstanceId -> Response PABResp -> AppMsg t
data CoreMsg t
FindingContract :: ContractInstanceId -> CoreMsg t
FoundContract :: Maybe (ContractResponse Value Value PABResp PABReq) -> CoreMsg t
ConnectingToAlonzoNode :: PABServerConfig -> SlotNo -> CoreMsg t

-- | FIXME: Redundant?
data PABMultiAgentMsg t
EmulatorMsg :: EmulatorEvent -> PABMultiAgentMsg t
ContractInstanceLog :: ContractInstanceMsg t -> PABMultiAgentMsg t
UserLog :: Text -> PABMultiAgentMsg t
BeamLogItem :: BeamLog -> PABMultiAgentMsg t
PABStateRestored :: Int -> PABMultiAgentMsg t
RestoringPABState :: PABMultiAgentMsg t
StartingPABBackendServer :: Int -> PABMultiAgentMsg t
WalletBalancingMsg :: Wallet -> TxBalanceMsg -> PABMultiAgentMsg t
WalletClient :: WalletClientMsg -> PABMultiAgentMsg t
newtype RequestSize
RequestSize :: Int -> RequestSize
data WalletClientMsg
WalletClientError :: String -> WalletClientMsg
BalanceTxError :: String -> WalletClientMsg
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Monitoring.PABLogMsg.WalletClientMsg
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Monitoring.PABLogMsg.WalletClientMsg
instance GHC.Generics.Generic Plutus.PAB.Monitoring.PABLogMsg.WalletClientMsg
instance GHC.Show.Show Plutus.PAB.Monitoring.PABLogMsg.WalletClientMsg
instance GHC.Classes.Eq Plutus.PAB.Monitoring.PABLogMsg.WalletClientMsg
instance GHC.Generics.Generic (Plutus.PAB.Monitoring.PABLogMsg.PABMultiAgentMsg t)
instance GHC.Generics.Generic (Plutus.PAB.Monitoring.PABLogMsg.CoreMsg t)
instance GHC.Generics.Generic (Plutus.PAB.Monitoring.PABLogMsg.PABLogMsg t)
instance GHC.Generics.Generic (Plutus.PAB.Monitoring.PABLogMsg.AppMsg t)
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.PAB.Monitoring.PABLogMsg.RequestSize
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.PAB.Monitoring.PABLogMsg.RequestSize
instance GHC.Show.Show Plutus.PAB.Monitoring.PABLogMsg.RequestSize
instance GHC.Show.Show (Plutus.PAB.Effects.Contract.ContractDef t) => GHC.Show.Show (Plutus.PAB.Monitoring.PABLogMsg.AppMsg t)
instance Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Effects.Contract.ContractDef t) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Monitoring.PABLogMsg.AppMsg t)
instance Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Effects.Contract.ContractDef t) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Monitoring.PABLogMsg.AppMsg t)
instance GHC.Show.Show (Plutus.PAB.Effects.Contract.ContractDef t) => GHC.Show.Show (Plutus.PAB.Monitoring.PABLogMsg.PABLogMsg t)
instance Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Effects.Contract.ContractDef t) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Monitoring.PABLogMsg.PABLogMsg t)
instance Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Effects.Contract.ContractDef t) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Monitoring.PABLogMsg.PABLogMsg t)
instance GHC.Show.Show (Plutus.PAB.Effects.Contract.ContractDef t) => GHC.Show.Show (Plutus.PAB.Monitoring.PABLogMsg.PABMultiAgentMsg t)
instance Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Effects.Contract.ContractDef t) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Monitoring.PABLogMsg.PABMultiAgentMsg t)
instance Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Effects.Contract.ContractDef t) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Monitoring.PABLogMsg.PABMultiAgentMsg t)
instance GHC.Show.Show (Plutus.PAB.Effects.Contract.ContractDef t) => GHC.Show.Show (Plutus.PAB.Monitoring.PABLogMsg.CoreMsg t)
instance Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Effects.Contract.ContractDef t) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Monitoring.PABLogMsg.CoreMsg t)
instance Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Effects.Contract.ContractDef t) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.PAB.Monitoring.PABLogMsg.CoreMsg t)
instance Prettyprinter.Internal.Pretty Plutus.PAB.Monitoring.PABLogMsg.RequestSize
instance Prettyprinter.Internal.Pretty (Plutus.PAB.Effects.Contract.ContractDef t) => Prettyprinter.Internal.Pretty (Plutus.PAB.Monitoring.PABLogMsg.AppMsg t)
instance (Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Effects.Contract.ContractDef t), Cardano.BM.Data.Tracer.Extras.StructuredLog (Plutus.PAB.Effects.Contract.ContractDef t)) => Cardano.BM.Data.Tracer.ToObject (Plutus.PAB.Monitoring.PABLogMsg.AppMsg t)
instance Prettyprinter.Internal.Pretty (Plutus.PAB.Effects.Contract.ContractDef t) => Prettyprinter.Internal.Pretty (Plutus.PAB.Monitoring.PABLogMsg.PABLogMsg t)
instance (Cardano.BM.Data.Tracer.Extras.StructuredLog (Plutus.PAB.Effects.Contract.ContractDef t), Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Effects.Contract.ContractDef t)) => Cardano.BM.Data.Tracer.ToObject (Plutus.PAB.Monitoring.PABLogMsg.PABLogMsg t)
instance Prettyprinter.Internal.Pretty (Plutus.PAB.Effects.Contract.ContractDef t) => Prettyprinter.Internal.Pretty (Plutus.PAB.Monitoring.PABLogMsg.CoreMsg t)
instance (Cardano.BM.Data.Tracer.Extras.StructuredLog (Plutus.PAB.Effects.Contract.ContractDef t), Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Effects.Contract.ContractDef t)) => Cardano.BM.Data.Tracer.ToObject (Plutus.PAB.Monitoring.PABLogMsg.CoreMsg t)
instance (Cardano.BM.Data.Tracer.Extras.StructuredLog (Plutus.PAB.Effects.Contract.ContractDef t), Data.Aeson.Types.ToJSON.ToJSON (Plutus.PAB.Effects.Contract.ContractDef t)) => Cardano.BM.Data.Tracer.ToObject (Plutus.PAB.Monitoring.PABLogMsg.PABMultiAgentMsg t)
instance Prettyprinter.Internal.Pretty (Plutus.PAB.Effects.Contract.ContractDef t) => Prettyprinter.Internal.Pretty (Plutus.PAB.Monitoring.PABLogMsg.PABMultiAgentMsg t)
instance Prettyprinter.Internal.Pretty Plutus.PAB.Monitoring.PABLogMsg.WalletClientMsg
instance Cardano.BM.Data.Tracer.ToObject Plutus.PAB.Monitoring.PABLogMsg.WalletClientMsg

module Plutus.PAB.Monitoring.Monitoring

module Cardano.Wallet.Mock.Handlers

-- | Process wallet effects. Retain state and yield HTTP400 on error or set
--   new state on success.
processWalletEffects :: (MonadIO m, MonadError ServerError m) => Trace IO WalletMsg -> TxSendHandle -> ChainSyncHandle -> ClientEnv -> MVar Wallets -> Params -> Eff (WalletEffects IO) a -> m a

-- | <tt>i2bs bitLen i</tt> converts <tt>i</tt> to a <tt>ByteString</tt> of
--   <tt>bitLen</tt> bits (must be a multiple of 8).
integer2ByteString32 :: Integer -> ByteString

-- | Helper function to convert bytestrings to integers
byteString2Integer :: ByteString -> Integer
newWallet :: forall m effs. (LastMember m effs, MonadIO m) => Eff effs MockWallet
distributeNewWalletFunds :: forall effs. (Member WalletEffect effs, Member (Error WalletAPIError) effs, Member (LogMsg Text) effs, Member (LogMsg RequestHandlerLogMsg) effs) => Params -> Maybe Ada -> PaymentPubKeyHash -> Eff effs CardanoTx

module Cardano.Wallet.Mock.Server
main :: Trace IO WalletMsg -> LocalWalletSettings -> FilePath -> Params -> ChainIndexUrl -> Availability -> IO ()

module Cardano.Node.Mock
healthcheck :: Monad m => m NoContent
consumeEventHistory :: MonadIO m => MVar AppState -> m [LogMessage PABServerLogMsg]
addTx :: (Member (LogMsg PABServerLogMsg) effs, Member (Reader (Maybe TxSendHandle)) effs, MonadIO m, LastMember m effs) => Tx BabbageEra -> Eff effs NoContent

-- | Run all chain effects in the IO Monad
runChainEffects :: Trace IO PABServerLogMsg -> Params -> Maybe TxSendHandle -> MVar AppState -> Eff (NodeServerEffects IO) a -> IO ([LogMessage PABServerLogMsg], a)
processChainEffects :: Trace IO PABServerLogMsg -> Params -> Maybe TxSendHandle -> MVar AppState -> Eff (NodeServerEffects IO) a -> IO a

-- | Calls <tt>addBlock</tt> at the start of every slot, causing pending
--   transactions to be validated and added to the chain.
slotCoordinator :: SlotConfig -> ServerHandler -> IO a

module Cardano.Node.Server
main :: Trace IO PABServerLogMsg -> PABServerConfig -> Availability -> IO ()

module Cardano.ChainIndex.ChainIndex

-- | Process the chain index effects for the emulator.
processChainIndexEffects :: MonadIO m => ChainIndexTrace -> TVar ChainIndexEmulatorState -> Eff (ChainIndexEffects IO) a -> m a

-- | Update the chain index by asking the node for new blocks since the
--   last time.
syncState :: (Member ChainIndexControlEffect effs, Member ChainIndexQueryEffect effs) => Block -> Slot -> Eff effs ()

module Cardano.ChainIndex.Server
main :: ChainIndexTrace -> ChainIndexConfig -> FilePath -> Params -> Availability -> IO ()
newtype ChainIndexConfig
ChainIndexConfig :: ChainIndexUrl -> ChainIndexConfig
[ciBaseUrl] :: ChainIndexConfig -> ChainIndexUrl

-- | Messages from the ChainIndex Server
data ChainIndexServerMsg

module Plutus.PAB.Effects.Contract.Builtin

-- | Contracts that are built into the PAB (ie. compiled with it) and
--   receive an initial value of type <tt>a</tt>.
--   
--   We have a dummy constructor so that we can convert this datatype in
--   Purescript with '(equal <a>*</a> (genericShow <a>*</a> mkSumType))
--   (Proxy @(Builtin A))'.
data Builtin a
type ContractConstraints w schema error = (Monoid w, Forall (Output schema) ToJSON, Forall (Input schema) ToJSON, Forall (Input schema) FromJSON, ToJSON error, ToJSON w, FromJSON w, AllUniqueLabels (Input schema))

-- | Plutus contract with all parameters existentially quantified. Can be
--   any contract that satisfies the <a>ContractConstraints</a>.
data SomeBuiltin
[SomeBuiltin] :: forall contract w schema error a. (ContractConstraints w schema error, IsContract contract) => contract w schema error a -> SomeBuiltin
data SomeBuiltinState a
[SomeBuiltinState] :: forall a w schema error b. ContractConstraints w schema error => ContractInstanceStateInternal w schema error b -> w -> SomeBuiltinState a

-- | Defined in order to prevent type errors like: "Couldn't match type
--   <tt>effs</tt> with <tt>effs1</tt>".
newtype BuiltinHandler a
BuiltinHandler :: (forall effs. (Member (Error PABError) effs, Member (LogMsg (PABMultiAgentMsg (Builtin a))) effs) => ContractEffect (Builtin a) ~> Eff effs) -> BuiltinHandler a
[contractHandler] :: BuiltinHandler a -> forall effs. (Member (Error PABError) effs, Member (LogMsg (PABMultiAgentMsg (Builtin a))) effs) => ContractEffect (Builtin a) ~> Eff effs

-- | Handle the <a>ContractEffect</a> for a builtin contract type with
--   parameter <tt>a</tt>.
handleBuiltin :: HasDefinitions a => BuiltinHandler a

-- | Type level Row difference. That is, <tt>l <a>.\\</a> r</tt> is the row
--   remaining after removing any matching elements of <tt>r</tt> from
--   <tt>l</tt>.
type family (l :: Row k) .\\ (r :: Row k) :: Row k
infixl 6 .\\

-- | The minimum join of the two rows.
type family (l :: Row k) .\/ (r :: Row k) :: Row k
infixl 6 .\/
type EmptySchema = Empty :: Row a

-- | Type level version of <tt>empty</tt>
type Empty = 'R '[] :: [LT a]
endpointsToSchemas :: EndpointToSchema s => [FunctionSchema FormSchema]
getResponse :: forall a. SomeBuiltinState a -> ContractResponse Value Value PABResp PABReq

-- | Reconstruct a state from a serialised response by replaying back the
--   actions.
fromResponse :: forall a effs. (Member (LogMsg (PABMultiAgentMsg (Builtin a))) effs, Member (Error PABError) effs) => ContractInstanceId -> SomeBuiltin -> ContractResponse Value Value PABResp PABReq -> Eff effs (SomeBuiltinState a)

-- | Allows contract type <tt>a</tt> to specify its available contract
--   definitions. Also, for each contract type, we specify its contract
--   function and its schemas.
class HasDefinitions a
getDefinitions :: HasDefinitions a => [a]
getContract :: HasDefinitions a => a -> SomeBuiltin
getSchema :: HasDefinitions a => a -> [FunctionSchema FormSchema]
instance GHC.Generics.Generic (Plutus.PAB.Effects.Contract.Builtin.Builtin a)
instance GHC.Classes.Eq (Plutus.PAB.Effects.Contract.Builtin.Builtin a)
instance Plutus.PAB.Effects.Contract.PABContract (Plutus.PAB.Effects.Contract.Builtin.Builtin a)
instance Data.OpenApi.Internal.Schema.ToSchema t => Data.OpenApi.Internal.Schema.ToSchema (Plutus.PAB.Effects.Contract.Builtin.Builtin t)

module Plutus.PAB.Db.Beam.ContractStore

-- | Run the <a>ContractStore</a> actions against the database.
handleContractStore :: forall dbt a effs. (FromBackendRow dbt Text, FromBackendRow dbt Bool, FromBackendRow dbt SqlNull, HasSqlValueSyntax (Synt dbt) (Maybe Text), HasSqlValueSyntax (Synt dbt) Text, HasSqlValueSyntax (Synt dbt) Bool, HasSqlEqualityCheck dbt Text, HasSqlEqualityCheck dbt Bool, HasQBuilder dbt, Member (BeamEffect dbt) effs, Member (Error PABError) effs, Member (LogMsg (PABMultiAgentMsg (Builtin a))) effs, ToJSON a, FromJSON a, HasDefinitions a, Typeable a) => ContractStore (Builtin a) ~> Eff effs

module Plutus.PAB.Db.Beam

-- | Run the ContractStore and ContractDefinitionStore effects on the
--   configured database.
runBeamStoreAction :: forall a b. (ToJSON a, FromJSON a, HasDefinitions a, Typeable a) => DBConnection -> Trace IO (PABLogMsg (Builtin a)) -> Eff '[ContractStore (Builtin a), LogMsg (PABMultiAgentMsg (Builtin a)), DelayEffect, IO] b -> IO (Either PABError b)

module Cardano.Wallet.LocalClient
getWalletKey :: ApiT WalletId -> ApiT Role -> ApiT DerivationIndex -> Maybe Bool -> ClientM ApiVerificationKeyShelley
handleWalletClient :: forall m effs. (LastMember m effs, MonadIO m, Member NodeClientEffect effs, Member (Error ClientError) effs, Member (Error WalletAPIError) effs, Member (Reader ClientEnv) effs, Member (LogMsg WalletClientMsg) effs) => PABServerConfig -> Wallet -> WalletEffect ~> Eff effs
tokenMapToValue :: TokenMap -> Value
fromApiSerialisedTransaction :: ApiSerialisedTransaction -> CardanoTx
toSealedTx :: Params -> CardanoTx -> Either ToCardanoError SealedTx
throwOtherError :: (Member (Error WalletAPIError) effs, Show err) => err -> Eff effs a

module Plutus.PAB.Core

-- | Effects that are available in <a>PABAction</a>s.
type PABEffects t env = '[ContractStore t, ContractEffect t, ContractDefinition t, LogMsg (PABMultiAgentMsg t), TimeEffect, Reader (PABEnvironment t env), Error PABError, IO]

-- | Actions that are run by the PAB.
type PABAction t env a = Eff (PABEffects t env) a

-- | Effect handlers for running the PAB.
data EffectHandlers t env
EffectHandlers :: (forall effs. (Member (Error PABError) effs, LastMember IO effs) => Eff effs (InstancesState, BlockchainEnv, env)) -> (forall effs. (Member (Reader (PABEnvironment t env)) effs, Member TimeEffect effs, Member (Error PABError) effs, LastMember IO effs) => Eff (LogMsg (PABMultiAgentMsg t) : effs) ~> Eff effs) -> (forall effs. (Member (Reader (PABEnvironment t env)) effs, Member (Error PABError) effs, Member TimeEffect effs, Member (LogMsg (PABMultiAgentMsg t)) effs, LastMember IO effs) => Eff (ContractStore t : effs) ~> Eff effs) -> (forall effs. (Member (Reader (PABEnvironment t env)) effs, Member (Error PABError) effs, Member TimeEffect effs, Member (LogMsg (PABMultiAgentMsg t)) effs, LastMember IO effs) => Eff (ContractEffect t : effs) ~> Eff effs) -> (forall effs. (Member (Reader (PABEnvironment t env)) effs, Member (Error PABError) effs, Member TimeEffect effs, Member (LogMsg (PABMultiAgentMsg t)) effs, LastMember IO effs) => Eff (ContractDefinition t : effs) ~> Eff effs) -> (forall effs. (Member (Reader (PABEnvironment t env)) effs, Member (Error PABError) effs, Member TimeEffect effs, Member (LogMsg (PABMultiAgentMsg t)) effs, LastMember IO effs) => Wallet -> Maybe ContractInstanceId -> Eff (WalletEffect : (ChainIndexQueryEffect : (NodeClientEffect : effs))) ~> Eff effs) -> PABAction t env () -> PABAction t env () -> EffectHandlers t env

-- | Create the initial environment. This value is shared between all
--   threads started by the PAB.
[initialiseEnvironment] :: EffectHandlers t env -> forall effs. (Member (Error PABError) effs, LastMember IO effs) => Eff effs (InstancesState, BlockchainEnv, env)

-- | Handle log messages
[handleLogMessages] :: EffectHandlers t env -> forall effs. (Member (Reader (PABEnvironment t env)) effs, Member TimeEffect effs, Member (Error PABError) effs, LastMember IO effs) => Eff (LogMsg (PABMultiAgentMsg t) : effs) ~> Eff effs

-- | Handle the <a>ContractStore</a> effect
[handleContractStoreEffect] :: EffectHandlers t env -> forall effs. (Member (Reader (PABEnvironment t env)) effs, Member (Error PABError) effs, Member TimeEffect effs, Member (LogMsg (PABMultiAgentMsg t)) effs, LastMember IO effs) => Eff (ContractStore t : effs) ~> Eff effs

-- | Handle the <a>ContractEffect</a>
[handleContractEffect] :: EffectHandlers t env -> forall effs. (Member (Reader (PABEnvironment t env)) effs, Member (Error PABError) effs, Member TimeEffect effs, Member (LogMsg (PABMultiAgentMsg t)) effs, LastMember IO effs) => Eff (ContractEffect t : effs) ~> Eff effs

-- | Handle the <a>ContractDefinition</a> effect
[handleContractDefinitionEffect] :: EffectHandlers t env -> forall effs. (Member (Reader (PABEnvironment t env)) effs, Member (Error PABError) effs, Member TimeEffect effs, Member (LogMsg (PABMultiAgentMsg t)) effs, LastMember IO effs) => Eff (ContractDefinition t : effs) ~> Eff effs

-- | Handle effects that serve requests to external services managed by the
--   PAB Runs in the context of a particular wallet.
[handleServicesEffects] :: EffectHandlers t env -> forall effs. (Member (Reader (PABEnvironment t env)) effs, Member (Error PABError) effs, Member TimeEffect effs, Member (LogMsg (PABMultiAgentMsg t)) effs, LastMember IO effs) => Wallet -> Maybe ContractInstanceId -> Eff (WalletEffect : (ChainIndexQueryEffect : (NodeClientEffect : effs))) ~> Eff effs

-- | Action to run on startup.
[onStartup] :: EffectHandlers t env -> PABAction t env ()

-- | Action to run on shutdown
[onShutdown] :: EffectHandlers t env -> PABAction t env ()

-- | Top-level entry point. Run a <a>PABAction</a>, using the
--   <a>EffectHandlers</a> to deal with logs, startup and shutdown,
--   contract requests and communication with external services.
runPAB :: forall t env a. Timeout -> Timeout -> EffectHandlers t env -> PABAction t env a -> IO (Either PABError a)

-- | Run a PABAction in the context of the given environment. TODO: Clean
--   it up so there is less duplication of the above.
runPAB' :: forall t env a. PABEnvironment t env -> PABAction t env a -> IO (Either PABError a)

-- | Shared data that is needed by all PAB threads.
data PABEnvironment t env
PABEnvironment :: InstancesState -> Timeout -> Timeout -> BlockchainEnv -> env -> EffectHandlers t env -> PABEnvironment t env
[instancesState] :: PABEnvironment t env -> InstancesState

-- | How long to wait for an endpoint to become active before throwing the
--   <tt>EndpointNotAvailable</tt> error.
[endpointTimeout] :: PABEnvironment t env -> Timeout

-- | How long to wait when querying the status for an invoked endpoint
--   before throwing the a timeout error.
[waitStatusTimeout] :: PABEnvironment t env -> Timeout
[blockchainEnv] :: PABEnvironment t env -> BlockchainEnv
[appEnv] :: PABEnvironment t env -> env
[effectHandlers] :: PABEnvironment t env -> EffectHandlers t env

-- | Report the state of a running contract.
reportContractState :: forall t effs. (Member (ContractStore t) effs, PABContract t) => ContractInstanceId -> Eff effs (PartiallyDecodedResponse PABReq)

-- | Start a new instance of a contract
activateContract :: forall t env. PABContract t => Wallet -> ContractDef t -> PABAction t env ContractInstanceId

-- | Start a new instance of a contract, with a given state. Note that we
--   skip running the effects that push the state into the contract store,
--   because we assume that if you're providing the state, it's already
--   present in the store.
activateContract' :: forall t env. PABContract t => ContractInstanceState t -> ContractInstanceId -> Wallet -> ContractDef t -> PABAction t env ContractInstanceId

-- | Call a named endpoint on a contract instance. Waits if the endpoint is
--   not available.
callEndpointOnInstance :: forall t env a. ToJSON a => ContractInstanceId -> String -> a -> PABAction t env (Maybe NotificationError)

-- | Call a named endpoint on a contract instance. Fails immediately if the
--   endpoint is not available.
callEndpointOnInstance' :: forall t env a. ToJSON a => ContractInstanceId -> String -> a -> PABAction t env (Maybe NotificationError)

-- | Make a payment.
payToAddress :: Params -> ContractInstanceId -> Wallet -> Address -> Value -> PABAction t env CardanoTx

-- | Make a payment to a payment public key.
payToPaymentPublicKey :: Params -> ContractInstanceId -> Wallet -> PaymentPubKeyHash -> Value -> PABAction t env CardanoTx

-- | Effects available to contract instances with access to external
--   services.
type ContractInstanceEffects t env effs = ContractEffect t : ContractStore t : WalletEffect : ChainIndexQueryEffect : NodeClientEffect : UUIDEffect : LogMsg TxBalanceMsg : LogMsg RequestHandlerLogMsg : LogMsg (ContractInstanceMsg t) : LogObserve (LogMessage Text) : LogMsg Text : Error PABError : TimeEffect : Reader BlockchainEnv : Reader InstancesState : Reader (PABEnvironment t env) : Reader Wallet : effs

-- | Handle an action with <a>ContractInstanceEffects</a> in the context of
--   a wallet.
handleAgentThread :: forall t env a. Wallet -> Maybe ContractInstanceId -> Eff (ContractInstanceEffects t env '[IO]) a -> PABAction t env a

-- | Stop the instance.
stopInstance :: forall t env. ContractInstanceId -> PABAction t env ()

-- | Delete the instance from the <a>InstancesState</a> of the
--   <tt>PABEnvironment</tt> and from <tt>InMemInstances</tt> / Beam db.
removeInstance :: forall t env. ContractInstanceId -> PABAction t env ()

-- | The <a>Activity</a> of the instance.
instanceActivity :: forall t env. ContractInstanceId -> PABAction t env Activity

-- | Get the current state of the contract instance.
instanceState :: forall t env. Wallet -> ContractInstanceId -> PABAction t env (State t)

-- | The <tt>InstanceState</tt> for the instance. Throws a
--   <a>ContractInstanceNotFound</a> error if the instance does not exist.
instanceStateInternal :: forall t env. ContractInstanceId -> PABAction t env InstanceState

-- | An STM transaction that returns the observable state of the contract
--   instance.
observableState :: forall t env. ContractInstanceId -> PABAction t env (STM Value)

-- | Wait until the observable state of the instance matches a predicate.
waitForState :: forall t env a. (Value -> Maybe a) -> ContractInstanceId -> PABAction t env a

-- | Wait until the instance state of the instance satisfies a predicate
--   and returns the activity status
waitForInstanceState :: forall t env. (InstanceState -> STM (Maybe ContractActivityStatus)) -> ContractInstanceId -> PABAction t env ContractActivityStatus

-- | Wait until the instance state is updated with a response form an
--   invoked endpoint. Note that the waiting is performed only when a
--   contract is expected to end with a Done status, i.e., no open
--   endpoints available after invocation.
waitForInstanceStateWithResult :: forall t env. ContractInstanceId -> PABAction t env ContractActivityStatus

-- | Wait for the transaction to be confirmed on the blockchain.
waitForTxStatusChange :: forall t env. TxId -> PABAction t env TxStatus

-- | Wait for the transaction output to be confirmed on the blockchain.
waitForTxOutStatusChange :: forall t env. TxOutRef -> PABAction t env TxOutStatus

-- | The list of endpoints that are currently open
activeEndpoints :: forall t env. ContractInstanceId -> PABAction t env (STM [OpenEndpoint])

-- | Wait until the endpoint becomes active.
waitForEndpoint :: forall t env. ContractInstanceId -> String -> PABAction t env ()

-- | Get exported transactions waiting to be balanced, signed and submitted
--   by an external client.
yieldedExportTxs :: forall t env. ContractInstanceId -> PABAction t env [ExportTx]
currentSlot :: forall t env. PABAction t env (STM Slot)

-- | Wait until the target slot number has been reached relative to the
--   current slot.
waitUntilSlot :: forall t env. Slot -> PABAction t env ()

-- | Wait for a certain number of slots relative to the current slot.
waitNSlots :: forall t env. Int -> PABAction t env ()

-- | The set of all active contracts.
activeContracts :: forall t env. PABAction t env (Set ContractInstanceId)

-- | The final result of the instance (waits until it is available)
finalResult :: forall t env. ContractInstanceId -> PABAction t env (STM (Maybe Value))

-- | Wait until the contract is done, then return the error (if any)
waitUntilFinished :: forall t env. ContractInstanceId -> PABAction t env (Maybe Value)

-- | The value in a wallet.
--   
--   TODO: Change from <a>Wallet</a> to <a>Address</a> (see SCP-2208).
valueAt :: Wallet -> PABAction t env Value

-- | Read the <tt>env</tt> from the environment
askUserEnv :: forall t env effs. Member (Reader (PABEnvironment t env)) effs => Eff effs env

-- | Read the <a>BlockchainEnv</a> from the environment
askBlockchainEnv :: forall t env effs. Member (Reader (PABEnvironment t env)) effs => Eff effs BlockchainEnv

-- | Read the <a>InstancesState</a> from the environment
askInstancesState :: forall t env effs. Member (Reader (PABEnvironment t env)) effs => Eff effs InstancesState
instancesWithStatuses :: forall t env. PABAction t env (Map ContractInstanceId ContractActivityStatus)

-- | A handler for <a>PABAction</a> types.
newtype PABRunner t env
PABRunner :: (forall a. PABAction t env a -> IO (Either PABError a)) -> PABRunner t env
[runPABAction] :: PABRunner t env -> forall a. PABAction t env a -> IO (Either PABError a)

-- | Get a <a>PABRunner</a> that uses the current environment.
pabRunner :: forall t env. PABAction t env (PABRunner t env)
handleMappedReader :: forall f g effs. Member (Reader f) effs => (f -> g) -> Reader g ~> Eff effs
handleUserEnvReader :: forall t env effs. Member (Reader (PABEnvironment t env)) effs => Reader env ~> Eff effs
handleBlockchainEnvReader :: forall t env effs. Member (Reader (PABEnvironment t env)) effs => Reader BlockchainEnv ~> Eff effs
handleInstancesStateReader :: forall t env effs. Member (Reader (PABEnvironment t env)) effs => Reader InstancesState ~> Eff effs

-- | Annotate log messages with the current slot number.
timed :: forall e effs. (Member (LogMsg (EmulatorTimeEvent e)) effs, Member TimeEffect effs) => LogMsg e ~> Eff effs

module Plutus.PAB.Webserver.Handler

-- | Handler for the API
apiHandler :: forall t env. PABContract t => PABAction t env () :<|> (PABAction t env (FullReport (ContractDef t)) :<|> ((ContractActivationArgs (ContractDef t) -> PABAction t env ContractInstanceId) :<|> ((ContractInstanceId -> PABAction t env (ContractInstanceClientState (ContractDef t)) :<|> (PABAction t env (ContractSignatureResponse (ContractDef t)) :<|> ((String -> Value -> PABAction t env ()) :<|> PABAction t env ()))) :<|> ((WalletId -> Maybe Text -> PABAction t env [ContractInstanceClientState (ContractDef t)]) :<|> ((Maybe Text -> PABAction t env [ContractInstanceClientState (ContractDef t)]) :<|> PABAction t env [ContractSignatureResponse (ContractDef t)])))))
swagger :: forall t api dir. (Server api ~ Handler Value, ToSchema (ContractDef t)) => Server (SwaggerSchemaUI' dir api)
getFullReport :: forall t env. PABContract t => PABAction t env (FullReport (ContractDef t))
contractSchema :: forall t env. PABContract t => ContractInstanceId -> PABAction t env (ContractSignatureResponse (ContractDef t))

module Plutus.PAB.Simulator
type Simulation t a = PABAction t (SimulatorState t) a
data SimulatorState t

-- | A handler for the <tt>ContractEffect</tt> of <tt>t</tt> that can run
--   contracts in a simulated environment.
type SimulatorContractHandler t = forall effs. (Member (Error PABError) effs, Member (LogMsg (PABMultiAgentMsg t)) effs) => Eff (ContractEffect t : effs) ~> Eff effs
runSimulationWith :: SimulatorEffectHandlers t -> Simulation t a -> IO (Either PABError a)
type SimulatorEffectHandlers t = EffectHandlers t (SimulatorState t)

-- | Build <a>EffectHandlers</a> for running a contract in the simulator.
mkSimulatorHandlers :: forall t. (Pretty (ContractDef t), HasDefinitions (ContractDef t)) => Params -> SimulatorContractHandler t -> SimulatorEffectHandlers t

-- | Create a new wallet with a random key, give it some funds and add it
--   to the list of simulated wallets.
addWallet :: forall t. Simulation t (Wallet, PaymentPubKeyHash)

-- | Create a new wallet with a random key, give it provided funds and add
--   it to the list of simulated wallets.
addWalletWith :: forall t. Maybe Ada -> Simulation t (Wallet, PaymentPubKeyHash)

-- | Log some output to the console
logString :: forall t effs. Member (LogMsg (PABMultiAgentMsg t)) effs => String -> Eff effs ()

-- | Make a payment from one wallet to another
payToWallet :: forall t. Wallet -> Wallet -> Value -> Simulation t CardanoTx

-- | Make a payment from one wallet to a public key address
payToPaymentPublicKeyHash :: forall t. Wallet -> PaymentPubKeyHash -> Value -> Simulation t CardanoTx

-- | Start a new instance of a contract
activateContract :: forall t. PABContract t => Wallet -> ContractDef t -> Simulation t ContractInstanceId

-- | Call a named endpoint on a contract instance
callEndpointOnInstance :: forall a t. ToJSON a => ContractInstanceId -> String -> a -> Simulation t (Maybe NotificationError)
handleAgentThread :: forall t a. Wallet -> Maybe ContractInstanceId -> Eff (ContractInstanceEffects t (SimulatorState t) '[IO]) a -> Simulation t a

-- | Whether the contract instance is still waiting for an event.
data Activity
Active :: Activity

-- | Instance was stopped before all requests were handled
Stopped :: Activity

-- | Instance finished, possibly with an error
Done :: Maybe Value -> Activity

-- | Stop the instance.
stopInstance :: forall t. ContractInstanceId -> Simulation t ()

-- | The <a>Activity</a> state of the instance
instanceActivity :: forall t. ContractInstanceId -> Simulation t Activity

-- | Wait 1 slot length, then add a new block.
makeBlock :: forall t effs. (LastMember IO effs, Member (Reader (SimulatorState t)) effs, Member (Reader BlockchainEnv) effs, Member (Reader InstancesState) effs, Member DelayEffect effs, Member TimeEffect effs) => Eff effs ()

-- | Get the current state of the contract instance.
instanceState :: forall t. Wallet -> ContractInstanceId -> Simulation t (State t)

-- | An STM transaction that returns the observable state of the contract
--   instance.
observableState :: forall t. ContractInstanceId -> Simulation t (STM Value)

-- | Wait until the observable state of the instance matches a predicate.
waitForState :: forall t a. (Value -> Maybe a) -> ContractInstanceId -> Simulation t a
waitForInstanceState :: forall t. (InstanceState -> STM (Maybe ContractActivityStatus)) -> ContractInstanceId -> Simulation t ContractActivityStatus
waitForInstanceStateWithResult :: forall t. ContractInstanceId -> Simulation t ContractActivityStatus

-- | The list of endpoints that are currently open
activeEndpoints :: forall t. ContractInstanceId -> Simulation t (STM [OpenEndpoint])

-- | Wait until the endpoint becomes active.
waitForEndpoint :: forall t. ContractInstanceId -> String -> Simulation t ()

-- | Wait until the status of the transaction changes
waitForTxStatusChange :: forall t. TxId -> Simulation t TxStatus

-- | Wait until the status of the transaction changes
waitForTxOutStatusChange :: forall t. TxOutRef -> Simulation t TxOutStatus
currentSlot :: forall t. Simulation t (STM Slot)

-- | Wait until the target slot number has been reached
waitUntilSlot :: forall t. Slot -> Simulation t ()

-- | Wait for the given number of slots.
waitNSlots :: forall t. Int -> Simulation t ()

-- | The set of all active contracts.
activeContracts :: forall t. Simulation t (Set ContractInstanceId)

-- | The final result of the instance (waits until it is available)
finalResult :: forall t. ContractInstanceId -> Simulation t (STM (Maybe Value))

-- | Wait until the contract is done, then return the error (if any)
waitUntilFinished :: forall t. ContractInstanceId -> Simulation t (Maybe Value)

-- | The total value currently at an address
valueAt :: forall t. CardanoAddress -> Simulation t Value

-- | The total value currently at an address
valueAtSTM :: forall t. CardanoAddress -> Simulation t (STM Value)

-- | The fees paid by the wallet.
walletFees :: forall t. Wallet -> Simulation t Value

-- | The entire chain (newest transactions first)
blockchain :: forall t. Simulation t Blockchain

-- | Retrieve the balances of all the entities in the simulator.
currentBalances :: forall t. Simulation t (Map Entity Value)

-- | Write the <tt>balances</tt> out to the log.
logBalances :: forall t effs. Member (LogMsg (PABMultiAgentMsg t)) effs => Map Entity Value -> Eff effs ()

-- | Statistics about the transactions that have been validated by the
--   emulated node.
data TxCounts
TxCounts :: Int -> Int -> TxCounts

-- | How many transactions were checked and added to the ledger
[_txValidated] :: TxCounts -> Int

-- | How many transactions remain in the mempool of the emulated node
[_txMemPool] :: TxCounts -> Int

-- | Get the <a>TxCounts</a> of the emulated blockchain
txCounts :: forall t. Simulation t TxCounts

-- | Get an STM transaction with the <a>TxCounts</a> of the emulated
--   blockchain
txCountsSTM :: forall t. Simulation t (STM TxCounts)
txValidated :: Lens' TxCounts Int
txMemPool :: Lens' TxCounts Int

-- | Wait until at least the given number of valid transactions are on the
--   simulated blockchain.
waitForValidatedTxCount :: forall t. Int -> Simulation t ()
instance GHC.Show.Show Plutus.PAB.Simulator.TxCounts
instance GHC.Classes.Ord Plutus.PAB.Simulator.TxCounts
instance GHC.Classes.Eq Plutus.PAB.Simulator.TxCounts

module Plutus.PAB.App
type App a b = PABAction (Builtin a) (AppEnv a) b
runApp :: forall a b. (FromJSON a, ToJSON a, HasDefinitions a, Typeable a) => StorageBackend -> Trace IO (PABLogMsg (Builtin a)) -> BuiltinHandler a -> Config -> App a b -> IO (Either PABError b)

-- | Application environment with a contract type <tt>a</tt>.
data AppEnv a
AppEnv :: DBConnection -> Maybe ClientEnv -> ClientEnv -> ChainQueryEnv -> Maybe TxSendHandle -> ChainSyncHandle -> Config -> Trace IO (PABLogMsg (Builtin a)) -> InMemInstances (Builtin a) -> AppEnv a
[dbPool] :: AppEnv a -> DBConnection

-- | No <a>ClientEnv</a> when in the remote client setting.
[walletClientEnv] :: AppEnv a -> Maybe ClientEnv
[nodeClientEnv] :: AppEnv a -> ClientEnv
[chainQueryEnv] :: AppEnv a -> ChainQueryEnv
[txSendHandle] :: AppEnv a -> Maybe TxSendHandle
[chainSyncHandle] :: AppEnv a -> ChainSyncHandle
[appConfig] :: AppEnv a -> Config
[appTrace] :: AppEnv a -> Trace IO (PABLogMsg (Builtin a))
[appInMemContractStore] :: AppEnv a -> InMemInstances (Builtin a)
data StorageBackend
BeamBackend :: StorageBackend
InMemoryBackend :: StorageBackend
migrate :: DbConfig -> Trace IO (PABLogMsg (Builtin a)) -> IO ()
dbConnect :: DbConfig -> Trace IO (PABLogMsg (Builtin a)) -> IO DBConnection
handleContractDefinition :: forall a effs. HasDefinitions a => ContractDefinition (Builtin a) ~> Eff effs
instance GHC.Show.Show Plutus.PAB.App.StorageBackend
instance GHC.Classes.Ord Plutus.PAB.App.StorageBackend
instance GHC.Classes.Eq Plutus.PAB.App.StorageBackend

module Plutus.PAB.Run.CommandParser
parseOptions :: IO AppOpts
data AppOpts
AppOpts :: Maybe Severity -> Maybe FilePath -> Maybe FilePath -> Maybe Text -> Maybe Int -> Point -> Bool -> StorageBackend -> ConfigCommand -> AppOpts
[minLogLevel] :: AppOpts -> Maybe Severity
[logConfigPath] :: AppOpts -> Maybe FilePath
[configPath] :: AppOpts -> Maybe FilePath
[passphrase] :: AppOpts -> Maybe Text
[rollbackHistory] :: AppOpts -> Maybe Int
[resumeFrom] :: AppOpts -> Point
[runEkgServer] :: AppOpts -> Bool
[storageBackend] :: AppOpts -> StorageBackend
[cmd] :: AppOpts -> ConfigCommand

module Plutus.PAB.Webserver.WebSocket

-- | Handler for WSAPI
wsHandler :: forall t env. (ContractInstanceId -> PendingConnection -> PABAction t env ()) :<|> (PendingConnection -> PABAction t env ())
combinedWebsocket :: forall t env. PendingConnection -> PABAction t env ()
contractInstanceUpdates :: forall t env. ContractInstanceId -> PendingConnection -> PABAction t env ()
getContractReport :: forall t env. PABContract t => PABAction t env (ContractReport (ContractDef t))
openEndpoints :: InstanceState -> STMStream [ActiveEndpoint]
slotChange :: BlockchainEnv -> STMStream Slot
observableStateChange :: InstanceState -> STMStream Value

module Plutus.PAB.Webserver.Server

-- | Start the server using the config. Returns an action that shuts it
--   down again, and an MVar that is filled when the webserver thread
--   exits.
startServer :: forall t env. (FromJSON (ContractDef t), ToJSON (ContractDef t), PABContract t, MimeUnrender JSON (ContractDef t), ToSchema (ContractDef t)) => WebserverConfig -> Availability -> PABAction t env (MVar (), PABAction t env ())

-- | Start the server. Returns an action that shuts it down again, and an
--   MVar that is filled when the webserver thread exits.
startServer' :: forall t env. (FromJSON (ContractDef t), ToJSON (ContractDef t), PABContract t, MimeUnrender JSON (ContractDef t), ToSchema (ContractDef t)) => [Middleware] -> Int -> Maybe TLSSettings -> Maybe FilePath -> Availability -> Int -> PABAction t env (MVar (), PABAction t env ())

-- | Start the server using a default configuration for debugging.
startServerDebug :: (FromJSON (ContractDef t), ToJSON (ContractDef t), PABContract t, MimeUnrender JSON (ContractDef t), ToSchema (ContractDef t)) => Simulation t (Simulation t ())

-- | Start the server using (mostly) a default configuration for debugging,
--   but allow an optional webserver config.
startServerDebug' :: (FromJSON (ContractDef t), ToJSON (ContractDef t), PABContract t, MimeUnrender JSON (ContractDef t), ToSchema (ContractDef t)) => WebserverConfig -> Simulation t (Simulation t ())

module Plutus.PAB.Run.Cli
data ConfigCommandArgs a
ConfigCommandArgs :: Trace IO (AppMsg (Builtin a)) -> Configuration -> Config -> Availability -> StorageBackend -> ConfigCommandArgs a

-- | PAB Tracer logging instance
[ccaTrace] :: ConfigCommandArgs a -> Trace IO (AppMsg (Builtin a))

-- | Monitoring configuration
[ccaLoggingConfig] :: ConfigCommandArgs a -> Configuration

-- | PAB Configuration
[ccaPABConfig] :: ConfigCommandArgs a -> Config

-- | Token for signaling service availability
[ccaAvailability] :: ConfigCommandArgs a -> Availability

-- | Wheter to use the beam-sqlite or in-memory backend
[ccaStorageBackend] :: ConfigCommandArgs a -> StorageBackend

-- | Interpret a <tt>Command</tt> in <a>Eff</a> using the provided tracer
--   and configurations
runConfigCommand :: forall a. (Ord a, Show a, ToJSON a, FromJSON a, Pretty a, MimeUnrender JSON a, HasDefinitions a, ToSchema a) => BuiltinHandler a -> ConfigCommandArgs a -> ConfigCommand -> IO ()

module Plutus.PAB.Run

-- | PAB entry point for a contract type <tt>a</tt>.
runWith :: forall a. (Show a, Ord a, FromJSON a, ToJSON a, Pretty a, MimeUnrender JSON a, HasDefinitions a, ToSchema a) => BuiltinHandler a -> IO ()

-- | Helper function to launch a complete PAB (all the necessary services)
--   that can be interacted over the API endpoints defined in
--   <a>Server</a>.
runWithOpts :: forall a. (Show a, Ord a, FromJSON a, ToJSON a, Pretty a, MimeUnrender JSON a, HasDefinitions a, ToSchema a) => BuiltinHandler a -> Maybe Config -> AppOpts -> IO ()


-- | Start a local cluster of cardano nodes and PAB(s)
module Plutus.PAB.LocalCluster.Run
data LogOutputs
LogOutputs :: [LogOutput] -> [LogOutput] -> LogOutputs
[loCluster] :: LogOutputs -> [LogOutput]
[loWallet] :: LogOutputs -> [LogOutput]
withLocalClusterSetup :: (FilePath -> LogOutputs -> IO a) -> IO a
runWith :: forall a. (Show a, Ord a, FromJSON a, ToJSON a, Pretty a, MimeUnrender JSON a, HasDefinitions a, ToSchema a) => BuiltinHandler a -> IO ()
newtype ChainIndexPort
ChainIndexPort :: Int -> ChainIndexPort
setupPABServices :: forall a. (Show a, Ord a, FromJSON a, ToJSON a, Pretty a, MimeUnrender JSON a, HasDefinitions a, ToSchema a) => BuiltinHandler a -> String -> Int -> FilePath -> RunningNode -> IO ()

-- | Launch the chain index in a separate thread.
launchChainIndex :: FilePath -> RunningNode -> IO ChainIndexPort

-- | Launch the PAB in a separate thread.
launchPAB :: forall a. (Show a, Ord a, FromJSON a, ToJSON a, Pretty a, MimeUnrender JSON a, HasDefinitions a, ToSchema a) => BuiltinHandler a -> Text -> FilePath -> BaseUrl -> RunningNode -> ChainIndexPort -> IO ()
slotConfigOfNetworkParameters :: NetworkParameters -> SlotConfig

-- | Set up wallets
restoreWallets :: String -> Int -> IO BaseUrl
sleep :: Int -> IO ()
data TestsLog
MsgBaseUrl :: Text -> Text -> Text -> TestsLog
MsgSettingUpFaucet :: TestsLog
MsgCluster :: ClusterLog -> TestsLog
instance GHC.Show.Show Plutus.PAB.LocalCluster.Run.TestsLog
instance Data.Text.Class.ToText Plutus.PAB.LocalCluster.Run.TestsLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Plutus.PAB.LocalCluster.Run.TestsLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Plutus.PAB.LocalCluster.Run.TestsLog

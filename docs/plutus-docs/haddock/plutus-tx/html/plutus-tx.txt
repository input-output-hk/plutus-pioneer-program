-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Libraries for Plutus Tx and its prelude
--   
--   Libraries for Plutus Tx and its prelude
@package plutus-tx
@version 1.0.0.0

module PlutusTx.Bool
data Bool
False :: Bool
True :: Bool

-- | Logical AND
--   
--   <pre>
--   &gt;&gt;&gt; True &amp;&amp; False
--   False
--   </pre>
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Logical OR
--   
--   <pre>
--   &gt;&gt;&gt; True || False
--   True
--   </pre>
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Logical negation
--   
--   <pre>
--   &gt;&gt;&gt; not True
--   False
--   </pre>
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool


-- | Plutus Tx basic functions.
module PlutusTx.Base

-- | Plutus Tx version of <a>fst</a>
fst :: (a, b) -> a

-- | Plutus Tx version of <a>snd</a>
snd :: (a, b) -> b
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | Plutus Tx version of 'Data.Function.($)'.
($) :: (a -> b) -> a -> b
infixr 0 $

-- | Plutus Tx version of <a>flip</a>.
flip :: (a -> b -> c) -> b -> a -> c

-- | Plutus Tx version of <a>until</a>.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | Plutus Tx version of 'Prelude.(.)'.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | Plutus Tx version of <a>const</a>.
const :: a -> b -> a

-- | Plutus Tx version of <a>id</a>.
id :: a -> a

module PlutusTx.Coverage
data CoverageAnnotation
CoverLocation :: CovLoc -> CoverageAnnotation
CoverBool :: CovLoc -> Bool -> CoverageAnnotation

-- | This type keeps track of all coverage annotations and where they have
--   been inserted / what annotations are expected to be found when
--   executing a piece of code.
data CoverageIndex
CoverageIndex :: Map CoverageAnnotation CoverageMetadata -> CoverageIndex
[_coverageMetadata] :: CoverageIndex -> Map CoverageAnnotation CoverageMetadata
newtype CoverageMetadata
CoverageMetadata :: Set Metadata -> CoverageMetadata
[_metadataSet] :: CoverageMetadata -> Set Metadata
data Metadata
ApplicationHeadSymbol :: String -> Metadata

-- | Location that is not interesting to cover. This is not generated by
--   the compiler, but can be added later using <a>addCoverageMetadata</a>.
IgnoredAnnotation :: Metadata
newtype CoverageData
CoverageData :: Set CoverageAnnotation -> CoverageData
[_coveredAnnotations] :: CoverageData -> Set CoverageAnnotation
data CoverageReport
CoverageReport :: CoverageIndex -> CoverageData -> CoverageReport
[_coverageIndex] :: CoverageReport -> CoverageIndex
[_coverageData] :: CoverageReport -> CoverageData

-- | A source location for coverage
data CovLoc
CovLoc :: String -> Int -> Int -> Int -> Int -> CovLoc
[_covLocFile] :: CovLoc -> String
[_covLocStartLine] :: CovLoc -> Int
[_covLocEndLine] :: CovLoc -> Int
[_covLocStartCol] :: CovLoc -> Int
[_covLocEndCol] :: CovLoc -> Int
covLocFile :: Lens' CovLoc String
covLocStartLine :: Lens' CovLoc Int
covLocEndLine :: Lens' CovLoc Int
covLocStartCol :: Lens' CovLoc Int
covLocEndCol :: Lens' CovLoc Int
metadataSet :: Iso' CoverageMetadata (Set Metadata)
coverageAnnotations :: Getter CoverageIndex (Set CoverageAnnotation)
ignoredAnnotations :: Getter CoverageIndex (Set CoverageAnnotation)
coverageMetadata :: Iso' CoverageIndex (Map CoverageAnnotation CoverageMetadata)
coveredAnnotations :: Iso' CoverageData (Set CoverageAnnotation)

-- | Add metadata to a coverage annotation. Does nothing if the annotation
--   is not in the index.
addCoverageMetadata :: CoverageAnnotation -> Metadata -> CoverageIndex -> CoverageIndex

-- | Include a location coverage annotation in the index
addLocationToCoverageIndex :: MonadWriter CoverageIndex m => CovLoc -> m CoverageAnnotation

-- | Include a boolean coverage annotation in the index
addBoolCaseToCoverageIndex :: MonadWriter CoverageIndex m => CovLoc -> Bool -> CoverageMetadata -> m CoverageAnnotation
coverageDataFromLogMsg :: String -> CoverageData
instance GHC.Base.Semigroup PlutusTx.Coverage.CoverageReport
instance GHC.Base.Monoid PlutusTx.Coverage.CoverageReport
instance Prettyprinter.Internal.Pretty PlutusTx.Coverage.CoverageReport
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.CoverageReport
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.CoverageReport
instance Control.DeepSeq.NFData PlutusTx.Coverage.CoverageReport
instance GHC.Generics.Generic PlutusTx.Coverage.CoverageReport
instance GHC.Show.Show PlutusTx.Coverage.CoverageReport
instance GHC.Classes.Eq PlutusTx.Coverage.CoverageReport
instance GHC.Classes.Ord PlutusTx.Coverage.CoverageReport
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.CoverageData
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.CoverageData
instance Control.DeepSeq.NFData PlutusTx.Coverage.CoverageData
instance GHC.Base.Monoid PlutusTx.Coverage.CoverageData
instance GHC.Base.Semigroup PlutusTx.Coverage.CoverageData
instance GHC.Generics.Generic PlutusTx.Coverage.CoverageData
instance GHC.Show.Show PlutusTx.Coverage.CoverageData
instance GHC.Classes.Eq PlutusTx.Coverage.CoverageData
instance GHC.Classes.Ord PlutusTx.Coverage.CoverageData
instance GHC.Base.Semigroup PlutusTx.Coverage.CoverageIndex
instance GHC.Base.Monoid PlutusTx.Coverage.CoverageIndex
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.CoverageIndex
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.CoverageIndex
instance Control.DeepSeq.NFData PlutusTx.Coverage.CoverageIndex
instance Flat.Class.Flat PlutusTx.Coverage.CoverageIndex
instance Codec.Serialise.Class.Serialise PlutusTx.Coverage.CoverageIndex
instance GHC.Generics.Generic PlutusTx.Coverage.CoverageIndex
instance GHC.Show.Show PlutusTx.Coverage.CoverageIndex
instance GHC.Classes.Eq PlutusTx.Coverage.CoverageIndex
instance GHC.Classes.Ord PlutusTx.Coverage.CoverageIndex
instance Prettyprinter.Internal.Pretty PlutusTx.Coverage.CoverageMetadata
instance Data.Aeson.Types.FromJSON.FromJSONKey PlutusTx.Coverage.CoverageAnnotation
instance Data.Aeson.Types.ToJSON.ToJSONKey PlutusTx.Coverage.CoverageAnnotation
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.CoverageAnnotation
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.CoverageAnnotation
instance Control.DeepSeq.NFData PlutusTx.Coverage.CoverageAnnotation
instance Flat.Class.Flat PlutusTx.Coverage.CoverageAnnotation
instance Codec.Serialise.Class.Serialise PlutusTx.Coverage.CoverageAnnotation
instance GHC.Generics.Generic PlutusTx.Coverage.CoverageAnnotation
instance GHC.Read.Read PlutusTx.Coverage.CoverageAnnotation
instance GHC.Show.Show PlutusTx.Coverage.CoverageAnnotation
instance GHC.Classes.Eq PlutusTx.Coverage.CoverageAnnotation
instance GHC.Classes.Ord PlutusTx.Coverage.CoverageAnnotation
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.Metadata
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.Metadata
instance Control.DeepSeq.NFData PlutusTx.Coverage.Metadata
instance Flat.Class.Flat PlutusTx.Coverage.Metadata
instance Codec.Serialise.Class.Serialise PlutusTx.Coverage.Metadata
instance GHC.Generics.Generic PlutusTx.Coverage.Metadata
instance GHC.Show.Show PlutusTx.Coverage.Metadata
instance GHC.Classes.Eq PlutusTx.Coverage.Metadata
instance GHC.Classes.Ord PlutusTx.Coverage.Metadata
instance Flat.Class.Flat PlutusTx.Coverage.CoverageMetadata
instance GHC.Base.Monoid PlutusTx.Coverage.CoverageMetadata
instance GHC.Base.Semigroup PlutusTx.Coverage.CoverageMetadata
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.CoverageMetadata
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.CoverageMetadata
instance Control.DeepSeq.NFData PlutusTx.Coverage.CoverageMetadata
instance Codec.Serialise.Class.Serialise PlutusTx.Coverage.CoverageMetadata
instance GHC.Generics.Generic PlutusTx.Coverage.CoverageMetadata
instance GHC.Show.Show PlutusTx.Coverage.CoverageMetadata
instance GHC.Classes.Eq PlutusTx.Coverage.CoverageMetadata
instance GHC.Classes.Ord PlutusTx.Coverage.CoverageMetadata
instance Prettyprinter.Internal.Pretty PlutusTx.Coverage.Metadata
instance Prettyprinter.Internal.Pretty PlutusTx.Coverage.CoverageAnnotation
instance Prettyprinter.Internal.Pretty PlutusTx.Coverage.CovLoc
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.CovLoc
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.CovLoc
instance Control.DeepSeq.NFData PlutusTx.Coverage.CovLoc
instance Flat.Class.Flat PlutusTx.Coverage.CovLoc
instance Codec.Serialise.Class.Serialise PlutusTx.Coverage.CovLoc
instance GHC.Generics.Generic PlutusTx.Coverage.CovLoc
instance GHC.Read.Read PlutusTx.Coverage.CovLoc
instance GHC.Show.Show PlutusTx.Coverage.CovLoc
instance GHC.Classes.Eq PlutusTx.Coverage.CovLoc
instance GHC.Classes.Ord PlutusTx.Coverage.CovLoc

module PlutusTx.Either

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
isLeft :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
isRight :: Either a b -> Bool

-- | Plutus Tx version of <a>either</a>
either :: (a -> c) -> (b -> c) -> Either a b -> c

module PlutusTx.Functor

-- | Plutus Tx version of <a>Functor</a>.
class Functor f

-- | Plutus Tx version of <a>fmap</a>.
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Plutus Tx version of <a>(&lt;$&gt;)</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Plutus Tx version of <a>(&lt;$)</a>.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$
instance PlutusTx.Functor.Functor []
instance PlutusTx.Functor.Functor GHC.Maybe.Maybe
instance PlutusTx.Functor.Functor (Data.Either.Either c)
instance PlutusTx.Functor.Functor ((,) c)
instance PlutusTx.Functor.Functor Data.Functor.Identity.Identity
instance PlutusTx.Functor.Functor (Data.Functor.Const.Const m)

module PlutusTx.Integer

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   For more information about this type's representation, see the
--   comments in its implementation.
data Integer

module PlutusTx.Lift.Class

-- | Class for types which have a corresponding Plutus IR type. Instances
--   should always be derived, do not write your own instance!
class Typeable uni (a :: k)

-- | Get the Plutus IR type corresponding to this type.
typeRep :: Typeable uni a => Proxy a -> RTCompile uni fun (Type TyName uni ())

-- | Class for types which can be lifted into Plutus IR. Instances should
--   be derived, do not write your own instance!
class Lift uni a

-- | Get a Plutus IR term corresponding to the given value.
lift :: Lift uni a => a -> RTCompile uni fun (Term TyName Name uni fun ())
type RTCompile uni fun = DefT Name uni fun () Quote
makeTypeable :: Type -> Name -> Q [Dec]
makeLift :: Name -> Q [Dec]
withTyVars :: MonadReader (LocalVars uni) m => [(Name, TyVarDecl TyName ())] -> m a -> m a
data LiftError
UnsupportedLiftKind :: Kind -> LiftError
UnsupportedLiftType :: Type -> LiftError
UserLiftError :: Text -> LiftError
LiftMissingDataCons :: Name -> LiftError
LiftMissingVar :: Name -> LiftError
instance GHC.Exception.Type.Exception PlutusTx.Lift.Class.LiftError
instance GHC.Classes.Ord PlutusTx.Lift.Class.Dep
instance GHC.Classes.Eq PlutusTx.Lift.Class.Dep
instance GHC.Show.Show PlutusTx.Lift.Class.Dep
instance Prettyprinter.Internal.Pretty PlutusTx.Lift.Class.LiftError
instance GHC.Show.Show PlutusTx.Lift.Class.LiftError
instance ErrorCode.HasErrorCode PlutusTx.Lift.Class.LiftError

module PlutusTx.These

-- | A <a>These</a> <tt>a</tt> <tt>b</tt> is either an <tt>a</tt>, or a
--   <tt>b</tt> or an <tt>a</tt> and a <tt>b</tt>. Plutus version of
--   <a>These</a>.
data These a b
This :: a -> These a b
That :: b -> These a b
These :: a -> b -> These a b
these :: (a -> c) -> (b -> c) -> (a -> b -> c) -> These a b -> c

-- | Consume a 'These a b' value.
theseWithDefault :: a -> b -> (a -> b -> c) -> These a b -> c

module PlutusTx.Utils
mustBeReplaced :: String -> a


-- | This module contains the special Haskell names that are used to map to
--   builtin types or functions in Plutus Core.
--   
--   Most users should not use this module directly, but rather use
--   <a>Builtins</a>.
module PlutusTx.Builtins.Internal
error :: BuiltinUnit -> a
data BuiltinBool
BuiltinBool :: Bool -> BuiltinBool
true :: BuiltinBool
false :: BuiltinBool
ifThenElse :: BuiltinBool -> a -> a -> a
data BuiltinUnit
BuiltinUnit :: () -> BuiltinUnit
unitval :: BuiltinUnit
chooseUnit :: BuiltinUnit -> a -> a
type BuiltinInteger = Integer
addInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
subtractInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
multiplyInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
divideInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
modInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
quotientInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
remainderInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
lessThanInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinBool
lessThanEqualsInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinBool
equalsInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinBool

-- | An opaque type representing Plutus Core ByteStrings.
data BuiltinByteString
BuiltinByteString :: ByteString -> BuiltinByteString
appendByteString :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString
consByteString :: BuiltinInteger -> BuiltinByteString -> BuiltinByteString
sliceByteString :: BuiltinInteger -> BuiltinInteger -> BuiltinByteString -> BuiltinByteString
lengthOfByteString :: BuiltinByteString -> BuiltinInteger
indexByteString :: BuiltinByteString -> BuiltinInteger -> BuiltinInteger
emptyByteString :: BuiltinByteString
sha2_256 :: BuiltinByteString -> BuiltinByteString
sha3_256 :: BuiltinByteString -> BuiltinByteString
blake2b_256 :: BuiltinByteString -> BuiltinByteString
verifyEd25519Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> BuiltinBool
verifyEcdsaSecp256k1Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> BuiltinBool
verifySchnorrSecp256k1Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> BuiltinBool
traceAll :: forall (a :: Type) (f :: Type -> Type). Foldable f => f Text -> a -> a
equalsByteString :: BuiltinByteString -> BuiltinByteString -> BuiltinBool
lessThanByteString :: BuiltinByteString -> BuiltinByteString -> BuiltinBool
lessThanEqualsByteString :: BuiltinByteString -> BuiltinByteString -> BuiltinBool
decodeUtf8 :: BuiltinByteString -> BuiltinString
data BuiltinString
BuiltinString :: Text -> BuiltinString
appendString :: BuiltinString -> BuiltinString -> BuiltinString
emptyString :: BuiltinString
equalsString :: BuiltinString -> BuiltinString -> BuiltinBool
trace :: BuiltinString -> a -> a
encodeUtf8 :: BuiltinString -> BuiltinByteString
data BuiltinPair a b
BuiltinPair :: (a, b) -> BuiltinPair a b
fst :: BuiltinPair a b -> a
snd :: BuiltinPair a b -> b
mkPairData :: BuiltinData -> BuiltinData -> BuiltinPair BuiltinData BuiltinData
data BuiltinList a
BuiltinList :: [a] -> BuiltinList a
null :: BuiltinList a -> BuiltinBool
head :: BuiltinList a -> a
tail :: BuiltinList a -> BuiltinList a
chooseList :: BuiltinList a -> b -> b -> b
mkNilData :: BuiltinUnit -> BuiltinList BuiltinData
mkNilPairData :: BuiltinUnit -> BuiltinList (BuiltinPair BuiltinData BuiltinData)
mkCons :: a -> BuiltinList a -> BuiltinList a

-- | A type corresponding to the Plutus Core builtin equivalent of
--   <a>Data</a>.
--   
--   The point of this type is to be an opaque equivalent of <a>Data</a>,
--   so as to ensure that it is only used in ways that the compiler can
--   handle.
--   
--   As such, you should use this type in your on-chain code, and in any
--   data structures that you want to be representable on-chain.
--   
--   For off-chain usage, there are conversion functions
--   <a>builtinDataToData</a> and <a>dataToBuiltinData</a>, but note that
--   these will not work on-chain.
data BuiltinData
BuiltinData :: Data -> BuiltinData

-- | Convert a <a>BuiltinData</a> into a <a>Data</a>. Only works off-chain.
builtinDataToData :: BuiltinData -> Data

-- | Convert a <a>Data</a> into a <a>BuiltinData</a>. Only works off-chain.
dataToBuiltinData :: Data -> BuiltinData
chooseData :: forall a. BuiltinData -> a -> a -> a -> a -> a -> a
mkConstr :: BuiltinInteger -> BuiltinList BuiltinData -> BuiltinData
mkMap :: BuiltinList (BuiltinPair BuiltinData BuiltinData) -> BuiltinData
mkList :: BuiltinList BuiltinData -> BuiltinData
mkI :: BuiltinInteger -> BuiltinData
mkB :: BuiltinByteString -> BuiltinData
unsafeDataAsConstr :: BuiltinData -> BuiltinPair BuiltinInteger (BuiltinList BuiltinData)
unsafeDataAsMap :: BuiltinData -> BuiltinList (BuiltinPair BuiltinData BuiltinData)
unsafeDataAsList :: BuiltinData -> BuiltinList BuiltinData
unsafeDataAsI :: BuiltinData -> BuiltinInteger
unsafeDataAsB :: BuiltinData -> BuiltinByteString
equalsData :: BuiltinData -> BuiltinData -> BuiltinBool
serialiseData :: BuiltinData -> BuiltinByteString
instance Data.Data.Data PlutusTx.Builtins.Internal.BuiltinBool
instance Data.Data.Data PlutusTx.Builtins.Internal.BuiltinUnit
instance Data.Data.Data PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.Data.Data PlutusTx.Builtins.Internal.BuiltinString
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (PlutusTx.Builtins.Internal.BuiltinPair a b)
instance Data.Data.Data a => Data.Data.Data (PlutusTx.Builtins.Internal.BuiltinList a)
instance Data.Data.Data PlutusTx.Builtins.Internal.BuiltinData
instance GHC.Show.Show PlutusTx.Builtins.Internal.BuiltinData
instance GHC.Classes.Eq PlutusTx.Builtins.Internal.BuiltinData
instance GHC.Classes.Ord PlutusTx.Builtins.Internal.BuiltinData
instance Control.DeepSeq.NFData PlutusTx.Builtins.Internal.BuiltinData
instance Prettyprinter.Internal.Pretty PlutusTx.Builtins.Internal.BuiltinData
instance GHC.Show.Show a => GHC.Show.Show (PlutusTx.Builtins.Internal.BuiltinList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusTx.Builtins.Internal.BuiltinList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (PlutusTx.Builtins.Internal.BuiltinList a)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (PlutusTx.Builtins.Internal.BuiltinPair a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (PlutusTx.Builtins.Internal.BuiltinPair a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (PlutusTx.Builtins.Internal.BuiltinPair a b)
instance GHC.Show.Show PlutusTx.Builtins.Internal.BuiltinString
instance GHC.Classes.Eq PlutusTx.Builtins.Internal.BuiltinString
instance GHC.Classes.Ord PlutusTx.Builtins.Internal.BuiltinString
instance GHC.Show.Show PlutusTx.Builtins.Internal.BuiltinByteString
instance GHC.Classes.Eq PlutusTx.Builtins.Internal.BuiltinByteString
instance GHC.Classes.Ord PlutusTx.Builtins.Internal.BuiltinByteString
instance GHC.Base.Semigroup PlutusTx.Builtins.Internal.BuiltinByteString
instance GHC.Base.Monoid PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.Hashable.Class.Hashable PlutusTx.Builtins.Internal.BuiltinByteString
instance Codec.Serialise.Class.Serialise PlutusTx.Builtins.Internal.BuiltinByteString
instance Control.DeepSeq.NFData PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.ByteArray.Types.ByteArrayAccess PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.ByteArray.Types.ByteArray PlutusTx.Builtins.Internal.BuiltinByteString
instance Prettyprinter.Internal.Pretty PlutusTx.Builtins.Internal.BuiltinByteString

module PlutusTx.Builtins.Class

-- | A class witnessing the ability to convert from the builtin
--   representation to the Haskell representation.
class FromBuiltin arep a | arep -> a
fromBuiltin :: FromBuiltin arep a => arep -> a

-- | A class witnessing the ability to convert from the Haskell
--   representation to the builtin representation.
class ToBuiltin a arep | a -> arep
toBuiltin :: ToBuiltin a arep => a -> arep
stringToBuiltinString :: String -> BuiltinString
obfuscatedId :: a -> a
stringToBuiltinByteString :: String -> BuiltinByteString
instance PlutusTx.Builtins.Class.ToBuiltin GHC.Integer.Type.Integer PlutusTx.Builtins.Internal.BuiltinInteger
instance PlutusTx.Builtins.Class.ToBuiltin GHC.Types.Bool PlutusTx.Builtins.Internal.BuiltinBool
instance PlutusTx.Builtins.Class.ToBuiltin () PlutusTx.Builtins.Internal.BuiltinUnit
instance PlutusTx.Builtins.Class.ToBuiltin Data.ByteString.Internal.ByteString PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Builtins.Class.ToBuiltin Data.Text.Internal.Text PlutusTx.Builtins.Internal.BuiltinString
instance PlutusTx.Builtins.Class.ToBuiltin (PlutusTx.Builtins.Internal.BuiltinData, PlutusTx.Builtins.Internal.BuiltinData) (PlutusTx.Builtins.Internal.BuiltinPair PlutusTx.Builtins.Internal.BuiltinData PlutusTx.Builtins.Internal.BuiltinData)
instance PlutusTx.Builtins.Class.ToBuiltin [PlutusTx.Builtins.Internal.BuiltinData] (PlutusTx.Builtins.Internal.BuiltinList PlutusTx.Builtins.Internal.BuiltinData)
instance PlutusTx.Builtins.Class.ToBuiltin [(PlutusTx.Builtins.Internal.BuiltinData, PlutusTx.Builtins.Internal.BuiltinData)] (PlutusTx.Builtins.Internal.BuiltinList (PlutusTx.Builtins.Internal.BuiltinPair PlutusTx.Builtins.Internal.BuiltinData PlutusTx.Builtins.Internal.BuiltinData))
instance PlutusTx.Builtins.Class.ToBuiltin PlutusTx.Builtins.Internal.BuiltinData PlutusTx.Builtins.Internal.BuiltinData
instance PlutusTx.Builtins.Class.FromBuiltin PlutusTx.Builtins.Internal.BuiltinInteger GHC.Integer.Type.Integer
instance PlutusTx.Builtins.Class.FromBuiltin PlutusTx.Builtins.Internal.BuiltinBool GHC.Types.Bool
instance PlutusTx.Builtins.Class.FromBuiltin PlutusTx.Builtins.Internal.BuiltinUnit ()
instance PlutusTx.Builtins.Class.FromBuiltin PlutusTx.Builtins.Internal.BuiltinByteString Data.ByteString.Internal.ByteString
instance PlutusTx.Builtins.Class.FromBuiltin PlutusTx.Builtins.Internal.BuiltinString Data.Text.Internal.Text
instance (PlutusTx.Builtins.Class.FromBuiltin arep a, PlutusTx.Builtins.Class.FromBuiltin brep b) => PlutusTx.Builtins.Class.FromBuiltin (PlutusTx.Builtins.Internal.BuiltinPair arep brep) (a, b)
instance PlutusTx.Builtins.Class.FromBuiltin arep a => PlutusTx.Builtins.Class.FromBuiltin (PlutusTx.Builtins.Internal.BuiltinList arep) [a]
instance PlutusTx.Builtins.Class.FromBuiltin PlutusTx.Builtins.Internal.BuiltinData PlutusTx.Builtins.Internal.BuiltinData
instance Data.String.IsString PlutusTx.Builtins.Internal.BuiltinString
instance Data.String.IsString PlutusTx.Builtins.Internal.BuiltinByteString


-- | Primitive names and functions for working with Plutus Core builtins.
module PlutusTx.Builtins

-- | An opaque type representing Plutus Core ByteStrings.
data BuiltinByteString

-- | Concatenates two <tt>ByteString</tt>s.
appendByteString :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString

-- | Adds a byte to the front of a <tt>ByteString</tt>.
consByteString :: Integer -> BuiltinByteString -> BuiltinByteString

-- | Returns the substring of a <tt>ByteString</tt> from index
--   <tt>start</tt> of length <tt>n</tt>.
sliceByteString :: Integer -> Integer -> BuiltinByteString -> BuiltinByteString

-- | Returns the length of a <tt>ByteString</tt>.
lengthOfByteString :: BuiltinByteString -> Integer

-- | Returns the byte of a <tt>ByteString</tt> at index.
indexByteString :: BuiltinByteString -> Integer -> Integer

-- | An empty <tt>ByteString</tt>.
emptyByteString :: BuiltinByteString

-- | Check if two <tt>ByteString</tt>s are equal.
equalsByteString :: BuiltinByteString -> BuiltinByteString -> Bool

-- | Check if one <tt>ByteString</tt> is less than another.
lessThanByteString :: BuiltinByteString -> BuiltinByteString -> Bool

-- | Check if one <tt>ByteString</tt> is less than or equal to another.
lessThanEqualsByteString :: BuiltinByteString -> BuiltinByteString -> Bool

-- | Check if one <tt>ByteString</tt> is greater than another.
greaterThanByteString :: BuiltinByteString -> BuiltinByteString -> Bool

-- | Check if one <tt>ByteString</tt> is greater than another.
greaterThanEqualsByteString :: BuiltinByteString -> BuiltinByteString -> Bool

-- | The SHA2-256 hash of a <tt>ByteString</tt>
sha2_256 :: BuiltinByteString -> BuiltinByteString

-- | The SHA3-256 hash of a <tt>ByteString</tt>
sha3_256 :: BuiltinByteString -> BuiltinByteString

-- | The BLAKE2B-256 hash of a <tt>ByteString</tt>
blake2b_256 :: BuiltinByteString -> BuiltinByteString

-- | Ed25519 signature verification. Verify that the signature is a
--   signature of the message by the public key. This will fail if key or
--   the signature are not of the expected length.
verifyEd25519Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> Bool

-- | Given an ECDSA SECP256k1 verification key, an ECDSA SECP256k1
--   signature, and an ECDSA SECP256k1 message hash (all as
--   <a>BuiltinByteString</a>s), verify the hash with that key and
--   signature.
--   
--   <h1>Important note</h1>
--   
--   The verification key, the signature, and the message hash must all be
--   of appropriate form and length. This function will error if any of
--   these are not the case.
verifyEcdsaSecp256k1Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> Bool

-- | Given a Schnorr SECP256k1 verification key, a Schnorr SECP256k1
--   signature, and a message (all as <a>BuiltinByteString</a>s), verify
--   the message with that key and signature.
--   
--   <h1>Important note</h1>
--   
--   The verification key and signature must all be of appropriate form and
--   length. This function will error if this is not the case.
verifySchnorrSecp256k1Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> Bool

-- | Converts a ByteString to a String.
decodeUtf8 :: BuiltinByteString -> BuiltinString

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   For more information about this type's representation, see the
--   comments in its implementation.
data Integer

-- | Add two <a>Integer</a>s.
addInteger :: Integer -> Integer -> Integer

-- | Subtract two <a>Integer</a>s.
subtractInteger :: Integer -> Integer -> Integer

-- | Multiply two <a>Integer</a>s.
multiplyInteger :: Integer -> Integer -> Integer

-- | Divide two integers.
divideInteger :: Integer -> Integer -> Integer

-- | Integer modulo operation.
modInteger :: Integer -> Integer -> Integer

-- | Quotient of two integers.
quotientInteger :: Integer -> Integer -> Integer

-- | Take the remainder of dividing two <a>Integer</a>s.
remainderInteger :: Integer -> Integer -> Integer

-- | Check whether one <a>Integer</a> is greater than another.
greaterThanInteger :: Integer -> Integer -> Bool

-- | Check whether one <a>Integer</a> is greater than or equal to another.
greaterThanEqualsInteger :: Integer -> Integer -> Bool

-- | Check whether one <a>Integer</a> is less than another.
lessThanInteger :: Integer -> Integer -> Bool

-- | Check whether one <a>Integer</a> is less than or equal to another.
lessThanEqualsInteger :: Integer -> Integer -> Bool

-- | Check if two <a>Integer</a>s are equal.
equalsInteger :: Integer -> Integer -> Bool

-- | Aborts evaluation with an error.
error :: () -> a

-- | A type corresponding to the Plutus Core builtin equivalent of
--   <a>Data</a>.
--   
--   The point of this type is to be an opaque equivalent of <a>Data</a>,
--   so as to ensure that it is only used in ways that the compiler can
--   handle.
--   
--   As such, you should use this type in your on-chain code, and in any
--   data structures that you want to be representable on-chain.
--   
--   For off-chain usage, there are conversion functions
--   <a>builtinDataToData</a> and <a>dataToBuiltinData</a>, but note that
--   these will not work on-chain.
data BuiltinData

-- | Given five values for the five different constructors of
--   <a>BuiltinData</a>, selects one depending on which corresponds to the
--   actual constructor of the given value.
chooseData :: forall a. BuiltinData -> a -> a -> a -> a -> a -> a

-- | Given a <a>BuiltinData</a> value and matching functions for the five
--   constructors, applies the appropriate matcher to the arguments of the
--   constructor and returns the result.
matchData :: BuiltinData -> (Integer -> [BuiltinData] -> r) -> ([(BuiltinData, BuiltinData)] -> r) -> ([BuiltinData] -> r) -> (Integer -> r) -> (BuiltinByteString -> r) -> r

-- | Given a <a>BuiltinData</a> value and matching functions for the five
--   constructors, applies the appropriate matcher to the arguments of the
--   constructor and returns the result.
matchData' :: BuiltinData -> (Integer -> BuiltinList BuiltinData -> r) -> (BuiltinList (BuiltinPair BuiltinData BuiltinData) -> r) -> (BuiltinList BuiltinData -> r) -> (Integer -> r) -> (BuiltinByteString -> r) -> r

-- | Check if two <a>BuiltinData</a>s are equal.
equalsData :: BuiltinData -> BuiltinData -> Bool

-- | Convert a String into a ByteString.
serialiseData :: BuiltinData -> BuiltinByteString

-- | Constructs a <a>BuiltinData</a> value with the <tt>Constr</tt>
--   constructor.
mkConstr :: Integer -> [BuiltinData] -> BuiltinData

-- | Constructs a <a>BuiltinData</a> value with the <tt>Map</tt>
--   constructor.
mkMap :: [(BuiltinData, BuiltinData)] -> BuiltinData

-- | Constructs a <a>BuiltinData</a> value with the <tt>List</tt>
--   constructor.
mkList :: [BuiltinData] -> BuiltinData

-- | Constructs a <a>BuiltinData</a> value with the <tt>I</tt> constructor.
mkI :: Integer -> BuiltinData

-- | Constructs a <a>BuiltinData</a> value with the <tt>B</tt> constructor.
mkB :: BuiltinByteString -> BuiltinData

-- | Deconstructs a <a>BuiltinData</a> as a <tt>Constr</tt>, or fails if it
--   is not one.
unsafeDataAsConstr :: BuiltinData -> (Integer, [BuiltinData])

-- | Deconstructs a <a>BuiltinData</a> as a <tt>Map</tt>, or fails if it is
--   not one.
unsafeDataAsMap :: BuiltinData -> [(BuiltinData, BuiltinData)]

-- | Deconstructs a <a>BuiltinData</a> as a <tt>List</tt>, or fails if it
--   is not one.
unsafeDataAsList :: BuiltinData -> [BuiltinData]

-- | Deconstructs a <a>BuiltinData</a> as an <tt>I</tt>, or fails if it is
--   not one.
unsafeDataAsI :: BuiltinData -> Integer

-- | Deconstructs a <a>BuiltinData</a> as a <tt>B</tt>, or fails if it is
--   not one.
unsafeDataAsB :: BuiltinData -> BuiltinByteString

-- | Convert a <a>BuiltinData</a> into a <a>Data</a>. Only works off-chain.
builtinDataToData :: BuiltinData -> Data

-- | Convert a <a>Data</a> into a <a>BuiltinData</a>. Only works off-chain.
dataToBuiltinData :: Data -> BuiltinData
data BuiltinString

-- | Append two <tt>String</tt>s.
appendString :: BuiltinString -> BuiltinString -> BuiltinString

-- | An empty <tt>String</tt>.
emptyString :: BuiltinString

-- | Check if two strings are equal
equalsString :: BuiltinString -> BuiltinString -> Bool

-- | Convert a String into a ByteString.
encodeUtf8 :: BuiltinString -> BuiltinByteString
matchList :: forall a r. BuiltinList a -> r -> (a -> BuiltinList a -> r) -> r

-- | Emit the given string as a trace message before evaluating the
--   argument.
trace :: BuiltinString -> a -> a
fromBuiltin :: FromBuiltin arep a => arep -> a
toBuiltin :: ToBuiltin a arep => a -> arep

module PlutusTx.Trace

-- | Emit the given string as a trace message before evaluating the
--   argument.
trace :: BuiltinString -> a -> a

-- | Log a message and then terminate the evaluation with an error.
traceError :: BuiltinString -> a

-- | Emit the given <a>BuiltinString</a> only if the argument evaluates to
--   <a>False</a>.
traceIfFalse :: BuiltinString -> Bool -> Bool

-- | Emit the given <a>BuiltinString</a> only if the argument evaluates to
--   <a>True</a>.
traceIfTrue :: BuiltinString -> Bool -> Bool

-- | Emit one of two <a>BuiltinString</a> depending on whether or not the
--   argument evaluates to <a>True</a> or <a>False</a>.
traceBool :: BuiltinString -> BuiltinString -> Bool -> Bool

module PlutusTx.Code

-- | A compiled Plutus Tx program. The last type parameter indicates the
--   type of the Haskell expression that was compiled, and hence the type
--   of the compiled code.
--   
--   Note: the compiled PLC program does *not* have normalized types, if
--   you want to put it on the chain you must normalize the types first.
data CompiledCodeIn uni fun a

-- | Serialized UPLC code and possibly serialized PIR code with metadata
--   used for program coverage.
SerializedCode :: ByteString -> Maybe ByteString -> CoverageIndex -> CompiledCodeIn uni fun a

-- | Deserialized UPLC program, and possibly deserialized PIR program with
--   metadata used for program coverage.
DeserializedCode :: Program NamedDeBruijn uni fun () -> Maybe (Program TyName Name uni fun ()) -> CoverageIndex -> CompiledCodeIn uni fun a

-- | <a>CompiledCodeIn</a> instantiated with default built-in types and
--   functions.
type CompiledCode = CompiledCodeIn DefaultUni DefaultFun

-- | Apply a compiled function to a compiled argument.
applyCode :: (Closed uni, uni `Everywhere` Flat, Flat fun, uni `Everywhere` PrettyConst, GShow uni, Pretty fun) => CompiledCodeIn uni fun (a -> b) -> CompiledCodeIn uni fun a -> CompiledCodeIn uni fun b

-- | The size of a <a>CompiledCodeIn</a>, in AST nodes.
sizePlc :: (Closed uni, uni `Everywhere` Flat, Flat fun, uni `Everywhere` PrettyConst, GShow uni, Pretty fun) => CompiledCodeIn uni fun a -> Integer
newtype ImpossibleDeserialisationFailure
ImpossibleDeserialisationFailure :: DecodeException -> ImpossibleDeserialisationFailure

-- | Get the actual Plutus Core program out of a <a>CompiledCodeIn</a>.
getPlc :: (Closed uni, uni `Everywhere` Flat, Flat fun, uni `Everywhere` PrettyConst, GShow uni, Pretty fun) => CompiledCodeIn uni fun a -> Program NamedDeBruijn uni fun ()

-- | Get the Plutus IR program, if there is one, out of a
--   <a>CompiledCodeIn</a>.
getPir :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Maybe (Program TyName Name uni fun ())
getCovIdx :: CompiledCodeIn uni fun a -> CoverageIndex
instance GHC.Exception.Type.Exception PlutusTx.Code.ImpossibleDeserialisationFailure
instance GHC.Show.Show PlutusTx.Code.ImpossibleDeserialisationFailure
instance ErrorCode.HasErrorCode PlutusTx.Code.ImpossibleDeserialisationFailure
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni Flat.Class.Flat, Flat.Class.Flat fun, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst, Data.GADT.Internal.GShow uni, Prettyprinter.Internal.Pretty fun) => Flat.Class.Flat (PlutusTx.Code.CompiledCodeIn uni fun a)

module PlutusTx.Plugin.Utils

-- | Marks the given expression for compilation to PLC.
plc :: forall (loc :: Symbol) a. Proxy loc -> a -> CompiledCode a

module PlutusTx.TH

-- | Compile a quoted Haskell expression into a corresponding Plutus Core
--   program.
compile :: SpliceQ a -> SpliceQ (CompiledCode a)

-- | Compile a quoted Haskell expression into a corresponding Plutus Core
--   program.
compileUntyped :: Q Exp -> Q Exp

-- | Load a <a>CompiledCode</a> from a file. Drop-in replacement for
--   <a>compile</a>.
loadFromFile :: FilePath -> SpliceQ (CompiledCode a)

module PlutusTx.Lift
makeLift :: Name -> Q [Dec]

-- | Get a Plutus Core term corresponding to the given value.
safeLift :: (Lift uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), GEq uni, AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, Typecheckable uni fun, PrettyPrintable uni fun) => a -> m (Term NamedDeBruijn uni fun ())

-- | Get a Plutus Core program corresponding to the given value.
safeLiftProgram :: (Lift uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), GEq uni, AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, Typecheckable uni fun, PrettyPrintable uni fun) => a -> m (Program NamedDeBruijn uni fun ())
safeLiftCode :: (Lift uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), GEq uni, AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, Typecheckable uni fun, PrettyPrintable uni fun) => a -> m (CompiledCodeIn uni fun a)

-- | Get a Plutus Core term corresponding to the given value, throwing any
--   errors that occur as exceptions and ignoring fresh names.
lift :: (Lift uni a, Throwable uni fun, Typecheckable uni fun) => a -> Term NamedDeBruijn uni fun ()

-- | Get a Plutus Core program corresponding to the given value, throwing
--   any errors that occur as exceptions and ignoring fresh names.
liftProgram :: (Lift uni a, Throwable uni fun, Typecheckable uni fun) => a -> Program NamedDeBruijn uni fun ()

-- | Get a Plutus Core program in the default universe corresponding to the
--   given value, throwing any errors that occur as exceptions and ignoring
--   fresh names.
liftProgramDef :: Lift DefaultUni a => a -> Program NamedDeBruijn DefaultUni DefaultFun ()

-- | Get a Plutus Core program corresponding to the given value as a
--   <a>CompiledCodeIn</a>, throwing any errors that occur as exceptions
--   and ignoring fresh names.
liftCode :: (Lift uni a, Throwable uni fun, Typecheckable uni fun) => a -> CompiledCodeIn uni fun a

-- | Check that PLC term has the given type.
typeCheckAgainst :: forall e a uni fun m. (Typeable uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), AsTypeErrorExt e uni (Provenance ()), AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, GEq uni, Typecheckable uni fun, PrettyPrintable uni fun) => Proxy a -> Term TyName Name uni fun () -> m ()

-- | Try to interpret a PLC program as a <a>CompiledCodeIn</a> of the given
--   type. Returns successfully iff the program has the right type.
typeCode :: forall e a uni fun m. (Typeable uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, GEq uni, Typecheckable uni fun, PrettyPrintable uni fun) => Proxy a -> Program TyName Name uni fun () -> m (CompiledCodeIn uni fun a)

module PlutusTx.ErrorCodes

-- | A list of all error codes used in the plutus prelude
allErrorCodes :: Map BuiltinString String

-- | The error happens in TH generation of indexed data
reconstructCaseError :: BuiltinString

-- | Error case of <tt>unsafeFromBuiltinData</tt>
voidIsNotSupportedError :: BuiltinString

-- | Ratio number can't have a zero denominator
ratioHasZeroDenominatorError :: BuiltinString

-- | <tt>round</tt> got an incorrect input
roundDefaultDefnError :: BuiltinString

-- | <tt>check</tt> input is <tt>False</tt>
checkHasFailedError :: BuiltinString

-- | PlutusTx.List.!!: negative index
negativeIndexError :: BuiltinString

-- | PlutusTx.List.!!: index too large
indexTooLargeError :: BuiltinString

-- | PlutusTx.List.head: empty list
headEmptyListError :: BuiltinString

-- | PlutusTx.List.tail: empty list
tailEmptyListError :: BuiltinString

-- | PlutusTx.Enum.().succ: bad argument
succVoidBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.().pred: bad argument
predVoidBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.().toEnum: bad argument
toEnumVoidBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.Bool.succ: bad argument
succBoolBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.Bool.pred: bad argument
predBoolBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.Bool.toEnum: bad argument
toEnumBoolBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.Ordering.succ: bad argument
succOrderingBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.Ordering.pred: bad argument
predOrderingBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.Ordering.toEnum: bad argument
toEnumOrderingBadArgumentError :: BuiltinString

module PlutusTx.Eq

-- | The <a>Eq</a> class defines equality (<a>==</a>).
class Eq a
(==) :: Eq a => a -> a -> Bool
infix 4 ==
(/=) :: Eq a => a -> a -> Bool
infix 4 /=
instance PlutusTx.Eq.Eq GHC.Integer.Type.Integer
instance PlutusTx.Eq.Eq PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Eq.Eq PlutusTx.Builtins.Internal.BuiltinData
instance PlutusTx.Eq.Eq PlutusTx.Builtins.Internal.BuiltinString
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq [a]
instance PlutusTx.Eq.Eq GHC.Types.Bool
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (GHC.Maybe.Maybe a)
instance (PlutusTx.Eq.Eq a, PlutusTx.Eq.Eq b) => PlutusTx.Eq.Eq (Data.Either.Either a b)
instance PlutusTx.Eq.Eq ()
instance (PlutusTx.Eq.Eq a, PlutusTx.Eq.Eq b) => PlutusTx.Eq.Eq (a, b)

module PlutusTx.Ord

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 >
infix 4 <=
infix 4 <
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering
instance PlutusTx.Ord.Ord GHC.Integer.Type.Integer
instance PlutusTx.Ord.Ord PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord [a]
instance PlutusTx.Ord.Ord GHC.Types.Bool
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (GHC.Maybe.Maybe a)
instance (PlutusTx.Ord.Ord a, PlutusTx.Ord.Ord b) => PlutusTx.Ord.Ord (Data.Either.Either a b)
instance PlutusTx.Ord.Ord ()
instance (PlutusTx.Ord.Ord a, PlutusTx.Ord.Ord b) => PlutusTx.Ord.Ord (a, b)
instance PlutusTx.Eq.Eq GHC.Types.Ordering

module PlutusTx.List

-- | Plutus Tx version of <a>map</a>.
--   
--   <pre>
--   &gt;&gt;&gt; map (\i -&gt; i + 1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Plutus Tx version of <a>filter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; filter (&gt; 1) [1, 2, 3, 4]
--   [2,3,4]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>listToMaybe</a>.
listToMaybe :: [a] -> Maybe a

-- | Return the element in the list, if there is precisely one.
uniqueElement :: [a] -> Maybe a

-- | Plutus Tx version of <a>findIndices</a>.
findIndices :: (a -> Bool) -> [a] -> [Integer]

-- | Plutus Tx version of <a>findIndex</a>.
findIndex :: (a -> Bool) -> [a] -> Maybe Integer

-- | Plutus Tx version of <a>foldr</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\i s -&gt; s + i) 0 [1, 2, 3, 4]
--   10
--   </pre>
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | Plutus Tx version of <a>reverse</a>.
reverse :: [a] -> [a]

-- | Plutus Tx version of <a>zip</a>.
zip :: [a] -> [b] -> [(a, b)]

-- | Plutus Tx version of <a>(++)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0, 1, 2] ++ [1, 2, 3, 4]
--   [0,1,2,1,2,3,4]
--   </pre>
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | Plutus Tx version of <a>(!!)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [10, 11, 12] !! 2
--   12
--   </pre>
(!!) :: [a] -> Integer -> a
infixl 9 !!

-- | Plutus Tx version of <a>head</a>.
head :: [a] -> a

-- | Plutus Tx version of <a>take</a>.
take :: Integer -> [a] -> [a]

-- | Plutus Tx version of <a>tail</a>.
tail :: [a] -> [a]

-- | Plutus Tx version of <a>nub</a>.
nub :: Eq a => [a] -> [a]

-- | Plutus Tx version of <a>nubBy</a>.
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>zipWith</a>.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | Plutus Tx version of <a>dropWhile</a>.
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>partition</a>.
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | Plutus Tx version of <a>sort</a>.
sort :: Ord a => [a] -> [a]

-- | Plutus Tx version of <a>sortBy</a>.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

module PlutusTx.Semigroup

-- | Plutus Tx version of <a>Semigroup</a>.
class Semigroup a

-- | Plutus Tx version of <a>(&lt;&gt;)</a>.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>
newtype Max a
Max :: a -> Max a
[getMax] :: Max a -> a
newtype Min a
Min :: a -> Min a
[getMin] :: Min a -> a
instance PlutusTx.Functor.Functor PlutusTx.Semigroup.Min
instance PlutusTx.Ord.Ord a => PlutusTx.Semigroup.Semigroup (PlutusTx.Semigroup.Min a)
instance PlutusTx.Functor.Functor PlutusTx.Semigroup.Max
instance PlutusTx.Ord.Ord a => PlutusTx.Semigroup.Semigroup (PlutusTx.Semigroup.Max a)
instance PlutusTx.Semigroup.Semigroup PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Semigroup.Semigroup PlutusTx.Builtins.Internal.BuiltinString
instance PlutusTx.Semigroup.Semigroup [a]
instance (PlutusTx.Semigroup.Semigroup a, PlutusTx.Semigroup.Semigroup b) => PlutusTx.Semigroup.Semigroup (a, b)
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Semigroup.Semigroup (GHC.Maybe.Maybe a)
instance PlutusTx.Semigroup.Semigroup GHC.Types.Ordering
instance PlutusTx.Semigroup.Semigroup ()
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Semigroup.Semigroup (Data.Semigroup.Internal.Dual a)
instance PlutusTx.Semigroup.Semigroup (Data.Semigroup.Internal.Endo a)
instance PlutusTx.Semigroup.Semigroup (Data.Monoid.First a)

module PlutusTx.Maybe

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | Check if a <a>Maybe</a> <tt>a</tt> is <tt>Just a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   
--   &gt;&gt;&gt; isJust (Just "plutus")
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | Check if a <a>Maybe</a> <tt>a</tt> is <tt>Nothing</tt>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   
--   &gt;&gt;&gt; isNothing (Just "plutus")
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | Plutus Tx version of <a>maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maybe "platypus" (\s -&gt; s) (Just "plutus")
--   "plutus"
--   
--   &gt;&gt;&gt; maybe "platypus" (\s -&gt; s) Nothing
--   "platypus"
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | Plutus Tx version of <a>fromMaybe</a>
fromMaybe :: a -> Maybe a -> a

-- | Plutus Tx version of <a>mapMaybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe (\i -&gt; if i == 2 then Just '2' else Nothing) [1, 2, 3, 4]
--   "2"
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

module PlutusTx.Monoid

-- | Plutus Tx version of <a>Monoid</a>.
class Semigroup a => Monoid a

-- | Plutus Tx version of <a>mempty</a>.
mempty :: Monoid a => a

-- | Plutus Tx version of <a>mappend</a>.
mappend :: Monoid a => a -> a -> a

-- | Plutus Tx version of <a>mconcat</a>.
mconcat :: Monoid a => [a] -> a
class Monoid a => Group a
inv :: Group a => a -> a
gsub :: Group a => a -> a -> a
instance PlutusTx.Monoid.Monoid PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Monoid.Monoid PlutusTx.Builtins.Internal.BuiltinString
instance PlutusTx.Monoid.Monoid [a]
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Monoid.Monoid (GHC.Maybe.Maybe a)
instance PlutusTx.Monoid.Monoid ()
instance (PlutusTx.Monoid.Monoid a, PlutusTx.Monoid.Monoid b) => PlutusTx.Monoid.Monoid (a, b)
instance PlutusTx.Monoid.Monoid a => PlutusTx.Monoid.Monoid (Data.Semigroup.Internal.Dual a)
instance PlutusTx.Monoid.Monoid (Data.Semigroup.Internal.Endo a)
instance PlutusTx.Monoid.Monoid (Data.Monoid.First a)

module PlutusTx.Numeric

-- | A <a>Semigroup</a> that it is sensible to describe using addition.
class AdditiveSemigroup a
(+) :: AdditiveSemigroup a => a -> a -> a
infixl 6 +

-- | A <a>Monoid</a> that it is sensible to describe using addition and
--   zero.
class AdditiveSemigroup a => AdditiveMonoid a
zero :: AdditiveMonoid a => a

-- | A <a>Group</a> that it is sensible to describe using addition, zero,
--   and subtraction.
class AdditiveMonoid a => AdditiveGroup a
(-) :: AdditiveGroup a => a -> a -> a
infixl 6 -

-- | A <a>Semigroup</a> that it is sensible to describe using
--   multiplication.
class MultiplicativeSemigroup a
(*) :: MultiplicativeSemigroup a => a -> a -> a
infixl 7 *

-- | A <a>Semigroup</a> that it is sensible to describe using
--   multiplication and one.
class MultiplicativeSemigroup a => MultiplicativeMonoid a
one :: MultiplicativeMonoid a => a

-- | A semiring.
type Semiring a = (AdditiveMonoid a, MultiplicativeMonoid a)

-- | A ring.
type Ring a = (AdditiveGroup a, MultiplicativeMonoid a)

-- | A module, with a type of scalars which can be used to scale the
--   values.
class (Ring s, AdditiveGroup v) => Module s v | v -> s
scale :: Module s v => s -> v -> v

-- | A newtype wrapper to derive <a>Additive</a> classes via.
newtype Additive a
Additive :: a -> Additive a

-- | A newtype wrapper to derive <a>Multiplicative</a> classes via.
newtype Multiplicative a
Multiplicative :: a -> Multiplicative a
negate :: AdditiveGroup a => a -> a

-- | Simultaneous div and mod.
divMod :: Integer -> Integer -> (Integer, Integer)

-- | Simultaneous quot and rem.
quotRem :: Integer -> Integer -> (Integer, Integer)

-- | Absolute value for any <a>AdditiveGroup</a>.
abs :: (Ord n, AdditiveGroup n) => n -> n
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Numeric.MultiplicativeSemigroup (PlutusTx.Numeric.Multiplicative a)
instance PlutusTx.Monoid.Monoid a => PlutusTx.Numeric.MultiplicativeMonoid (PlutusTx.Numeric.Multiplicative a)
instance PlutusTx.Numeric.MultiplicativeMonoid GHC.Integer.Type.Integer
instance PlutusTx.Numeric.MultiplicativeMonoid GHC.Types.Bool
instance PlutusTx.Numeric.MultiplicativeMonoid a => PlutusTx.Monoid.Monoid (Data.Semigroup.Internal.Product a)
instance PlutusTx.Numeric.MultiplicativeSemigroup GHC.Integer.Type.Integer
instance PlutusTx.Numeric.MultiplicativeSemigroup GHC.Types.Bool
instance PlutusTx.Numeric.MultiplicativeSemigroup a => PlutusTx.Semigroup.Semigroup (Data.Semigroup.Internal.Product a)
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Numeric.AdditiveSemigroup (PlutusTx.Numeric.Additive a)
instance PlutusTx.Monoid.Monoid a => PlutusTx.Numeric.AdditiveMonoid (PlutusTx.Numeric.Additive a)
instance PlutusTx.Monoid.Group a => PlutusTx.Numeric.AdditiveGroup (PlutusTx.Numeric.Additive a)
instance PlutusTx.Numeric.AdditiveGroup GHC.Integer.Type.Integer
instance PlutusTx.Numeric.AdditiveMonoid GHC.Integer.Type.Integer
instance PlutusTx.Numeric.AdditiveMonoid GHC.Types.Bool
instance PlutusTx.Numeric.AdditiveMonoid a => PlutusTx.Monoid.Monoid (Data.Semigroup.Internal.Sum a)
instance PlutusTx.Numeric.AdditiveSemigroup GHC.Integer.Type.Integer
instance PlutusTx.Numeric.AdditiveSemigroup GHC.Types.Bool
instance PlutusTx.Numeric.AdditiveSemigroup a => PlutusTx.Semigroup.Semigroup (Data.Semigroup.Internal.Sum a)

module PlutusTx.Lattice

-- | A join semi-lattice, i.e. a partially ordered set equipped with a
--   binary operation <a>(\/)</a>.
--   
--   Note that the mathematical definition would require an ordering
--   constraint - we omit that so we can define instances for e.g.
--   <tt>(-&gt;)</tt>.
class JoinSemiLattice a
(\/) :: JoinSemiLattice a => a -> a -> a

-- | A meet semi-lattice, i.e. a partially ordered set equipped with a
--   binary operation <a>(/\)</a>.
--   
--   Note that the mathematical definition would require an ordering
--   constraint - we omit that so we can define instances for e.g.
--   <tt>(-&gt;)</tt>.
class MeetSemiLattice a
(/\) :: MeetSemiLattice a => a -> a -> a

-- | A lattice.
type Lattice a = (JoinSemiLattice a, MeetSemiLattice a)

-- | A bounded join semi-lattice, i.e. a join semi-lattice augmented with a
--   distinguished element <a>bottom</a> which is the unit of <a>(\/)</a>.
class JoinSemiLattice a => BoundedJoinSemiLattice a
bottom :: BoundedJoinSemiLattice a => a

-- | A bounded meet semi-lattice, i.e. a meet semi-lattice augmented with a
--   distinguished element <a>top</a> which is the unit of <a>(/\)</a>.
class MeetSemiLattice a => BoundedMeetSemiLattice a
top :: BoundedMeetSemiLattice a => a

-- | A bounded lattice.
type BoundedLattice a = (BoundedJoinSemiLattice a, BoundedMeetSemiLattice a)

-- | A wrapper witnessing that a join semi-lattice is a monoid with
--   <a>(\/)</a> and <a>bottom</a>.
newtype Join a
Join :: a -> Join a

-- | A wrapper witnessing that a meet semi-lattice is a monoid with
--   <a>(/\)</a> and <a>top</a>.
newtype Meet a
Meet :: a -> Meet a
instance PlutusTx.Lattice.MeetSemiLattice a => PlutusTx.Semigroup.Semigroup (PlutusTx.Lattice.Meet a)
instance PlutusTx.Lattice.BoundedMeetSemiLattice a => PlutusTx.Monoid.Monoid (PlutusTx.Lattice.Meet a)
instance PlutusTx.Lattice.JoinSemiLattice a => PlutusTx.Semigroup.Semigroup (PlutusTx.Lattice.Join a)
instance PlutusTx.Lattice.BoundedJoinSemiLattice a => PlutusTx.Monoid.Monoid (PlutusTx.Lattice.Join a)
instance PlutusTx.Lattice.BoundedMeetSemiLattice GHC.Types.Bool
instance (PlutusTx.Lattice.BoundedMeetSemiLattice a, PlutusTx.Lattice.BoundedMeetSemiLattice b) => PlutusTx.Lattice.BoundedMeetSemiLattice (a, b)
instance PlutusTx.Lattice.BoundedMeetSemiLattice b => PlutusTx.Lattice.BoundedMeetSemiLattice (a -> b)
instance PlutusTx.Lattice.BoundedJoinSemiLattice GHC.Types.Bool
instance (PlutusTx.Lattice.BoundedJoinSemiLattice a, PlutusTx.Lattice.BoundedJoinSemiLattice b) => PlutusTx.Lattice.BoundedJoinSemiLattice (a, b)
instance PlutusTx.Lattice.BoundedJoinSemiLattice b => PlutusTx.Lattice.BoundedJoinSemiLattice (a -> b)
instance PlutusTx.Lattice.MeetSemiLattice GHC.Types.Bool
instance (PlutusTx.Lattice.MeetSemiLattice a, PlutusTx.Lattice.MeetSemiLattice b) => PlutusTx.Lattice.MeetSemiLattice (a, b)
instance PlutusTx.Lattice.MeetSemiLattice b => PlutusTx.Lattice.MeetSemiLattice (a -> b)
instance PlutusTx.Lattice.JoinSemiLattice GHC.Types.Bool
instance (PlutusTx.Lattice.JoinSemiLattice a, PlutusTx.Lattice.JoinSemiLattice b) => PlutusTx.Lattice.JoinSemiLattice (a, b)
instance PlutusTx.Lattice.JoinSemiLattice b => PlutusTx.Lattice.JoinSemiLattice (a -> b)

module PlutusTx.Applicative

-- | Plutus Tx version of <a>Applicative</a>.
class Functor f => Applicative f

-- | Plutus Tx version of <a>pure</a>.
pure :: Applicative f => a -> f a

-- | Plutus Tx version of <a>(&lt;*&gt;)</a>.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
infixl 4 <*>

-- | Plutus Tx version of <a>liftA2</a>.
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Plutus Tx version of <a>(*&gt;)</a>.
(*>) :: Applicative f => f a -> f b -> f b
infixl 4 *>

-- | Plutus Tx version of <a>(&lt;*)</a>.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*

-- | Plutus Tx version of <a>unless</a>.
unless :: Applicative f => Bool -> f () -> f ()
instance PlutusTx.Applicative.Applicative GHC.Maybe.Maybe
instance PlutusTx.Applicative.Applicative (Data.Either.Either a)
instance PlutusTx.Applicative.Applicative Data.Functor.Identity.Identity
instance PlutusTx.Monoid.Monoid m => PlutusTx.Applicative.Applicative (Data.Functor.Const.Const m)

module PlutusTx.IsData.Class

-- | A typeclass for types that can be converted to and from
--   <a>BuiltinData</a>.
class ToData (a :: Type)

-- | Convert a value to <a>BuiltinData</a>.
toBuiltinData :: ToData a => a -> BuiltinData
class FromData (a :: Type)

-- | Convert a value from <a>BuiltinData</a>, returning <a>Nothing</a> if
--   this fails.
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class UnsafeFromData (a :: Type)

-- | Convert a value from <a>BuiltinData</a>, calling <a>error</a> if this
--   fails. This is typically much faster than <a>fromBuiltinData</a>.
--   
--   When implementing this function, make sure to call
--   <a>unsafeFromBuiltinData</a> rather than <a>fromBuiltinData</a> when
--   converting substructures!
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a

-- | Convert a value to <a>Data</a>.
toData :: ToData a => a -> Data

-- | Convert a value from <a>Data</a>, returning <a>Nothing</a> if this
--   fails.
fromData :: FromData a => Data -> Maybe a
instance PlutusTx.IsData.Class.UnsafeFromData PlutusTx.Builtins.Internal.BuiltinData
instance (TypeError ...) => PlutusTx.IsData.Class.UnsafeFromData GHC.Types.Int
instance PlutusTx.IsData.Class.UnsafeFromData GHC.Integer.Type.Integer
instance PlutusTx.IsData.Class.UnsafeFromData PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData [a]
instance PlutusTx.IsData.Class.UnsafeFromData Data.Void.Void
instance PlutusTx.IsData.Class.FromData PlutusTx.Builtins.Internal.BuiltinData
instance (TypeError ...) => PlutusTx.IsData.Class.FromData GHC.Types.Int
instance PlutusTx.IsData.Class.FromData GHC.Integer.Type.Integer
instance PlutusTx.IsData.Class.FromData PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData [a]
instance PlutusTx.IsData.Class.FromData Data.Void.Void
instance PlutusTx.IsData.Class.ToData PlutusTx.Builtins.Internal.BuiltinData
instance (TypeError ...) => PlutusTx.IsData.Class.ToData GHC.Types.Int
instance PlutusTx.IsData.Class.ToData GHC.Integer.Type.Integer
instance PlutusTx.IsData.Class.ToData PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData [a]
instance PlutusTx.IsData.Class.ToData Data.Void.Void

module PlutusTx.IsData

-- | Generate a <a>FromData</a> and a <a>ToData</a> instance for a type.
--   This may not be stable in the face of constructor additions,
--   renamings, etc. Use <a>makeIsDataIndexed</a> if you need stability.
unstableMakeIsData :: Name -> Q [Dec]

-- | Generate a <a>FromData</a> and a <a>ToData</a> instance for a type,
--   using an explicit mapping of constructor names to indices. Use this
--   for types where you need to keep the representation stable.
makeIsDataIndexed :: Name -> [(Name, Int)] -> Q [Dec]

module PlutusTx.Ratio

-- | Represents an arbitrary-precision ratio.
data Rational

-- | Makes a <a>Rational</a> from a numerator and a denominator.
--   
--   <h1>Important note</h1>
--   
--   If given a zero denominator, this function will error. If you don't
--   mind a size increase, and care about safety, use <a>ratio</a> instead.
unsafeRatio :: Integer -> Integer -> Rational

-- | Converts an <a>Integer</a> into the equivalent <a>Rational</a>.
fromInteger :: Integer -> Rational

-- | Safely constructs a <a>Rational</a> from a numerator and a
--   denominator. Returns <tt>Nothing</tt> if given a zero denominator.
ratio :: Integer -> Integer -> Maybe Rational

-- | Returns the numerator of its argument.
--   
--   <h1>Note</h1>
--   
--   It is <i>not</i> true in general that <tt><a>numerator</a>
--   <tt>&lt;$&gt;</tt> <a>ratio</a> x y = x</tt>; this will only hold if
--   <tt>x</tt> and <tt>y</tt> are coprime. This is due to <a>Rational</a>
--   normalizing the numerator and denominator.
numerator :: Rational -> Integer

-- | Returns the denominator of its argument. This will always be greater
--   than, or equal to, 1, although the type does not describe this.
--   
--   <h1>Note</h1>
--   
--   It is <i>not</i> true in general that <tt><a>denominator</a>
--   <tt>&lt;$&gt;</tt> <a>ratio</a> x y = y</tt>; this will only hold if
--   <tt>x</tt> and <tt>y</tt> are coprime. This is due to <a>Rational</a>
--   normalizing the numerator and denominator.
denominator :: Rational -> Integer

-- | <tt><a>round</a> r</tt> returns the nearest <a>Integer</a> value to
--   <tt>r</tt>. If <tt>r</tt> is equidistant between two values, the even
--   value will be given.
round :: Rational -> Integer

-- | Returns the whole-number part of its argument, dropping any leftover
--   fractional part. More precisely, <tt><a>truncate</a> r = n</tt> where
--   <tt>(n, _) = <a>properFraction</a> r</tt>, but is much more efficient.
truncate :: Rational -> Integer

-- | <tt><a>properFraction</a> r</tt> returns the pair <tt>(n, f)</tt>,
--   such that all of the following hold:
--   
--   <ul>
--   <li><tt><a>fromInteger</a> n <a>+</a> f = r</tt>;</li>
--   <li><tt>n</tt> and <tt>f</tt> both have the same sign as <tt>r</tt>;
--   and</li>
--   <li><tt><a>abs</a> f <a>&lt;</a> <a>one</a></tt>.</li>
--   </ul>
properFraction :: Rational -> (Integer, Rational)

-- | Gives the reciprocal of the argument; specifically, for <tt>r
--   <a>/=</a> <a>zero</a></tt>, <tt>r <a>*</a> <a>recip</a> r =
--   <a>one</a></tt>.
--   
--   <h1>Important note</h1>
--   
--   The reciprocal of zero is mathematically undefined; thus,
--   <tt><a>recip</a> <a>zero</a></tt> will error. Use with care.
recip :: Rational -> Rational

-- | Returns the absolute value of its argument.
--   
--   <h1>Note</h1>
--   
--   This is specialized for <a>Rational</a>; use this instead of the
--   generic version in <tt>PlutusTx.Numeric</tt>, as said generic version
--   produces much larger on-chain code than the specialized version here.
abs :: Rational -> Rational

-- | Produces the additive inverse of its argument.
--   
--   <h1>Note</h1>
--   
--   This is specialized for <a>Rational</a>; use this instead of the
--   generic version of this function, as it is significantly smaller
--   on-chain.
negate :: Rational -> Rational

-- | <ol>
--   <li>5</li>
--   </ol>
half :: Rational

-- | Converts a GHC <a>Rational</a>, preserving value. Does not work
--   on-chain.
fromGHC :: Rational -> Rational

-- | Converts a <a>Rational</a> to a GHC <a>Rational</a>, preserving value.
--   Does not work on-chain.
toGHC :: Rational -> Rational

-- | Given a numerator and denominator, produces a <a>Rational</a> by
--   dividing both numerator and denominator by their greatest common
--   divisor.
reduce :: Integer -> Integer -> Rational

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>.
gcd :: Integer -> Integer -> Integer
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusTx.Ratio.Rational
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusTx.Ratio.Rational
instance GHC.Show.Show PlutusTx.Ratio.Rational
instance GHC.Classes.Eq PlutusTx.Ratio.Rational
instance PlutusTx.Eq.Eq PlutusTx.Ratio.Rational
instance PlutusTx.Ord.Ord PlutusTx.Ratio.Rational
instance GHC.Classes.Ord PlutusTx.Ratio.Rational
instance PlutusTx.Numeric.AdditiveSemigroup PlutusTx.Ratio.Rational
instance PlutusTx.Numeric.AdditiveMonoid PlutusTx.Ratio.Rational
instance PlutusTx.Numeric.AdditiveGroup PlutusTx.Ratio.Rational
instance PlutusTx.Numeric.MultiplicativeSemigroup PlutusTx.Ratio.Rational
instance PlutusTx.Numeric.MultiplicativeMonoid PlutusTx.Ratio.Rational
instance PlutusTx.Numeric.Module GHC.Integer.Type.Integer PlutusTx.Ratio.Rational
instance PlutusTx.IsData.Class.ToData PlutusTx.Ratio.Rational
instance PlutusTx.IsData.Class.FromData PlutusTx.Ratio.Rational
instance PlutusTx.IsData.Class.UnsafeFromData PlutusTx.Ratio.Rational
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Ratio.Rational
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Ratio.Rational

module PlutusTx.Foldable

-- | Plutus Tx version of <a>Foldable</a>.
class Foldable t

-- | Plutus Tx version of <a>foldMap</a>.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Plutus Tx version of <a>foldrM</a>.
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | Plutus Tx version of <a>foldlM</a>.
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Plutus Tx version of <a>traverse_</a>.
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | Plutus Tx version of <a>for_</a>.
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Plutus Tx version of <a>sequenceA_</a>.
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | Plutus Tx version of <a>sequence_</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Plutus Tx version of <a>asum</a>.
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Plutus Tx version of <a>mapM_</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | Plutus Tx version of <a>concat</a>.
concat :: Foldable t => t [a] -> [a]

-- | Plutus Tx version of <a>concatMap</a>.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | Plutus Tx version of <a>and</a>.
and :: Foldable t => t Bool -> Bool

-- | Plutus Tx version of <a>or</a>.
or :: Foldable t => t Bool -> Bool

-- | Plutus Tx version of <a>any</a>.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Plutus Tx version of <a>all</a>.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Plutus Tx version of <a>notElem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | Plutus Tx version of <a>find</a>.
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

-- | Plutus Tx version of <a>fold</a>.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Plutus Tx version of <a>foldr</a>.
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Plutus Tx version of <a>foldl</a>.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Plutus Tx version of <a>toList</a>.
toList :: Foldable t => t a -> [a]

-- | Plutus Tx version of <a>null</a>.
null :: Foldable t => t a -> Bool

-- | Plutus Tx version of <a>length</a>.
length :: Foldable t => t a -> Integer

-- | Plutus Tx version of <a>elem</a>.
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | Plutus Tx version of <a>sum</a>.
sum :: (Foldable t, AdditiveMonoid a) => t a -> a

-- | Plutus Tx version of <a>product</a>.
product :: (Foldable t, MultiplicativeMonoid a) => t a -> a
instance PlutusTx.Foldable.Foldable []
instance PlutusTx.Foldable.Foldable GHC.Maybe.Maybe
instance PlutusTx.Foldable.Foldable (Data.Either.Either c)
instance PlutusTx.Foldable.Foldable ((,) c)
instance PlutusTx.Foldable.Foldable Data.Functor.Identity.Identity
instance PlutusTx.Foldable.Foldable (Data.Functor.Const.Const c)

module PlutusTx.Traversable

-- | Plutus Tx version of <a>Traversable</a>.
class (Functor t, Foldable t) => Traversable t

-- | Plutus Tx version of <a>traverse</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Plutus Tx version of <a>sequenceA</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Plutus Tx version of <a>mapM</a>.
mapM :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Plutus Tx version of <a>sequence</a>.
sequence :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Plutus Tx version of <a>for</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | Plutus Tx version of <a>fmapDefault</a>.
fmapDefault :: forall t a b. Traversable t => (a -> b) -> t a -> t b

-- | Plutus Tx version of <a>foldMapDefault</a>.
foldMapDefault :: forall t m a. (Traversable t, Monoid m) => (a -> m) -> t a -> m
instance PlutusTx.Traversable.Traversable []
instance PlutusTx.Traversable.Traversable GHC.Maybe.Maybe
instance PlutusTx.Traversable.Traversable (Data.Either.Either c)
instance PlutusTx.Traversable.Traversable ((,) c)
instance PlutusTx.Traversable.Traversable Data.Functor.Identity.Identity
instance PlutusTx.Traversable.Traversable (Data.Functor.Const.Const c)

module PlutusTx.Enum

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Integer</a>.
toEnum :: Enum a => Integer -> a

-- | Convert to an <a>Integer</a>.
fromEnum :: Enum a => a -> Integer
instance PlutusTx.Enum.Enum GHC.Integer.Type.Integer
instance PlutusTx.Enum.Enum ()
instance PlutusTx.Enum.Enum GHC.Types.Bool
instance PlutusTx.Enum.Enum GHC.Types.Ordering

module PlutusTx.Prelude

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b
infixl 1 >>=

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b
infixl 1 >>

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
data BuiltinString

-- | Append two <tt>String</tt>s.
appendString :: BuiltinString -> BuiltinString -> BuiltinString

-- | An empty <tt>String</tt>.
emptyString :: BuiltinString

-- | Check if two strings are equal
equalsString :: BuiltinString -> BuiltinString -> Bool

-- | Convert a String into a ByteString.
encodeUtf8 :: BuiltinString -> BuiltinByteString

-- | Aborts evaluation with an error.
error :: () -> a

-- | Checks a <a>Bool</a> and aborts if it is false.
check :: Bool -> ()

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   For more information about this type's representation, see the
--   comments in its implementation.
data Integer

-- | Integer division, rounding downwards
--   
--   <pre>
--   &gt;&gt;&gt; divide (-41) 5
--   -9
--   </pre>
divide :: Integer -> Integer -> Integer

-- | Integer remainder, always positive for a positive divisor
--   
--   <pre>
--   &gt;&gt;&gt; modulo (-41) 5
--   4
--   </pre>
modulo :: Integer -> Integer -> Integer

-- | Integer division, rouding towards zero
--   
--   <pre>
--   &gt;&gt;&gt; quotient (-41) 5
--   -8
--   </pre>
quotient :: Integer -> Integer -> Integer

-- | Integer remainder, same sign as dividend
--   
--   <pre>
--   &gt;&gt;&gt; remainder (-41) 5
--   -1
--   </pre>
remainder :: Integer -> Integer -> Integer
even :: Integer -> Bool

-- | Plutus Tx version of <a>map</a>.
--   
--   <pre>
--   &gt;&gt;&gt; map (\i -&gt; i + 1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Plutus Tx version of <a>(++)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0, 1, 2] ++ [1, 2, 3, 4]
--   [0,1,2,1,2,3,4]
--   </pre>
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | Plutus Tx version of <a>filter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; filter (&gt; 1) [1, 2, 3, 4]
--   [2,3,4]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>listToMaybe</a>.
listToMaybe :: [a] -> Maybe a

-- | Return the element in the list, if there is precisely one.
uniqueElement :: [a] -> Maybe a

-- | Plutus Tx version of <a>findIndices</a>.
findIndices :: (a -> Bool) -> [a] -> [Integer]

-- | Plutus Tx version of <a>findIndex</a>.
findIndex :: (a -> Bool) -> [a] -> Maybe Integer

-- | Plutus Tx version of <a>(!!)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [10, 11, 12] !! 2
--   12
--   </pre>
(!!) :: [a] -> Integer -> a
infixl 9 !!

-- | Plutus Tx version of <a>reverse</a>.
reverse :: [a] -> [a]

-- | Plutus Tx version of <a>zip</a>.
zip :: [a] -> [b] -> [(a, b)]

-- | Plutus Tx version of <a>head</a>.
head :: [a] -> a

-- | Plutus Tx version of <a>tail</a>.
tail :: [a] -> [a]

-- | Plutus Tx version of <a>take</a>.
take :: Integer -> [a] -> [a]

-- | Plutus Tx version of <a>nub</a>.
nub :: Eq a => [a] -> [a]

-- | Plutus Tx version of <a>nubBy</a>.
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>zipWith</a>.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | Plutus Tx version of <a>dropWhile</a>.
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>partition</a>.
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | Plutus Tx version of <a>sort</a>.
sort :: Ord a => [a] -> [a]

-- | Plutus Tx version of <a>sortBy</a>.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | An opaque type representing Plutus Core ByteStrings.
data BuiltinByteString

-- | Concatenates two <tt>ByteString</tt>s.
appendByteString :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString

-- | Adds a byte to the front of a <tt>ByteString</tt>.
consByteString :: Integer -> BuiltinByteString -> BuiltinByteString

-- | Returns the n length prefix of a <tt>ByteString</tt>.
takeByteString :: Integer -> BuiltinByteString -> BuiltinByteString

-- | Returns the suffix of a <tt>ByteString</tt> after n elements.
dropByteString :: Integer -> BuiltinByteString -> BuiltinByteString

-- | Returns the substring of a <tt>ByteString</tt> from index
--   <tt>start</tt> of length <tt>n</tt>.
sliceByteString :: Integer -> Integer -> BuiltinByteString -> BuiltinByteString

-- | Returns the length of a <tt>ByteString</tt>.
lengthOfByteString :: BuiltinByteString -> Integer

-- | Returns the byte of a <tt>ByteString</tt> at index.
indexByteString :: BuiltinByteString -> Integer -> Integer

-- | An empty <tt>ByteString</tt>.
emptyByteString :: BuiltinByteString

-- | Converts a ByteString to a String.
decodeUtf8 :: BuiltinByteString -> BuiltinString

-- | The SHA2-256 hash of a <tt>ByteString</tt>
sha2_256 :: BuiltinByteString -> BuiltinByteString

-- | The SHA3-256 hash of a <tt>ByteString</tt>
sha3_256 :: BuiltinByteString -> BuiltinByteString

-- | Ed25519 signature verification. Verify that the signature is a
--   signature of the message by the public key. This will fail if key or
--   the signature are not of the expected length.
verifyEd25519Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> Bool

-- | Given an ECDSA SECP256k1 verification key, an ECDSA SECP256k1
--   signature, and an ECDSA SECP256k1 message hash (all as
--   <a>BuiltinByteString</a>s), verify the hash with that key and
--   signature.
--   
--   <h1>Important note</h1>
--   
--   The verification key, the signature, and the message hash must all be
--   of appropriate form and length. This function will error if any of
--   these are not the case.
verifyEcdsaSecp256k1Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> Bool

-- | Given a Schnorr SECP256k1 verification key, a Schnorr SECP256k1
--   signature, and a message (all as <a>BuiltinByteString</a>s), verify
--   the message with that key and signature.
--   
--   <h1>Important note</h1>
--   
--   The verification key and signature must all be of appropriate form and
--   length. This function will error if this is not the case.
verifySchnorrSecp256k1Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> Bool

-- | Represents an arbitrary-precision ratio.
data Rational

-- | Makes a <a>Rational</a> from a numerator and a denominator.
--   
--   <h1>Important note</h1>
--   
--   If given a zero denominator, this function will error. If you don't
--   mind a size increase, and care about safety, use <a>ratio</a> instead.
unsafeRatio :: Integer -> Integer -> Rational

-- | Safely constructs a <a>Rational</a> from a numerator and a
--   denominator. Returns <tt>Nothing</tt> if given a zero denominator.
ratio :: Integer -> Integer -> Maybe Rational

-- | Converts an <a>Integer</a> into the equivalent <a>Rational</a>.
fromInteger :: Integer -> Rational

-- | <tt><a>round</a> r</tt> returns the nearest <a>Integer</a> value to
--   <tt>r</tt>. If <tt>r</tt> is equidistant between two values, the even
--   value will be given.
round :: Rational -> Integer

-- | A type corresponding to the Plutus Core builtin equivalent of
--   <a>Data</a>.
--   
--   The point of this type is to be an opaque equivalent of <a>Data</a>,
--   so as to ensure that it is only used in ways that the compiler can
--   handle.
--   
--   As such, you should use this type in your on-chain code, and in any
--   data structures that you want to be representable on-chain.
--   
--   For off-chain usage, there are conversion functions
--   <a>builtinDataToData</a> and <a>dataToBuiltinData</a>, but note that
--   these will not work on-chain.
data BuiltinData
fromBuiltin :: FromBuiltin arep a => arep -> a
toBuiltin :: ToBuiltin a arep => a -> arep

module PlutusTx.Sqrt

-- | Integer square-root representation, discarding imaginary integers.
data Sqrt

-- | The number was negative, so we don't even attempt to compute it; just
--   note that the result would be imaginary.
Imaginary :: Sqrt

-- | An exact integer result. The <a>rsqrt</a> of 4 is 'Exactly 2'.
Exactly :: Integer -> Sqrt

-- | The Integer component (i.e. the floor) of a non-integral result. The
--   'rsqrt 2' is 'Approximately 1'.
Approximately :: Integer -> Sqrt

-- | Calculates the sqrt of a ratio of integers. As x / 0 is undefined,
--   calling this function with `d=0` results in an error.
rsqrt :: Rational -> Sqrt

-- | Calculates the integer-component of the sqrt of <tt>n</tt>.
isqrt :: Integer -> Sqrt
instance PlutusTx.IsData.Class.ToData PlutusTx.Sqrt.Sqrt
instance PlutusTx.IsData.Class.FromData PlutusTx.Sqrt.Sqrt
instance PlutusTx.IsData.Class.UnsafeFromData PlutusTx.Sqrt.Sqrt
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusTx.Sqrt.Sqrt
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusTx.Sqrt.Sqrt
instance GHC.Classes.Eq PlutusTx.Sqrt.Sqrt
instance GHC.Show.Show PlutusTx.Sqrt.Sqrt

module PlutusTx

-- | <a>CompiledCodeIn</a> instantiated with default built-in types and
--   functions.
type CompiledCode = CompiledCodeIn DefaultUni DefaultFun

-- | A compiled Plutus Tx program. The last type parameter indicates the
--   type of the Haskell expression that was compiled, and hence the type
--   of the compiled code.
--   
--   Note: the compiled PLC program does *not* have normalized types, if
--   you want to put it on the chain you must normalize the types first.
data CompiledCodeIn uni fun a

-- | Get the actual Plutus Core program out of a <a>CompiledCodeIn</a>.
getPlc :: (Closed uni, uni `Everywhere` Flat, Flat fun, uni `Everywhere` PrettyConst, GShow uni, Pretty fun) => CompiledCodeIn uni fun a -> Program NamedDeBruijn uni fun ()

-- | Get the Plutus IR program, if there is one, out of a
--   <a>CompiledCodeIn</a>.
getPir :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Maybe (Program TyName Name uni fun ())

-- | Apply a compiled function to a compiled argument.
applyCode :: (Closed uni, uni `Everywhere` Flat, Flat fun, uni `Everywhere` PrettyConst, GShow uni, Pretty fun) => CompiledCodeIn uni fun (a -> b) -> CompiledCodeIn uni fun a -> CompiledCodeIn uni fun b

-- | A type corresponding to the Plutus Core builtin equivalent of
--   <a>Data</a>.
--   
--   The point of this type is to be an opaque equivalent of <a>Data</a>,
--   so as to ensure that it is only used in ways that the compiler can
--   handle.
--   
--   As such, you should use this type in your on-chain code, and in any
--   data structures that you want to be representable on-chain.
--   
--   For off-chain usage, there are conversion functions
--   <a>builtinDataToData</a> and <a>dataToBuiltinData</a>, but note that
--   these will not work on-chain.
data BuiltinData

-- | A generic "data" type.
--   
--   The main constructor <a>Constr</a> represents a datatype value in
--   sum-of-products form: <tt>Constr i args</tt> represents a use of the
--   <tt>i</tt>th constructor along with its arguments.
--   
--   The other constructors are various primitives.
data Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data

-- | A typeclass for types that can be converted to and from
--   <a>BuiltinData</a>.
class ToData (a :: Type)

-- | Convert a value to <a>BuiltinData</a>.
toBuiltinData :: ToData a => a -> BuiltinData
class FromData (a :: Type)

-- | Convert a value from <a>BuiltinData</a>, returning <a>Nothing</a> if
--   this fails.
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class UnsafeFromData (a :: Type)

-- | Convert a value from <a>BuiltinData</a>, calling <a>error</a> if this
--   fails. This is typically much faster than <a>fromBuiltinData</a>.
--   
--   When implementing this function, make sure to call
--   <a>unsafeFromBuiltinData</a> rather than <a>fromBuiltinData</a> when
--   converting substructures!
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a

-- | Convert a value to <a>Data</a>.
toData :: ToData a => a -> Data

-- | Convert a value from <a>Data</a>, returning <a>Nothing</a> if this
--   fails.
fromData :: FromData a => Data -> Maybe a

-- | Convert a <a>BuiltinData</a> into a <a>Data</a>. Only works off-chain.
builtinDataToData :: BuiltinData -> Data

-- | Convert a <a>Data</a> into a <a>BuiltinData</a>. Only works off-chain.
dataToBuiltinData :: Data -> BuiltinData

-- | Generate a <a>FromData</a> and a <a>ToData</a> instance for a type.
--   This may not be stable in the face of constructor additions,
--   renamings, etc. Use <a>makeIsDataIndexed</a> if you need stability.
unstableMakeIsData :: Name -> Q [Dec]

-- | Generate a <a>FromData</a> and a <a>ToData</a> instance for a type,
--   using an explicit mapping of constructor names to indices. Use this
--   for types where you need to keep the representation stable.
makeIsDataIndexed :: Name -> [(Name, Int)] -> Q [Dec]

-- | Class for types which can be lifted into Plutus IR. Instances should
--   be derived, do not write your own instance!
class Lift uni a

-- | Class for types which have a corresponding Plutus IR type. Instances
--   should always be derived, do not write your own instance!
class Typeable uni (a :: k)
makeLift :: Name -> Q [Dec]
safeLiftCode :: (Lift uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), GEq uni, AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, Typecheckable uni fun, PrettyPrintable uni fun) => a -> m (CompiledCodeIn uni fun a)

-- | Get a Plutus Core program corresponding to the given value as a
--   <a>CompiledCodeIn</a>, throwing any errors that occur as exceptions
--   and ignoring fresh names.
liftCode :: (Lift uni a, Throwable uni fun, Typecheckable uni fun) => a -> CompiledCodeIn uni fun a


-- | A map represented as an "association list" of key-value pairs.
module PlutusTx.AssocMap

-- | A <a>Map</a> of key-value pairs.
data Map k v

-- | A singleton map.
singleton :: k -> v -> Map k v

-- | An empty <a>Map</a>.
empty :: Map k v

-- | Is the map empty?
null :: Map k v -> Bool
fromList :: [(k, v)] -> Map k v
toList :: Map k v -> [(k, v)]

-- | The keys of a <a>Map</a>.
keys :: Map k v -> [k]

-- | Return all elements of the map in the ascending order of their keys.
elems :: Map k v -> [v]

-- | Find an entry in a <a>Map</a>.
lookup :: forall k v. Eq k => k -> Map k v -> Maybe v

-- | Is the key a member of the map?
member :: forall k v. Eq k => k -> Map k v -> Bool
insert :: forall k v. Eq k => k -> v -> Map k v -> Map k v
delete :: forall k v. Eq k => k -> Map k v -> Map k v

-- | Combine two <a>Map</a>s.
union :: forall k v r. Eq k => Map k v -> Map k r -> Map k (These v r)

-- | Combine two <a>Map</a>s with the given combination function.
unionWith :: forall k a. Eq k => (a -> a -> a) -> Map k a -> Map k a -> Map k a

-- | Filter all values that satisfy the predicate.
filter :: (v -> Bool) -> Map k v -> Map k v

-- | Map a function over all values in the map.
mapWithKey :: (k -> a -> b) -> Map k a -> Map k b

-- | Map keys/values and collect the <a>Just</a> results.
mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b

-- | Map keys/values and collect the <a>Just</a> results.
mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b

-- | Plutus Tx version of <a>all</a>.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | A version of <a>mapEither</a> that works with <a>These</a>.
mapThese :: (v -> These a b) -> Map k v -> (Map k a, Map k b)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusTx.AssocMap.Map
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni [(k, v)] => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusTx.AssocMap.Map k v)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.Ord.Ord k, PlutusTx.Ord.Ord v) => PlutusTx.Ord.Ord (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.Eq.Eq k, PlutusTx.Eq.Eq v) => PlutusTx.Eq.Eq (PlutusTx.AssocMap.Map k v)
instance (Data.Data.Data k, Data.Data.Data v) => Data.Data.Data (PlutusTx.AssocMap.Map k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (PlutusTx.AssocMap.Map k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (PlutusTx.AssocMap.Map k v)
instance GHC.Generics.Generic (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.IsData.Class.ToData k, PlutusTx.IsData.Class.ToData v) => PlutusTx.IsData.Class.ToData (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.IsData.Class.FromData k, PlutusTx.IsData.Class.FromData v) => PlutusTx.IsData.Class.FromData (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.IsData.Class.UnsafeFromData k, PlutusTx.IsData.Class.UnsafeFromData v) => PlutusTx.IsData.Class.UnsafeFromData (PlutusTx.AssocMap.Map k v)
instance PlutusTx.Functor.Functor (PlutusTx.AssocMap.Map k)
instance PlutusTx.Foldable.Foldable (PlutusTx.AssocMap.Map k)
instance PlutusTx.Traversable.Traversable (PlutusTx.AssocMap.Map k)
instance (PlutusTx.Eq.Eq k, PlutusTx.Semigroup.Semigroup v) => PlutusTx.Semigroup.Semigroup (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.Eq.Eq k, PlutusTx.Semigroup.Semigroup v) => PlutusTx.Monoid.Monoid (PlutusTx.AssocMap.Map k v)
instance (Prettyprinter.Internal.Pretty k, Prettyprinter.Internal.Pretty v) => Prettyprinter.Internal.Pretty (PlutusTx.AssocMap.Map k v)

-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Collection of smart contracts to develop the plutus/wallet interface
--   
--   Collection of smart contracts to develop the plutus/wallet interface.
@package plutus-use-cases
@version 1.1.0.0

module Plutus.Contracts

module Plutus.Contracts.Auction

-- | The states of the auction
data AuctionState
Ongoing :: HighestBid -> AuctionState
Finished :: HighestBid -> AuctionState

-- | Transition between auction states
data AuctionInput
Bid :: Ada -> Address -> AuctionInput
[newBid] :: AuctionInput -> Ada
[newBidder] :: AuctionInput -> Address
Payout :: AuctionInput
type BuyerSchema = Endpoint "bid" Ada
type SellerSchema = EmptySchema

-- | Definition of an auction
data AuctionParams
AuctionParams :: Address -> Value -> POSIXTime -> AuctionParams

-- | Current owner of the asset. This is where the proceeds of the auction
--   will be sent.
[apOwner] :: AuctionParams -> Address

-- | The asset itself. This value is going to be locked by the auction
--   script output.
[apAsset] :: AuctionParams -> Value

-- | When the time window for bidding ends.
[apEndTime] :: AuctionParams -> POSIXTime
data HighestBid
HighestBid :: Ada -> Address -> HighestBid
[highestBid] :: HighestBid -> Ada
[highestBidder] :: HighestBid -> Address
auctionBuyer :: ThreadToken -> AuctionParams -> Contract AuctionOutput BuyerSchema AuctionError ()

-- | Client code for the seller
auctionSeller :: Value -> POSIXTime -> Contract AuctionOutput SellerSchema AuctionError ()

-- | Observable state of the auction app
data AuctionOutput
AuctionOutput :: Last AuctionState -> Last ThreadToken -> AuctionOutput
[auctionState] :: AuctionOutput -> Last AuctionState
[auctionThreadToken] :: AuctionOutput -> Last ThreadToken
data AuctionError

-- | State machine operation failed
StateMachineContractError :: SMContractError -> AuctionError

-- | Endpoint, coin selection, etc. failed
AuctionContractError :: ContractError -> AuctionError
data ThreadToken

-- | Create a thread token. The thread token contains a reference to an
--   unspent output of the wallet, so it needs to used with
--   <tt>mkStateMachine</tt> immediately, and the machine must be
--   initialised, to prevent the output from getting spent in the mean
--   time.
getThreadToken :: forall e w (schema :: Row Type). AsSMContractError e => Contract w schema e ThreadToken
covIdx :: CoverageIndex
instance Plutus.Contracts.Auction.AsAuctionError Plutus.Contracts.Auction.AuctionError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.Auction.AuctionError
instance Plutus.Contract.StateMachine.AsSMContractError Plutus.Contracts.Auction.AuctionError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Auction.AuctionLog
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Auction.AuctionLog
instance GHC.Generics.Generic Plutus.Contracts.Auction.AuctionLog
instance GHC.Show.Show Plutus.Contracts.Auction.AuctionLog
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Auction.AuctionError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Auction.AuctionError
instance GHC.Generics.Generic Plutus.Contracts.Auction.AuctionError
instance GHC.Show.Show Plutus.Contracts.Auction.AuctionError
instance GHC.Classes.Eq Plutus.Contracts.Auction.AuctionError
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Auction.AuctionInput
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Auction.AuctionInput
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Auction.AuctionInput
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Auction.AuctionInput
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Auction.AuctionInput
instance GHC.Show.Show Plutus.Contracts.Auction.AuctionInput
instance GHC.Generics.Generic Plutus.Contracts.Auction.AuctionInput
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Auction.AuctionState
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Auction.AuctionState
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Auction.AuctionState
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Auction.AuctionState
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Auction.AuctionState
instance GHC.Classes.Eq Plutus.Contracts.Auction.AuctionState
instance GHC.Show.Show Plutus.Contracts.Auction.AuctionState
instance GHC.Generics.Generic Plutus.Contracts.Auction.AuctionState
instance GHC.Base.Monoid Plutus.Contracts.Auction.AuctionOutput
instance GHC.Base.Semigroup Plutus.Contracts.Auction.AuctionOutput
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Auction.AuctionOutput
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Auction.AuctionOutput
instance GHC.Classes.Eq Plutus.Contracts.Auction.AuctionOutput
instance GHC.Show.Show Plutus.Contracts.Auction.AuctionOutput
instance GHC.Generics.Generic Plutus.Contracts.Auction.AuctionOutput
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Auction.HighestBid
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Auction.HighestBid
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Auction.HighestBid
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Auction.HighestBid
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Auction.HighestBid
instance GHC.Generics.Generic Plutus.Contracts.Auction.HighestBid
instance GHC.Show.Show Plutus.Contracts.Auction.HighestBid
instance GHC.Classes.Eq Plutus.Contracts.Auction.HighestBid
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Auction.AuctionParams
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Auction.AuctionParams
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Auction.AuctionParams
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Auction.AuctionParams
instance GHC.Generics.Generic Plutus.Contracts.Auction.AuctionParams
instance GHC.Show.Show Plutus.Contracts.Auction.AuctionParams
instance GHC.Classes.Eq Plutus.Contracts.Auction.AuctionParams


-- | Crowdfunding contract implemented using the [[Plutus]] interface. This
--   is the fully parallel version that collects all contributions in a
--   single transaction. This is, of course, limited by the maximum number
--   of inputs a transaction can have.
module Plutus.Contracts.Crowdfunding

-- | A crowdfunding campaign.
data Campaign
Campaign :: POSIXTime -> POSIXTime -> PaymentPubKeyHash -> Campaign

-- | The date by which the campaign funds can be contributed.
[campaignDeadline] :: Campaign -> POSIXTime

-- | The date by which the campaign owner has to collect the funds
[campaignCollectionDeadline] :: Campaign -> POSIXTime

-- | Public key of the campaign owner. This key is entitled to retrieve the
--   funds if the campaign is successful.
[campaignOwner] :: Campaign -> PaymentPubKeyHash
type CrowdfundingSchema = Endpoint "schedule collection" () .\/ Endpoint "contribute" Contribution

-- | The crowdfunding contract for the <a>Campaign</a>.
crowdfunding :: Campaign -> Contract () CrowdfundingSchema ContractError ()

-- | A sample campaign
theCampaign :: POSIXTime -> Campaign

-- | The "contribute" branch of the contract for a specific
--   <a>Campaign</a>. Exposes an endpoint that allows the user to enter
--   their public key and the contribution. Then waits until the campaign
--   is over, and collects the refund if the funding was not collected.
contribute :: Campaign -> Promise () CrowdfundingSchema ContractError ()
newtype Contribution
Contribution :: Value -> Contribution

-- | how much to contribute
[contribValue] :: Contribution -> Value

-- | The campaign owner's branch of the contract for a given
--   <a>Campaign</a>. It watches the campaign address for contributions and
--   collects them if the funding goal was reached in time.
scheduleCollection :: Campaign -> Promise () CrowdfundingSchema ContractError ()

-- | The address of a [[Campaign]]
campaignAddress :: Campaign -> ValidatorHash

-- | The validator script that determines whether the campaign owner can
--   retrieve the funds or the contributors can claim a refund.
contributionScript :: Campaign -> Validator

-- | The validator script is of type <tt>CrowdfundingValidator</tt>, and is
--   additionally parameterized by a <a>Campaign</a> definition. This
--   argument is provided by the Plutus client, using <a>applyCode</a>. As
--   a result, the <a>Campaign</a> definition is part of the script
--   address, and different campaigns have different addresses. The
--   Campaign{..} syntax means that all fields of the <a>Campaign</a> value
--   are in scope (for example <a>campaignDeadline</a> in l. 70).
mkValidator :: Campaign -> PaymentPubKeyHash -> CampaignAction -> ScriptContext -> Bool

-- | Construct a <a>Campaign</a> value from the campaign parameters, using
--   the wallet's public key.
mkCampaign :: POSIXTime -> POSIXTime -> Wallet -> Campaign

-- | Action that can be taken by the participants in this contract. A value
--   of <a>CampaignAction</a> is provided as the redeemer. The validator
--   script then checks if the conditions for performing this action are
--   met.
data CampaignAction
Collect :: CampaignAction
Refund :: CampaignAction

-- | The 'ValidityInterval POSIXTime' during which the funds can be
--   collected
collectionRange :: Campaign -> ValidityInterval POSIXTime

-- | The 'ValidityInterval POSIXTime' during which a refund may be claimed
refundRange :: Campaign -> ValidityInterval POSIXTime

-- | Call the "schedule collection" endpoint and instruct the campaign
--   owner's wallet (wallet 1) to start watching the campaign address.
startCampaign :: EmulatorTrace (ContractHandle () CrowdfundingSchema ContractError)

-- | Call the "contribute" endpoint, contributing the amount from the
--   wallet
makeContribution :: Wallet -> Value -> EmulatorTrace ()

-- | Run a successful campaign with contributions from wallets 2, 3 and 4.
successfulCampaign :: EmulatorTrace ()
instance Schema.ToArgument Plutus.Contracts.Crowdfunding.Contribution
instance Schema.ToSchema Plutus.Contracts.Crowdfunding.Contribution
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Crowdfunding.Contribution
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Crowdfunding.Contribution
instance GHC.Generics.Generic Plutus.Contracts.Crowdfunding.Contribution
instance GHC.Show.Show Plutus.Contracts.Crowdfunding.Contribution
instance GHC.Classes.Eq Plutus.Contracts.Crowdfunding.Contribution
instance Plutus.Script.Utils.Typed.ValidatorTypes Plutus.Contracts.Crowdfunding.Crowdfunding
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Crowdfunding.CampaignAction
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Crowdfunding.CampaignAction
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Crowdfunding.CampaignAction
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Crowdfunding.CampaignAction
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Crowdfunding.CampaignAction
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Crowdfunding.Campaign
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Crowdfunding.Campaign
instance GHC.Show.Show Plutus.Contracts.Crowdfunding.Campaign
instance Schema.ToSchema Plutus.Contracts.Crowdfunding.Campaign
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Crowdfunding.Campaign
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Crowdfunding.Campaign
instance GHC.Generics.Generic Plutus.Contracts.Crowdfunding.Campaign


-- | Implements a custom currency with a minting policy that allows the
--   minting of a fixed amount of units.
module Plutus.Contracts.Currency

-- | A currency that can be created exactly once
data OneShotCurrency
OneShotCurrency :: (TxId, Integer) -> Map TokenName Integer -> OneShotCurrency

-- | Transaction input that must be spent when the currency is minted.
[curRefTransactionOutput] :: OneShotCurrency -> (TxId, Integer)

-- | How many units of each <a>TokenName</a> are to be minted.
[curAmounts] :: OneShotCurrency -> Map TokenName Integer
type CurrencySchema = Endpoint "Create native token" SimpleMPS
newtype CurrencyError
CurContractError :: ContractError -> CurrencyError
class AsCurrencyError r_a21NB
_CurrencyError :: AsCurrencyError r_a21NB => Prism' r_a21NB CurrencyError
_CurContractError :: AsCurrencyError r_a21NB => Prism' r_a21NB ContractError
curPolicy :: OneShotCurrency -> MintingPolicy

-- | <tt>mint [(n1, c1), ..., (n_k, c_k)]</tt> creates a new currency with
--   <tt>k</tt> token names, minting <tt>c_i</tt> units of each token
--   <tt>n_i</tt>. If <tt>k == 0</tt> then no value is minted. A one-shot
--   minting policy script is used to ensure that no more units of the
--   currency can be minted afterwards.
mintContract :: forall w s e. AsCurrencyError e => CardanoAddress -> [(TokenName, Integer)] -> Contract w s e OneShotCurrency

-- | The <a>Value</a> minted by the <a>OneShotCurrency</a> contract
mintedValue :: OneShotCurrency -> Value
currencySymbol :: OneShotCurrency -> CurrencySymbol

-- | Minting policy for a currency that has a fixed amount of tokens issued
--   in one transaction
data SimpleMPS
SimpleMPS :: TokenName -> Integer -> SimpleMPS
[tokenName] :: SimpleMPS -> TokenName
[amount] :: SimpleMPS -> Integer

-- | Use <a>mintContract</a> to create the currency specified by a
--   <a>SimpleMPS</a>
mintCurrency :: Promise (Maybe (Last OneShotCurrency)) CurrencySchema CurrencyError OneShotCurrency
instance Schema.ToSchema Plutus.Contracts.Currency.SimpleMPS
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Currency.SimpleMPS
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Currency.SimpleMPS
instance GHC.Generics.Generic Plutus.Contracts.Currency.SimpleMPS
instance GHC.Show.Show Plutus.Contracts.Currency.SimpleMPS
instance GHC.Classes.Eq Plutus.Contracts.Currency.SimpleMPS
instance Plutus.Contracts.Currency.AsCurrencyError Plutus.Contracts.Currency.CurrencyError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.Currency.CurrencyError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Currency.CurrencyError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Currency.CurrencyError
instance GHC.Generics.Generic Plutus.Contracts.Currency.CurrencyError
instance GHC.Show.Show Plutus.Contracts.Currency.CurrencyError
instance GHC.Classes.Eq Plutus.Contracts.Currency.CurrencyError
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Currency.OneShotCurrency
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Currency.OneShotCurrency
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Currency.OneShotCurrency
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Currency.OneShotCurrency
instance GHC.Classes.Eq Plutus.Contracts.Currency.OneShotCurrency
instance GHC.Show.Show Plutus.Contracts.Currency.OneShotCurrency
instance GHC.Generics.Generic Plutus.Contracts.Currency.OneShotCurrency

module Plutus.Contracts.ErrorHandling
type Schema = Endpoint "throwError" () .\/ Endpoint "catchError" () .\/ Endpoint "catchContractError" ()

-- | <a>MyError</a> has a constructor for each type of error that our
--   contract can throw. The <a>MyContractError</a> constructor wraps a
--   <a>ContractError</a>.
data MyError
Error1 :: Text -> MyError
Error2 :: MyError
MyContractError :: ContractError -> MyError
class AsMyError r_a28YV
_MyError :: AsMyError r_a28YV => Prism' r_a28YV MyError
_Error1 :: AsMyError r_a28YV => Prism' r_a28YV Text
_Error2 :: AsMyError r_a28YV => Prism' r_a28YV ()
_MyContractError :: AsMyError r_a28YV => Prism' r_a28YV ContractError
contract :: (AsMyError e, AsContractError e) => SlotConfig -> Contract w Schema e ()
instance Plutus.Contracts.ErrorHandling.AsMyError Plutus.Contracts.ErrorHandling.MyError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.ErrorHandling.MyError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.ErrorHandling.MyError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.ErrorHandling.MyError
instance GHC.Generics.Generic Plutus.Contracts.ErrorHandling.MyError
instance GHC.Show.Show Plutus.Contracts.ErrorHandling.MyError


-- | A general-purpose escrow contract in Plutus
module Plutus.Contracts.Escrow
data Escrow
data EscrowError
RedeemFailed :: RedeemFailReason -> EscrowError
RefundFailed :: EscrowError
EContractError :: ContractError -> EscrowError
class AsEscrowError r_a2bj1
_EscrowError :: AsEscrowError r_a2bj1 => Prism' r_a2bj1 EscrowError
_RedeemFailed :: AsEscrowError r_a2bj1 => Prism' r_a2bj1 RedeemFailReason
_RefundFailed :: AsEscrowError r_a2bj1 => Prism' r_a2bj1 ()
_EContractError :: AsEscrowError r_a2bj1 => Prism' r_a2bj1 ContractError

-- | Definition of an escrow contract, consisting of a deadline and a list
--   of targets
data EscrowParams d
EscrowParams :: POSIXTime -> [EscrowTarget d] -> EscrowParams d

-- | Latest point at which the outputs may be spent.
[escrowDeadline] :: EscrowParams d -> POSIXTime

-- | Where the money should go. For each target, the contract checks that
--   the output <tt>mkTxOutput</tt> of the target is present in the
--   spending transaction.
[escrowTargets] :: EscrowParams d -> [EscrowTarget d]

-- | Defines where the money should go. Usually we have `d = Datum` (when
--   defining <a>EscrowTarget</a> values in off-chain code). Sometimes we
--   have `d = DatumHash` (when checking the hashes in on-chain code)
data EscrowTarget d
PaymentPubKeyTarget :: PaymentPubKeyHash -> Value -> EscrowTarget d
ScriptTarget :: ValidatorHash -> d -> Value -> EscrowTarget d

-- | An <a>EscrowTarget</a> that pays the value to a script address, with
--   the given data script.
payToScriptTarget :: ValidatorHash -> Datum -> Value -> EscrowTarget Datum

-- | An <a>EscrowTarget</a> that pays the value to a public key address.
payToPaymentPubKeyTarget :: PaymentPubKeyHash -> Value -> EscrowTarget d

-- | The total <a>Value</a> that must be paid into the escrow contract
--   before it can be unlocked
targetTotal :: EscrowParams d -> Value
escrowContract :: EscrowParams Datum -> Contract () EscrowSchema EscrowError ()

-- | Pay some money into the escrow contract. Then release all funds to
--   their specified targets if enough funds were deposited before the
--   deadline, or reclaim the contribution if the goal has not been met.
payRedeemRefund :: forall w s. EscrowParams Datum -> Value -> Contract w s EscrowError (Either RefundSuccess RedeemSuccess)
typedValidator :: EscrowParams Datum -> TypedValidator Escrow

-- | Pay some money into the escrow contract.
pay :: forall w s e. AsContractError e => TypedValidator Escrow -> EscrowParams Datum -> Value -> Contract w s e TxId

-- | <a>pay</a> with an endpoint that gets the owner's public key and the
--   contribution.
payEp :: forall w s e. (HasEndpoint "pay-escrow" Value s, AsEscrowError e) => EscrowParams Datum -> Promise w s e TxId

-- | Redeem all outputs at the contract address using a transaction that
--   has all the outputs defined in the contract's list of targets.
redeem :: forall w s e. AsEscrowError e => TypedValidator Escrow -> EscrowParams Datum -> Contract w s e RedeemSuccess

-- | <a>redeem</a> with an endpoint.
redeemEp :: forall w s e. (HasEndpoint "redeem-escrow" () s, AsEscrowError e) => EscrowParams Datum -> Promise w s e RedeemSuccess

-- | Claim a refund of the contribution.
refund :: forall w s. TypedValidator Escrow -> EscrowParams Datum -> Contract w s EscrowError RefundSuccess

-- | <a>refund</a> with an endpoint.
refundEp :: forall w s. HasEndpoint "refund-escrow" () s => EscrowParams Datum -> Promise w s EscrowError RefundSuccess
data RedeemFailReason
DeadlinePassed :: RedeemFailReason
NotEnoughFundsAtAddress :: RedeemFailReason
newtype RedeemSuccess
RedeemSuccess :: TxId -> RedeemSuccess
newtype RefundSuccess
RefundSuccess :: TxId -> RefundSuccess
type EscrowSchema = Endpoint "pay-escrow" Value .\/ Endpoint "redeem-escrow" () .\/ Endpoint "refund-escrow" ()
data Action
Redeem :: Action
Refund :: Action
covIdx :: CoverageIndex
instance GHC.Show.Show Plutus.Contracts.Escrow.RedeemSuccess
instance GHC.Classes.Eq Plutus.Contracts.Escrow.RedeemSuccess
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Escrow.RefundSuccess
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Escrow.RefundSuccess
instance GHC.Generics.Generic Plutus.Contracts.Escrow.RefundSuccess
instance GHC.Show.Show Plutus.Contracts.Escrow.RefundSuccess
instance GHC.Classes.Eq Plutus.Contracts.Escrow.RefundSuccess
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Escrow.Action
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Escrow.Action
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Escrow.Action
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Escrow.Action
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Escrow.Action
instance Plutus.Script.Utils.Typed.ValidatorTypes Plutus.Contracts.Escrow.Escrow
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Escrow.EscrowParams
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni d, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni [Plutus.Contracts.Escrow.EscrowTarget d]) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contracts.Escrow.EscrowParams d)
instance GHC.Base.Functor Plutus.Contracts.Escrow.EscrowParams
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Escrow.EscrowTarget
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni d, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni d) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contracts.Escrow.EscrowTarget d)
instance GHC.Base.Functor Plutus.Contracts.Escrow.EscrowTarget
instance Plutus.Contracts.Escrow.AsEscrowError Plutus.Contracts.Escrow.EscrowError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.Escrow.EscrowError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Escrow.RedeemFailReason
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Escrow.RedeemFailReason
instance GHC.Generics.Generic Plutus.Contracts.Escrow.RedeemFailReason
instance GHC.Show.Show Plutus.Contracts.Escrow.RedeemFailReason
instance GHC.Classes.Eq Plutus.Contracts.Escrow.RedeemFailReason
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Escrow.EscrowError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Escrow.EscrowError
instance GHC.Generics.Generic Plutus.Contracts.Escrow.EscrowError
instance GHC.Show.Show Plutus.Contracts.Escrow.EscrowError


-- | A guessing game. A simplified version of <a>GameStateMachine</a> not
--   using <a>StateMachine</a> and using <a>yieldUnbalancedTx</a> for
--   balancing, signing and submitting transactions.
--   
--   Currently, remote wallets (anything other than WBE) can only handles
--   <a>yieldUnbalancedTx</a> requests, and not <tt>balanceTx</tt>,
--   <tt>signTx</tt> and <tt>submitTx</tt> requests.
module Plutus.Contracts.Game
contract :: AsContractError e => Contract () GameSchema e ()

-- | Datatype for creating a parameterized validator.
data GameParam
GameParam :: PaymentPubKeyHash -> POSIXTime -> GameParam

-- | Payment public key hash of the wallet locking some funds
[gameParamPayeePkh] :: GameParam -> PaymentPubKeyHash

-- | Starting time of the game
[gameParamStartTime] :: GameParam -> POSIXTime
type GameSchema = Endpoint "lock" LockArgs .\/ Endpoint "guess" GuessArgs

-- | Arguments for the <tt>"lock"</tt> endpoint
data LockArgs
LockArgs :: GameParam -> String -> Value -> LockArgs

-- | The parameters for parameterizing the validator.
[lockArgsGameParam] :: LockArgs -> GameParam

-- | The secret
[lockArgsSecret] :: LockArgs -> String

-- | Value that is locked by the contract initially
[lockArgsValue] :: LockArgs -> Value

-- | Arguments for the <tt>"guess"</tt> endpoint
data GuessArgs
GuessArgs :: GameParam -> String -> GuessArgs

-- | The parameters for parameterizing the validator.
[guessArgsGameParam] :: GuessArgs -> GameParam

-- | The guess
[guessArgsSecret] :: GuessArgs -> String
gameInstance :: GameParam -> TypedValidator Game

-- | The validation function (Datum -&gt; Redeemer -&gt; ScriptContext
--   -&gt; Bool)
--   
--   The <a>GameParam</a> parameter is not used in the validation. It is
--   meant to parameterize the script address depending based on the value
--   of <tt>GaramParam</tt>.
mkValidator :: GameParam -> HashedString -> ClearString -> ScriptContext -> Bool

-- | The address of the game (the hash of its validator script)
gameAddress :: GameParam -> CardanoAddress
covIdx :: GameParam -> CoverageIndex
instance Schema.ToSchema Plutus.Contracts.Game.LockArgs
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Game.LockArgs
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Game.LockArgs
instance GHC.Generics.Generic Plutus.Contracts.Game.LockArgs
instance GHC.Show.Show Plutus.Contracts.Game.LockArgs
instance Schema.ToSchema Plutus.Contracts.Game.GuessArgs
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Game.GuessArgs
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Game.GuessArgs
instance GHC.Generics.Generic Plutus.Contracts.Game.GuessArgs
instance GHC.Show.Show Plutus.Contracts.Game.GuessArgs
instance Plutus.Script.Utils.Typed.ValidatorTypes Plutus.Contracts.Game.Game
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Game.ClearString
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Game.ClearString
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Game.ClearString
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Game.ClearString
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Game.ClearString
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Game.HashedString
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Game.HashedString
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Game.HashedString
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Game.HashedString
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Game.HashedString
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Game.GameParam
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Game.GameParam
instance Schema.ToSchema Plutus.Contracts.Game.GameParam
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Game.GameParam
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Game.GameParam
instance GHC.Generics.Generic Plutus.Contracts.Game.GameParam
instance GHC.Show.Show Plutus.Contracts.Game.GameParam


-- | A guessing game that
--   
--   <ul>
--   <li>Uses a state machine to keep track of the current secret word</li>
--   <li>Uses a token to keep track of who is allowed to make a guess</li>
--   </ul>
module Plutus.Contracts.GameStateMachine

-- | Top-level contract, exposing both endpoints.
contract :: Contract () GameStateMachineSchema GameError ()
typedValidator :: GameParam -> TypedValidator GameStateMachine

-- | Datatype for creating a parameterized validator.
data GameParam
GameParam :: Address -> POSIXTime -> GameParam

-- | Payment address of the wallet locking some funds
[gameParamPayeePkh] :: GameParam -> Address

-- | Starting time of the game
[gameParamStartTime] :: GameParam -> POSIXTime

-- | State of the guessing game
data GameState

-- | Initial state. In this state only the <tt>MintTokens</tt> action is
--   allowed.
Initialised :: MintingPolicyHash -> TokenName -> HashedString -> GameState

-- | Funds have been locked. In this state only the <a>Guess</a> action is
--   allowed.
Locked :: MintingPolicyHash -> TokenName -> HashedString -> GameState

-- | All funds were unlocked.
Finished :: GameState

-- | Inputs (actions)
data GameInput

-- | Mint the "guess" token
MintToken :: GameInput

-- | Make a guess, extract the funds, and lock the remaining funds using a
--   new secret word.
Guess :: Address -> ClearString -> HashedString -> Value -> GameInput

-- | The token that represents the right to make a guess
data GuessToken
mkValidator :: GameParam -> ValidatorType GameStateMachine
mintingPolicy :: GameParam -> MintingPolicy

-- | Arguments for the <tt>"lock"</tt> endpoint
data LockArgs
LockArgs :: GameParam -> SecretArgument String -> Value -> LockArgs

-- | The parameters for parameterizing the validator.
[lockArgsGameParam] :: LockArgs -> GameParam

-- | The secret
[lockArgsSecret] :: LockArgs -> SecretArgument String

-- | Value that is locked by the contract initially
[lockArgsValue] :: LockArgs -> Value

-- | Arguments for the <tt>"guess"</tt> endpoint
data GuessArgs
GuessArgs :: GameParam -> Address -> String -> SecretArgument String -> Value -> GuessArgs

-- | The parameters for parameterizing the validator.
[guessArgsGameParam] :: GuessArgs -> GameParam

-- | The recipient of the guess token
[guessTokenTarget] :: GuessArgs -> Address

-- | The guess
[guessArgsOldSecret] :: GuessArgs -> String

-- | The new secret
[guessArgsNewSecret] :: GuessArgs -> SecretArgument String

-- | How much to extract from the contract
[guessArgsValueTakenOut] :: GuessArgs -> Value

-- | The schema of the contract. It consists of the two endpoints
--   <tt>"lock"</tt> and <tt>"guess"</tt> with their respective argument
--   types.
type GameStateMachineSchema = Endpoint "lock" LockArgs .\/ Endpoint "guess" GuessArgs
data GameError
token :: MintingPolicyHash -> TokenName -> Value
covIdx :: CoverageIndex
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.GameStateMachine.GuessToken
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.GameStateMachine.GuessToken
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.GameStateMachine.GuessToken
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.GameStateMachine.GuessToken
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.GameStateMachine.GuessToken
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.GameStateMachine.GameInput
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.GameStateMachine.GameInput
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.GameStateMachine.GameInput
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.GameStateMachine.GameInput
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.GameStateMachine.GameInput
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.GameStateMachine.GameState
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.GameStateMachine.GameState
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.GameStateMachine.GameState
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.GameStateMachine.GameState
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.GameStateMachine.GameState
instance GHC.Show.Show Plutus.Contracts.GameStateMachine.GuessToken
instance PlutusTx.Eq.Eq Plutus.Contracts.GameStateMachine.GuessToken
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.GameStateMachine.GameState
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.GameStateMachine.GameState
instance GHC.Generics.Generic Plutus.Contracts.GameStateMachine.GameState
instance GHC.Show.Show Plutus.Contracts.GameStateMachine.GameState
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.GameStateMachine.GameInput
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.GameStateMachine.GameInput
instance GHC.Generics.Generic Plutus.Contracts.GameStateMachine.GameInput
instance GHC.Show.Show Plutus.Contracts.GameStateMachine.GameInput
instance PlutusTx.Eq.Eq Plutus.Contracts.GameStateMachine.GameState
instance Plutus.Contracts.GameStateMachine.AsGameError Plutus.Contracts.GameStateMachine.GameError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.GameStateMachine.GameError
instance Plutus.Contract.StateMachine.AsSMContractError Plutus.Contracts.GameStateMachine.GameError
instance Schema.ToSchema Plutus.Contracts.GameStateMachine.LockArgs
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.GameStateMachine.LockArgs
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.GameStateMachine.LockArgs
instance GHC.Generics.Generic Plutus.Contracts.GameStateMachine.LockArgs
instance GHC.Show.Show Plutus.Contracts.GameStateMachine.LockArgs
instance Schema.ToSchema Plutus.Contracts.GameStateMachine.GuessArgs
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.GameStateMachine.GuessArgs
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.GameStateMachine.GuessArgs
instance GHC.Generics.Generic Plutus.Contracts.GameStateMachine.GuessArgs
instance GHC.Show.Show Plutus.Contracts.GameStateMachine.GuessArgs
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.GameStateMachine.GameError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.GameStateMachine.GameError
instance GHC.Generics.Generic Plutus.Contracts.GameStateMachine.GameError
instance GHC.Show.Show Plutus.Contracts.GameStateMachine.GameError
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.GameStateMachine.ClearString
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.GameStateMachine.ClearString
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.GameStateMachine.ClearString
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.GameStateMachine.ClearString
instance GHC.Generics.Generic Plutus.Contracts.GameStateMachine.ClearString
instance GHC.Show.Show Plutus.Contracts.GameStateMachine.ClearString
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.GameStateMachine.ClearString
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.GameStateMachine.ClearString
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.GameStateMachine.ClearString
instance PlutusTx.Eq.Eq Plutus.Contracts.GameStateMachine.ClearString
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.GameStateMachine.HashedString
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.GameStateMachine.HashedString
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.GameStateMachine.HashedString
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.GameStateMachine.HashedString
instance GHC.Generics.Generic Plutus.Contracts.GameStateMachine.HashedString
instance GHC.Show.Show Plutus.Contracts.GameStateMachine.HashedString
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.GameStateMachine.HashedString
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.GameStateMachine.HashedString
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.GameStateMachine.HashedString
instance PlutusTx.Eq.Eq Plutus.Contracts.GameStateMachine.HashedString
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.GameStateMachine.GameParam
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.GameStateMachine.GameParam
instance Schema.ToSchema Plutus.Contracts.GameStateMachine.GameParam
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.GameStateMachine.GameParam
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.GameStateMachine.GameParam
instance GHC.Generics.Generic Plutus.Contracts.GameStateMachine.GameParam
instance GHC.Show.Show Plutus.Contracts.GameStateMachine.GameParam


-- | A basic governance contract in Plutus.
module Plutus.Contracts.Governance

-- | The main contract for creating a new law and for voting on proposals.
contract :: AsGovError e => Params -> Contract () Schema e ()

-- | The contract for proposing changes to a law.
proposalContract :: AsGovError e => Params -> Address -> Proposal -> Contract () EmptySchema e ()

-- | The governace contract parameters.
data Params
Params :: TokenName -> [Address] -> Integer -> Params

-- | The token names that allow voting are generated by adding an
--   increasing number to the base token name. See <a>mkTokenName</a>.
[baseTokenName] :: Params -> TokenName

-- | The public key hashes of the initial holders of the voting tokens.
[initialHolders] :: Params -> [Address]

-- | The number of votes in favor required for a proposal to be accepted.
[requiredVotes] :: Params -> Integer

-- | The parameters for the proposal contract.
data Proposal
Proposal :: Law -> TokenName -> POSIXTime -> Proposal

-- | The new contents of the law
[newLaw] :: Proposal -> Law

-- | The name of the voting tokens. Only voting token owners are allowed to
--   propose changes.
[tokenName] :: Proposal -> TokenName

-- | The time when voting ends and the votes are tallied.
[votingDeadline] :: Proposal -> POSIXTime

-- | The endpoints of governance contracts are
--   
--   <ul>
--   <li><tt>new-law</tt> to create a new law and distribute voting
--   tokens</li>
--   <li><tt>add-vote</tt> to vote on a proposal with the name of the
--   voting token and a boolean to vote in favor or against.</li>
--   </ul>
type Schema = Endpoint "new-law" Law .\/ Endpoint "add-vote" (Address, TokenName, Bool)

-- | Generate a voting token name by tagging on a number after the base
--   token name.
mkTokenName :: TokenName -> Integer -> TokenName
typedValidator :: Params -> TypedValidator GovernanceMachine
mkValidator :: Params -> ValidatorType GovernanceMachine
data GovState
GovState :: Law -> MintingPolicyHash -> Maybe Voting -> GovState
[law] :: GovState -> Law
[mph] :: GovState -> MintingPolicyHash
[voting] :: GovState -> Maybe Voting
newtype Law
Law :: BuiltinByteString -> Law
[unLaw] :: Law -> BuiltinByteString
data Voting
Voting :: Proposal -> Map TokenName Bool -> Voting
[proposal] :: Voting -> Proposal
[votes] :: Voting -> Map TokenName Bool
data GovError
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Governance.GovInput
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Governance.GovInput
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Governance.GovInput
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Governance.GovInput
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Governance.GovInput
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Governance.GovState
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Governance.GovState
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Governance.GovState
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Governance.GovState
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Governance.GovState
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Governance.Voting
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Governance.Voting
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Governance.Voting
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Governance.Voting
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Governance.Voting
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Governance.Proposal
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Governance.Proposal
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Governance.Proposal
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Governance.Proposal
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Governance.Proposal
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Governance.Law
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Governance.Law
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Governance.Law
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Governance.Law
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Governance.Law
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Governance.Params
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Governance.Params
instance Plutus.Contracts.Governance.AsGovError Plutus.Contracts.Governance.GovError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.Governance.GovError
instance Plutus.Contract.StateMachine.AsSMContractError Plutus.Contracts.Governance.GovError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Governance.Law
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Governance.Law
instance GHC.Generics.Generic Plutus.Contracts.Governance.Law
instance GHC.Show.Show Plutus.Contracts.Governance.Law
instance GHC.Classes.Eq Plutus.Contracts.Governance.Law
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Governance.Proposal
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Governance.Proposal
instance GHC.Generics.Generic Plutus.Contracts.Governance.Proposal
instance GHC.Show.Show Plutus.Contracts.Governance.Proposal
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Governance.Voting
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Governance.Voting
instance GHC.Generics.Generic Plutus.Contracts.Governance.Voting
instance GHC.Show.Show Plutus.Contracts.Governance.Voting
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Governance.GovState
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Governance.GovState
instance GHC.Generics.Generic Plutus.Contracts.Governance.GovState
instance GHC.Show.Show Plutus.Contracts.Governance.GovState
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Governance.GovInput
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Governance.GovInput
instance GHC.Generics.Generic Plutus.Contracts.Governance.GovInput
instance GHC.Show.Show Plutus.Contracts.Governance.GovInput
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Governance.GovError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Governance.GovError
instance GHC.Generics.Generic Plutus.Contracts.Governance.GovError
instance GHC.Show.Show Plutus.Contracts.Governance.GovError
instance GHC.Classes.Eq Plutus.Contracts.Governance.GovError


-- | Implements an n-out-of-m multisig contract.
module Plutus.Contracts.MultiSig
data MultiSig
MultiSig :: [PaymentPubKeyHash] -> Integer -> MultiSig

-- | List of public keys of people who may sign the transaction
[signatories] :: MultiSig -> [PaymentPubKeyHash]

-- | Minimum number of signatures required to unlock the output (should not
--   exceed <tt>length signatories</tt>)
[minNumSignatures] :: MultiSig -> Integer
type MultiSigSchema = Endpoint "lock" (MultiSig, Value) .\/ Endpoint "unlock" (MultiSig, [PaymentPubKeyHash])
contract :: AsContractError e => Contract () MultiSigSchema e ()

-- | Lock some funds in a <a>MultiSig</a> contract.
lock :: AsContractError e => Promise () MultiSigSchema e ()
typedValidator :: MultiSig -> TypedValidator MultiSig
validate :: MultiSig -> () -> () -> ScriptContext -> Bool
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.MultiSig.MultiSig
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.MultiSig.MultiSig
instance Plutus.Script.Utils.Typed.ValidatorTypes Plutus.Contracts.MultiSig.MultiSig
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.MultiSig.MultiSig
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.MultiSig.MultiSig
instance GHC.Generics.Generic Plutus.Contracts.MultiSig.MultiSig
instance GHC.Show.Show Plutus.Contracts.MultiSig.MultiSig


-- | A multisig contract written as a state machine.
module Plutus.Contracts.MultiSigStateMachine
data Params
Params :: [PaymentPubKeyHash] -> Integer -> Params

-- | Public keys that are allowed to authorise payments
[mspSignatories] :: Params -> [PaymentPubKeyHash]

-- | How many signatures are required for a payment
[mspRequiredSigs] :: Params -> Integer

-- | A proposal for making a payment under the multisig scheme.
data Payment
Payment :: Value -> Address -> POSIXTime -> Payment

-- | How much to pay out
[paymentAmount] :: Payment -> Value

-- | Address to pay the value to
[paymentRecipient] :: Payment -> Address

-- | Time until the required amount of signatures has to be collected.
[paymentDeadline] :: Payment -> POSIXTime
data State s
mkValidator :: Params -> ValidatorType MultiSigSym
typedValidator :: Params -> TypedValidator MultiSigSym
data MultiSigError
MSContractError :: ContractError -> MultiSigError
MSStateMachineError :: SMContractError -> MultiSigError
type MultiSigSchema = Endpoint "propose-payment" Payment .\/ Endpoint "add-signature" () .\/ Endpoint "cancel-payment" () .\/ Endpoint "pay" () .\/ Endpoint "lock" Value
contract :: (AsContractError e, AsSMContractError e) => Params -> Contract () MultiSigSchema e ()
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.MultiSigStateMachine.Input
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.MultiSigStateMachine.Input
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.MultiSigStateMachine.Input
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.MultiSigStateMachine.Input
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.MultiSigStateMachine.Input
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.MultiSigStateMachine.Params
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.MultiSigStateMachine.Params
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.MultiSigStateMachine.MSState
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.MultiSigStateMachine.MSState
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.MultiSigStateMachine.MSState
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.MultiSigStateMachine.MSState
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.MultiSigStateMachine.MSState
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.MultiSigStateMachine.Payment
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.MultiSigStateMachine.Payment
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.MultiSigStateMachine.Payment
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.MultiSigStateMachine.Payment
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.MultiSigStateMachine.Payment
instance Plutus.Contracts.MultiSigStateMachine.AsMultiSigError Plutus.Contracts.MultiSigStateMachine.MultiSigError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.MultiSigStateMachine.MultiSigError
instance Plutus.Contract.StateMachine.AsSMContractError Plutus.Contracts.MultiSigStateMachine.MultiSigError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.MultiSigStateMachine.Payment
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.MultiSigStateMachine.Payment
instance GHC.Generics.Generic Plutus.Contracts.MultiSigStateMachine.Payment
instance GHC.Show.Show Plutus.Contracts.MultiSigStateMachine.Payment
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.MultiSigStateMachine.MSState
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.MultiSigStateMachine.MSState
instance GHC.Generics.Generic Plutus.Contracts.MultiSigStateMachine.MSState
instance GHC.Show.Show Plutus.Contracts.MultiSigStateMachine.MSState
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.MultiSigStateMachine.Input
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.MultiSigStateMachine.Input
instance GHC.Generics.Generic Plutus.Contracts.MultiSigStateMachine.Input
instance GHC.Show.Show Plutus.Contracts.MultiSigStateMachine.Input
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.MultiSigStateMachine.MultiSigError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.MultiSigStateMachine.MultiSigError
instance GHC.Generics.Generic Plutus.Contracts.MultiSigStateMachine.MultiSigError
instance GHC.Show.Show Plutus.Contracts.MultiSigStateMachine.MultiSigError
instance PlutusTx.Eq.Eq Plutus.Contracts.MultiSigStateMachine.MSState
instance PlutusTx.Eq.Eq Plutus.Contracts.MultiSigStateMachine.Payment


-- | A state machine with two states and two roles that take turns.
module Plutus.Contracts.PingPong
data PingPongState
Pinged :: PingPongState
Ponged :: PingPongState
Stopped :: PingPongState
data Input
Ping :: Input
Pong :: Input
Stop :: Input
data PingPongError
PingPongContractError :: ContractError -> PingPongError
PingPongSMError :: SMContractError -> PingPongError
StoppedUnexpectedly :: PingPongError
type PingPongSchema = Endpoint "initialise" () .\/ Endpoint "ping" () .\/ Endpoint "pong" () .\/ Endpoint "stop" () .\/ Endpoint "wait" ()
runPing :: forall w. Contract w PingPongSchema PingPongError ()
runPong :: forall w. Contract w PingPongSchema PingPongError ()
ping :: forall w. Promise w PingPongSchema PingPongError ()
pong :: forall w. Promise w PingPongSchema PingPongError ()
initialise :: forall w. Promise w PingPongSchema PingPongError ()
runStop :: forall w. Promise w PingPongSchema PingPongError ()
runWaitForUpdate :: forall w. Contract w PingPongSchema PingPongError (Maybe (OnChainState PingPongState Input))
combined :: Contract (Last PingPongState) PingPongSchema PingPongError ()
simplePingPong :: Contract (Last PingPongState) PingPongSchema PingPongError ()
simplePingPongAuto :: Contract (Last PingPongState) PingPongSchema PingPongError ()
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.PingPong.Input
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.PingPong.Input
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.PingPong.Input
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.PingPong.Input
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.PingPong.Input
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.PingPong.PingPongState
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.PingPong.PingPongState
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.PingPong.PingPongState
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.PingPong.PingPongState
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.PingPong.PingPongState
instance Plutus.Contracts.PingPong.AsPingPongError Plutus.Contracts.PingPong.PingPongError
instance Plutus.Contract.StateMachine.AsSMContractError Plutus.Contracts.PingPong.PingPongError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.PingPong.PingPongError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.PingPong.PingPongState
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.PingPong.PingPongState
instance GHC.Generics.Generic Plutus.Contracts.PingPong.PingPongState
instance GHC.Show.Show Plutus.Contracts.PingPong.PingPongState
instance GHC.Classes.Eq Plutus.Contracts.PingPong.PingPongState
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.PingPong.Input
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.PingPong.Input
instance GHC.Generics.Generic Plutus.Contracts.PingPong.Input
instance GHC.Show.Show Plutus.Contracts.PingPong.Input
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.PingPong.PingPongError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.PingPong.PingPongError
instance GHC.Generics.Generic Plutus.Contracts.PingPong.PingPongError
instance GHC.Show.Show Plutus.Contracts.PingPong.PingPongError
instance PlutusTx.Eq.Eq Plutus.Contracts.PingPong.PingPongState

module Plutus.Contracts.Prism.STO
data STOData
STOData :: PaymentPubKeyHash -> TokenName -> Value -> STOData
[stoIssuer] :: STOData -> PaymentPubKeyHash
[stoTokenName] :: STOData -> TokenName
[stoCredentialToken] :: STOData -> Value
policy :: STOData -> MintingPolicy

-- | A <a>Value</a> of a number of coins issued in the STO
coins :: STOData -> Integer -> Value
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Prism.STO.STOData
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Prism.STO.STOData
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Prism.STO.STOData
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Prism.STO.STOData
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Prism.STO.STOData
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Prism.STO.STOData
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Prism.STO.STOData
instance GHC.Show.Show Plutus.Contracts.Prism.STO.STOData
instance GHC.Classes.Eq Plutus.Contracts.Prism.STO.STOData
instance GHC.Generics.Generic Plutus.Contracts.Prism.STO.STOData


-- | A "pay-to-pubkey" transaction output implemented as a Plutus contract.
--   This is useful if you need something that behaves like a pay-to-pubkey
--   output, but is not (easily) identified by wallets as one.
module Plutus.Contracts.PubKey

-- | Lock some funds in a <tt>PayToPubKey</tt> contract, returning the
--   output's address and a <a>TxIn</a> transaction input that can spend
--   it.
pubKeyContract :: forall w s e. AsPubKeyError e => PaymentPubKeyHash -> Value -> Contract w s e (TxOutRef, Maybe DecoratedTxOut, TypedValidator PubKeyContract)
typedValidator :: PaymentPubKeyHash -> TypedValidator PubKeyContract
data PubKeyError
ScriptOutputMissing :: PaymentPubKeyHash -> PubKeyError
MultipleScriptOutputs :: PaymentPubKeyHash -> PubKeyError
PKContractError :: ContractError -> PubKeyError
class AsPubKeyError r_a4gSp
_PubKeyError :: AsPubKeyError r_a4gSp => Prism' r_a4gSp PubKeyError
_ScriptOutputMissing :: AsPubKeyError r_a4gSp => Prism' r_a4gSp PaymentPubKeyHash
_MultipleScriptOutputs :: AsPubKeyError r_a4gSp => Prism' r_a4gSp PaymentPubKeyHash
_PKContractError :: AsPubKeyError r_a4gSp => Prism' r_a4gSp ContractError
instance Plutus.Contracts.PubKey.AsPubKeyError Plutus.Contracts.PubKey.PubKeyError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.PubKey.PubKeyError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.PubKey.PubKeyError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.PubKey.PubKeyError
instance GHC.Generics.Generic Plutus.Contracts.PubKey.PubKeyError
instance GHC.Show.Show Plutus.Contracts.PubKey.PubKeyError
instance GHC.Classes.Eq Plutus.Contracts.PubKey.PubKeyError
instance Plutus.Script.Utils.Typed.ValidatorTypes Plutus.Contracts.PubKey.PubKeyContract

module Plutus.Contracts.SealedBidAuction

-- | Definition of an auction
data AuctionParams
AuctionParams :: Address -> Value -> POSIXTime -> POSIXTime -> AuctionParams

-- | Current owner of the asset. This is where the proceeds of the auction
--   will be sent.
[apOwner] :: AuctionParams -> Address

-- | The asset itself. This value is going to be locked by the auction
--   script output.
[apAsset] :: AuctionParams -> Value

-- | When the time window for bidding ends.
[apEndTime] :: AuctionParams -> POSIXTime

-- | When the time window for revealing your bid ends.
[apPayoutTime] :: AuctionParams -> POSIXTime
newtype BidArgs
BidArgs :: SecretArgument Integer -> BidArgs
[secretBid] :: BidArgs -> SecretArgument Integer
newtype RevealArgs
RevealArgs :: Integer -> RevealArgs
[publicBid] :: RevealArgs -> Integer
data AuctionError

-- | State machine operation failed
StateMachineContractError :: SMContractError -> AuctionError

-- | Endpoint, coin selection, etc. failed
AuctionContractError :: ContractError -> AuctionError
type BidderSchema = Endpoint "bid" BidArgs .\/ Endpoint "reveal" RevealArgs .\/ Endpoint "payout" ()
type SellerSchema = Endpoint "payout" ()
startAuction :: Value -> POSIXTime -> POSIXTime -> Contract () SellerSchema AuctionError ()
bid :: AuctionParams -> Promise () BidderSchema AuctionError ()
reveal :: AuctionParams -> Promise () BidderSchema AuctionError ()
payout :: HasEndpoint "payout" () s => AuctionParams -> Promise () s AuctionError ()

-- | Pack an integer into a byte string with a leading sign byte in
--   little-endian order
packInteger :: Integer -> BuiltinByteString

-- | Top-level contract for seller
sellerContract :: AuctionParams -> Contract () SellerSchema AuctionError ()

-- | Top-level contract for buyer
bidderContract :: AuctionParams -> Contract () BidderSchema AuctionError ()
instance Plutus.Contracts.SealedBidAuction.AsAuctionError Plutus.Contracts.SealedBidAuction.AuctionError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.SealedBidAuction.AuctionError
instance Plutus.Contract.StateMachine.AsSMContractError Plutus.Contracts.SealedBidAuction.AuctionError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.SealedBidAuction.AuctionError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.SealedBidAuction.AuctionError
instance GHC.Generics.Generic Plutus.Contracts.SealedBidAuction.AuctionError
instance GHC.Show.Show Plutus.Contracts.SealedBidAuction.AuctionError
instance GHC.Classes.Eq Plutus.Contracts.SealedBidAuction.AuctionError
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.SealedBidAuction.AuctionInput
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.SealedBidAuction.AuctionInput
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.SealedBidAuction.AuctionInput
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.SealedBidAuction.AuctionInput
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.SealedBidAuction.AuctionInput
instance GHC.Show.Show Plutus.Contracts.SealedBidAuction.AuctionInput
instance GHC.Generics.Generic Plutus.Contracts.SealedBidAuction.AuctionInput
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.SealedBidAuction.AuctionState
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.SealedBidAuction.AuctionState
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.SealedBidAuction.AuctionState
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.SealedBidAuction.AuctionState
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.SealedBidAuction.AuctionState
instance GHC.Classes.Eq Plutus.Contracts.SealedBidAuction.AuctionState
instance GHC.Show.Show Plutus.Contracts.SealedBidAuction.AuctionState
instance GHC.Generics.Generic Plutus.Contracts.SealedBidAuction.AuctionState
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.SealedBidAuction.RevealedBid
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.SealedBidAuction.RevealedBid
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.SealedBidAuction.RevealedBid
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.SealedBidAuction.RevealedBid
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.SealedBidAuction.RevealedBid
instance GHC.Generics.Generic Plutus.Contracts.SealedBidAuction.RevealedBid
instance GHC.Show.Show Plutus.Contracts.SealedBidAuction.RevealedBid
instance GHC.Classes.Eq Plutus.Contracts.SealedBidAuction.RevealedBid
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.SealedBidAuction.SealedBid
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.SealedBidAuction.SealedBid
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.SealedBidAuction.SealedBid
instance PlutusTx.Eq.Eq Plutus.Contracts.SealedBidAuction.SealedBid
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.SealedBidAuction.SealedBid
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.SealedBidAuction.SealedBid
instance GHC.Generics.Generic Plutus.Contracts.SealedBidAuction.SealedBid
instance GHC.Show.Show Plutus.Contracts.SealedBidAuction.SealedBid
instance GHC.Classes.Eq Plutus.Contracts.SealedBidAuction.SealedBid
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.SealedBidAuction.AuctionParams
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.SealedBidAuction.AuctionParams
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.SealedBidAuction.BidArgs
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.SealedBidAuction.BidArgs
instance GHC.Generics.Generic Plutus.Contracts.SealedBidAuction.BidArgs
instance GHC.Show.Show Plutus.Contracts.SealedBidAuction.BidArgs
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.SealedBidAuction.RevealArgs
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.SealedBidAuction.RevealArgs
instance GHC.Generics.Generic Plutus.Contracts.SealedBidAuction.RevealArgs
instance GHC.Show.Show Plutus.Contracts.SealedBidAuction.RevealArgs
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.SealedBidAuction.AuctionParams
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.SealedBidAuction.AuctionParams
instance GHC.Generics.Generic Plutus.Contracts.SealedBidAuction.AuctionParams
instance GHC.Show.Show Plutus.Contracts.SealedBidAuction.AuctionParams
instance GHC.Classes.Eq Plutus.Contracts.SealedBidAuction.AuctionParams


-- | This simple escrow contract facilitiates and exchange of currencies.
module Plutus.Contracts.SimpleEscrow
data EscrowParams
EscrowParams :: PaymentPubKeyHash -> Value -> Value -> POSIXTime -> EscrowParams

-- | The entity that needs to be paid the <a>expecting</a> <a>Value</a>.
[payee] :: EscrowParams -> PaymentPubKeyHash

-- | Value to be paid out to the redeemer.
[paying] :: EscrowParams -> Value

-- | Value to be received by the payee.
[expecting] :: EscrowParams -> Value

-- | Time after which the contract expires.
[deadline] :: EscrowParams -> POSIXTime
type EscrowSchema = Endpoint "lock" EscrowParams .\/ Endpoint "refund" EscrowParams .\/ Endpoint "redeem" EscrowParams
data Action
Redeem :: Action
Refund :: Action
data RedeemFailReason
DeadlinePassed :: RedeemFailReason
data EscrowError
RedeemFailed :: RedeemFailReason -> EscrowError
RefundFailed :: EscrowError
EContractError :: ContractError -> EscrowError
class AsEscrowError r_a4zkL
_EscrowError :: AsEscrowError r_a4zkL => Prism' r_a4zkL EscrowError
_RedeemFailed :: AsEscrowError r_a4zkL => Prism' r_a4zkL RedeemFailReason
_RefundFailed :: AsEscrowError r_a4zkL => Prism' r_a4zkL ()
_EContractError :: AsEscrowError r_a4zkL => Prism' r_a4zkL ContractError
newtype RefundSuccess
RefundSuccess :: TxId -> RefundSuccess
newtype RedeemSuccess
RedeemSuccess :: TxId -> RedeemSuccess
data Escrow
escrowAddress :: CardanoAddress
escrowInstance :: TypedValidator Escrow
validate :: EscrowParams -> Action -> ScriptContext -> Bool

-- | Lock the <a>paying</a> <a>Value</a> in the output of this script, with
--   the requirement that the transaction validates before the
--   <a>deadline</a>.
lockEp :: Promise () EscrowSchema EscrowError ()

-- | Attempts to redeem the <a>Value</a> locked into this script by paying
--   in from the callers address to the payee.
redeemEp :: Promise () EscrowSchema EscrowError RedeemSuccess

-- | Refunds the locked amount back to the <a>payee</a>.
refundEp :: Promise () EscrowSchema EscrowError RefundSuccess
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.SimpleEscrow.Action
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.SimpleEscrow.Action
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.SimpleEscrow.Action
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.SimpleEscrow.Action
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.SimpleEscrow.Action
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.SimpleEscrow.EscrowParams
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.SimpleEscrow.EscrowParams
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.SimpleEscrow.EscrowParams
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.SimpleEscrow.EscrowParams
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.SimpleEscrow.EscrowParams
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.SimpleEscrow.RefundSuccess
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.SimpleEscrow.RefundSuccess
instance GHC.Generics.Generic Plutus.Contracts.SimpleEscrow.RefundSuccess
instance GHC.Show.Show Plutus.Contracts.SimpleEscrow.RefundSuccess
instance GHC.Classes.Eq Plutus.Contracts.SimpleEscrow.RefundSuccess
instance GHC.Show.Show Plutus.Contracts.SimpleEscrow.RedeemSuccess
instance GHC.Classes.Eq Plutus.Contracts.SimpleEscrow.RedeemSuccess
instance Plutus.Script.Utils.Typed.ValidatorTypes Plutus.Contracts.SimpleEscrow.Escrow
instance Plutus.Contracts.SimpleEscrow.AsEscrowError Plutus.Contracts.SimpleEscrow.EscrowError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.SimpleEscrow.EscrowError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.SimpleEscrow.EscrowParams
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.SimpleEscrow.EscrowParams
instance GHC.Generics.Generic Plutus.Contracts.SimpleEscrow.EscrowParams
instance GHC.Show.Show Plutus.Contracts.SimpleEscrow.EscrowParams
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.SimpleEscrow.RedeemFailReason
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.SimpleEscrow.RedeemFailReason
instance GHC.Generics.Generic Plutus.Contracts.SimpleEscrow.RedeemFailReason
instance GHC.Show.Show Plutus.Contracts.SimpleEscrow.RedeemFailReason
instance GHC.Classes.Eq Plutus.Contracts.SimpleEscrow.RedeemFailReason
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.SimpleEscrow.EscrowError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.SimpleEscrow.EscrowError
instance GHC.Generics.Generic Plutus.Contracts.SimpleEscrow.EscrowError
instance GHC.Show.Show Plutus.Contracts.SimpleEscrow.EscrowError

module Plutus.Contracts.Stablecoin

-- | An amount of stablecoins
newtype SC a
SC :: a -> SC a
[unSC] :: SC a -> a

-- | An amount of reservecoins
newtype RC a
RC :: a -> RC a
[unRC] :: RC a -> a

-- | An amount of base currency coins (eg. Ada or some native currency)
newtype BC a
BC :: a -> BC a
[unBC] :: BC a -> a

-- | An amount of peg currency (eg. USD)
newtype PC a
PC :: a -> PC a
[unPC] :: PC a -> a

-- | The bank's state
data BankState
BankState :: BC Integer -> SC Integer -> RC Integer -> MintingPolicyHash -> BankState

-- | Value of the bank's reserves in base currency
[bsReserves] :: BankState -> BC Integer

-- | Amount of stablecoins in circulation
[bsStablecoins] :: BankState -> SC Integer

-- | Amount of reservecoins currently in circulation
[bsReservecoins] :: BankState -> RC Integer

-- | Hash of the minting policy that forwards all checks to the state
--   machine. (This has to be in this type, rather than in
--   <a>Stablecoin</a>, to avoid a circular dependency on the script's
--   hash)
[bsMintingPolicyScript] :: BankState -> MintingPolicyHash

-- | Stablecoin parameters.
data Stablecoin
Stablecoin :: PaymentPubKey -> Rational -> Rational -> Rational -> BC Integer -> AssetClass -> TokenName -> TokenName -> Stablecoin

-- | Public key of the oracle that provides exchange rates
[scOracle] :: Stablecoin -> PaymentPubKey

-- | Fee charged by bank for transactions. Calculated as a fraction of the
--   total transaction volume in base currency.
[scFee] :: Stablecoin -> Rational

-- | The minimum ratio of reserves to liabilities
[scMinReserveRatio] :: Stablecoin -> Rational

-- | The maximum ratio of reserves to liabilities
[scMaxReserveRatio] :: Stablecoin -> Rational

-- | The price of a single reservecoin if no reservecoins have been issued
[scReservecoinDefaultPrice] :: Stablecoin -> BC Integer

-- | The asset class of the base currency. Value of this currency will be
--   locked by the stablecoin state machine instance
[scBaseCurrency] :: Stablecoin -> AssetClass

-- | <a>TokenName</a> of the stablecoin
[scStablecoinTokenName] :: Stablecoin -> TokenName

-- | <a>TokenName</a> of the reservecoin
[scReservecoinTokenName] :: Stablecoin -> TokenName

-- | Input to the stablecoin state machine
data Input
Input :: SCAction -> SignedMessage (Observation ConversionRate) -> Input

-- | The action to be performed
[inpSCAction] :: Input -> SCAction

-- | Exchange rate between base currency and peg currency
[inpConversionRate] :: Input -> SignedMessage (Observation ConversionRate)

-- | Action that can be performed on the stablecoin contract.
data SCAction

-- | Create a number stablecoins, depositing the matching amount of base
--   currency
MintStablecoin :: SC Integer -> SCAction

-- | Create a number of reservecoins, depositing the matching amount of
--   base currency
MintReserveCoin :: RC Integer -> SCAction

-- | Conversion rate from peg currency (eg. USD) to base currency (eg. Ada)
type ConversionRate = Rational
typedValidator :: Stablecoin -> TypedValidator (StateMachine BankState Input)
machineClient :: TypedValidator (StateMachine BankState Input) -> Stablecoin -> StateMachineClient BankState Input
step :: forall i o. Stablecoin -> BankState -> Input -> Maybe (TxConstraints i o, BankState)

-- | A <a>Contract</a> that initialises the state machine and then accepts
--   <a>Input</a> transitions.
contract :: Promise () StablecoinSchema StablecoinError ()
data StablecoinError
type StablecoinSchema = Endpoint "run step" Input .\/ Endpoint "initialise" Stablecoin

-- | A <a>Value</a> with the given number of stablecoins
stableCoins :: Stablecoin -> SC Integer -> Value

-- | A <a>Value</a> with the given number of reservecoins
reserveCoins :: Stablecoin -> RC Integer -> Value
checkValidState :: Stablecoin -> BankState -> ConversionRate -> Either InvalidStateReason ()
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Stablecoin.Input
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Stablecoin.Input
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Stablecoin.Input
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Stablecoin.SCAction
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Stablecoin.SCAction
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Stablecoin.SCAction
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Stablecoin.Stablecoin
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Stablecoin.Stablecoin
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Stablecoin.Stablecoin
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Stablecoin.BankState
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Stablecoin.BankState
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Stablecoin.BankState
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.Contracts.Stablecoin.PC a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.Contracts.Stablecoin.PC a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.Contracts.Stablecoin.PC a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.Contracts.Stablecoin.RC a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.Contracts.Stablecoin.RC a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.Contracts.Stablecoin.RC a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.Contracts.Stablecoin.SC a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.Contracts.Stablecoin.SC a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.Contracts.Stablecoin.SC a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.Contracts.Stablecoin.BC a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.Contracts.Stablecoin.BC a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.Contracts.Stablecoin.BC a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Stablecoin.Stablecoin
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Stablecoin.Stablecoin
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Stablecoin.BankState
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Stablecoin.BankState
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Stablecoin.PC
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni a => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contracts.Stablecoin.PC a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Stablecoin.BC
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni a => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contracts.Stablecoin.BC a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Stablecoin.RC
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni a => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contracts.Stablecoin.RC a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Stablecoin.SC
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni a => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contracts.Stablecoin.SC a)
instance Plutus.Contracts.Stablecoin.AsStablecoinError Plutus.Contracts.Stablecoin.StablecoinError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.Stablecoin.StablecoinError
instance Plutus.Contract.StateMachine.AsSMContractError Plutus.Contracts.Stablecoin.StablecoinError
instance PlutusTx.Functor.Functor Plutus.Contracts.Stablecoin.SC
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contracts.Stablecoin.SC a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contracts.Stablecoin.SC a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contracts.Stablecoin.SC a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.Contracts.Stablecoin.SC a)
instance GHC.Generics.Generic (Plutus.Contracts.Stablecoin.SC a)
instance PlutusTx.Numeric.MultiplicativeSemigroup a => PlutusTx.Numeric.MultiplicativeSemigroup (Plutus.Contracts.Stablecoin.SC a)
instance PlutusTx.Numeric.AdditiveSemigroup a => PlutusTx.Numeric.AdditiveSemigroup (Plutus.Contracts.Stablecoin.SC a)
instance PlutusTx.Numeric.AdditiveMonoid a => PlutusTx.Numeric.AdditiveMonoid (Plutus.Contracts.Stablecoin.SC a)
instance PlutusTx.Numeric.AdditiveGroup a => PlutusTx.Numeric.AdditiveGroup (Plutus.Contracts.Stablecoin.SC a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (Plutus.Contracts.Stablecoin.SC a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.Contracts.Stablecoin.SC a)
instance GHC.Num.Num a => GHC.Num.Num (Plutus.Contracts.Stablecoin.SC a)
instance PlutusTx.Functor.Functor Plutus.Contracts.Stablecoin.RC
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contracts.Stablecoin.RC a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contracts.Stablecoin.RC a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contracts.Stablecoin.RC a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.Contracts.Stablecoin.RC a)
instance GHC.Generics.Generic (Plutus.Contracts.Stablecoin.RC a)
instance PlutusTx.Numeric.MultiplicativeSemigroup a => PlutusTx.Numeric.MultiplicativeSemigroup (Plutus.Contracts.Stablecoin.RC a)
instance PlutusTx.Numeric.AdditiveSemigroup a => PlutusTx.Numeric.AdditiveSemigroup (Plutus.Contracts.Stablecoin.RC a)
instance PlutusTx.Numeric.AdditiveMonoid a => PlutusTx.Numeric.AdditiveMonoid (Plutus.Contracts.Stablecoin.RC a)
instance PlutusTx.Numeric.AdditiveGroup a => PlutusTx.Numeric.AdditiveGroup (Plutus.Contracts.Stablecoin.RC a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (Plutus.Contracts.Stablecoin.RC a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.Contracts.Stablecoin.RC a)
instance GHC.Num.Num a => GHC.Num.Num (Plutus.Contracts.Stablecoin.RC a)
instance PlutusTx.Functor.Functor Plutus.Contracts.Stablecoin.BC
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contracts.Stablecoin.BC a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contracts.Stablecoin.BC a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contracts.Stablecoin.BC a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.Contracts.Stablecoin.BC a)
instance GHC.Generics.Generic (Plutus.Contracts.Stablecoin.BC a)
instance PlutusTx.Numeric.MultiplicativeSemigroup a => PlutusTx.Numeric.MultiplicativeSemigroup (Plutus.Contracts.Stablecoin.BC a)
instance PlutusTx.Numeric.AdditiveSemigroup a => PlutusTx.Numeric.AdditiveSemigroup (Plutus.Contracts.Stablecoin.BC a)
instance PlutusTx.Numeric.AdditiveMonoid a => PlutusTx.Numeric.AdditiveMonoid (Plutus.Contracts.Stablecoin.BC a)
instance PlutusTx.Numeric.AdditiveGroup a => PlutusTx.Numeric.AdditiveGroup (Plutus.Contracts.Stablecoin.BC a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (Plutus.Contracts.Stablecoin.BC a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.Contracts.Stablecoin.BC a)
instance GHC.Num.Num a => GHC.Num.Num (Plutus.Contracts.Stablecoin.BC a)
instance PlutusTx.Functor.Functor Plutus.Contracts.Stablecoin.PC
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contracts.Stablecoin.PC a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contracts.Stablecoin.PC a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contracts.Stablecoin.PC a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.Contracts.Stablecoin.PC a)
instance GHC.Generics.Generic (Plutus.Contracts.Stablecoin.PC a)
instance PlutusTx.Numeric.MultiplicativeSemigroup a => PlutusTx.Numeric.MultiplicativeSemigroup (Plutus.Contracts.Stablecoin.PC a)
instance PlutusTx.Numeric.AdditiveSemigroup a => PlutusTx.Numeric.AdditiveSemigroup (Plutus.Contracts.Stablecoin.PC a)
instance PlutusTx.Numeric.AdditiveMonoid a => PlutusTx.Numeric.AdditiveMonoid (Plutus.Contracts.Stablecoin.PC a)
instance PlutusTx.Numeric.AdditiveGroup a => PlutusTx.Numeric.AdditiveGroup (Plutus.Contracts.Stablecoin.PC a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (Plutus.Contracts.Stablecoin.PC a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.Contracts.Stablecoin.PC a)
instance GHC.Num.Num a => GHC.Num.Num (Plutus.Contracts.Stablecoin.PC a)
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Stablecoin.BankState
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Stablecoin.BankState
instance GHC.Show.Show Plutus.Contracts.Stablecoin.BankState
instance GHC.Classes.Eq Plutus.Contracts.Stablecoin.BankState
instance GHC.Generics.Generic Plutus.Contracts.Stablecoin.BankState
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Stablecoin.Stablecoin
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Stablecoin.Stablecoin
instance GHC.Show.Show Plutus.Contracts.Stablecoin.Stablecoin
instance GHC.Classes.Eq Plutus.Contracts.Stablecoin.Stablecoin
instance GHC.Generics.Generic Plutus.Contracts.Stablecoin.Stablecoin
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Stablecoin.SCAction
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Stablecoin.SCAction
instance GHC.Show.Show Plutus.Contracts.Stablecoin.SCAction
instance GHC.Classes.Eq Plutus.Contracts.Stablecoin.SCAction
instance GHC.Generics.Generic Plutus.Contracts.Stablecoin.SCAction
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Stablecoin.Input
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Stablecoin.Input
instance GHC.Show.Show Plutus.Contracts.Stablecoin.Input
instance GHC.Classes.Eq Plutus.Contracts.Stablecoin.Input
instance GHC.Generics.Generic Plutus.Contracts.Stablecoin.Input
instance GHC.Show.Show Plutus.Contracts.Stablecoin.InvalidStateReason
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Stablecoin.StablecoinError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Stablecoin.StablecoinError
instance GHC.Generics.Generic Plutus.Contracts.Stablecoin.StablecoinError
instance GHC.Show.Show Plutus.Contracts.Stablecoin.StablecoinError

module Plutus.Contracts.Swap

-- | A swap is an agreement to exchange cashflows at future dates. To keep
--   things simple, this is an interest rate swap (meaning that the
--   cashflows are interest payments on the same principal amount but with
--   two different interest rates, of which one is fixed and one is
--   floating (varying with time)) with only a single payment date.
--   
--   At the beginning of the contract, the fixed rate is set to the
--   expected future value of the floating rate (so if the floating rate
--   behaves as expected, the two payments will be exactly equal).
data Swap
Swap :: !Ada -> !POSIXTime -> !Rational -> !Rational -> !Ada -> PaymentPubKey -> Swap
[swapNotionalAmt] :: Swap -> !Ada
[swapObservationTime] :: Swap -> !POSIXTime

-- | Interest rate fixed at the beginning of the contract
[swapFixedRate] :: Swap -> !Rational

-- | Interest rate whose value will be observed (by an oracle) on the day
--   of the payment
[swapFloatingRate] :: Swap -> !Rational

-- | Margin deposited at the beginning of the contract to protect against
--   default (one party failing to pay)
[swapMargin] :: Swap -> !Ada

-- | Public key of the oracle (see note [Oracles] in [[Plutus.Contracts]]).
--   Unsure why, but this field needs to be non-strict, otherwise GHC will
--   try to unbox the datatype, which will result in a compilation error
--   such as "GHC Core to PLC plugin: E042:Error: Unsupported feature: Type
--   constructor: GHC.Prim.Addr#"
[swapOracle] :: Swap -> PaymentPubKey

-- | Validator script for the two transactions that initialise the swap.
--   See note [Swap Transactions] See note [Contracts and Validator
--   Scripts] in Language.Plutus.Coordination.Contracts
swapValidator :: Swap -> Validator
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Swap.SwapOwners
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Swap.SwapOwners
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Swap.SwapOwners
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Swap.SwapOwners
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Swap.SwapOwners
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Swap.Swap
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Swap.Swap


-- | Plutus implementation of an account that can be unlocked with a token.
--   Whoever owns the token can spend the outputs locked by the contract.
--   (A suitable token can be created with the <a>Currency</a> contract, or
--   with <a>newAccount</a> in this module)
module Plutus.Contracts.TokenAccount
newtype Account
Account :: AssetClass -> Account
[accountOwner] :: Account -> AssetClass

-- | Pay some money to the given token account
pay :: AsTokenAccountError e => Account -> Value -> Contract w s e CardanoTx

-- | Empty the account by spending all outputs belonging to the
--   <a>Account</a>.
redeem :: AsTokenAccountError e => CardanoAddress -> Account -> Contract w s e CardanoTx

-- | Create a new token and return its <a>Account</a> information.
newAccount :: forall w s e. AsTokenAccountError e => TokenName -> CardanoAddress -> Contract w s e Account

-- | <tt>balance account</tt> returns the value of all unspent outputs that
--   can be unlocked with <tt>accountToken account</tt>
balance :: AsTokenAccountError e => Account -> Contract w s e Value
address :: Account -> CardanoAddress
accountToken :: Account -> Value

-- | A transaction that pays the given value to the account
payTx :: Value -> TxConstraints (RedeemerType TokenAccount) (DatumType TokenAccount)

-- | Create a transaction that spends all outputs belonging to the
--   <a>Account</a>.
redeemTx :: forall w s e. AsTokenAccountError e => Account -> CardanoAddress -> Contract w s e (TxConstraints () (), ScriptLookups TokenAccount)
type TokenAccountSchema = Endpoint "redeem" (Account, CardanoAddress) .\/ Endpoint "pay" (Account, Value) .\/ Endpoint "new-account" (TokenName, CardanoAddress)
type HasTokenAccountSchema s = (HasEndpoint "redeem" (Account, CardanoAddress) s, HasEndpoint "pay" (Account, Value) s, HasEndpoint "new-account" (TokenName, CardanoAddress) s)

-- | <a>redeem</a>, <a>pay</a> and <a>newAccount</a> with endpoints.
tokenAccountContract :: forall w s e. (HasTokenAccountSchema s, AsTokenAccountError e) => Contract w s e ()
data TokenAccount
data TokenAccountError
TAContractError :: ContractError -> TokenAccountError
TACurrencyError :: CurrencyError -> TokenAccountError
class AsTokenAccountError r_a5nMf
_TokenAccountError :: AsTokenAccountError r_a5nMf => Prism' r_a5nMf TokenAccountError
_TAContractError :: AsTokenAccountError r_a5nMf => Prism' r_a5nMf ContractError
_TACurrencyError :: AsTokenAccountError r_a5nMf => Prism' r_a5nMf CurrencyError
validatorHash :: Account -> ValidatorHash
typedValidator :: Account -> TypedValidator TokenAccount
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.TokenAccount.Account
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.TokenAccount.Account
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.TokenAccount.Account
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.TokenAccount.Account
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.TokenAccount.Account
instance Plutus.Contracts.TokenAccount.AsTokenAccountError Plutus.Contracts.TokenAccount.TokenAccountError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.TokenAccount.TokenAccountError
instance Plutus.Contracts.Currency.AsCurrencyError Plutus.Contracts.TokenAccount.TokenAccountError
instance Prettyprinter.Internal.Pretty Plutus.Contracts.TokenAccount.Account
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.TokenAccount.Account
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.TokenAccount.Account
instance GHC.Generics.Generic Plutus.Contracts.TokenAccount.Account
instance GHC.Show.Show Plutus.Contracts.TokenAccount.Account
instance GHC.Classes.Eq Plutus.Contracts.TokenAccount.Account
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.TokenAccount.TokenAccountError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.TokenAccount.TokenAccountError
instance GHC.Generics.Generic Plutus.Contracts.TokenAccount.TokenAccountError
instance GHC.Show.Show Plutus.Contracts.TokenAccount.TokenAccountError
instance GHC.Classes.Eq Plutus.Contracts.TokenAccount.TokenAccountError
instance Plutus.Script.Utils.Typed.ValidatorTypes Plutus.Contracts.TokenAccount.TokenAccount


-- | Minting policy script for credential tokens.
module Plutus.Contracts.Prism.Credential

-- | Entity that is authorised to mint credential tokens
newtype CredentialAuthority
CredentialAuthority :: PaymentPubKeyHash -> CredentialAuthority
[unCredentialAuthority] :: CredentialAuthority -> PaymentPubKeyHash

-- | Named credential issued by a credential authority
data Credential
Credential :: CredentialAuthority -> TokenName -> Credential
[credAuthority] :: Credential -> CredentialAuthority
[credName] :: Credential -> TokenName
policy :: CredentialAuthority -> MintingPolicy

-- | A single credential of the given name
token :: Credential -> Value

-- | A number of credentials of the given name
tokens :: Credential -> Integer -> Value

-- | The <a>Account</a> that can be spent by presenting the credential
tokenAccount :: Credential -> Account
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Prism.Credential.Credential
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Prism.Credential.Credential
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Prism.Credential.Credential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Prism.Credential.Credential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Prism.Credential.Credential
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Prism.Credential.CredentialAuthority
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Prism.Credential.CredentialAuthority
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Prism.Credential.CredentialAuthority
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Prism.Credential.CredentialAuthority
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Prism.Credential.CredentialAuthority
instance Schema.ToSchema Plutus.Contracts.Prism.Credential.CredentialAuthority
instance Data.Hashable.Class.Hashable Plutus.Contracts.Prism.Credential.CredentialAuthority
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Prism.Credential.CredentialAuthority
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Prism.Credential.CredentialAuthority
instance GHC.Classes.Ord Plutus.Contracts.Prism.Credential.CredentialAuthority
instance GHC.Show.Show Plutus.Contracts.Prism.Credential.CredentialAuthority
instance GHC.Classes.Eq Plutus.Contracts.Prism.Credential.CredentialAuthority
instance GHC.Generics.Generic Plutus.Contracts.Prism.Credential.CredentialAuthority
instance Schema.ToSchema Plutus.Contracts.Prism.Credential.Credential
instance Data.Hashable.Class.Hashable Plutus.Contracts.Prism.Credential.Credential
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Prism.Credential.Credential
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Prism.Credential.Credential
instance GHC.Classes.Ord Plutus.Contracts.Prism.Credential.Credential
instance GHC.Show.Show Plutus.Contracts.Prism.Credential.Credential
instance GHC.Classes.Eq Plutus.Contracts.Prism.Credential.Credential
instance GHC.Generics.Generic Plutus.Contracts.Prism.Credential.Credential


-- | State machine that manages credential tokens
module Plutus.Contracts.Prism.StateMachine
data IDState

-- | The credential is active and can be used in transactions
Active :: IDState

-- | The credential has been revoked and can't be used anymore.
Revoked :: IDState
data IDAction

-- | Present the credential in a transaction
PresentCredential :: IDAction

-- | Revoke the credential
RevokeCredential :: IDAction

-- | A <a>Credential</a> issued to a user (public key address)
data UserCredential
UserCredential :: PaymentPubKeyHash -> Credential -> Value -> UserCredential

-- | Address of the credential holder
[ucAddress] :: UserCredential -> PaymentPubKeyHash

-- | The credential
[ucCredential] :: UserCredential -> Credential

-- | The <a>Value</a> containing a token of the credential (this needs to
--   be included here because <a>token</a> is not available in on-chain
--   code)
[ucToken] :: UserCredential -> Value
typedValidator :: UserCredential -> TypedValidator (StateMachine IDState IDAction)
machineClient :: TypedValidator (StateMachine IDState IDAction) -> UserCredential -> StateMachineClient IDState IDAction
mkMachineClient :: CredentialAuthority -> PaymentPubKeyHash -> TokenName -> StateMachineClient IDState IDAction
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Prism.StateMachine.IDAction
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Prism.StateMachine.IDAction
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Prism.StateMachine.IDAction
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Prism.StateMachine.IDState
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Prism.StateMachine.IDState
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Prism.StateMachine.IDState
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Prism.StateMachine.IDAction
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Prism.StateMachine.IDAction
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Prism.StateMachine.IDState
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Prism.StateMachine.IDState
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Prism.StateMachine.UserCredential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Prism.StateMachine.UserCredential
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Prism.StateMachine.IDState
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Prism.StateMachine.IDState
instance GHC.Show.Show Plutus.Contracts.Prism.StateMachine.IDState
instance GHC.Classes.Eq Plutus.Contracts.Prism.StateMachine.IDState
instance GHC.Generics.Generic Plutus.Contracts.Prism.StateMachine.IDState
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Prism.StateMachine.IDAction
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Prism.StateMachine.IDAction
instance GHC.Show.Show Plutus.Contracts.Prism.StateMachine.IDAction
instance GHC.Classes.Eq Plutus.Contracts.Prism.StateMachine.IDAction
instance GHC.Generics.Generic Plutus.Contracts.Prism.StateMachine.IDAction
instance Data.Hashable.Class.Hashable Plutus.Contracts.Prism.StateMachine.UserCredential
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Prism.StateMachine.UserCredential
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Prism.StateMachine.UserCredential
instance GHC.Generics.Generic Plutus.Contracts.Prism.StateMachine.UserCredential
instance GHC.Show.Show Plutus.Contracts.Prism.StateMachine.UserCredential
instance GHC.Classes.Eq Plutus.Contracts.Prism.StateMachine.UserCredential


-- | Two sample that unlock some funds by presenting the credentials. *
--   <a>subscribeSTO</a> uses the credential to participate in an STO *
--   <a>unlockExchange</a> uses the credential to take ownership of funds
--   that were locked by an exchange.
module Plutus.Contracts.Prism.Unlock
data STOSubscriber
STOSubscriber :: Credential -> PaymentPubKeyHash -> TokenName -> Integer -> STOSubscriber
[wCredential] :: STOSubscriber -> Credential
[wSTOIssuer] :: STOSubscriber -> PaymentPubKeyHash
[wSTOTokenName] :: STOSubscriber -> TokenName
[wSTOAmount] :: STOSubscriber -> Integer
type STOSubscriberSchema = Endpoint "sto" STOSubscriber

-- | Obtain a token from the credential manager app, then participate in
--   the STO
subscribeSTO :: forall w s. HasEndpoint "sto" STOSubscriber s => Contract w s UnlockError ()
type UnlockExchangeSchema = Endpoint "unlock from exchange" Credential

-- | Obtain a token from the credential manager app, then use it to unlock
--   funds that were locked by an exchange.
unlockExchange :: forall w s. HasEndpoint "unlock from exchange" Credential s => Contract w s UnlockError ()
data UnlockError
WithdrawEndpointError :: ContractError -> UnlockError
WithdrawTxError :: ContractError -> UnlockError
WithdrawPkError :: ContractError -> UnlockError
GetCredentialStateMachineError :: SMContractError -> UnlockError
GetCredentialTransitionError :: InvalidTransition IDState IDAction -> UnlockError
UnlockExchangeTokenAccError :: TokenAccountError -> UnlockError
UnlockMkTxError :: MkTxError -> UnlockError
instance Plutus.Contracts.Prism.Unlock.AsUnlockError Plutus.Contracts.Prism.Unlock.UnlockError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.Prism.Unlock.UnlockError
instance Schema.ToSchema Plutus.Contracts.Prism.Unlock.STOSubscriber
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Prism.Unlock.STOSubscriber
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Prism.Unlock.STOSubscriber
instance GHC.Show.Show Plutus.Contracts.Prism.Unlock.STOSubscriber
instance GHC.Classes.Eq Plutus.Contracts.Prism.Unlock.STOSubscriber
instance GHC.Generics.Generic Plutus.Contracts.Prism.Unlock.STOSubscriber
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Prism.Unlock.UnlockError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Prism.Unlock.UnlockError
instance GHC.Show.Show Plutus.Contracts.Prism.Unlock.UnlockError
instance GHC.Classes.Eq Plutus.Contracts.Prism.Unlock.UnlockError
instance GHC.Generics.Generic Plutus.Contracts.Prism.Unlock.UnlockError


-- | The Atala Mirror application that initialises the state machine
module Plutus.Contracts.Prism.Mirror
type MirrorSchema = Endpoint "issue" CredentialOwnerReference .\/ Endpoint "revoke" CredentialOwnerReference

-- | Reference to a credential tied to a specific owner (public key
--   address). From this, and the public key of the Mirror instance, we can
--   compute the address of the state machine script that locks the token
--   for the owner.
data CredentialOwnerReference
CredentialOwnerReference :: TokenName -> Wallet -> CredentialOwnerReference
[coTokenName] :: CredentialOwnerReference -> TokenName
[coOwner] :: CredentialOwnerReference -> Wallet
data MirrorError
StateNotFound :: TokenName -> PaymentPubKeyHash -> MirrorError
SetupError :: ContractError -> MirrorError
MirrorEndpointError :: ContractError -> MirrorError
CreateTokenTxError :: ContractError -> MirrorError
StateMachineError :: SMContractError -> MirrorError
mirror :: (HasEndpoint "revoke" CredentialOwnerReference s, HasEndpoint "issue" CredentialOwnerReference s) => Contract w s MirrorError ()
instance Plutus.Contracts.Prism.Mirror.AsMirrorError Plutus.Contracts.Prism.Mirror.MirrorError
instance Plutus.Contract.StateMachine.AsSMContractError Plutus.Contracts.Prism.Mirror.MirrorError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.Prism.Mirror.MirrorError
instance Schema.ToSchema Plutus.Contracts.Prism.Mirror.CredentialOwnerReference
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Prism.Mirror.CredentialOwnerReference
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Prism.Mirror.CredentialOwnerReference
instance GHC.Classes.Ord Plutus.Contracts.Prism.Mirror.CredentialOwnerReference
instance GHC.Show.Show Plutus.Contracts.Prism.Mirror.CredentialOwnerReference
instance GHC.Classes.Eq Plutus.Contracts.Prism.Mirror.CredentialOwnerReference
instance GHC.Generics.Generic Plutus.Contracts.Prism.Mirror.CredentialOwnerReference
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Prism.Mirror.MirrorError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Prism.Mirror.MirrorError
instance GHC.Generics.Generic Plutus.Contracts.Prism.Mirror.MirrorError
instance GHC.Show.Show Plutus.Contracts.Prism.Mirror.MirrorError
instance GHC.Classes.Eq Plutus.Contracts.Prism.Mirror.MirrorError

module Plutus.Contracts.Prism
data STOSubscriber
STOSubscriber :: Credential -> PaymentPubKeyHash -> TokenName -> Integer -> STOSubscriber
[wCredential] :: STOSubscriber -> Credential
[wSTOIssuer] :: STOSubscriber -> PaymentPubKeyHash
[wSTOTokenName] :: STOSubscriber -> TokenName
[wSTOAmount] :: STOSubscriber -> Integer
type STOSubscriberSchema = Endpoint "sto" STOSubscriber
data UnlockError
WithdrawEndpointError :: ContractError -> UnlockError
WithdrawTxError :: ContractError -> UnlockError
WithdrawPkError :: ContractError -> UnlockError
GetCredentialStateMachineError :: SMContractError -> UnlockError
GetCredentialTransitionError :: InvalidTransition IDState IDAction -> UnlockError
UnlockExchangeTokenAccError :: TokenAccountError -> UnlockError
UnlockMkTxError :: MkTxError -> UnlockError

-- | Obtain a token from the credential manager app, then participate in
--   the STO
subscribeSTO :: forall w s. HasEndpoint "sto" STOSubscriber s => Contract w s UnlockError ()
type UnlockExchangeSchema = Endpoint "unlock from exchange" Credential

-- | Obtain a token from the credential manager app, then use it to unlock
--   funds that were locked by an exchange.
unlockExchange :: forall w s. HasEndpoint "unlock from exchange" Credential s => Contract w s UnlockError ()
type MirrorSchema = Endpoint "issue" CredentialOwnerReference .\/ Endpoint "revoke" CredentialOwnerReference

-- | Reference to a credential tied to a specific owner (public key
--   address). From this, and the public key of the Mirror instance, we can
--   compute the address of the state machine script that locks the token
--   for the owner.
data CredentialOwnerReference
CredentialOwnerReference :: TokenName -> Wallet -> CredentialOwnerReference
[coTokenName] :: CredentialOwnerReference -> TokenName
[coOwner] :: CredentialOwnerReference -> Wallet
data MirrorError
StateNotFound :: TokenName -> PaymentPubKeyHash -> MirrorError
SetupError :: ContractError -> MirrorError
MirrorEndpointError :: ContractError -> MirrorError
CreateTokenTxError :: ContractError -> MirrorError
StateMachineError :: SMContractError -> MirrorError
mirror :: (HasEndpoint "revoke" CredentialOwnerReference s, HasEndpoint "issue" CredentialOwnerReference s) => Contract w s MirrorError ()

-- | Named credential issued by a credential authority
data Credential
Credential :: CredentialAuthority -> TokenName -> Credential
[credAuthority] :: Credential -> CredentialAuthority
[credName] :: Credential -> TokenName

-- | A <a>Credential</a> issued to a user (public key address)
data UserCredential
UserCredential :: PaymentPubKeyHash -> Credential -> Value -> UserCredential

-- | Address of the credential holder
[ucAddress] :: UserCredential -> PaymentPubKeyHash

-- | The credential
[ucCredential] :: UserCredential -> Credential

-- | The <a>Value</a> containing a token of the credential (this needs to
--   be included here because <a>token</a> is not available in on-chain
--   code)
[ucToken] :: UserCredential -> Value

-- | Entity that is authorised to mint credential tokens
newtype CredentialAuthority
CredentialAuthority :: PaymentPubKeyHash -> CredentialAuthority
[unCredentialAuthority] :: CredentialAuthority -> PaymentPubKeyHash

-- | The roles that we pass to <a>contract</a>.
data Role

-- | The <a>mirror</a> contract
Mirror :: Role

-- | The <a>subscribeSTO</a> contract
UnlockSTO :: Role

-- | The <a>unlockExchange</a> contract
UnlockExchange :: Role
type PrismSchema = MirrorSchema .\/ STOSubscriberSchema .\/ UnlockExchangeSchema .\/ Endpoint "role" Role
data PrismError
UnlockSTOErr :: UnlockError -> PrismError
MirrorErr :: MirrorError -> PrismError
EPError :: ContractError -> PrismError
UnlockExchangeErr :: UnlockError -> PrismError

-- | A wrapper around the four prism contracts. This is just a workaround
--   for the emulator, where we can only ever run a single <a>Contract</a>.
--   In the PAB we could simply start all four contracts
--   (credentialManager, mirror, subscribeSTO, subscribeExchange)
--   separately.
contract :: Contract () PrismSchema PrismError ()
instance Plutus.Contracts.Prism.AsPrismError Plutus.Contracts.Prism.PrismError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.Prism.PrismError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Prism.Role
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Prism.Role
instance GHC.Show.Show Plutus.Contracts.Prism.Role
instance GHC.Generics.Generic Plutus.Contracts.Prism.Role
instance GHC.Classes.Eq Plutus.Contracts.Prism.Role
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Prism.PrismError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Prism.PrismError
instance GHC.Show.Show Plutus.Contracts.Prism.PrismError
instance GHC.Generics.Generic Plutus.Contracts.Prism.PrismError
instance GHC.Classes.Eq Plutus.Contracts.Prism.PrismError

module Plutus.Contracts.Future

-- | Basic data of a futures contract. <a>Future</a> contains all values
--   that do not change during the lifetime of the contract.
data Future
Future :: POSIXTime -> Integer -> Value -> Value -> PaymentPubKey -> Value -> Future
[ftDeliveryDate] :: Future -> POSIXTime
[ftUnits] :: Future -> Integer
[ftUnitPrice] :: Future -> Value
[ftInitialMargin] :: Future -> Value
[ftPriceOracle] :: Future -> PaymentPubKey

-- | How much a participant loses if they fail to make the required margin
--   payments.
[ftMarginPenalty] :: Future -> Value

-- | The token accounts that represent ownership of the two sides of the
--   future. When the contract is done, payments will be made to these
--   accounts.
data FutureAccounts
FutureAccounts :: Account -> ValidatorHash -> Account -> ValidatorHash -> FutureAccounts

-- | The owner of the "long" account (represented by a token)
[ftoLong] :: FutureAccounts -> Account

-- | Address of the <tt>TokenAccount</tt> validator script for
--   <a>ftoLong</a>. This hash can be derived from <a>ftoLong</a>, but only
--   in off-chain code. We store it here so that we can lift it into
--   on-chain code.
[ftoLongAccount] :: FutureAccounts -> ValidatorHash

-- | The owner of the "short" account (represented by a token).
[ftoShort] :: FutureAccounts -> Account

-- | Address of the <tt>TokenAccount</tt> validator script for
--   <a>ftoShort</a>. The comment on <a>ftoLongAccount</a> applies to this
--   as well.
[ftoShortAccount] :: FutureAccounts -> ValidatorHash
mkAccounts :: Account -> Account -> FutureAccounts
data FutureError

-- | Something went wrong during the setup of the two tokens
TokenSetupFailed :: CurrencyError -> FutureError
StateMachineError :: SMContractError -> FutureError
OtherFutureError :: ContractError -> FutureError

-- | The escrow that initialises the future contract failed
EscrowFailed :: EscrowError -> FutureError

-- | The other party didn't make their payment in time so the contract
--   never started.
EscrowRefunded :: RefundSuccess -> FutureError
type FutureSchema = Endpoint "initialise-future" (FutureSetup, Role) .\/ Endpoint "join-future" (FutureAccounts, FutureSetup) .\/ Endpoint "increase-margin" (Value, Role) .\/ Endpoint "settle-early" (SignedMessage (Observation Value)) .\/ Endpoint "settle-future" (SignedMessage (Observation Value))

-- | The data needed to initialise the futures contract.
data FutureSetup
FutureSetup :: PaymentPubKeyHash -> PaymentPubKeyHash -> POSIXTime -> FutureSetup

-- | Initial owner of the short token
[shortPK] :: FutureSetup -> PaymentPubKeyHash

-- | Initial owner of the long token
[longPK] :: FutureSetup -> PaymentPubKeyHash

-- | Start of the futures contract itself. By this time the setup code has
--   to be finished, otherwise the contract is void.
[contractStart] :: FutureSetup -> POSIXTime

-- | The two roles involved in the contract.
data Role
Long :: Role
Short :: Role
futureContract :: Future -> Contract () FutureSchema FutureError ()
futureStateMachine :: Future -> FutureAccounts -> StateMachine FutureState FutureAction
validator :: Future -> FutureAccounts -> Validator

-- | Initialise the contract by * Generating the tokens for long and short
--   * Setting up an escrow contract for the initial margins * Paying the
--   initial margin for the given role
initialiseFuture :: (HasEndpoint "initialise-future" (FutureSetup, Role) s, AsFutureError e) => Future -> Promise w s e (StateMachineClient FutureState FutureAction)
initialMargin :: Future -> Value
futureAddress :: Future -> FutureAccounts -> Address
tokenFor :: Role -> FutureAccounts -> Value

-- | The initial state of the <a>Future</a> contract
initialState :: Future -> FutureState
typedValidator :: Future -> FutureAccounts -> TypedValidator (StateMachine FutureState FutureAction)

-- | Create two unique tokens that can be used for the short and long
--   positions and return a <a>FutureAccounts</a> value for them.
--   
--   Note that after <a>setupTokens</a> is complete, both tokens will be
--   locked by a public key output belonging to the wallet that ran
--   <a>setupTokens</a>.
setupTokens :: forall w s e. AsFutureError e => Contract w s e FutureAccounts
setupTokensTrace :: EmulatorTrace ()
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Future.FutureAction
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Future.FutureAction
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Future.FutureAction
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Future.FutureAction
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Future.FutureAction
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Future.FutureState
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Future.FutureState
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Future.FutureState
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Future.FutureState
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Future.FutureState
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Future.Role
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Future.Role
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Future.Role
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Future.Role
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Future.Role
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Future.Margins
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Future.Margins
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Future.Margins
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Future.Margins
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Future.Margins
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Future.FutureAccounts
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Future.FutureAccounts
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Future.Future
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Future.Future
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Future.FutureSetup
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Future.FutureSetup
instance GHC.Generics.Generic Plutus.Contracts.Future.FutureSetup
instance GHC.Show.Show Plutus.Contracts.Future.FutureSetup
instance Plutus.Contracts.Future.AsFutureError Plutus.Contracts.Future.FutureError
instance Plutus.Contract.StateMachine.AsSMContractError Plutus.Contracts.Future.FutureError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.Future.FutureError
instance Plutus.Contract.Checkpoint.AsCheckpointError Plutus.Contracts.Future.FutureError
instance Plutus.Contracts.Escrow.AsEscrowError Plutus.Contracts.Future.FutureError
instance GHC.Generics.Generic Plutus.Contracts.Future.Future
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Future.Role
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Future.Role
instance GHC.Show.Show Plutus.Contracts.Future.Role
instance GHC.Generics.Generic Plutus.Contracts.Future.Role
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Future.FutureAccounts
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Future.FutureAccounts
instance GHC.Generics.Generic Plutus.Contracts.Future.FutureAccounts
instance GHC.Show.Show Plutus.Contracts.Future.FutureAccounts
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Future.Margins
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Future.Margins
instance GHC.Generics.Generic Plutus.Contracts.Future.Margins
instance GHC.Show.Show Plutus.Contracts.Future.Margins
instance GHC.Classes.Eq Plutus.Contracts.Future.Margins
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Future.FutureState
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Future.FutureState
instance GHC.Classes.Eq Plutus.Contracts.Future.FutureState
instance GHC.Generics.Generic Plutus.Contracts.Future.FutureState
instance GHC.Show.Show Plutus.Contracts.Future.FutureState
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Future.FutureAction
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Future.FutureAction
instance GHC.Generics.Generic Plutus.Contracts.Future.FutureAction
instance GHC.Show.Show Plutus.Contracts.Future.FutureAction
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Future.FutureError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Future.FutureError
instance GHC.Generics.Generic Plutus.Contracts.Future.FutureError
instance GHC.Show.Show Plutus.Contracts.Future.FutureError
instance PlutusTx.Eq.Eq Plutus.Contracts.Future.FutureState
instance PlutusTx.Eq.Eq Plutus.Contracts.Future.Margins
instance PlutusTx.Eq.Eq Plutus.Contracts.Future.Role


-- | A general-purpose escrow contract in Plutus
module Plutus.Contracts.Tutorial.Escrow
data Escrow
data EscrowError
RedeemFailed :: RedeemFailReason -> EscrowError
RefundFailed :: EscrowError
EContractError :: ContractError -> EscrowError
class AsEscrowError r_a6vqD
_EscrowError :: AsEscrowError r_a6vqD => Prism' r_a6vqD EscrowError
_RedeemFailed :: AsEscrowError r_a6vqD => Prism' r_a6vqD RedeemFailReason
_RefundFailed :: AsEscrowError r_a6vqD => Prism' r_a6vqD ()
_EContractError :: AsEscrowError r_a6vqD => Prism' r_a6vqD ContractError

-- | Definition of an escrow contract, consisting of a deadline and a list
--   of targets
newtype EscrowParams d
EscrowParams :: [EscrowTarget d] -> EscrowParams d

-- | Where the money should go. For each target, the contract checks that
--   the output <tt>mkTxOutput</tt> of the target is present in the
--   spending transaction.
[escrowTargets] :: EscrowParams d -> [EscrowTarget d]

-- | Defines where the money should go. Usually we have `d = Datum` (when
--   defining <a>EscrowTarget</a> values in off-chain code). Sometimes we
--   have `d = DatumHash` (when checking the hashes in on-chain code)
data EscrowTarget d
PaymentPubKeyTarget :: PaymentPubKeyHash -> Value -> EscrowTarget d

-- | An <a>EscrowTarget</a> that pays the value to a public key address.
payToPaymentPubKeyTarget :: PaymentPubKeyHash -> Value -> EscrowTarget d

-- | The total <a>Value</a> that must be paid into the escrow contract
--   before it can be unlocked
targetTotal :: EscrowParams d -> Value
escrowContract :: EscrowParams Datum -> Contract () EscrowSchema EscrowError ()
typedValidator :: EscrowParams Datum -> TypedValidator Escrow

-- | Pay some money into the escrow contract.
pay :: forall w s e. AsContractError e => TypedValidator Escrow -> EscrowParams Datum -> Value -> Contract w s e TxId

-- | <a>pay</a> with an endpoint that gets the owner's public key and the
--   contribution.
payEp :: forall w s e. (HasEndpoint "pay-escrow" Value s, AsEscrowError e) => EscrowParams Datum -> Promise w s e TxId

-- | Redeem all outputs at the contract address using a transaction that
--   has all the outputs defined in the contract's list of targets.
redeem :: forall w s e. AsEscrowError e => TypedValidator Escrow -> EscrowParams Datum -> Contract w s e RedeemSuccess

-- | <a>redeem</a> with an endpoint.
redeemEp :: forall w s e. (HasEndpoint "redeem-escrow" () s, AsEscrowError e) => EscrowParams Datum -> Promise w s e RedeemSuccess

-- | Claim a refund of the contribution.
refund :: forall w s. TypedValidator Escrow -> EscrowParams Datum -> Contract w s EscrowError RefundSuccess

-- | <a>refund</a> with an endpoint.
refundEp :: forall w s. HasEndpoint "refund-escrow" () s => EscrowParams Datum -> Promise w s EscrowError RefundSuccess
data RedeemFailReason
DeadlinePassed :: RedeemFailReason
NotEnoughFundsAtAddress :: RedeemFailReason
newtype RedeemSuccess
RedeemSuccess :: TxId -> RedeemSuccess
newtype RefundSuccess
RefundSuccess :: TxId -> RefundSuccess
type EscrowSchema = Endpoint "pay-escrow" Value .\/ Endpoint "redeem-escrow" () .\/ Endpoint "refund-escrow" ()
data Action
Redeem :: Action
Refund :: Action
covIdx :: CoverageIndex
instance GHC.Show.Show Plutus.Contracts.Tutorial.Escrow.RedeemSuccess
instance GHC.Classes.Eq Plutus.Contracts.Tutorial.Escrow.RedeemSuccess
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Tutorial.Escrow.RefundSuccess
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Tutorial.Escrow.RefundSuccess
instance GHC.Generics.Generic Plutus.Contracts.Tutorial.Escrow.RefundSuccess
instance GHC.Show.Show Plutus.Contracts.Tutorial.Escrow.RefundSuccess
instance GHC.Classes.Eq Plutus.Contracts.Tutorial.Escrow.RefundSuccess
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Tutorial.Escrow.Action
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Tutorial.Escrow.Action
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Tutorial.Escrow.Action
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Tutorial.Escrow.Action
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Tutorial.Escrow.Action
instance Plutus.Script.Utils.Typed.ValidatorTypes Plutus.Contracts.Tutorial.Escrow.Escrow
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Tutorial.Escrow.EscrowParams
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni [Plutus.Contracts.Tutorial.Escrow.EscrowTarget d] => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contracts.Tutorial.Escrow.EscrowParams d)
instance GHC.Base.Functor Plutus.Contracts.Tutorial.Escrow.EscrowParams
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Tutorial.Escrow.EscrowTarget
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni d => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contracts.Tutorial.Escrow.EscrowTarget d)
instance GHC.Base.Functor Plutus.Contracts.Tutorial.Escrow.EscrowTarget
instance Plutus.Contracts.Tutorial.Escrow.AsEscrowError Plutus.Contracts.Tutorial.Escrow.EscrowError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.Tutorial.Escrow.EscrowError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Tutorial.Escrow.RedeemFailReason
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Tutorial.Escrow.RedeemFailReason
instance GHC.Generics.Generic Plutus.Contracts.Tutorial.Escrow.RedeemFailReason
instance GHC.Show.Show Plutus.Contracts.Tutorial.Escrow.RedeemFailReason
instance GHC.Classes.Eq Plutus.Contracts.Tutorial.Escrow.RedeemFailReason
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Tutorial.Escrow.EscrowError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Tutorial.Escrow.EscrowError
instance GHC.Generics.Generic Plutus.Contracts.Tutorial.Escrow.EscrowError
instance GHC.Show.Show Plutus.Contracts.Tutorial.Escrow.EscrowError


-- | A general-purpose escrow contract in Plutus
module Plutus.Contracts.Tutorial.EscrowStrict
data Escrow
data EscrowError
RedeemFailed :: RedeemFailReason -> EscrowError
RefundFailed :: EscrowError
EContractError :: ContractError -> EscrowError
class AsEscrowError r_a6JgP
_EscrowError :: AsEscrowError r_a6JgP => Prism' r_a6JgP EscrowError
_RedeemFailed :: AsEscrowError r_a6JgP => Prism' r_a6JgP RedeemFailReason
_RefundFailed :: AsEscrowError r_a6JgP => Prism' r_a6JgP ()
_EContractError :: AsEscrowError r_a6JgP => Prism' r_a6JgP ContractError

-- | Definition of an escrow contract, consisting of a deadline and a list
--   of targets
data EscrowParams d
EscrowParams :: [EscrowTarget d] -> EscrowParams d

-- | Where the money should go. For each target, the contract checks that
--   the output <tt>mkTxOutput</tt> of the target is present in the
--   spending transaction.
[escrowTargets] :: EscrowParams d -> [EscrowTarget d]

-- | Defines where the money should go. Usually we have `d = Datum` (when
--   defining <a>EscrowTarget</a> values in off-chain code). Sometimes we
--   have `d = DatumHash` (when checking the hashes in on-chain code)
data EscrowTarget d
PaymentPubKeyTarget :: PaymentPubKeyHash -> Value -> EscrowTarget d
ScriptTarget :: ValidatorHash -> d -> Value -> EscrowTarget d

-- | An <a>EscrowTarget</a> that pays the value to a script address, with
--   the given data script.
payToScriptTarget :: ValidatorHash -> Datum -> Value -> EscrowTarget Datum

-- | An <a>EscrowTarget</a> that pays the value to a public key address.
payToPaymentPubKeyTarget :: PaymentPubKeyHash -> Value -> EscrowTarget d

-- | The total <a>Value</a> that must be paid into the escrow contract
--   before it can be unlocked
targetTotal :: EscrowParams d -> Value
escrowContract :: EscrowParams Datum -> Contract () EscrowSchema EscrowError ()
typedValidator :: EscrowParams Datum -> TypedValidator Escrow

-- | Pay some money into the escrow contract.
pay :: forall w s e. AsContractError e => TypedValidator Escrow -> EscrowParams Datum -> Value -> Contract w s e TxId

-- | <a>pay</a> with an endpoint that gets the owner's public key and the
--   contribution.
payEp :: forall w s e. (HasEndpoint "pay-escrow" Value s, AsEscrowError e) => EscrowParams Datum -> Promise w s e TxId

-- | Redeem all outputs at the contract address using a transaction that
--   has all the outputs defined in the contract's list of targets.
redeem :: forall w s e. AsEscrowError e => TypedValidator Escrow -> EscrowParams Datum -> Contract w s e RedeemSuccess

-- | <a>redeem</a> with an endpoint.
redeemEp :: forall w s e. (HasEndpoint "redeem-escrow" () s, AsEscrowError e) => EscrowParams Datum -> Promise w s e RedeemSuccess

-- | Claim a refund of the contribution.
refund :: forall w s. TypedValidator Escrow -> EscrowParams Datum -> Contract w s EscrowError RefundSuccess

-- | <a>refund</a> with an endpoint.
refundEp :: forall w s. HasEndpoint "refund-escrow" () s => EscrowParams Datum -> Promise w s EscrowError RefundSuccess
data RedeemFailReason
DeadlinePassed :: RedeemFailReason
NotEnoughFundsAtAddress :: RedeemFailReason
newtype RedeemSuccess
RedeemSuccess :: TxId -> RedeemSuccess
newtype RefundSuccess
RefundSuccess :: TxId -> RefundSuccess
type EscrowSchema = Endpoint "pay-escrow" Value .\/ Endpoint "redeem-escrow" () .\/ Endpoint "refund-escrow" ()
data Action
Redeem :: Action
Refund :: Action
instance GHC.Show.Show Plutus.Contracts.Tutorial.EscrowStrict.RedeemSuccess
instance GHC.Classes.Eq Plutus.Contracts.Tutorial.EscrowStrict.RedeemSuccess
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Tutorial.EscrowStrict.RefundSuccess
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Tutorial.EscrowStrict.RefundSuccess
instance GHC.Generics.Generic Plutus.Contracts.Tutorial.EscrowStrict.RefundSuccess
instance GHC.Show.Show Plutus.Contracts.Tutorial.EscrowStrict.RefundSuccess
instance GHC.Classes.Eq Plutus.Contracts.Tutorial.EscrowStrict.RefundSuccess
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Tutorial.EscrowStrict.Action
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Tutorial.EscrowStrict.Action
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Tutorial.EscrowStrict.Action
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Tutorial.EscrowStrict.Action
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Tutorial.EscrowStrict.Action
instance Plutus.Script.Utils.Typed.ValidatorTypes Plutus.Contracts.Tutorial.EscrowStrict.Escrow
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Tutorial.EscrowStrict.EscrowParams
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni d, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni [Plutus.Contracts.Tutorial.EscrowStrict.EscrowTarget d]) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contracts.Tutorial.EscrowStrict.EscrowParams d)
instance GHC.Base.Functor Plutus.Contracts.Tutorial.EscrowStrict.EscrowParams
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Tutorial.EscrowStrict.EscrowTarget
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni d, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni d) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contracts.Tutorial.EscrowStrict.EscrowTarget d)
instance GHC.Base.Functor Plutus.Contracts.Tutorial.EscrowStrict.EscrowTarget
instance Plutus.Contracts.Tutorial.EscrowStrict.AsEscrowError Plutus.Contracts.Tutorial.EscrowStrict.EscrowError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.Tutorial.EscrowStrict.EscrowError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Tutorial.EscrowStrict.RedeemFailReason
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Tutorial.EscrowStrict.RedeemFailReason
instance GHC.Generics.Generic Plutus.Contracts.Tutorial.EscrowStrict.RedeemFailReason
instance GHC.Show.Show Plutus.Contracts.Tutorial.EscrowStrict.RedeemFailReason
instance GHC.Classes.Eq Plutus.Contracts.Tutorial.EscrowStrict.RedeemFailReason
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Tutorial.EscrowStrict.EscrowError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Tutorial.EscrowStrict.EscrowError
instance GHC.Generics.Generic Plutus.Contracts.Tutorial.EscrowStrict.EscrowError
instance GHC.Show.Show Plutus.Contracts.Tutorial.EscrowStrict.EscrowError

module Plutus.Contracts.Uniswap.Types

-- | Uniswap coin token
data U
U :: U

-- | <a>A</a>-side coin token
data A
A :: A

-- | <a>B</a>-side coin token
data B
B :: B

-- | Pool-state coin token
data PoolState
PoolState :: PoolState

-- | Liquidity-state coin token
data Liquidity
Liquidity :: Liquidity

-- | A single <a>AssetClass</a>. Because we use three coins, we use a
--   phantom type to track which one is which.
newtype Coin a
Coin :: AssetClass -> Coin a
[unCoin] :: Coin a -> AssetClass

-- | Likewise for <a>Integer</a>; the corresponding amount we have of the
--   particular <a>Coin</a>.
newtype Amount a
Amount :: Integer -> Amount a
[unAmount] :: Amount a -> Integer
valueOf :: Coin a -> Amount a -> Value
unitValue :: Coin a -> Value
isUnity :: Value -> Coin a -> Bool
amountOf :: Value -> Coin a -> Amount a
mkCoin :: CurrencySymbol -> TokenName -> Coin a
newtype Uniswap
Uniswap :: Coin U -> Uniswap
[usCoin] :: Uniswap -> Coin U
data LiquidityPool
LiquidityPool :: Coin A -> Coin B -> LiquidityPool
[lpCoinA] :: LiquidityPool -> Coin A
[lpCoinB] :: LiquidityPool -> Coin B
data UniswapAction
Create :: LiquidityPool -> UniswapAction
Close :: UniswapAction
Swap :: UniswapAction
Remove :: UniswapAction
Add :: UniswapAction
data UniswapDatum
Factory :: [LiquidityPool] -> UniswapDatum
Pool :: LiquidityPool -> Amount Liquidity -> UniswapDatum
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.UniswapDatum
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.UniswapDatum
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Uniswap.Types.UniswapDatum
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Uniswap.Types.UniswapDatum
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Uniswap.Types.UniswapDatum
instance GHC.Show.Show Plutus.Contracts.Uniswap.Types.UniswapDatum
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.UniswapAction
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.UniswapAction
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Uniswap.Types.UniswapAction
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Uniswap.Types.UniswapAction
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Uniswap.Types.UniswapAction
instance GHC.Show.Show Plutus.Contracts.Uniswap.Types.UniswapAction
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.LiquidityPool
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.LiquidityPool
instance PlutusTx.Eq.Eq Plutus.Contracts.Uniswap.Types.LiquidityPool
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Uniswap.Types.LiquidityPool
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Uniswap.Types.LiquidityPool
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Uniswap.Types.LiquidityPool
instance Data.Data.Data Plutus.Contracts.Uniswap.Types.LiquidityPool
instance Schema.ToSchema Plutus.Contracts.Uniswap.Types.LiquidityPool
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Uniswap.Types.LiquidityPool
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Uniswap.Types.LiquidityPool
instance GHC.Generics.Generic Plutus.Contracts.Uniswap.Types.LiquidityPool
instance GHC.Show.Show Plutus.Contracts.Uniswap.Types.LiquidityPool
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.Uniswap
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.Uniswap
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Uniswap.Types.Uniswap
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Uniswap.Types.Uniswap
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Uniswap.Types.Uniswap
instance GHC.Classes.Ord Plutus.Contracts.Uniswap.Types.Uniswap
instance GHC.Classes.Eq Plutus.Contracts.Uniswap.Types.Uniswap
instance Data.OpenApi.Internal.Schema.ToSchema Plutus.Contracts.Uniswap.Types.Uniswap
instance Schema.ToSchema Plutus.Contracts.Uniswap.Types.Uniswap
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Uniswap.Types.Uniswap
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Uniswap.Types.Uniswap
instance Data.Data.Data Plutus.Contracts.Uniswap.Types.Uniswap
instance GHC.Generics.Generic Plutus.Contracts.Uniswap.Types.Uniswap
instance GHC.Show.Show Plutus.Contracts.Uniswap.Types.Uniswap
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.Amount
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contracts.Uniswap.Types.Amount a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.Contracts.Uniswap.Types.Amount a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.Contracts.Uniswap.Types.Amount a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.Contracts.Uniswap.Types.Amount a)
instance PlutusTx.Numeric.MultiplicativeSemigroup (Plutus.Contracts.Uniswap.Types.Amount a)
instance PlutusTx.Numeric.AdditiveSemigroup (Plutus.Contracts.Uniswap.Types.Amount a)
instance PlutusTx.Numeric.AdditiveMonoid (Plutus.Contracts.Uniswap.Types.Amount a)
instance PlutusTx.Numeric.AdditiveGroup (Plutus.Contracts.Uniswap.Types.Amount a)
instance GHC.Num.Num (Plutus.Contracts.Uniswap.Types.Amount a)
instance GHC.Classes.Ord (Plutus.Contracts.Uniswap.Types.Amount a)
instance GHC.Classes.Eq (Plutus.Contracts.Uniswap.Types.Amount a)
instance Text.Printf.PrintfArg (Plutus.Contracts.Uniswap.Types.Amount a)
instance PlutusTx.Ord.Ord (Plutus.Contracts.Uniswap.Types.Amount a)
instance PlutusTx.Eq.Eq (Plutus.Contracts.Uniswap.Types.Amount a)
instance Schema.ToSchema (Plutus.Contracts.Uniswap.Types.Amount a)
instance Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contracts.Uniswap.Types.Amount a)
instance Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contracts.Uniswap.Types.Amount a)
instance Data.Data.Data a => Data.Data.Data (Plutus.Contracts.Uniswap.Types.Amount a)
instance GHC.Generics.Generic (Plutus.Contracts.Uniswap.Types.Amount a)
instance GHC.Show.Show (Plutus.Contracts.Uniswap.Types.Amount a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.Coin
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contracts.Uniswap.Types.Coin a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.Contracts.Uniswap.Types.Coin a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.Contracts.Uniswap.Types.Coin a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.Contracts.Uniswap.Types.Coin a)
instance Data.Typeable.Internal.Typeable a => Data.OpenApi.Internal.Schema.ToSchema (Plutus.Contracts.Uniswap.Types.Coin a)
instance GHC.Classes.Ord (Plutus.Contracts.Uniswap.Types.Coin a)
instance GHC.Classes.Eq (Plutus.Contracts.Uniswap.Types.Coin a)
instance PlutusTx.Eq.Eq (Plutus.Contracts.Uniswap.Types.Coin a)
instance Schema.ToSchema (Plutus.Contracts.Uniswap.Types.Coin a)
instance Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contracts.Uniswap.Types.Coin a)
instance Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contracts.Uniswap.Types.Coin a)
instance Data.Data.Data a => Data.Data.Data (Plutus.Contracts.Uniswap.Types.Coin a)
instance GHC.Generics.Generic (Plutus.Contracts.Uniswap.Types.Coin a)
instance GHC.Show.Show (Plutus.Contracts.Uniswap.Types.Coin a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.Liquidity
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.Liquidity
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Uniswap.Types.Liquidity
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Uniswap.Types.Liquidity
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Uniswap.Types.Liquidity
instance Data.Data.Data Plutus.Contracts.Uniswap.Types.Liquidity
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.PoolState
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.PoolState
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Uniswap.Types.PoolState
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Uniswap.Types.PoolState
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Uniswap.Types.PoolState
instance Data.Data.Data Plutus.Contracts.Uniswap.Types.PoolState
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.B
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.B
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Uniswap.Types.B
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Uniswap.Types.B
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Uniswap.Types.B
instance Data.Data.Data Plutus.Contracts.Uniswap.Types.B
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.A
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.A
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Uniswap.Types.A
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Uniswap.Types.A
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Uniswap.Types.A
instance Data.Data.Data Plutus.Contracts.Uniswap.Types.A
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.U
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Uniswap.Types.U
instance PlutusTx.IsData.Class.ToData Plutus.Contracts.Uniswap.Types.U
instance PlutusTx.IsData.Class.FromData Plutus.Contracts.Uniswap.Types.U
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contracts.Uniswap.Types.U
instance Data.Data.Data Plutus.Contracts.Uniswap.Types.U
instance GHC.Generics.Generic Plutus.Contracts.Uniswap.Types.U
instance GHC.Classes.Eq Plutus.Contracts.Uniswap.Types.U
instance GHC.Show.Show Plutus.Contracts.Uniswap.Types.U

module Plutus.Contracts.Uniswap.Pool
calculateAdditionalLiquidity :: Amount A -> Amount B -> Amount Liquidity -> Amount A -> Amount B -> Amount Liquidity

-- | The initial liquidity is 'ceil( sqrt(x*y) )' where <tt>x</tt> is the
--   amount of 'Coin A' and y the amount of 'Coin B'. See Eq. 13 of the
--   Uniswap v2 paper.
calculateInitialLiquidity :: Amount A -> Amount B -> Amount Liquidity

-- | See Definition 3 of
--   <a>https://github.com/runtimeverification/verified-smart-contracts/blob/c40c98d6ae35148b76742aaaa29e6eaa405b2f93/uniswap/x-y-k.pdf</a>.
calculateRemoval :: Amount A -> Amount B -> Amount Liquidity -> Amount Liquidity -> (Amount A, Amount B)

-- | A swap is valid if the fee is computed correctly, and we're swapping
--   some positive amount of A for B. See:
--   <a>https://uniswap.org/whitepaper.pdf</a> Eq (11) (Page 7.)
checkSwap :: Amount A -> Amount B -> Amount A -> Amount B -> Bool

-- | Generate a unique token name for this particular pool; based on the
--   tokens it exchanges. This should be such that looking for a pool
--   exchanging any two tokens always yields a unique name.
lpTicker :: LiquidityPool -> TokenName

module Plutus.Contracts.Uniswap.OnChain
mkUniswapValidator :: Uniswap -> Coin PoolState -> UniswapDatum -> UniswapAction -> ScriptContext -> Bool
validateLiquidityMinting :: Uniswap -> TokenName -> () -> ScriptContext -> Bool

module Plutus.Contracts.Uniswap.OffChain

-- | Gets the <a>Coin</a> used to identity liquidity pools.
poolStateCoinFromUniswapCurrency :: CurrencySymbol -> Coin PoolState

-- | Gets the liquidity token for a given liquidity pool.
liquidityCoin :: CurrencySymbol -> Coin A -> Coin B -> Coin Liquidity

-- | Parameters for the <tt>create</tt>-endpoint, which creates a new
--   liquidity pool.
data CreateParams
CreateParams :: Coin A -> Coin B -> Amount A -> Amount B -> CreateParams

-- | One <a>Coin</a> of the liquidity pair.
[cpCoinA] :: CreateParams -> Coin A

-- | The other <a>Coin</a>.
[cpCoinB] :: CreateParams -> Coin B

-- | Amount of liquidity for the first <a>Coin</a>.
[cpAmountA] :: CreateParams -> Amount A

-- | Amount of liquidity for the second <a>Coin</a>.
[cpAmountB] :: CreateParams -> Amount B

-- | Parameters for the <tt>swap</tt>-endpoint, which allows swaps between
--   the two different coins in a liquidity pool. One of the provided
--   amounts must be positive, the other must be zero.
data SwapParams
SwapParams :: Coin A -> Coin B -> Amount A -> Amount B -> SwapParams

-- | One <a>Coin</a> of the liquidity pair.
[spCoinA] :: SwapParams -> Coin A

-- | The other <a>Coin</a>.
[spCoinB] :: SwapParams -> Coin B

-- | The amount the first <a>Coin</a> that should be swapped.
[spAmountA] :: SwapParams -> Amount A

-- | The amount of the second <a>Coin</a> that should be swapped.
[spAmountB] :: SwapParams -> Amount B

-- | Parameters for the <tt>close</tt>-endpoint, which closes a liquidity
--   pool.
data CloseParams
CloseParams :: Coin A -> Coin B -> CloseParams

-- | One <a>Coin</a> of the liquidity pair.
[clpCoinA] :: CloseParams -> Coin A

-- | The other <a>Coin</a> of the liquidity pair.
[clpCoinB] :: CloseParams -> Coin B

-- | Parameters for the <tt>remove</tt>-endpoint, which removes some
--   liquidity from a liquidity pool.
data RemoveParams
RemoveParams :: Coin A -> Coin B -> Amount Liquidity -> RemoveParams

-- | One <a>Coin</a> of the liquidity pair.
[rpCoinA] :: RemoveParams -> Coin A

-- | The other <a>Coin</a> of the liquidity pair.
[rpCoinB] :: RemoveParams -> Coin B

-- | The amount of liquidity tokens to burn in exchange for liquidity from
--   the pool.
[rpDiff] :: RemoveParams -> Amount Liquidity

-- | Parameters for the <tt>add</tt>-endpoint, which adds liquidity to a
--   liquidity pool in exchange for liquidity tokens.
data AddParams
AddParams :: Coin A -> Coin B -> Amount A -> Amount B -> AddParams

-- | One <a>Coin</a> of the liquidity pair.
[apCoinA] :: AddParams -> Coin A

-- | The other <a>Coin</a> of the liquidity pair.
[apCoinB] :: AddParams -> Coin B

-- | The amount of coins of the first kind to add to the pool.
[apAmountA] :: AddParams -> Amount A

-- | The amount of coins of the second kind to add to the pool.
[apAmountB] :: AddParams -> Amount B

-- | Schema for the endpoints for users of Uniswap.
type UniswapUserSchema = Endpoint "create" CreateParams .\/ Endpoint "swap" SwapParams .\/ Endpoint "close" CloseParams .\/ Endpoint "remove" RemoveParams .\/ Endpoint "add" AddParams .\/ Endpoint "pools" () .\/ Endpoint "funds" () .\/ Endpoint "stop" ()

-- | Type of the Uniswap user contract state.
data UserContractState
Pools :: [((Coin A, Amount A), (Coin B, Amount B))] -> UserContractState
Funds :: Value -> UserContractState
Created :: UserContractState
Swapped :: UserContractState
Added :: UserContractState
Removed :: UserContractState
Closed :: UserContractState
Stopped :: UserContractState
type UniswapOwnerSchema = Endpoint "start" ()

-- | Creates a Uniswap "factory". This factory will keep track of the
--   existing liquidity pools and enforce that there will be at most one
--   liquidity pool for any pair of tokens at any given time.
start :: forall w s. Contract w s Text Uniswap

-- | Creates a liquidity pool for a pair of coins. The creator provides
--   liquidity for both coins and gets liquidity tokens in return.
create :: forall w s. Uniswap -> CreateParams -> Contract w s Text ()

-- | Adds some liquidity to an existing liquidity pool in exchange for
--   newly minted liquidity tokens.
add :: forall w s. Uniswap -> AddParams -> Contract w s Text ()

-- | Removes some liquidity from a liquidity pool in exchange for liquidity
--   tokens.
remove :: forall w s. Uniswap -> RemoveParams -> Contract w s Text ()

-- | Closes a liquidity pool by burning all remaining liquidity tokens in
--   exchange for all liquidity remaining in the pool.
close :: forall w s. Uniswap -> CloseParams -> Contract w s Text ()

-- | Uses a liquidity pool two swap one sort of coins in the pool against
--   the other.
swap :: forall w s. Uniswap -> SwapParams -> Contract w s Text ()

-- | Finds all liquidity pools and their liquidity belonging to the Uniswap
--   instance. This merely inspects the blockchain and does not issue any
--   transactions.
pools :: forall w s. Uniswap -> Contract w s Text [((Coin A, Amount A), (Coin B, Amount B))]
ownerEndpoint :: Contract (Last (Either Text Uniswap)) EmptySchema ContractError ()

-- | Provides the following endpoints for users of a Uniswap instance:
--   
--   <ul>
--   <li><i><tt>create</tt></i> Creates a liquidity pool for a pair of
--   coins. The creator provides liquidity for both coins and gets
--   liquidity tokens in return.</li>
--   <li><i><tt>swap</tt></i> Uses a liquidity pool two swap one sort of
--   coins in the pool against the other.</li>
--   <li><i><tt>close</tt></i> Closes a liquidity pool by burning all
--   remaining liquidity tokens in exchange for all liquidity remaining in
--   the pool.</li>
--   <li><i><tt>remove</tt></i> Removes some liquidity from a liquidity
--   pool in exchange for liquidity tokens.</li>
--   <li><i><tt>add</tt></i> Adds some liquidity to an existing liquidity
--   pool in exchange for newly minted liquidity tokens.</li>
--   <li><i><tt>pools</tt></i> Finds all liquidity pools and their
--   liquidity belonging to the Uniswap instance. This merely inspects the
--   blockchain and does not issue any transactions.</li>
--   <li><i><tt>funds</tt></i> Gets the caller's funds. This merely
--   inspects the blockchain and does not issue any transactions.</li>
--   <li><i><tt>stop</tt></i> Stops the contract.</li>
--   </ul>
userEndpoints :: Uniswap -> Promise (Last (Either Text UserContractState)) UniswapUserSchema Void ()
findSwapA :: Amount A -> Amount B -> Amount A -> Integer
findSwapB :: Amount A -> Amount B -> Amount B -> Integer
covIdx :: CoverageIndex
findUniswapFactoryAndPool :: forall w s. Uniswap -> Coin A -> Coin B -> Contract w s Text ((TxOutRef, DecoratedTxOut, [LiquidityPool]), (TxOutRef, DecoratedTxOut, LiquidityPool, Amount Liquidity))
uniswapInstance :: Uniswap -> TypedValidator Uniswapping
liquidityPolicy :: Uniswap -> MintingPolicy
uniswapScript :: Uniswap -> Validator
poolStateCoin :: Uniswap -> Coin PoolState
liquidityCurrency :: Uniswap -> CurrencySymbol

-- | Generate a unique token name for this particular pool; based on the
--   tokens it exchanges. This should be such that looking for a pool
--   exchanging any two tokens always yields a unique name.
lpTicker :: LiquidityPool -> TokenName

-- | See Definition 3 of
--   <a>https://github.com/runtimeverification/verified-smart-contracts/blob/c40c98d6ae35148b76742aaaa29e6eaa405b2f93/uniswap/x-y-k.pdf</a>.
calculateRemoval :: Amount A -> Amount B -> Amount Liquidity -> Amount Liquidity -> (Amount A, Amount B)

-- | Gets the caller's funds.
funds :: forall w s. Contract w s Text Value
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Uniswap.OffChain.UserContractState
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Uniswap.OffChain.UserContractState
instance GHC.Generics.Generic Plutus.Contracts.Uniswap.OffChain.UserContractState
instance GHC.Show.Show Plutus.Contracts.Uniswap.OffChain.UserContractState
instance Schema.ToSchema Plutus.Contracts.Uniswap.OffChain.CreateParams
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Uniswap.OffChain.CreateParams
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Uniswap.OffChain.CreateParams
instance GHC.Generics.Generic Plutus.Contracts.Uniswap.OffChain.CreateParams
instance GHC.Show.Show Plutus.Contracts.Uniswap.OffChain.CreateParams
instance Schema.ToSchema Plutus.Contracts.Uniswap.OffChain.SwapParams
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Uniswap.OffChain.SwapParams
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Uniswap.OffChain.SwapParams
instance GHC.Generics.Generic Plutus.Contracts.Uniswap.OffChain.SwapParams
instance GHC.Show.Show Plutus.Contracts.Uniswap.OffChain.SwapParams
instance Schema.ToSchema Plutus.Contracts.Uniswap.OffChain.CloseParams
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Uniswap.OffChain.CloseParams
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Uniswap.OffChain.CloseParams
instance GHC.Generics.Generic Plutus.Contracts.Uniswap.OffChain.CloseParams
instance GHC.Show.Show Plutus.Contracts.Uniswap.OffChain.CloseParams
instance Schema.ToSchema Plutus.Contracts.Uniswap.OffChain.RemoveParams
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Uniswap.OffChain.RemoveParams
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Uniswap.OffChain.RemoveParams
instance GHC.Generics.Generic Plutus.Contracts.Uniswap.OffChain.RemoveParams
instance GHC.Show.Show Plutus.Contracts.Uniswap.OffChain.RemoveParams
instance Schema.ToSchema Plutus.Contracts.Uniswap.OffChain.AddParams
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Uniswap.OffChain.AddParams
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Uniswap.OffChain.AddParams
instance GHC.Generics.Generic Plutus.Contracts.Uniswap.OffChain.AddParams
instance GHC.Show.Show Plutus.Contracts.Uniswap.OffChain.AddParams
instance Plutus.Script.Utils.Typed.ValidatorTypes Plutus.Contracts.Uniswap.OffChain.Uniswapping


-- | Example trace for the uniswap contract
module Plutus.Contracts.Uniswap.Trace

-- | Set up a liquidity pool and call the "add" endpoint
uniswapTrace :: EmulatorTrace ()

-- | Create some sample tokens and distribute them to the emulated wallets
setupTokens :: Contract (Maybe (Last OneShotCurrency)) CurrencySchema CurrencyError ()
tokenNames :: [TokenName]
wallets :: [Wallet]


-- | A decentralized exchange for arbitrary token pairs following the
--   <a>Uniswap protocol</a>.
--   
--   Details:
--   
--   <ul>
--   <li><tt>OffChain</tt> contains the instance endpoints and client
--   functionality</li>
--   <li><tt>OnChain</tt> contains the validation logic</li>
--   <li><tt>Types</tt> conains a few common datatypes for working with
--   this contract</li>
--   <li><a>Pool</a> contains functions needed by both on-chain and
--   off-chain code related to working with liquidity pools.</li>
--   </ul>
module Plutus.Contracts.Uniswap

module Plutus.Contracts.Vesting

-- | A vesting scheme consisting of two tranches. Each tranche defines a
--   date (POSIX time) after which an additional amount can be spent.
data VestingParams
VestingParams :: VestingTranche -> VestingTranche -> PaymentPubKeyHash -> VestingParams
[vestingTranche1] :: VestingParams -> VestingTranche
[vestingTranche2] :: VestingParams -> VestingTranche
[vestingOwner] :: VestingParams -> PaymentPubKeyHash

-- | A simple vesting scheme. Money is locked by a contract and may only be
--   retrieved after some time has passed.
--   
--   This is our first example of a contract that covers multiple
--   transactions, with a contract state that changes over time.
--   
--   In our vesting scheme the money will be released in two _tranches_
--   (parts): A smaller part will be available after an initial number of
--   time has passed, and the entire amount will be released at the end.
--   The owner of the vesting scheme does not have to take out all the
--   money at once: They can take out any amount up to the total that has
--   been released so far. The remaining funds stay locked and can be
--   retrieved later.
--   
--   Let's start with the data types.
type VestingSchema = Endpoint "vest funds" () .\/ Endpoint "retrieve funds" Value

-- | Tranche of a vesting scheme.
data VestingTranche
VestingTranche :: POSIXTime -> Value -> VestingTranche
[vestingTrancheDate] :: VestingTranche -> POSIXTime
[vestingTrancheAmount] :: VestingTranche -> Value
data VestingError
VContractError :: ContractError -> VestingError
InsufficientFundsError :: Value -> Value -> Value -> VestingError
class AsVestingError r_a7ST5
_VestingError :: AsVestingError r_a7ST5 => Prism' r_a7ST5 VestingError
_VContractError :: AsVestingError r_a7ST5 => Prism' r_a7ST5 ContractError
_InsufficientFundsError :: AsVestingError r_a7ST5 => Prism' r_a7ST5 (Value, Value, Value)

-- | The total amount vested
totalAmount :: VestingParams -> Value
vestingContract :: VestingParams -> Contract () VestingSchema VestingError ()
validate :: VestingParams -> () -> () -> ScriptContext -> Bool
vestingScript :: VestingParams -> Validator
instance Plutus.Contracts.Vesting.AsVestingError Plutus.Contracts.Vesting.VestingError
instance Plutus.Contract.Error.AsContractError Plutus.Contracts.Vesting.VestingError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contracts.Vesting.VestingError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contracts.Vesting.VestingError
instance GHC.Generics.Generic Plutus.Contracts.Vesting.VestingError
instance GHC.Show.Show Plutus.Contracts.Vesting.VestingError
instance GHC.Classes.Eq Plutus.Contracts.Vesting.VestingError
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Vesting.VestingParams
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Vesting.VestingParams
instance GHC.Generics.Generic Plutus.Contracts.Vesting.VestingParams
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Vesting.VestingTranche
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contracts.Vesting.VestingTranche
instance GHC.Generics.Generic Plutus.Contracts.Vesting.VestingTranche
instance Plutus.Script.Utils.Typed.ValidatorTypes Plutus.Contracts.Vesting.Vesting

-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Indexers that can rewind the state to a previous version.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/rewindable-index#README.md</a>
@package rewindable-index
@version 1.1.0.0

module RewindableIndex.Index.VSplit
data SplitIndex m h v e n q r
SplitIndex :: h -> Storage v m e -> [n] -> (SplitIndex m h v e n q r -> m ()) -> (SplitIndex m h v e n q r -> q -> [e] -> m r) -> (SplitIndex m h v e n q r -> e -> m [n]) -> SplitIndex m h v e n q r
[_handle] :: SplitIndex m h v e n q r -> h
[_storage] :: SplitIndex m h v e n q r -> Storage v m e
[_notifications] :: SplitIndex m h v e n q r -> [n]
[_store] :: SplitIndex m h v e n q r -> SplitIndex m h v e n q r -> m ()
[_query] :: SplitIndex m h v e n q r -> SplitIndex m h v e n q r -> q -> [e] -> m r
[_onInsert] :: SplitIndex m h v e n q r -> SplitIndex m h v e n q r -> e -> m [n]
new :: Monad m => MVector (Mutable v) e => (SplitIndex m h v e n q r -> q -> [e] -> m r) -> (SplitIndex m h v e n q r -> m ()) -> (SplitIndex m h v e n q r -> e -> m [n]) -> Int -> h -> Mutable v (PrimState m) e -> m (Maybe (SplitIndex m h v e n q r))
newBoxed :: Monad m => PrimMonad m => (BoxedIndex m h e n q r -> q -> [e] -> m r) -> (BoxedIndex m h e n q r -> m ()) -> (BoxedIndex m h e n q r -> e -> m [n]) -> Int -> Int -> h -> m (Maybe (BoxedIndex m h e n q r))
newUnboxed :: Monad m => PrimMonad m => MVector MVector e => (UnboxedIndex m h e n q r -> q -> [e] -> m r) -> (UnboxedIndex m h e n q r -> m ()) -> (UnboxedIndex m h e n q r -> e -> m [n]) -> Int -> Int -> h -> m (Maybe (UnboxedIndex m h e n q r))
insert :: forall m h v e n q r. Monad m => PrimMonad m => MVector (Mutable v) e => e -> SplitIndex m h v e n q r -> m (SplitIndex m h v e n q r)
insertL :: PrimMonad m => MVector (Mutable v) e => [e] -> SplitIndex m h v e n q r -> m (SplitIndex m h v e n q r)
size :: SplitIndex m h v e n q r -> Int
rewind :: MVector (Mutable v) e => Int -> SplitIndex m h v e n q r -> Maybe (SplitIndex m h v e n q r)
handle :: forall m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV. Lens' (SplitIndex m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV) h_a8VQ
storage :: forall m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV. Lens' (SplitIndex m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV) (Storage v_a8VR m_a8VP e_a8VS)
notifications :: forall m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV. Lens' (SplitIndex m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV) [n_a8VT]
store :: forall m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV. Lens' (SplitIndex m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV) (SplitIndex m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV -> m_a8VP ())
query :: forall m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV. Lens' (SplitIndex m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV) (SplitIndex m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV -> q_a8VU -> [e_a8VS] -> m_a8VP r_a8VV)
onInsert :: forall m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV. Lens' (SplitIndex m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV) (SplitIndex m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV -> e_a8VS -> m_a8VP [n_a8VT])
data Storage v m e
Storage :: Mutable v (PrimState m) e -> Int -> Int -> Int -> Int -> Storage v m e
[_events] :: Storage v m e -> Mutable v (PrimState m) e
[_cursor] :: Storage v m e -> Int
[_eSize] :: Storage v m e -> Int
[_bSize] :: Storage v m e -> Int
[_k] :: Storage v m e -> Int
getBuffer :: forall v m e. MVector (Mutable v) e => PrimMonad m => Show e => Storage v m e -> m [e]
getEvents :: forall v m e. MVector (Mutable v) e => PrimMonad m => Show e => Storage v m e -> m [e]
k :: forall v_a7oc m_a7od e_a7oe. Lens' (Storage v_a7oc m_a7od e_a7oe) Int

module RewindableIndex.Index.VSqlite
type SqliteIndex e n q r = SplitIndex IO Connection Vector e n q r
new :: (SqliteIndex e n q r -> q -> [e] -> IO r) -> (SqliteIndex e n q r -> IO ()) -> (SqliteIndex e n q r -> e -> IO [n]) -> Int -> FilePath -> Mutable Vector (PrimState IO) e -> IO (Maybe (SqliteIndex e n q r))
newBoxed :: (BoxedIndex e n q r -> q -> [e] -> IO r) -> (BoxedIndex e n q r -> IO ()) -> (BoxedIndex e n q r -> e -> IO [n]) -> Int -> Int -> FilePath -> IO (Maybe (BoxedIndex e n q r))
insert :: forall m h v e n q r. Monad m => PrimMonad m => MVector (Mutable v) e => e -> SplitIndex m h v e n q r -> m (SplitIndex m h v e n q r)
insertL :: PrimMonad m => MVector (Mutable v) e => [e] -> SplitIndex m h v e n q r -> m (SplitIndex m h v e n q r)
size :: SplitIndex m h v e n q r -> Int
rewind :: MVector (Mutable v) e => Int -> SplitIndex m h v e n q r -> Maybe (SplitIndex m h v e n q r)
getEvents :: forall v m e. MVector (Mutable v) e => PrimMonad m => Show e => Storage v m e -> m [e]
getBuffer :: forall v m e. MVector (Mutable v) e => PrimMonad m => Show e => Storage v m e -> m [e]
handle :: forall m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV. Lens' (SplitIndex m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV) h_a8VQ
storage :: forall m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV. Lens' (SplitIndex m_a8VP h_a8VQ v_a8VR e_a8VS n_a8VT q_a8VU r_a8VV) (Storage v_a8VR m_a8VP e_a8VS)

module RewindableIndex.Storable
data Config
memoryBufferSize :: Iso' Config Int
data State h
handle :: forall h_ajcd. Lens' (State h_ajcd) h_ajcd
config :: forall h_ajcd. Lens' (State h_ajcd) Config
emptyState :: PrimMonad (StorableMonad h) => Int -> h -> StorableMonad h (State h)
data Storage h
storage :: forall h_ajcd. Lens' (State h_ajcd) (Storage h_ajcd)
events :: forall h_aj8s h_ajbX. Lens (Storage h_aj8s) (Storage h_ajbX) (MVector (PrimState (StorableMonad h_aj8s)) (StorableEvent h_aj8s)) (MVector (PrimState (StorableMonad h_ajbX)) (StorableEvent h_ajbX))
cursor :: forall h_aj8s. Lens' (Storage h_aj8s) Int
getMemoryEvents :: Storage h -> MVector (PrimState (StorableMonad h)) (StorableEvent h)
getEvents :: Buffered h => PrimMonad (StorableMonad h) => State h -> StorableMonad h [StorableEvent h]
filterWithQueryInterval :: forall h. HasPoint (StorableEvent h) (StorablePoint h) => Ord (StorablePoint h) => QueryInterval (StorablePoint h) -> [StorableEvent h] -> [StorableEvent h]
data family StorableEvent h
type family StorablePoint h
data family StorableQuery h
data family StorableResult h
type family StorableMonad h :: * -> *
data QueryInterval p
QEverything :: QueryInterval p
QInterval :: p -> p -> QueryInterval p
class Buffered h
persistToStorage :: (Buffered h, Foldable f) => f (StorableEvent h) -> h -> StorableMonad h h
getStoredEvents :: Buffered h => h -> StorableMonad h [StorableEvent h]
class Queryable h
queryStorage :: (Queryable h, Foldable f) => QueryInterval (StorablePoint h) -> f (StorableEvent h) -> h -> StorableQuery h -> StorableMonad h (StorableResult h)
class Resumable h
resumeFromStorage :: Resumable h => h -> StorableMonad h [StorablePoint h]
class Rewindable h
rewindStorage :: Rewindable h => StorablePoint h -> h -> StorableMonad h (Maybe h)
class HasPoint e p
getPoint :: HasPoint e p => e -> p
insert :: Buffered h => PrimMonad (StorableMonad h) => StorableEvent h -> State h -> StorableMonad h (State h)
insertMany :: Foldable f => Buffered h => PrimMonad (StorableMonad h) => f (StorableEvent h) -> State h -> StorableMonad h (State h)
rewind :: forall h. Rewindable h => HasPoint (StorableEvent h) (StorablePoint h) => PrimMonad (StorableMonad h) => Eq (StorablePoint h) => StorablePoint h -> State h -> StorableMonad h (Maybe (State h))
resume :: Resumable h => State h -> StorableMonad h [StorablePoint h]
query :: HasPoint (StorableEvent h) (StorablePoint h) => Ord (StorablePoint h) => Queryable h => PrimMonad (StorableMonad h) => QueryInterval (StorablePoint h) -> State h -> StorableQuery h -> StorableMonad h (StorableResult h)
instance GHC.Generics.Generic (RewindableIndex.Storable.QueryInterval p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (RewindableIndex.Storable.QueryInterval p)
instance GHC.Show.Show p => GHC.Show.Show (RewindableIndex.Storable.QueryInterval p)
instance GHC.Classes.Eq RewindableIndex.Storable.Config
instance GHC.Show.Show RewindableIndex.Storable.Config

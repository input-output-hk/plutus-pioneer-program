<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Testing Plutus Contracts with Contract Models &mdash; Plutus Tools SDK User Guide 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="How-to guides" href="../howtos/index.html" />
    <link rel="prev" title="Property-based testing of Plutus contracts" href="contract-testing.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #fcfcfc" >
            <a href="../../index.html" class="icon icon-home"> Plutus Tools SDK User Guide
            <img src="../../_static/cardano-logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Explore Plutus</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../explanations/index.html">Explanations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html">Plutus tools in development</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html#logical-components">Logical components</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html#marconi">1. Marconi</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html#plutus-use-case-examples">2. Plutus use case examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html#pab-plutus-application-backend">3. PAB (Plutus application backend)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html#contract-monad-emulator">4. Contract monad emulator</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html#plutus-contract-model-testing">5. Plutus contract model testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html#plutus-contract-state-machine">6. Plutus contract state machine</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html#contract-api-also-known-as-contract-monad">7. Contract API (also known as Contract monad)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html#plutus-chain-index">8. Plutus chain index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html#plutus-ledger-constraints">9. Plutus ledger constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html#plutus-tx-constraints">10. Plutus Tx constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html#id10">11. Plutus ledger</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/plutus-tools-component-descriptions.html#plutus-script-utils">12. Plutus script utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../explanations/rollback.html">What is a rollback?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../explanations/rollback.html#what-does-this-mean-for-dapps">What does this mean for dapps?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../explanations/pab.html">What is the PAB?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../explanations/pab.html#client-interface">Client interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../explanations/pab.html#other-components">Other components</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../explanations/pab.html#chain-index">Chain index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/pab.html#alonzo-node">Alonzo node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/pab.html#wallet">Wallet</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../explanations/pab.html#deployment-scenarios">Deployment Scenarios</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../explanations/pab.html#hosted">Hosted</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/pab.html#in-browser">In-browser</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../explanations/order-book-pattern.html">What is the order book pattern?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../explanations/order-book-pattern.html#example-distributed-exchange">Example: Distributed exchange</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../explanations/order-book-pattern.html#orders-and-plutus-scripts">Orders and Plutus scripts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/order-book-pattern.html#decentralisation">Decentralisation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../explanations/order-book-pattern.html#generalising-the-pattern">Generalising the pattern</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../explanations/order-book-pattern.html#off-chain-oracles">Off-chain oracles</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/order-book-pattern.html#on-chain-oracles">On-chain oracles</a></li>
<li class="toctree-l4"><a class="reference internal" href="../explanations/order-book-pattern.html#state-machines">State machines</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../explanations/order-book-pattern.html#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basic-apps.html">Writing a basic Plutus app in an emulated environment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="basic-apps.html#defining-the-types">Defining the types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="basic-apps.html#instances-for-data-types">Instances for data types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="basic-apps.html#defining-the-validator-script">Defining the validator script</a></li>
<li class="toctree-l3"><a class="reference internal" href="basic-apps.html#asking-for-input">Asking for input</a></li>
<li class="toctree-l3"><a class="reference internal" href="basic-apps.html#locking-the-funds">Locking the funds</a></li>
<li class="toctree-l3"><a class="reference internal" href="basic-apps.html#unlocking-the-funds">Unlocking the funds</a></li>
<li class="toctree-l3"><a class="reference internal" href="basic-apps.html#running-the-app-on-the-plutus-apps-emulator">Running the app on the Plutus apps emulator</a></li>
<li class="toctree-l3"><a class="reference internal" href="basic-apps.html#exercise">Exercise</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="basic-apps-constraints.html">Extending the basic Plutus app with the constraints API</a></li>
<li class="toctree-l2"><a class="reference internal" href="contract-testing.html">Property-based testing of Plutus contracts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contract-testing.html#an-overview-of-the-guessing-game">An overview of the guessing game</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#emulated-wallets">Emulated wallets</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#values-and-tokens">Values and <span class="xref std std-term">tokens</span></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contract-testing.html#introducing-contract-models">Introducing contract models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#generating-actions">Generating actions</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#modelling-expectations">Modelling expectations</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#restricting-test-cases-with-preconditions">Restricting test cases with preconditions</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#performing-actions">Performing actions</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#shrinking-actions">Shrinking Actions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contract-testing.html#debugging-the-model">Debugging the model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#adding-delays-to-test-cases">Adding delays to test cases</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#rerunning-a-failed-test">Rerunning a failed test</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#controlling-the-log-level">Controlling the log-level</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#refining-preconditions">Refining preconditions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contract-testing.html#measuring-and-tuning-distributions">Measuring and tuning distributions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#custom-generators-vs-preconditions">Custom generators vs preconditions</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#instrumenting-contract-models-to-gather-statistics">Instrumenting contract models to gather statistics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contract-testing.html#goal-directed-testing-with-dynamic-logic">Goal-directed testing with dynamic logic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#introducing-the-dynamic-logic-monad">Introducing the dynamic logic monad</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#quantifiers-in-dynamic-logic">Quantifiers in dynamic logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#repeating-a-dynamic-logic-test">Repeating a dynamic logic test</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#something-good-is-always-possible">Something good is always possible</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#monitoring-and-tuning-dynamic-logic-tests">Monitoring and tuning dynamic logic tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#more-dynamic-logic">More dynamic logic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contract-testing.html#limitations">Limitations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#testing-only-via-contract-endpoints">Testing only via <span class="xref std std-term">contract endpoints</span></a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#test-assumptions-on-timing">Test assumptions on timing</a></li>
<li class="toctree-l4"><a class="reference internal" href="contract-testing.html#testing-for-information-leaks">Testing for information leaks</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contract-testing.html#further-examples">Further Examples</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Testing Plutus Contracts with Contract Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basic-contract-models">Basic Contract Models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example-a-simple-escrow-contract">Example: A Simple Escrow Contract</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-contract-model-type">The Contract Model Type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#what-contracts-shall-we-test">What contracts shall we test?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#what-actions-should-tests-perform">What actions should tests perform?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generating-actions">Generating Actions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#running-tests-and-debugging-the-model">Running tests and debugging the model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#analysing-the-distribution-of-tests">Analysing the distribution of tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#parameterising-models-and-dynamic-contract-instances">Parameterising Models and Dynamic Contract Instances</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#adding-an-initial-action-and-test-case-phases">Adding an initial action, and test case phases</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-contract-instances">Dynamic contract instances</a></li>
<li class="toctree-l4"><a class="reference internal" href="#running-our-extended-tests-another-design-issue">Running our extended tests; another design issue</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#testing-no-locked-funds-with-dynamic-logic">Testing “No Locked Funds” with Dynamic Logic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#writing-and-testing-properties-using-dynamic-logic">Writing and testing properties using Dynamic Logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#digression-revisiting-a-design-decision">Digression: revisiting a design decision</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fair-s-fair-unilateral-strategies">Fair’s fair: Unilateral strategies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fixing-the-contract-refunds">Fixing the contract: refunds</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#taking-time-into-account">Taking Time into Account</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#slots-and-posixtime">Slots and POSIXTime</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initialising-the-deadline">Initialising the deadline</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modelling-the-passage-of-time">Modelling the passage of time</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monitoring-and-the-distribution-of-tests">Monitoring and the distribution of tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="#no-locked-funds">No locked funds?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#digression-testing-the-model-alone-for-speed">Digression: testing the model alone for speed</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#measuring-coverage-of-on-chain-code">Measuring coverage of on-chain code</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#adding-a-coverage-index">Adding a coverage index</a></li>
<li class="toctree-l4"><a class="reference internal" href="#measuring-coverage">Measuring coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interpreting-the-coverage-annotations">Interpreting the coverage annotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-generated-coverage-report">The generated coverage report</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#crashes-and-how-to-tolerate-them">Crashes, and how to tolerate them</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id6">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#debugging-the-auction-contract-with-model-assertions">Debugging the Auction contract with model assertions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#modelling-the-auction-contract">Modelling the Auction contract</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">No locked funds?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model-assertions-and-unexpected-expectations">Model assertions, and unexpected expectations.</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crashing-the-auction">Crashing the auction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#coverage-of-the-auction-contract">Coverage of the Auction contract</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">Exercises</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#becoming-level-1-certification-ready">Becoming Level 1 Certification Ready</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id9">Exercises</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../howtos/index.html">How-to guides</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../howtos/getting-started.html">How to get started with the Plutus Platform</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../howtos/getting-started.html#further-reading">Further reading</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../howtos/writing-a-scalable-app.html">How to write a scalable Plutus app</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../howtos/writing-a-scalable-app.html#the-building-blocks">The building blocks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../howtos/writing-a-scalable-app.html#transaction-outputs">Transaction outputs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../howtos/writing-a-scalable-app.html#state-of-transaction-outputs">State of transaction outputs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../howtos/writing-a-scalable-app.html#changing-the-state-of-our-app">Changing the state of our app</a></li>
<li class="toctree-l4"><a class="reference internal" href="../howtos/writing-a-scalable-app.html#minting-policy-scripts">Minting Policy Scripts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../howtos/writing-a-scalable-app.html#scalability-guidelines">Scalability guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howtos/writing-a-scalable-app.html#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../howtos/writing-a-scalable-app.html#decentralised-exchange">Decentralised exchange</a></li>
<li class="toctree-l4"><a class="reference internal" href="../howtos/writing-a-scalable-app.html#marlowe">Marlowe</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../howtos/writing-a-scalable-app.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../howtos/handling-blockchain-events.html">How to handle blockchain events</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../howtos/handling-blockchain-events.html#transaction-output-lifecycle">Transaction output lifecycle</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../howtos/handling-blockchain-events.html#transaction-states">Transaction states</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../howtos/handling-blockchain-events.html#pab-functions-for-listening-to-state-changes">PAB functions for listening to state changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../howtos/analysing-scripts.html">How to analyse the cost and size of Plutus scripts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../howtos/analysing-scripts.html#resource-use-of-plutus-scripts">Resource use of Plutus scripts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howtos/analysing-scripts.html#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../howtos/analysing-scripts.html#validator-scripts">Validator scripts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../howtos/analysing-scripts.html#partial-transactions">Partial transactions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../howtos/plutus-spending-script-example.html">Plutus Scripts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../howtos/plutus-spending-script-example.html#what-is-a-plutus-spending-script">What is a Plutus spending script?</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../howtos/plutus-spending-script-example.html#an-example-of-using-a-plutus-spending-script">An example of using a Plutus spending script</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../troubleshooting.html">Troubleshooting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting.html#error-codes">Error codes</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Architectural decision records</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../adr/index.html">Architectural Decision Records</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0001-record-architecture-decisions.html">ADR 1: Record architectural decisions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0001-record-architecture-decisions.html#authors">Authors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0001-record-architecture-decisions.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0001-record-architecture-decisions.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0001-record-architecture-decisions.html#decision">Decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0001-record-architecture-decisions.html#implications">Implications</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0001-record-architecture-decisions.html#adr-template">ADR template</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0002-repository-standardization.html">ADR 2: Repository Standardization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0002-repository-standardization.html#authors">Authors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0002-repository-standardization.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0002-repository-standardization.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0002-repository-standardization.html#decision">Decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0002-repository-standardization.html#argument">Argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0002-repository-standardization.html#implications">Implications</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0003-marconi-monorepo.html">ADR 3: Move Marconi into a separate repository</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0003-marconi-monorepo.html#authors">Authors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0003-marconi-monorepo.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0003-marconi-monorepo.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0003-marconi-monorepo.html#decision">Decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0003-marconi-monorepo.html#implications">Implications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0003-marconi-monorepo.html#related-decisions">Related Decisions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0004-marconi-initiative.html">ADR 4: Making a case for Marconi</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0004-marconi-initiative.html#author-s">Author(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0004-marconi-initiative.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0004-marconi-initiative.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0004-marconi-initiative.html#design-principles-of-marconi">Design principles of Marconi</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0004-marconi-initiative.html#indexing-solution">Indexing solution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0004-marconi-initiative.html#query-and-storage">Query and storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0004-marconi-initiative.html#identification-of-events">Identification of events</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0004-marconi-initiative.html#event-streams">Event streams</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0005-pab-indexing-solution-integration.html">ADR 5: PAB and indexing component integration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0005-pab-indexing-solution-integration.html#author-s">Author(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0005-pab-indexing-solution-integration.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0005-pab-indexing-solution-integration.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0005-pab-indexing-solution-integration.html#decisions">Decisions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0005-pab-indexing-solution-integration.html#alternative-solutions">Alternative solutions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0005-pab-indexing-solution-integration.html#make-sure-all-components-are-in-sync">Make sure all components are in sync</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0005-pab-indexing-solution-integration.html#add-indexing-specific-functions-in-the-contract-api">Add indexing specific functions in the Contract API</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0005-pab-indexing-solution-integration.html#query-functions-should-interact-with-a-single-source-of-truth">Query functions should interact with a single source of truth</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0005-pab-indexing-solution-integration.html#implications">Implications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0005-pab-indexing-solution-integration.html#notes">Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0006-common-contract-api.html">ADR 6: Common Contract API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0006-common-contract-api.html#authors">Authors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0006-common-contract-api.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0006-common-contract-api.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0006-common-contract-api.html#decision">Decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0006-common-contract-api.html#argument">Argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0006-common-contract-api.html#implications">Implications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0006-common-contract-api.html#notes">Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0007-support-reference-inputs-in-constraint-library.html">ADR 7: Support reference inputs in constraint library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0007-support-reference-inputs-in-constraint-library.html#author-s">Author(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0007-support-reference-inputs-in-constraint-library.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0007-support-reference-inputs-in-constraint-library.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0007-support-reference-inputs-in-constraint-library.html#decision">Decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0007-support-reference-inputs-in-constraint-library.html#argument">Argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0007-support-reference-inputs-in-constraint-library.html#notes">Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0008-support-inline-datums-in-constraint-library.html">ADR 8: Support inline datums in constraint library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0008-support-inline-datums-in-constraint-library.html#author-s">Author(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0008-support-inline-datums-in-constraint-library.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0008-support-inline-datums-in-constraint-library.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0008-support-inline-datums-in-constraint-library.html#decision">Decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0008-support-inline-datums-in-constraint-library.html#argument">Argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0008-support-inline-datums-in-constraint-library.html#notes">Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0009-support-reference-scripts-in-constraint-library.html">ADR 9: Support reference scripts in constraint library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0009-support-reference-scripts-in-constraint-library.html#author-s">Author(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0009-support-reference-scripts-in-constraint-library.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0009-support-reference-scripts-in-constraint-library.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0009-support-reference-scripts-in-constraint-library.html#decision">Decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0009-support-reference-scripts-in-constraint-library.html#argument">Argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0009-support-reference-scripts-in-constraint-library.html#notes">Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0010-marconi-indexer-rollbacks.html">ADR 10: Rolling back on-disk data for Marconi indexers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0010-marconi-indexer-rollbacks.html#author-s">Author(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0010-marconi-indexer-rollbacks.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0010-marconi-indexer-rollbacks.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0010-marconi-indexer-rollbacks.html#decision">Decision</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0010-marconi-indexer-rollbacks.html#events">Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0010-marconi-indexer-rollbacks.html#queries">Queries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0010-marconi-indexer-rollbacks.html#api-design">API Design</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0010-marconi-indexer-rollbacks.html#implementation">Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0011-support-return-and-total-collateral-when-building-transactions.html">ADR 11: Support return and total collateral when building transactions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0011-support-return-and-total-collateral-when-building-transactions.html#author-s">Author(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0011-support-return-and-total-collateral-when-building-transactions.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0011-support-return-and-total-collateral-when-building-transactions.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0011-support-return-and-total-collateral-when-building-transactions.html#decision">Decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0011-support-return-and-total-collateral-when-building-transactions.html#argument">Argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0011-support-return-and-total-collateral-when-building-transactions.html#alternatives">Alternatives</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0011-support-return-and-total-collateral-when-building-transactions.html#notes">Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0012-commit-to-data-types-in-cardano-api.html">ADR 12: Commit to data types in cardano-api</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0012-commit-to-data-types-in-cardano-api.html#author-s">Author(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0012-commit-to-data-types-in-cardano-api.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0012-commit-to-data-types-in-cardano-api.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0012-commit-to-data-types-in-cardano-api.html#decision">Decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0012-commit-to-data-types-in-cardano-api.html#argument">Argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0012-commit-to-data-types-in-cardano-api.html#alternatives">Alternatives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0012-commit-to-data-types-in-cardano-api.html#define-our-own-data-types-for-off-chain-use">Define our own data types for off-chain use</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0012-commit-to-data-types-in-cardano-api.html#implications">Implications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0012-commit-to-data-types-in-cardano-api.html#notes">Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0013-tx-validity-time-range-fix.html">ADR 13: Transaction validity time range fix</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0013-tx-validity-time-range-fix.html#author-s">Author(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0013-tx-validity-time-range-fix.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0013-tx-validity-time-range-fix.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0013-tx-validity-time-range-fix.html#decision">Decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0013-tx-validity-time-range-fix.html#argument">Argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0013-tx-validity-time-range-fix.html#implications">Implications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0013-tx-validity-time-range-fix.html#alternatives">Alternatives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0013-tx-validity-time-range-fix.html#add-mustvalidateinslotrange-constraint">Add <code class="docutils literal notranslate"><span class="pre">MustValidateInSlotRange</span></code> constraint</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0013-tx-validity-time-range-fix.html#remove-mustvalidateintimerange">Remove <code class="docutils literal notranslate"><span class="pre">mustValidateInTimeRange</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0013-tx-validity-time-range-fix.html#alter-mustvalidateintimerange">Alter <code class="docutils literal notranslate"><span class="pre">mustValidateInTimeRange</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0013-tx-validity-time-range-fix.html#notes">Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0014-marconi-query-interface.html">ADR 14: Marconi Query Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0014-marconi-query-interface.html#author-s">Author(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0014-marconi-query-interface.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0014-marconi-query-interface.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0014-marconi-query-interface.html#decision">Decision</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0014-marconi-query-interface.html#implications">Implications</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0015-time-conversion.html">ADR 15: Time conversion semantic change</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0015-time-conversion.html#author-s">Author(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0015-time-conversion.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0015-time-conversion.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0015-time-conversion.html#decision">Decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0015-time-conversion.html#argument">Argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0015-time-conversion.html#implications">Implications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0015-time-conversion.html#alternatives">Alternatives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0015-time-conversion.html#changing-the-representation-of-slotconfig-to-the-correct-one">Changing the representation of <code class="docutils literal notranslate"><span class="pre">SlotConfig</span></code> to the correct one</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0015-time-conversion.html#directly-use-epochinfo-in-the-emulator-and-contract-api">Directly use EpochInfo in the emulator and Contract API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0015-time-conversion.html#notes">Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0016-cardano-node-emulator.html">ADR 16: Self-contained cardano-node emulator component</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0016-cardano-node-emulator.html#author-s">Author(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0016-cardano-node-emulator.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0016-cardano-node-emulator.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0016-cardano-node-emulator.html#decision">Decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0016-cardano-node-emulator.html#argument">Argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0016-cardano-node-emulator.html#notes">Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html">ADR 17: End-to-end testing strategy for Plutus, cardano-ledger-api and cardano-node-client</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html#author-s">Author(s)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html#status">Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html#context">Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html#decision">Decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html#types-of-plutus-tests-for-the-plutus-e2e-tests-haskell-framework">Types of Plutus tests for the <code class="docutils literal notranslate"><span class="pre">plutus-e2e-tests</span></code> Haskell framework</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html#argument">Argument</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html#pros-of-building-and-maintaining-our-own-test-framework">Pros of building and maintaining our own test framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html#cons-of-building-and-maintaining-our-own-test-framework">Cons of building and maintaining our own test framework</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html#additional-considerations">Additional Considerations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html#alternatives">Alternatives</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html#notes">Notes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../adr/0017-end-to-end-testing-strategy.html#other-places-spinning-up-a-local-testnet">Other places spinning up a local testnet</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/examples.html">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/cost-model-parameters.html">Cost model parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/glossary.html">Glossary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/bibliography.html">Bibliography</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/index.html#elsewhere">Elsewhere</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #fcfcfc" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Plutus Tools SDK User Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Tutorials</a> &raquo;</li>
      <li>Testing Plutus Contracts with Contract Models</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/input-output-hk/plutus/blob/master/doc/plutus/tutorials/contract-models.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="testing-plutus-contracts-with-contract-models">
<span id="contract-models-tutorial"></span><h1>Testing Plutus Contracts with Contract Models<a class="headerlink" href="#testing-plutus-contracts-with-contract-models" title="Permalink to this heading"></a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<p>In this tutorial we will see how to test Plutus contracts with
<em>contract models</em>, using the framework provided by
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel.html" title="(in plutus-contract v1.1.0.0)"><code class="xref hs hs-hsmod docutils literal notranslate"><span class="pre">Plutus.Contract.Test.ContractModel</span></code></a> This framework generates
and runs tests on the Plutus emulator, where each test may involve a
number of emulated wallets, each running a collection of Plutus
contracts, all submitting transactions to an emulated blockchain.
Once the user has defined a suitable model, then QuickCheck can
generate and run many thousands of scenarios, taking the application
through a wide variety of states, and checking that it behaves
correctly in each one. Once the underlying contract model is in place,
then the framework can check user-defined properties specific to the
application, generic properties such as that no funds remain locked in
contracts for ever, and indeed both positive and negative
tests—where positive tests check that the contracts allow the
intended usages, and negative tests check that they do <em>not</em> allow
the unintended ones.</p>
<p>The <cite>ContractModel</cite> framework is quite rich in features, but we will
introduce them gradually and explain how they can best be used.</p>
</section>
<section id="basic-contract-models">
<h2>Basic Contract Models<a class="headerlink" href="#basic-contract-models" title="Permalink to this heading"></a></h2>
<section id="example-a-simple-escrow-contract">
<h3>Example: A Simple Escrow Contract<a class="headerlink" href="#example-a-simple-escrow-contract" title="Permalink to this heading"></a></h3>
<p>We begin by showing how to construct a model for a simplified escrow
contract, which can be found in
<a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html" title="(in plutus-use-cases v1.1.0.0)"><code class="xref hs hs-hsmod docutils literal notranslate"><span class="pre">Plutus.Contracts.Tutorial.Escrow</span></code></a>. This contract enables a
group of wallets to make a predetermined exchange of tokens, for
example selling an NFT for Ada. There are two endpoints, a
<a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#v:pay" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">pay</span></code></a> endpoint, and a
<a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#v:redeem" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">redeem</span></code></a> endpoint.
Each wallet pays in its contribution to the contract using the
<a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#v:pay" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">pay</span></code></a> endpoint, and once all
the wallets have done so, then any wallet can trigger the
predetermined payout using the
<a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#v:redeem" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">redeem</span></code></a> endpoint.</p>
<p>For simplicity, we will begin by testing the contract for a fixed set
of predetermined payouts.
These are defined by the
<a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#t:EscrowParams" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">EscrowParams</span></code></a>, a
type exported by the escrow contract, and which is actually passed to
the on-chain validators. <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test.html" title="(in plutus-contract v1.1.0.0)"><code class="xref hs hs-hsmod docutils literal notranslate"><span class="pre">Plutus.Contract.Test</span></code></a> provides ten
emulated wallets for use in tests, <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test.html#v:w1" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">w1</span></code></a>
to <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test.html#v:w10" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">w10</span></code></a>; in this case we
will use five of them:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">testWallets</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Wallet</span><span class="p">]</span><span class="w"></span>
<span class="nf">testWallets</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">w1</span><span class="p">,</span><span class="w"> </span><span class="n">w2</span><span class="p">,</span><span class="w"> </span><span class="n">w3</span><span class="p">,</span><span class="w"> </span><span class="n">w4</span><span class="p">,</span><span class="w"> </span><span class="n">w5</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Let us decide arbitrarily that <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test.html#v:w1" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">w1</span></code></a> will
receive a payout of 10 Ada, and <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test.html#v:w2" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">w2</span></code></a> will
receive a payout of 20, and define an
<a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#t:EscrowParams" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">EscrowParams</span></code></a>
value to represent that:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">escrowParams</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">EscrowParams</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
<span class="nf">escrowParams</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kt">EscrowParams</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">escrowTargets</span><span class="w">  </span><span class="ow">=</span><span class="w"></span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="n">payToPaymentPubKeyTarget</span><span class="w"> </span><span class="p">(</span><span class="n">mockWalletPaymentPubKeyHash</span><span class="w"> </span><span class="n">w1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">payToPaymentPubKeyTarget</span><span class="w"> </span><span class="p">(</span><span class="n">mockWalletPaymentPubKeyHash</span><span class="w"> </span><span class="n">w2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="the-contract-model-type">
<h3>The Contract Model Type<a class="headerlink" href="#the-contract-model-type" title="Permalink to this heading"></a></h3>
<p>In order to generate sensible tests, and to decide how they should
behave, we need to track the expected state of the system. The first
step in defining a contract model is to define a type to represent
this expected state. We usually need to refine it as the model
evolves, but for now we keep things simple.</p>
<p>In this case, as wallets make payments into the escrow, we will need
to keep track of how much each wallet has paid in. So let us define an
<code class="docutils literal notranslate"><span class="pre">EscrowModel</span></code> type that records these contributions. Once the
contributions reach the targets, then the escrow may be redeemed, so
let us keep track of these targets in the model too. We define</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_contributions</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="kt">Value</span><span class="o">.</span><span class="kt">Value</span><span class="w"></span>
<span class="w">                               </span><span class="p">,</span><span class="w"> </span><span class="n">_targets</span><span class="w">       </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="kt">Value</span><span class="o">.</span><span class="kt">Value</span><span class="w"></span>
<span class="w">                               </span><span class="p">}</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">Generic</span><span class="p">)</span><span class="w"></span>

<span class="nf">makeLenses</span><span class="w"> </span><span class="kt">&#39;&#39;EscrowModel</span><span class="w"></span>
</pre></div>
</div>
<p>Note that we use <a class="reference external" href="http://hackage.haskell.org/package/lens">lenses</a>
to access the fields of the model. This is why the field names begin
with an underscore; the <code class="docutils literal notranslate"><span class="pre">makeLenses</span></code> call creates lenses called just
<code class="docutils literal notranslate"><span class="pre">contributions</span></code> and <code class="docutils literal notranslate"><span class="pre">targets</span></code> for these fields, which we will use
to access and modify the fields below.</p>
<p>We turn this type into a contract model by making it an instance of
the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a> class:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">ContractModel</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>The rest of the contract model is provided by defining the methods and
associated data types of this class.</p>
</section>
<section id="what-contracts-shall-we-test">
<h3>What contracts shall we test?<a class="headerlink" href="#what-contracts-shall-we-test" title="Permalink to this heading"></a></h3>
<p>In general, a contract model can be used to test any number of
contracts, of differing types, running in any of the emulated
wallets. But we need to tell the framework <em>which</em> contracts we are
going to test, and we need a way for the model to refer to each
<em>contract instance</em>, so that we can invoke the right endpoints. We do
so using a <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractInstanceKey</span></code></a>, but since different models will be
testing different collections of contracts, then this type is not
<em>fixed</em>, it is defined as part of each model, as an associated type of
the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a> class.</p>
<p>In this case only one kind of contract is involved in the tests, the
escrow contract, but there will be many instances of it, one running
in each wallet. To identify a contract instance, a
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractInstanceKey</span></code></a> just has to record the wallet it is running
in, we only need one constructor in the type. In general there will be
one constructor for each type of contract instance in the test.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">ContractInstanceKey</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kt">WalletKey</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">ContractInstanceKey</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="kt">EscrowSchema</span><span class="w"> </span><span class="kt">EscrowError</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
</pre></div>
</div>
<p>Note that the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractInstanceKey</span></code></a> type is a GADT, so it tracks not only the
model type it belongs to, but also the type of the contract instance
it refers to.</p>
<p>The framework also needs to be able to show and compare
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractInstanceKey</span></code></a>, so you might expect that we would add a
deriving clause to this type definition. But a deriving clause is
actually not supported here, because the type is a GADT, so instead we
have to give separate ‘standalone deriving’ declarations outside the
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a> instance:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">deriving</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">CM</span><span class="o">.</span><span class="kt">ContractInstanceKey</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">params</span><span class="p">)</span><span class="w"></span>
<span class="kr">deriving</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="p">(</span><span class="kt">CM</span><span class="o">.</span><span class="kt">ContractInstanceKey</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">params</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Defining <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractInstanceKey</span></code></a> is only part of the story: we also
have to tell the framework how to <em>interpret</em> the contract instance
keys, in particular</p>
<ol class="arabic simple">
<li><p>which contract instances to start</p></li>
<li><p>which emulated wallets to run them in</p></li>
<li><p>which actual contract each contract instance should run.</p></li>
</ol>
<p>We do so by defining three methods in the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a> class:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">initialInstances</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="kt">StartContract</span><span class="w"> </span><span class="p">(</span><span class="kt">WalletKey</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">testWallets</span><span class="p">]</span><span class="w"></span>

<span class="w">  </span><span class="n">instanceWallet</span><span class="w"> </span><span class="p">(</span><span class="kt">WalletKey</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">w</span><span class="w"></span>

<span class="w">  </span><span class="n">instanceContract</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">WalletKey</span><span class="p">{}</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">testContract</span><span class="w"></span>
</pre></div>
</div>
<p>The first line above tells the test framework to start a contract
instance in each of the test wallets (with contract parameter <code class="docutils literal notranslate"><span class="pre">()</span></code>),
the second line tells the framework which wallet each contract key
should run in, and the third line tells the framework which contract
to run for each key–in this case, the same <code class="docutils literal notranslate"><span class="pre">testContract</span></code> in each
wallet. <code class="docutils literal notranslate"><span class="pre">Spec.Tutorial.Escrow</span></code> does not actually export a complete
concrete, only contract endpoints, so for the purposes of the test we
just define a contract that allows us to invoke those endpoints
repeatedly:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">testContract</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">selectList</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">payEp</span><span class="w"> </span><span class="n">escrowParams</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">redeemEp</span><span class="w"> </span><span class="n">escrowParams</span><span class="w"></span>
<span class="w">                          </span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">testContract</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="what-actions-should-tests-perform">
<h3>What actions should tests perform?<a class="headerlink" href="#what-actions-should-tests-perform" title="Permalink to this heading"></a></h3>
<section id="the-type-of-actions">
<h4>The type of Actions<a class="headerlink" href="#the-type-of-actions" title="Permalink to this heading"></a></h4>
<p>The final <em>type</em> we need to define as part of a contract model tells
the framework what <em>actions</em> to include in generated tests. This is
defined as another associated datatype of the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a> class,
and in this case, we will just need actions to invoke the two contract
endpoints:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">Action</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Pay</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="w">                          </span><span class="o">|</span><span class="w"> </span><span class="kt">Redeem</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="c1">-- ^ Refund Wallet</span><span class="w"></span>
<span class="w">    </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">Generic</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The framework needs to be able to show and compare
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> too, but in this case we <em>can</em> just add a <code class="docutils literal notranslate"><span class="pre">deriving</span></code>
clause to the definition.</p>
</section>
<section id="performing-actions">
<h4>Performing Actions<a class="headerlink" href="#performing-actions" title="Permalink to this heading"></a></h4>
<p>QuickCheck will generate sequences of <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> as tests, but in
order to <em>run</em> the tests, we need to specify how each action should be
performed. This is done by defining the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">perform</span></code></a> method of the
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a> class, which maps <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> to a computation in the
emulator. <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">perform</span></code></a> takes several parameters besides the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> to
perform, but for now we ignore all but the first, whose purpose is to
translate a <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractInstanceKey</span></code></a>, used in the model, into a
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Trace-Emulator-Types.html#t:ContractHandle" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractHandle</span></code></a>, used to refer to a contract instance in the
emulator. The <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">perform</span></code></a> method is free to use any <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Trace-Emulator.html#t:EmulatorTrace" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">EmulatorTrace</span></code></a>
operations, but in practice we usually keep it simple, interpreting
each <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> as a single call to a contract endpoint. This gives
QuickCheck maximal control over the interaction between the tests and
the contracts. In this case, we just call either the <a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#v:pay" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">pay</span></code></a> or the
<a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#v:redeem" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">redeem</span></code></a> endpoint.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">perform</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">Pay</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">v</span><span class="w">        </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="kt">Trace</span><span class="o">.</span><span class="n">callEndpoint</span><span class="w"> </span><span class="o">@</span><span class="s">&quot;pay-escrow&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">WalletKey</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">fromInteger</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="kt">CM</span><span class="o">.</span><span class="n">delay</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="kt">Redeem</span><span class="w"> </span><span class="n">w</span><span class="w">       </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="kt">Trace</span><span class="o">.</span><span class="n">callEndpoint</span><span class="w"> </span><span class="o">@</span><span class="s">&quot;redeem-escrow&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">WalletKey</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">      </span><span class="kt">CM</span><span class="o">.</span><span class="n">delay</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that we <em>do</em> need to allow each <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> time to complete, so
we include a <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:delay" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">delay</span></code></a> to tell the emulator to move on to the next
slot after each endpoint call. Of course we are free <em>not</em> to do this,
but then tests will submit many endpoint calls per slot, and fail
because the endpoints are not ready to perform them. This is not the
most interesting kind of test failure, and so we avoid it by delaying
an appropriate number of slots after each endpoint call. The number of
slots we need to wait varies from contract to contract, so we usually
determine these numbers experimentally. Exactly the same problem
arises in writing unit tests, of course.</p>
</section>
<section id="modelling-actions">
<h4>Modelling Actions<a class="headerlink" href="#modelling-actions" title="Permalink to this heading"></a></h4>
<p>Remember that we need to track the real state of the system using the
contract model state? We defined a type for this purpose:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_contributions</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="kt">Value</span><span class="o">.</span><span class="kt">Value</span><span class="w"></span>
<span class="w">                               </span><span class="p">,</span><span class="w"> </span><span class="n">_targets</span><span class="w">       </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="kt">Value</span><span class="o">.</span><span class="kt">Value</span><span class="w"></span>
<span class="w">                               </span><span class="p">}</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">Generic</span><span class="p">)</span><span class="w"></span>

<span class="nf">makeLenses</span><span class="w"> </span><span class="kt">&#39;&#39;EscrowModel</span><span class="w"></span>
</pre></div>
</div>
<p>We need to tell the framework what the <em>effect</em> of each <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> is
expected to be, both on wallet contents, and in terms of the model state. We do
this by defining the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextState</span></code></a> method of the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a>
class, which just takes an <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> as a parameter, and interprets
it in the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:Spec" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Spec</span></code></a> monad, provided by the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a> framework.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">nextState</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">Pay</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="n">withdraw</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">fromInteger</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">contributions</span><span class="w"> </span><span class="o">%=</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">insertWith</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">fromInteger</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">wait</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="kt">Redeem</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="n">targets</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">targets</span><span class="w"></span>
<span class="w">      </span><span class="n">sequence_</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">deposit</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">toList</span><span class="w"> </span><span class="n">targets</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="n">contributions</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">empty</span><span class="w"></span>
<span class="w">      </span><span class="n">wait</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>You can see that the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:Spec" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Spec</span></code></a> monad allows us to withdraw and deposit
values in wallets, so that the framework can predict their expected
contents, and also to read and update the model state using the lenses
generated from its type definition. For a <code class="docutils literal notranslate"><span class="pre">Pay</span></code> action, we withdraw
the payment from the wallet, and record the contribution in the model
state, using <a class="reference external" href="https://hackage.haskell.org/package/lens-5.1.1/docs/Control-Lens-Setter.html#v:-37--61-"><code class="docutils literal notranslate"><span class="pre">(%=)</span></code></a> to update the <code class="docutils literal notranslate"><span class="pre">contributions</span></code> field. For a
<code class="docutils literal notranslate"><span class="pre">Redeem</span></code> action, we read the targets from the model state (using
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:viewContractState" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">viewContractState</span></code></a> and the lens generated from the type
definition), and then make the corresponding payments to the wallets
concerned. In both cases we tell the model to <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:wait" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">wait</span></code></a> one slot,
corresponding to the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:delay" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">delay</span></code></a> call in <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">perform</span></code></a>; this is necessary
to avoid the model and the emulator getting out of sync.</p>
<p>We also have to specify the <em>initial</em> model state at the beginning of
each test: we just record that no contributions have been made yet,
along with the targets we chose for testing with.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">initialState</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_contributions</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">empty</span><span class="w"></span>
<span class="w">                             </span><span class="p">,</span><span class="w"> </span><span class="n">_targets</span><span class="w">       </span><span class="ow">=</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="p">(</span><span class="n">w1</span><span class="p">,</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">                                                             </span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">w2</span><span class="p">,</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"></span>
<span class="w">                                                             </span><span class="p">]</span><span class="w"></span>
<span class="w">                             </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Given these definitions, the framework can predict the expected model
state after any sequence of <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a>.</p>
</section>
</section>
<section id="generating-actions">
<h3>Generating Actions<a class="headerlink" href="#generating-actions" title="Permalink to this heading"></a></h3>
<p>The last step, before we can actually run tests, is to tell the
framework how to <em>generate</em> random actions. We do this by defining the
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">arbitraryAction</span></code></a> method, which is just a QuickCheck generator for
the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> type. It gets the current model state as a parameter,
so we can if need be adapt the generator depending on the state, but
for now that is not important: we just choose between making a payment
from a random wallet, and invoking <a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#v:redeem" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">redeem</span></code></a> from a random
wallet. Since we expect to need several payments to fund a redemption,
we generate <code class="docutils literal notranslate"><span class="pre">Pay</span></code> actions a bit more often than <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> ones.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">arbitraryAction</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">frequency</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kt">Pay</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">elements</span><span class="w"> </span><span class="n">testWallets</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">choose</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">))</span><span class="w"></span>
<span class="w">                                  </span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">Redeem</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">elements</span><span class="w"> </span><span class="n">testWallets</span><span class="p">)</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Strictly speaking the framework now has enough information to generate
and run tests, but it is good practice to define <em>shrinking</em> every
time we define <em>generation</em>; we just defined a generator for actions,
so we should define a shrinker too. We do so by defining the
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">shrinkAction</span></code></a> method, which, like the QuickCheck <a class="reference external" href="https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck.html#v:shrink"><code class="docutils literal notranslate"><span class="pre">shrink</span></code></a>
function, just returns a list of smaller <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> to try replacing
an action by when a test fails. It is always worth defining a
shrinker: the small amount of effort required is repaid <em>very</em>
quickly, since failed tests become much easier to understand.</p>
<p>In this case, as in most others, we can just reuse the existing
shrinking for those parts of an <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> that make sense to
shrink. There is no sensible way to shrink a wallet, really, so we
just shrink the amount in a payment.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">shrinkAction</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="p">(</span><span class="kt">Pay</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="kt">Pay</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">n&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">n&#39;</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">shrink</span><span class="w"> </span><span class="n">n</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">shrinkAction</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w">         </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
</pre></div>
</div>
<p>With this definition, failing test cases will be reported with the
<em>minimum</em> payment value that causes a failure.</p>
</section>
<section id="running-tests-and-debugging-the-model">
<h3>Running tests and debugging the model<a class="headerlink" href="#running-tests-and-debugging-the-model" title="Permalink to this heading"></a></h3>
<p>We are finally ready to run some tests! We do still need to define a
<em>property</em> that we can call QuickCheck with, but the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a>
framework provides a standard one that we can just reuse. So we define</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_Escrow</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">Actions</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Property</span><span class="w"></span>
<span class="nf">prop_Escrow</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">propRunActions_</span><span class="w"></span>
</pre></div>
</div>
<p>The important information here is in the type signature, which tells
QuickCheck <em>which</em> contract model we want to generate and run tests
for.</p>
<section id="a-failing-test">
<h4>A failing test<a class="headerlink" href="#a-failing-test" title="Permalink to this heading"></a></h4>
<p>Once the property is defined, we are ready to test–and a test fails
immediately! This is not unexpected–it is quite rare that a model and
implementation match on the first try, so we should expect a little
debugging–<em>of the model</em>–before we start to find interesting bugs in
contracts. When models are written <em>after</em> the implementation, as in
this case, then the new code–the model code–is likely to be where
bugs appear first.</p>
<p>Looking at the test output, the first thing QuickCheck reports is the
failed test case:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Prelude Spec.Tutorial.Escrow Test.QuickCheck Main&gt; quickCheck prop_Escrow
*** Failed! Assertion failed (after 7 tests and 2 shrinks):
Actions
 [Redeem (Wallet 5)]
</pre></div>
</div>
<p>Here we see what generated tests looks like: they are essentially
lists of <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a>, performed in sequence. In this case there is only
one <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a>: wallet 5 just attempted to redeem the funds in the
contract.</p>
<p>The next lines of output tell us why the test failed:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Expected funds of W[2] to change by
  Value (Map [(,Map [(&quot;&quot;,20000000)])])
but they did not change
Expected funds of W[1] to change by
  Value (Map [(,Map [(&quot;&quot;,10000000)])])
but they did not change
</pre></div>
</div>
<p>Remember we defined the expected payout to be 10 Ada to <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test.html#v:w1" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">w1</span></code></a>, and 20
Ada to <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test.html#v:w2" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">w2</span></code></a>. Our model says (in <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextState</span></code></a>) that when we perform
a <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> then the payout should be made (in Lovelace, not Ada,
which is why the numbers are a million times larger than those in the
model). But the wallets did not get the money–which is hardly
surprising since no payments at all have been made <em>to</em> the contract,
so there is no money to disburse.</p>
<p>The remaining output displays a log from the failing contract
instance, and the emulator log, both containing the line</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Contract instance stopped with error: RedeemFailed NotEnoughFundsAtAddress
</pre></div>
</div>
<p>This is an error thrown by the off-chain <a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#v:redeem" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">redeem</span></code></a> endpoint code,
which (quite correctly) checks the funds available, and fails since there
are not enough.</p>
</section>
<section id="positive-testing-with-preconditions">
<h4>Positive testing with preconditions<a class="headerlink" href="#positive-testing-with-preconditions" title="Permalink to this heading"></a></h4>
<p>We now have a failing test, that highlights a discrepancy between the
model and the implementation–and it is the model that is wrong. The
question is how to fix it, and there is a choice to be made. Either we
could decide that the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextState</span></code></a> function in the model should
<em>check</em> whether sufficient funds are available, and if they are not,
predict that no payments are made. Or perhaps, we should <em>restrict our
tests so they do not attempt to use ``Redeem`` when it should not
succeed</em>.</p>
<p>Both choices are reasonable. The first alternative is usually called
<em>negative testing</em>–we deliberately test error situations, and make
sure that the implementation correctly detects and handles those
errors. The second alternative is <em>positive testing</em> (or “happy path”
testing), when we make sure that the implementation provides the
functionality that it should, when the user makes <em>correct</em> use of its
API.</p>
<p>It is usually a good idea to focus on positive testing first–indeed,
good positive testing is a prerequisite for good negative testing,
because it enables us to get the system into a wide variety of
interesting states (in which to perform negative tests). So we shall
return to negative testing later, and focus–in this section–on
making positive testing work well.</p>
<p>To do so, we have to <em>restrict</em> test cases, so that they do not
include <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> actions, when there are insufficient funds in the
escrow. We restrict actions by defining the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">precondition</span></code></a> method of
the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a> class: any <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> for which <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">precondition</span></code></a>
returns <code class="docutils literal notranslate"><span class="pre">False</span></code> will <em>not</em> be included in any generated test. The
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">precondition</span></code></a> method is also given the current <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ModelState" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ModelState</span></code></a> as a
parameter, so that it can decide to accept or reject an <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a>
based on where it appears in a test.</p>
<p>In this case, we want to <em>allow</em> a <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> action only if there are
sufficient funds in the escrow, so we just need to compare the
contributions made so far to the targets:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">precondition</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">Redeem</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">contributions</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">fold</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">`</span><span class="n">geq</span><span class="p">`</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">targets</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">fold</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">_</span><span class="w">        </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
<p>In this code, <code class="docutils literal notranslate"><span class="pre">s</span></code> is the entire model state maintained by the
framework (including wallet contents, slot number etc), but it
contains the “contract state”, which is the state we have defined
ourselves, the <code class="docutils literal notranslate"><span class="pre">EscrowModel</span></code>. The <em>lens</em> <code class="docutils literal notranslate"><span class="pre">contractState</span>
<span class="pre">.</span> <span class="pre">contributions</span> <span class="pre">.</span> <span class="pre">to</span> <span class="pre">fold</span></code> extracts the <code class="docutils literal notranslate"><span class="pre">EscrowModel</span></code>, extracts the
<code class="docutils literal notranslate"><span class="pre">contributions</span></code> field from it, and then combines all the <a class="reference external" href="../../haddock/plutus-ledger/html/Ledger.html#t:Value" title="(in plutus-ledger v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Value</span></code></a>
using <a class="reference external" href="https://hackage.haskell.org/package/base-4.16.1.0/docs/Data-Foldable.html#v:fold"><code class="docutils literal notranslate"><span class="pre">fold</span></code></a>. When we apply it to <code class="docutils literal notranslate"><span class="pre">s</span></code> using <a class="reference external" href="https://hackage.haskell.org/package/lens-5.1.1/docs/Control-Lens-Getter.html#v:-94-."><code class="docutils literal notranslate"><span class="pre">(^.)</span></code></a>, we get
the total value of all contributions. Likewise, the second lens
application computes the combined value of all the targets. If the
contributions exceed the targets, then the <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> is allowed;
otherwise, it will not be included in the test. Once
we define <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">precondition</span></code></a>, then it has to be defined for every form
of <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a>, so we just add a default branch that returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We can’t use <code class="docutils literal notranslate"><span class="pre">(&gt;=)</span></code> to compare <a class="reference external" href="../../haddock/plutus-ledger/html/Ledger.html#t:Value" title="(in plutus-ledger v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Value</span></code></a>; there is no
<code class="docutils literal notranslate"><span class="pre">Ord</span></code> instance. That is because some <a class="reference external" href="../../haddock/plutus-ledger/html/Ledger.html#t:Value" title="(in plutus-ledger v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Value</span></code></a> are incomparable,
such as one Ada and one NFT, which would break our expectations about
<code class="docutils literal notranslate"><span class="pre">Ord</span></code>. That is why we have to compare them using <a class="reference external" href="../../haddock/plutus-ledger-api/html/Plutus-V1-Ledger-Value.html#v:geq" title="(in plutus-ledger-api v1.0.0.1)"><code class="docutils literal notranslate"><span class="pre">geq</span></code></a> instead.</p>
</div>
<p>With this precondition, the failing test we have seen can no longer be
generated, and will not appear again in our <a class="reference external" href="https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck.html#v:quickCheck"><code class="docutils literal notranslate"><span class="pre">quickCheck</span></code></a> runs.</p>
</section>
<section id="a-second-infelicity-in-the-model">
<h4>A second infelicity in the model<a class="headerlink" href="#a-second-infelicity-in-the-model" title="Permalink to this heading"></a></h4>
<p>Adding a precondition for <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> prevents the previous failing
test from being generated, but it does not make the tests pass: it
just allows QuickCheck to reveal the next problem in the
model. Running tests again, we see:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Prelude Spec.Tutorial.Escrow Test.QuickCheck Main&gt; quickCheck prop_Escrow
*** Failed! Assertion failed (after 4 tests and 5 shrinks):
Actions
 [Pay (Wallet 2) 0]
</pre></div>
</div>
<p>This time the test just consists of a single <code class="docutils literal notranslate"><span class="pre">Pay</span></code> action, making a
payment of zero (!) Ada to the the contract.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It may seem surprising that the test tries to make a zero payment,
given that the <em>generator</em> we saw above only generates payments in
the range 1 to 30 Ada. But remember that the failing test cases we
see are not necessarily freshly generated, they may also have been
<em>shrunk</em>. In this case, the zero is a result of shrinking: the
shrinker we saw can certainly shrink payments to zero, and the
<em>precondition</em> for <code class="docutils literal notranslate"><span class="pre">Pay</span></code> allows that… it’s always <code class="docutils literal notranslate"><span class="pre">True</span></code>. And
so, a zero payment can appear in tests. If we wanted to prevent
this, the correct way would be to tighten the precondition of
<code class="docutils literal notranslate"><span class="pre">Pay</span></code>.</p>
</div>
<p>The next part of the output explains why the test failed:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Expected funds of W[2] to change by
  Value (Map [])
but they changed by
  Value (Map [(,Map [(&quot;&quot;,-2000000)])])
a discrepancy of
  Value (Map [(,Map [(&quot;&quot;,-2000000)])])
</pre></div>
</div>
<p>In other words, the model expected that a payment of zero would not
affect the funds held by the calling wallet, but in fact, the wallet
lost 2 Ada.</p>
<p>Why did this happen? In this case, the emulator log that follows
provides an explanation:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>.
.
.
[INFO] Slot 1: W[2]: Balancing an unbalanced transaction:
       Tx:
         Tx 2dc052b47a1faeacc0f50b99359990302885a34104df0109576597cc490b8a98:
           {inputs:
           collateral inputs:
           outputs:
             - Value (Map [(,Map [(&quot;&quot;,2000000)])]) addressed to
               ScriptCredential: bcf453ff769866e23d14d5104c36ce4da0ff5bcbed23c622f46b94f1 (no staking credential)
           mint: Value (Map [])
           fee: Value (Map [])
           mps:
           signatures:
           validity range: Interval {ivFrom = LowerBound NegInf True, ivTo = UpperBound PosInf True}
           data:
             &quot;\128\164\244[V\184\141\DC19\218#\188L&lt;u\236m2\148&lt;\b\DEL%\v\134\EM&lt;\167&quot;}
       Requires signatures:
       Utxo index:
       Validity range:
         (-? , +?)
.
.
.
</pre></div>
</div>
<p>We see the transaction submitted by the contract, and we can see from
its outputs that it <em>is</em> paying 2 Ada to the script, even though we
specified a payment of zero. The reason for this is that the Cardano
blockchain requires a <em>minimum Ada amount</em> in every transaction
output, currently 2 Ada. It is therefore <em>impossible</em> to make a
payment of zero Ada to the script–and the Plutus libraries avoid this
by adding Ada to each output, if necessary, to meet the minimum
requirement. It is these 2 Ada that the wallet has lost.</p>
<p>This is not really a bug in the escrow contract: it’s a fundamental
limitation enforced by the blockchain itself. Therefore we must adapt
our model to allow for it. Once again we have a choice: we <em>could</em>
specify that every <code class="docutils literal notranslate"><span class="pre">Pay</span></code> action costs at least the minimum Ada, even
if the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> contains a lower payment, <em>or</em> we can restrict
<code class="docutils literal notranslate"><span class="pre">Pay</span></code> actions to amounts greater than or equal to the minimum. We
choose the latter, because it is simpler to express–we just tighten
the precondition for <code class="docutils literal notranslate"><span class="pre">Pay</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">precondition</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">Redeem</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">contributions</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">fold</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">`</span><span class="n">geq</span><span class="p">`</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">targets</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">fold</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kt">Pay</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">v</span><span class="w">  </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="p">(</span><span class="n">fromInteger</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="n">geq</span><span class="p">`</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">toValue</span><span class="w"> </span><span class="n">minAdaTxOutEstimated</span><span class="w"></span>
</pre></div>
</div>
<p>Now this failure can no longer appear.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It’s debatable whether the contract’s behaviour is actually buggy
or not. We decided to accept it, and exclude payments smaller than
2 Ada from our tests. But of course, a <em>user</em> of the contract might
attempt to make a payment of, say, 1 Ada–nothing prevents
that. Such a user will see their wallet debited with 2 Ada, and may
be surprised by that behaviour. Arguably the contract should
explicitly <em>reject</em> payments below the minimum, rather than
silently increase them. So this failing test does expose this
issue.</p>
</div>
</section>
<section id="a-third-infelicity-in-the-model-and-a-design-issue">
<span id="designissue"></span><h4>A third infelicity in the model, and a design issue<a class="headerlink" href="#a-third-infelicity-in-the-model-and-a-design-issue" title="Permalink to this heading"></a></h4>
<p>Now that we have reasonable preconditions for each <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> in a
test, we can expect to see more interesting failures. And indeed, the
tests still fail, but now with a test case that combines payment and
redemption:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Prelude Spec.Tutorial.Escrow Test.QuickCheck Main&gt; quickCheck prop_Escrow
*** Failed! Assertion failed (after 8 tests and 5 shrinks):
Actions
 [Pay (Wallet 4) 11,
  Pay (Wallet 5) 20,
  Redeem (Wallet 5)]
Expected funds of W[5] to change by
  Value (Map [(,Map [(&quot;&quot;,-20000000)])])
but they changed by
  Value (Map [(,Map [(&quot;&quot;,-19000000)])])
a discrepancy of
  Value (Map [(,Map [(&quot;&quot;,1000000)])])
</pre></div>
</div>
<p>Here we made two payments, totalling 31 Ada, <em>which is exactly one Ada
more than the combined targets</em> (recall our targets are 10 Ada to
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test.html#v:w1" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">w1</span></code></a> and 20 Ada to <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test.html#v:w2" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">w2</span></code></a>). Then <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test.html#v:w5" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">w5</span></code></a> redeemed the escrow, <em>and
ended up with 1 Ada too much</em> (last line). That extra Ada is, of
course, the extra unnecessary Ada that was paid to the script in the
previous action.</p>
<p>This raises the question: what <em>should</em> happen if an escrow holds more
funds than are needed to make the target payments? The designers of
this contract decided that any surplus should be paid to the wallet
submitting the <a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#v:redeem" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">redeem</span></code></a> transaction. Since this is part of the
intended behaviour of the contract, then our model has to reflect
it. We can do so with a small extension to the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextState</span></code></a> function
in the model:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">nextState</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">Pay</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">    </span><span class="kt">Redeem</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="n">targets</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">targets</span><span class="w"></span>
<span class="w">      </span><span class="n">sequence_</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">deposit</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">toList</span><span class="w"> </span><span class="n">targets</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="n">contribs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">contributions</span><span class="w">                 </span><span class="c1">-- NEW</span><span class="w"></span>
<span class="w">      </span><span class="kr">let</span><span class="w"> </span><span class="n">leftoverValue</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fold</span><span class="w"> </span><span class="n">contribs</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">inv</span><span class="w"> </span><span class="p">(</span><span class="n">fold</span><span class="w"> </span><span class="n">targets</span><span class="p">)</span><span class="w">     </span><span class="c1">-- NEW</span><span class="w"></span>
<span class="w">      </span><span class="n">deposit</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">leftoverValue</span><span class="w">                                     </span><span class="c1">-- NEW</span><span class="w"></span>
<span class="w">      </span><span class="n">contributions</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">empty</span><span class="w"></span>
<span class="w">      </span><span class="n">wait</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>The extra code just computes the total contributions and the surplus,
and deposits the surplus in the calling wallet.</p>
<p>Now, at last, the tests pass!</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Prelude Spec.Tutorial.Escrow Test.QuickCheck Main&gt; quickCheck prop_Escrow
+++ OK, passed 100 tests.
</pre></div>
</div>
<p>By default, quickCheck runs 100 tests, which is enough to reveal
easily-caught bugs such as those we have seen, but far too few to
catch really subtle issues. So at this point, it’s wise to run many
more tests–the number is limited only by your patience and the speed
of the emulator:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Prelude Spec.Tutorial.Escrow Test.QuickCheck Main&gt; quickCheck . withMaxSuccess 1000 $ prop_Escrow
+++ OK, passed 1000 tests.
</pre></div>
</div>
</section>
</section>
<section id="analysing-the-distribution-of-tests">
<h3>Analysing the distribution of tests<a class="headerlink" href="#analysing-the-distribution-of-tests" title="Permalink to this heading"></a></h3>
<p>Once tests are passing, then the framework displays statistics
collected from the running tests. These statistics give us important
information about the <em>effectiveness</em> of our tests; a risk with any
automated test case generation is that, since we do not usually
inspect the running tests, we may not notice if almost all of them
are trivial.</p>
<p>The contract model framework gathers some basic statistics by default,
and can be configured to gather more, but for now we just consider the
built-in ones. After each successful test run, we see a number of
tables, starting with a distribution of the actions performed by
tests:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Prelude Spec.Tutorial.Escrow Test.QuickCheck Main&gt; quickCheck . withMaxSuccess 1000 $ prop_Escrow
+++ OK, passed 1000 tests.

Actions (25363 in total):
75.894% Pay
12.771% Redeem
11.335% WaitUntil
</pre></div>
</div>
<p>Here we ran 1,000 tests, and as we see from the table, around 25,000
actions were generated. So, on average, each test case consisted of
around 25 actions.</p>
<p>Of those actions, three quarters were <code class="docutils literal notranslate"><span class="pre">Pay</span></code> actions, and 10-15% were
<code class="docutils literal notranslate"><span class="pre">Redeem</span></code>. This is not unreasonable–we decided when we wrote the
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> generator to generate more payments than redemptions. The
remaining actions are <code class="docutils literal notranslate"><span class="pre">WaitUntil</span></code> actions, inserted by the
framework, which simply wait a number of slots to test for timing
dependence; we shall return to them later, but can ignore them for
now. Thus this distribution looks quite reasonable.</p>
<p>The second table that appears tells us how often a <em>generated</em>
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> could not be included in a test, because its <em>precondition</em>
failed.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Actions rejected by precondition (360 in total):
87.8% Redeem
12.2% Pay
</pre></div>
</div>
<p>We can see that 360 actions–in addition to the 25,000 that were
included in tests–were generated, but <em>discarded</em> because their
preconditions were not true. This does represent wasted generation
effort, although rejecting 360 out of over 25,000 actions is not
really a serious problem–especially given that test case generation
is so very much faster than the emulator.</p>
<p>Nevertheless, we can see that the vast majority of rejected actions
were <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> actions, and this is because a <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> is not
allowed until sufficient payments have been made–but our generator
produces them anyway.</p>
<p>We can, of course, change this, to generate <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> actions only
when redemption is actually possible:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">arbitraryAction</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">frequency</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kt">Pay</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">elements</span><span class="w"> </span><span class="n">testWallets</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">choose</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">))</span><span class="w"> </span><span class="kt">:</span><span class="w"></span>
<span class="w">                                  </span><span class="p">[</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">Redeem</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">elements</span><span class="w"> </span><span class="n">testWallets</span><span class="p">)</span><span class="w"></span>
<span class="w">                                  </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">contributions</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">fold</span><span class="p">)</span><span class="w">   </span><span class="c1">-- NEW</span><span class="w"></span>
<span class="w">                                    </span><span class="p">`</span><span class="kt">Value</span><span class="o">.</span><span class="n">geq</span><span class="p">`</span><span class="w">                                      </span><span class="c1">-- NEW</span><span class="w"></span>
<span class="w">                                    </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">targets</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">fold</span><span class="p">)</span><span class="w">         </span><span class="c1">-- NEW</span><span class="w"></span>
<span class="w">                                  </span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Measuring the distribution again after this change, we see that only
valid <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> actions are now generated; the only discarded actions
are <code class="docutils literal notranslate"><span class="pre">Pay</span></code> actions.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Prelude Spec.Tutorial.Escrow Test.QuickCheck Main&gt; quickCheck . withMaxSuccess 1000 $ prop_Escrow
+++ OK, passed 1000 tests.

Actions (25693 in total):
76.717% Pay
13.035% Redeem
10.248% WaitUntil

Actions rejected by precondition (650 in total):
100.0% Pay
</pre></div>
</div>
<p>The main <em>disadvantage</em> of making this change is that it limits the
tests that <em>can</em> be generated, if the precondition of <code class="docutils literal notranslate"><span class="pre">Redeem</span></code>
should be changed in the future. In particular, when we move on to
negative testing, then we will want to test invalid attempts to redeem
the escrow also. Once the generator is changed like this, then
relaxing the precondition is no longer enough to introduce invalid
calls. For this reason it could be preferable to <em>keep</em> the
possibility of generation invalid calls alongside the generator for
valid calls, but to assign the potentially-invalid generator a much
lower weight.</p>
<p>We will discuss the remaining tables in a later section.</p>
</section>
<section id="exercises">
<h3>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading"></a></h3>
<p>You can find the final version of the contract model discussed in this
section in <code class="docutils literal notranslate"><span class="pre">Spec.Tutorial.Escrow1</span></code>, in the <code class="docutils literal notranslate"><span class="pre">plutus-apps</span></code> repo.</p>
<ol class="arabic">
<li><p>Try running the code in <code class="docutils literal notranslate"><span class="pre">ghci</span></code>. You can do so by starting a
<code class="docutils literal notranslate"><span class="pre">nix</span></code> shell, and starting <code class="docutils literal notranslate"><span class="pre">ghci</span></code> using</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>cabal repl plutus-use-cases-test
</pre></div>
</div>
<p>Then import QuickCheck and the contract model:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>import Test.QuickCheck
import Spec.Tutorial.Escrow1
</pre></div>
</div>
<p>and run tests using</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>quickCheck prop_Escrow
</pre></div>
</div>
<p>The tests should pass, and you should see tables showing the
distribution of tested actions, and so on.</p>
</li>
<li><p>Try removing the preconditions for <code class="docutils literal notranslate"><span class="pre">Pay</span></code> and <code class="docutils literal notranslate"><span class="pre">Redeem</span></code>, and
reinserting them one by one. Run <a class="reference external" href="https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck.html#v:quickCheck"><code class="docutils literal notranslate"><span class="pre">quickCheck</span></code></a> after each change,
and inspect the failing tests that are generated.</p></li>
<li><p>Try removing the line</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>deposit w leftoverValue
</pre></div>
</div>
<p>from the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextState</span></code></a> function, and verify that tests fail as
expected.</p>
</li>
<li><p>Try removing one of the lines</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>wait 1
</pre></div>
</div>
<p>from the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextState</span></code></a> function (so that the model and the
implementation get out of sync). What happens when you run tests?</p>
</li>
<li><p>This model does generate <code class="docutils literal notranslate"><span class="pre">Pay</span></code> actions that are discarded by the
precondition. Adjust the generator so that invalid <code class="docutils literal notranslate"><span class="pre">Pay</span></code> actions
are no longer generated, and run <a class="reference external" href="https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck.html#v:quickCheck"><code class="docutils literal notranslate"><span class="pre">quickCheck</span></code></a> to verify that this
is no longer the case.</p></li>
</ol>
</section>
</section>
<section id="parameterising-models-and-dynamic-contract-instances">
<h2>Parameterising Models and Dynamic Contract Instances<a class="headerlink" href="#parameterising-models-and-dynamic-contract-instances" title="Permalink to this heading"></a></h2>
<p>One of the unsatisfactory aspects of the tests developed in the
previous section is that they <em>always</em> pay 10 Ada to wallet 1, and 20
Ada to wallet 2. What if the contract only works for certain amounts,
or what if it only works with exactly two beneficiary wallets? Of
course, we would like to <em>generate</em> a random set of payment targets
for each test. Such a generator is easy to write:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">arbitraryTargets</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Gen</span><span class="w"> </span><span class="p">[(</span><span class="kt">Wallet</span><span class="p">,</span><span class="kt">Integer</span><span class="p">)]</span><span class="w"></span>
<span class="nf">arbitraryTargets</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">ws</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">sublistOf</span><span class="w"> </span><span class="n">testWallets</span><span class="w"></span>
<span class="w">  </span><span class="n">vs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">infiniteListOf</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">choose</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="n">ws</span><span class="w"> </span><span class="n">vs</span><span class="w"></span>
</pre></div>
</div>
<p>but it is a little more intricate to make the model <em>use</em> these
generated targets.</p>
<p>There are two problems to overcome:</p>
<ol class="arabic simple">
<li><p>The generated targets are an important part of a test case, <em>so they
must be included in the test case</em> somehow. But a test case is just
a list of actions. So where do we put the targets?</p></li>
<li><p>The running contracts need to know what the targets are–but our
model just contains a static list of contract instances in the test
(<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">initialInstances</span></code></a>). How can we pass the generated targets to
each running contract instance?</p></li>
</ol>
<p>Solve these two problems, and we can test escrows with arbitrary payout targets. The techniques we learn will be applicable in many other situations.</p>
<section id="adding-an-initial-action-and-test-case-phases">
<h3>Adding an initial action, and test case phases<a class="headerlink" href="#adding-an-initial-action-and-test-case-phases" title="Permalink to this heading"></a></h3>
<p>The first problem is quite easy to solve, in principle. The generated
payment targets are an important part of a test case, and a test case
is just a list of actions, therefore the generated payment targets
must be included in one or more of the actions. Quite simply, <em>any
generated data in a contract model test must be part of an action</em>. In
this case, we just decide that every test should begin with an
<code class="docutils literal notranslate"><span class="pre">Init</span></code> action, that specifies the targets to be used in this test
case. So we must extend the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a> type to include <code class="docutils literal notranslate"><span class="pre">Init</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">Action</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Init</span><span class="w"> </span><span class="p">[(</span><span class="kt">Wallet</span><span class="p">,</span><span class="w"> </span><span class="kt">Integer</span><span class="p">)]</span><span class="w">    </span><span class="c1">-- NEW!</span><span class="w"></span>
<span class="w">                          </span><span class="o">|</span><span class="w"> </span><span class="kt">Redeem</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"></span>
<span class="w">                          </span><span class="o">|</span><span class="w"> </span><span class="kt">Pay</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="w">    </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">Generic</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>We must also ensure that <code class="docutils literal notranslate"><span class="pre">Init</span></code> actions <em>only</em> appear as the first
action of a test case, and that every test case starts with an
<code class="docutils literal notranslate"><span class="pre">Init</span></code> action. We restrict the form of test cases using
preconditions, so this means that we must refine the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">precondition</span></code></a>
function so that the <code class="docutils literal notranslate"><span class="pre">Init</span></code> precondition only holds at the beginning
of a test case, and the other operations’ preconditions only hold
<em>after</em> an <code class="docutils literal notranslate"><span class="pre">Init</span></code> has taken place.</p>
<p>However, the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">precondition</span></code></a> method is only given the action and the
contract state as parameters, which means in turn that we must be able
to tell whether or not we are at the beginning of the test case, just
from the model state. So we have to add a field to the model, to keep
track of where in a test case we are. In this simple case we could
just add a boolean <code class="docutils literal notranslate"><span class="pre">initialised</span></code>, but we will be a little more
general and say that a test case is made up of a number of <em>phases</em>,
in this case just two, <code class="docutils literal notranslate"><span class="pre">Initial</span></code> and <code class="docutils literal notranslate"><span class="pre">Running</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_contributions</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="kt">Value</span><span class="o">.</span><span class="kt">Value</span><span class="w"></span>
<span class="w">                               </span><span class="p">,</span><span class="w"> </span><span class="n">_targets</span><span class="w">       </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="kt">Value</span><span class="o">.</span><span class="kt">Value</span><span class="w"></span>
<span class="w">                               </span><span class="p">,</span><span class="w"> </span><span class="n">_phase</span><span class="w">         </span><span class="ow">::</span><span class="w"> </span><span class="kt">Phase</span><span class="w">             </span><span class="c1">-- NEW!</span><span class="w"></span>
<span class="w">                               </span><span class="p">}</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">Generic</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Now we can specify that at the beginning of a test case we are in the
<code class="docutils literal notranslate"><span class="pre">Initial</span></code> phase, and there are no targets:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">initialState</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_contributions</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">empty</span><span class="w"></span>
<span class="w">                             </span><span class="p">,</span><span class="w"> </span><span class="n">_targets</span><span class="w">       </span><span class="ow">=</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">empty</span><span class="w"></span>
<span class="w">                             </span><span class="p">,</span><span class="w"> </span><span class="n">_phase</span><span class="w">         </span><span class="ow">=</span><span class="w"> </span><span class="kt">Initial</span><span class="w"></span>
<span class="w">                             </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>and that when we model the <code class="docutils literal notranslate"><span class="pre">Init</span></code> action, we update both the phase
and the targets accordingly:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">nextState</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">Init</span><span class="w"> </span><span class="n">wns</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="n">phase</span><span class="w">   </span><span class="o">.=</span><span class="w"> </span><span class="kt">Running</span><span class="w"></span>
<span class="w">      </span><span class="n">targets</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span><span class="w"> </span><span class="p">[(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="p">(</span><span class="n">fromInteger</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">wns</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>We have to specify how to perform an <code class="docutils literal notranslate"><span class="pre">Init</span></code> action also, but in this
case it exists only to initialise the model state with generated
targets, so performing it need not do anything:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">perform</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">Init</span><span class="w"> </span><span class="kr">_</span><span class="w">         </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="n">return</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">    </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Now we can add a precondition for <code class="docutils literal notranslate"><span class="pre">Init</span></code>, and restrict the other
actions to the <code class="docutils literal notranslate"><span class="pre">Running</span></code> phase only:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">precondition</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">Init</span><span class="w"> </span><span class="kr">_</span><span class="w">   </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Initial</span><span class="w"></span>
<span class="w">    </span><span class="kt">Redeem</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Running</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">    </span><span class="kt">Pay</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">v</span><span class="w">  </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Running</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">    </span><span class="kr">where</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">phase</span><span class="w"></span>
</pre></div>
</div>
<p>It only remains to <em>generate</em> <code class="docutils literal notranslate"><span class="pre">Init</span></code> actions, using the
generator for targets that we saw above. We can take the phase into
account, and generate an <code class="docutils literal notranslate"><span class="pre">Init</span></code> action only at the start of the test
case, and other actions only in the <code class="docutils literal notranslate"><span class="pre">Running</span></code> phase.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">arbitraryAction</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Initial</span><span class="w"></span>
<span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="kt">Init</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">arbitraryTargets</span><span class="w"></span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"></span>
<span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="n">as</span><span class="w"> </span><span class="n">before</span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Here we ensure that we always <em>generate</em> test cases that begin with
<code class="docutils literal notranslate"><span class="pre">Init</span></code>, but this is <em>not</em> enough to ensure that every test case
we <em>run</em> begins with <code class="docutils literal notranslate"><span class="pre">Init</span></code>. Remember that failed tests are
always shrunk, and the first thing the shrinker will try is to
discard the leading <code class="docutils literal notranslate"><span class="pre">Init</span></code> action (if that still results in a
failing test, which it probably will). The only way to prevent
shrinking from discarding the leading <code class="docutils literal notranslate"><span class="pre">Init</span></code> is for the
<em>preconditions</em> to require it to be there. This is why we focussed
on writing the preconditions first: they are more important.</p>
</div>
<p>As a matter of principle, when we write a generator, we also write a shrinker,
which just requires a one-line addition to the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">shrinkAction</span></code></a> function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">shrinkAction</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="p">(</span><span class="kt">Init</span><span class="w"> </span><span class="n">tgts</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="kt">Init</span><span class="w"> </span><span class="p">(</span><span class="n">shrinkList</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="ow">-&gt;</span><span class="p">(</span><span class="n">w</span><span class="p">,)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">shrink</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">tgts</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>We cannot shrink wallets, which is why we can’t simply apply
<a class="reference external" href="https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck.html#v:shrink"><code class="docutils literal notranslate"><span class="pre">shrink</span></code></a> to the list of targets, but using the <a class="reference external" href="https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck.html#v:shrinkList"><code class="docutils literal notranslate"><span class="pre">shrinkList</span></code></a>
function from <a class="reference external" href="https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck.html"><code class="docutils literal notranslate"><span class="pre">Test.QuickCheck</span></code></a> we can easily write a shrinker that
will discard list elements and shrink the target values.</p>
</section>
<section id="dynamic-contract-instances">
<h3>Dynamic contract instances<a class="headerlink" href="#dynamic-contract-instances" title="Permalink to this heading"></a></h3>
<p>At this point we can generate tests that begin by initialising the
escrow targets randomly, but we cannot yet run them successfully. If we try, we see failures like this:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>*** Failed! Assertion failed (after 11 tests and 5 shrinks):
Actions
 [Init [],
  Redeem (Wallet 1)]
Contract instance log failed to validate:
...
Slot 1: 00000000-0000-4000-8000-000000000000 {Wallet W[1]}:
          Contract instance stopped with error: RedeemFailed NotEnoughFundsAtAddress
...
</pre></div>
</div>
<p>Here we started a test with an empty list of targets, and tried to
redeem the escrow, but failed because there were ‘not enough
funds’. Why not? Because <em>the contracts we are running still expect
the fixed targets</em> that we started with; we have not yet passed our generated
targets to the contract instances under test.</p>
<p>Recall the contract we are testing:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">testContract</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">selectList</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">payEp</span><span class="w"> </span><span class="n">escrowParams</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">redeemEp</span><span class="w"> </span><span class="n">escrowParams</span><span class="w"></span>
<span class="w">                          </span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">testContract</span><span class="w"></span>
</pre></div>
</div>
<p>It invokes the contract endpoints with the fixed set of <a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#t:EscrowParams" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">EscrowParams</span></code></a>
we defined earlier. Clearly we need to parameterise the contract on
these <a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#t:EscrowParams" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">EscrowParams</span></code></a> instead:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">testContract</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">EscrowParams</span><span class="w"> </span><span class="kt">Datum</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Contract</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="kt">EscrowSchema</span><span class="w"> </span><span class="kt">EscrowError</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">testContract</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">selectList</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">payEp</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="w">                                 </span><span class="p">,</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">redeemEp</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="w">                                 </span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">testContract</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
</pre></div>
</div>
<p>Now the question is: how do we pass this parameter to each <code class="docutils literal notranslate"><span class="pre">testContract</span></code> as we start them?</p>
<p>Recall the way we started contracts in the previous section. We
defined the contracts to start at the beginning of a test in the
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">initialInstances</span></code></a> method:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">initialInstances</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="kt">CM</span><span class="o">.</span><span class="kt">StartContract</span><span class="w"> </span><span class="p">(</span><span class="kt">WalletKey</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">testWallets</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Each contract is specified by a <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:StartContract" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">StartContract</span></code></a>, containing not only
a contract instance key, but also a <em>parameter</em>–in this case <code class="docutils literal notranslate"><span class="pre">()</span></code>,
since we did not need to pass any generated values to
<code class="docutils literal notranslate"><span class="pre">testContract</span></code>. Now we do need to, so we must replace that <code class="docutils literal notranslate"><span class="pre">()</span></code>
with escrow parameters generated from our payment targets. Moreover,
we can no longer start the contracts at the beginning of the test–we
must see the <code class="docutils literal notranslate"><span class="pre">Init</span></code> action first, so that we know what the generated
targets are. To do so, we redefine</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">initialInstances</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
</pre></div>
</div>
<p>and instead add a definition of the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">startInstances</span></code></a> method:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">startInstances</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="p">(</span><span class="kt">Init</span><span class="w"> </span><span class="n">wns</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="kt">CM</span><span class="o">.</span><span class="kt">StartContract</span><span class="w"> </span><span class="p">(</span><span class="kt">WalletKey</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">escrowParams</span><span class="w"> </span><span class="n">wns</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">testWallets</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">startInstances</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
</pre></div>
</div>
<p>where the escrow parameters are now constructed from our generated targets:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">escrowParams</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[(</span><span class="kt">Wallet</span><span class="p">,</span><span class="w"> </span><span class="kt">Integer</span><span class="p">)]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">EscrowParams</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
<span class="nf">escrowParams</span><span class="w"> </span><span class="n">tgts</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kt">EscrowParams</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">escrowTargets</span><span class="w">  </span><span class="ow">=</span><span class="w"></span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="n">payToPaymentPubKeyTarget</span><span class="w"> </span><span class="p">(</span><span class="n">mockWalletPaymentPubKeyHash</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="p">(</span><span class="n">fromInteger</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">tgts</span><span class="w"></span>
<span class="w">        </span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The effect of this is to start the contracts <em>just before</em> the
<code class="docutils literal notranslate"><span class="pre">Init</span></code> action; in fact, using this mechanism, we can start contracts
dynamically at any point in a test case.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We should be careful to avoid reusing the same contract instance
key more than once, though, since this may lead to confusing
results.</p>
<p>You may wonder why we don’t simply start new contract instances in the
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">perform</span></code></a> method instead. The answer is the framework needs to track
the running contract instances, and using <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">startInstances</span></code></a> makes
this explicit.</p>
</div>
<p>The <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:StartContract" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">StartContract</span></code></a> just specifies the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractInstanceKey</span></code></a> to be
started; we define the actual contract to start in the
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">instanceContract</span></code></a> method, <em>which receives the contract parameter</em>
from <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:StartContract" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">StartContract</span></code></a> as its last argument. So we can just define</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">instanceContract</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">WalletKey</span><span class="p">{}</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">testContract</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
</pre></div>
</div>
<p>and our work is (almost) done. The last step is just to update the
<em>type</em> of <code class="docutils literal notranslate"><span class="pre">WalletKey</span></code>, since it includes the type of the parameter
that <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:StartContract" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">StartContract</span></code></a> accepts.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">ContractInstanceKey</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kt">WalletKey</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">ContractInstanceKey</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="kt">EscrowSchema</span><span class="w"> </span><span class="kt">EscrowError</span><span class="w"> </span><span class="p">(</span><span class="kt">EscrowParams</span><span class="w"> </span><span class="kt">Datum</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Now, at last, our extended model is complete.</p>
</section>
<section id="running-our-extended-tests-another-design-issue">
<h3>Running our extended tests; another design issue<a class="headerlink" href="#running-our-extended-tests-another-design-issue" title="Permalink to this heading"></a></h3>
<p>We can now run our new tests, and, as so often happens when the scope
of QuickCheck tests is extended, they do not pass. Here is an example
of a failure:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Actions
 [Init [(Wallet 5,0)],
  Redeem (Wallet 4)]
Expected funds of W[4] to change by
  Value (Map [])
but they changed by
  Value (Map [(,Map [(&quot;&quot;,-2000000)])])
a discrepancy of
  Value (Map [(,Map [(&quot;&quot;,-2000000)])])
Expected funds of W[5] to change by
  Value (Map [])
but they changed by
  Value (Map [(,Map [(&quot;&quot;,2000000)])])
a discrepancy of
  Value (Map [(,Map [(&quot;&quot;,2000000)])])
Test failed.
</pre></div>
</div>
<p>In this case the generated target just specifies that wallet 5 should
receive 0 Ada–a slightly odd target, perhaps, but not obviously
invalid. Since the total of all targets is 0 Ada, then the target is
already met, and wallet 4 attempts to redeem the escrow. We might
expect the effect to be a no-op–and this is what our model
predicts–but it is not what happens. Instead, <em>wallet 4 pays two Ada
to wallet 5</em>!</p>
<p>The reason this happens is the blockchain rule that every transaction
output must contain at least 2 Ada. When wallet 4 attempts to redeem
the escrow, then the off-chain code attempts to create a transaction
with an output paying 0 Ada to wallet 5, but that is increased to 2
Ada to make the transaction valid. Then when the transaction is
balanced, the 2 Ada is taken from the submitting wallet.</p>
<p>Is this a bug in the contract? It is certainly an inconsistency with
the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextState</span></code></a> function in the model, and we could modify that
function to reflect the <em>actual</em> transfers of Ada that the contract
performs. But these transfers were surely not intentional: a more
reasonable approach is to say that target payments that are too small
to be accepted by the blockchain are invalid; such targets should not
be chosen.</p>
<p>We can make our tests pass by tightening the precondition of <code class="docutils literal notranslate"><span class="pre">Init</span></code>
so that targets below the minimum are not accepted:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">precondition</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">Init</span><span class="w"> </span><span class="n">tgts</span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Initial</span><span class="w"></span>
<span class="w">             </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="p">[</span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="p">(</span><span class="n">fromInteger</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="n">geq</span><span class="p">`</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">toValue</span><span class="w"> </span><span class="n">minAdaTxOutEstimated</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">tgts</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>This demonstrates that the contract works as expected, provided we
<em>don’t</em> specify targets less than the minimum, but nothing prevents a
<em>user</em> of the contract from specifying such targets–and we know that
the contract code will accept them, and deliver surprising results in
those cases. Arguably <em>all</em> the contract endpoints should check that
the specified targets are valid, and raise an error if they are
not. This would prevent the <em>creation</em> of invalid escrows, rather than
generating unexpected behaviour when they are redeemed.</p>
<p>Thus these failing tests <em>do</em> suggest a way in which the contract
implementation can be improved, even if the failing cases are fairly
unlikely in practice.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>QuickCheck was able to find this bug because our <em>generator</em> for
target payments includes invalid values; we chose values in the
range 1 to 31, where 1 is invalid (and shrinking reduced the 1 to a
0 in the failing case that was reported). It is a good thing we did
not ensure, from the start, that only valid target values could be
generated–had we done so, we would not have discovered this
anomalous behaviour.</p>
<p>In general, it is a good idea for generators to produce, at least
occasionally, every kind of input that a user can actually supply,
even if some of them are invalid (and may be filtered out by
preconditions). Doing so enables this kind of strange behaviour to
be discovered.</p>
</div>
</section>
<section id="id3">
<h3>Exercises<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<ol class="arabic">
<li><p>You will find the code presented here in <code class="docutils literal notranslate"><span class="pre">Spec.Tutorial.Escrow2</span></code>,
with the exception of the last precondition we discussed for
<code class="docutils literal notranslate"><span class="pre">Init</span></code>. Run the tests using</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>quickCheck prop_Escrow
</pre></div>
</div>
<p>and make sure you understand how they fail.</p>
</li>
<li><p>Make your own copy of the code, and add the tighter precondition
for <code class="docutils literal notranslate"><span class="pre">Init</span></code>. Verify that the tests then pass.</p></li>
<li><p>An alternative explanation for the problem might have been that a
target of <em>zero</em> should not be allowed (and perhaps the contract
implementation should interpret a target of zero by not creating a
transaction output at all). <em>Change the precondition</em> of <code class="docutils literal notranslate"><span class="pre">Init</span></code>
so that it only excludes targets of zero, rather than any target
below the minimum. Verify that the tests still fail, and make sure
you understand the (slightly more complex) failure.</p></li>
<li><p>There are quite a few steps involved in introducing these
dynamically chosen targets. You can practice these steps by taking
the code from <code class="docutils literal notranslate"><span class="pre">Spec.Tutorial.Escrow1</span></code>, which uses fixed targets,
and following the steps outlined in this tutorial to turn it into a
copy of <code class="docutils literal notranslate"><span class="pre">Spec.Tutorial.Escrow2</span></code>.</p></li>
</ol>
</section>
</section>
<section id="testing-no-locked-funds-with-dynamic-logic">
<h2>Testing “No Locked Funds” with Dynamic Logic<a class="headerlink" href="#testing-no-locked-funds-with-dynamic-logic" title="Permalink to this heading"></a></h2>
<p>So far, we have tested that a contract’s actual transfers of tokens
are consistent with the model. That is, <em>nothing goes wrong</em>–or to
put it bluntly, nobody steals your money. This is an example of a
<em>safety property</em>. But when we use smart contracts, this is not the
only kind of property we care about. Very often, we <em>also</em> want to be
certain that we can eventually reach some kind of <em>goal</em> state–an
example of a <em>liveness property</em>. In particular, it would be bad if
tokens were to be trapped in a contract for ever, with no possibility
of recovering them. The Cardano model certainly allows this… imagine
a UTXO whose verifier always returns <code class="docutils literal notranslate"><span class="pre">False</span></code>… and so it is our
responsibility to ensure that contracts do not fall into this
trap. Not only does nothing go wrong, but <em>something good is always
possible</em>. Not only does no-one steal your money, but you can always
recover it yourself.</p>
<p>We call these properties “no locked funds” properties, because that is
usually what we want to test: that we can always reach a state in
which all tokens have been recovered from the contracts under test. Of
course, there is no <em>general</em> way to recover tokens held by a
contract, so we cannot expect QuickCheck to find a way to reach this
goal automatically; instead, we <em>specify a strategy</em> for recovering
funds, and what we test is that the given strategy always works.</p>
<section id="writing-and-testing-properties-using-dynamic-logic">
<h3>Writing and testing properties using Dynamic Logic<a class="headerlink" href="#writing-and-testing-properties-using-dynamic-logic" title="Permalink to this heading"></a></h3>
<p>We specify this kind of property using <em>dynamic logic</em>.
This part of the contract testing framework is inspired
by <a class="reference external" href="http://en.wikipedia.org/wiki/Dynamic_logic_(modal_logic)">dynamic logic for reasoning about programs</a>, but it
can be thought of just as a way of writing <em>test scenarios</em>, in
which we mix random generation, explicit actions, and assertions. We
write such scenarios in the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:DL" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">DL</span></code></a> monad; for example, here is a scenario
that first performs a random sequence of actions, then invokes a
finishing strategy, and finally asserts that no tokens remain locked
in contracts.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">finishEscrow</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">DL</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">finishEscrow</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">anyActions_</span><span class="w"></span>
<span class="w">    </span><span class="n">finishingStrategy</span><span class="w"> </span><span class="n">w1</span><span class="w"></span>
<span class="w">    </span><span class="n">assertModel</span><span class="w"> </span><span class="s">&quot;Locked funds are not zero&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">symIsZero</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">lockedValue</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Here <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:assertModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">assertModel</span></code></a> lets us include an assertion about the contract
model state, <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:lockedValue" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">lockedValue</span></code></a> is a function provided by the framework
that computes the total value held by contracts, and <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:symIsZero" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">symIsZero</span></code></a>
checks that this is zero. The value is returned here as a
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Symbolics.html#t:SymValue" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">SymValue</span></code></a>, but for now it can be thought of just as a normal
Plutus <a class="reference external" href="../../haddock/plutus-ledger/html/Ledger.html#t:Value" title="(in plutus-ledger v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Value</span></code></a> with an extra type wrapper.</p>
<p>This scenario just tests that the given finishing strategy always
succeeds in recovering all tokens from contracts, no matter what
actions have been performed beforehand. The finishing strategy itself
is written in the same monad. For example, if we think we should use a
<code class="docutils literal notranslate"><span class="pre">Redeem</span></code> action to recover the tokens, then we can define</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">finishingStrategy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">DL</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">finishingStrategy</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">currentPhase</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">phase</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="w"> </span><span class="p">(</span><span class="n">currentPhase</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="kt">Initial</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="n">action</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Redeem</span><span class="w"> </span><span class="n">w</span><span class="w"></span>
</pre></div>
</div>
<p>Of course, since the strategy must work in any state, including the
initial one, then we do have to check that the escrow has been
initialised before we attempt to <code class="docutils literal notranslate"><span class="pre">Redeem</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These test scenarios are very flexible, and can be used for other
purposes too. For example, we could write a test scenario that fixes
the escrow targets, thus undoing the generalization we made in the previous section:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fixedTargets</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">DL</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">fixedTargets</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">action</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Init</span><span class="w"> </span><span class="p">[(</span><span class="n">w1</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="n">w2</span><span class="p">,</span><span class="mi">20</span><span class="p">)]</span><span class="w"></span>
<span class="w">  </span><span class="n">anyActions_</span><span class="w"></span>
</pre></div>
</div>
<p>Note that generated actions are always <em>appropriate for the current
state</em>, so here <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:anyActions_" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">anyActions_</span></code></a> will pick up generating the test case
from the point after the escrow targets are initialised.</p>
<p>We can use dynamic logic to express everything from unit tests to full
random generation (by just specifying <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:anyActions_" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">anyActions_</span></code></a> as the
scenario). But for now, we focus on testing “no locked funds” properties.</p>
</div>
<p>Now, dynamic logic just specifies a <em>generator</em> for tests to
perform; we still need to specify <em>how</em> to perform those
tests. Usually, we just reuse the existing property we have already
written, which runs the test case on the emulator and performs the
usual checks. In this case, we can define</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_FinishEscrow</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Property</span><span class="w"></span>
<span class="nf">prop_FinishEscrow</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">forAllDL</span><span class="w"> </span><span class="n">finishEscrow</span><span class="w"> </span><span class="n">prop_Escrow</span><span class="w"></span>
</pre></div>
</div>
<p>Then we can run the tests by passing the property to <a class="reference external" href="https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck.html#v:quickCheck"><code class="docutils literal notranslate"><span class="pre">quickCheck</span></code></a>, as usual:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_FinishEscrow
*** Failed! Falsified (after 1 test and 3 shrinks):
BadPrecondition
  [Do $ Init [(Wallet 2,2)]]
  [Action (Redeem (Wallet 1))]
  (EscrowModel {_contributions = fromList [],
                _targets = fromList [(Wallet 2,Value (Map [(,Map [(&quot;&quot;,2000000)])]))],
                _phase = Running})

BadPrecondition
[Do $ Var 0 := Init [(Wallet 2,2)]]
Some (Redeem (Wallet 1))
</pre></div>
</div>
</div></blockquote>
<p>The property fails, which is not surprising: our “finishing strategy”
is quite simplistic, and not yet expected to work. But let us inspect
the error message. The test failed because of a bad precondition,
after running the sequence</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Init [(Wallet 2,2)]
</pre></div>
</div>
</div></blockquote>
<p>So we set up a target to pay wallet 2 a sum of 2 Ada. Then we tried to
apply our finishing strategy, which is just for wallet 1 to issue a
<code class="docutils literal notranslate"><span class="pre">Redeem</span></code> request:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Redeem (Wallet 1)
</pre></div>
</div>
</div></blockquote>
<p>This wasn’t possible, because the precondition of <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> wasn’t
satisfied. The message also shows us the model state–we have set up
the escrow targets successfully, but there are no contributions, and
the <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> precondition says that the contributions must cover the
targets before <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> is possible. So of course, it doesn’t work.</p>
<p>But the counterexample does show us what we need to do to <em>make</em>
<code class="docutils literal notranslate"><span class="pre">Redeem</span></code> possible: we need to pay in sufficient contributions to
cover the targets. So that suggests a refined finishing strategy:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">finishingStrategy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">DL</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">finishingStrategy</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">currentPhase</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">phase</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="w"> </span><span class="p">(</span><span class="n">currentPhase</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="kt">Initial</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="n">currentTargets</span><span class="w">  </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">targets</span><span class="w"></span>
<span class="w">      </span><span class="n">currentContribs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">contributions</span><span class="w"></span>
<span class="w">      </span><span class="kr">let</span><span class="w"> </span><span class="n">deficit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fold</span><span class="w"> </span><span class="n">currentTargets</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">inv</span><span class="w"> </span><span class="p">(</span><span class="n">fold</span><span class="w"> </span><span class="n">currentContribs</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">when</span><span class="w"> </span><span class="p">(</span><span class="n">deficit</span><span class="w"> </span><span class="p">`</span><span class="n">gt</span><span class="p">`</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"></span>
<span class="w">        </span><span class="n">action</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Pay</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">round</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">getAda</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="n">minAdaTxOutEstimated</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">fromValue</span><span class="w"> </span><span class="n">deficit</span><span class="w"></span>
<span class="w">      </span><span class="n">action</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Redeem</span><span class="w"> </span><span class="n">w</span><span class="w"></span>
</pre></div>
</div>
<p>We read the contributions and targets from the contract state, compute
the remaining deficit, and if the deficit is positive, then we make a
payment to cover it. After this, a <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> should be
successful. And indeed, testing the property passes: this finishing
strategy works.</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt;  quickCheck . withMaxSuccess 1000 $ prop_FinishEscrow
+++ OK, passed 1000 tests.

Actions (51925 in total):
73.483% Pay
14.278% Redeem
10.315% WaitUntil
 1.924% Init
</pre></div>
</div>
</div></blockquote>
</section>
<section id="digression-revisiting-a-design-decision">
<span id="strictredeem"></span><h3>Digression: revisiting a design decision<a class="headerlink" href="#digression-revisiting-a-design-decision" title="Permalink to this heading"></a></h3>
<p>In section <a class="reference internal" href="#designissue"><span class="std std-ref">A third infelicity in the model, and a design issue</span></a> above, we discussed the situation in
which contributors pay in <em>more</em> to the escrow than is needed to meet
the targets. The actual contract allows that, and so do we in our
model; as a consequence we had to <em>specify</em> where the surplus funds
end up on redemption (in the wallet that invokes <code class="docutils literal notranslate"><span class="pre">Redeem</span></code>). But
there is another approach we could have taken: we could simply have
said that <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> <em>requires</em> the contributions and targets to match
exactly, by strengthening the precondition:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">precondition</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="kt">Redeem</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">     </span><span class="n">currentPhase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Running</span><span class="w"></span>
<span class="w">  </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">fold</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">contributions</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">fold</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">targets</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This does make <code class="docutils literal notranslate"><span class="pre">prop_Escrow</span></code> pass:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_Escrow
+++ OK, passed 100 tests.

Actions (2845 in total):
82.81% Pay
13.78% WaitUntil
 3.30% Init
 0.11% Redeem

Actions rejected by precondition (870 in total):
88.3% Redeem
10.8% Pay
 0.9% Init
</pre></div>
</div>
</div></blockquote>
<p>But should we be satisfied with this? There are warning signs in the
statistics that QuickCheck collects:</p>
<ol class="arabic simple">
<li><p>We have tested <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> an extremely small number of times.</p></li>
<li><p>A high proportion of generated <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> actions were <em>discarded</em> by the precondition.</p></li>
</ol>
<p>The explanation for this is that we can now only include <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> in
a test case if the previous (random) payments have hit the target
<em>exactly</em>, and this is very unlikely. Moreover, once we have overshot
the target, then further random payments cannot help.</p>
<p>We could add a stronger <em>precondition</em> to <code class="docutils literal notranslate"><span class="pre">Pay</span></code>, that forbids
payments taking us over the target, and that would result in a better
distribution of actions. But it is not a <em>realistic</em> solution, because
at the end of the day, there is no way to <em>prevent</em> someone making a
payment to a script on the Cardano blockchain. <em>Making a payment to a
contract does not require the contract’s approval</em>.</p>
<p>So there is a problem here, but when we test <code class="docutils literal notranslate"><span class="pre">prop_Escrow</span></code>, then it
is revealed only by careful inspection of the generated
statistics–the property does not <em>fail</em>.</p>
<p>On the other hand, when we test <code class="docutils literal notranslate"><span class="pre">prop_FinishEscrow</span></code>, then it fails immediately:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_FinishEscrow
*** Failed! Falsified (after 5 tests and 6 shrinks):
BadPrecondition
  [Do $ Init [],
   Do $ Pay (Wallet 2) 2]
  [Action (Redeem (Wallet 1))]
  (EscrowModel {_contributions = fromList [(Wallet 2,Value (Map [(,Map [(&quot;&quot;,2000000)])]))],
                _targets = fromList [],
                _phase = Running})

BadPrecondition
[Do $ Var 0 := Init [],Do $ Var 3 := Pay (Wallet 2) 2]
Some (Redeem (Wallet 1))
</pre></div>
</div>
</div></blockquote>
<p>The counterexample sets up an escrow with an empty list of targets
(which may seem odd, but is allowed, and tells us that no particular
targets are <em>needed</em> to make the property fail). Then it makes a
payment to the escrow, thus overshooting the targets. Finally, we try
to use the given finishing strategy–which just attempts to use
<code class="docutils literal notranslate"><span class="pre">Redeem</span></code>, and fails because the strong precondition we wrote does
not allow it.</p>
<p>In this case, not only does the given finishing strategy fail, but the
bug cannot be fixed: <em>there is no possible finishing strategy that
works</em>. Once we have overshot the targets, there is no way to return
to a state in which <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> is possible! And that is why the
contract authors did <em>not</em> follow this path: had they done so, then an
attacker would be able to ‘brick’ an escrow contract just by making an
unexpected payment to it.</p>
</section>
<section id="fair-s-fair-unilateral-strategies">
<h3>Fair’s fair: Unilateral strategies<a class="headerlink" href="#fair-s-fair-unilateral-strategies" title="Permalink to this heading"></a></h3>
<p>We saw above how to test that a finishing strategy succeeds in
recovering all the tokens. But not all strategies are created
equal. For example, suppose you use an escrow contract to buy an
NFT. You place your funds in the escrow, but before the seller can
place the NFT there, they get a better offer. Now the seller will
never place the NFT in the escrow–and neither can the buyer–and so
the buyer’s funds <em>will</em> be locked for ever, even though there is a
way (using the NFT) to recover them.</p>
<p>This little story shows that there is a need for each wallet to be
able to recover their “fair share” of the funds in the contract,
without any other wallet’s cooperation. And the contract model
framework provides a way of testing this too.</p>
<p>The idea is to provide <em>two</em> strategies, one that recovers all the
tokens from contracts, and is also interpreted to define each wallet’s
“fair share”, and a second strategy <em>that can be followed by any
single wallet</em>, and recovers that wallet’s tokens. We call this kind
of strategy a <em>unilateral</em> strategy; it is defined in the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:DL" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">DL</span></code></a> monad
in just the same way as the strategies we saw earlier, but only a
single wallet is allowed to perform actions. Indeed, this is why we
gave <code class="docutils literal notranslate"><span class="pre">finishingStrategy</span></code> a wallet as a parameter: it defines the
unilateral strategy for that wallet. Since the strategy uses
<code class="docutils literal notranslate"><span class="pre">Redeem</span></code>, which actually pays out <em>all</em> the targets, then we can
reuse it as the general strategy too, just by choosing a wallet to
perform it (and we chose wallet 1 above).</p>
<p>The framework lets us package the general and unilateral strategies
together, into a “no locked funds proof”:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">noLockProof</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">NoLockedFundsProof</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"></span>
<span class="nf">noLockProof</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">defaultNLFP</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">nlfpMainStrategy</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="n">finishingStrategy</span><span class="w"> </span><span class="n">w1</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">nlfpWalletStrategy</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">finishingStrategy</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are other components in a <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:NoLockedFundsProof" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">NoLockedFundsProof</span></code></a>, which we
will see later; we can ignore them for now, but we do need to take
suitable default values from <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:defaultNLFP" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">defaultNLFP</span></code></a> in the definition
above.</p>
</div>
<p>and we can test them together using <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:checkNoLockedFundsProof" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">checkNoLockedFundsProof</span></code></a></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_NoLockedFunds</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Property</span><span class="w"></span>
<span class="nf">prop_NoLockedFunds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">checkNoLockedFundsProof</span><span class="w"> </span><span class="n">noLockProof</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_NoLockedFunds
*** Failed! Falsified (after 1 test and 5 shrinks):
DLScript
  [Do $ Init [(Wallet 4,2)]]

Unilateral strategy for Wallet 4 should have gotten it at least
  SymValue {symValMap = fromList [], actualValPart = Value (Map [(,Map [(&quot;&quot;,2000000)])])}
but it got
  SymValue {symValMap = fromList [], actualValPart = Value (Map [])}
</pre></div>
</div>
<p>The property actually fails, because if all we do is create a target
that wallet 4 should receive 2 Ada, then wallet 4’s unilateral
strategy is unable to recover that–even though, when wallet 1 follows
the strategy, then wallet 4 does receive the money.</p>
<p>What happens here is that the <em>general</em> strategy, which is just the
same strategy followed by wallet 1, <em>does</em> pay out to wallet 4, and so
we <em>define</em> wallet 4’s “fair share” to be 2 Ada. But this isn’t really
right, because since no Ada have been paid into the contract, then
there are no tokens to disburse. Indeed, if anything, the “general”
strategy is <em>unfair</em> to wallet 1, which has to stump up 2 Ada in this
situation so that the escrow can be redeemed. So this test failure
does reveal a fairness problem, even if the victim is really wallet 1
rather than wallet 4.</p>
<p>We will see how to fix this problem in the next section. In the
meantime, to summarize, defining a <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:NoLockedFundsProof" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">NoLockedFundsProof</span></code></a> requires us</p>
<ol class="arabic simple">
<li><p>to define a general strategy that can recover <em>all</em> the tokens from
the contracts under test, and moreover implies a <em>fair share</em> of
the tokens for each wallet <em>in any state</em> (for example, a fair
share of the profits-so-far of any trading contract),</p></li>
<li><p>to define a <em>unilateral strategy</em> for each wallet, that can recover
that wallet’s fair share of the tokens from any state, without
cooperation from any other wallet.</p></li>
</ol>
</section>
<section id="fixing-the-contract-refunds">
<h3>Fixing the contract: refunds<a class="headerlink" href="#fixing-the-contract-refunds" title="Permalink to this heading"></a></h3>
<p>The fundamental problem with the finishing strategy we have developed
so far, is that in order to recover tokens already held by the
contract, we may need to pay in even more tokens! This seems a poor
design. It would make far more sense, in the event that the contract
is not followed to completion, to <em>refund</em> contributions to the
wallets that made them. And indeed, the actual implementation of the
contract supports a <a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html#v:refund" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">refund</span></code></a> endpoint as well.</p>
<p>To add refunds to our model, we need to add a new action</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">Action</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Init</span><span class="w"> </span><span class="p">[(</span><span class="kt">Wallet</span><span class="p">,</span><span class="w"> </span><span class="kt">Integer</span><span class="p">)]</span><span class="w"></span>
<span class="w">                          </span><span class="o">|</span><span class="w"> </span><span class="kt">Redeem</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"></span>
<span class="w">                          </span><span class="o">|</span><span class="w"> </span><span class="kt">Pay</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="w">                          </span><span class="o">|</span><span class="w"> </span><span class="kt">Refund</span><span class="w"> </span><span class="kt">Wallet</span><span class="w">            </span><span class="c1">-- NEW!</span><span class="w"></span>
<span class="w">    </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">Generic</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>and add it to <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextState</span></code></a>, <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">precondition</span></code></a>, <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">perform</span></code></a>, and <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">arbitraryAction</span></code></a>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">nextState</span><span class="w"> </span><span class="p">(</span><span class="kt">Refund</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="n">v</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">contributions</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">fold</span><span class="w"></span>
<span class="w">      </span><span class="n">contributions</span><span class="w"> </span><span class="o">%=</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">delete</span><span class="w"> </span><span class="n">w</span><span class="w"></span>
<span class="w">      </span><span class="n">deposit</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="w">      </span><span class="n">wait</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">  </span><span class="n">precondition</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="kt">Refund</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">       </span><span class="n">currentPhase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Running</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="p">`</span><span class="kt">Map</span><span class="o">.</span><span class="n">member</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">contributions</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">where</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">phase</span><span class="w"></span>

<span class="w">  </span><span class="n">perform</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="p">(</span><span class="kt">Refund</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="kt">Trace</span><span class="o">.</span><span class="n">callEndpoint</span><span class="w"> </span><span class="o">@</span><span class="s">&quot;refund-escrow&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">WalletKey</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">      </span><span class="n">delay</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">  </span><span class="n">arbitraryAction</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
<span class="w">    </span><span class="o">...</span><span class="w"></span>
<span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="n">frequency</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="o">++</span><span class="w"></span>
<span class="w">                    </span><span class="p">[</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">Refund</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">elements</span><span class="w"> </span><span class="n">testWallets</span><span class="p">)</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>(In the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextState</span></code></a> clause, the first line uses a more complex lens
to extract the contributions, select the value for wallet <code class="docutils literal notranslate"><span class="pre">w</span></code>, if
present, and then pass the resulting <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Value</span></code> to <a class="reference external" href="https://hackage.haskell.org/package/base-4.16.1.0/docs/Data-Foldable.html#v:fold"><code class="docutils literal notranslate"><span class="pre">fold</span></code></a>, thus
returning zero if there was no contribution, and the value itself if
there was). We also have to extend the <code class="docutils literal notranslate"><span class="pre">testContract</span></code> to include the
refund endpoint:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">testContract</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">EscrowParams</span><span class="w"> </span><span class="kt">Datum</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Contract</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="kt">EscrowSchema</span><span class="w"> </span><span class="kt">EscrowError</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">testContract</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">selectList</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">payEp</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="w">                                 </span><span class="p">,</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">redeemEp</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="w">                                 </span><span class="p">,</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">refundEp</span><span class="w"> </span><span class="n">params</span><span class="w">     </span><span class="c1">-- NEW!</span><span class="w"></span>
<span class="w">                                 </span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">testContract</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
</pre></div>
</div>
<p>With these additions, <code class="docutils literal notranslate"><span class="pre">prop_Escrow</span></code> still passes, but
now tests refunds as well:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_Escrow
+++ OK, passed 100 tests.

Actions (2625 in total):
66.44% Pay
12.46% WaitUntil
 9.64% Redeem
 7.96% Refund
 3.50% Init

Actions rejected by precondition (478 in total):
85.8% Refund
12.6% Pay
 1.7% Init
</pre></div>
</div>
<p>We can see that <code class="docutils literal notranslate"><span class="pre">Refund</span></code> is tested almost as often as <code class="docutils literal notranslate"><span class="pre">Redeem</span></code>,
although many refunds are rejected by the precondition (which requires
that there actually <em>is</em> a contribution to refund). This isn’t a big
deal, though, because the overall proportion of rejected actions is
low (15%), and sufficiently many <code class="docutils literal notranslate"><span class="pre">Refund</span></code> actions are being tested.</p>
<p>The payoff, though, is that we can now define a far better finishing
strategy: the general strategy will just refund all the contributions,
and the unilateral strategies will claim a refund for the
wallet concerned.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">finishingStrategy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">DL</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">finishingStrategy</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">contribs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">viewContractState</span><span class="w"> </span><span class="n">contributions</span><span class="w"></span>
<span class="w">    </span><span class="kt">CM</span><span class="o">.</span><span class="n">monitor</span><span class="w"> </span><span class="p">(</span><span class="n">tabulate</span><span class="w"> </span><span class="s">&quot;Refunded wallets&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">show</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">size</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">contribs</span><span class="p">])</span><span class="w"></span>
<span class="w">    </span><span class="n">sequence_</span><span class="w"> </span><span class="p">[</span><span class="kt">CM</span><span class="o">.</span><span class="n">action</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Refund</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">testWallets</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="p">`</span><span class="kt">Map</span><span class="o">.</span><span class="n">member</span><span class="p">`</span><span class="w"> </span><span class="n">contribs</span><span class="p">]</span><span class="w"></span>

<span class="nf">walletStrategy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">DL</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">walletStrategy</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">contribs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">viewContractState</span><span class="w"> </span><span class="n">contributions</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="w"> </span><span class="p">`</span><span class="kt">Map</span><span class="o">.</span><span class="n">member</span><span class="p">`</span><span class="w"> </span><span class="n">contribs</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">action</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Refund</span><span class="w"> </span><span class="n">w</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Here we use <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:monitor" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">monitor</span></code></a> to gather statistics on the number of
wallets receiving refunds during the finishing strategy, just to
make sure, for example, that it is not always zero. We place such
monitoring in the <em>general</em> strategy, not the wallet-specific ones,
because the general strategy is invoked exactly once per test,
while the wallet-specific ones may be invoked a variable–and
unpredictable–number of times. This makes statistics gathered in
the wallet-specific strategies harder to interpret.</p>
</div>
<p>We put these strategies together into a <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:NoLockedFundsProof" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">NoLockedFundsProof</span></code></a>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">noLockProof</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">NoLockedFundsProof</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"></span>
<span class="nf">noLockProof</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">defaultNLFP</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">nlfpMainStrategy</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="n">finishingStrategy</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">nlfpWalletStrategy</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">walletStrategy</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>and run tests:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_NoLockedFunds
+++ OK, passed 100 tests.

Actions (31076 in total):
65.211% Pay
11.794% WaitUntil
10.117% Redeem
 9.506% Refund
 1.847% Init
 1.525% Unilateral

Refunded wallets (100 in total):
30% 2
23% 1
17% 4
16% 3
13% 0
 1% 5
</pre></div>
</div>
<p>Now the tests pass–each wallet can indeed recover its own fair share
of tokens–and moreover we test each action fairly often, and the
number of refunded wallets has a reasonable-looking distribution.</p>
</section>
<section id="id4">
<h3>Exercises<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<p>You will find the code presented in this section in <code class="docutils literal notranslate"><span class="pre">Spec.Tutorial.Escrow3</span></code>.</p>
<ol class="arabic">
<li><p>Strengthen the precondition of <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> to require the
contributions and targets to match exactly, as discussed in
<a class="reference internal" href="#strictredeem"><span class="std std-ref">Digression: revisiting a design decision</span></a>. Verify that <code class="docutils literal notranslate"><span class="pre">prop_Escrow</span></code> passes and
<code class="docutils literal notranslate"><span class="pre">prop_FinishEscrow</span></code> fails. Now, <em>add a precondition to</em> <code class="docutils literal notranslate"><span class="pre">Pay</span></code>
to disallow payments that take the contributions over the target.</p>
<ol class="arabic simple">
<li><p>Test <code class="docutils literal notranslate"><span class="pre">prop_Escrow</span></code>, and make sure it passes; have you achieved
a better distribution of actions in tests?</p></li>
<li><p>Test <code class="docutils literal notranslate"><span class="pre">prop_FinishEscrow</span></code>; does it pass now?</p></li>
</ol>
</li>
<li><p>The code provided uses the poor finishing strategy based on
<code class="docutils literal notranslate"><span class="pre">Redeem</span></code>. Verify that <code class="docutils literal notranslate"><span class="pre">prop_NoLockedFunds</span></code> fails, and replace
the strategy with the better one described above (you will find the
code in comments in the file). Verify that <code class="docutils literal notranslate"><span class="pre">prop_NoLockedFunds</span></code>
passes now.</p>
<p>Do not be surprised if testing <code class="docutils literal notranslate"><span class="pre">prop_NoLockedFunds</span></code> is
considerably slower than testing <code class="docutils literal notranslate"><span class="pre">prop_FinishEscrow</span></code>. The latter
runs the emulator only once per test, while the former must run it
repeatedly to test each wallet’s unilateral strategy.</p>
</li>
<li><p>Sometimes a wallet which is targetted to <em>receive</em> funds might do
better to complete the contributions and redeem the escrow, rather
than refund its own contribution. Implement this idea as a
per-wallet strategy, and see whether <code class="docutils literal notranslate"><span class="pre">prop_NoLockedFunds</span></code> still
passes. Add a call of <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:monitor" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">monitor</span></code></a> to your strategy to gather
statistics on how often <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> is used instead of <code class="docutils literal notranslate"><span class="pre">Refund</span></code>.</p></li>
</ol>
</section>
</section>
<section id="taking-time-into-account">
<h2>Taking Time into Account<a class="headerlink" href="#taking-time-into-account" title="Permalink to this heading"></a></h2>
<p>In the last section we added refunds to our tests; now a client can
pay into an escrow, and claim a refund of their contribution
freely–but this doesn’t really correspond to the intention of an
escrow contract. In reality, an escrow contract should have a deadline
for payments and redemption, with refunds permitted only after the
deadline has passed. In fact, the <em>real</em> escrow contract, in
<a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Escrow.html" title="(in plutus-use-cases v1.1.0.0)"><code class="xref hs hs-hsmod docutils literal notranslate"><span class="pre">Plutus.Contracts.Escrow</span></code></a>, provides such a deadline: the main
difference between this and the simplified contract we have tested so
far, <a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Tutorial-Escrow.html" title="(in plutus-use-cases v1.1.0.0)"><code class="xref hs hs-hsmod docutils literal notranslate"><span class="pre">Plutus.Contracts.Tutorial.Escrow</span></code></a>, is that the latter omits
the deadline and associated checks.</p>
<p>In this section, we’ll switch to testing the real contract, which we
can achieve just by changing the import in our model to be the real
contract. (As usual, you can find the code presented in this section
in <code class="docutils literal notranslate"><span class="pre">Spec.Tutorial.Escrow4</span></code>).</p>
<section id="slots-and-posixtime">
<h3>Slots and POSIXTime<a class="headerlink" href="#slots-and-posixtime" title="Permalink to this heading"></a></h3>
<p>Just changing the import leads to a compiler warning: the
<a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Escrow.html#t:EscrowParams" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">EscrowParams</span></code></a> type, which is passed to the contract under test, has
a new field <a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Escrow.html#t:EscrowParams" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">escrowDeadline</span></code></a>, and so far, our code does not
initialise it. We will generate the deadlines, so that they vary from
test to test, but there is a slight mismatch to overcome first. In a
contract model we measure time in <em>slots</em>, but the <a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Escrow.html#t:EscrowParams" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">escrowDeadline</span></code></a>
field is not a slot number, it is a <a class="reference external" href="../../haddock/plutus-ledger-api/html/Plutus-V1-Ledger-Time.html#t:POSIXTime" title="(in plutus-ledger-api v1.0.0.1)"><code class="docutils literal notranslate"><span class="pre">POSIXTime</span></code></a>. So while we shall
generate the deadline as a slot number (for convenience in the model),
we must convert it to a <a class="reference external" href="../../haddock/plutus-ledger-api/html/Plutus-V1-Ledger-Time.html#t:POSIXTime" title="(in plutus-ledger-api v1.0.0.1)"><code class="docutils literal notranslate"><span class="pre">POSIXTime</span></code></a> before we can pass it to the
contract under test.</p>
<p>To do so, we need to know when slot 0 happens in POSIX time, and how
long the duration of each slot is. These are defined in a
<a class="reference external" href="../../haddock/cardano-node-emulator/html/Cardano-Node-Emulator-TimeSlot.html#t:SlotConfig" title="(in cardano-node-emulator v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">SlotConfig</span></code></a>, a type defined in <a class="reference external" href="../../haddock/cardano-node-emulator/html/Cardano-Node-Emulator-TimeSlot.html" title="(in cardano-node-emulator v1.1.0.0)"><code class="xref hs hs-hsmod docutils literal notranslate"><span class="pre">Cardano.Node.Emulator.TimeSlot</span></code></a>. In principle
the slot configuration might vary, but we will use the default values
for testing (by using <a class="reference external" href="https://hackage.haskell.org/package/data-default-0.7.1.1/docs/Data-Default.html#v:def"><code class="docutils literal notranslate"><span class="pre">def</span></code></a> from <a class="reference external" href="https://hackage.haskell.org/package/data-default-0.7.1.1/docs/Data-Default.html"><code class="docutils literal notranslate"><span class="pre">Data.Default</span></code></a> as our
configuration. Putting all this together, we can add a deadline to our
<a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Escrow.html#t:EscrowParams" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">EscrowParams</span></code></a> as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">escrowParams</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Slot</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[(</span><span class="kt">Wallet</span><span class="p">,</span><span class="w"> </span><span class="kt">Integer</span><span class="p">)]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">EscrowParams</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
<span class="nf">escrowParams</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">tgts</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kt">EscrowParams</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">escrowTargets</span><span class="w">  </span><span class="ow">=</span><span class="w"></span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="n">payToPaymentPubKeyTarget</span><span class="w"> </span><span class="p">(</span><span class="n">mockWalletPaymentPubKeyHash</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="p">(</span><span class="n">fromInteger</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">tgts</span><span class="w"></span>
<span class="w">        </span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">escrowDeadline</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">scSlotZeroTime</span><span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">POSIXTime</span><span class="w"> </span><span class="p">(</span><span class="n">getSlot</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scSlotLength</span><span class="w"> </span><span class="n">def</span><span class="p">)</span><span class="w">     </span><span class="c1">-- NEW!!!</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you are familiar with the <a class="reference external" href="https://hackage.haskell.org/package/time-1.13/docs/Data-Time-Clock-POSIX.html#t:POSIXTime"><code class="docutils literal notranslate"><span class="pre">POSIXTime</span></code></a> type from
<a class="reference external" href="https://hackage.haskell.org/package/time-1.13/docs/Data-Time-Clock-POSIX.html"><code class="docutils literal notranslate"><span class="pre">Data.Time.Clock.POSIX</span></code></a>, then beware that <em>this is not the same
type</em>. That type has a resolution of picoseconds, while Plutus uses
its own <a class="reference external" href="../../haddock/plutus-ledger-api/html/Plutus-V1-Ledger-Time.html#t:POSIXTime" title="(in plutus-ledger-api v1.0.0.1)"><code class="docutils literal notranslate"><span class="pre">POSIXTime</span></code></a> type with a resolution of milliseconds.</p>
</div>
</section>
<section id="initialising-the-deadline">
<h3>Initialising the deadline<a class="headerlink" href="#initialising-the-deadline" title="Permalink to this heading"></a></h3>
<p>The deadline, like the escrow targets, is fixed for each test, so it
makes sense to add the deadline as a new field to the <code class="docutils literal notranslate"><span class="pre">Init</span></code>
action–recall that it is the <code class="docutils literal notranslate"><span class="pre">Init</span></code> action that starts the contract
instances under test, and so must supply the deadline as part of the
<a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Escrow.html#t:EscrowParams" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">EscrowParams</span></code></a>. So we add the deadline slot to this action</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">Action</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Init</span><span class="w"> </span><span class="kt">Slot</span><span class="w"> </span><span class="p">[(</span><span class="kt">Wallet</span><span class="p">,</span><span class="w"> </span><span class="kt">Integer</span><span class="p">)]</span><span class="w">    </span><span class="c1">-- NEW!!!</span><span class="w"></span>
<span class="w">                          </span><span class="o">|</span><span class="w"> </span><span class="kt">Redeem</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"></span>
<span class="w">                          </span><span class="o">|</span><span class="w"> </span><span class="kt">Pay</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="w">                          </span><span class="o">|</span><span class="w"> </span><span class="kt">Refund</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"></span>
<span class="w">    </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">Generic</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>and pass it to the contracts in the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">startInstances</span></code></a> method:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">startInstances</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="p">(</span><span class="kt">Init</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">wns</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="kt">CM</span><span class="o">.</span><span class="kt">StartContract</span><span class="w"> </span><span class="p">(</span><span class="kt">WalletKey</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">escrowParams</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">wns</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">testWallets</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Just as we record the escrow targets in the model state, so we will
need to include the deadline as part of the model, so we extend our
model type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="kt">EscrowModel</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="n">_contributions</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="kt">Value</span><span class="o">.</span><span class="kt">Value</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">_targets</span><span class="w">       </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="kt">Value</span><span class="o">.</span><span class="kt">Value</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">_refundSlot</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="kt">Slot</span><span class="w">             </span><span class="c1">-- NEW!!!</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">_phase</span><span class="w">         </span><span class="ow">::</span><span class="w"> </span><span class="kt">Phase</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">Generic</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>and record the deadline in our model state transition:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">nextState</span><span class="w"> </span><span class="p">(</span><span class="kt">Init</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">wns</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="n">phase</span><span class="w">   </span><span class="o">.=</span><span class="w"> </span><span class="kt">Running</span><span class="w"></span>
<span class="w">      </span><span class="n">targets</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span><span class="w"> </span><span class="p">[(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="p">(</span><span class="n">fromInteger</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">wns</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="n">refundSlot</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">s</span><span class="w">                 </span><span class="c1">-- NEW!!!</span><span class="w"></span>
</pre></div>
</div>
<p>It just remains to generate deadline slots (we choose positive
integers), and shrink them (by reusing integer shrinking):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">arbitraryAction</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Initial</span><span class="w"></span>
<span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="kt">Init</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Slot</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">getPositive</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">arbitrary</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">arbitraryTargets</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">shrinkAction</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="p">(</span><span class="kt">Init</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">tgts</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="kt">Init</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">shrinkList</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="ow">-&gt;</span><span class="p">(</span><span class="n">w</span><span class="p">,)</span><span class="o">&lt;$&gt;</span><span class="n">shrink</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">tgts</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="o">++</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(`</span><span class="kt">Init</span><span class="p">`</span><span class="w"> </span><span class="n">tgts</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="kt">Slot</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">shrink</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">getSlot</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w">      </span><span class="c1">-- NEW!!!</span><span class="w"></span>
</pre></div>
</div>
<p>Now we are ready to run tests.</p>
<blockquote>
<div></div></blockquote>
</section>
<section id="modelling-the-passage-of-time">
<span id="timing"></span><h3>Modelling the passage of time<a class="headerlink" href="#modelling-the-passage-of-time" title="Permalink to this heading"></a></h3>
<p>We can now run tests, but they do not pass:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_Escrow
*** Failed! Assertion failed (after 5 tests and 7 shrinks):
Actions
 [Init (Slot {getSlot = 0}) [],
  Pay (Wallet 1) 2]
Expected funds of W[1] to change by
  Value (Map [(,Map [(&quot;&quot;,-2000000)])])
but they did not change
Test failed.
Emulator log:
[INFO] Slot 0: TxnValidate ee3a44b98e0325e19bc6be1e6f25cdb269301666a3473758296e96cd7ea9a851
[INFO] Slot 1: 00000000-0000-4000-8000-000000000000 {Wallet W[1]}:
                 Contract instance started
[INFO] Slot 1: 00000000-0000-4000-8000-000000000001 {Wallet W[2]}:
                 Contract instance started
...
</pre></div>
</div>
<p>We tried to pay 2 Ada from wallet 1, but the payment did not take
effect. Notice that the generated deadline is slot zero, though; in
other words, the deadline passed before we started the test. This
might seem surprising, since we <em>generated</em> the deadline as a positive
integer (and zero does not count as positive), but it is the result of
shrinking. If we don’t want to test a deadline of slot zero, then we
must strengthen the precondition of <code class="docutils literal notranslate"><span class="pre">Init</span></code> to prevent it.</p>
<p>Noting that the contract instances do not start until slot one, let us
require the deadline slot to be greater than that–at least slot
two. When we add this to the precondition then tests still fail, but
the shrunk counterexample is different:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_Escrow
*** Failed! Assertion failed (after 2 tests and 5 shrinks):
Actions
 [Init (Slot {getSlot = 2}) [],
  WaitUntil (Slot {getSlot = 2}),
  Pay (Wallet 3) 2]
Expected funds of W[3] to change by
  Value (Map [(,Map [(&quot;&quot;,-2000000)])])
but they did not change
Test failed.
</pre></div>
</div>
<p>This test case makes the problem easier to see: it</p>
<ol class="arabic simple">
<li><p>first, initializes the deadline to slot 2</p></li>
<li><p>then, <em>waits until</em> slot 2,</p></li>
<li><p>and finally, attempts a payment, which does not go through.</p></li>
</ol>
<p>The second action, <code class="docutils literal notranslate"><span class="pre">WaitUntil</span></code>, is one we have not seen in
counterexamples previously; it only appears when <em>timing is important</em>
to provoke a failure. In this case it’s now clear what the problem is:
<em>the contract does not allow payments after the deadline</em>. So the next
step is to encode this in our model.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">WaitUntil</span></code> actions are inserted automatically into test cases by
the framework, to explore timing dependence. It is <em>possible</em> to
control the probability of a <code class="docutils literal notranslate"><span class="pre">WaitUntil</span></code> action, and the
distribution of the slots that we wait for, but it is often not
<em>necessary</em>–the default behaviour is often good enough.</p>
</div>
<p>The contract model framework automatically keeps track of the current
slot number for us, so we <em>could</em> write a precondition for <code class="docutils literal notranslate"><span class="pre">Pay</span></code>
that refers explicitly to the slot number. However, all that really
matters is <em>whether or not the deadline has passed</em>–and probably
other parts of the model will depend on this too. So it is simpler to
check for this in one place, and then just refer to it elsewhere in
the model.</p>
<p>Now we can benefit from our choice earlier to introduce a <code class="docutils literal notranslate"><span class="pre">phase</span></code>
field in the model: hitherto it has only distinguished initialization
from running the test, but now we can add a new phase: <code class="docutils literal notranslate"><span class="pre">Refunding</span></code></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Initial</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Running</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Refunding</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">Generic</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The idea is that when the deadline passes, we move into the
<code class="docutils literal notranslate"><span class="pre">Refunding</span></code> phase, and we can refer to the current phase in
preconditions. In fact, our preconditions <em>already</em> refer to the
phase, so with this change then <code class="docutils literal notranslate"><span class="pre">Pay</span></code> and <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> will be
restricted to take place <em>before</em> the deadline. All we have to do is
to adjust the precondition for <code class="docutils literal notranslate"><span class="pre">Refund</span></code>, which should of course be
restricted to <em>after</em> the deadline:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">precondition</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">Init</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">tgts</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Initial</span><span class="w"></span>
<span class="w">                </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">                </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="p">[</span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="p">(</span><span class="n">fromInteger</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="kt">Value</span><span class="o">.</span><span class="n">geq</span><span class="p">`</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">toValue</span><span class="w"> </span><span class="n">minAdaTxOutEstimated</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">tgts</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="kt">Redeem</span><span class="w"> </span><span class="kr">_</span><span class="w">    </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Running</span><span class="w"></span>
<span class="w">                </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">fold</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">contributions</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="kt">Value</span><span class="o">.</span><span class="n">geq</span><span class="p">`</span><span class="w"> </span><span class="n">fold</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">targets</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kt">Pay</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">v</span><span class="w">     </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Running</span><span class="w"></span>
<span class="w">                </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="p">(</span><span class="n">fromInteger</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="kt">Value</span><span class="o">.</span><span class="n">geq</span><span class="p">`</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">toValue</span><span class="w"> </span><span class="n">minAdaTxOutEstimated</span><span class="w"></span>
<span class="w">    </span><span class="kt">Refund</span><span class="w"> </span><span class="n">w</span><span class="w">    </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Refunding</span><span class="w">           </span><span class="c1">-- NEW!!!</span><span class="w"></span>
<span class="w">                </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="p">`</span><span class="kt">Map</span><span class="o">.</span><span class="n">member</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">contributions</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">where</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">phase</span><span class="w"></span>
</pre></div>
</div>
<p>One question remains: <em>where do we change the phase?</em> Changing the
phase changes the model state, but not in response to an <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Action</span></code></a>:
it doesn’t matter whether or not an action is performed on the
deadline, the phase must change anyway. This means that <em>we cannot
change the phase in the</em> <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextState</span></code></a> <em>function</em>, because this is
invoked only when actions are performed. We need to be able to <em>change
the contract state in response to the passage of time</em>. We can do this
by defining the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextReactiveState</span></code></a> method of the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a>
class.</p>
<p>This method is called every time the slot number advances in the model
(although not necessarily every slot–slot numbers can jump during a
test). In this case all we need to do is compare the new slot number
with the deadline, and move to the <code class="docutils literal notranslate"><span class="pre">Refunding</span></code> phase if appropriate:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">nextReactiveState</span><span class="w"> </span><span class="n">slot</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">deadline</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">viewContractState</span><span class="w"> </span><span class="n">refundSlot</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="w"> </span><span class="p">(</span><span class="n">slot</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">deadline</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="kt">Refunding</span><span class="w"></span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">prop_Escrow</span></code> passes.</p>
</section>
<section id="monitoring-and-the-distribution-of-tests">
<h3>Monitoring and the distribution of tests<a class="headerlink" href="#monitoring-and-the-distribution-of-tests" title="Permalink to this heading"></a></h3>
<p>Testing <code class="docutils literal notranslate"><span class="pre">prop_Escrow</span></code> generates some interesting statistics:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_Escrow
+++ OK, passed 100 tests.

Actions (2291 in total):
62.03% WaitUntil
27.37% Pay
 3.71% Redeem
 3.62% Init
 3.27% Refund

Actions rejected by precondition (11626 in total):
70.437% Pay
23.757% Refund
 5.746% Redeem
 0.060% Init
</pre></div>
</div>
<p>In comparison with previous versions of this property, we can see from
the first table that there are <em>many</em> more <code class="docutils literal notranslate"><span class="pre">WaitUntil</span></code> actions in
these tests (previously they were around 10% of the tested
actions). Moreover, we can see that many more generated actions were
rejected by their precondition: we rejected over 11,000 actions, while
generating 2291 that were included in tests. Rejecting so many actions
is undesirable: not only does it waste testing time, but there is a
risk that the <em>distribution</em> of accepted actions is quite different
from that of generated actions, which can lead to ineffective testing.</p>
<p>But why do we see this behaviour? It is because <em>once the deadline has
passed, then neither</em> <code class="docutils literal notranslate"><span class="pre">Pay</span></code> <em>nor</em> <code class="docutils literal notranslate"><span class="pre">Redeem</span></code> <em>is possible</em>; when we
generate these actions, then they will <em>always</em> be rejected by their
preconditions. Moreover, <em>after the deadline then we can</em> <code class="docutils literal notranslate"><span class="pre">Refund</span></code>
<em>each wallet at most once</em>. Once the deadline has passed, and all the
contributions have been refunded, then the preconditions allow no
further actions–except <code class="docutils literal notranslate"><span class="pre">WaitUntil</span></code>. And so, test case generation
will choose <code class="docutils literal notranslate"><span class="pre">WaitUntil</span></code>, over and over again, and this is why so
many of them appear in our tests.</p>
<p>The following tables tell us more about the passage of time in our tests:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Wait interval (1421 in total):
28.85% &lt;10
25.83% 10-19
23.15% 20-29
15.76% 30-39
 5.77% 40-49
 0.63% 50-59

Wait until (1421 in total):
14.07% 100-199
12.03% 1000-1999
 9.29% 200-299
 8.94% 300-399
 7.67% 400-499
 ...
 2.32% 2000-2999
 ...
</pre></div>
</div>
<p>The first table shows us <em>how long</em> we waited at each individual
occurrence of <code class="docutils literal notranslate"><span class="pre">WaitUntil</span></code>: mostly under 30 slots, but up to 59 slots
at a maximum. The second table shows us which slot numbers we waited
until: we can see that many tests ran for several hundred slots, and
indeed, some ran for over 2000 slots.</p>
<p>Luckily, waiting is cheap, but since we are performing fewer useful
actions in each test, then we should probably run more tests overall
for the same level of confidence in our code.</p>
</section>
<section id="no-locked-funds">
<h3>No locked funds?<a class="headerlink" href="#no-locked-funds" title="Permalink to this heading"></a></h3>
<p>We still need to test that we can recover all tokens from the escrow,
and do so fairly. Recall our previous finishing strategy:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">finishingStrategy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">DL</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">finishingStrategy</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">contribs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">contributions</span><span class="w"></span>
<span class="w">    </span><span class="n">monitor</span><span class="w"> </span><span class="p">(</span><span class="n">tabulate</span><span class="w"> </span><span class="s">&quot;Refunded wallets&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">show</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">size</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">contribs</span><span class="p">])</span><span class="w"></span>
<span class="w">    </span><span class="n">sequence_</span><span class="w"> </span><span class="p">[</span><span class="n">action</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Refund</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">testWallets</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="p">`</span><span class="kt">Map</span><span class="o">.</span><span class="n">member</span><span class="p">`</span><span class="w"> </span><span class="n">contribs</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>If we just use this as it is, it will fail. As before, we begin by
testing <code class="docutils literal notranslate"><span class="pre">prop_FinishEscrow</span></code>, before we worry about unilateral
strategies for individual wallets:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_FinishEscrow
*** Failed! Falsified (after 5 tests and 5 shrinks):
BadPrecondition
  [Do $ Init (Slot {getSlot = 3}) [],
   Do $ Pay (Wallet 3) 2]
  [Action (Refund (Wallet 3))]
  (EscrowModel {_contributions = fromList [(Wallet 3,Value (Map [(,Map [(&quot;&quot;,2000000)])]))],
                _targets = fromList [],
                _refundSlot = Slot {getSlot = 3},
                _phase = Running})
</pre></div>
</div>
</div></blockquote>
<p>In this test we set the deadline to slot 3, make a payment, and then
the finishing strategy attempts to refund the payment… in slot
two. It doesn’t work: the precondition forbids a refund in that
slot. So we have to adapt our finishing strategy, which must simply
wait until the deadline before refunding the contributions.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">finishingStrategy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">DL</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">finishingStrategy</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">contribs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">viewContractState</span><span class="w"> </span><span class="n">contributions</span><span class="w"></span>
<span class="w">    </span><span class="kt">CM</span><span class="o">.</span><span class="n">monitor</span><span class="w"> </span><span class="p">(</span><span class="n">tabulate</span><span class="w"> </span><span class="s">&quot;Refunded wallets&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">show</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">size</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">contribs</span><span class="p">])</span><span class="w"></span>
<span class="w">    </span><span class="n">waitUntilDeadline</span><span class="w">                                                  </span><span class="c1">-- NEW!!!</span><span class="w"></span>
<span class="w">    </span><span class="n">sequence_</span><span class="w"> </span><span class="p">[</span><span class="kt">CM</span><span class="o">.</span><span class="n">action</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Refund</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">testWallets</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="p">`</span><span class="kt">Map</span><span class="o">.</span><span class="n">member</span><span class="p">`</span><span class="w"> </span><span class="n">contribs</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>To wait until the deadline, we use <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:waitUntilDL" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">waitUntilDL</span></code></a>; since this fails
if we try to wait until a slot in the past, then we have to check the
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:currentSlot" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">currentSlot</span></code></a> (maintained by the model) before we decide whether or
not to wait.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">waitUntilDeadline</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">DL</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">waitUntilDeadline</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">deadline</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">viewContractState</span><span class="w"> </span><span class="n">refundSlot</span><span class="w"></span>
<span class="w">    </span><span class="n">slot</span><span class="w">     </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">viewModelState</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">currentSlot</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="w"> </span><span class="p">(</span><span class="n">slot</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">deadline</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">waitUntilDL</span><span class="w"> </span><span class="n">deadline</span><span class="w"></span>
</pre></div>
</div>
<p>With this extended strategy, the property passes:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_FinishEscrow
+++ OK, passed 100 tests.

Actions (3588 in total):
68.87% WaitUntil
20.71% Pay
 4.77% Refund
 3.18% Redeem
 2.48% Init

Refunded wallets (100 in total):
67% 0
13% 2
 7% 1
 6% 3
 6% 4
 1% 5
</pre></div>
</div>
</div></blockquote>
<p>The strategy works, but the statistics we gathered on the number of
wallets to be refunded in each test are a little suspect. <em>In two
thirds of the tests, there were no refunds to be made!</em> This is not
ideal, given that we are testing whether or not our refund strategy
works.</p>
<p>This leads us to wonder: <em>which phase of the test did we reach</em> before
testing our finishing strategy? To find out, we can just add a couple
of lines to the <code class="docutils literal notranslate"><span class="pre">finishingStrategy</span></code> code, to <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:monitor" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">monitor</span></code></a> the phase:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">finishingStrategy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">DL</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">finishingStrategy</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">contribs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">contributions</span><span class="w"></span>
<span class="w">    </span><span class="n">monitor</span><span class="w"> </span><span class="p">(</span><span class="n">tabulate</span><span class="w"> </span><span class="s">&quot;Refunded wallets&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">show</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">size</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">contribs</span><span class="p">])</span><span class="w"></span>
<span class="w">    </span><span class="n">phase</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">phase</span><span class="w">           </span><span class="c1">-- NEW!!!</span><span class="w"></span>
<span class="w">    </span><span class="n">monitor</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">tabulate</span><span class="w"> </span><span class="s">&quot;Phase&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">show</span><span class="w"> </span><span class="n">phase</span><span class="p">]</span><span class="w">    </span><span class="c1">-- NEW!!!</span><span class="w"></span>
<span class="w">    </span><span class="n">waitUntilDeadline</span><span class="w"></span>
<span class="w">    </span><span class="n">sequence_</span><span class="w"> </span><span class="p">[</span><span class="n">action</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Refund</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">testWallets</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="p">`</span><span class="kt">Map</span><span class="o">.</span><span class="n">member</span><span class="p">`</span><span class="w"> </span><span class="n">contribs</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Testing the property again, we see</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Phase (100 in total):
68% Refunding
32% Running
</pre></div>
</div>
</div></blockquote>
<p>So in two thirds of our tests, we had already reached the
<code class="docutils literal notranslate"><span class="pre">Refunding</span></code> phase before the finishing strategy was invoked–which
means, in many cases, that the addition we made to the strategy was
not needed.</p>
<p>While we certainly want to run <em>some</em> tests of the finishing strategy
starting in the <code class="docutils literal notranslate"><span class="pre">Refunding</span></code> phase, two thirds seems far too
many. How can we ensure that more tests invoke the strategy in the
<code class="docutils literal notranslate"><span class="pre">Running</span></code> phase? The simplest way is just to <em>choose longer
deadlines</em>. There is no particular reason why QuickCheck’s default
positive integer distribution should be the right one for
deadlines. The simplest way to increase the values chosen is just to
apply QuickCheck’s <a class="reference external" href="https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck.html#v:scale"><code class="docutils literal notranslate"><span class="pre">scale</span></code></a> combinator to the generator concerned:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">arbitraryAction</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Initial</span><span class="w"></span>
<span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="kt">Init</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Slot</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">getPositive</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="n">arbitrary</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">arbitraryTargets</span><span class="w"></span>
</pre></div>
</div>
<p>Here we scale the positive integer generator by multiplying the
QuickCheck size parameter by ten before generating; the effect is to
increase the range of values by a factor of ten.</p>
<p>Is ten the right number? The only way to tell is to run tests and
measure how often we reach the refunding stage:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck . withMaxSuccess 1000 $ prop_FinishFast
+++ OK, passed 1000 tests.

Phase (1000 in total):
81.5% Running
18.5% Refunding

Refunded wallets (1000 in total):
34.1% 0
18.5% 1
17.3% 2
13.5% 3
11.2% 4
 5.4% 5
</pre></div>
</div>
</div></blockquote>
<p>It seems that we reach the refunding stage in around 20% of tests,
which seems reasonable. Moreover the propertion of cases in which
there are no refunds to be made is now lower–one third instead of two
thirds. So this is a useful improvement.</p>
<p>Finally, we also need to update the unilateral strategy for each
wallet in the same way. Once we have done so, then
<code class="docutils literal notranslate"><span class="pre">prop_NoLockedFunds</span></code> passes again.</p>
</section>
<section id="digression-testing-the-model-alone-for-speed">
<h3>Digression: testing the model alone for speed<a class="headerlink" href="#digression-testing-the-model-alone-for-speed" title="Permalink to this heading"></a></h3>
<p>We ran a thousand tests to measure the proportion that reach the
refunding stage, because one hundred tests is rather few to estimate
this percentage from. In fact even a thousand tests is rather few to
get accurate results; repeating that thousand-test run ten times
yielded a refunding-percentage ranging from 17.4% to 21.6%. Ideally
one might run millions of tests to measure the distribution, so we can tune
the generation more accurately. Yet running a thousand tests is already
quite slow, because of the speed of the emulator.</p>
<p>However, <em>it is not actually necessary to run the tests, to measure
their distribution</em>! The measurements we are making <em>depend only on
the model</em>, and so we can make them much more rapidly by taking the
emulator out of the test. This is simple to do: recall we defined
<code class="docutils literal notranslate"><span class="pre">prop_FinishEscrow</span></code> by</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_FinishEscrow</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Property</span><span class="w"></span>
<span class="nf">prop_FinishEscrow</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">forAllDL</span><span class="w"> </span><span class="n">finishEscrow</span><span class="w"> </span><span class="n">prop_Escrow</span><span class="w"></span>
</pre></div>
</div>
<p>which <em>generates</em> a test case from the dynamic logic test scenario
<code class="docutils literal notranslate"><span class="pre">finishEscrow</span></code>, and then <em>runs</em> it using <code class="docutils literal notranslate"><span class="pre">prop_Escrow</span></code>. All we
have to do to take out the emulator is to replace <code class="docutils literal notranslate"><span class="pre">prop_Escrow</span></code> by
the property that is always <code class="docutils literal notranslate"><span class="pre">True</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_FinishFast</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Property</span><span class="w"></span>
<span class="nf">prop_FinishFast</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forAllDL</span><span class="w"> </span><span class="n">finishEscrow</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
<p>This property generates tests in exactly the same way, and gathers
statistics in the same way (and checks preconditions in the same
way), but does not actually run the test on the emulator. In other
words, it’s an excellent test of the <em>model</em>, and can be used to tune
it (or find bugs in it) without the cost of emulation.</p>
<p>With this version, we can at least run 100,000 tests in a short time,
and obtain much more accurate statistics:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck . withMaxSuccess 100000 $ prop_FinishFast
+++ OK, passed 100000 tests.

Phase (100000 in total):
80.514% Running
19.486% Refunding

Refunded wallets (100000 in total):
34.204% 0
18.387% 1
17.514% 2
14.877% 3
10.016% 4
 5.002% 5
</pre></div>
</div>
</div></blockquote>
<p>The results confirm that the distribution of test cases is reasonably good.</p>
</section>
<section id="id5">
<h3>Exercises<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<p>You will find the code discussed in this section in <code class="docutils literal notranslate"><span class="pre">Spec.Tutorial.Escrow4</span></code>.</p>
<ol class="arabic">
<li><p>Run <code class="docutils literal notranslate"><span class="pre">quickCheck</span> <span class="pre">prop_Escrow</span></code> and observe the distributions
reported. You will see that, even though we have extended the
escrow deadlines, many actions are still rejected by their
preconditions. Adapt the <em>generator</em> for actions, so that it only
generates each action during the correct phase. How does that
affect the proportion of rejected actions?</p></li>
<li><p>The supplied code still has a buggy <code class="docutils literal notranslate"><span class="pre">walletStrategy</span></code>. Verify this
by checking that <code class="docutils literal notranslate"><span class="pre">prop_NoLockedFunds</span></code> fails, and inspect the
counterexample. Correct the <code class="docutils literal notranslate"><span class="pre">walletStrategy</span></code>, and veryify that
<code class="docutils literal notranslate"><span class="pre">prop_NoLockedFunds</span></code> now passes.</p></li>
<li><p>The code also contains a fast version of <code class="docutils literal notranslate"><span class="pre">prop_NoLockedFunds</span></code>
that does not run the emulator. Use <em>this</em> property to test your
model, with and without the fix to the <code class="docutils literal notranslate"><span class="pre">walletStrategy</span></code>. You
should find that the bug is found anyway (it is at the model
level), and that verifying that it has been fixed runs satisfyingly
faster.</p></li>
<li><p>Modify the provided code to <em>remove</em> the scaling we applied to the
deadline generator, and test <code class="docutils literal notranslate"><span class="pre">prop_FinishFast</span></code> repeatedly to
judge the effect on the test case distribution. Reinsert the bug in
<code class="docutils literal notranslate"><span class="pre">walletStrategy</span></code>, and use</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>quickCheck . withMaxSuccess 10000 $ prop_NoLockedFundsFast
</pre></div>
</div>
<p>to find it. Run this repeatedly, and make an estimate of the number
of tests needed to find the bug. Reinsert the scaling, and repeat
your estimate. Hopefully this will help persuade you of the value
of tuning your test case distributions!</p>
</li>
</ol>
</section>
</section>
<section id="measuring-coverage-of-on-chain-code">
<h2>Measuring coverage of on-chain code<a class="headerlink" href="#measuring-coverage-of-on-chain-code" title="Permalink to this heading"></a></h2>
<p>It is always good practice to measure the source-code coverage of
tests. Coverage information provides a sanity check that nothing has
been missed altogether: while covering a line of code is no guarantee
that a bug in that line will be revealed, <em>failing to cover</em> a line of
code <em>does</em> guarantee that any bug there will <em>not</em> be found. For
critical code, it is reasonable to aim for 100% coverage.</p>
<p>Coverage of Haskell code can be measured using the <a class="reference external" href="https://wiki.haskell.org/Haskell_program_coverage">Haskell Program
Coverage</a>
toolkit; we will not discuss this further here. But while this works
well for measuring the coverage of <em>off-chain</em> code, it does not apply
to <em>on-chain</em> code, because this is compiled using the Plutus compiler
and executed on the blockchain, rather than by GHC. If we want to
measure the coverage of <em>on-chain</em> code–which is the most critical
code in a Plutus contract–then we need to use a separate tool. This
is what we cover in this section.</p>
<section id="adding-a-coverage-index">
<h3>Adding a coverage index<a class="headerlink" href="#adding-a-coverage-index" title="Permalink to this heading"></a></h3>
<p>In order to generate a coverage report, the framework needs to know</p>
<ol class="arabic simple">
<li><p>what was covered by tests,</p></li>
<li><p>what should have been covered.</p></li>
</ol>
<p>Indeed, the most important part of a coverage report is often the
parts that were <em>not</em> covered by tests. This latter information–what
should be covered–is represented by a <a class="reference external" href="../../haddock/plutus-tx/html/PlutusTx-Coverage.html#t:CoverageIndex" title="(in plutus-tx v1.0.0.0)"><code class="docutils literal notranslate"><span class="pre">CoverageIndex</span></code></a> that the
Plutus compiler constructs. Since the Plutus compiler is invoked using
Template Haskell in the code of the contract itself, then this is
where we have to save, and export, the coverage index. That is, we
must make additions to the code of a contract in order to enable
coverage measurement.</p>
<p>To do so, we first inspect the code, and find all the
occurrences of <code class="docutils literal notranslate"><span class="pre">PlutusTx.compile</span></code>. In the case of the escrow
contract, they are in the definition of <a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Escrow.html#v:typedValidator" title="(in plutus-use-cases v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">typedValidator</span></code></a>:</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">typedValidator</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">EscrowParams</span><span class="w"> </span><span class="kt">Datum</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Scripts</span><span class="o">.</span><span class="kt">TypedValidator</span><span class="w"> </span><span class="kt">Escrow</span><span class="w"></span>
<span class="nf">typedValidator</span><span class="w"> </span><span class="n">escrow</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="p">(</span><span class="kt">Haskell</span><span class="o">.</span><span class="n">fmap</span><span class="w"> </span><span class="kt">Scripts</span><span class="o">.</span><span class="n">datumHash</span><span class="w"> </span><span class="n">escrow</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">go</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Scripts</span><span class="o">.</span><span class="n">mkTypedValidatorParam</span><span class="w"> </span><span class="o">@</span><span class="kt">Escrow</span><span class="w"></span>
<span class="w">        </span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span><span class="w"> </span><span class="p">[</span><span class="o">||</span><span class="w"> </span><span class="n">validate</span><span class="w"> </span><span class="o">||</span><span class="p">])</span><span class="w"></span>
<span class="w">        </span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span><span class="w"> </span><span class="p">[</span><span class="o">||</span><span class="w"> </span><span class="n">wrap</span><span class="w"> </span><span class="o">||</span><span class="p">])</span><span class="w"></span>
<span class="w">    </span><span class="n">wrap</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Scripts</span><span class="o">.</span><span class="n">mkUntypedValidator</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>The on-chain code consists of <code class="docutils literal notranslate"><span class="pre">validate</span></code> and <code class="docutils literal notranslate"><span class="pre">wrap</span></code>. The latter is
a library function, whose coverage we do not need to measure, so we
just add (and export) a definition of a <a class="reference external" href="../../haddock/plutus-tx/html/PlutusTx-Coverage.html#t:CoverageIndex" title="(in plutus-tx v1.0.0.0)"><code class="docutils literal notranslate"><span class="pre">CoverageIndex</span></code></a> that covers
<code class="docutils literal notranslate"><span class="pre">validate</span></code>:</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">covIdx</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">CoverageIndex</span><span class="w"></span>
<span class="nf">covIdx</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">getCovIdx</span><span class="w"> </span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span><span class="w"> </span><span class="p">[</span><span class="o">||</span><span class="w"> </span><span class="n">validate</span><span class="w"> </span><span class="o">||</span><span class="p">])</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is important that the coverage index is computed in the same module as
the calls to <code class="docutils literal notranslate"><span class="pre">PlutusTx.compile</span></code>, or else the Haskell compiler–and thus by
extension, the Plutus compiler–may produce different code for the coverage
index and for the code under test, resulting in misleading coverage reports.</p>
</div>
<p>It just remains to <em>import</em> the necessary types and functions</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="w"> </span><span class="nn">PlutusTx.Code</span><span class="w"> </span><span class="n">qualified</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="kt">PlutusTx</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">PlutusTx.Coverage</span><span class="w"> </span><span class="n">qualified</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="kt">PlutusTx</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>and to supply GHC options that cause the Plutus compiler to generate
coverage information:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# OPTIONS_GHC -g -fplugin-opt PlutusTx.Plugin:coverage-all #-}</span><span class="w"></span>
</pre></div>
</div>
<p>With these additions, the contract implementation is ready for
coverage measurement.</p>
</section>
<section id="measuring-coverage">
<h3>Measuring coverage<a class="headerlink" href="#measuring-coverage" title="Permalink to this heading"></a></h3>
<p>Once we have created a suitable <a class="reference external" href="../../haddock/plutus-tx/html/PlutusTx-Coverage.html#t:CoverageIndex" title="(in plutus-tx v1.0.0.0)"><code class="docutils literal notranslate"><span class="pre">CoverageIndex</span></code></a>, we must create a
test that uses it. To do so, we need to</p>
<ol class="arabic simple">
<li><p>Run the test using <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:quickCheckWithCoverage" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">quickCheckWithCoverage</span></code></a>, and give it coverage options specifying the coverage index,</p></li>
<li><p>Pass the (modified) coverage options that <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:quickCheckWithCoverage" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">quickCheckWithCoverage</span></code></a> constructs in to <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:propRunActionsWithOptions" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">propRunActionsWithOptions</span></code></a> (instead of <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:propRunActions_" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">propRunActions_</span></code></a>) when we run the action sequence, and</p></li>
<li><p>(Ideally) visualize the resulting <a class="reference external" href="../../haddock/plutus-tx/html/PlutusTx-Coverage.html#t:CoverageReport" title="(in plutus-tx v1.0.0.0)"><code class="docutils literal notranslate"><span class="pre">CoverageReport</span></code></a> as annotated source code.</p></li>
</ol>
<p>Here is the code to do all this (we also need to import <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-Coverage.html" title="(in plutus-contract v1.1.0.0)"><code class="xref hs hs-hsmod docutils literal notranslate"><span class="pre">Plutus.Contract.Test.Coverage</span></code></a>):</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">check_propEscrowWithCoverage</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">check_propEscrowWithCoverage</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">cr</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">quickCheckWithCoverage</span><span class="w"> </span><span class="n">stdArgs</span><span class="w"> </span><span class="p">(</span><span class="n">set</span><span class="w"> </span><span class="n">coverageIndex</span><span class="w"> </span><span class="n">covIdx</span><span class="w"> </span><span class="n">defaultCoverageOptions</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">covopts</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">    </span><span class="n">withMaxSuccess</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">$</span><span class="w"></span>
<span class="w">      </span><span class="kt">CM</span><span class="o">.</span><span class="n">propRunActionsWithOptions</span><span class="w"> </span><span class="o">@</span><span class="kt">EscrowModel</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">defaultCheckOptionsContractModel</span><span class="w"> </span><span class="n">covopts</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="p">(</span><span class="n">pure</span><span class="w"> </span><span class="kt">True</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="n">writeCoverageReport</span><span class="w"> </span><span class="s">&quot;Escrow&quot;</span><span class="w"> </span><span class="n">cr</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>First we call <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:quickCheckWithCoverage" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">quickCheckWithCoverage</span></code></a> with options containing
<code class="docutils literal notranslate"><span class="pre">covIdx</span></code>; it passes modified options to the rest of the property. We
test the property 1000 times, so that we are very likely to cover all
the reachable code in the tests. We cannot just reuse <code class="docutils literal notranslate"><span class="pre">prop_Escrow</span></code>,
because we must pass in the modified coverage options <code class="docutils literal notranslate"><span class="pre">covopts</span></code> when
we run the actions, but otherwise this is just the same as
<code class="docutils literal notranslate"><span class="pre">prop_Escrow</span></code>. The result returned by <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:quickCheckWithCoverage" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">quickCheckWithCoverage</span></code></a> is
a <a class="reference external" href="../../haddock/plutus-tx/html/PlutusTx-Coverage.html#t:CoverageReport" title="(in plutus-tx v1.0.0.0)"><code class="docutils literal notranslate"><span class="pre">CoverageReport</span></code></a>, which is difficult to interpret by itself, so we
bind it to <code class="docutils literal notranslate"><span class="pre">cr</span></code> and then generate an HTML file <code class="docutils literal notranslate"><span class="pre">Escrow.html</span></code> using
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-Coverage.html#v:writeCoverageReport" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">writeCoverageReport</span></code></a>.</p>
<p>Running this does take a little while, because we run a large number of
tests; on the other hand, diagnosing <em>why</em> a part of the code has not
been covered can be very time-consuming, and is wasted effort if the
reason is simply that we were unlucky when we ran the tests. It is
worth waiting a few minutes for more accurate coverage data, before
starting this kind of diagnosis.</p>
<p>Quite a lot of output is generated, including lists of coverage items
that were covered respectively not covered. We shall ignore these for
now; the same information is presented much more readably in the
generated HTML file. But note that we do see statistics on endpoint
invocations:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; check_propEscrowWithCoverage
+++ OK, passed 1000 tests:
63.1% Contract instance for W[4] at endpoint pay-escrow
62.5% Contract instance for W[1] at endpoint pay-escrow
62.5% Contract instance for W[2] at endpoint pay-escrow
61.2% Contract instance for W[3] at endpoint pay-escrow
60.8% Contract instance for W[5] at endpoint pay-escrow
29.1% Contract instance for W[5] at endpoint redeem-escrow
28.2% Contract instance for W[1] at endpoint redeem-escrow
27.4% Contract instance for W[3] at endpoint redeem-escrow
25.8% Contract instance for W[2] at endpoint redeem-escrow
25.6% Contract instance for W[4] at endpoint redeem-escrow
 4.5% Contract instance for W[1] at endpoint refund-escrow
 4.1% Contract instance for W[2] at endpoint refund-escrow
 3.9% Contract instance for W[4] at endpoint refund-escrow
 3.5% Contract instance for W[3] at endpoint refund-escrow
 3.3% Contract instance for W[5] at endpoint refund-escrow

...
</pre></div>
</div>
</div></blockquote>
<p>This table tells us what percentage of test cases made a call to each
endpoint from the given wallet; for example, 63.1% of test cases made
(somewhere) a call to the <code class="docutils literal notranslate"><span class="pre">pay-escrow</span></code> endpoint from wallet 4. As we
can see, the <code class="docutils literal notranslate"><span class="pre">pay-escrow</span></code> endpoint is called in most tests from each
wallet, <code class="docutils literal notranslate"><span class="pre">redeem-escrow</span></code> is a bit rarer, and <code class="docutils literal notranslate"><span class="pre">refund-escrow</span></code> is
used quite rarely. Most serious, of course, would be if one of the
endpoints doesn’t appear in this table at all.</p>
<p>It is possible to supply coverage goals for each wallet/endpoint
combination via an additional coverage option. We don’t consider this
further here, except to note that by default the framework expects
each combination to appear in 20% of tests, and so we get warnings in
this case:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Only 4.5% Contract instance for W[1] at endpoint refund-escrow, but expected 20.0%
Only 4.1% Contract instance for W[2] at endpoint refund-escrow, but expected 20.0%
Only 3.5% Contract instance for W[3] at endpoint refund-escrow, but expected 20.0%
Only 3.9% Contract instance for W[4] at endpoint refund-escrow, but expected 20.0%
Only 3.3% Contract instance for W[5] at endpoint refund-escrow, but expected 20.0%
</pre></div>
</div>
</div></blockquote>
<p>These warnings can be eliminated by specifying more appropriate (lower)
coverage goals for these endpoint calls.</p>
</section>
<section id="interpreting-the-coverage-annotations">
<h3>Interpreting the coverage annotations<a class="headerlink" href="#interpreting-the-coverage-annotations" title="Permalink to this heading"></a></h3>
<p>Running the test above writes annotated source code to
<code class="docutils literal notranslate"><span class="pre">Escrow.html</span></code>. The entire contents of the file are reproduced
<a class="reference internal" href="#coveragereport"><span class="std std-ref">here</span></a>. The report contains all of the
on-chain code provided in the <a class="reference external" href="../../haddock/plutus-tx/html/PlutusTx-Coverage.html#t:CoverageIndex" title="(in plutus-tx v1.0.0.0)"><code class="docutils literal notranslate"><span class="pre">CoverageIndex</span></code></a>, together with a few
lines of code around it for context. Off-chain code appears in grey,
so it can be distinguished. On-chain code on a white background was
covered by tests, and we know no more about it. Code on a red or green
background was also covered, but it is a boolean expression, and only
took one value (red for <code class="docutils literal notranslate"><span class="pre">False</span></code>, green for <code class="docutils literal notranslate"><span class="pre">True</span></code>). Orange code on
a black background is on-chain code that was not covered at all–and
thus may represent a gap in testing.</p>
<p>Looking at the last section of code in the report,</p>
<blockquote>
<div><pre>
   365    <span style=background-color:lightgray;color:gray >covIdx :: CoverageIndex</span>
   366    <span style=background-color:lightgray;color:gray >covIdx = getCovIdx $$(</span><span style=background-color:black;color:orangered >PlutusTx.compile [|| val
</pre></div></blockquote>
<p>we see that it is the construction of the coverage index, and
parts of this code are labelled on-chain and uncovered. We can ignore
this, it’s simply an artefact of the way the code labelling is done.</p>
<p>More interesting is the second section of the report:</p>
<blockquote>
<div><pre>
   201    <span style=background-color:lightgray;color:gray >{-# INLINABLE validate #-}</span>
   202    <span style=background-color:lightgray;color:gray >validate :: EscrowParams DatumHash -&gt; PaymentPubKeyHash -&gt; Action -&gt; ScriptContext -&gt; Bool</span>
   203    <span style=background-color:white;color:black >validate EscrowParams{escrowDeadline, escrowTargets} contributor action ScriptContext{scriptContextTxInfo} =</span><span style=background-color:lightgray;color:gray ></span>
   204    <span style=background-color:white;color:black >    case action of</span><span style=background-color:lightgray;color:gray ></span>
   205    <span style=background-color:white;color:black >        Redeem -&gt;</span><span style=background-color:lightgray;color:gray ></span>
   206    <span style=background-color:white;color:black >            traceIfFalse </span><span style=background-color:black;color:orangered >&quot;escrowDeadline-after&quot; </span><span style=background-color:white;color:black >(escrowDeadline `after` txInfoValidRange scriptContextTxInfo)</span><span style=background-color:lightgray;color:gray ></span>
   207    <span style=background-color:white;color:black >            &amp;&amp; </span><span style=background-color:lightgreen;color:black >traceIfFalse </span><span style=background-color:black;color:orangered >&quot;meetsTarget&quot; </span><span style=background-color:lightgreen;color:black >(all (meetsTarget scriptContextTxInfo) escrowTargets)</span><span style=background-color:white;color:black ></span><span style=background-color:lightgray;color:gray ></span>
   208    <span style=background-color:white;color:black >        Refund -&gt;</span><span style=background-color:lightgray;color:gray ></span>
   209    <span style=background-color:white;color:black >            </span><span style=background-color:lightgreen;color:black >traceIfFalse </span><span style=background-color:black;color:orangered >&quot;escrowDeadline-before&quot; </span><span style=background-color:lightgreen;color:black >((escrowDeadline - 1) `before` txInfoValidRange scriptContextTxInfo)</span><span style=background-color:lightgray;color:gray ></span>
   210    <span style=background-color:lightgreen;color:black >            &amp;&amp; </span><span style=background-color:lightgreen;color:black >traceIfFalse </span><span style=background-color:black;color:orangered >&quot;txSignedBy&quot; </span><span style=background-color:lightgreen;color:black >(scriptContextTxInfo `txSignedBy` unPaymentPubKeyHash contributor)</span><span style=background-color:lightgray;color:gray ></span>
   211    <span style=background-color:lightgray;color:gray ></span>
</pre></div></blockquote>
<p>This is the main validator, and while some of its code is coloured
white, much of it is coloured green. This means the checks in this
function always returned <code class="docutils literal notranslate"><span class="pre">True</span></code> in our tests; we have not tested the
cases in which they return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>This does indicate a weakness in our testing: since these checks
always passed in our tests, then those tests would <em>also</em> have passed
if the checks were removed completely (replaced by <code class="docutils literal notranslate"><span class="pre">True</span></code>)–but the
contract would have been quite wrong. We will return to this point
later, when we discuss <em>negative testing</em>. For now, though, we just
note that <em>if the checks had returned</em> <code class="docutils literal notranslate"><span class="pre">False</span></code>, <em>then the
transaction would have failed</em>–and the off-chain code is, of course,
designed not to submit failing transactions. So, in a sense, we should
expect this code to be coloured green–at least, when we test through
well-designed off-chain endpoints, as we have been doing.</p>
<p>This code fragment also contains some entirely uncovered code–the
strings passed to <a class="reference external" href="../../haddock/plutus-tx/html/PlutusTx-Trace.html#v:traceIfFalse" title="(in plutus-tx v1.0.0.0)"><code class="docutils literal notranslate"><span class="pre">traceIfFalse</span></code></a> to be used as error messages if a
check fails. Since correct off-chain code never submits failing
transactions, then these error messages are never used–and hence the
code is labelled as ‘uncovered’. Again, this is not really a problem.</p>
<p>The most interesting part of the report is the first section:</p>
<blockquote>
<div><pre>
   190    <span style=background-color:lightgray;color:gray >meetsTarget :: TxInfo -&gt; EscrowTarget DatumHash -&gt; Bool</span>
   191    <span style=background-color:white;color:black >meetsTarget ptx = \case</span><span style=background-color:lightgray;color:gray ></span>
   192    <span style=background-color:white;color:black >    PaymentPubKeyTarget pkh vl -&gt;</span><span style=background-color:lightgray;color:gray ></span>
   193    <span style=background-color:white;color:black >        </span><span style=background-color:lightgreen;color:black >valuePaidTo ptx (unPaymentPubKeyHash pkh) `geq` vl</span><span style=background-color:white;color:black ></span><span style=background-color:lightgray;color:gray ></span>
   194    <span style=background-color:white;color:black >    ScriptTarget validatorHash dataValue vl -&gt;</span><span style=background-color:lightgray;color:gray ></span>
   195    <span style=background-color:white;color:black >        </span><span style=background-color:black;color:orangered >case scriptOutputsAt </span><span style=background-color:black;color:orangered >validatorHash </span><span style=background-color:black;color:orangered >ptx </span><span style=background-color:black;color:orangered >of</span><span style=background-color:lightgray;color:gray ></span>
   196    <span style=background-color:black;color:orangered >            [(dataValue&#39;, vl&#39;)] -&gt;</span><span style=background-color:lightgray;color:gray ></span>
   197    <span style=background-color:black;color:orangered >                </span><span style=background-color:black;color:orangered >traceIfFalse </span><span style=background-color:black;color:orangered >&quot;dataValue&quot; </span><span style=background-color:black;color:orangered >(</span><span style=background-color:black;color:orangered >dataValue&#39; </span><span style=background-color:black;color:orangered >== </span><span style=background-color:black;color:orangered >dataValue)</span><span style=background-color:black;color:orangered ></span><span style=background-color:lightgray;color:gray ></span>
   198    <span style=background-color:black;color:orangered >                &amp;&amp; </span><span style=background-color:black;color:orangered >traceIfFalse </span><span style=background-color:black;color:orangered >&quot;value&quot; </span><span style=background-color:black;color:orangered >(</span><span style=background-color:black;color:orangered >vl&#39; </span><span style=background-color:black;color:orangered >`geq` </span><span style=background-color:black;color:orangered >vl)</span><span style=background-color:black;color:orangered ></span><span style=background-color:black;color:orangered ></span><span style=background-color:lightgray;color:gray ></span>
   199    <span style=background-color:black;color:orangered >            _ -&gt; </span><span style=background-color:black;color:orangered >False</span><span style=background-color:lightgray;color:gray ></span>
</pre></div></blockquote>
<p>This is the function that is used to check that each target payment is
made when the escrow is redeemed, and as we see from the coverage
report, there are two cases, of which only one has been tested. In
fact the two cases handle payments to a wallet, and payments to a
script, and the second kind of payment is <em>not tested at all</em> by our
tests–yet it is handled by entirely different code in the on-chain
function.</p>
<p><strong>This exposes a serious deficiency in the tests developed so far</strong>:
they give us no evidence at all that target payments to a script work
as intended. To test this code as well, we would need to add ‘proxy’
contracts to the tests, to act as recipients for such payments. We
leave making this extension as an exercise for the reader.</p>
</section>
<section id="the-generated-coverage-report">
<span id="coveragereport"></span><h3>The generated coverage report<a class="headerlink" href="#the-generated-coverage-report" title="Permalink to this heading"></a></h3>
<p>This is the generated coverage report in its entirety:</p>
<blockquote>
<div><body ><h1 >Files</h1><ul ><li ><a href="#src/Plutus/Contracts/Escrow.hs" >src/Plutus/Contracts/Escrow.hs</a></li></ul><hr><h2 id="src/Plutus/Contracts/Escrow.hs" >src/Plutus/Contracts/Escrow.hs</h2><pre >.
.
.
   186    <span style=background-color:lightgray;color:gray >--   spending transaction to be paid to target addresses. This may happen if</span>
   187    <span style=background-color:lightgray;color:gray >--   the target address is also used as a change address for the spending</span>
   188    <span style=background-color:lightgray;color:gray >--   transaction, and allowing the target to be exceed prevents outsiders from</span>
   189    <span style=background-color:lightgray;color:gray >--   poisoning the contract by adding arbitrary outputs to the script address.</span>
   190    <span style=background-color:lightgray;color:gray >meetsTarget :: TxInfo -&gt; EscrowTarget DatumHash -&gt; Bool</span>
   191    <span style=background-color:white;color:black >meetsTarget ptx = \case</span><span style=background-color:lightgray;color:gray ></span>
   192    <span style=background-color:white;color:black >    PaymentPubKeyTarget pkh vl -&gt;</span><span style=background-color:lightgray;color:gray ></span>
   193    <span style=background-color:white;color:black >        </span><span style=background-color:lightgreen;color:black >valuePaidTo ptx (unPaymentPubKeyHash pkh) `geq` vl</span><span style=background-color:white;color:black ></span><span style=background-color:lightgray;color:gray ></span>
   194    <span style=background-color:white;color:black >    ScriptTarget validatorHash dataValue vl -&gt;</span><span style=background-color:lightgray;color:gray ></span>
   195    <span style=background-color:white;color:black >        </span><span style=background-color:black;color:orangered >case scriptOutputsAt </span><span style=background-color:black;color:orangered >validatorHash </span><span style=background-color:black;color:orangered >ptx </span><span style=background-color:black;color:orangered >of</span><span style=background-color:lightgray;color:gray ></span>
   196    <span style=background-color:black;color:orangered >            [(dataValue&#39;, vl&#39;)] -&gt;</span><span style=background-color:lightgray;color:gray ></span>
   197    <span style=background-color:black;color:orangered >                </span><span style=background-color:black;color:orangered >traceIfFalse </span><span style=background-color:black;color:orangered >&quot;dataValue&quot; </span><span style=background-color:black;color:orangered >(</span><span style=background-color:black;color:orangered >dataValue&#39; </span><span style=background-color:black;color:orangered >== </span><span style=background-color:black;color:orangered >dataValue)</span><span style=background-color:black;color:orangered ></span><span style=background-color:lightgray;color:gray ></span>
   198    <span style=background-color:black;color:orangered >                &amp;&amp; </span><span style=background-color:black;color:orangered >traceIfFalse </span><span style=background-color:black;color:orangered >&quot;value&quot; </span><span style=background-color:black;color:orangered >(</span><span style=background-color:black;color:orangered >vl&#39; </span><span style=background-color:black;color:orangered >`geq` </span><span style=background-color:black;color:orangered >vl)</span><span style=background-color:black;color:orangered ></span><span style=background-color:black;color:orangered ></span><span style=background-color:lightgray;color:gray ></span>
   199    <span style=background-color:black;color:orangered >            _ -&gt; </span><span style=background-color:black;color:orangered >False</span><span style=background-color:lightgray;color:gray ></span>
   200    <span style=background-color:lightgray;color:gray ></span>
   201    <span style=background-color:lightgray;color:gray >{-# INLINABLE validate #-}</span>
   202    <span style=background-color:lightgray;color:gray >validate :: EscrowParams DatumHash -&gt; PaymentPubKeyHash -&gt; Action -&gt; ScriptContext -&gt; Bool</span>
   203    <span style=background-color:white;color:black >validate EscrowParams{escrowDeadline, escrowTargets} contributor action ScriptContext{scriptContextTxInfo} =</span><span style=background-color:lightgray;color:gray ></span>
   204    <span style=background-color:white;color:black >    case action of</span><span style=background-color:lightgray;color:gray ></span>
   205    <span style=background-color:white;color:black >        Redeem -&gt;</span><span style=background-color:lightgray;color:gray ></span>
   206    <span style=background-color:white;color:black >            traceIfFalse </span><span style=background-color:black;color:orangered >&quot;escrowDeadline-after&quot; </span><span style=background-color:white;color:black >(escrowDeadline `after` txInfoValidRange scriptContextTxInfo)</span><span style=background-color:lightgray;color:gray ></span>
   207    <span style=background-color:white;color:black >            &amp;&amp; </span><span style=background-color:lightgreen;color:black >traceIfFalse </span><span style=background-color:black;color:orangered >&quot;meetsTarget&quot; </span><span style=background-color:lightgreen;color:black >(all (meetsTarget scriptContextTxInfo) escrowTargets)</span><span style=background-color:white;color:black ></span><span style=background-color:lightgray;color:gray ></span>
   208    <span style=background-color:white;color:black >        Refund -&gt;</span><span style=background-color:lightgray;color:gray ></span>
   209    <span style=background-color:white;color:black >            </span><span style=background-color:lightgreen;color:black >traceIfFalse </span><span style=background-color:black;color:orangered >&quot;escrowDeadline-before&quot; </span><span style=background-color:lightgreen;color:black >((escrowDeadline - 1) `before` txInfoValidRange scriptContextTxInfo)</span><span style=background-color:lightgray;color:gray ></span>
   210    <span style=background-color:lightgreen;color:black >            &amp;&amp; </span><span style=background-color:lightgreen;color:black >traceIfFalse </span><span style=background-color:black;color:orangered >&quot;txSignedBy&quot; </span><span style=background-color:lightgreen;color:black >(scriptContextTxInfo `txSignedBy` unPaymentPubKeyHash contributor)</span><span style=background-color:lightgray;color:gray ></span>
   211    <span style=background-color:lightgray;color:gray ></span>
   212    <span style=background-color:lightgray;color:gray >typedValidator :: EscrowParams Datum -&gt; Scripts.TypedValidator Escrow</span>
   213    <span style=background-color:lightgray;color:gray >typedValidator escrow = go (Haskell.fmap Ledger.datumHash escrow) where</span>
   214    <span style=background-color:lightgray;color:gray >    go = Scripts.mkTypedValidatorParam @Escrow</span>
   215    <span style=background-color:lightgray;color:gray >        $$(PlutusTx.compile [|| validate ||])</span>
.
.
.
   361    <span style=background-color:lightgray;color:gray >    -- Pay the value &#39;vl&#39; into the contract</span>
   362    <span style=background-color:lightgray;color:gray >    _ &lt;- pay inst params vl</span>
   363    <span style=background-color:lightgray;color:gray >    go</span>
   364    <span style=background-color:lightgray;color:gray ></span>
   365    <span style=background-color:lightgray;color:gray >covIdx :: CoverageIndex</span>
   366    <span style=background-color:lightgray;color:gray >covIdx = getCovIdx $$(</span><span style=background-color:black;color:orangered >PlutusTx.compile [|| validate ||])</span><span style=background-color:lightgray;color:gray ></span>
</pre></body>
</div></blockquote>
</section>
</section>
<section id="crashes-and-how-to-tolerate-them">
<h2>Crashes, and how to tolerate them<a class="headerlink" href="#crashes-and-how-to-tolerate-them" title="Permalink to this heading"></a></h2>
<p>One awkward possibility, that we cannot avoid, is that a contract
instance might crash during execution–for example, because of a power
failure to the machine it is running on. We don’t want anything to be
lost permanently as a result–it should be possible to recover by
restarting the contract instance, perhaps in a different state, and
continue. Yet how should we test this? We need to deliberately crash
and restart contracts in tests, and check that they still behave as
the model says they should.</p>
<p>The <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a> framework provides a simple way to <em>extend</em> a
contract model, so that it can test crash-tolerance too. If <code class="docutils literal notranslate"><span class="pre">m</span></code> is a
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a> instance, then so is <code class="docutils literal notranslate"><span class="pre">WithCrashTolerance</span> <span class="pre">m</span></code>–and
testing the latter model will insert actions to crash and restart
contract instances at random. To define a property that runs these
tests, all we have to do is import <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-CrashTolerance.html" title="(in plutus-contract v1.1.0.0)"><code class="xref hs hs-hsmod docutils literal notranslate"><span class="pre">Plutus.Contract.Test.ContractModel.CrashTolerance</span></code></a> and include
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-CrashTolerance.html#t:WithCrashTolerance" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">WithCrashTolerance</span></code></a> in the type
signature:</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_CrashTolerance</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="kt">Actions</span><span class="w"> </span><span class="p">(</span><span class="kt">WithCrashTolerance</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Property</span><span class="w"></span>
<span class="nf">prop_CrashTolerance</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">propRunActions_</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>(The actual code here is the same as <code class="docutils literal notranslate"><span class="pre">prop_Escrow</span></code>, only the type is different).</p>
<p>We do have to provide a little more information before we can run
tests, though.</p>
<ol class="arabic simple">
<li><p>Firstly, we cannot expect to include an action in a
test, when the contract(s) that should perform the action are not
running. We thus need to tell the framework whether or not an action
is <em>available</em>, given the contracts currently running.</p></li>
<li><p>Secondly, when we restart a contract it may need to take some
recovery action, and so we must be able to give it the necessary
information to recover. We achieve this by specifying
possibly-different contract parameters to use, when a contract is
restarted. These parameters may depend on the model state.</p></li>
</ol>
<p>We provide this information by defining an instance of the
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-CrashTolerance.html#t:CrashTolerance" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">CrashTolerance</span></code></a> class:</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">CrashTolerance</span><span class="w"> </span><span class="kt">EscrowModel</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">available</span><span class="w"> </span><span class="p">(</span><span class="kt">Init</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="kr">_</span><span class="w">     </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="w">  </span><span class="n">available</span><span class="w"> </span><span class="n">a</span><span class="w">          </span><span class="n">alive</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Key</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">WalletKey</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="n">elem</span><span class="p">`</span><span class="w"> </span><span class="n">alive</span><span class="w"></span>
<span class="w">    </span><span class="kr">where</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">                </span><span class="kt">Pay</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="kr">_</span><span class="w">  </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">w</span><span class="w"></span>
<span class="w">                </span><span class="kt">Redeem</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">w</span><span class="w"></span>
<span class="w">                </span><span class="kt">Refund</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">w</span><span class="w"></span>
<span class="w">                </span><span class="kt">Init</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">undefined</span><span class="w"></span>

<span class="w">  </span><span class="n">restartArguments</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="kt">WalletKey</span><span class="p">{}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">escrowParams&#39;</span><span class="w"> </span><span class="n">slot</span><span class="w"> </span><span class="n">tgts</span><span class="w"></span>
<span class="w">    </span><span class="kr">where</span><span class="w"> </span><span class="n">slot</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">refundSlot</span><span class="w"></span>
<span class="w">          </span><span class="n">tgts</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">toList</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="kt">CM</span><span class="o">.</span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">targets</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>The <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-CrashTolerance.html#t:CrashTolerance" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">available</span></code></a> method returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if an action is available,
given a list of active contract keys <code class="docutils literal notranslate"><span class="pre">alive</span></code>; since contract
instance keys have varying types, then the list actually contains keys
wrapped in an existential type, which is why the <code class="docutils literal notranslate"><span class="pre">Key</span></code> constructor
appears there.</p>
<p>The <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-CrashTolerance.html#t:CrashTolerance" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">restartArguments</span></code></a> method provides the parameter for restarting
an escrow contract, which in this case can be just the same as when
the contract was first started. We need to recover the targets from
the model state, in which they are represented as a <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">Wallet</span>
<span class="pre">Value</span></code>, so we convert them back to a list and refactor the
<code class="docutils literal notranslate"><span class="pre">escrowParams</span></code> function so we can give <code class="docutils literal notranslate"><span class="pre">escrowParams'</span></code> a list of
<code class="docutils literal notranslate"><span class="pre">(Wallet,</span> <span class="pre">Value)</span></code> pairs, rather than a list of <code class="docutils literal notranslate"><span class="pre">(Wallet,</span> <span class="pre">Int)</span></code>:</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">escrowParams</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Slot</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[(</span><span class="kt">Wallet</span><span class="p">,</span><span class="w"> </span><span class="kt">Integer</span><span class="p">)]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">EscrowParams</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
<span class="nf">escrowParams</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">tgts</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">escrowParams&#39;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">[(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">adaValueOf</span><span class="w"> </span><span class="p">(</span><span class="n">fromInteger</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">tgts</span><span class="p">]</span><span class="w"></span>

<span class="nf">escrowParams&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Slot</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[(</span><span class="kt">Wallet</span><span class="p">,</span><span class="w"> </span><span class="kt">Value</span><span class="o">.</span><span class="kt">Value</span><span class="p">)]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">EscrowParams</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
<span class="nf">escrowParams&#39;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">tgts&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kt">EscrowParams</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">escrowTargets</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">payToPaymentPubKeyTarget</span><span class="w"> </span><span class="p">(</span><span class="n">mockWalletPaymentPubKeyHash</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">tgts&#39;</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">escrowDeadline</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">scSlotZeroTime</span><span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">POSIXTime</span><span class="w"> </span><span class="p">(</span><span class="n">getSlot</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scSlotLength</span><span class="w"> </span><span class="n">def</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>It is possible to define the effect of crashing or restarting a
contract instance on the <em>model</em> too, if need be, by defining
additional methods in this class. In this case, though, crashing and
restarting ought to be entirely transparent, so we can omit them.</p>
<p>Surprisingly, the tests do not pass!</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_CrashTolerance
*** Failed! Assertion failed (after 24 tests and 26 shrinks):
Actions
 [Init (Slot {getSlot = 6}) [(Wallet 1,2),(Wallet 4,2)],
  Crash (WalletKey (Wallet 4)),
  Restart (WalletKey (Wallet 4)),
  Pay (Wallet 4) 4,
  Redeem (Wallet 1)]
Expected funds of W[4] to change by
  Value (Map [(,Map [(&quot;&quot;,-2000000)])])
but they changed by
  Value (Map [(,Map [(&quot;&quot;,-4000000)])])
a discrepancy of
  Value (Map [(,Map [(&quot;&quot;,-2000000)])])
Expected funds of W[1] to change by
  Value (Map [(,Map [(&quot;&quot;,2000000)])])
but they did not change
Contract instance log failed to validate:
...
Slot 5: 00000000-0000-4000-8000-000000000000 {Wallet W[1]}:
          Contract instance stopped with error: RedeemFailed NotEnoughFundsAtAddress
...
</pre></div>
</div>
</div></blockquote>
<p>Here we simply set up targets with two beneficiaries, crash and
restart wallet 4, pay sufficient contributions to cover the targets,
and then try to redeem the escrow, which seems straightforward enough,
and yet the redemption thinks there are not enough funds in the
escrow, <em>even though we just paid them in</em>!</p>
<p>This failure is a little tricky to debug. A clue is that the <em>payment</em>
was made by a contract instance that has been restarted, while the
<em>redemption</em> was made by a contract that has not. Do the payment and
redemption actually refer to the same escrow? In fact the targets
supplied to the contract instance are not necessarily exactly the
same: the contract receives a <em>list</em> of targets, but in the model we
represented them as a <em>map</em>–and converted the list of targets to a
map, and back again, when we restarted the contract. That means the
<em>order</em> of the targets might be different.</p>
<p>Could that make a difference? To find out, we can just <em>sort</em> the
targets before passing them to the contract instance, thus
guaranteeing the same order every time:</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">escrowParams&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Slot</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[(</span><span class="kt">Wallet</span><span class="p">,</span><span class="kt">Value</span><span class="p">)]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">EscrowParams</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
<span class="nf">escrowParams&#39;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">tgts&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kt">EscrowParams</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">escrowTargets</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">payToPaymentPubKeyTarget</span><span class="w"> </span><span class="p">(</span><span class="n">mockWalletPaymentPubKeyHash</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="w">                       </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">sortBy</span><span class="w"> </span><span class="p">(</span><span class="n">compare</span><span class="w"> </span><span class="p">`</span><span class="n">on</span><span class="p">`</span><span class="w"> </span><span class="n">fst</span><span class="p">)</span><span class="w"> </span><span class="n">tgts&#39;</span><span class="w"> </span><span class="p">]</span><span class="w">                  </span><span class="c1">-- NEW!!</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">escrowDeadline</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">scSlotZeroTime</span><span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">POSIXTime</span><span class="w"> </span><span class="p">(</span><span class="n">getSlot</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scSlotLength</span><span class="w"> </span><span class="n">def</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>Once we do this, the tests pass. We can also see from the resulting
statistics that quite a lot of crashing and restarting is going on:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_CrashTolerance
+++ OK, passed 100 tests.

Actions (2721 in total):
42.48% Pay
24.99% WaitUntil
13.08% Crash
 9.52% Restart
 6.06% Redeem
 3.01% Init
 0.85% Refund
</pre></div>
</div>
</div></blockquote>
<p>Perhaps it’s debatable whether or not the behaviour we uncovered here
is a <em>bug</em>, but it is certainly a feature–it was not obvious in
advance that specifying the same targets in a different order would
create an independent escrow, but that is what happens. So for
example, if a buyer and seller using an escrow contract to exchange an
NFT for Ada specify the two targets in different orders, then they
would place their assets in independent escrow that cannot be redeemed
until the refund deadline passes. Arguably a better designed contract
would sort the targets by wallet, as we have done here, before
creating any UTXOs, so that the problem cannot arise.</p>
<section id="id6">
<h3>Exercises<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h3>
<p>You will find the code discussed here in <code class="docutils literal notranslate"><span class="pre">Spec.Tutorial.Escrow6</span></code>, <em>without</em> the addition of <code class="docutils literal notranslate"><span class="pre">sortBy</span></code> to <code class="docutils literal notranslate"><span class="pre">escrowParams</span></code>.</p>
<ol class="arabic">
<li><p>Run <code class="docutils literal notranslate"><span class="pre">quickCheck</span> <span class="pre">prop_CrashTolerance</span></code> to provoke a test
failure. Examine the counterexample and the test output, and make
sure you understand how the test fails. Run this test several
times: you will see the failure in several different forms, with
the same underlying cause. Make sure you understand how each
failure arises.</p>
<p>Why does <a class="reference external" href="https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck.html#v:quickCheck"><code class="docutils literal notranslate"><span class="pre">quickCheck</span></code></a> always report a test case with <em>two</em> target
payments–why isn’t one target enough to reveal the problem?</p>
</li>
<li><p>Add sorting to the model, and verify that the tests now pass.</p></li>
<li><p>An alternative way to fix the model is <em>not</em> to convert the targets
to a <code class="docutils literal notranslate"><span class="pre">Map</span></code> in the model state, but just keep them as a list of
pairs, so that exactly the same list can be supplied to the
contract instances when they are restarted. Implement this change,
and verify that the tests still pass.</p>
<p>Which solution do you prefer? Arguably this one reflects the
<em>actual</em> design of the contract more closely, since the model makes
explicit that the order of the targets matters.</p>
</li>
</ol>
</section>
</section>
<section id="debugging-the-auction-contract-with-model-assertions">
<h2>Debugging the Auction contract with model assertions<a class="headerlink" href="#debugging-the-auction-contract-with-model-assertions" title="Permalink to this heading"></a></h2>
<p>In this section, we’ll apply the techniques we have seen so far to
test another contract, and we’ll see how they reveal some surprising
behaviour.  The contract we take this time is the auction contract in
<a class="reference external" href="../../haddock/plutus-use-cases/html/Plutus-Contracts-Auction.html" title="(in plutus-use-cases v1.1.0.0)"><code class="xref hs hs-hsmod docutils literal notranslate"><span class="pre">Plutus.Contracts.Auction</span></code></a>. This module actually defines <em>two</em>
contracts, a seller contract and a buyer contract. The seller puts up
a <a class="reference external" href="../../haddock/plutus-ledger/html/Ledger.html#t:Value" title="(in plutus-ledger v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Value</span></code></a> for sale, creating an auction UTXO containing the value,
and buyers can then bid Ada for it. When the auction deadline is
reached, the highest bidder receives the auctioned value, and the
seller receives the bid.</p>
<section id="modelling-the-auction-contract">
<h3>Modelling the Auction contract<a class="headerlink" href="#modelling-the-auction-contract" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Spec.Auction</span></code> contains a contract model for testing this
contract. The value for sale is a custom token, wallet 1 is the
seller, and the deadline used for testing is fixed at slot 101; the
generated tests just consist of an <code class="docutils literal notranslate"><span class="pre">Init</span></code> action to start the
auction, and a series of <code class="docutils literal notranslate"><span class="pre">Bid</span></code> actions by the other wallets.</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="kr">data</span><span class="w"> </span><span class="kt">Action</span><span class="w"> </span><span class="kt">AuctionModel</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Init</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Bid</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="w">        </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Data</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>The model keeps track of the highest bid and bidder, and the current
phase the auction is in:</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">AuctionModel</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">AuctionModel</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">_currentBid</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">_winner</span><span class="w">     </span><span class="ow">::</span><span class="w"> </span><span class="kt">Wallet</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">_endSlot</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="kt">Slot</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">_phase</span><span class="w">      </span><span class="ow">::</span><span class="w"> </span><span class="kt">Phase</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Data</span><span class="p">)</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">NotStarted</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Bidding</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">AuctionOver</span><span class="w"></span>
<span class="w">    </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Data</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>It is updated by the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextState</span></code></a> method on each bid:</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">nextState</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">        </span><span class="kr">case</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">            </span><span class="kt">Init</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">                </span><span class="n">phase</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="kt">Bidding</span><span class="w"></span>
<span class="w">                </span><span class="n">withdraw</span><span class="w"> </span><span class="n">w1</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">toValue</span><span class="w"> </span><span class="kt">Ledger</span><span class="o">.</span><span class="n">minAdaTxOutEstimated</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">theToken</span><span class="w"></span>
<span class="w">                </span><span class="n">wait</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="w">            </span><span class="kt">Bid</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">                </span><span class="n">currentPhase</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">phase</span><span class="w"></span>
<span class="w">                </span><span class="n">when</span><span class="w"> </span><span class="p">(</span><span class="n">currentPhase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Bidding</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">                    </span><span class="n">current</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">currentBid</span><span class="w"></span>
<span class="w">                    </span><span class="n">leader</span><span class="w">  </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">winner</span><span class="w"></span>
<span class="w">                    </span><span class="n">withdraw</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span><span class="w"> </span><span class="n">bid</span><span class="w"></span>
<span class="w">                    </span><span class="n">deposit</span><span class="w"> </span><span class="n">leader</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span><span class="w"> </span><span class="n">current</span><span class="w"></span>
<span class="w">                    </span><span class="n">currentBid</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">bid</span><span class="w"></span>
<span class="w">                    </span><span class="n">winner</span><span class="w">     </span><span class="o">.=</span><span class="w"> </span><span class="n">w</span><span class="w"></span>
<span class="w">                </span><span class="n">wait</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>Note that when a higher bid is received, the previous bid is returned
to the bidder.</p>
<p>We only allow bids that are larger than the previous one (which is why
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextState</span></code></a> doesn’t need to check this):</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">precondition</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="kt">Init</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">NotStarted</span><span class="w"></span>
<span class="w">    </span><span class="n">precondition</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="kt">Bid</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">bid</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">      </span><span class="c1">-- In order to place a bid, we need to satisfy the constraint where</span><span class="w"></span>
<span class="w">      </span><span class="c1">-- each tx output must have at least N Ada.</span><span class="w"></span>
<span class="w">      </span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="kt">NotStarted</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">      </span><span class="n">bid</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">getLovelace</span><span class="w"> </span><span class="p">(</span><span class="kt">Ledger</span><span class="o">.</span><span class="n">minAdaTxOutEstimated</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">      </span><span class="n">bid</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">^.</span><span class="w"> </span><span class="n">contractState</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">currentBid</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>The most interesting part of the model covers what happens when the
auction deadline is reached: in contrast to the <code class="docutils literal notranslate"><span class="pre">Escrow</span></code> contract,
the highest bid is paid to the seller automatically, and the buyer
receives the token. We model this using the <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextReactiveState</span></code></a>
method introduced in section <a class="reference internal" href="#timing"><span class="std std-ref">Modelling the passage of time</span></a></p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">nextReactiveState</span><span class="w"> </span><span class="n">slot&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w">  </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">endSlot</span><span class="w"></span>
<span class="w">      </span><span class="n">p</span><span class="w">    </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">phase</span><span class="w"></span>
<span class="w">      </span><span class="n">when</span><span class="w"> </span><span class="p">(</span><span class="n">slot&#39;</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Bidding</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">        </span><span class="n">w</span><span class="w">   </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">winner</span><span class="w"></span>
<span class="w">        </span><span class="n">bid</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">currentBid</span><span class="w"></span>
<span class="w">        </span><span class="n">phase</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="kt">AuctionOver</span><span class="w"></span>
<span class="w">        </span><span class="n">deposit</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">toValue</span><span class="w"> </span><span class="kt">Ledger</span><span class="o">.</span><span class="n">minAdaTxOutEstimated</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">theToken</span><span class="w"></span>
<span class="w">        </span><span class="n">deposit</span><span class="w"> </span><span class="n">w1</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span><span class="w"> </span><span class="n">bid</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>Finally we can define the property to test; in this case we have to
supply some options to initialize wallet 1 with the token to be
auctioned:</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_Auction</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Actions</span><span class="w"> </span><span class="kt">AuctionModel</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Property</span><span class="w"></span>
<span class="nf">prop_Auction</span><span class="w"> </span><span class="n">script</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="n">propRunActionsWithOptions</span><span class="w"> </span><span class="p">(</span><span class="n">set</span><span class="w"> </span><span class="n">minLogLevel</span><span class="w"> </span><span class="kt">Info</span><span class="w"> </span><span class="n">options</span><span class="p">)</span><span class="w"> </span><span class="n">defaultCoverageOptions</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">pure</span><span class="w"> </span><span class="kt">True</span><span class="p">)</span><span class="w">  </span><span class="c1">-- TODO: check termination</span><span class="w"></span>
<span class="w">        </span><span class="n">script</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>The only important part here is <code class="docutils literal notranslate"><span class="pre">options</span></code>, which is defined as follows:</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | The token that we are auctioning off.</span><span class="w"></span>
<span class="nf">theToken</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Value</span><span class="w"></span>
<span class="nf">theToken</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="c1">-- This currency is created by the initial transaction.</span><span class="w"></span>
<span class="w">    </span><span class="n">someTokenValue</span><span class="w"> </span><span class="s">&quot;token&quot;</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="c1">-- | &#39;CheckOptions&#39; that includes &#39;theToken&#39; in the initial distribution of Wallet 1.</span><span class="w"></span>
<span class="nf">options</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CheckOptions</span><span class="w"></span>
<span class="nf">options</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">defaultCheckOptionsContractModel</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="w"> </span><span class="n">changeInitialWalletValue</span><span class="w"> </span><span class="n">w1</span><span class="w"> </span><span class="p">((</span><span class="o">&lt;&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">theToken</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>Unsurprisingly, the tests pass.</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_Auction
+++ OK, passed 100 tests.

Actions (2348 in total):
85.82% Bid
10.35% WaitUntil
 3.83% Init
</pre></div>
</div>
</div></blockquote>
</section>
<section id="id7">
<h3>No locked funds?<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<p>Now we have a basic working model of the auction contract, we can
begin to test more subtle properties. To begin with, can we recover
the funds held by the contract? The strategy to try is obvious: all we
have to do is wait for the deadline to pass. So <code class="docutils literal notranslate"><span class="pre">prop_FinishAuction</span></code>
is very simple:</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">finishAuction</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">DL</span><span class="w"> </span><span class="kt">AuctionModel</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">finishAuction</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">anyActions_</span><span class="w"></span>
<span class="w">    </span><span class="n">finishingStrategy</span><span class="w"></span>
<span class="w">    </span><span class="n">assertModel</span><span class="w"> </span><span class="s">&quot;Locked funds are not zero&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">symIsZero</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">lockedValue</span><span class="p">)</span><span class="w"></span>

<span class="nf">finishingStrategy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">DL</span><span class="w"> </span><span class="kt">AuctionModel</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">finishingStrategy</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">slot</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewModelState</span><span class="w"> </span><span class="n">currentSlot</span><span class="w"></span>
<span class="w">    </span><span class="n">end</span><span class="w">  </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">endSlot</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="w"> </span><span class="p">(</span><span class="n">slot</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">waitUntilDL</span><span class="w"> </span><span class="n">end</span><span class="w"></span>

<span class="nf">prop_FinishAuction</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Property</span><span class="w"></span>
<span class="nf">prop_FinishAuction</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forAllDL</span><span class="w"> </span><span class="n">finishAuction</span><span class="w"> </span><span class="n">prop_Auction</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>This property passes too:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_FinishAuction
+++ OK, passed 100 tests.

Actions (3152 in total):
84.77% Bid
12.25% WaitUntil
 2.98% Init
</pre></div>
</div>
</div></blockquote>
<p>Now, to supply a <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:NoLockedFundsProof" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">NoLockedFundsProof</span></code></a> we need a general strategy for
fund recovery, and a wallet-specific one. Since all we have to do is
wait, we can use the <em>same</em> strategy as both.</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">noLockProof</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">NoLockedFundsProof</span><span class="w"> </span><span class="kt">AuctionModel</span><span class="w"></span>
<span class="nf">noLockProof</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">defaultNLFP</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">nlfpMainStrategy</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="n">finishingStrategy</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">nlfpWalletStrategy</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">finishingStrategy</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>Surprisingly, <em>these tests fail</em>!</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_NoLockedFunds
*** Failed! Assertion failed (after 2 tests and 1 shrink):
DLScript
  [Do $ Init,
   Do $ Bid (Wallet 3) 2000000]

The ContractModel&#39;s Unilateral behaviour for Wallet 3 does not match the
actual behaviour for actions:
Actions
 [Var 0 := Init,
  Var 1 := Bid (Wallet 3) 2000000,
  Var 2 := Unilateral (Wallet 3),
  Var 3 := WaitUntil (Slot {getSlot = 101})]
Expected funds of W[1] to change by
  Value (Map [(363d...,Map [(&quot;token&quot;,-1)])])
but they changed by
  Value (Map [(,Map [(&quot;&quot;,-2000000)]),(363d...,Map [(&quot;token&quot;,-1)])])
a discrepancy of
  Value (Map [(,Map [(&quot;&quot;,-2000000)])])
Expected funds of W[3] to change by
  Value (Map [(363d...,Map [(&quot;token&quot;,1)])])
but they changed by
  Value (Map [(,Map [(&quot;&quot;,-2000000)])])
a discrepancy of
  Value (Map [(,Map [(&quot;&quot;,-2000000)]),(363d...,Map [(&quot;token&quot;,-1)])])
Test failed.
</pre></div>
</div>
</div></blockquote>
<p>This test just started the auction and submitted a bid from wallet 3,
then <em>stopped all the other wallets</em> (this is what <code class="docutils literal notranslate"><span class="pre">Unilateral</span>
<span class="pre">(Wallet</span> <span class="pre">3)</span></code> does), before waiting until the auction deadline.  This
resulted in a different distribution of funds from the one the model
predicts.  Looking at the last part of the message, we see that we
expected wallet 3 to get the token, <em>but it did not</em>; neither did it
get its bid back. Wallet 1 did lose the token, though, and in addition
lost the 2 Ada required to create the auction UTXO in the first place.</p>
<p>What is going on? The strategy worked in the general case, but failed
in the unilateral case, which tells us that <em>the buyer requires the
cooperation of the seller</em> in order to recover the auctioned
token. Why? Well, our description of the contract above was a little
misleading: the proceeds of the auction <em>cannot</em> be paid out
automatically just because the deadline passes; the Cardano blockchain
won’t do that. Instead, <em>someone must submit the payout
transaction</em>. In the case of this contract, it’s the seller: even
though there is no <em>endpoint call</em> at the deadline, the seller’s
off-chain code continues running throughout the auction, and when the
deadline comes it submits the payout transaction. So if the seller’s
contract is stopped, then no payout occurs.</p>
<p>This is not a <em>very</em> serious bug, because the <em>on-chain</em> code allows
anyone to submit the payout transaction, so the buyer could in
principle do so. However, the existing off-chain code does not provide
an endpoint for this, and so recovering the locked funds would require
writing a new version of the off-chain code (or rolling a suitable
transaction by hand).</p>
<blockquote>
<div></div></blockquote>
</section>
<section id="model-assertions-and-unexpected-expectations">
<span id="auctionassertion"></span><h3>Model assertions, and unexpected expectations.<a class="headerlink" href="#model-assertions-and-unexpected-expectations" title="Permalink to this heading"></a></h3>
<p>Looking back at the failed test again, the <em>expected</em> wallet contents
are actually a little <em>unexpected</em>:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Actions
 [Var 0 := Init,
  Var 1 := Bid (Wallet 3) 2000000,
  Var 2 := Unilateral (Wallet 3),
  Var 3 := WaitUntil (Slot {getSlot = 101})]
Expected funds of W[1] to change by
  Value (Map [(363d...,Map [(&quot;token&quot;,-1)])])
but they changed by
  Value (Map [(,Map [(&quot;&quot;,-2000000)]),(363d...,Map [(&quot;token&quot;,-1)])])
a discrepancy of
  Value (Map [(,Map [(&quot;&quot;,-2000000)])])
</pre></div>
</div>
</div></blockquote>
<p>Notice that, even though wallet 3 made a bid of 2 Ada, we <em>expected</em>
the seller to end up without the token, but <em>with no extra
money</em>. Wouldn’t we expect the seller to end up with 2 Ada?</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">prop_Auction</span></code> passed, then we know that in the absence of a
<code class="docutils literal notranslate"><span class="pre">Unilateral</span></code> then the model and the contract implementation agree on
fund transfers. But does the model actually predict that the seller
gets the winning bid? This can be a little hard to infer from the
state transitions themselves; we can check that each action appears to
do the right thing, but whether the end result is as expected is not
necessarily immediately obvious.</p>
<p>We can address this kind of problem by <em>adding assertions to the
model</em>. The model tracks the change in each wallet’s balance since the
beginning of the test, so we can add an assertion, at the point where
the auction ends, that checks that the seller loses the token and
gains the winning bid. We just a little code to <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">nextReactiveState</span></code></a>:</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">nextReactiveState</span><span class="w"> </span><span class="n">slot&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w">  </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">endSlot</span><span class="w"></span>
<span class="w">      </span><span class="n">p</span><span class="w">    </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">phase</span><span class="w"></span>
<span class="w">      </span><span class="n">when</span><span class="w"> </span><span class="p">(</span><span class="n">slot&#39;</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Bidding</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">        </span><span class="n">w</span><span class="w">   </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">winner</span><span class="w"></span>
<span class="w">        </span><span class="n">bid</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewContractState</span><span class="w"> </span><span class="n">currentBid</span><span class="w"></span>
<span class="w">        </span><span class="n">phase</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="kt">AuctionOver</span><span class="w"></span>
<span class="w">        </span><span class="n">deposit</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">toValue</span><span class="w"> </span><span class="kt">Ledger</span><span class="o">.</span><span class="n">minAdaTxOutEstimated</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">theToken</span><span class="w"></span>
<span class="w">        </span><span class="n">deposit</span><span class="w"> </span><span class="n">w1</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span><span class="w"> </span><span class="n">bid</span><span class="w"></span>
<span class="w">        </span><span class="c1">-- NEW!!!</span><span class="w"></span>
<span class="w">        </span><span class="n">w1change</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">viewModelState</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">balanceChange</span><span class="w"> </span><span class="n">w1</span><span class="w">  </span><span class="c1">-- since the start of the test</span><span class="w"></span>
<span class="w">        </span><span class="n">assertSpec</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;w1 final balance is wrong:</span><span class="se">\n</span><span class="s">  &quot;</span><span class="o">++</span><span class="n">show</span><span class="w"> </span><span class="n">w1change</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"></span>
<span class="w">          </span><span class="n">w1change</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">toSymValue</span><span class="w"> </span><span class="p">(</span><span class="n">inv</span><span class="w"> </span><span class="n">theToken</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span><span class="w"> </span><span class="n">bid</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">          </span><span class="n">w1change</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">mempty</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>If the boolean passed to <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:assertSpec" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">assertSpec</span></code></a> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, then the test
fails with the first argument in the error message.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>We do have to allow for the possibility that the auction never
started, which is why we include in the assertion the possibility
that wallet 1’s balance remains unchanged. Without this, the tests
fail.</p>
</div>
</div></blockquote>
<p>Now <code class="docutils literal notranslate"><span class="pre">prop_Auction</span></code> fails!</p>
<blockquote>
<div><blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_Auction
*** Failed! Falsified (after 27 tests and 24 shrinks):
Actions
 [Init,
  Bid (Wallet 3) 2000000,
  WaitUntil (Slot {getSlot = 100})]
assertSpec failed: w1 final balance is wrong:
  SymValue {symValMap = fromList [], actualValPart = Value (Map [(363d...,Map [(&quot;token&quot;,-1)])])}
</pre></div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The balance change is actually a <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Symbolics.html#t:SymValue" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">SymValue</span></code></a>, not a <a class="reference external" href="../../haddock/plutus-ledger/html/Ledger.html#t:Value" title="(in plutus-ledger v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Value</span></code></a>,
but as you can see it <em>contains</em> a <a class="reference external" href="../../haddock/plutus-ledger/html/Ledger.html#t:Value" title="(in plutus-ledger v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Value</span></code></a>, which is all we care
about right now.</p>
</div>
</div></blockquote>
<p>Even in this simple case, the seller does not receive the right
amount: wallet 1 lost the token, but received no payment!</p>
<p>The reason has to do with the minimum Ada in each UTXO. When the
auction UTXO is created, the seller has to put in 2 Ada along with the
token. When the auction ends, one might expect that 2 Ada to be
returned to the seller. But it can’t be: <em>it is needed to create the
UTXO that delivers the token to the buyer</em>! Thus the seller receives 2
Ada (from the buyer’s bid) in this example, but this only makes up for
the 2 Ada deposited in the auction UTXO, and the seller ends up giving
away the token for nothing.</p>
<p>This is quite surprising behaviour, and arguably, the contract should
require that the buyer pay the seller 2 Ada <em>plus</em> the winning bid, so that
the stated bid is equal to the seller’s net receipts.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Model assertions can be tested without running the emulator, by
using <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:propSanityCheckAssertions" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">propSanityCheckAssertions</span></code></a> instead of
<a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:propRunActions_" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">propRunActions_</span></code></a>. This is very much faster, and enables very
thorough testing of the model. Since other tests check that the
implementation correponds to the model, then this still gives us
valuable information about the implementation.</p>
</div>
</div></blockquote>
</section>
<section id="crashing-the-auction">
<h3>Crashing the auction<a class="headerlink" href="#crashing-the-auction" title="Permalink to this heading"></a></h3>
<p>Is the auction crash tolerant? To find out, we just declare that
<code class="docutils literal notranslate"><span class="pre">Bid</span></code> actions are available when the corresponding buyer contract is
running, define the restart arguments, and the crash-tolerant property
(which just replicates the definition of <code class="docutils literal notranslate"><span class="pre">prop_Auction</span></code> with a
different type).</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">CrashTolerance</span><span class="w"> </span><span class="kt">AuctionModel</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">available</span><span class="w"> </span><span class="p">(</span><span class="kt">Bid</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="n">alive</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Key</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">BuyerH</span><span class="w">  </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="n">elem</span><span class="p">`</span><span class="w"> </span><span class="n">alive</span><span class="w"></span>
<span class="w">  </span><span class="n">available</span><span class="w"> </span><span class="kt">Init</span><span class="w">      </span><span class="n">alive</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>

<span class="w">  </span><span class="n">restartArguments</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">BuyerH</span><span class="p">{}</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">  </span><span class="n">restartArguments</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">SellerH</span><span class="p">{}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>

<span class="nf">prop_CrashTolerance</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Actions</span><span class="w"> </span><span class="p">(</span><span class="kt">WithCrashTolerance</span><span class="w"> </span><span class="kt">AuctionModel</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Property</span><span class="w"></span>
<span class="nf">prop_CrashTolerance</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">propRunActionsWithOptions</span><span class="w"> </span><span class="p">(</span><span class="n">set</span><span class="w"> </span><span class="n">minLogLevel</span><span class="w"> </span><span class="kt">Critical</span><span class="w"> </span><span class="n">options</span><span class="p">)</span><span class="w"> </span><span class="n">defaultCoverageOptions</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">pure</span><span class="w"> </span><span class="kt">True</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>Perhaps unsurprisingly, this property fails:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_CrashTolerance
*** Failed! Assertion failed (after 17 tests and 11 shrinks):
Actions
 [Init,
  Crash SellerH,
  WaitUntil (Slot {getSlot = 100})]
Expected funds of W[1] to change by
  Value (Map [])
but they changed by
  Value (Map [(,Map [(&quot;&quot;,-2000000)]),(363d3944282b3d16b239235a112c0f6e2f1195de5067f61c0dfc0f5f,Map [(&quot;token&quot;,-1)])])
a discrepancy of
  Value (Map [(,Map [(&quot;&quot;,-2000000)]),(363d3944282b3d16b239235a112c0f6e2f1195de5067f61c0dfc0f5f,Map [(&quot;token&quot;,-1)])])
Test failed.
</pre></div>
</div>
</div></blockquote>
<p>We already know that the auction payout is initiated by the seller
contract, so if that contract is not running, then no payout takes
place. (Although there are no bids in this counterexample, a payout is
still needed–to return the token to the seller). That is why this test fails.</p>
<p>But this is actually not the only way the property can fail. The other
failure (which generates some rather long contract logs) looks like
this:</p>
<blockquote>
<div><div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt; quickCheck prop_CrashTolerance
*** Failed! Assertion failed (after 13 tests and 9 shrinks):
Actions
 [Init,
  Crash SellerH,
  Restart SellerH]
Contract instance log failed to validate:
... half a megabyte of output ...
Slot 6: 00000000-0000-4000-8000-000000000004 {Wallet W[1]}:
          Contract instance stopped with error: StateMachineContractError (SMCContractError (WalletContractError (InsufficientFunds &quot;Total: Value (Map [(,Map [(\&quot;\&quot;,9999999997645750)])]) expected: Value (Map [(363d3944282b3d16b239235a112c0f6e2f1195de5067f61c0dfc0f5f,Map [(\&quot;token\&quot;,1)])])&quot;)))
Test failed.
</pre></div>
</div>
</div></blockquote>
<p>In other words, after a crash, <em>the seller contract fails to
restart</em>. This is simply because the seller tries to put the token up
for auction when it starts, and <em>wallet 1 no longer holds the
token</em>–it is already in an auction UTXO on the blockchain. So the
seller contract fails with an <a class="reference external" href="../../haddock/plutus-contract/html/Wallet-Emulator-Error.html#t:WalletAPIError" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">InsufficientFunds</span></code></a> error. To continue
the auction, we would really need another endpoint to resume the
seller, which the contract does not provide, or a parameter to the
seller contract which specifies whether to start or continue an
auction.</p>
</section>
<section id="coverage-of-the-auction-contract">
<h3>Coverage of the Auction contract<a class="headerlink" href="#coverage-of-the-auction-contract" title="Permalink to this heading"></a></h3>
<p>We can generate a coverage report for the <code class="docutils literal notranslate"><span class="pre">Auction</span></code> contract just as
we did for the <code class="docutils literal notranslate"><span class="pre">Escrow</span></code> one. The interesting part of the report is:</p>
<blockquote>
<div><pre>
   124    <span style=background-color:lightgray;color:gray >auctionTransition</span>
   125    <span style=background-color:lightgray;color:gray >    :: AuctionParams</span>
   126    <span style=background-color:lightgray;color:gray >    -&gt; State AuctionState</span>
   127    <span style=background-color:lightgray;color:gray >    -&gt; AuctionInput</span>
   128    <span style=background-color:lightgray;color:gray >    -&gt; Maybe (TxConstraints Void Void, State AuctionState)</span>
   129    <span style=background-color:white;color:black >auctionTransition AuctionParams{apOwner, apAsset, apEndTime} State{stateData=oldStateData, stateValue=oldStateValue} input =</span><span style=background-color:lightgray;color:gray ></span>
   130    <span style=background-color:white;color:black >    case (oldStateData, input) of</span><span style=background-color:lightgray;color:gray ></span>
   131    <span style=background-color:white;color:black ></span><span style=background-color:lightgray;color:gray ></span>
   132    <span style=background-color:white;color:black >        (Ongoing HighestBid{highestBid, highestBidder}, Bid{newBid, newBidder}) | </span><span style=background-color:lightgreen;color:black >newBid &gt; highestBid </span><span style=background-color:white;color:black >-&gt; -- if the new bid is higher,</span><span style=background-color:lightgray;color:gray ></span>
   133    <span style=background-color:white;color:black >            let constraints = if highestBid == 0 then mempty else</span><span style=background-color:lightgray;color:gray ></span>
   134    <span style=background-color:white;color:black >                    Constraints.mustPayToPubKey highestBidder (Ada.toValue highestBid) -- we pay back the previous highest bid</span><span style=background-color:lightgray;color:gray ></span>
   135    <span style=background-color:white;color:black >                    &lt;&gt; Constraints.mustValidateIn (Interval.to $ apEndTime - 1) -- but only if we haven&#39;t gone past &#39;apEndTime&#39;</span><span style=background-color:lightgray;color:gray ></span>
   136    <span style=background-color:white;color:black >                newState =</span><span style=background-color:lightgray;color:gray ></span>
   137    <span style=background-color:white;color:black >                    State</span><span style=background-color:lightgray;color:gray ></span>
   138    <span style=background-color:white;color:black >                        { stateData = Ongoing HighestBid{highestBid = newBid, highestBidder = newBidder}</span><span style=background-color:lightgray;color:gray ></span>
   139    <span style=background-color:white;color:black >                        , stateValue = Value.noAdaValue oldStateValue</span><span style=background-color:lightgray;color:gray ></span>
   140    <span style=background-color:white;color:black >                                    &lt;&gt; Ada.toValue (Ada.fromValue oldStateValue - highestBid)</span><span style=background-color:lightgray;color:gray ></span>
   141    <span style=background-color:white;color:black >                                    &lt;&gt; Ada.toValue newBid -- and lock the new bid in the script output</span><span style=background-color:lightgray;color:gray ></span>
   142    <span style=background-color:white;color:black >                        }</span><span style=background-color:lightgray;color:gray ></span>
   143    <span style=background-color:white;color:black >            in Just (constraints, newState)</span><span style=background-color:lightgray;color:gray ></span>
   144    <span style=background-color:white;color:black ></span><span style=background-color:lightgray;color:gray ></span>
   145    <span style=background-color:white;color:black >        (Ongoing h@HighestBid{highestBidder, highestBid}, Payout) -&gt;</span><span style=background-color:lightgray;color:gray ></span>
   146    <span style=background-color:white;color:black >            let constraints =</span><span style=background-color:lightgray;color:gray ></span>
   147    <span style=background-color:white;color:black >                    Constraints.mustValidateIn (Interval.from apEndTime) -- When the auction has ended,</span><span style=background-color:lightgray;color:gray ></span>
   148    <span style=background-color:white;color:black >                    &lt;&gt; Constraints.mustPayToPubKey apOwner (Ada.toValue highestBid) -- the owner receives the payment</span><span style=background-color:lightgray;color:gray ></span>
   149    <span style=background-color:white;color:black >                    &lt;&gt; Constraints.mustPayToPubKey highestBidder apAsset -- and the highest bidder the asset</span><span style=background-color:lightgray;color:gray ></span>
   150    <span style=background-color:white;color:black >                newState = State { stateData = Finished h, stateValue = mempty }</span><span style=background-color:lightgray;color:gray ></span>
   151    <span style=background-color:white;color:black >            in Just (constraints, newState)</span><span style=background-color:lightgray;color:gray ></span>
   152    <span style=background-color:white;color:black ></span><span style=background-color:lightgray;color:gray ></span>
   153    <span style=background-color:white;color:black >        -- Any other combination of &#39;AuctionState&#39; and &#39;AuctionInput&#39; is disallowed.</span><span style=background-color:lightgray;color:gray ></span>
   154    <span style=background-color:white;color:black >        -- This rules out new bids that don&#39;t go over the current highest bid.</span><span style=background-color:lightgray;color:gray ></span>
   155    <span style=background-color:white;color:black >        _ -&gt; </span><span style=background-color:black;color:orangered >Nothing</span><span style=background-color:lightgray;color:gray ></span>
   156    <span style=background-color:lightgray;color:gray ></span>
   157    <span style=background-color:lightgray;color:gray ></span>
   158    <span style=background-color:lightgray;color:gray >{-# INLINABLE auctionStateMachine #-}</span>
   159    <span style=background-color:lightgray;color:gray >auctionStateMachine :: (ThreadToken, AuctionParams) -&gt; AuctionMachine</span>
   160    <span style=background-color:white;color:black >auctionStateMachine (threadToken, auctionParams) =</span><span style=background-color:lightgray;color:gray ></span>
   161    <span style=background-color:white;color:black >    SM.mkStateMachine (Just threadToken) (auctionTransition auctionParams) isFinal</span><span style=background-color:lightgray;color:gray ></span>
   162    <span style=background-color:white;color:black >  where</span><span style=background-color:lightgray;color:gray ></span>
   163    <span style=background-color:white;color:black >    isFinal Finished{} = True</span><span style=background-color:lightgray;color:gray ></span>
   164    <span style=background-color:white;color:black >    isFinal _          = False</span><span style=background-color:lightgray;color:gray ></span>
   165    <span style=background-color:lightgray;color:gray ></span>
   166    <span style=background-color:lightgray;color:gray >{-# INLINABLE mkValidator #-}</span>
   167    <span style=background-color:lightgray;color:gray >mkValidator :: (ThreadToken, AuctionParams) -&gt; Scripts.ValidatorType AuctionMachine</span>
   168    <span style=background-color:white;color:black >mkValidator = SM.mkValidator . auctionStateMachine</span><span style=background-color:lightgray;color:gray ></span>
</pre>
</div></blockquote>
<p>The auction is defined as a Plutus state machine, which just repeats
an <code class="docutils literal notranslate"><span class="pre">auctionTransition</span></code> over and over again. We can see that the
state machine itself, and most of the transition code, is
covered. However, the <code class="docutils literal notranslate"><span class="pre">Bid</span></code> transition has only been tested in the
case where new bid is higher than the old one. Indeed, the tests are
designed to respect that precondition. Moroever, the last clause in
the <code class="docutils literal notranslate"><span class="pre">case</span></code> expression has not been tested at all–but this is quite
OK, because it returns <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> which the state machine library
interprets to mean “reject the transaction”. So the uncovered code
<em>could</em> only be covered by failing transactions, which the off-chain
code is designed not to submit.</p>
</section>
<section id="id8">
<h3>Exercises<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h3>
<p>The code discussed here is in <code class="docutils literal notranslate"><span class="pre">Spec.Auction</span></code>.</p>
<ol class="arabic simple">
<li><p>Test the failing properties (<code class="docutils literal notranslate"><span class="pre">prop_NoLockedFunds</span></code> and
<code class="docutils literal notranslate"><span class="pre">prop_CrashTolerance</span></code>) and observe the failures.</p></li>
<li><p>Add the model assertion discussed in <a class="reference internal" href="#auctionassertion"><span class="std std-ref">Model assertions, and unexpected expectations.</span></a> to the
code, and <code class="docutils literal notranslate"><span class="pre">quickCheck</span> <span class="pre">prop_SanityCheckAssertions</span></code> to verify that
it fails. Change the assertion to say that the seller receives 2
Ada <em>less</em> than the bid, and verify that it now passes.</p></li>
</ol>
</section>
</section>
<section id="becoming-level-1-certification-ready">
<h2>Becoming Level 1 Certification Ready<a class="headerlink" href="#becoming-level-1-certification-ready" title="Permalink to this heading"></a></h2>
<p>Level 1 certification of plutus smart contracts relies on the machinery
we have discussed in this tutorial. First things first we are going to
have a look at the <a class="reference external" href="../../haddock/plutus-contract-certification/html/Plutus-Contract-Test-Certification.html" title="(in plutus-contract-certification v1.1.0.0)"><code class="xref hs hs-hsmod docutils literal notranslate"><span class="pre">Plutus.Contract.Test.Certification</span></code></a> module.</p>
<p>This module defines a type <a class="reference external" href="../../haddock/plutus-contract-certification/html/Plutus-Contract-Test-Certification.html#t:Certification" title="(in plutus-contract-certification v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Certification</span></code></a> paramtereized over a type
<code class="docutils literal notranslate"><span class="pre">m</span></code> that should be a <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#t:ContractModel" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">ContractModel</span></code></a>. This is a record type that has
fields for:</p>
<ol class="arabic simple">
<li><p>a <a class="reference external" href="../../haddock/plutus-tx/html/PlutusTx-Coverage.html#t:CoverageIndex" title="(in plutus-tx v1.0.0.0)"><code class="docutils literal notranslate"><span class="pre">CoverageIndex</span></code></a>,</p></li>
<li><p>two different types of <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-Interface.html#v:NoLockedFundsProof" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">NoLockedFundsProof</span></code></a>
(a standard full proof and a light proof that does not require you to provide
a per-wallet unilateral strategy),</p></li>
<li><p>the ability to provide a specialized error whitelist,</p></li>
<li><p>a way to specify that we have an instance of <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-ContractModel-CrashTolerance.html#t:CrashTolerance" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">CrashTolerance</span></code></a> for <code class="docutils literal notranslate"><span class="pre">m</span></code>,</p></li>
<li><p>unit tests in the form of a function from a <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test-Coverage.html#t:CoverageRef" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">CoverageRef</span></code></a> to a <a class="reference external" href="https://hackage.haskell.org/package/tasty-1.4.2.3/docs/Test-Tasty.html#t:TestTree"><code class="docutils literal notranslate"><span class="pre">TestTree</span></code></a>
(see <a class="reference external" href="../../haddock/plutus-contract/html/Plutus-Contract-Test.html#v:checkPredicateCoverage" title="(in plutus-contract v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">checkPredicateCoverage</span></code></a>
for how to construct one of these), and</p></li>
<li><p>named dynamic logic unit tests.</p></li>
</ol>
<p>Fortunately, understanding what we need to do to get certification-ready
at this stage is simple. We just need to build a <a class="reference external" href="../../haddock/plutus-contract-certification/html/Plutus-Contract-Test-Certification.html#t:Certification" title="(in plutus-contract-certification v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">Certification</span></code></a> object.
For example of how to do this, check out <code class="docutils literal notranslate"><span class="pre">Spec.GameStateMachine.certification</span></code>
and <code class="docutils literal notranslate"><span class="pre">Spec.Uniswap.certification</span></code>.</p>
<p>You can run level 1 certification locally using the
<a class="reference external" href="../../haddock/plutus-contract-certification/html/Plutus-Contract-Test-Certification-Run.html#v:certify" title="(in plutus-contract-certification v1.1.0.0)"><code class="docutils literal notranslate"><span class="pre">certify</span></code></a> function - but at
this stage you may find it difficult to read the output of this function.
Don’t worry! A certification dashboard is on the way!</p>
<section id="id9">
<h3>Exercises<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h3>
<ol class="arabic simple">
<li><p>Build a certification object for the <code class="docutils literal notranslate"><span class="pre">Auction</span></code> and <code class="docutils literal notranslate"><span class="pre">Escrow</span></code> contracts.</p></li>
</ol>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="contract-testing.html" class="btn btn-neutral float-left" title="Property-based testing of Plutus contracts" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../howtos/index.html" class="btn btn-neutral float-right" title="How-to guides" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1980, IOHK.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>